(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["Scroller"] = factory(require("React"));
	else
		root["Scroller"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/infinitegridscroller.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/detect-browser/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/detect-browser/es/index.js ***!
  \*************************************************/
/*! exports provided: BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, detect, browserName, parseUserAgent, detectOS, getNodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BrowserInfo\", function() { return BrowserInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeInfo\", function() { return NodeInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SearchBotDeviceInfo\", function() { return SearchBotDeviceInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BotInfo\", function() { return BotInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReactNativeInfo\", function() { return ReactNativeInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detect\", function() { return detect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"browserName\", function() { return browserName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseUserAgent\", function() { return parseUserAgent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectOS\", function() { return detectOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNodeVersion\", function() { return getNodeVersion; });\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar BrowserInfo = /** @class */ (function () {\n    function BrowserInfo(name, version, os) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.type = 'browser';\n    }\n    return BrowserInfo;\n}());\n\nvar NodeInfo = /** @class */ (function () {\n    function NodeInfo(version) {\n        this.version = version;\n        this.type = 'node';\n        this.name = 'node';\n        this.os = process.platform;\n    }\n    return NodeInfo;\n}());\n\nvar SearchBotDeviceInfo = /** @class */ (function () {\n    function SearchBotDeviceInfo(name, version, os, bot) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.bot = bot;\n        this.type = 'bot-device';\n    }\n    return SearchBotDeviceInfo;\n}());\n\nvar BotInfo = /** @class */ (function () {\n    function BotInfo() {\n        this.type = 'bot';\n        this.bot = true; // NOTE: deprecated test name instead\n        this.name = 'bot';\n        this.version = null;\n        this.os = null;\n    }\n    return BotInfo;\n}());\n\nvar ReactNativeInfo = /** @class */ (function () {\n    function ReactNativeInfo() {\n        this.type = 'react-native';\n        this.name = 'react-native';\n        this.version = null;\n        this.os = null;\n    }\n    return ReactNativeInfo;\n}());\n\n// tslint:disable-next-line:max-line-length\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n    ['aol', /AOLShield\\/([0-9\\._]+)/],\n    ['edge', /Edge\\/([0-9\\._]+)/],\n    ['edge-ios', /EdgiOS\\/([0-9\\._]+)/],\n    ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/],\n    ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/],\n    ['samsung', /SamsungBrowser\\/([0-9\\.]+)/],\n    ['silk', /\\bSilk\\/([0-9._-]+)\\b/],\n    ['miui', /MiuiBrowser\\/([0-9\\.]+)$/],\n    ['beaker', /BeakerBrowser\\/([0-9\\.]+)/],\n    ['edge-chromium', /Edg\\/([0-9\\.]+)/],\n    [\n        'chromium-webview',\n        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/,\n    ],\n    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n    ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n    ['fxios', /FxiOS\\/([0-9\\.]+)/],\n    ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/],\n    ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n    ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n    ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n    ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n    ['ie', /MSIE\\s(7\\.0)/],\n    ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n    ['android', /Android\\s([0-9\\.]+)/],\n    ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n    ['safari', /Version\\/([0-9\\._]+).*Safari/],\n    ['facebook', /FBAV\\/([0-9\\.]+)/],\n    ['instagram', /Instagram\\s([0-9\\.]+)/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n    ['searchbot', SEARCHBOX_UA_REGEX],\n];\nvar operatingSystemRules = [\n    ['iOS', /iP(hone|od|ad)/],\n    ['Android OS', /Android/],\n    ['BlackBerry OS', /BlackBerry|BB10/],\n    ['Windows Mobile', /IEMobile/],\n    ['Amazon OS', /Kindle/],\n    ['Windows 3.11', /Win16/],\n    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],\n    ['Windows 98', /(Windows 98)|(Win98)/],\n    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],\n    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],\n    ['Windows Server 2003', /(Windows NT 5.2)/],\n    ['Windows Vista', /(Windows NT 6.0)/],\n    ['Windows 7', /(Windows NT 6.1)/],\n    ['Windows 8', /(Windows NT 6.2)/],\n    ['Windows 8.1', /(Windows NT 6.3)/],\n    ['Windows 10', /(Windows NT 10.0)/],\n    ['Windows ME', /Windows ME/],\n    ['Open BSD', /OpenBSD/],\n    ['Sun OS', /SunOS/],\n    ['Chrome OS', /CrOS/],\n    ['Linux', /(Linux)|(X11)/],\n    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],\n    ['QNX', /QNX/],\n    ['BeOS', /BeOS/],\n    ['OS/2', /OS\\/2/],\n];\nfunction detect(userAgent) {\n    if (!!userAgent) {\n        return parseUserAgent(userAgent);\n    }\n    if (typeof document === 'undefined' &&\n        typeof navigator !== 'undefined' &&\n        navigator.product === 'ReactNative') {\n        return new ReactNativeInfo();\n    }\n    if (typeof navigator !== 'undefined') {\n        return parseUserAgent(navigator.userAgent);\n    }\n    return getNodeVersion();\n}\nfunction matchUserAgent(ua) {\n    // opted for using reduce here rather than Array#first with a regex.test call\n    // this is primarily because using the reduce we only perform the regex\n    // execution once rather than once for the test and for the exec again below\n    // probably something that needs to be benchmarked though\n    return (ua !== '' &&\n        userAgentRules.reduce(function (matched, _a) {\n            var browser = _a[0], regex = _a[1];\n            if (matched) {\n                return matched;\n            }\n            var uaMatch = regex.exec(ua);\n            return !!uaMatch && [browser, uaMatch];\n        }, false));\n}\nfunction browserName(ua) {\n    var data = matchUserAgent(ua);\n    return data ? data[0] : null;\n}\nfunction parseUserAgent(ua) {\n    var matchedRule = matchUserAgent(ua);\n    if (!matchedRule) {\n        return null;\n    }\n    var name = matchedRule[0], match = matchedRule[1];\n    if (name === 'searchbot') {\n        return new BotInfo();\n    }\n    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);\n    if (versionParts) {\n        if (versionParts.length < REQUIRED_VERSION_PARTS) {\n            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));\n        }\n    }\n    else {\n        versionParts = [];\n    }\n    var version = versionParts.join('.');\n    var os = detectOS(ua);\n    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n    if (searchBotMatch && searchBotMatch[1]) {\n        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);\n    }\n    return new BrowserInfo(name, version, os);\n}\nfunction detectOS(ua) {\n    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n        var match = regex.exec(ua);\n        if (match) {\n            return os;\n        }\n    }\n    return null;\n}\nfunction getNodeVersion() {\n    var isNode = typeof process !== 'undefined' && process.version;\n    return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nfunction createVersionParts(count) {\n    var output = [];\n    for (var ii = 0; ii < count; ii++) {\n        output.push('0');\n    }\n    return output;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9kZXRlY3QtYnJvd3Nlci9lcy9pbmRleC5qcz83YjQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBc0IsU0FBSSxJQUFJLFNBQUk7QUFDbEMsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbnZhciBCcm93c2VySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uLCBvcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm9zID0gb3M7XG4gICAgICAgIHRoaXMudHlwZSA9ICdicm93c2VyJztcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJJbmZvO1xufSgpKTtcbmV4cG9ydCB7IEJyb3dzZXJJbmZvIH07XG52YXIgTm9kZUluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUluZm8odmVyc2lvbikge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdub2RlJztcbiAgICAgICAgdGhpcy5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgfVxuICAgIHJldHVybiBOb2RlSW5mbztcbn0oKSk7XG5leHBvcnQgeyBOb2RlSW5mbyB9O1xudmFyIFNlYXJjaEJvdERldmljZUluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoQm90RGV2aWNlSW5mbyhuYW1lLCB2ZXJzaW9uLCBvcywgYm90KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3MgPSBvcztcbiAgICAgICAgdGhpcy5ib3QgPSBib3Q7XG4gICAgICAgIHRoaXMudHlwZSA9ICdib3QtZGV2aWNlJztcbiAgICB9XG4gICAgcmV0dXJuIFNlYXJjaEJvdERldmljZUluZm87XG59KCkpO1xuZXhwb3J0IHsgU2VhcmNoQm90RGV2aWNlSW5mbyB9O1xudmFyIEJvdEluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm90SW5mbygpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2JvdCc7XG4gICAgICAgIHRoaXMuYm90ID0gdHJ1ZTsgLy8gTk9URTogZGVwcmVjYXRlZCB0ZXN0IG5hbWUgaW5zdGVhZFxuICAgICAgICB0aGlzLm5hbWUgPSAnYm90JztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCb3RJbmZvO1xufSgpKTtcbmV4cG9ydCB7IEJvdEluZm8gfTtcbnZhciBSZWFjdE5hdGl2ZUluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVhY3ROYXRpdmVJbmZvKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVhY3QtbmF0aXZlJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3JlYWN0LW5hdGl2ZSc7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3ROYXRpdmVJbmZvO1xufSgpKTtcbmV4cG9ydCB7IFJlYWN0TmF0aXZlSW5mbyB9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxudmFyIFNFQVJDSEJPWF9VQV9SRUdFWCA9IC9hbGV4YXxib3R8Y3Jhd2woZXJ8aW5nKXxmYWNlYm9va2V4dGVybmFsaGl0fGZlZWRidXJuZXJ8Z29vZ2xlIHdlYiBwcmV2aWV3fG5hZ2lvc3xwb3N0cmFua3xwaW5nZG9tfHNsdXJwfHNwaWRlcnx5YWhvbyF8eWFuZGV4LztcbnZhciBTRUFSQ0hCT1RfT1NfUkVHRVggPSAvKG51aGt8R29vZ2xlYm90fFlhbW15Ym90fE9wZW5ib3R8U2x1cnB8TVNOQm90fEFza1xcIEplZXZlc1xcL1Rlb21hfGlhX2FyY2hpdmVyKS87XG52YXIgUkVRVUlSRURfVkVSU0lPTl9QQVJUUyA9IDM7XG52YXIgdXNlckFnZW50UnVsZXMgPSBbXG4gICAgWydhb2wnLCAvQU9MU2hpZWxkXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydlZGdlJywgL0VkZ2VcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UtaW9zJywgL0VkZ2lPU1xcLyhbMC05XFwuX10rKS9dLFxuICAgIFsneWFuZGV4YnJvd3NlcicsIC9ZYUJyb3dzZXJcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2tha2FvdGFsaycsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnc2Ftc3VuZycsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydzaWxrJywgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLFxuICAgIFsnbWl1aScsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLFxuICAgIFsnYmVha2VyJywgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnZWRnZS1jaHJvbWl1bScsIC9FZGdcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbl07XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0KHVzZXJBZ2VudCkge1xuICAgIGlmICghIXVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vZGVWZXJzaW9uKCk7XG59XG5mdW5jdGlvbiBtYXRjaFVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgcmV0dXJuICh1YSAhPT0gJycgJiZcbiAgICAgICAgdXNlckFnZW50UnVsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVkLCBfYSkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICAgICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gICAgICAgIH0sIGZhbHNlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnJvd3Nlck5hbWUodWEpIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoVXNlckFnZW50KHVhKTtcbiAgICByZXR1cm4gZGF0YSA/IGRhdGFbMF0gOiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXNlckFnZW50KHVhKSB7XG4gICAgdmFyIG1hdGNoZWRSdWxlID0gbWF0Y2hVc2VyQWdlbnQodWEpO1xuICAgIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFJ1bGVbMF0sIG1hdGNoID0gbWF0Y2hlZFJ1bGVbMV07XG4gICAgaWYgKG5hbWUgPT09ICdzZWFyY2hib3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm90SW5mbygpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvblBhcnRzID0gbWF0Y2hbMV0gJiYgbWF0Y2hbMV0uc3BsaXQoL1suX10vKS5zbGljZSgwLCAzKTtcbiAgICBpZiAodmVyc2lvblBhcnRzKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uUGFydHMubGVuZ3RoIDwgUkVRVUlSRURfVkVSU0lPTl9QQVJUUykge1xuICAgICAgICAgICAgdmVyc2lvblBhcnRzID0gX19zcHJlYWRBcnJheXModmVyc2lvblBhcnRzLCBjcmVhdGVWZXJzaW9uUGFydHMoUkVRVUlSRURfVkVSU0lPTl9QQVJUUyAtIHZlcnNpb25QYXJ0cy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmVyc2lvblBhcnRzID0gW107XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmVyc2lvblBhcnRzLmpvaW4oJy4nKTtcbiAgICB2YXIgb3MgPSBkZXRlY3RPUyh1YSk7XG4gICAgdmFyIHNlYXJjaEJvdE1hdGNoID0gU0VBUkNIQk9UX09TX1JFR0VYLmV4ZWModWEpO1xuICAgIGlmIChzZWFyY2hCb3RNYXRjaCAmJiBzZWFyY2hCb3RNYXRjaFsxXSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaEJvdERldmljZUluZm8obmFtZSwgdmVyc2lvbiwgb3MsIHNlYXJjaEJvdE1hdGNoWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uLCBvcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVWZXJzaW9uKCkge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uO1xuICAgIHJldHVybiBpc05vZGUgPyBuZXcgTm9kZUluZm8ocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpKSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uUGFydHMoY291bnQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcwJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/detect-browser/es/index.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/ZjI4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/react-is-mounted-hook/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-is-mounted-hook/lib/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar use_is_mounted_1 = __importDefault(__webpack_require__(/*! ./use-is-mounted */ \"./node_modules/react-is-mounted-hook/lib/use-is-mounted.js\"));\nexports.default = use_is_mounted_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL2luZGV4LmpzPzVjOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHVDQUF1QyxtQkFBTyxDQUFDLG9GQUFrQjtBQUNqRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzLW1vdW50ZWQtaG9vay9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1c2VfaXNfbW91bnRlZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3VzZS1pcy1tb3VudGVkXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZV9pc19tb3VudGVkXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is-mounted-hook/lib/index.js\n");

/***/ }),

/***/ "./node_modules/react-is-mounted-hook/lib/use-is-mounted.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-is-mounted-hook/lib/use-is-mounted.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = __webpack_require__(/*! react */ \"react\");\nfunction useIsMounted() {\n    var ref = react_1.useRef(false);\n    react_1.useEffect(function () {\n        ref.current = true;\n        return function () {\n            ref.current = false;\n        };\n    }, []);\n    return function () { return ref.current; };\n}\nexports.default = useIsMounted;\n//# sourceMappingURL=use-is-mounted.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL3VzZS1pcy1tb3VudGVkLmpzPzkzMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMtbW91bnRlZC1ob29rL2xpYi91c2UtaXMtbW91bnRlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gICAgdmFyIHJlZiA9IHJlYWN0XzEudXNlUmVmKGZhbHNlKTtcbiAgICByZWFjdF8xLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuY3VycmVudDsgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUlzTW91bnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pcy1tb3VudGVkLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is-mounted-hook/lib/use-is-mounted.js\n");

/***/ }),

/***/ "./node_modules/requestidlecallback/index.js":
/*!***************************************************!*\
  !*** ./node_modules/requestidlecallback/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof global != undefined ?\n\t\t\tglobal :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxLQUFLLElBQTBDO0FBQy9DLEVBQUUsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3JCLEVBQUUsTUFBTSxFQUlOO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyx5REFBeUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixpREFBaUQ7QUFDbkk7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlcXVlc3RpZGxlY2FsbGJhY2svaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuaWRsZUNhbGxiYWNrU2hpbSA9IGZhY3RvcnkoKTtcblx0fVxufShmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBzY2hlZHVsZVN0YXJ0LCB0aHJvdHRsZURlbGF5LCBsYXp5dGltZXIsIGxhenlyYWY7XG5cdHZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/XG5cdFx0d2luZG93IDpcblx0XHR0eXBlb2YgZ2xvYmFsICE9IHVuZGVmaW5lZCA/XG5cdFx0XHRnbG9iYWwgOlxuXHRcdFx0dGhpcyB8fCB7fTtcblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG5cdHZhciBjYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG5cdHZhciB0YXNrcyA9IFtdO1xuXHR2YXIgcnVuQXR0ZW1wdHMgPSAwO1xuXHR2YXIgaXNSdW5uaW5nID0gZmFsc2U7XG5cdHZhciByZW1haW5pbmdUaW1lID0gNztcblx0dmFyIG1pblRocm90dGxlID0gMzU7XG5cdHZhciB0aHJvdHRsZSA9IDEyNTtcblx0dmFyIGluZGV4ID0gMDtcblx0dmFyIHRhc2tTdGFydCA9IDA7XG5cdHZhciB0YXNrbGVuZ3RoID0gMDtcblx0dmFyIElkbGVEZWFkbGluZSA9IHtcblx0XHRnZXQgZGlkVGltZW91dCgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dGltZVJlbWFpbmluZzogZnVuY3Rpb24oKXtcblx0XHRcdHZhciB0aW1lUmVtYWluaW5nID0gcmVtYWluaW5nVGltZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nIDwgMCA/IDAgOiB0aW1lUmVtYWluaW5nO1xuXHRcdH0sXG5cdH07XG5cdHZhciBzZXRJbmFjdGl2ZSA9IGRlYm91bmNlKGZ1bmN0aW9uKCl7XG5cdFx0cmVtYWluaW5nVGltZSA9IDIyO1xuXHRcdHRocm90dGxlID0gNjY7XG5cdFx0bWluVGhyb3R0bGUgPSAwO1xuXHR9KTtcblxuXHRmdW5jdGlvbiBkZWJvdW5jZShmbil7XG5cdFx0dmFyIGlkLCB0aW1lc3RhbXA7XG5cdFx0dmFyIHdhaXQgPSA5OTtcblx0XHR2YXIgY2hlY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGxhc3QgPSAoRGF0ZS5ub3coKSkgLSB0aW1lc3RhbXA7XG5cblx0XHRcdGlmIChsYXN0IDwgd2FpdCkge1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQgLSBsYXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlkID0gbnVsbDtcblx0XHRcdFx0Zm4oKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0dGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblx0XHRcdGlmKCFpZCl7XG5cdFx0XHRcdGlkID0gc2V0VGltZW91dChjaGVjaywgd2FpdCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFib3J0UnVubmluZygpe1xuXHRcdGlmKGlzUnVubmluZyl7XG5cdFx0XHRpZihsYXp5cmFmKXtcblx0XHRcdFx0Y2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxhenlyYWYpO1xuXHRcdFx0fVxuXHRcdFx0aWYobGF6eXRpbWVyKXtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGxhenl0aW1lcik7XG5cdFx0XHR9XG5cdFx0XHRpc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvbklucHV0b3JNdXRhdGlvbigpe1xuXHRcdGlmKHRocm90dGxlICE9IDEyNSl7XG5cdFx0XHRyZW1haW5pbmdUaW1lID0gNztcblx0XHRcdHRocm90dGxlID0gMTI1O1xuXHRcdFx0bWluVGhyb3R0bGUgPSAzNTtcblxuXHRcdFx0aWYoaXNSdW5uaW5nKSB7XG5cdFx0XHRcdGFib3J0UnVubmluZygpO1xuXHRcdFx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2V0SW5hY3RpdmUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlQWZ0ZXJSYWYoKSB7XG5cdFx0bGF6eXJhZiA9IG51bGw7XG5cdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChydW5UYXNrcywgMCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZVJhZigpe1xuXHRcdGxhenl0aW1lciA9IG51bGw7XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlQWZ0ZXJSYWYpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVMYXp5KCl7XG5cblx0XHRpZihpc1J1bm5pbmcpe3JldHVybjt9XG5cdFx0dGhyb3R0bGVEZWxheSA9IHRocm90dGxlIC0gKERhdGUubm93KCkgLSB0YXNrU3RhcnQpO1xuXG5cdFx0c2NoZWR1bGVTdGFydCA9IERhdGUubm93KCk7XG5cblx0XHRpc1J1bm5pbmcgPSB0cnVlO1xuXG5cdFx0aWYobWluVGhyb3R0bGUgJiYgdGhyb3R0bGVEZWxheSA8IG1pblRocm90dGxlKXtcblx0XHRcdHRocm90dGxlRGVsYXkgPSBtaW5UaHJvdHRsZTtcblx0XHR9XG5cblx0XHRpZih0aHJvdHRsZURlbGF5ID4gOSl7XG5cdFx0XHRsYXp5dGltZXIgPSBzZXRUaW1lb3V0KHNjaGVkdWxlUmFmLCB0aHJvdHRsZURlbGF5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3R0bGVEZWxheSA9IDA7XG5cdFx0XHRzY2hlZHVsZVJhZigpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJ1blRhc2tzKCl7XG5cdFx0dmFyIHRhc2ssIGksIGxlbjtcblx0XHR2YXIgdGltZVRocmVzaG9sZCA9IHJlbWFpbmluZ1RpbWUgPiA5ID9cblx0XHRcdDkgOlxuXHRcdFx0MVxuXHRcdDtcblxuXHRcdHRhc2tTdGFydCA9IERhdGUubm93KCk7XG5cdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXG5cdFx0aWYocnVuQXR0ZW1wdHMgPiAyIHx8IHRhc2tTdGFydCAtIHRocm90dGxlRGVsYXkgLSA1MCA8IHNjaGVkdWxlU3RhcnQpe1xuXHRcdFx0Zm9yKGkgPSAwLCBsZW4gPSB0YXNrcy5sZW5ndGg7IGkgPCBsZW4gJiYgSWRsZURlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVUaHJlc2hvbGQ7IGkrKyl7XG5cdFx0XHRcdHRhc2sgPSB0YXNrcy5zaGlmdCgpO1xuXHRcdFx0XHR0YXNrbGVuZ3RoKys7XG5cdFx0XHRcdGlmKHRhc2spe1xuXHRcdFx0XHRcdHRhc2soSWRsZURlYWRsaW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHRhc2tzLmxlbmd0aCl7XG5cdFx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cnVuQXR0ZW1wdHMgPSAwO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltKHRhc2spe1xuXHRcdGluZGV4Kys7XG5cdFx0dGFza3MucHVzaCh0YXNrKTtcblx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHRyZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltKGlkKXtcblx0XHR2YXIgaW5kZXggPSBpZCAtIDEgLSB0YXNrbGVuZ3RoO1xuXHRcdGlmKHRhc2tzW2luZGV4XSl7XG5cdFx0XHR0YXNrc1tpbmRleF0gPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGlmKCFyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgIXJvb3QuY2FuY2VsSWRsZUNhbGxiYWNrKXtcblx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbTtcblx0XHRyb290LmNhbmNlbElkbGVDYWxsYmFjayA9IGNhbmNlbElkbGVDYWxsYmFja1NoaW07XG5cblx0XHRpZihyb290LmRvY3VtZW50ICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpe1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRyb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uSW5wdXRvck11dGF0aW9uKTtcblxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRbJ2NsaWNrJywgJ2tleXByZXNzJywgJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvbklucHV0b3JNdXRhdGlvbiwge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWV9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZihyb290Lk11dGF0aW9uT2JzZXJ2ZXIpe1xuXHRcdFx0XHRuZXcgTXV0YXRpb25PYnNlcnZlciggb25JbnB1dG9yTXV0YXRpb24gKS5vYnNlcnZlKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWV9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRyeXtcblx0XHRcdHJvb3QucmVxdWVzdElkbGVDYWxsYmFjayhmdW5jdGlvbigpe30sIHt0aW1lb3V0OiAwfSk7XG5cdFx0fSBjYXRjaChlKXtcblx0XHRcdChmdW5jdGlvbihySUMpe1xuXHRcdFx0XHR2YXIgdGltZVJlbWFpbmluZ1Byb3RvLCB0aW1lUmVtYWluaW5nO1xuXHRcdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbihmbiwgdGltZW91dCl7XG5cdFx0XHRcdFx0aWYodGltZW91dCAmJiB0eXBlb2YgdGltZW91dC50aW1lb3V0ID09ICdudW1iZXInKXtcblx0XHRcdFx0XHRcdHJldHVybiBySUMoZm4sIHRpbWVvdXQudGltZW91dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBySUMoZm4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZihyb290LklkbGVDYWxsYmFja0RlYWRsaW5lICYmICh0aW1lUmVtYWluaW5nUHJvdG8gPSBJZGxlQ2FsbGJhY2tEZWFkbGluZS5wcm90b3R5cGUpKXtcblx0XHRcdFx0XHR0aW1lUmVtYWluaW5nID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aW1lUmVtYWluaW5nUHJvdG8sICd0aW1lUmVtYWluaW5nJyk7XG5cdFx0XHRcdFx0aWYoIXRpbWVSZW1haW5pbmcgfHwgIXRpbWVSZW1haW5pbmcuY29uZmlndXJhYmxlIHx8ICF0aW1lUmVtYWluaW5nLmdldCl7cmV0dXJuO31cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycsIHtcblx0XHRcdFx0XHRcdHZhbHVlOiAgZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRpbWVSZW1haW5pbmcuZ2V0LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSkocm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cmVxdWVzdDogcmVxdWVzdElkbGVDYWxsYmFja1NoaW0sXG5cdFx0Y2FuY2VsOiBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltLFxuXHR9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n");

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz82ZGQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0MsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWMsb0VBQUssRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/cradle.tsx":
/*!************************!*\
  !*** ./src/cradle.tsx ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // cradle.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    TODO:\n\n    in horizontal mode, rapid scroll to right sometimes leads to wrong placement of spine\n\n    for resize, preserve cache for reload\n\n    fix spine location anomalies at front and back.\n\n    resizing is triggered twice on setup and probably shouldn't be\n\n    replace safari test with native observer test in cradlefunctions\n\n    sometimes when reaching end of list by repositioning, the spine is one row higher than designe.\n    Rare, therefore probablyh rounding somewhere to to with referenceindex\n\n    occasionally on first vertical scroll the itemobserver fails (sometimes after a few scrolls)\n    seems to get behind in processing and then lose positioning for notifications.\n\n    listisize overshoots on rapid scroll to end\n\n    sometimes padding at bottom is too high (double)\n\n    can't mount error in nested lists\n\n    ***fold is sometimes wayword on scroll to upper limit\n\n    create cradleConfig var for stable things like number of cradle and viewport rows\n\n    Debug scrollToItem callback (including setting scrollforward on first action).\n        motion takes place but gets close rather than exact. Position is off by runwaycount\n\n    Make sure item shell triggers are only fired at the leading, not trailing, edge\n\n    Inconsistency in viewportrows, sometimes Math.ceil, sometimes Math.floor\n\n    change height to 0px from auto for spine in vertical\n    \n    update scrollforward logic to take into account rapid opposite scrolling.\n    Use differences in scrollTop?\n\n    ==>> check getShift logic. !scrollforward should select next calculated index\n    to be above the fold if possible.\n\n    review rotate spineReferenceIndex settings\n    investigate cascading calls to out of scope cradle, in relation to itemshift\n\n    QA defend against butterfly getting intersections from opposite scroll direction\n        as the result of a short viewport\n\n    implement sessionid scheme for cell content\n\n    deal with spine being notified by bottom border rather than top\n\n    spine location occasionally down by 10 = padding\n    spineReferenceIndex is sometimes located (spineOffset) outside the viewport -- should never happen\n\n*/\n\n/*\n    Description\n    -----------\n    The GridSroller provides the illusion of infinite scrolling through the use of a data 'cradle' inside a viewport.\n    The illusion is maintained by synchronizing changes in cradle content with cradle location inside a scrollblock, such\n    that as the scrollblock is moved, the cradle moves oppositely in the scrollblock (to stay visible within the viewport).\n    The scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size and position which\n    realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by a 'spine' which is a 0px height/width (along the medial - ScrollBlock can be\n    verticsl or horizontal). The purpose of the spine is to act as a 'fold', above which cell content expands 'upwards', and\n    below which the cell content expands  'downwards'. GridScroller can be viewed vertically or horizontally. When horizontal,\n    the spine has a 0px width, so that the 'fold' is vertical, and cells expand to the left and right.\n\n    The spine is controlled to always be in the at the leading edge of the leading cellrow of the viewport. Thus\n    in vertical orientation, the spine 'top' css attribute is always equal to the 'scrollTop' position of the scrollblock,\n    plus an adjustment. The adjustment is the result of the alignment of the spine in relation to the top-(or left-)most cell\n    in the viewport (the 'reference' row). The spine can only be placed at the leading edge of the first visible\n    cell in the viewport. Therefore the spine offset from the leading edge of the viewport can be anywhere from minus to\n    plus the length of the leading row. The exact amount depends on where the 'breakpoint' of transition notification is set for\n    cells crossing the viewport threshold (and can be configured). The default of the breakpoint is .5 (half the length of the cell).\n\n    Technically, there are several reference points tracked by the GridScroller. These are:\n        - spineReferenceIndex (the virtual index of the item controlling the location of the spine)\n            The spineReferenceIndex is also used to allocate items above (lower index value) and below (same or higher index value)\n            the fold\n        - cradleReferenceIndex (the virtual index of the item defining the leading bound of the cradle content)\n        - spineOffset (pixels - plus or minus - that the spine is placed in relation to the viewport's leading edge)\n    \n    These reference points are applied to the following structures:\n        - the viewport\n        - the scrollblock\n        - the cradle, consisting of\n            - the spine (contains cradle head and tail)\n            - the head (contains leading items)\n            - the tail (contains trailing items)\n\n    Structure details:\n        the cradle content consists of\n        - the number of rows that are visible in the viewport (according to the default parameters)\n            - this typically includes one partially visible row\n        - the number of runway rows specified in the parameters, times 2 (one et for the head; one for the tail)\n        - the number of items is the number of rows times the 'crosscount' the lateral number of cells.\n        - the last row might consist of fewer items than crosscount, to match the maximum listsize\n        - the cradleRowcount (visible default rows + runwaycount * 2) and viewpointRowcount (visble rows;typicall one partial)\n\n    Item containers:\n        Client cell content is contained in ItemShell's, which are configured according to GridScroller's input parameters.\n        The ItemCell's are in turn contained in CSS grid structures. There are two grid structures - one in the cradle head,\n        and one in the cradle tail. Each grid structure is allowed uniform padding and gaps - identical between the two.\n\n    Overscroll handling:\n        Owing to the weight of the code, and potential rapidity of scrolling, there is an overscroll protocol.\n        if the overscroll is such that part of the cradle is still within the viewport boundaries, then the overscroll\n        is calculated as the number of cell rows that would fit (completely or partially) in the space between the edge of\n        the cradle that is receding from a viewport edge.\n\n        If the overshoot is such that the cradle has entirely passed out of the viewport, the GridScroller goes into 'Repositoining'\n        mode, meaning that it tracks relative location of the spine edge of the viewport, and repaints the cradle accroding to\n        this position when the scrolling stops.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\");\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"];\nvar ITEM_OBSERVER_THRESHOLD = 1;\n\nvar cradlefunctions_1 = __webpack_require__(/*! ./cradlefunctions */ \"./src/cradlefunctions.tsx\");\n\nvar scrolltracker_1 = __importDefault(__webpack_require__(/*! ./scrolltracker */ \"./src/scrolltracker.tsx\"));\n\nvar SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = 200;\n\nvar Cradle = function Cradle(_a) {\n  var gap = _a.gap,\n      padding = _a.padding,\n      // runwaylength,\n  runwaycount = _a.runwaycount,\n      listsize = _a.listsize,\n      indexOffset = _a.indexOffset,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      getItem = _a.getItem,\n      placeholder = _a.placeholder,\n      functions = _a.functions,\n      styles = _a.styles; // functions and styles handled separately\n\n  var cradlePropsRef = react_1.useRef(null); // access by closures\n\n  cradlePropsRef.current = react_1.useMemo(function () {\n    return {\n      gap: gap,\n      padding: padding,\n      // runwaylength,\n      runwaycount: runwaycount,\n      listsize: listsize,\n      indexOffset: indexOffset,\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      getItem: getItem,\n      placeholder: placeholder\n    };\n  }, [gap, padding, // runwaylength,\n  runwaycount, listsize, indexOffset, orientation, cellHeight, cellWidth, getItem, placeholder]); // =============================================================================================\n  // --------------------------------------[ INITIALIZATION ]-------------------------------------\n  // =============================================================================================\n  // -----------------------------------------------------------------------\n  // -----------------------------------[ utilites ]------------------------\n\n  var isMounted = react_is_mounted_hook_1[\"default\"]();\n  var referenceIndexCallbackRef = react_1.useRef(functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback);\n  var itemObserverRef = react_1.useRef(null); // IntersectionObserver\n\n  var cradleIntersectionObserverRef = react_1.useRef(null);\n  var cradleResizeObserverRef = react_1.useRef(null); // -----------------------------------------------------------------------\n  // ---------------------------[ context data ]----------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n  var viewportDataRef = react_1.useRef(null);\n  viewportDataRef.current = viewportData;\n\n  var _b = react_1.useState('setup'),\n      cradleState = _b[0],\n      saveCradleState = _b[1];\n\n  var cradleStateRef = react_1.useRef(null); // access by closures\n\n  cradleStateRef.current = cradleState; // console.log('cradleState', cradleState)\n  // -----------------------------------------------------------------------\n  // -------------------------[ control flags ]-----------------\n\n  var controlFlagsRef = react_1.useRef({\n    pauseItemObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false,\n    isTailCradleInView: true,\n    isHeadCradleInView: true,\n    isCradleInView: true\n  }); // ------------------------------------------------------------------------\n  // -----------------------[ initialization effects ]-----------------------\n  //initialize host functions properties\n\n  react_1.useEffect(function () {\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('scrollToItem')) {\n      functions.scrollToItem = scrollToItem;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getVisibleList')) {\n      functions.getVisibleList = getVisibleList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getContentList')) {\n      functions.getContentList = getContentList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('reload')) {\n      functions.reload = reload;\n    }\n\n    referenceIndexCallbackRef.current = functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback;\n  }, [functions]); // initialize window scroll listener\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n    viewportData.elementref.current.addEventListener('scroll', onScroll);\n    return function () {\n      viewportData.elementref.current && viewportData.elementref.current.removeEventListener('scroll', onScroll);\n    };\n  }, []); // -----------------------------------------------------------------------\n  // -----------------------[ reconfiguration effects ]---------------------\n  // trigger resizing based on viewport state\n\n  react_1.useEffect(function () {\n    // console.log('viewportData.isResizing', viewportData.isResizing)\n    if (cradleStateRef.current == 'setup') return;\n\n    if (viewportData.isResizing) {\n      callingReferenceIndexDataRef.current = __assign({}, stableReferenceIndexDataRef.current);\n      controlFlagsRef.current.pauseItemObserver = true;\n      controlFlagsRef.current.pauseCradleIntersectionObserver = true;\n      controlFlagsRef.current.pauseCradleResizeObserver = true;\n      controlFlagsRef.current.pauseScrollingEffects = true;\n      saveCradleState('resizing');\n    } // complete resizing mode\n\n\n    if (!viewportData.isResizing && cradleStateRef.current == 'resizing') {\n      saveCradleState('resize');\n    }\n  }, [viewportData.isResizing]); // reload for changed parameters\n\n  react_1.useEffect(function () {\n    if (cradleStateRef.current == 'setup') return; // let spineoffset\n    // if (cradlePropsRef.current.orientation == 'vertical') {\n    //     spineoffset = spineCradleElementRef.current.offsetTop - viewportDataRef.current.elementref.current.scrollTop\n    // } else {\n    //     spineoffset = spineCradleElementRef.current.offsetLeft - viewportDataRef.current.elementref.current.scrollLeft\n    // }\n\n    callingReferenceIndexDataRef.current = __assign({}, stableReferenceIndexDataRef.current);\n    controlFlagsRef.current.pauseItemObserver = true; // pauseCradleIntersectionObserverRef.current = true\n\n    controlFlagsRef.current.pauseScrollingEffects = true;\n    saveCradleState('reload');\n  }, [listsize, cellHeight, cellWidth, gap, padding]); // trigger pivot on change in orientation\n\n  react_1.useEffect(function () {\n    if (cradleStateRef.current != 'setup') {\n      callingReferenceIndexDataRef.current = __assign({}, stableReferenceIndexDataRef.current); // let orientation = cradlePropsRef.current.orientation\n      // get previous ration\n\n      var previousCellPixelLength = orientation == 'vertical' ? cradlePropsRef.current.cellWidth : cradlePropsRef.current.cellHeight;\n      var previousSpineOffset = callingReferenceIndexDataRef.current.spineoffset;\n      var previousratio = previousSpineOffset / previousCellPixelLength;\n      var currentCellPixelLength = orientation == 'vertical' ? cradlePropsRef.current.cellHeight : cradlePropsRef.current.cellWidth;\n      var currentSpineOffset = previousratio * currentCellPixelLength; // scrollReferenceIndexDataRef.current.spineoffset = \n\n      callingReferenceIndexDataRef.current.spineoffset = Math.round(currentSpineOffset);\n      controlFlagsRef.current.pauseItemObserver = true; // pauseCradleIntersectionObserverRef.current = true\n\n      controlFlagsRef.current.pauseScrollingEffects = true;\n      saveCradleState('pivot');\n    }\n\n    var cradleContent = cradleContentRef.current;\n    cradleContent.headModel = [];\n    cradleContent.tailModel = [];\n    cradleContent.headView = [];\n    cradleContent.tailView = [];\n  }, [orientation]); // =======================================================================\n  // -------------------------[ OPERATION ]---------------------------------\n  // =======================================================================\n  // -----------------------------------------------------------------------\n  // ------------------------[ session data ]-------------------------------\n  // ------------------ current location -- first tail visible item -------------\n\n  var scrollReferenceIndexDataRef = react_1.useRef({\n    index: Math.min(indexOffset, listsize - 1) || 0,\n    spineoffset: padding\n  }); // access by closures\n  // set by onScroll at the end of scroll sessions\n\n  var stableReferenceIndexDataRef = react_1.useRef(scrollReferenceIndexDataRef.current); // anticipate calling of operation which requires ReferenceIndex data\n\n  var callingReferenceIndexDataRef = react_1.useRef(stableReferenceIndexDataRef.current); // anticipate reposition\n  // -------------------------------[ cradle data ]-------------------------------------\n  // TODO: create a datamodel object for this?\n  // cradle butterfly html components\n\n  var headCradleElementRef = react_1.useRef(null);\n  var tailCradleElementRef = react_1.useRef(null);\n  var spineCradleElementRef = react_1.useRef(null);\n  var cradleElementsRef = react_1.useRef({\n    head: headCradleElementRef,\n    tail: tailCradleElementRef,\n    spine: spineCradleElementRef\n  }); // // data model\n  // const modelContentRef = useRef(null)\n  // const headModelContentRef = useRef(null)\n  // const tailModelContentRef = useRef(null)\n  // // view model\n  // const headViewContentRef = useRef([])\n  // const tailViewContentRef = useRef([])\n\n  var cradleContentRef = react_1.useRef({\n    cradleModel: null,\n    headModel: null,\n    tailModel: null,\n    headView: [],\n    tailView: []\n  }); // item elements cache...\n\n  var itemElementsRef = react_1.useRef(new Map()); // items register their element\n  // ------------------------------[ cradle configuration ]---------------------------\n\n  var viewportDimensions = viewportData.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width;\n  var crosscount = react_1.useMemo(function () {\n    var crosscount;\n    var size = orientation == 'horizontal' ? viewportheight : viewportwidth;\n    var crossLength = orientation == 'horizontal' ? cellHeight : cellWidth;\n    var lengthforcalc = size - padding * 2 + gap; // length of viewport\n\n    var tilelengthforcalc = crossLength + gap;\n    tilelengthforcalc = Math.min(tilelengthforcalc, lengthforcalc); // result cannot be less than 1\n\n    crosscount = Math.floor(lengthforcalc / tilelengthforcalc);\n    return crosscount;\n  }, [orientation, cellWidth, cellHeight, gap, padding, viewportheight, viewportwidth]); // const crosscountRef = useRef(crosscount) // for easy reference by observer\n  // crosscountRef.current = crosscount // available for observer closure\n\n  var _c = react_1.useMemo(function () {\n    var viewportLength, cellLength;\n\n    if (orientation == 'vertical') {\n      viewportLength = viewportheight;\n      cellLength = cellHeight;\n    } else {\n      viewportLength = viewportwidth;\n      cellLength = cellWidth;\n    }\n\n    cellLength += gap;\n    var viewportrowcount = Math.ceil(viewportLength / cellLength);\n    var cradlerowcount = viewportrowcount + runwaycount * 2;\n    var itemcount = cradlerowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradlerowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradlerowcount, viewportrowcount];\n  }, [orientation, cellWidth, cellHeight, gap, listsize, // padding,\n  viewportheight, viewportwidth, runwaycount, crosscount]),\n      cradleRowcount = _c[0],\n      viewportRowcount = _c[1]; // const cradleRowcountRef = useRef(null)\n  // cradleRowcountRef.current = cradleRowcount\n  // const viewportRowcountRef = useRef(null)\n  // viewportRowcountRef.current = viewportRowcount\n\n\n  var cradleConfigRef = react_1.useRef({\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    itemObserverThreshold: ITEM_OBSERVER_THRESHOLD\n  });\n  cradleConfigRef.current = {\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    itemObserverThreshold: ITEM_OBSERVER_THRESHOLD\n  }; // ----------------------------------[ cradle default styles]----------------------------------\n  // base styles\n\n  var cradleHeadStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = 0;\n      right = 0;\n      top = 'auto';\n    } else {\n      bottom = 0;\n      left = 'auto';\n      right = 0;\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]);\n  var cradleTailStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 'auto';\n      left = 0;\n      right = 0;\n      top = 0;\n    } else {\n      bottom = 0;\n      left = 0;\n      right = 'auto';\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]); // redundant\n\n  var cradleSpineStyle = react_1.useMemo(function () {\n    var styleobj = {\n      position: 'relative'\n    };\n    return styleobj;\n  }, [padding, orientation]); // enhanced styles for grid\n\n  var _d = react_1.useMemo(function () {\n    // merge base style and revisions (by observer)\n    var headCradleStyles = __assign({}, cradleHeadStyle);\n\n    var tailCradleStyles = __assign({}, cradleTailStyle);\n\n    var _a = cradlefunctions_1.setCradleGridStyles({\n      orientation: orientation,\n      headCradleStyles: headCradleStyles,\n      tailCradleStyles: tailCradleStyles,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      crosscount: crosscount,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth\n    }),\n        headstyles = _a[0],\n        tailstyles = _a[1];\n\n    var top, left, width, height;\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n      width = '100%';\n      height = 'auto';\n    } else {\n      top = 'auto';\n      left = padding + 'px';\n      width = 0;\n      height = '100%';\n    }\n\n    var spinestyle = {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n    return [headstyles, tailstyles, spinestyle];\n  }, [orientation, cellHeight, cellWidth, gap, padding, viewportheight, viewportwidth, crosscount]),\n      headstyle = _d[0],\n      tailstyle = _d[1],\n      spinestyle = _d[2];\n\n  cradleHeadStyle = headstyle;\n  cradleTailStyle = tailstyle;\n  cradleSpineStyle = spinestyle; // =================================================================================\n  // -------------------------[ IntersectionObserver support]-------------------------\n  // =================================================================================\n\n  /*\n      There are two interection observers, one for the cradle, and another for itemShells;\n          both against the viewport.\n      There is also a resize observer for the cradle wings, to respond to size changes of\n          variable cells.\n  */\n  // --------------------------[ cradle observers ]-----------------------------------\n  // set up cradle resizeobserver\n\n  react_1.useEffect(function () {\n    // ResizeObserver\n    cradleResizeObserverRef.current = new LocalResizeObserver(cradleresizeobservercallback);\n    var cradleElements = cradleElementsRef.current;\n    cradleResizeObserverRef.current.observe(cradleElements.head.current);\n    cradleResizeObserverRef.current.observe(cradleElements.tail.current);\n    return function () {\n      cradleResizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleresizeobservercallback = react_1.useCallback(function (entries) {\n    if (controlFlagsRef.current.pauseCradleResizeObserver) return;\n  }, []); // this sets up an IntersectionObserver of the cradle against the viewport. When the\n  // cradle goes out of the observer scope, the \"repositioning\" cradle state is triggerd.\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current; // IntersectionObserver\n\n    cradleIntersectionObserverRef.current = new IntersectionObserver(cradleintersectionobservercallback, {\n      root: viewportData.elementref.current,\n      threshold: 0\n    });\n    var cradleElements = cradleElementsRef.current;\n    cradleIntersectionObserverRef.current.observe(cradleElements.head.current);\n    cradleIntersectionObserverRef.current.observe(cradleElements.tail.current);\n    return function () {\n      cradleIntersectionObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleintersectionobservercallback = react_1.useCallback(function (entries) {\n    var controlFlags = controlFlagsRef.current;\n    if (controlFlags.pauseCradleIntersectionObserver) return;\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.name == 'head') {\n        controlFlags.isHeadCradleInView = entry.isIntersecting;\n      } else {\n        controlFlags.isTailCradleInView = entry.isIntersecting;\n      }\n    }\n\n    controlFlags.isCradleInView = controlFlags.isHeadCradleInView || controlFlags.isTailCradleInView;\n\n    if (!controlFlags.isCradleInView) {\n      var cradleState_1 = cradleStateRef.current;\n\n      if (!viewportDataRef.current.isResizing && !(cradleState_1 == 'resize') && !(cradleState_1 == 'repositioning') && !(cradleState_1 == 'reposition') && !(cradleState_1 == 'pivot')) {\n        var rect = viewportDataRef.current.elementref.current.getBoundingClientRect();\n        var top_1 = rect.top,\n            right = rect.right,\n            bottom = rect.bottom,\n            left = rect.left;\n        var width = right - left,\n            height = bottom - top_1;\n        viewportDataRef.current.viewportDimensions = {\n          top: top_1,\n          right: right,\n          bottom: bottom,\n          left: left,\n          width: width,\n          height: height\n        }; // update for scrolltracker\n\n        controlFlags.pauseItemObserver = true; // pauseCradleIntersectionObserverRef.current = true\n\n        console.log('REPOSITIONING');\n        var cradleContent_1 = cradleContentRef.current;\n        cradleContent_1.headModel = [];\n        cradleContent_1.tailModel = [];\n        cradleContent_1.headView = [];\n        cradleContent_1.tailView = [];\n        saveCradleState('repositioning');\n      }\n    }\n  }, []); // --------------------------[ item shell observer ]-----------------------------\n\n  /*\n      The cradle content is driven by notifications from the IntersectionObserver.\n      - as the user scrolls the cradle, which has a runwaycount at both the leading\n          and trailing edges, itemShells scroll into or out of the scope of the observer\n          (defined by the width/height of the viewport + the lengths of the runways). The observer\n          notifies the app (through itemobservercallback() below) at the crossings of the itemshells\n          of the defined observer cradle boundaries.\n           The no-longer-intersecting notifications trigger dropping of that number of affected items from\n          the cradle contentlist. The dropping of items from the trailing end of the content list\n          triggers the addition of an equal number of items at the leading edge of the cradle content.\n           Technically, the opposite end position spec is set (top or left depending on orientation),\n          and the matching end position spec is set to 'auto' when items are added. This causes items to be\n          \"squeezed\" into the leading or trailing ends of the ui content (out of view) as appropriate.\n           There are exceptions for setup and edge cases.\n  */\n  // change orientation\n\n  react_1.useEffect(function () {\n    if (itemObserverRef.current) itemObserverRef.current.disconnect();\n    itemObserverRef.current = new IntersectionObserver(itemobservercallback, {\n      root: viewportDataRef.current.elementref.current,\n      threshold: cradleConfigRef.current.itemObserverThreshold\n    });\n    return function () {\n      itemObserverRef.current.disconnect();\n    };\n  }, [orientation]); // the async callback from IntersectionObserver.\n\n  var itemobservercallback = react_1.useCallback(function (entries) {\n    var movedentries = [];\n\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n\n      if (entry.target.dataset.initialized) {\n        movedentries.push(entry);\n      } else {\n        entry.target.dataset.initialized = true;\n      }\n    }\n\n    if (controlFlagsRef.current.pauseItemObserver) {\n      return;\n    }\n\n    isMounted() && updateCradleContent(movedentries);\n  }, []);\n  var previousScrollForwardRef = react_1.useRef(undefined);\n\n  var updateCradleContent = function updateCradleContent(entries, source) {\n    if (source === void 0) {\n      source = 'notifications';\n    }\n\n    console.log('updating cradle content: entries.length, source', entries.length, source);\n    var viewportData = viewportDataRef.current;\n    var viewportElement = viewportData.elementref.current;\n    var cradleProps = cradlePropsRef.current;\n    var scrollOffset;\n\n    if (cradleProps.orientation == 'vertical') {\n      scrollOffset = viewportElement.scrollTop;\n    } else {\n      scrollOffset = viewportElement.scrollLeft;\n    }\n\n    if (scrollOffset < 0) {\n      // for Safari elastic bounce at top of scroll\n      return;\n    } // console.log('updateCradleContent scrollOffset', scrollOffset)\n    // ----------------------------[ 1. initialize ]----------------------------\n\n\n    var scrollPositions = scrollPositionsRef.current;\n    var scrollforward;\n\n    if (scrollPositions.current == scrollPositions.previous) {\n      // edge case \n      scrollforward = previousScrollForwardRef.current;\n    } else {\n      scrollforward = scrollPositions.current > scrollPositions.previous;\n      previousScrollForwardRef.current = scrollforward;\n    }\n\n    if (scrollforward === undefined) {\n      return; // init call\n    }\n\n    var cradleElements = cradleElementsRef.current;\n    var cradleContent = cradleContentRef.current;\n    var cradleConfig = cradleConfigRef.current;\n    var itemElements = itemElementsRef.current;\n    var modelcontentlist = cradleContent.cradleModel;\n    var cradleReferenceIndex = modelcontentlist[0].props.index;\n    var _a = cradleConfigRef.current,\n        cradleRowcount = _a.cradleRowcount,\n        crosscount = _a.crosscount; // --------------------[ 2. filter intersections list ]-----------------------\n    // filter out inapplicable intersection entries\n    // we're only interested in intersections proximal to the spine\n\n    var intersections = cradlefunctions_1.isolateRelevantIntersections({\n      scrollforward: scrollforward,\n      intersections: entries,\n      cradleContent: cradleContent,\n      itemObserverThreshold: cradleConfig.itemObserverThreshold\n    }); // console.log('intersections', intersections)\n    // --------------------------------[ 3. Calculate shifts ]-------------------------------\n\n    var _b = cradlefunctions_1.calcContentShifts({\n      cradleProps: cradleProps,\n      cradleConfig: cradleConfig,\n      cradleElements: cradleElements,\n      cradleContent: cradleContent,\n      viewportElement: viewportElement,\n      itemElements: itemElements,\n      intersections: intersections,\n      scrollforward: scrollforward\n    }),\n        cradleindex = _b[0],\n        cradleitemshift = _b[1],\n        spineReferenceIndex = _b[2],\n        referenceitemshift = _b[3],\n        spineOffset = _b[4],\n        contentCount = _b[5];\n\n    if (referenceitemshift == 0) return; // console.log('in updateCradleContent: cradleindex, cradleitemshift, spineReferenceIndex, referenceitemshift, spineOffset, contentCount, cradleConfig',\n    //     cradleindex, cradleitemshift, spineReferenceIndex, referenceitemshift, spineOffset, contentCount, cradleConfig)\n    // ------------------[ 4. calculate head and tail consolidated cradle content changes ]-----------------\n\n    var _c = cradlefunctions_1.calcHeadAndTailChanges({\n      itemshiftcount: cradleitemshift,\n      crosscount: crosscount,\n      cradlerowcount: cradleRowcount,\n      headcontent: cradleContent.headModel,\n      tailcontent: cradleContent.tailModel,\n      scrollforward: scrollforward,\n      cradleProps: cradleProps,\n      cradleReferenceIndex: cradleReferenceIndex\n    }),\n        headchangecount = _c[0],\n        tailchangecount = _c[1]; // console.log('headchangecount,tailchangecount',headchangecount,tailchangecount)\n    // ----------------------------------[ 5. reconfigure cradle content ]--------------------------\n    // collect modified content\n\n\n    var localContentList;\n\n    if (headchangecount || tailchangecount) {\n      localContentList = cradlefunctions_1.getUIContentList({\n        contentCount: contentCount,\n        localContentList: modelcontentlist,\n        headchangecount: headchangecount,\n        tailchangecount: tailchangecount,\n        cradleReferenceIndex: cradleReferenceIndex,\n        cradleProps: cradleProps,\n        observer: itemObserverRef.current,\n        callbacks: callbacksRef.current,\n        cradleRowcount: cradleRowcount,\n        crosscount: cradleConfig.crosscount\n      });\n    } else {\n      localContentList = modelcontentlist;\n    } // console.log('localContentList.length', localContentList.length)\n    // ----------------------------------[ 7. allocate cradle content ]--------------------------\n\n\n    var _d = cradlefunctions_1.allocateContentList({\n      contentlist: localContentList,\n      spineReferenceIndex: spineReferenceIndex\n    }),\n        headcontent = _d[0],\n        tailcontent = _d[1]; // console.log('headcontent.length, tailcontent.length',headcontent.length, tailcontent.length)\n\n\n    cradleContent.cradleModel = localContentList;\n    cradleContent.headView = cradleContent.headModel = headcontent;\n    cradleContent.tailView = cradleContent.tailModel = tailcontent; // -------------------------------[ 8. set css changes ]-------------------------\n\n    if (spineOffset !== undefined) {\n      var cradleElements_1 = cradleElementsRef.current;\n\n      if (cradleProps.orientation == 'vertical') {\n        scrollPositionDataRef.current = {\n          property: 'scrollTop',\n          value: viewportElement.scrollTop\n        };\n        cradleElements_1.spine.current.style.top = viewportElement.scrollTop + spineOffset + 'px';\n        cradleElements_1.spine.current.style.left = 'auto';\n        cradleElements_1.head.current.style.paddingBottom = headcontent.length ? cradleProps.gap + 'px' : 0;\n      } else {\n        scrollPositionDataRef.current = {\n          property: 'scrollLeft',\n          value: viewportElement.scrollLeft\n        };\n        cradleElements_1.spine.current.style.top = 'auto';\n        cradleElements_1.spine.current.style.left = viewportElement.scrollLeft + spineOffset + 'px';\n        cradleElements_1.head.current.style.paddingRight = headcontent.length ? cradleProps.gap + 'px' : 0;\n      }\n    }\n\n    scrollReferenceIndexDataRef.current = {\n      index: spineReferenceIndex,\n      spineoffset: spineOffset\n    };\n    saveCradleState('updatecontent');\n  }; // End of IntersectionObserver support\n  // ========================================================================================\n  // -------------------------------[ Assembly of content]-----------------------------------\n  // ========================================================================================\n  // reset cradle, including allocation between head and tail parts of the cradle\n\n\n  var setCradleContent = function setCradleContent(cradleState, referenceIndexData) {\n    // console.log('setCradleContent start: cradleState, referenceIndexData',cradleState, referenceIndexData)\n    var cradleProps = cradlePropsRef.current;\n    var visibletargetindexoffset = referenceIndexData.index,\n        visibletargetscrolloffset = referenceIndexData.spineoffset;\n    var cellHeight = cradleProps.cellHeight,\n        cellWidth = cradleProps.cellWidth,\n        orientation = cradleProps.orientation,\n        runwaycount = cradleProps.runwaycount,\n        gap = cradleProps.gap,\n        padding = cradleProps.padding,\n        listsize = cradleProps.listsize;\n    var cradleConfig = cradleConfigRef.current;\n    var cradleRowcount = cradleConfig.cradleRowcount,\n        crosscount = cradleConfig.crosscount,\n        viewportRowcount = cradleConfig.viewportRowcount;\n\n    if (cradleState == 'reposition') {\n      visibletargetscrolloffset = visibletargetindexoffset == 0 ? padding : gap;\n    }\n\n    var localContentList = []; // any duplicated items will be re-used by react\n\n    var cradleContent = cradleContentRef.current;\n\n    var _a = cradlefunctions_1.getContentListRequirements({\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      orientation: orientation,\n      runwaycount: runwaycount,\n      cradleRowcount: cradleRowcount,\n      viewportRowcount: viewportRowcount,\n      gap: gap,\n      padding: padding,\n      visibletargetindexoffset: visibletargetindexoffset,\n      targetViewportOffset: visibletargetscrolloffset,\n      crosscount: crosscount,\n      listsize: listsize,\n      viewportElement: viewportDataRef.current.elementref.current\n    }),\n        cradleReferenceIndex = _a.cradleReferenceIndex,\n        referenceoffset = _a.referenceoffset,\n        contentCount = _a.contentCount,\n        scrollblockoffset = _a.scrollblockoffset,\n        spineOffset = _a.spineOffset,\n        spineadjustment = _a.spineadjustment; // console.log('setCradleContent getContentListRequirements: cradleReferenceIndex, referenceoffset, contentCount, scrollblockoffset, spineOffset, spineadjustment',\n    //     cradleReferenceIndex, referenceoffset, contentCount, scrollblockoffset, spineOffset, spineadjustment)\n    // returns content constrained by cradleRowcount\n\n\n    var childlist = cradlefunctions_1.getUIContentList({\n      contentCount: contentCount,\n      crosscount: cradleConfig.crosscount,\n      // cradleitemshift:0,\n      // content,\n      cradleReferenceIndex: cradleReferenceIndex,\n      headchangecount: 0,\n      tailchangecount: contentCount,\n      cradleProps: cradlePropsRef.current,\n      localContentList: localContentList,\n      callbacks: callbacksRef.current,\n      observer: itemObserverRef.current,\n      cradleRowcount: cradleRowcount\n    }); // console.log('childlist.length, contentCount, rows from setContent', childlist.length, contentCount, Math.ceil(contentCount/crosscount))\n\n    var _b = cradlefunctions_1.allocateContentList({\n      contentlist: childlist,\n      spineReferenceIndex: referenceoffset\n    }),\n        headcontentlist = _b[0],\n        tailcontentlist = _b[1]; // console.log('headcontentlist.length, tailcontentlist.length',headcontentlist.length, tailcontentlist.length)\n\n\n    if (headcontentlist.length == 0) {\n      spineOffset = padding;\n    }\n\n    cradleContent.cradleModel = childlist;\n    cradleContent.headModel = headcontentlist;\n    cradleContent.tailModel = tailcontentlist;\n    scrollReferenceIndexDataRef.current = stableReferenceIndexDataRef.current = {\n      index: referenceoffset,\n      spineoffset: spineOffset\n    };\n\n    if (referenceIndexCallbackRef.current) {\n      var cstate = cradleState;\n      if (cstate == 'setreload') cstate = 'reload';\n      referenceIndexCallbackRef.current(stableReferenceIndexDataRef.current.index, 'setCradleContent', cstate);\n    } // console.log('scrollblockoffset, spineOffset, spineadjustment',\n    //     scrollblockoffset, spineOffset, spineadjustment)\n\n\n    var cradleElements = cradleElementsRef.current;\n\n    if (orientation == 'vertical') {\n      scrollPositionDataRef.current = {\n        property: 'scrollTop',\n        value: scrollblockoffset - spineOffset\n      };\n      cradleElements.spine.current.style.top = scrollblockoffset + spineadjustment + 'px';\n      cradleElements.spine.current.style.left = 'auto';\n      cradleElements.head.current.style.paddingBottom = headcontentlist.length ? cradleProps.gap + 'px' : 0; // console.log('CSS adjustments: scrollTop, scrollblockoffset, spineOffset, top, spineadjustment',\n      //     scrollblockoffset  - spineOffset, scrollblockoffset, spineOffset, scrollblockoffset, scrollblockoffset + spineadjustment, spineadjustment )\n    } else {\n      // orientation = 'horizontal'\n      scrollPositionDataRef.current = {\n        property: 'scrollLeft',\n        value: scrollblockoffset - spineOffset\n      };\n      cradleElements.spine.current.style.top = 'auto';\n      cradleElements.spine.current.style.left = scrollblockoffset + spineadjustment + 'px';\n      cradleElements.head.current.style.paddingRight = headcontentlist.length ? cradleProps.gap + 'px' : 0;\n    }\n  }; // =====================================================================================\n  // ----------------------------------[ state management ]-------------------------------\n  // =====================================================================================\n\n\n  var scrollTimeridRef = react_1.useRef(null);\n  var scrollPositionsRef = react_1.useRef({\n    current: 0,\n    previous: 0\n  }); // callback for scrolling\n\n  var onScroll = react_1.useCallback(function (e) {\n    var _a;\n\n    if (controlFlagsRef.current.pauseScrollingEffects) {\n      // console.log('returning from onScroll with pauseScrollingEffects true', \n      //     viewportDataRef.current.elementref.current.scrollTop)\n      return;\n    }\n\n    var viewportElement = viewportDataRef.current.elementref.current;\n    var scrollPositions = scrollPositionsRef.current;\n    var scrollPositioncurrent = cradlePropsRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n\n    if (scrollPositioncurrent < 0) {\n      // for Safari\n      return;\n    }\n\n    scrollPositions.previous = scrollPositions.current;\n    scrollPositions.current = //scrollPositioncurrent\n    cradlePropsRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(scrollTimeridRef.current);\n    var cradleState = cradleStateRef.current;\n    var cradleContent = cradleContentRef.current;\n\n    if (!viewportDataRef.current.isResizing) {\n      if (cradleState == 'ready' || cradleState == 'repositioning') {\n        if (cradleState == 'ready') {\n          var itemindex = (_a = cradleContent.tailModel[0]) === null || _a === void 0 ? void 0 : _a.props.index;\n\n          if (itemindex === undefined) {\n            console.log('ERROR: scroll encountered undefined tailcontent lead');\n          }\n\n          var spineoffset = void 0;\n          var cradleElements = cradleElementsRef.current;\n\n          if (cradlePropsRef.current.orientation == 'vertical') {\n            spineoffset = cradleElements.spine.current.offsetTop - viewportDataRef.current.elementref.current.scrollTop;\n          } else {\n            spineoffset = cradleElements.spine.current.offsetLeft - viewportDataRef.current.elementref.current.scrollLeft;\n          }\n\n          scrollReferenceIndexDataRef.current = {\n            index: itemindex,\n            spineoffset: spineoffset\n          };\n        } else {\n          scrollReferenceIndexDataRef.current = cradlefunctions_1.getScrollReferenceIndexData({\n            viewportData: viewportDataRef.current,\n            cradleProps: cradlePropsRef.current,\n            crosscount: cradleConfigRef.current.crosscount\n          });\n          saveCradleState('updatereposition');\n        }\n\n        referenceIndexCallbackRef.current && referenceIndexCallbackRef.current(scrollReferenceIndexDataRef.current.index, 'scrolling', cradleState);\n      }\n    }\n\n    scrollTimeridRef.current = setTimeout(function () {\n      var cradleState = cradleStateRef.current;\n\n      if (!viewportDataRef.current.isResizing) {\n        var localrefdata = __assign({}, scrollReferenceIndexDataRef.current);\n\n        stableReferenceIndexDataRef.current = localrefdata;\n      }\n\n      switch (cradleState) {\n        case 'repositioning':\n          {\n            callingReferenceIndexDataRef.current = __assign({}, stableReferenceIndexDataRef.current);\n            saveCradleState('reposition');\n            break;\n          }\n\n        default:\n          {\n            updateCradleContent([], 'end of scroll'); // for Safari to compensate for overscroll\n          }\n      }\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n  }, []); // data for state processing\n\n  var callingCradleState = react_1.useRef(cradleStateRef.current);\n  var headlayoutDataRef = react_1.useRef(null);\n  var scrollPositionDataRef = react_1.useRef(null); // this is the core state engine\n  // useLayout for suppressing flashes\n\n  react_1.useLayoutEffect(function () {\n    var viewportData = viewportDataRef.current;\n    var cradleContent = cradleContentRef.current;\n\n    switch (cradleState) {\n      case 'reload':\n        // cradleContent.headModel = []\n        // cradleContent.tailModel = []\n        // cradleContent.headView = []\n        // cradleContent.tailView = []\n        saveCradleState('setreload');\n        break;\n\n      case 'updatereposition':\n        saveCradleState('repositioning');\n\n      case 'repositioning':\n        break;\n\n      case 'setscrolloffset':\n        {\n          // setTimeout(() => {\n          viewportData.elementref.current[scrollPositionDataRef.current.property] = scrollPositionDataRef.current.value; // console.log('setscrolloffset', scrollPositionDataRef.current)\n\n          saveCradleState('normalize'); //'content')\n          // })\n\n          break;\n        }\n\n      case 'updatecontent':\n        {\n          // scroll\n          saveCradleState('ready');\n          break;\n        }\n\n      case 'content':\n        {\n          // console.log('content')\n          var cradleContent_2 = cradleContentRef.current;\n          cradleContent_2.headView = cradleContent_2.headModel;\n          cradleContent_2.tailView = cradleContent_2.tailModel;\n          saveCradleState('setscrolloffset'); //'normalize')\n\n          break;\n        }\n    }\n  }, [cradleState]); // standard processing stages\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n\n    switch (cradleState) {\n      case 'setup':\n      case 'resize':\n      case 'pivot':\n      case 'setreload':\n      case 'reposition':\n        callingCradleState.current = cradleState;\n        saveCradleState('settle');\n        break;\n\n      case 'settle':\n        {\n          // console.log('settle (setCradleContent): state, refIndex',callingCradleState.current, callingReferenceIndexDataRef.current)\n          cradleContent.headModel = [];\n          cradleContent.tailModel = [];\n          cradleContent.headView = [];\n          cradleContent.tailView = [];\n          setCradleContent(callingCradleState.current, callingReferenceIndexDataRef.current);\n          saveCradleState('content'); //'setscrolloffset')\n\n          break;\n        }\n\n      case 'normalize':\n        {\n          setTimeout(function () {\n            // console.log('inside normalize: viewportData.isResizing', viewportData.isResizing)\n            if (!viewportData.isResizing) {\n              // redundant scroll position to avoid accidental positioning at tail end of reposition\n              if (viewportData.elementref.current) {\n                // already unmounted if fails\n                var controlFlags = controlFlagsRef.current; // console.log('clearing control Flags', controlFlags)\n\n                controlFlags.pauseItemObserver && (controlFlags.pauseItemObserver = false);\n                controlFlags.pauseScrollingEffects && (controlFlags.pauseScrollingEffects = false);\n                controlFlags.pauseCradleIntersectionObserver && (controlFlags.pauseCradleIntersectionObserver = false);\n                controlFlags.pauseCradleResizeObserver && (controlFlags.pauseCradleResizeObserver = false);\n              }\n\n              if (controlFlagsRef.current.isCradleInView) {\n                saveCradleState('ready');\n              } else {\n                saveCradleState('repositioning');\n              }\n            } else {\n              saveCradleState('resizing');\n            }\n          }, 100);\n          break;\n        }\n\n      case 'ready':\n        break;\n    }\n  }, [cradleState]); // =============================================================================\n  // ------------------------------[ callbacks ]----------------------------------\n  // =============================================================================\n  // on host demand\n\n  var getVisibleList = react_1.useCallback(function () {\n    var cradleElements = cradleElementsRef.current;\n    var cradleContent = cradleContentRef.current;\n    return cradlefunctions_1.calcVisibleItems({\n      itemElementMap: itemElementsRef.current,\n      viewportElement: viewportDataRef.current.elementref.current,\n      headElement: cradleElements.head.current,\n      // tailElement:cradlePropsRef.current.orientation,\n      spineElement: cradleElements.spine.current,\n      orientation: cradlePropsRef.current.orientation,\n      headlist: cradleContent.headView\n    });\n  }, []);\n  var getContentList = react_1.useCallback(function () {\n    var contentlist = Array.from(itemElementsRef.current);\n    contentlist.sort(function (a, b) {\n      return a[0] < b[0] ? -1 : 1;\n    });\n    return contentlist;\n  }, []);\n  var reload = react_1.useCallback(function () {\n    controlFlagsRef.current.pauseItemObserver = true;\n    controlFlagsRef.current.pauseScrollingEffects = true;\n    var spineoffset;\n    var cradleElements = cradleElementsRef.current;\n\n    if (cradlePropsRef.current.orientation == 'vertical') {\n      spineoffset = cradleElements.spine.current.offsetTop - viewportDataRef.current.elementref.current.scrollTop;\n    } else {\n      spineoffset = cradleElements.spine.current.offsetLeft - viewportDataRef.current.elementref.current.scrollLeft;\n    }\n\n    callingReferenceIndexDataRef.current = __assign({}, stableReferenceIndexDataRef.current);\n    saveCradleState('reload');\n  }, []); // content item registration callback; called from item\n\n  var getItemElementData = react_1.useCallback(function (itemElementData, reportType) {\n    var index = itemElementData[0],\n        shellref = itemElementData[1];\n\n    if (reportType == 'register') {\n      itemElementsRef.current.set(index, shellref);\n    } else if (reportType == 'unregister') {\n      itemElementsRef.current[\"delete\"](index);\n    }\n  }, []);\n  var scrollToItem = react_1.useCallback(function (index) {\n    controlFlagsRef.current.pauseItemObserver = true;\n    controlFlagsRef.current.pauseScrollingEffects = true;\n    callingReferenceIndexDataRef.current = {\n      index: index,\n      spineoffset: 0\n    };\n    saveCradleState('reposition');\n  }, []);\n  var callbacksRef = react_1.useRef({\n    getElementData: getItemElementData\n  }); // =============================================================================\n  // ------------------------------[ RENDER... ]----------------------------------\n  // =============================================================================\n\n  var scrollTrackerArgs = react_1.useMemo(function () {\n    return {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      indexOffset: scrollReferenceIndexDataRef.current.index,\n      listsize: cradlePropsRef.current.listsize,\n      styles: cradlePropsRef.current.styles\n    };\n  }, [viewportDimensions, scrollReferenceIndexDataRef.current, cradlePropsRef]);\n  var cradleContent = cradleContentRef.current;\n  return react_1[\"default\"].createElement(react_1[\"default\"].Fragment, null, cradleStateRef.current == 'updatereposition' || cradleStateRef.current == 'repositioning' ? react_1[\"default\"].createElement(scrolltracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.indexOffset,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    style: cradleSpineStyle,\n    ref: spineCradleElementRef,\n    \"data-name\": 'spine'\n  }, true ? react_1[\"default\"].createElement(\"div\", {\n    style: {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    }\n  }) : undefined, react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleStateRef.current != 'setup' ? cradleContent.headView : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleStateRef.current != 'setup' ? cradleContent.tailView : null)));\n}; // Cradle\n\n\nexports[\"default\"] = Cradle;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGUudHN4PzE4M2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4REE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQ7QUFFQSxJQUFNLHVCQUF1QixHQUFHLENBQWhDOztBQUVBOztBQWVBOztBQUVBLElBQU0sZ0NBQWdDLEdBQUcsR0FBekM7O0FBRUEsSUFBTSxNQUFNLEdBQUcsU0FBVCxNQUFTLENBQUMsRUFBRCxFQWNWO01BYkcsWTtNQUNBLG9CO01BQ0E7QUFDQSw4QjtNQUNBLHNCO01BQ0EsNEI7TUFDQSw0QjtNQUNBLDBCO01BQ0Esd0I7TUFDQSxvQjtNQUNBLDRCO01BQ0Esd0I7TUFDQSxrQixDQUNILENBRUQ7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsZUFBTyxJQUFQLENBQXZCLENBSEMsQ0FHbUM7O0FBQ3BDLGdCQUFjLENBQUMsT0FBZixHQUF5QixnQkFBUTtBQUM3QixXQUFPO0FBQ0gsU0FBRyxLQURBO0FBRUgsYUFBTyxTQUZKO0FBR0g7QUFDQSxpQkFBVyxhQUpSO0FBS0gsY0FBUSxVQUxMO0FBTUgsaUJBQVcsYUFOUjtBQU9ILGlCQUFXLGFBUFI7QUFRSCxnQkFBVSxZQVJQO0FBU0gsZUFBUyxXQVROO0FBVUgsYUFBTyxTQVZKO0FBV0gsaUJBQVc7QUFYUixLQUFQO0FBWUYsR0FidUIsRUFhdEIsQ0FDQyxHQURELEVBRUMsT0FGRCxFQUdDO0FBQ0EsYUFKRCxFQUtDLFFBTEQsRUFNQyxX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bEQsR0FBMkQsSUFSaEUsQ0FqQkosQ0FYRyxDQUFQO0FBMkNILENBeDNDRCxDLENBdzNDRTs7O0FBR0YscUJBQWUsTUFBZiIsImZpbGUiOiIuL3NyYy9jcmFkbGUudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gY3JhZGxlLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVE9ETzpcblxuICAgIGluIGhvcml6b250YWwgbW9kZSwgcmFwaWQgc2Nyb2xsIHRvIHJpZ2h0IHNvbWV0aW1lcyBsZWFkcyB0byB3cm9uZyBwbGFjZW1lbnQgb2Ygc3BpbmVcblxuICAgIGZvciByZXNpemUsIHByZXNlcnZlIGNhY2hlIGZvciByZWxvYWRcblxuICAgIGZpeCBzcGluZSBsb2NhdGlvbiBhbm9tYWxpZXMgYXQgZnJvbnQgYW5kIGJhY2suXG5cbiAgICByZXNpemluZyBpcyB0cmlnZ2VyZWQgdHdpY2Ugb24gc2V0dXAgYW5kIHByb2JhYmx5IHNob3VsZG4ndCBiZVxuXG4gICAgcmVwbGFjZSBzYWZhcmkgdGVzdCB3aXRoIG5hdGl2ZSBvYnNlcnZlciB0ZXN0IGluIGNyYWRsZWZ1bmN0aW9uc1xuXG4gICAgc29tZXRpbWVzIHdoZW4gcmVhY2hpbmcgZW5kIG9mIGxpc3QgYnkgcmVwb3NpdGlvbmluZywgdGhlIHNwaW5lIGlzIG9uZSByb3cgaGlnaGVyIHRoYW4gZGVzaWduZS4gXG4gICAgUmFyZSwgdGhlcmVmb3JlIHByb2JhYmx5aCByb3VuZGluZyBzb21ld2hlcmUgdG8gdG8gd2l0aCByZWZlcmVuY2VpbmRleFxuXG4gICAgb2NjYXNpb25hbGx5IG9uIGZpcnN0IHZlcnRpY2FsIHNjcm9sbCB0aGUgaXRlbW9ic2VydmVyIGZhaWxzIChzb21ldGltZXMgYWZ0ZXIgYSBmZXcgc2Nyb2xscylcbiAgICBzZWVtcyB0byBnZXQgYmVoaW5kIGluIHByb2Nlc3NpbmcgYW5kIHRoZW4gbG9zZSBwb3NpdGlvbmluZyBmb3Igbm90aWZpY2F0aW9ucy5cblxuICAgIGxpc3Rpc2l6ZSBvdmVyc2hvb3RzIG9uIHJhcGlkIHNjcm9sbCB0byBlbmRcblxuICAgIHNvbWV0aW1lcyBwYWRkaW5nIGF0IGJvdHRvbSBpcyB0b28gaGlnaCAoZG91YmxlKVxuXG4gICAgY2FuJ3QgbW91bnQgZXJyb3IgaW4gbmVzdGVkIGxpc3RzXG5cbiAgICAqKipmb2xkIGlzIHNvbWV0aW1lcyB3YXl3b3JkIG9uIHNjcm9sbCB0byB1cHBlciBsaW1pdFxuXG4gICAgY3JlYXRlIGNyYWRsZUNvbmZpZyB2YXIgZm9yIHN0YWJsZSB0aGluZ3MgbGlrZSBudW1iZXIgb2YgY3JhZGxlIGFuZCB2aWV3cG9ydCByb3dzXG5cbiAgICBEZWJ1ZyBzY3JvbGxUb0l0ZW0gY2FsbGJhY2sgKGluY2x1ZGluZyBzZXR0aW5nIHNjcm9sbGZvcndhcmQgb24gZmlyc3QgYWN0aW9uKS5cbiAgICAgICAgbW90aW9uIHRha2VzIHBsYWNlIGJ1dCBnZXRzIGNsb3NlIHJhdGhlciB0aGFuIGV4YWN0LiBQb3NpdGlvbiBpcyBvZmYgYnkgcnVud2F5Y291bnRcblxuICAgIE1ha2Ugc3VyZSBpdGVtIHNoZWxsIHRyaWdnZXJzIGFyZSBvbmx5IGZpcmVkIGF0IHRoZSBsZWFkaW5nLCBub3QgdHJhaWxpbmcsIGVkZ2VcblxuICAgIEluY29uc2lzdGVuY3kgaW4gdmlld3BvcnRyb3dzLCBzb21ldGltZXMgTWF0aC5jZWlsLCBzb21ldGltZXMgTWF0aC5mbG9vclxuXG4gICAgY2hhbmdlIGhlaWdodCB0byAwcHggZnJvbSBhdXRvIGZvciBzcGluZSBpbiB2ZXJ0aWNhbFxuICAgIFxuICAgIHVwZGF0ZSBzY3JvbGxmb3J3YXJkIGxvZ2ljIHRvIHRha2UgaW50byBhY2NvdW50IHJhcGlkIG9wcG9zaXRlIHNjcm9sbGluZy4gXG4gICAgVXNlIGRpZmZlcmVuY2VzIGluIHNjcm9sbFRvcD9cblxuICAgID09Pj4gY2hlY2sgZ2V0U2hpZnQgbG9naWMuICFzY3JvbGxmb3J3YXJkIHNob3VsZCBzZWxlY3QgbmV4dCBjYWxjdWxhdGVkIGluZGV4IFxuICAgIHRvIGJlIGFib3ZlIHRoZSBmb2xkIGlmIHBvc3NpYmxlLlxuXG4gICAgcmV2aWV3IHJvdGF0ZSBzcGluZVJlZmVyZW5jZUluZGV4IHNldHRpbmdzXG4gICAgaW52ZXN0aWdhdGUgY2FzY2FkaW5nIGNhbGxzIHRvIG91dCBvZiBzY29wZSBjcmFkbGUsIGluIHJlbGF0aW9uIHRvIGl0ZW1zaGlmdFxuXG4gICAgUUEgZGVmZW5kIGFnYWluc3QgYnV0dGVyZmx5IGdldHRpbmcgaW50ZXJzZWN0aW9ucyBmcm9tIG9wcG9zaXRlIHNjcm9sbCBkaXJlY3Rpb25cbiAgICAgICAgYXMgdGhlIHJlc3VsdCBvZiBhIHNob3J0IHZpZXdwb3J0XG5cbiAgICBpbXBsZW1lbnQgc2Vzc2lvbmlkIHNjaGVtZSBmb3IgY2VsbCBjb250ZW50XG5cbiAgICBkZWFsIHdpdGggc3BpbmUgYmVpbmcgbm90aWZpZWQgYnkgYm90dG9tIGJvcmRlciByYXRoZXIgdGhhbiB0b3BcblxuICAgIHNwaW5lIGxvY2F0aW9uIG9jY2FzaW9uYWxseSBkb3duIGJ5IDEwID0gcGFkZGluZ1xuICAgIHNwaW5lUmVmZXJlbmNlSW5kZXggaXMgc29tZXRpbWVzIGxvY2F0ZWQgKHNwaW5lT2Zmc2V0KSBvdXRzaWRlIHRoZSB2aWV3cG9ydCAtLSBzaG91bGQgbmV2ZXIgaGFwcGVuXG5cbiovXG5cbi8qXG4gICAgRGVzY3JpcHRpb25cbiAgICAtLS0tLS0tLS0tLVxuICAgIFRoZSBHcmlkU3JvbGxlciBwcm92aWRlcyB0aGUgaWxsdXNpb24gb2YgaW5maW5pdGUgc2Nyb2xsaW5nIHRocm91Z2ggdGhlIHVzZSBvZiBhIGRhdGEgJ2NyYWRsZScgaW5zaWRlIGEgdmlld3BvcnQuXG4gICAgVGhlIGlsbHVzaW9uIGlzIG1haW50YWluZWQgYnkgc3luY2hyb25pemluZyBjaGFuZ2VzIGluIGNyYWRsZSBjb250ZW50IHdpdGggY3JhZGxlIGxvY2F0aW9uIGluc2lkZSBhIHNjcm9sbGJsb2NrLCBzdWNoXG4gICAgdGhhdCBhcyB0aGUgc2Nyb2xsYmxvY2sgaXMgbW92ZWQsIHRoZSBjcmFkbGUgbW92ZXMgb3Bwb3NpdGVseSBpbiB0aGUgc2Nyb2xsYmxvY2sgKHRvIHN0YXkgdmlzaWJsZSB3aXRoaW4gdGhlIHZpZXdwb3J0KS4gXG4gICAgVGhlIHNjcm9sbGJsb2NrIGlzIHNpemVkIHRvIGFwcHJveGltYXRlIHRoZSBsaXN0IGJlaW5nIHZpZXdlZCwgc28gYXMgdG8gaGF2ZSBhIHNjcm9sbCB0aHVtYiBzaXplIGFuZCBwb3NpdGlvbiB3aGljaCBcbiAgICByZWFsaXN0aWNhbGx5IHJlZmxlY3RzIHRoZSBzaXplIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBjcmFkbGUgaXMgY29udHJvbGxlZCBieSBhICdzcGluZScgd2hpY2ggaXMgYSAwcHggaGVpZ2h0L3dpZHRoIChhbG9uZyB0aGUgbWVkaWFsIC0gU2Nyb2xsQmxvY2sgY2FuIGJlIFxuICAgIHZlcnRpY3NsIG9yIGhvcml6b250YWwpLiBUaGUgcHVycG9zZSBvZiB0aGUgc3BpbmUgaXMgdG8gYWN0IGFzIGEgJ2ZvbGQnLCBhYm92ZSB3aGljaCBjZWxsIGNvbnRlbnQgZXhwYW5kcyAndXB3YXJkcycsIGFuZCBcbiAgICBiZWxvdyB3aGljaCB0aGUgY2VsbCBjb250ZW50IGV4cGFuZHMgICdkb3dud2FyZHMnLiBHcmlkU2Nyb2xsZXIgY2FuIGJlIHZpZXdlZCB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseS4gV2hlbiBob3Jpem9udGFsLCBcbiAgICB0aGUgc3BpbmUgaGFzIGEgMHB4IHdpZHRoLCBzbyB0aGF0IHRoZSAnZm9sZCcgaXMgdmVydGljYWwsIGFuZCBjZWxscyBleHBhbmQgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0LlxuXG4gICAgVGhlIHNwaW5lIGlzIGNvbnRyb2xsZWQgdG8gYWx3YXlzIGJlIGluIHRoZSBhdCB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSBsZWFkaW5nIGNlbGxyb3cgb2YgdGhlIHZpZXdwb3J0LiBUaHVzXG4gICAgaW4gdmVydGljYWwgb3JpZW50YXRpb24sIHRoZSBzcGluZSAndG9wJyBjc3MgYXR0cmlidXRlIGlzIGFsd2F5cyBlcXVhbCB0byB0aGUgJ3Njcm9sbFRvcCcgcG9zaXRpb24gb2YgdGhlIHNjcm9sbGJsb2NrLFxuICAgIHBsdXMgYW4gYWRqdXN0bWVudC4gVGhlIGFkanVzdG1lbnQgaXMgdGhlIHJlc3VsdCBvZiB0aGUgYWxpZ25tZW50IG9mIHRoZSBzcGluZSBpbiByZWxhdGlvbiB0byB0aGUgdG9wLShvciBsZWZ0LSltb3N0IGNlbGxcbiAgICBpbiB0aGUgdmlld3BvcnQgKHRoZSAncmVmZXJlbmNlJyByb3cpLiBUaGUgc3BpbmUgY2FuIG9ubHkgYmUgcGxhY2VkIGF0IHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIGZpcnN0IHZpc2libGVcbiAgICBjZWxsIGluIHRoZSB2aWV3cG9ydC4gVGhlcmVmb3JlIHRoZSBzcGluZSBvZmZzZXQgZnJvbSB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB2aWV3cG9ydCBjYW4gYmUgYW55d2hlcmUgZnJvbSBtaW51cyB0b1xuICAgIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVhZGluZyByb3cuIFRoZSBleGFjdCBhbW91bnQgZGVwZW5kcyBvbiB3aGVyZSB0aGUgJ2JyZWFrcG9pbnQnIG9mIHRyYW5zaXRpb24gbm90aWZpY2F0aW9uIGlzIHNldCBmb3JcbiAgICBjZWxscyBjcm9zc2luZyB0aGUgdmlld3BvcnQgdGhyZXNob2xkIChhbmQgY2FuIGJlIGNvbmZpZ3VyZWQpLiBUaGUgZGVmYXVsdCBvZiB0aGUgYnJlYWtwb2ludCBpcyAuNSAoaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBjZWxsKS5cblxuICAgIFRlY2huaWNhbGx5LCB0aGVyZSBhcmUgc2V2ZXJhbCByZWZlcmVuY2UgcG9pbnRzIHRyYWNrZWQgYnkgdGhlIEdyaWRTY3JvbGxlci4gVGhlc2UgYXJlOlxuICAgICAgICAtIHNwaW5lUmVmZXJlbmNlSW5kZXggKHRoZSB2aXJ0dWFsIGluZGV4IG9mIHRoZSBpdGVtIGNvbnRyb2xsaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3BpbmUpXG4gICAgICAgICAgICBUaGUgc3BpbmVSZWZlcmVuY2VJbmRleCBpcyBhbHNvIHVzZWQgdG8gYWxsb2NhdGUgaXRlbXMgYWJvdmUgKGxvd2VyIGluZGV4IHZhbHVlKSBhbmQgYmVsb3cgKHNhbWUgb3IgaGlnaGVyIGluZGV4IHZhbHVlKVxuICAgICAgICAgICAgdGhlIGZvbGRcbiAgICAgICAgLSBjcmFkbGVSZWZlcmVuY2VJbmRleCAodGhlIHZpcnR1YWwgaW5kZXggb2YgdGhlIGl0ZW0gZGVmaW5pbmcgdGhlIGxlYWRpbmcgYm91bmQgb2YgdGhlIGNyYWRsZSBjb250ZW50KVxuICAgICAgICAtIHNwaW5lT2Zmc2V0IChwaXhlbHMgLSBwbHVzIG9yIG1pbnVzIC0gdGhhdCB0aGUgc3BpbmUgaXMgcGxhY2VkIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydCdzIGxlYWRpbmcgZWRnZSkgXG4gICAgXG4gICAgVGhlc2UgcmVmZXJlbmNlIHBvaW50cyBhcmUgYXBwbGllZCB0byB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZXM6XG4gICAgICAgIC0gdGhlIHZpZXdwb3J0XG4gICAgICAgIC0gdGhlIHNjcm9sbGJsb2NrXG4gICAgICAgIC0gdGhlIGNyYWRsZSwgY29uc2lzdGluZyBvZlxuICAgICAgICAgICAgLSB0aGUgc3BpbmUgKGNvbnRhaW5zIGNyYWRsZSBoZWFkIGFuZCB0YWlsKVxuICAgICAgICAgICAgLSB0aGUgaGVhZCAoY29udGFpbnMgbGVhZGluZyBpdGVtcylcbiAgICAgICAgICAgIC0gdGhlIHRhaWwgKGNvbnRhaW5zIHRyYWlsaW5nIGl0ZW1zKVxuXG4gICAgU3RydWN0dXJlIGRldGFpbHM6XG4gICAgICAgIHRoZSBjcmFkbGUgY29udGVudCBjb25zaXN0cyBvZlxuICAgICAgICAtIHRoZSBudW1iZXIgb2Ygcm93cyB0aGF0IGFyZSB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCAoYWNjb3JkaW5nIHRvIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMpXG4gICAgICAgICAgICAtIHRoaXMgdHlwaWNhbGx5IGluY2x1ZGVzIG9uZSBwYXJ0aWFsbHkgdmlzaWJsZSByb3dcbiAgICAgICAgLSB0aGUgbnVtYmVyIG9mIHJ1bndheSByb3dzIHNwZWNpZmllZCBpbiB0aGUgcGFyYW1ldGVycywgdGltZXMgMiAob25lIGV0IGZvciB0aGUgaGVhZDsgb25lIGZvciB0aGUgdGFpbClcbiAgICAgICAgLSB0aGUgbnVtYmVyIG9mIGl0ZW1zIGlzIHRoZSBudW1iZXIgb2Ygcm93cyB0aW1lcyB0aGUgJ2Nyb3NzY291bnQnIHRoZSBsYXRlcmFsIG51bWJlciBvZiBjZWxscy4gXG4gICAgICAgIC0gdGhlIGxhc3Qgcm93IG1pZ2h0IGNvbnNpc3Qgb2YgZmV3ZXIgaXRlbXMgdGhhbiBjcm9zc2NvdW50LCB0byBtYXRjaCB0aGUgbWF4aW11bSBsaXN0c2l6ZVxuICAgICAgICAtIHRoZSBjcmFkbGVSb3djb3VudCAodmlzaWJsZSBkZWZhdWx0IHJvd3MgKyBydW53YXljb3VudCAqIDIpIGFuZCB2aWV3cG9pbnRSb3djb3VudCAodmlzYmxlIHJvd3M7dHlwaWNhbGwgb25lIHBhcnRpYWwpXG5cbiAgICBJdGVtIGNvbnRhaW5lcnM6XG4gICAgICAgIENsaWVudCBjZWxsIGNvbnRlbnQgaXMgY29udGFpbmVkIGluIEl0ZW1TaGVsbCdzLCB3aGljaCBhcmUgY29uZmlndXJlZCBhY2NvcmRpbmcgdG8gR3JpZFNjcm9sbGVyJ3MgaW5wdXQgcGFyYW1ldGVycy5cbiAgICAgICAgVGhlIEl0ZW1DZWxsJ3MgYXJlIGluIHR1cm4gY29udGFpbmVkIGluIENTUyBncmlkIHN0cnVjdHVyZXMuIFRoZXJlIGFyZSB0d28gZ3JpZCBzdHJ1Y3R1cmVzIC0gb25lIGluIHRoZSBjcmFkbGUgaGVhZCxcbiAgICAgICAgYW5kIG9uZSBpbiB0aGUgY3JhZGxlIHRhaWwuIEVhY2ggZ3JpZCBzdHJ1Y3R1cmUgaXMgYWxsb3dlZCB1bmlmb3JtIHBhZGRpbmcgYW5kIGdhcHMgLSBpZGVudGljYWwgYmV0d2VlbiB0aGUgdHdvLlxuXG4gICAgT3ZlcnNjcm9sbCBoYW5kbGluZzpcbiAgICAgICAgT3dpbmcgdG8gdGhlIHdlaWdodCBvZiB0aGUgY29kZSwgYW5kIHBvdGVudGlhbCByYXBpZGl0eSBvZiBzY3JvbGxpbmcsIHRoZXJlIGlzIGFuIG92ZXJzY3JvbGwgcHJvdG9jb2wuIFxuICAgICAgICBpZiB0aGUgb3ZlcnNjcm9sbCBpcyBzdWNoIHRoYXQgcGFydCBvZiB0aGUgY3JhZGxlIGlzIHN0aWxsIHdpdGhpbiB0aGUgdmlld3BvcnQgYm91bmRhcmllcywgdGhlbiB0aGUgb3ZlcnNjcm9sbFxuICAgICAgICBpcyBjYWxjdWxhdGVkIGFzIHRoZSBudW1iZXIgb2YgY2VsbCByb3dzIHRoYXQgd291bGQgZml0IChjb21wbGV0ZWx5IG9yIHBhcnRpYWxseSkgaW4gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgXG4gICAgICAgIHRoZSBjcmFkbGUgdGhhdCBpcyByZWNlZGluZyBmcm9tIGEgdmlld3BvcnQgZWRnZS4gXG5cbiAgICAgICAgSWYgdGhlIG92ZXJzaG9vdCBpcyBzdWNoIHRoYXQgdGhlIGNyYWRsZSBoYXMgZW50aXJlbHkgcGFzc2VkIG91dCBvZiB0aGUgdmlld3BvcnQsIHRoZSBHcmlkU2Nyb2xsZXIgZ29lcyBpbnRvICdSZXBvc2l0b2luaW5nJ1xuICAgICAgICBtb2RlLCBtZWFuaW5nIHRoYXQgaXQgdHJhY2tzIHJlbGF0aXZlIGxvY2F0aW9uIG9mIHRoZSBzcGluZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCwgYW5kIHJlcGFpbnRzIHRoZSBjcmFkbGUgYWNjcm9kaW5nIHRvXG4gICAgICAgIHRoaXMgcG9zaXRpb24gd2hlbiB0aGUgc2Nyb2xsaW5nIHN0b3BzLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL3ZpZXdwb3J0J1xuXG5pbXBvcnQgdXNlSXNNb3VudGVkIGZyb20gJ3JlYWN0LWlzLW1vdW50ZWQtaG9vaydcblxuaW1wb3J0IFJlc2l6ZU9ic2VydmVyUG9seWZpbGwgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJ1xuXG5jb25zdCBMb2NhbFJlc2l6ZU9ic2VydmVyID0gd2luZG93WydSZXNpemVPYnNlcnZlciddIHx8IFJlc2l6ZU9ic2VydmVyUG9seWZpbGxcblxuY29uc3QgSVRFTV9PQlNFUlZFUl9USFJFU0hPTEQgPSAxXG5cbmltcG9ydCB7IFxuICAgIHNldENyYWRsZUdyaWRTdHlsZXMsIFxuICAgIGdldFVJQ29udGVudExpc3QsIFxuICAgIGNhbGNIZWFkQW5kVGFpbENoYW5nZXMsXG4gICAgY2FsY0NvbnRlbnRTaGlmdHMsXG4gICAgY2FsY1Zpc2libGVJdGVtcywgXG4gICAgZ2V0U2Nyb2xsUmVmZXJlbmNlSW5kZXhEYXRhLFxuICAgIGdldENvbnRlbnRMaXN0UmVxdWlyZW1lbnRzLFxuICAgIC8vIGdldFNwaW5lUG9ydGFsT2Zmc2V0LFxuICAgIGlzb2xhdGVSZWxldmFudEludGVyc2VjdGlvbnMsXG4gICAgLy8gbm9ybWFsaXplQ3JhZGxlQW5jaG9ycyxcbiAgICBhbGxvY2F0ZUNvbnRlbnRMaXN0LFxuXG59IGZyb20gJy4vY3JhZGxlZnVuY3Rpb25zJ1xuXG5pbXBvcnQgU2Nyb2xsVHJhY2tlciBmcm9tICcuL3Njcm9sbHRyYWNrZXInXG5cbmNvbnN0IFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMID0gMjAwXG5cbmNvbnN0IENyYWRsZSA9ICh7IFxuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgLy8gcnVud2F5bGVuZ3RoLFxuICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgaW5kZXhPZmZzZXQsIFxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIFxuICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgIHN0eWxlcyxcbiAgICB9KSA9PiB7XG5cbiAgICAvLyBmdW5jdGlvbnMgYW5kIHN0eWxlcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICBjb25zdCBjcmFkbGVQcm9wc1JlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXNcbiAgICBjcmFkbGVQcm9wc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgZ2FwLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgLy8gcnVud2F5bGVuZ3RoLFxuICAgICAgICAgICAgcnVud2F5Y291bnQsIFxuICAgICAgICAgICAgbGlzdHNpemUsIFxuICAgICAgICAgICAgaW5kZXhPZmZzZXQsIFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgfX0sW1xuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgLy8gcnVud2F5bGVuZ3RoLFxuICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgaW5kZXhPZmZzZXQsIFxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIFxuICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgSU5JVElBTElaQVRJT04gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHV0aWxpdGVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpXG4gICAgY29uc3QgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZiA9IHVzZVJlZihmdW5jdGlvbnM/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spXG5cbiAgICBjb25zdCBpdGVtT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCkgLy8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICBjb25zdCBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY29udGV4dCBkYXRhIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB2aWV3cG9ydERhdGEgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcbiAgICBjb25zdCB2aWV3cG9ydERhdGFSZWYgPSB1c2VSZWYobnVsbClcbiAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudCA9IHZpZXdwb3J0RGF0YVxuXG4gICAgY29uc3QgW2NyYWRsZVN0YXRlLCBzYXZlQ3JhZGxlU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBjcmFkbGVTdGF0ZVJlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXNcbiAgICBjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID0gY3JhZGxlU3RhdGVcblxuICAgIC8vIGNvbnNvbGUubG9nKCdjcmFkbGVTdGF0ZScsIGNyYWRsZVN0YXRlKVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY29udHJvbCBmbGFncyBdLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgY29uc3QgY29udHJvbEZsYWdzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXI6IGZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyOmZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzOiBmYWxzZSxcbiAgICAgICAgaXNUYWlsQ3JhZGxlSW5WaWV3OnRydWUsXG4gICAgICAgIGlzSGVhZENyYWRsZUluVmlldzp0cnVlLFxuICAgICAgICBpc0NyYWRsZUluVmlldzp0cnVlLFxuICAgIH0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6YXRpb24gZWZmZWN0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vaW5pdGlhbGl6ZSBob3N0IGZ1bmN0aW9ucyBwcm9wZXJ0aWVzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9ucz8uaGFzT3duUHJvcGVydHkoJ3Njcm9sbFRvSXRlbScpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMuc2Nyb2xsVG9JdGVtID0gc2Nyb2xsVG9JdGVtXG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKGZ1bmN0aW9ucz8uaGFzT3duUHJvcGVydHkoJ2dldFZpc2libGVMaXN0JykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9ucy5nZXRWaXNpYmxlTGlzdCA9IGdldFZpc2libGVMaXN0XG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKGZ1bmN0aW9ucz8uaGFzT3duUHJvcGVydHkoJ2dldENvbnRlbnRMaXN0JykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9ucy5nZXRDb250ZW50TGlzdCA9IGdldENvbnRlbnRMaXN0XG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKGZ1bmN0aW9ucz8uaGFzT3duUHJvcGVydHkoJ3JlbG9hZCcpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMucmVsb2FkID0gcmVsb2FkXG4gICAgICAgIH1cblxuICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrUmVmLmN1cnJlbnQgPSBmdW5jdGlvbnM/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2tcblxuICAgIH0sW2Z1bmN0aW9uc10pXG5cbiAgICAvLyBpbml0aWFsaXplIHdpbmRvdyBzY3JvbGwgbGlzdGVuZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLG9uU2Nyb2xsKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQgJiYgdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLG9uU2Nyb2xsKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZWNvbmZpZ3VyYXRpb24gZWZmZWN0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0cmlnZ2VyIHJlc2l6aW5nIGJhc2VkIG9uIHZpZXdwb3J0IHN0YXRlXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZpZXdwb3J0RGF0YS5pc1Jlc2l6aW5nJywgdmlld3BvcnREYXRhLmlzUmVzaXppbmcpXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuICAgICAgICBpZiAodmlld3BvcnREYXRhLmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gey4uLnN0YWJsZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUl0ZW1PYnNlcnZlciA9IHRydWVcbiAgICAgICAgICAgIGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgICAgICBjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgY29udHJvbEZsYWdzUmVmLmN1cnJlbnQucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXNpemluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbXBsZXRlIHJlc2l6aW5nIG1vZGVcbiAgICAgICAgaWYgKCF2aWV3cG9ydERhdGEuaXNSZXNpemluZyAmJiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAncmVzaXppbmcnKSkge1xuXG4gICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3Jlc2l6ZScpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbdmlld3BvcnREYXRhLmlzUmVzaXppbmddKVxuXG4gICAgLy8gcmVsb2FkIGZvciBjaGFuZ2VkIHBhcmFtZXRlcnNcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICAvLyBsZXQgc3BpbmVvZmZzZXRcbiAgICAgICAgLy8gaWYgKGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAvLyAgICAgc3BpbmVvZmZzZXQgPSBzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudC5vZmZzZXRUb3AgLSB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQuc2Nyb2xsVG9wXG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBzcGluZW9mZnNldCA9IHNwaW5lQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50Lm9mZnNldExlZnQgLSB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQuc2Nyb2xsTGVmdFxuICAgICAgICAvLyB9XG5cbiAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gey4uLnN0YWJsZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50fVxuXG4gICAgICAgIGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LnBhdXNlSXRlbU9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAvLyBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcblxuICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlbG9hZCcpXG5cbiAgICB9LFtcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIF0pXG5cbiAgICAvLyB0cmlnZ2VyIHBpdm90IG9uIGNoYW5nZSBpbiBvcmllbnRhdGlvblxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCAhPSAnc2V0dXAnKSB7XG5cbiAgICAgICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5zdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgLy8gbGV0IG9yaWVudGF0aW9uID0gY3JhZGxlUHJvcHNSZWYuY3VycmVudC5vcmllbnRhdGlvblxuICAgICAgICAgICAgLy8gZ2V0IHByZXZpb3VzIHJhdGlvblxuICAgICAgICAgICAgbGV0IHByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoID0gKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP2NyYWRsZVByb3BzUmVmLmN1cnJlbnQuY2VsbFdpZHRoOmNyYWRsZVByb3BzUmVmLmN1cnJlbnQuY2VsbEhlaWdodFxuICAgICAgICAgICAgbGV0IHByZXZpb3VzU3BpbmVPZmZzZXQgPSBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQuc3BpbmVvZmZzZXRcblxuICAgICAgICAgICAgbGV0IHByZXZpb3VzcmF0aW8gPSBwcmV2aW91c1NwaW5lT2Zmc2V0L3ByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoXG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50Q2VsbFBpeGVsTGVuZ3RoID0gKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP2NyYWRsZVByb3BzUmVmLmN1cnJlbnQuY2VsbEhlaWdodDpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LmNlbGxXaWR0aFxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFNwaW5lT2Zmc2V0ID0gcHJldmlvdXNyYXRpbyAqIGN1cnJlbnRDZWxsUGl4ZWxMZW5ndGhcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gc2Nyb2xsUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQuc3BpbmVvZmZzZXQgPSBcbiAgICAgICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudC5zcGluZW9mZnNldCA9IE1hdGgucm91bmQoY3VycmVudFNwaW5lT2Zmc2V0KVxuXG4gICAgICAgICAgICBjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUl0ZW1PYnNlcnZlciA9IHRydWVcbiAgICAgICAgICAgIC8vIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcblxuICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjcmFkbGVDb250ZW50ID0gY3JhZGxlQ29udGVudFJlZi5jdXJyZW50XG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWwgPSBbXVxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRWaWV3ID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsVmlldyA9IFtdXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIE9QRVJBVElPTiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXNzaW9uIGRhdGEgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLSBjdXJyZW50IGxvY2F0aW9uIC0tIGZpcnN0IHRhaWwgdmlzaWJsZSBpdGVtIC0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHNjcm9sbFJlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZih7IC8vIGV4aXN0aW5nIG9yIGV4cGVjdGVkLCBtb25pdG9yZWQgdGhyb3VnaCBvblNjcm9sbFxuICAgICAgICBpbmRleDpNYXRoLm1pbihpbmRleE9mZnNldCwobGlzdHNpemUgLSAxKSkgfHwgMCxcbiAgICAgICAgc3BpbmVvZmZzZXQ6cGFkZGluZ1xuICAgIH0pIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuXG4gICAgLy8gc2V0IGJ5IG9uU2Nyb2xsIGF0IHRoZSBlbmQgb2Ygc2Nyb2xsIHNlc3Npb25zXG4gICAgY29uc3Qgc3RhYmxlUmVmZXJlbmNlSW5kZXhEYXRhUmVmID0gdXNlUmVmKHNjcm9sbFJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50KSBcblxuICAgIC8vIGFudGljaXBhdGUgY2FsbGluZyBvZiBvcGVyYXRpb24gd2hpY2ggcmVxdWlyZXMgUmVmZXJlbmNlSW5kZXggZGF0YVxuICAgIGNvbnN0IGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYgPSB1c2VSZWYoc3RhYmxlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQpIC8vIGFudGljaXBhdGUgcmVwb3NpdGlvblxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIGRhdGEgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFRPRE86IGNyZWF0ZSBhIGRhdGFtb2RlbCBvYmplY3QgZm9yIHRoaXM/XG4gICAgLy8gY3JhZGxlIGJ1dHRlcmZseSBodG1sIGNvbXBvbmVudHNcbiAgICBjb25zdCBoZWFkQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRhaWxDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3Qgc3BpbmVDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgY3JhZGxlRWxlbWVudHNSZWYgPSB1c2VSZWYoe2hlYWQ6aGVhZENyYWRsZUVsZW1lbnRSZWYsIHRhaWw6dGFpbENyYWRsZUVsZW1lbnRSZWYsIHNwaW5lOnNwaW5lQ3JhZGxlRWxlbWVudFJlZn0pXG5cbiAgICAvLyAvLyBkYXRhIG1vZGVsXG4gICAgLy8gY29uc3QgbW9kZWxDb250ZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gY29uc3QgaGVhZE1vZGVsQ29udGVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIGNvbnN0IHRhaWxNb2RlbENvbnRlbnRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIC8vIHZpZXcgbW9kZWxcbiAgICAvLyBjb25zdCBoZWFkVmlld0NvbnRlbnRSZWYgPSB1c2VSZWYoW10pXG4gICAgLy8gY29uc3QgdGFpbFZpZXdDb250ZW50UmVmID0gdXNlUmVmKFtdKVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGVudFJlZiA9IHVzZVJlZih7XG4gICAgICAgIGNyYWRsZU1vZGVsOiBudWxsLFxuICAgICAgICBoZWFkTW9kZWw6IG51bGwsXG4gICAgICAgIHRhaWxNb2RlbDogbnVsbCxcbiAgICAgICAgaGVhZFZpZXc6IFtdLFxuICAgICAgICB0YWlsVmlldzogW10sXG4gICAgfSlcblxuICAgIC8vIGl0ZW0gZWxlbWVudHMgY2FjaGUuLi5cbiAgICBjb25zdCBpdGVtRWxlbWVudHNSZWYgPSB1c2VSZWYobmV3IE1hcCgpKSAvLyBpdGVtcyByZWdpc3RlciB0aGVpciBlbGVtZW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNyYWRsZSBjb25maWd1cmF0aW9uIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHsgdmlld3BvcnREaW1lbnNpb25zIH0gPSB2aWV3cG9ydERhdGFcblxuICAgIGxldCB7IGhlaWdodDp2aWV3cG9ydGhlaWdodCx3aWR0aDp2aWV3cG9ydHdpZHRoIH0gPSB2aWV3cG9ydERpbWVuc2lvbnNcbiAgICBcbiAgICBjb25zdCBjcm9zc2NvdW50ID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgbGV0IGNyb3NzY291bnRcbiAgICAgICAgbGV0IHNpemUgPSAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKT92aWV3cG9ydGhlaWdodDp2aWV3cG9ydHdpZHRoXG4gICAgICAgIGxldCBjcm9zc0xlbmd0aCA9IChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpP2NlbGxIZWlnaHQ6Y2VsbFdpZHRoXG5cbiAgICAgICAgbGV0IGxlbmd0aGZvcmNhbGMgPSBzaXplIC0gKHBhZGRpbmcgKiAyKSArIGdhcCAvLyBsZW5ndGggb2Ygdmlld3BvcnRcbiAgICAgICAgbGV0IHRpbGVsZW5ndGhmb3JjYWxjID0gY3Jvc3NMZW5ndGggKyBnYXBcbiAgICAgICAgdGlsZWxlbmd0aGZvcmNhbGMgPSBNYXRoLm1pbih0aWxlbGVuZ3RoZm9yY2FsYyxsZW5ndGhmb3JjYWxjKSAvLyByZXN1bHQgY2Fubm90IGJlIGxlc3MgdGhhbiAxXG4gICAgICAgIGNyb3NzY291bnQgPSBNYXRoLmZsb29yKGxlbmd0aGZvcmNhbGMvKHRpbGVsZW5ndGhmb3JjYWxjKSlcbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICAvLyBjb25zdCBjcm9zc2NvdW50UmVmID0gdXNlUmVmKGNyb3NzY291bnQpIC8vIGZvciBlYXN5IHJlZmVyZW5jZSBieSBvYnNlcnZlclxuICAgIC8vIGNyb3NzY291bnRSZWYuY3VycmVudCA9IGNyb3NzY291bnQgLy8gYXZhaWxhYmxlIGZvciBvYnNlcnZlciBjbG9zdXJlXG5cbiAgICBjb25zdCBbY3JhZGxlUm93Y291bnQsdmlld3BvcnRSb3djb3VudF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIGxldCB2aWV3cG9ydExlbmd0aCwgY2VsbExlbmd0aFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSB2aWV3cG9ydGhlaWdodFxuICAgICAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdwb3J0TGVuZ3RoID0gdmlld3BvcnR3aWR0aFxuICAgICAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgY2VsbExlbmd0aCArPSBnYXBcblxuICAgICAgICBsZXQgdmlld3BvcnRyb3djb3VudCA9IE1hdGguY2VpbCh2aWV3cG9ydExlbmd0aC9jZWxsTGVuZ3RoKVxuICAgICAgICBsZXQgY3JhZGxlcm93Y291bnQgPSB2aWV3cG9ydHJvd2NvdW50ICsgKHJ1bndheWNvdW50ICogMilcbiAgICAgICAgbGV0IGl0ZW1jb3VudCA9IGNyYWRsZXJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgICAgICBpZiAoaXRlbWNvdW50ID4gbGlzdHNpemUpIHtcbiAgICAgICAgICAgIGl0ZW1jb3VudCA9IGxpc3RzaXplXG4gICAgICAgICAgICBjcmFkbGVyb3djb3VudCA9IE1hdGguY2VpbChpdGVtY291bnQvY3Jvc3Njb3VudClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NyYWRsZXJvd2NvdW50LCB2aWV3cG9ydHJvd2NvdW50XVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHJ1bndheWNvdW50LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgIF0pXG5cbiAgICAvLyBjb25zdCBjcmFkbGVSb3djb3VudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIGNyYWRsZVJvd2NvdW50UmVmLmN1cnJlbnQgPSBjcmFkbGVSb3djb3VudFxuICAgIC8vIGNvbnN0IHZpZXdwb3J0Um93Y291bnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB2aWV3cG9ydFJvd2NvdW50UmVmLmN1cnJlbnQgPSB2aWV3cG9ydFJvd2NvdW50XG5cbiAgICBjb25zdCBjcmFkbGVDb25maWdSZWYgPSB1c2VSZWYoe1xuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCxcbiAgICAgICAgaXRlbU9ic2VydmVyVGhyZXNob2xkOklURU1fT0JTRVJWRVJfVEhSRVNIT0xELFxuICAgIH0pXG5cbiAgICBjcmFkbGVDb25maWdSZWYuY3VycmVudCA9IHtcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIGl0ZW1PYnNlcnZlclRocmVzaG9sZDpJVEVNX09CU0VSVkVSX1RIUkVTSE9MRCxcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjcmFkbGUgZGVmYXVsdCBzdHlsZXNdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gYmFzZSBzdHlsZXNcbiAgICBsZXQgY3JhZGxlSGVhZFN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAwXG4gICAgICAgICAgICBsZWZ0ID0gMFxuICAgICAgICAgICAgcmlnaHQgPSAwXG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi57XG5cbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYWxpZ25Db250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcywuLi5zdHlsZXM/LmNyYWRsZX1cblxuICAgIH0sW1xuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgXSlcblxuICAgIGxldCBjcmFkbGVUYWlsU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBsZXQgYm90dG9tLCBsZWZ0LCB0b3AsIHJpZ2h0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9ICdhdXRvJ1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gMFxuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0b3AgPSAwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gey4uLntcblxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdibHVlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBhbGlnbkNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG5cbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLC4uLnN0eWxlcz8uY3JhZGxlfVxuXG4gICAgfSxbXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICBdKVxuXG4gICAgLy8gcmVkdW5kYW50XG4gICAgbGV0IGNyYWRsZVNwaW5lU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBsZXQgc3R5bGVvYmo6UmVhY3QuQ1NTUHJvcGVydGllcyA9IHtcblxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZW9ialxuXG4gICAgfSxbXG5cbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgb3JpZW50YXRpb24sXG5cbiAgICBdKVxuXG4gICAgLy8gZW5oYW5jZWQgc3R5bGVzIGZvciBncmlkXG4gICAgY29uc3QgW2hlYWRzdHlsZSwgdGFpbHN0eWxlLCBzcGluZXN0eWxlXSA9IHVzZU1lbW8oKCk9PiB7XG4gICAgICAgIC8vIG1lcmdlIGJhc2Ugc3R5bGUgYW5kIHJldmlzaW9ucyAoYnkgb2JzZXJ2ZXIpXG4gICAgICAgIGxldCBoZWFkQ3JhZGxlU3R5bGVzOlJlYWN0LkNTU1Byb3BlcnRpZXMgPSB7Li4uY3JhZGxlSGVhZFN0eWxlfVxuICAgICAgICBsZXQgdGFpbENyYWRsZVN0eWxlczpSZWFjdC5DU1NQcm9wZXJ0aWVzID0gey4uLmNyYWRsZVRhaWxTdHlsZX1cbiAgICAgICAgbGV0IFtoZWFkc3R5bGVzLCB0YWlsc3R5bGVzXSA9IHNldENyYWRsZUdyaWRTdHlsZXMoe1xuXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBoZWFkQ3JhZGxlU3R5bGVzLCBcbiAgICAgICAgICAgIHRhaWxDcmFkbGVTdHlsZXMsIFxuICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICAgICAgdmlld3BvcnR3aWR0aCwgXG5cbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0b3AgPSBwYWRkaW5nICsgJ3B4J1xuICAgICAgICAgICAgbGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9ICdhdXRvJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBsZWZ0ID0gcGFkZGluZyArICdweCdcbiAgICAgICAgICAgIHdpZHRoID0gMFxuICAgICAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3BpbmVzdHlsZSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcblxuICAgICAgICByZXR1cm4gW2hlYWRzdHlsZXMsIHRhaWxzdHlsZXMsIHNwaW5lc3R5bGVdXG5cbiAgICB9LFtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuXG4gICAgICBdKVxuXG4gICAgY3JhZGxlSGVhZFN0eWxlID0gaGVhZHN0eWxlXG4gICAgY3JhZGxlVGFpbFN0eWxlID0gdGFpbHN0eWxlXG4gICAgY3JhZGxlU3BpbmVTdHlsZSA9IHNwaW5lc3R5bGVcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIEludGVyc2VjdGlvbk9ic2VydmVyIHN1cHBvcnRdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLypcbiAgICAgICAgVGhlcmUgYXJlIHR3byBpbnRlcmVjdGlvbiBvYnNlcnZlcnMsIG9uZSBmb3IgdGhlIGNyYWRsZSwgYW5kIGFub3RoZXIgZm9yIGl0ZW1TaGVsbHM7IFxuICAgICAgICAgICAgYm90aCBhZ2FpbnN0IHRoZSB2aWV3cG9ydC5cbiAgICAgICAgVGhlcmUgaXMgYWxzbyBhIHJlc2l6ZSBvYnNlcnZlciBmb3IgdGhlIGNyYWRsZSB3aW5ncywgdG8gcmVzcG9uZCB0byBzaXplIGNoYW5nZXMgb2YgXG4gICAgICAgICAgICB2YXJpYWJsZSBjZWxscy5cbiAgICAqLyAgICBcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjcmFkbGUgb2JzZXJ2ZXJzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gc2V0IHVwIGNyYWRsZSByZXNpemVvYnNlcnZlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXJcbiAgICAgICAgY3JhZGxlUmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBMb2NhbFJlc2l6ZU9ic2VydmVyKGNyYWRsZXJlc2l6ZW9ic2VydmVyY2FsbGJhY2spXG5cbiAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZC5jdXJyZW50KVxuICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoY3JhZGxlRWxlbWVudHMudGFpbC5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IGNyYWRsZXJlc2l6ZW9ic2VydmVyY2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcykgPT4ge1xuXG4gICAgICAgIGlmIChjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyKSByZXR1cm5cblxuICAgIH0sW10pXG5cbiAgICAvLyB0aGlzIHNldHMgdXAgYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgb2YgdGhlIGNyYWRsZSBhZ2FpbnN0IHRoZSB2aWV3cG9ydC4gV2hlbiB0aGVcbiAgICAvLyBjcmFkbGUgZ29lcyBvdXQgb2YgdGhlIG9ic2VydmVyIHNjb3BlLCB0aGUgXCJyZXBvc2l0aW9uaW5nXCIgY3JhZGxlIHN0YXRlIGlzIHRyaWdnZXJkLlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0RGF0YSA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50XG4gICAgICAgIC8vIEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICAgIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdGlvbm9ic2VydmVyY2FsbGJhY2ssXG4gICAgICAgICAgICB7cm9vdDp2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50LCB0aHJlc2hvbGQ6MH1cblxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZC5jdXJyZW50KVxuICAgICAgICBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoY3JhZGxlRWxlbWVudHMudGFpbC5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IGNyYWRsZWludGVyc2VjdGlvbm9ic2VydmVyY2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcykgPT4ge1xuXG4gICAgICAgIGxldCBjb250cm9sRmxhZ3MgPSBjb250cm9sRmxhZ3NSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChjb250cm9sRmxhZ3MucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlcikgcmV0dXJuXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0Lm5hbWUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbEZsYWdzLmlzSGVhZENyYWRsZUluVmlldyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xGbGFncy5pc1RhaWxDcmFkbGVJblZpZXcgPSBlbnRyeS5pc0ludGVyc2VjdGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xGbGFncy5pc0NyYWRsZUluVmlldyA9IChjb250cm9sRmxhZ3MuaXNIZWFkQ3JhZGxlSW5WaWV3IHx8IGNvbnRyb2xGbGFncy5pc1RhaWxDcmFkbGVJblZpZXcpXG5cbiAgICAgICAgaWYgKCFjb250cm9sRmxhZ3MuaXNDcmFkbGVJblZpZXcpIFxuXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IGNyYWRsZVN0YXRlID0gY3JhZGxlU3RhdGVSZWYuY3VycmVudCAgICAgICAgXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmlzUmVzaXppbmcgJiZcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXNpemUnKSAmJlxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmcnKSAmJiBcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uJykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncGl2b3QnKVxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmVsZW1lbnRyZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgIGxldCB7dG9wLCByaWdodCwgYm90dG9tLCBsZWZ0fSA9IHJlY3RcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LnZpZXdwb3J0RGltZW5zaW9ucyA9IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9IC8vIHVwZGF0ZSBmb3Igc2Nyb2xsdHJhY2tlclxuICAgICAgICAgICAgICAgIGNvbnRyb2xGbGFncy5wYXVzZUl0ZW1PYnNlcnZlciA9IHRydWVcbiAgICAgICAgICAgICAgICAvLyBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JFUE9TSVRJT05JTkcnKVxuICAgICAgICAgICAgICAgIGxldCBjcmFkbGVDb250ZW50ID0gY3JhZGxlQ29udGVudFJlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWwgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRWaWV3ID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxWaWV3ID0gW11cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmcnKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaXRlbSBzaGVsbCBvYnNlcnZlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICAgIFRoZSBjcmFkbGUgY29udGVudCBpcyBkcml2ZW4gYnkgbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlci5cbiAgICAgICAgLSBhcyB0aGUgdXNlciBzY3JvbGxzIHRoZSBjcmFkbGUsIHdoaWNoIGhhcyBhIHJ1bndheWNvdW50IGF0IGJvdGggdGhlIGxlYWRpbmdcbiAgICAgICAgICAgIGFuZCB0cmFpbGluZyBlZGdlcywgaXRlbVNoZWxscyBzY3JvbGwgaW50byBvciBvdXQgb2YgdGhlIHNjb3BlIG9mIHRoZSBvYnNlcnZlciBcbiAgICAgICAgICAgIChkZWZpbmVkIGJ5IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHZpZXdwb3J0ICsgdGhlIGxlbmd0aHMgb2YgdGhlIHJ1bndheXMpLiBUaGUgb2JzZXJ2ZXJcbiAgICAgICAgICAgIG5vdGlmaWVzIHRoZSBhcHAgKHRocm91Z2ggaXRlbW9ic2VydmVyY2FsbGJhY2soKSBiZWxvdykgYXQgdGhlIGNyb3NzaW5ncyBvZiB0aGUgaXRlbXNoZWxscyBcbiAgICAgICAgICAgIG9mIHRoZSBkZWZpbmVkIG9ic2VydmVyIGNyYWRsZSBib3VuZGFyaWVzLlxuXG4gICAgICAgICAgICBUaGUgbm8tbG9uZ2VyLWludGVyc2VjdGluZyBub3RpZmljYXRpb25zIHRyaWdnZXIgZHJvcHBpbmcgb2YgdGhhdCBudW1iZXIgb2YgYWZmZWN0ZWQgaXRlbXMgZnJvbSBcbiAgICAgICAgICAgIHRoZSBjcmFkbGUgY29udGVudGxpc3QuIFRoZSBkcm9wcGluZyBvZiBpdGVtcyBmcm9tIHRoZSB0cmFpbGluZyBlbmQgb2YgdGhlIGNvbnRlbnQgbGlzdFxuICAgICAgICAgICAgdHJpZ2dlcnMgdGhlIGFkZGl0aW9uIG9mIGFuIGVxdWFsIG51bWJlciBvZiBpdGVtcyBhdCB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSBjcmFkbGUgY29udGVudC5cblxuICAgICAgICAgICAgVGVjaG5pY2FsbHksIHRoZSBvcHBvc2l0ZSBlbmQgcG9zaXRpb24gc3BlYyBpcyBzZXQgKHRvcCBvciBsZWZ0IGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiksIFxuICAgICAgICAgICAgYW5kIHRoZSBtYXRjaGluZyBlbmQgcG9zaXRpb24gc3BlYyBpcyBzZXQgdG8gJ2F1dG8nIHdoZW4gaXRlbXMgYXJlIGFkZGVkLiBUaGlzIGNhdXNlcyBpdGVtcyB0byBiZSBcbiAgICAgICAgICAgIFwic3F1ZWV6ZWRcIiBpbnRvIHRoZSBsZWFkaW5nIG9yIHRyYWlsaW5nIGVuZHMgb2YgdGhlIHVpIGNvbnRlbnQgKG91dCBvZiB2aWV3KSBhcyBhcHByb3ByaWF0ZS5cblxuICAgICAgICAgICAgVGhlcmUgYXJlIGV4Y2VwdGlvbnMgZm9yIHNldHVwIGFuZCBlZGdlIGNhc2VzLlxuICAgICovXG5cbiAgICAvLyBjaGFuZ2Ugb3JpZW50YXRpb25cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGlmIChpdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCkgaXRlbU9ic2VydmVyUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpXG4gICAgICAgIGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuXG4gICAgICAgICAgICBpdGVtb2JzZXJ2ZXJjYWxsYmFjayxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb290OnZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmVsZW1lbnRyZWYuY3VycmVudCwgXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOmNyYWRsZUNvbmZpZ1JlZi5jdXJyZW50Lml0ZW1PYnNlcnZlclRocmVzaG9sZCxcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uXSlcblxuICAgIC8vIHRoZSBhc3luYyBjYWxsYmFjayBmcm9tIEludGVyc2VjdGlvbk9ic2VydmVyLlxuICAgIGNvbnN0IGl0ZW1vYnNlcnZlcmNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpPT57XG5cbiAgICAgICAgbGV0IG1vdmVkZW50cmllcyA9IFtdXG5cbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkKSB7XG5cbiAgICAgICAgICAgICAgICBtb3ZlZGVudHJpZXMucHVzaChlbnRyeSlcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGVudHJ5LnRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkID0gdHJ1ZVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udHJvbEZsYWdzUmVmLmN1cnJlbnQucGF1c2VJdGVtT2JzZXJ2ZXIpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlzTW91bnRlZCgpICYmIHVwZGF0ZUNyYWRsZUNvbnRlbnQobW92ZWRlbnRyaWVzKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHByZXZpb3VzU2Nyb2xsRm9yd2FyZFJlZiA9IHVzZVJlZih1bmRlZmluZWQpXG5cbiAgICBjb25zdCB1cGRhdGVDcmFkbGVDb250ZW50ID0gKGVudHJpZXMsIHNvdXJjZSA9ICdub3RpZmljYXRpb25zJykgPT4ge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGluZyBjcmFkbGUgY29udGVudDogZW50cmllcy5sZW5ndGgsIHNvdXJjZScsIGVudHJpZXMubGVuZ3RoLCBzb3VyY2UpXG5cbiAgICAgICAgbGV0IHZpZXdwb3J0RGF0YSA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50XG4gICAgICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50XG4gICAgICAgIGxldCBjcmFkbGVQcm9wcyA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgc2Nyb2xsT2Zmc2V0XG4gICAgICAgIGlmIChjcmFkbGVQcm9wcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzY3JvbGxPZmZzZXQgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxPZmZzZXQgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICB9XG4gICAgICAgIGlmICggc2Nyb2xsT2Zmc2V0IDwgMCkgeyAvLyBmb3IgU2FmYXJpIGVsYXN0aWMgYm91bmNlIGF0IHRvcCBvZiBzY3JvbGxcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlQ3JhZGxlQ29udGVudCBzY3JvbGxPZmZzZXQnLCBzY3JvbGxPZmZzZXQpXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgc2Nyb2xsUG9zaXRpb25zID0gc2Nyb2xsUG9zaXRpb25zUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgc2Nyb2xsZm9yd2FyZFxuICAgICAgICBpZiAoc2Nyb2xsUG9zaXRpb25zLmN1cnJlbnQgPT0gc2Nyb2xsUG9zaXRpb25zLnByZXZpb3VzKSB7IC8vIGVkZ2UgY2FzZSBcblxuICAgICAgICAgICAgc2Nyb2xsZm9yd2FyZCA9IHByZXZpb3VzU2Nyb2xsRm9yd2FyZFJlZi5jdXJyZW50XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsZm9yd2FyZCA9IHNjcm9sbFBvc2l0aW9ucy5jdXJyZW50ID4gc2Nyb2xsUG9zaXRpb25zLnByZXZpb3VzXG4gICAgICAgICAgICBwcmV2aW91c1Njcm9sbEZvcndhcmRSZWYuY3VycmVudCA9IHNjcm9sbGZvcndhcmRcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIC8vIGluaXQgY2FsbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBsZXQgY3JhZGxlQ29udGVudCA9IGNyYWRsZUNvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICBsZXQgY3JhZGxlQ29uZmlnID0gY3JhZGxlQ29uZmlnUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgaXRlbUVsZW1lbnRzID0gaXRlbUVsZW1lbnRzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgbW9kZWxjb250ZW50bGlzdCA9IGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxcblxuICAgICAgICBsZXQgY3JhZGxlUmVmZXJlbmNlSW5kZXggPSBtb2RlbGNvbnRlbnRsaXN0WzBdLnByb3BzLmluZGV4XG5cbiAgICAgICAgbGV0IHsgY3JhZGxlUm93Y291bnQsIGNyb3NzY291bnQgfSA9IGNyYWRsZUNvbmZpZ1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGZpbHRlciBpbnRlcnNlY3Rpb25zIGxpc3QgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbmFwcGxpY2FibGUgaW50ZXJzZWN0aW9uIGVudHJpZXNcbiAgICAgICAgLy8gd2UncmUgb25seSBpbnRlcmVzdGVkIGluIGludGVyc2VjdGlvbnMgcHJveGltYWwgdG8gdGhlIHNwaW5lXG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb25zID0gaXNvbGF0ZVJlbGV2YW50SW50ZXJzZWN0aW9ucyh7XG5cbiAgICAgICAgICAgIHNjcm9sbGZvcndhcmQsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zOmVudHJpZXMsXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50LFxuICAgICAgICAgICAgaXRlbU9ic2VydmVyVGhyZXNob2xkOmNyYWRsZUNvbmZpZy5pdGVtT2JzZXJ2ZXJUaHJlc2hvbGQsXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50ZXJzZWN0aW9ucycsIGludGVyc2VjdGlvbnMpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIENhbGN1bGF0ZSBzaGlmdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgW2NyYWRsZWluZGV4LCBcbiAgICAgICAgICAgIGNyYWRsZWl0ZW1zaGlmdCwgXG4gICAgICAgICAgICBzcGluZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIHJlZmVyZW5jZWl0ZW1zaGlmdCxcbiAgICAgICAgICAgIHNwaW5lT2Zmc2V0LCBcbiAgICAgICAgICAgIGNvbnRlbnRDb3VudF0gPSBjYWxjQ29udGVudFNoaWZ0cyh7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQcm9wcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVDb25maWcsXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaXRlbUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZm9yd2FyZCxcblxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChyZWZlcmVuY2VpdGVtc2hpZnQgPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbiB1cGRhdGVDcmFkbGVDb250ZW50OiBjcmFkbGVpbmRleCwgY3JhZGxlaXRlbXNoaWZ0LCBzcGluZVJlZmVyZW5jZUluZGV4LCByZWZlcmVuY2VpdGVtc2hpZnQsIHNwaW5lT2Zmc2V0LCBjb250ZW50Q291bnQsIGNyYWRsZUNvbmZpZycsXG4gICAgICAgICAvLyAgICAgY3JhZGxlaW5kZXgsIGNyYWRsZWl0ZW1zaGlmdCwgc3BpbmVSZWZlcmVuY2VJbmRleCwgcmVmZXJlbmNlaXRlbXNoaWZ0LCBzcGluZU9mZnNldCwgY29udGVudENvdW50LCBjcmFkbGVDb25maWcpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiBjYWxjdWxhdGUgaGVhZCBhbmQgdGFpbCBjb25zb2xpZGF0ZWQgY3JhZGxlIGNvbnRlbnQgY2hhbmdlcyBdLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgW2hlYWRjaGFuZ2Vjb3VudCx0YWlsY2hhbmdlY291bnRdID0gY2FsY0hlYWRBbmRUYWlsQ2hhbmdlcyh7XG5cbiAgICAgICAgICAgIGl0ZW1zaGlmdGNvdW50OmNyYWRsZWl0ZW1zaGlmdCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICBjcmFkbGVyb3djb3VudDpjcmFkbGVSb3djb3VudCwgLy8gVE9ETzogYWxpZ24gY2FzZSB1c2FnZVxuICAgICAgICAgICAgaGVhZGNvbnRlbnQ6Y3JhZGxlQ29udGVudC5oZWFkTW9kZWwsXG4gICAgICAgICAgICB0YWlsY29udGVudDpjcmFkbGVDb250ZW50LnRhaWxNb2RlbCxcbiAgICAgICAgICAgIHNjcm9sbGZvcndhcmQsXG4gICAgICAgICAgICBjcmFkbGVQcm9wcyxcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hlYWRjaGFuZ2Vjb3VudCx0YWlsY2hhbmdlY291bnQnLGhlYWRjaGFuZ2Vjb3VudCx0YWlsY2hhbmdlY291bnQpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNS4gcmVjb25maWd1cmUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY29sbGVjdCBtb2RpZmllZCBjb250ZW50XG4gICAgICAgIGxldCBsb2NhbENvbnRlbnRMaXN0IFxuXG4gICAgICAgIGlmIChoZWFkY2hhbmdlY291bnQgfHwgdGFpbGNoYW5nZWNvdW50KSB7XG5cbiAgICAgICAgICAgIGxvY2FsQ29udGVudExpc3QgPSBnZXRVSUNvbnRlbnRMaXN0KHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdDptb2RlbGNvbnRlbnRsaXN0LFxuICAgICAgICAgICAgICAgIGhlYWRjaGFuZ2Vjb3VudCxcbiAgICAgICAgICAgICAgICB0YWlsY2hhbmdlY291bnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICAgICAgY3JhZGxlUHJvcHMsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrczpjYWxsYmFja3NSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50OmNyYWRsZUNvbmZpZy5jcm9zc2NvdW50LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdCA9IG1vZGVsY29udGVudGxpc3RcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2xvY2FsQ29udGVudExpc3QubGVuZ3RoJywgbG9jYWxDb250ZW50TGlzdC5sZW5ndGgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNy4gYWxsb2NhdGUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IFtoZWFkY29udGVudCwgdGFpbGNvbnRlbnRdID0gYWxsb2NhdGVDb250ZW50TGlzdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdDpsb2NhbENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgICAgIHNwaW5lUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGVhZGNvbnRlbnQubGVuZ3RoLCB0YWlsY29udGVudC5sZW5ndGgnLGhlYWRjb250ZW50Lmxlbmd0aCwgdGFpbGNvbnRlbnQubGVuZ3RoKVxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWwgPSBsb2NhbENvbnRlbnRMaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZFZpZXcgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbCA9IGhlYWRjb250ZW50XG4gICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbFZpZXcgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbCA9IHRhaWxjb250ZW50XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgOC4gc2V0IGNzcyBjaGFuZ2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaWYgKHNwaW5lT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsUG9zaXRpb25EYXRhUmVmLmN1cnJlbnQgPSB7cHJvcGVydHk6J3Njcm9sbFRvcCcsdmFsdWU6dmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcH1cbiAgICAgICAgICAgICAgICBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50LnN0eWxlLnRvcCA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AgKyBzcGluZU9mZnNldCArICdweCdcbiAgICAgICAgICAgICAgICBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgICAgICBjcmFkbGVFbGVtZW50cy5oZWFkLmN1cnJlbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGhlYWRjb250ZW50Lmxlbmd0aD9jcmFkbGVQcm9wcy5nYXAgKyAncHgnOjBcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50ID0ge3Byb3BlcnR5OidzY3JvbGxMZWZ0Jyx2YWx1ZTp2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdH1cbiAgICAgICAgICAgICAgICBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnNwaW5lLmN1cnJlbnQuc3R5bGUubGVmdCA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0ICsgc3BpbmVPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMuaGVhZC5jdXJyZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGhlYWRjb250ZW50Lmxlbmd0aD9jcmFkbGVQcm9wcy5nYXAgKyAncHgnOjBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGluZGV4OnNwaW5lUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBzcGluZW9mZnNldDpzcGluZU9mZnNldFxuICAgICAgICB9XG5cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCd1cGRhdGVjb250ZW50JylcblxuICAgIH1cblxuICAgIC8vIEVuZCBvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciBzdXBwb3J0XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgQXNzZW1ibHkgb2YgY29udGVudF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBcbiAgICAvLyByZXNldCBjcmFkbGUsIGluY2x1ZGluZyBhbGxvY2F0aW9uIGJldHdlZW4gaGVhZCBhbmQgdGFpbCBwYXJ0cyBvZiB0aGUgY3JhZGxlXG4gICAgY29uc3Qgc2V0Q3JhZGxlQ29udGVudCA9IChjcmFkbGVTdGF0ZSwgcmVmZXJlbmNlSW5kZXhEYXRhKSA9PiB7IFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50IHN0YXJ0OiBjcmFkbGVTdGF0ZSwgcmVmZXJlbmNlSW5kZXhEYXRhJyxjcmFkbGVTdGF0ZSwgcmVmZXJlbmNlSW5kZXhEYXRhKVxuXG4gICAgICAgIGxldCBjcmFkbGVQcm9wcyA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnRcbiAgICAgICAgbGV0IHsgaW5kZXg6IHZpc2libGV0YXJnZXRpbmRleG9mZnNldCwgXG4gICAgICAgICAgICBzcGluZW9mZnNldDogdmlzaWJsZXRhcmdldHNjcm9sbG9mZnNldCB9ID0gcmVmZXJlbmNlSW5kZXhEYXRhXG5cbiAgICAgICAgbGV0IHtjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIG9yaWVudGF0aW9uLCBydW53YXljb3VudCwgZ2FwLCBwYWRkaW5nLCBsaXN0c2l6ZX0gPSBjcmFkbGVQcm9wc1xuXG4gICAgICAgIGxldCBjcmFkbGVDb25maWcgPSBjcmFkbGVDb25maWdSZWYuY3VycmVudFxuICAgICAgICBsZXQgeyBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICB2aWV3cG9ydFJvd2NvdW50IH0gPSBjcmFkbGVDb25maWdcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb24nKSB7XG5cbiAgICAgICAgICAgIHZpc2libGV0YXJnZXRzY3JvbGxvZmZzZXQgPSAodmlzaWJsZXRhcmdldGluZGV4b2Zmc2V0ID09IDApP3BhZGRpbmc6Z2FwXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb2NhbENvbnRlbnRMaXN0ID0gW10gLy8gYW55IGR1cGxpY2F0ZWQgaXRlbXMgd2lsbCBiZSByZS11c2VkIGJ5IHJlYWN0XG4gICAgICAgIGxldCBjcmFkbGVDb250ZW50ID0gY3JhZGxlQ29udGVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IHtjcmFkbGVSZWZlcmVuY2VJbmRleCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBzcGluZU9mZnNldCwgc3BpbmVhZGp1c3RtZW50fSA9IFxuICAgICAgICAgICAgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMoe1xuXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRSb3djb3VudCxcbiAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgICB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0Vmlld3BvcnRPZmZzZXQ6dmlzaWJsZXRhcmdldHNjcm9sbG9mZnNldCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudDp2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnRcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldENyYWRsZUNvbnRlbnQgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHM6IGNyYWRsZVJlZmVyZW5jZUluZGV4LCByZWZlcmVuY2VvZmZzZXQsIGNvbnRlbnRDb3VudCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0LCBzcGluZWFkanVzdG1lbnQnLFxuICAgICAgICAvLyAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsIHJlZmVyZW5jZW9mZnNldCwgY29udGVudENvdW50LCBzY3JvbGxibG9ja29mZnNldCwgc3BpbmVPZmZzZXQsIHNwaW5lYWRqdXN0bWVudClcblxuICAgICAgICAvLyByZXR1cm5zIGNvbnRlbnQgY29uc3RyYWluZWQgYnkgY3JhZGxlUm93Y291bnRcbiAgICAgICAgbGV0IGNoaWxkbGlzdCA9IGdldFVJQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50Q291bnQsXG4gICAgICAgICAgICBjcm9zc2NvdW50OmNyYWRsZUNvbmZpZy5jcm9zc2NvdW50LFxuICAgICAgICAgICAgLy8gY3JhZGxlaXRlbXNoaWZ0OjAsXG4gICAgICAgICAgICAvLyBjb250ZW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBoZWFkY2hhbmdlY291bnQ6MCxcbiAgICAgICAgICAgIHRhaWxjaGFuZ2Vjb3VudDpjb250ZW50Q291bnQsXG4gICAgICAgICAgICBjcmFkbGVQcm9wczpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGNhbGxiYWNrczpjYWxsYmFja3NSZWYuY3VycmVudCxcbiAgICAgICAgICAgIG9ic2VydmVyOiBpdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICB9KVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY2hpbGRsaXN0Lmxlbmd0aCwgY29udGVudENvdW50LCByb3dzIGZyb20gc2V0Q29udGVudCcsIGNoaWxkbGlzdC5sZW5ndGgsIGNvbnRlbnRDb3VudCwgTWF0aC5jZWlsKGNvbnRlbnRDb3VudC9jcm9zc2NvdW50KSlcblxuICAgICAgICBsZXQgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpjaGlsZGxpc3QsXG4gICAgICAgICAgICBzcGluZVJlZmVyZW5jZUluZGV4OnJlZmVyZW5jZW9mZnNldCxcbiAgICBcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aCwgdGFpbGNvbnRlbnRsaXN0Lmxlbmd0aCcsaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aCwgdGFpbGNvbnRlbnRsaXN0Lmxlbmd0aClcblxuICAgICAgICBpZiAoaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzcGluZU9mZnNldCA9IHBhZGRpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWwgPSBjaGlsZGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWwgPSBoZWFkY29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWwgPSB0YWlsY29udGVudGxpc3RcblxuICAgICAgICBzY3JvbGxSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IFxuICAgICAgICBzdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHtcblxuICAgICAgICAgICAgaW5kZXg6IHJlZmVyZW5jZW9mZnNldCxcbiAgICAgICAgICAgIHNwaW5lb2Zmc2V0OnNwaW5lT2Zmc2V0LFxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIGxldCBjc3RhdGUgPSBjcmFkbGVTdGF0ZVxuICAgICAgICAgICAgaWYgKGNzdGF0ZSA9PSAnc2V0cmVsb2FkJykgY3N0YXRlID0gJ3JlbG9hZCdcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudChcbiAgICAgICAgICAgICAgICBzdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudC5pbmRleCwgJ3NldENyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzY3JvbGxibG9ja29mZnNldCwgc3BpbmVPZmZzZXQsIHNwaW5lYWRqdXN0bWVudCcsXG4gICAgICAgIC8vICAgICBzY3JvbGxibG9ja29mZnNldCwgc3BpbmVPZmZzZXQsIHNwaW5lYWRqdXN0bWVudClcblxuICAgICAgICBsZXQgY3JhZGxlRWxlbWVudHMgPSBjcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zaXRpb25EYXRhUmVmLmN1cnJlbnQgPSB7cHJvcGVydHk6J3Njcm9sbFRvcCcsdmFsdWU6c2Nyb2xsYmxvY2tvZmZzZXQgIC0gc3BpbmVPZmZzZXR9XG5cbiAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnNwaW5lLmN1cnJlbnQuc3R5bGUudG9wID0gKHNjcm9sbGJsb2Nrb2Zmc2V0ICsgc3BpbmVhZGp1c3RtZW50KSArICdweCdcbiAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnNwaW5lLmN1cnJlbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMuaGVhZC5jdXJyZW50LnN0eWxlLnBhZGRpbmdCb3R0b20gPSBoZWFkY29udGVudGxpc3QubGVuZ3RoP2NyYWRsZVByb3BzLmdhcCArICdweCc6MFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NTUyBhZGp1c3RtZW50czogc2Nyb2xsVG9wLCBzY3JvbGxibG9ja29mZnNldCwgc3BpbmVPZmZzZXQsIHRvcCwgc3BpbmVhZGp1c3RtZW50JyxcbiAgICAgICAgICAgIC8vICAgICBzY3JvbGxibG9ja29mZnNldCAgLSBzcGluZU9mZnNldCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0LCBzY3JvbGxibG9ja29mZnNldCwgc2Nyb2xsYmxvY2tvZmZzZXQgKyBzcGluZWFkanVzdG1lbnQsIHNwaW5lYWRqdXN0bWVudCApXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgc2Nyb2xsUG9zaXRpb25EYXRhUmVmLmN1cnJlbnQgPSB7cHJvcGVydHk6J3Njcm9sbExlZnQnLHZhbHVlOnNjcm9sbGJsb2Nrb2Zmc2V0IC0gc3BpbmVPZmZzZXR9XG5cbiAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnNwaW5lLmN1cnJlbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50LnN0eWxlLmxlZnQgPSAoc2Nyb2xsYmxvY2tvZmZzZXQgKyBzcGluZWFkanVzdG1lbnQpICsgJ3B4J1xuICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMuaGVhZC5jdXJyZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGhlYWRjb250ZW50bGlzdC5sZW5ndGg/Y3JhZGxlUHJvcHMuZ2FwICsgJ3B4JzowXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIG1hbmFnZW1lbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxUaW1lcmlkUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbnNSZWYgPSB1c2VSZWYoe2N1cnJlbnQ6MCxwcmV2aW91czowfSlcblxuICAgIC8vIGNhbGxiYWNrIGZvciBzY3JvbGxpbmdcbiAgICBjb25zdCBvblNjcm9sbCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LnBhdXNlU2Nyb2xsaW5nRWZmZWN0cykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JldHVybmluZyBmcm9tIG9uU2Nyb2xsIHdpdGggcGF1c2VTY3JvbGxpbmdFZmZlY3RzIHRydWUnLCBcbiAgICAgICAgICAgIC8vICAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQuc2Nyb2xsVG9wKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50XG4gICAgICAgIGxldCBzY3JvbGxQb3NpdGlvbnMgPSBzY3JvbGxQb3NpdGlvbnNSZWYuY3VycmVudFxuXG4gICAgICAgIGxldCBzY3JvbGxQb3NpdGlvbmN1cnJlbnQgPSBcbiAgICAgICAgICAgIChjcmFkbGVQcm9wc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICA/dmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgOnZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uY3VycmVudCA8IDApIHsgLy8gZm9yIFNhZmFyaVxuXG4gICAgICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFBvc2l0aW9ucy5wcmV2aW91cyA9IHNjcm9sbFBvc2l0aW9ucy5jdXJyZW50XG4gICAgICAgIHNjcm9sbFBvc2l0aW9ucy5jdXJyZW50ID0gLy9zY3JvbGxQb3NpdGlvbmN1cnJlbnRcbiAgICAgICAgICAgIChjcmFkbGVQcm9wc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICA/dmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgOnZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyaWRSZWYuY3VycmVudClcblxuICAgICAgICBsZXQgY3JhZGxlU3RhdGUgPSBjcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGNyYWRsZUNvbnRlbnQgPSBjcmFkbGVDb250ZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIXZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWFkeScgfHwgY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmcnKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbWluZGV4ID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxbMF0/LnByb3BzLmluZGV4IFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbWluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUjogc2Nyb2xsIGVuY291bnRlcmVkIHVuZGVmaW5lZCB0YWlsY29udGVudCBsZWFkJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BpbmVvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcmFkbGVQcm9wc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbmVvZmZzZXQgPSBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50Lm9mZnNldFRvcCAtIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmVsZW1lbnRyZWYuY3VycmVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbmVvZmZzZXQgPSBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50Lm9mZnNldExlZnQgLSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6aXRlbWluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbmVvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSBnZXRTY3JvbGxSZWZlcmVuY2VJbmRleERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnREYXRhOnZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlUHJvcHM6Y3JhZGxlUHJvcHNSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzY291bnQ6Y3JhZGxlQ29uZmlnUmVmLmN1cnJlbnQuY3Jvc3Njb3VudCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCd1cGRhdGVyZXBvc2l0aW9uJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrUmVmLmN1cnJlbnQgJiYgXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudChzY3JvbGxSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudC5pbmRleCwnc2Nyb2xsaW5nJywgY3JhZGxlU3RhdGUpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsVGltZXJpZFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBjcmFkbGVTdGF0ZSA9IGNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIGlmICghdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIGxldCBsb2NhbHJlZmRhdGEgPSB7Li4uc2Nyb2xsUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnR9XG5cbiAgICAgICAgICAgICAgICBzdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IGxvY2FscmVmZGF0YVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nJzoge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5zdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ3JhZGxlQ29udGVudChbXSwgJ2VuZCBvZiBzY3JvbGwnKSAvLyBmb3IgU2FmYXJpIHRvIGNvbXBlbnNhdGUgZm9yIG92ZXJzY3JvbGxcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gZGF0YSBmb3Igc3RhdGUgcHJvY2Vzc2luZ1xuICAgIGNvbnN0IGNhbGxpbmdDcmFkbGVTdGF0ZSA9IHVzZVJlZihjcmFkbGVTdGF0ZVJlZi5jdXJyZW50KVxuICAgIGNvbnN0IGhlYWRsYXlvdXREYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb25EYXRhUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZVxuICAgIC8vIHVzZUxheW91dCBmb3Igc3VwcHJlc3NpbmcgZmxhc2hlc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGxldCB2aWV3cG9ydERhdGEgPSB2aWV3cG9ydERhdGFSZWYuY3VycmVudFxuICAgICAgICBsZXQgY3JhZGxlQ29udGVudCA9IGNyYWRsZUNvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdyZWxvYWQnOlxuICAgICAgICAgICAgICAgIC8vIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsID0gW11cbiAgICAgICAgICAgICAgICAvLyBjcmFkbGVDb250ZW50LnRhaWxNb2RlbCA9IFtdXG4gICAgICAgICAgICAgICAgLy8gY3JhZGxlQ29udGVudC5oZWFkVmlldyA9IFtdXG4gICAgICAgICAgICAgICAgLy8gY3JhZGxlQ29udGVudC50YWlsVmlldyA9IFtdXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXRyZWxvYWQnKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlcmVwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nJylcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZyc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NldHNjcm9sbG9mZnNldCc6IHtcblxuICAgICAgICAgICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50W3Njcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnByb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0c2Nyb2xsb2Zmc2V0Jywgc2Nyb2xsUG9zaXRpb25EYXRhUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdub3JtYWxpemUnKS8vJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC8vIH0pXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndXBkYXRlY29udGVudCc6IHsgLy8gc2Nyb2xsXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIGxldCBjcmFkbGVDb250ZW50ID0gY3JhZGxlQ29udGVudFJlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkVmlldyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsVmlldyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3NldHNjcm9sbG9mZnNldCcpLy8nbm9ybWFsaXplJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyBzdGFuZGFyZCBwcm9jZXNzaW5nIHN0YWdlc1xuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiBcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdwaXZvdCc6XG4gICAgICAgICAgICBjYXNlICdzZXRyZWxvYWQnOlxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG5cbiAgICAgICAgICAgICAgICBjYWxsaW5nQ3JhZGxlU3RhdGUuY3VycmVudCA9IGNyYWRsZVN0YXRlXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXR0bGUnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAnc2V0dGxlJzoge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldHRsZSAoc2V0Q3JhZGxlQ29udGVudCk6IHN0YXRlLCByZWZJbmRleCcsY2FsbGluZ0NyYWRsZVN0YXRlLmN1cnJlbnQsIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudClcblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbCA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkVmlldyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsVmlldyA9IFtdXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVDb250ZW50KGNhbGxpbmdDcmFkbGVTdGF0ZS5jdXJyZW50LCBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ2NvbnRlbnQnKS8vJ3NldHNjcm9sbG9mZnNldCcpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsaXplJzoge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2luc2lkZSBub3JtYWxpemU6IHZpZXdwb3J0RGF0YS5pc1Jlc2l6aW5nJywgdmlld3BvcnREYXRhLmlzUmVzaXppbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnREYXRhLmlzUmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZHVuZGFudCBzY3JvbGwgcG9zaXRpb24gdG8gYXZvaWQgYWNjaWRlbnRhbCBwb3NpdGlvbmluZyBhdCB0YWlsIGVuZCBvZiByZXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudCkgeyAvLyBhbHJlYWR5IHVubW91bnRlZCBpZiBmYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250cm9sRmxhZ3MgPSBjb250cm9sRmxhZ3NSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjbGVhcmluZyBjb250cm9sIEZsYWdzJywgY29udHJvbEZsYWdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbGFncy5wYXVzZUl0ZW1PYnNlcnZlciAgJiYgKGNvbnRyb2xGbGFncy5wYXVzZUl0ZW1PYnNlcnZlciA9IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbGFncy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgJiYgKGNvbnRyb2xGbGFncy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxhZ3MucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciAmJiAoY29udHJvbEZsYWdzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxhZ3MucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciAmJiAoY29udHJvbEZsYWdzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xGbGFnc1JlZi5jdXJyZW50LmlzQ3JhZGxlSW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWFkeScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVzaXppbmcnKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LDEwMClcblxuICAgICAgICAgICAgICAgIGJyZWFrIFxuXG4gICAgICAgICAgICB9ICAgICAgICAgIFxuXG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsbGJhY2tzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIG9uIGhvc3QgZGVtYW5kXG4gICAgY29uc3QgZ2V0VmlzaWJsZUxpc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG5cbiAgICAgICAgbGV0IGNyYWRsZUVsZW1lbnRzID0gY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBsZXQgY3JhZGxlQ29udGVudCA9IGNyYWRsZUNvbnRlbnRSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWxjVmlzaWJsZUl0ZW1zKHtcbiAgICAgICAgICAgIGl0ZW1FbGVtZW50TWFwOml0ZW1FbGVtZW50c1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50OnZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmVsZW1lbnRyZWYuY3VycmVudCxcbiAgICAgICAgICAgIGhlYWRFbGVtZW50OmNyYWRsZUVsZW1lbnRzLmhlYWQuY3VycmVudCwgXG4gICAgICAgICAgICAvLyB0YWlsRWxlbWVudDpjcmFkbGVQcm9wc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgc3BpbmVFbGVtZW50OmNyYWRsZUVsZW1lbnRzLnNwaW5lLmN1cnJlbnQsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjpjcmFkbGVQcm9wc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgaGVhZGxpc3Q6Y3JhZGxlQ29udGVudC5oZWFkVmlldyxcbiAgICAgICAgfSlcblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBnZXRDb250ZW50TGlzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgbGV0IGNvbnRlbnRsaXN0ID0gQXJyYXkuZnJvbShpdGVtRWxlbWVudHNSZWYuY3VycmVudClcblxuICAgICAgICBjb250ZW50bGlzdC5zb3J0KChhLGIpPT57XG4gICAgICAgICAgICByZXR1cm4gKGFbMF0gPCBiWzBdKT8tMToxXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRsaXN0XG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcblxuICAgICAgICBjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUl0ZW1PYnNlcnZlciA9IHRydWVcbiAgICAgICAgY29udHJvbEZsYWdzUmVmLmN1cnJlbnQucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuXG4gICAgICAgIGxldCBzcGluZW9mZnNldFxuICAgICAgICBsZXQgY3JhZGxlRWxlbWVudHMgPSBjcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc3BpbmVvZmZzZXQgPSBjcmFkbGVFbGVtZW50cy5zcGluZS5jdXJyZW50Lm9mZnNldFRvcCAtIHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmVsZW1lbnRyZWYuY3VycmVudC5zY3JvbGxUb3BcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwaW5lb2Zmc2V0ID0gY3JhZGxlRWxlbWVudHMuc3BpbmUuY3VycmVudC5vZmZzZXRMZWZ0IC0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LnNjcm9sbExlZnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5zdGFibGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGNvbnRlbnQgaXRlbSByZWdpc3RyYXRpb24gY2FsbGJhY2s7IGNhbGxlZCBmcm9tIGl0ZW1cbiAgICBjb25zdCBnZXRJdGVtRWxlbWVudERhdGEgPSB1c2VDYWxsYmFjaygoaXRlbUVsZW1lbnREYXRhLCByZXBvcnRUeXBlKSA9PiB7IC8vIGNhbmRpZGF0ZSB0byBleHBvcnRcblxuICAgICAgICBjb25zdCBbaW5kZXgsIHNoZWxscmVmXSA9IGl0ZW1FbGVtZW50RGF0YVxuXG4gICAgICAgIGlmIChyZXBvcnRUeXBlID09ICdyZWdpc3RlcicpIHtcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnRzUmVmLmN1cnJlbnQuc2V0KGluZGV4LHNoZWxscmVmKVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVwb3J0VHlwZSA9PSAndW5yZWdpc3RlcicpIHtcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnRzUmVmLmN1cnJlbnQuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBzY3JvbGxUb0l0ZW0gPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcblxuICAgICAgICBjb250cm9sRmxhZ3NSZWYuY3VycmVudC5wYXVzZUl0ZW1PYnNlcnZlciA9IHRydWVcbiAgICAgICAgY29udHJvbEZsYWdzUmVmLmN1cnJlbnQucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuXG4gICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHtpbmRleCxzcGluZW9mZnNldDowfVxuXG4gICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbicpXG5cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIGdldEVsZW1lbnREYXRhOmdldEl0ZW1FbGVtZW50RGF0YVxuICAgIH0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgUkVOREVSLi4uIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGNvbnN0IHNjcm9sbFRyYWNrZXJBcmdzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6dmlld3BvcnREaW1lbnNpb25zLnRvcCArIDMsXG4gICAgICAgICAgICBsZWZ0OnZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgMyxcbiAgICAgICAgICAgIGluZGV4T2Zmc2V0OnNjcm9sbFJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50LmluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemU6Y3JhZGxlUHJvcHNSZWYuY3VycmVudC5saXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlczpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LnN0eWxlcyxcbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0RGltZW5zaW9ucywgc2Nyb2xsUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQsIGNyYWRsZVByb3BzUmVmXSlcblxuICAgIGxldCBjcmFkbGVDb250ZW50ID0gY3JhZGxlQ29udGVudFJlZi5jdXJyZW50XG5cbiAgICByZXR1cm4gPD5cblxuICAgICAgICB7KGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3VwZGF0ZXJlcG9zaXRpb24nIHx8IGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3JlcG9zaXRpb25pbmcnKVxuICAgICAgICAgICAgPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHtzY3JvbGxUcmFja2VyQXJncy50b3B9IFxuICAgICAgICAgICAgICAgIGxlZnQgPSB7c2Nyb2xsVHJhY2tlckFyZ3MubGVmdH0gXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0ge3Njcm9sbFRyYWNrZXJBcmdzLmluZGV4T2Zmc2V0fSBcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHtzY3JvbGxUcmFja2VyQXJncy5saXN0c2l6ZX1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7c2Nyb2xsVHJhY2tlckFyZ3Muc3R5bGVzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDpudWxsfVxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlU3BpbmVTdHlsZX0gXG4gICAgICAgICAgICByZWYgPSB7c3BpbmVDcmFkbGVFbGVtZW50UmVmfVxuICAgICAgICAgICAgZGF0YS1uYW1lID0gJ3NwaW5lJ1xuICAgICAgICA+XG4gICAgICAgICAgICB7dHJ1ZT88ZGl2IHN0eWxlID0ge3t6SW5kZXg6MSwgcG9zaXRpb246J2Fic29sdXRlJyx3aWR0aDonMTAwJScsaGVpZ2h0OicxMDAlJyxib3hTaGFkb3c6JzAgMCA1cHggM3B4IHJlZCd9fT48L2Rpdj46bnVsbH1cbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhLW5hbWUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICByZWYgPSB7aGVhZENyYWRsZUVsZW1lbnRSZWZ9IFxuICAgICAgICAgICAgICAgIHN0eWxlID0ge2NyYWRsZUhlYWRTdHlsZX1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ICE9ICdzZXR1cCcpP2NyYWRsZUNvbnRlbnQuaGVhZFZpZXc6bnVsbH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS1uYW1lID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgcmVmID0ge3RhaWxDcmFkbGVFbGVtZW50UmVmfSBcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVUYWlsU3R5bGV9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHsoY3JhZGxlU3RhdGVSZWYuY3VycmVudCAhPSAnc2V0dXAnKT9jcmFkbGVDb250ZW50LnRhaWxWaWV3Om51bGx9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgPC8+XG5cbn0gLy8gQ3JhZGxlXG5cblxuZXhwb3J0IGRlZmF1bHQgQ3JhZGxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle.tsx\n");

/***/ }),

/***/ "./src/cradlefunctions.tsx":
/*!*********************************!*\
  !*** ./src/cradlefunctions.tsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // cradlefunctions.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/******************************************************************************************\n ------------------------------------[ SUPPORTING FUNCTIONS ]------------------------------\n*******************************************************************************************/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar itemshell_1 = __importDefault(__webpack_require__(/*! ./itemshell */ \"./src/itemshell.tsx\"));\n\nvar detect_browser_1 = __webpack_require__(/*! detect-browser */ \"./node_modules/detect-browser/es/index.js\");\n\nvar browser = detect_browser_1.detect();\n\nexports.calcVisibleItems = function (_a) {\n  var itemElementMap = _a.itemElementMap,\n      viewportElement = _a.viewportElement,\n      spineElement = _a.spineElement,\n      headElement = _a.headElement,\n      orientation = _a.orientation,\n      headlist = _a.headlist;\n  var itemlistindexes = Array.from(itemElementMap.keys());\n  itemlistindexes.sort(function (a, b) {\n    return a < b ? -1 : 1;\n  });\n  var headlistindexes = [];\n\n  for (var _i = 0, headlist_1 = headlist; _i < headlist_1.length; _i++) {\n    var item = headlist_1[_i];\n    headlistindexes.push(parseInt(item.props.index));\n  }\n\n  var list = [];\n  var cradleTop = headElement.offsetTop + spineElement.offsetTop,\n      cradleLeft = headElement.offsetLeft + spineElement.offsetLeft;\n  var scrollblockTopOffset = -viewportElement.scrollTop,\n      scrollblockLeftOffset = -viewportElement.scrollLeft,\n      viewportHeight = viewportElement.offsetHeight,\n      viewportWidth = viewportElement.offsetWidth,\n      viewportTopOffset = -scrollblockTopOffset,\n      viewportBottomOffset = -scrollblockTopOffset + viewportHeight;\n\n  for (var _b = 0, itemlistindexes_1 = itemlistindexes; _b < itemlistindexes_1.length; _b++) {\n    var index = itemlistindexes_1[_b];\n    var element = itemElementMap.get(index).current;\n    var inheadlist = headlistindexes.includes(index);\n    var top_1 = inheadlist ? element.offsetTop : (orientation == 'vertical' ? headElement.offsetHeight : 0) + element.offsetTop,\n        left = inheadlist ? element.offsetLeft : (orientation == 'horizontal' ? headElement.offsetWidth : 0) + element.offsetLeft,\n        width = element.offsetWidth,\n        height = element.offsetHeight,\n        right = left + width,\n        bottom = top_1 + height;\n    var itemTopOffset = scrollblockTopOffset + cradleTop + top_1,\n        // offset from top of viewport\n    itemBottomOffset = scrollblockTopOffset + cradleTop + bottom,\n        // offset from top of viewport\n    itemLeftOffset = scrollblockLeftOffset + cradleLeft + left,\n        itemRightOffset = scrollblockLeftOffset + cradleLeft + right;\n    var isVisible = false; // default\n\n    var topPortion = void 0,\n        bottomPortion = void 0,\n        leftPortion = void 0,\n        rightPortion = void 0;\n\n    if (itemTopOffset < 0 && itemBottomOffset > 0) {\n      orientation == 'vertical' && (isVisible = true);\n      bottomPortion = itemBottomOffset;\n      topPortion = bottomPortion - height;\n    } else if (itemTopOffset >= 0 && itemBottomOffset < viewportHeight) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = height;\n      bottomPortion = 0;\n    } else if (itemTopOffset > 0 && itemTopOffset - viewportHeight < 0) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = viewportHeight - itemTopOffset;\n      bottomPortion = topPortion - height;\n    } else {\n      if (orientation == 'vertical') continue;\n    }\n\n    if (itemLeftOffset < 0 && itemRightOffset > 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      rightPortion = itemRightOffset;\n      leftPortion = rightPortion - width;\n    } else if (itemLeftOffset >= 0 && itemRightOffset < viewportWidth) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = width;\n      rightPortion = 0;\n    } else if (itemLeftOffset > 0 && itemLeftOffset - viewportWidth < 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = viewportWidth - itemLeftOffset;\n      rightPortion = leftPortion - width;\n    } else {\n      if (orientation == 'horizontal') continue;\n    }\n\n    var verticalRatio = topPortion > 0 ? topPortion / height : bottomPortion / height,\n        horizontalRatio = leftPortion > 0 ? leftPortion / width : rightPortion / height;\n    var itemData = {\n      index: index,\n      isVisible: isVisible,\n      top: top_1,\n      right: right,\n      bottom: bottom,\n      left: left,\n      width: width,\n      height: height,\n      itemTopOffset: itemTopOffset,\n      itemBottomOffset: itemBottomOffset,\n      topPortion: topPortion,\n      bottomPortion: bottomPortion,\n      itemLeftOffset: itemLeftOffset,\n      itemRightOffset: itemRightOffset,\n      leftPortion: leftPortion,\n      rightPortion: rightPortion,\n      verticalRatio: verticalRatio,\n      horizontalRatio: horizontalRatio\n    };\n    list.push(itemData);\n  }\n\n  return list;\n};\n\nexports.getScrollReferenceIndexData = function (_a) {\n  var viewportData = _a.viewportData,\n      cradleProps = _a.cradleProps,\n      crosscount = _a.crosscount;\n  var viewportElement = viewportData.elementref.current;\n  var orientation = cradleProps.orientation,\n      listsize = cradleProps.listsize;\n  var scrollPos, cellLength;\n\n  if (orientation == 'vertical') {\n    scrollPos = viewportElement.scrollTop;\n    cellLength = cradleProps.cellHeight + cradleProps.gap;\n  } else {\n    scrollPos = viewportElement.scrollLeft;\n    cellLength = cradleProps.cellWidth + cradleProps.gap;\n  }\n\n  var referencescrolloffset = cellLength - scrollPos % cellLength;\n\n  if (referencescrolloffset == cellLength + cradleProps.padding) {\n    referencescrolloffset = 0;\n  }\n\n  var referencerowindex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n  var spineReferenceIndex = referencerowindex * crosscount;\n  spineReferenceIndex = Math.min(spineReferenceIndex, listsize - 1);\n  var diff = spineReferenceIndex % crosscount;\n  spineReferenceIndex -= diff;\n  var referenceIndexData = {\n    index: spineReferenceIndex,\n    spineoffset: referencescrolloffset\n  };\n  if (referenceIndexData.index == 0) referenceIndexData.spineoffset = 0; // defensive\n\n  return referenceIndexData;\n};\n\nexports.getContentListRequirements = function (_a) {\n  var _b;\n\n  var // called from setCradleContent only\n  orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      cradleRowcount = _a.cradleRowcount,\n      viewportRowcount = _a.viewportRowcount,\n      runwaycount = _a.runwaycount,\n      gap = _a.gap,\n      padding = _a.padding,\n      referenceoffset = _a.visibletargetindexoffset,\n      targetViewportOffset = _a.targetViewportOffset,\n      crosscount = _a.crosscount,\n      listsize = _a.listsize,\n      viewportElement = _a.viewportElement; // reconcile spineReferenceIndex to crosscount context\n\n  var diff = referenceoffset % crosscount;\n  referenceoffset -= diff; // -------------[ calc basic inputs: cellLength, contentCount. ]----------\n\n  var cellLength, viewportlength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellHeight + gap;\n    viewportlength = viewportElement.offsetHeight;\n  } else {\n    cellLength = cellWidth + gap;\n    viewportlength = viewportElement.offsetWidth;\n  } // let viewportrows = Math.floor(viewportlength / cellLength)\n\n\n  var viewportrows = viewportRowcount;\n  var contentCount = cradleRowcount * crosscount; // -----------------------[ calc leadingitemcount, referenceoffset ]-----------------------\n\n  var runwayitemcount = runwaycount * crosscount;\n  runwayitemcount = Math.min(runwayitemcount, referenceoffset); // for list head\n  // -----------------------[ calc cradleReferenceIndex ]------------------------\n  // leading edge\n\n  var cradleReferenceIndex = referenceoffset - runwayitemcount; // ------------[ adjust cradleReferenceIndex for underflow ]------------\n\n  diff = 0; // reset\n\n  var indexshift = 0; // adjustment if overshoot head\n\n  if (cradleReferenceIndex < 0) {\n    diff = cradleReferenceIndex;\n    indexshift = Math.floor(cradleReferenceIndex / crosscount) * crosscount;\n    cradleReferenceIndex += indexshift;\n  } // ------------[ adjust cradleReferenceIndex and contentCount for listsize overflow ]------------\n\n\n  var spineOffset = targetViewportOffset % cellLength; // --------------------[ calc css positioning ]-----------------------\n\n  var targetrowoffset = Math.ceil(referenceoffset / crosscount);\n  var scrollblockoffset = targetrowoffset * cellLength + padding; // gap\n\n  var spineadjustment;\n\n  if (targetrowoffset == 0) {\n    scrollblockoffset = 0;\n    spineOffset = 0; // padding\n\n    spineadjustment = padding;\n  } else {\n    spineadjustment = 0; //gap;\n\n    _b = adjustSpineOffsetForMaxRefindex({\n      referenceoffset: referenceoffset,\n      spineOffset: spineOffset,\n      scrollblockoffset: scrollblockoffset,\n      targetrowoffset: targetrowoffset,\n      viewportlength: viewportlength,\n      listsize: listsize,\n      viewportrows: viewportrows,\n      crosscount: crosscount,\n      cellLength: cellLength,\n      padding: padding,\n      gap: gap,\n      cradleReferenceIndex: cradleReferenceIndex,\n      contentCount: contentCount\n    }), cradleReferenceIndex = _b[0], contentCount = _b[1], referenceoffset = _b[2], scrollblockoffset = _b[3], spineOffset = _b[4];\n  } // debugger\n  // console.log('cradleReferenceIndex, referenceoffset, contentCount, scrollblockoffset, spineOffset, spineadjustment',\n  //     cradleReferenceIndex, referenceoffset, contentCount, scrollblockoffset, spineOffset, spineadjustment)\n\n\n  return {\n    cradleReferenceIndex: cradleReferenceIndex,\n    referenceoffset: referenceoffset,\n    contentCount: contentCount,\n    scrollblockoffset: scrollblockoffset,\n    spineOffset: spineOffset,\n    spineadjustment: spineadjustment\n  }; // summarize requirements message\n};\n\nvar adjustSpineOffsetForMaxRefindex = function adjustSpineOffsetForMaxRefindex(_a) {\n  var listsize = _a.listsize,\n      crosscount = _a.crosscount,\n      contentCount = _a.contentCount,\n      cradleReferenceIndex = _a.cradleReferenceIndex,\n      referenceoffset = _a.referenceoffset,\n      targetrowoffset = _a.targetrowoffset,\n      scrollblockoffset = _a.scrollblockoffset,\n      spineOffset = _a.spineOffset,\n      viewportlength = _a.viewportlength,\n      viewportrows = _a.viewportrows,\n      cellLength = _a.cellLength,\n      padding = _a.padding,\n      gap = _a.gap;\n  var activelistitemcount = cradleReferenceIndex + contentCount;\n  var activelistrowcount = Math.ceil(activelistitemcount / crosscount);\n  var listrowcount = Math.ceil(listsize / crosscount); // memos\n\n  var originalcradleoffset = cradleReferenceIndex;\n  var originalreferenceoffset = referenceoffset;\n  var originalspineOffset = spineOffset;\n\n  if (activelistrowcount > listrowcount) {\n    var diffrows = activelistrowcount - listrowcount;\n    var diff = diffrows * crosscount;\n    cradleReferenceIndex -= diff;\n    activelistrowcount -= diffrows; // console.log('cradlereference original, adjustment, rows, items, result', \n    // originalcradleoffset, diff, diffrows, cradleReferenceIndex)\n  } // let testlistrowcount = Math.ceil((cradleReferenceIndex + contentCount + 1)/crosscount)\n\n\n  if (activelistrowcount == listrowcount) {\n    var diff = listsize % crosscount;\n\n    if (diff) {\n      contentCount -= crosscount - diff;\n    } // console.log('final row adjustment through activelistrowcount, listrowcount, listsize, contentCount, crosscount, diff',\n    // activelistrowcount, listrowcount, listsize, contentCount, crosscount, diff)\n\n  }\n\n  var maxrefindexrow = Math.ceil(listsize / crosscount) - viewportrows + 1; // console.log('targetrowoffset, maxrefindexrow', targetrowoffset, maxrefindexrow)\n\n  if (targetrowoffset > maxrefindexrow) {\n    targetrowoffset = maxrefindexrow;\n    referenceoffset = targetrowoffset * crosscount;\n    scrollblockoffset = targetrowoffset * cellLength + gap;\n    spineOffset = viewportlength - (viewportrows * cellLength + padding + gap); // console.log('targetrow adjustment: targetrowoffset, referenceoffset, scrollblockoffset, spineOffset',\n    //     targetrowoffset, referenceoffset, scrollblockoffset, spineOffset)\n  } // debugger\n\n\n  return [cradleReferenceIndex, contentCount, referenceoffset, scrollblockoffset, spineOffset];\n}; // filter out items that not proximate to the spine\n\n\nexports.isolateRelevantIntersections = function (_a) {\n  var intersections = _a.intersections,\n      cradleContent = _a.cradleContent,\n      // headcontent, \n  // tailcontent,\n  itemObserverThreshold = _a.itemObserverThreshold,\n      scrollforward = _a.scrollforward;\n  var headcontent = cradleContent.headModel;\n  var tailcontent = cradleContent.tailModel;\n  var headindexes = [],\n      tailindexes = [],\n      headintersectionindexes = [],\n      headintersections = [],\n      tailintersectionindexes = [],\n      tailintersections = [],\n      intersecting = {},\n      filteredintersections = []; // collect lists of indexes...\n  // headindexes, tailindexes\n\n  for (var _i = 0, headcontent_1 = headcontent; _i < headcontent_1.length; _i++) {\n    var component = headcontent_1[_i];\n    headindexes.push(component.props.index);\n  }\n\n  for (var _b = 0, tailcontent_1 = tailcontent; _b < tailcontent_1.length; _b++) {\n    var component = tailcontent_1[_b];\n    tailindexes.push(component.props.index);\n  }\n\n  var duplicates = {};\n  var intersectionsptr = 0;\n\n  for (var _c = 0, intersections_1 = intersections; _c < intersections_1.length; _c++) {\n    var entry = intersections_1[_c];\n    var index = parseInt(entry.target.dataset.index);\n    var headptr_1 = void 0,\n        tailptr_1 = void 0;\n\n    if (tailindexes.includes(index)) {\n      tailintersectionindexes.push(index);\n      tailintersections.push(entry);\n      tailptr_1 = tailintersections.length - 1; // used for duplicate resolution\n    } else if (headindexes.includes(index)) {\n      headintersectionindexes.push(index);\n      headintersections.push(entry);\n      headptr_1 = headintersections.length - 1; // used for duplicate resolution\n    } else {\n      console.log('error: unknown intersection element, aborting isolateRelevantIntersections', entry);\n      return; // shouldn't happen; give up\n    }\n\n    var ratio = void 0;\n\n    if (browser && browser.name == 'safari') {\n      ratio = entry.intersectionRatio;\n    } else {\n      ratio = Math.round(entry.intersectionRatio * 1000) / 1000;\n    }\n\n    var calcintersecting = ratio >= itemObserverThreshold;\n    var iobj = {\n      index: index,\n      intersecting: calcintersecting,\n      isIntersecting: entry.isIntersecting,\n      ratio: ratio,\n      originalratio: entry.intersectionRatio,\n      time: entry.time,\n      headptr: headptr_1,\n      tailptr: tailptr_1,\n      intersectionsptr: intersectionsptr\n    };\n\n    if (!intersecting[index]) {\n      // new item\n      intersecting[index] = iobj;\n    } else {\n      // duplicate item\n      if (!Array.isArray(intersecting[index])) {\n        var arr = [intersecting[index]];\n        intersecting[index] = arr;\n      }\n\n      intersecting[index].push(iobj);\n\n      if (!duplicates[index]) {\n        duplicates[index] = [];\n        duplicates[index].push(intersecting[index][0]);\n      }\n\n      duplicates[index].push(iobj);\n    }\n\n    intersectionsptr++;\n  } // resolve duplicates. For uneven number, keep the most recent\n  // otherwise delete them, they cancel each other out.\n\n\n  var duplicateslength = Object.keys(duplicates).length;\n\n  if (duplicateslength > 0) {\n    // console.log('DUPLICATES found', duplicateslength, duplicates)\n    var headintersectionsdelete_1 = [],\n        tailintersectionsdelete_1 = [];\n\n    for (var duplicateindex in duplicates) {\n      var duplicate = duplicates[duplicateindex];\n\n      if (duplicate.length % 2) {\n        duplicate.sort(duplicatecompare);\n        var entry = duplicate.slice(duplicate.length - 1, 1);\n        intersecting[entry.index] = entry;\n      } else {\n        delete intersecting[duplicate[0].index]; // intersectingdelete.push(duplicate[0].index)\n      }\n\n      for (var _d = 0, duplicate_1 = duplicate; _d < duplicate_1.length; _d++) {\n        var entryobj = duplicate_1[_d];\n        var headptr_2 = entryobj.headptr;\n        var tailptr_2 = entryobj.tailptr;\n\n        if (headptr_2 !== undefined) {\n          headintersectionsdelete_1.push(headptr_2);\n        }\n\n        if (tailptr_2 !== undefined) {\n          tailintersectionsdelete_1.push(tailptr_2);\n        }\n      }\n    }\n\n    if (headintersectionsdelete_1.length) {\n      headintersectionindexes = headintersectionindexes.filter(function (value, index) {\n        return !headintersectionsdelete_1.includes(index);\n      });\n      headintersections = headintersections.filter(function (value, index) {\n        return !headintersectionsdelete_1.includes(index);\n      });\n    }\n\n    if (tailintersectionsdelete_1.length) {\n      tailintersectionindexes = tailintersectionindexes.filter(function (value, index) {\n        return !tailintersectionsdelete_1.includes(index);\n      });\n      tailintersections = tailintersections.filter(function (value, index) {\n        return !tailintersectionsdelete_1.includes(index);\n      });\n    }\n  }\n\n  headintersectionindexes.sort(indexcompare);\n  tailintersectionindexes.sort(indexcompare);\n  headintersections.sort(entrycompare);\n  tailintersections.sort(entrycompare); // set reference points in relation to the spine\n\n  var headindex = headindexes[headindexes.length - 1];\n  var tailindex = tailindexes[0];\n  var headptr = headintersectionindexes.indexOf(headindex);\n  var tailptr = tailintersectionindexes.indexOf(tailindex); // filter out items that register only because they have just been moved\n\n  if (headptr !== headintersectionindexes.length - 1) {\n    headptr = -1;\n  }\n\n  if (tailptr !== 0) {\n    tailptr = -1;\n  }\n\n  if (headptr > -1 && tailptr > -1) {\n    // edge case\n    if (scrollforward) {\n      headptr = -1;\n    } else {\n      tailptr = -1;\n    }\n  } // collect notifications to main thread (filtered intersections)\n  // for scrollbackward\n\n\n  var headrefindex, tailrefindex; // for return\n\n  if (!scrollforward && headptr >= 0) {\n    headrefindex = headintersectionindexes[headptr];\n    var refindex = headrefindex + 1;\n    var refintersecting = intersecting[refindex - 1].intersecting;\n\n    for (var ptr = headptr; ptr >= 0; ptr--) {\n      var index = headintersectionindexes[ptr]; // test for continuity and consistency\n\n      if (index + 1 == refindex && intersecting[index].intersecting == refintersecting) {\n        filteredintersections.push(headintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[refindex].intersecting;\n    }\n  } // for scrollforward\n\n\n  if (scrollforward && tailptr >= 0) {\n    tailrefindex = tailintersectionindexes[tailptr];\n    var refindex = tailrefindex - 1;\n    var refintersecting = intersecting[refindex + 1].intersecting;\n\n    for (var ptr = tailptr; ptr < tailintersectionindexes.length; ptr++) {\n      var index = tailintersectionindexes[ptr]; // test for continuity and consistency\n\n      if (index - 1 == refindex && intersecting[index].intersecting == refintersecting) {\n        filteredintersections.push(tailintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[index].intersecting;\n    }\n  }\n\n  filteredintersections.sort(entrycompare); // TODO this should be integrated into the code above\n\n  return filteredintersections;\n};\n\nvar indexcompare = function indexcompare(a, b) {\n  var retval = a < b ? -1 : 1;\n  return retval;\n};\n\nvar entrycompare = function entrycompare(a, b) {\n  var retval = parseInt(a.target.dataset.index) < parseInt(b.target.dataset.index) ? -1 : 1;\n  return retval;\n};\n\nvar duplicatecompare = function duplicatecompare(a, b) {\n  var retval = a.time < b.time ? -1 : 1;\n};\n\nexports.calcContentShifts = function (_a) {\n  var // called only from updateCradleContent\n  cradleProps = _a.cradleProps,\n      cradleElements = _a.cradleElements,\n      cradleContent = _a.cradleContent,\n      cradleConfig = _a.cradleConfig,\n      viewportElement = _a.viewportElement,\n      itemElements = _a.itemElements,\n      intersections = _a.intersections,\n      scrollforward = _a.scrollforward; // unpack\n\n  var gap = cradleProps.gap,\n      orientation = cradleProps.orientation,\n      cellHeight = cradleProps.cellHeight,\n      cellWidth = cradleProps.cellWidth,\n      listsize = cradleProps.listsize,\n      padding = cradleProps.padding,\n      runwaycount = cradleProps.runwaycount;\n  var spineElement = cradleElements.spine.current;\n  var headElement = cradleElements.head.current;\n  var tailElement = cradleElements.tail.current;\n  var cradlecontentlist = cradleContent.cradleModel;\n  var headcontentlist = cradleContent.headModel;\n  var tailcontentlist = cradleContent.tailModel;\n  var crosscount = cradleConfig.crosscount,\n      cradleRowcount = cradleConfig.cradleRowcount,\n      viewportRowcount = cradleConfig.viewportRowcount,\n      itemObserverThreshold = cradleConfig.itemObserverThreshold; // ------- calculate cradleboundary and boundary row and item count for overshoot\n\n  var startingspineoffset, headblockoffset, tailblockoffset, viewportlength;\n  var viewportgaplength;\n  var cellLength = orientation == 'vertical' ? cellHeight + gap : cellWidth + gap;\n\n  if (orientation == 'vertical') {\n    startingspineoffset = spineElement.offsetTop - viewportElement.scrollTop;\n    headblockoffset = headElement.offsetTop;\n    tailblockoffset = tailElement.offsetTop; // always 0\n\n    viewportlength = viewportElement.offsetHeight; // measure any gap between the cradle and the viewport boundary\n\n    if (scrollforward) {\n      viewportgaplength = viewportlength - (startingspineoffset + tailElement.offsetHeight);\n    } else {\n      viewportgaplength = startingspineoffset - headElement.offsetHeight;\n    }\n  } else {\n    // horizontal\n    startingspineoffset = spineElement.offsetLeft - viewportElement.scrollLeft;\n    headblockoffset = headElement.offsetLeft;\n    tailblockoffset = tailElement.offsetLeft; // always 0\n\n    viewportlength = viewportElement.offsetWidth;\n\n    if (scrollforward) {\n      viewportgaplength = viewportlength - (startingspineoffset + tailElement.offsetWidth);\n    } else {\n      viewportgaplength = startingspineoffset - headElement.offsetWidth;\n    }\n  }\n\n  if (viewportgaplength < 0) viewportgaplength = 0;\n  if (viewportgaplength > viewportlength) viewportgaplength = 0; // reposition should have kicked in\n\n  var overshootrowcount = viewportgaplength == 0 ? 0 : Math.ceil(viewportgaplength / cellLength); // rows to fill viewport\n\n  console.log('--> overshootrowcount = viewportgaplength/cellLength; scrollforward', overshootrowcount, viewportgaplength, cellLength, scrollforward); // extra rows for runway\n\n  if (overshootrowcount) {\n    overshootrowcount += runwaycount;\n  }\n\n  var overshootitemcount = overshootrowcount * crosscount; // let unincludedheaditems = 0\n\n  if (!scrollforward && overshootitemcount != 0) {\n    // negation of values for scroll backward\n    overshootitemcount = -overshootitemcount;\n    overshootrowcount = -overshootrowcount;\n  } // ----------------------[  calculate itemshiftcount includng overshoot ]------------------------\n  // shift item count is the number of items the virtual cradle shifts, according to observer notices\n\n\n  var forwardcount = 0,\n      backwardcount = 0;\n\n  if (scrollforward) {\n    backwardcount = intersections.length;\n  } else {\n    forwardcount = intersections.length;\n  }\n\n  var itemshiftcount = backwardcount - forwardcount + overshootitemcount;\n  console.log('itemshiftcount = backwardcount - forwardcount + overshootitemcount', itemshiftcount, backwardcount, forwardcount, overshootitemcount); //-------------------------------[ calc return values ]----------------------------\n\n  var previousreferenceindex = tailcontentlist[0].props.index;\n  var previouscradleindex = cradlecontentlist[0].props.index;\n  var newcradleindex = previouscradleindex + itemshiftcount;\n  var newreferenceindex = previousreferenceindex + itemshiftcount;\n  console.log('+++ newreferenceindex = previousreferenceindex + itemshiftcount', newreferenceindex, previousreferenceindex, itemshiftcount); // --- head based adjustments\n  // reset cradleindex to be relative to referenceindex by runwaycount\n\n  if (newreferenceindex - newcradleindex < runwaycount * crosscount) {\n    newcradleindex = newreferenceindex - runwaycount * crosscount;\n  } // correct cradleindex undershoot\n\n\n  if (newcradleindex < 0) {\n    newcradleindex = 0;\n  }\n\n  if (newreferenceindex < 0) {\n    newreferenceindex = 0;\n  }\n\n  console.log('previouscradleindex, previousreferenceindex, newcradleindex, newreferenceindex', previouscradleindex, previousreferenceindex, newcradleindex, newreferenceindex); // -- tailbased adjustments\n\n  var cradleitemcount = cradleRowcount * crosscount;\n  var cradleadjustment = listsize % crosscount;\n  if (cradleadjustment) cradleadjustment = crosscount - cradleadjustment;\n  console.log('cradleitemcount, cradleadjustment, crosscount, listsize', cradleitemcount, cradleadjustment, crosscount, listsize);\n\n  if (newcradleindex + cradleitemcount > listsize) {\n    var diff = listsize - (newcradleindex + cradleitemcount);\n    newcradleindex -= diff;\n  }\n\n  var viewportfullrows = Math.floor(viewportlength / cellLength);\n  var targetindexrow = newreferenceindex / crosscount; // 0-based\n\n  var maxrefindexrow = Math.ceil(listsize / crosscount) - viewportfullrows;\n\n  if (targetindexrow >= maxrefindexrow) {\n    newreferenceindex = maxrefindexrow * crosscount; // ((targetindexrow - maxrefindexrow) * crosscount)\n\n    console.log('>>>setting referenceindex to maxrefindexrow', newreferenceindex);\n  }\n\n  var cradleitemshiftcount = newcradleindex - previouscradleindex;\n  var referenceitemshiftcount = newreferenceindex - previousreferenceindex;\n  var referencerowshift = referenceitemshiftcount / crosscount;\n  var referencepixelshift = referencerowshift * cellLength;\n  var spineOffset = startingspineoffset + referencepixelshift;\n  console.log('spineOffset = startingspineoffset + referencepixelshift; referencerowshift', spineOffset, startingspineoffset, referencepixelshift, referencerowshift); // console.log('adjusted spineOffset, crosscount, cellLength, referenceitemshiftcount, referencerowshift', \n  //     spineOffset, crosscount, cellLength, referenceitemshiftcount, referencerowshift)\n\n  cradleitemcount -= cradleadjustment;\n  return [newcradleindex, cradleitemshiftcount, newreferenceindex, referenceitemshiftcount, spineOffset, cradleitemcount];\n};\n\nexports.calcHeadAndTailChanges = function (_a) {\n  var cradleProps = _a.cradleProps,\n      itemshiftcount = _a.itemshiftcount,\n      crosscount = _a.crosscount,\n      headcontent = _a.headcontent,\n      tailcontent = _a.tailcontent,\n      scrollforward = _a.scrollforward,\n      cradleReferenceIndex = _a.cradleReferenceIndex,\n      cradlerowcount = _a.cradlerowcount;\n  var listsize = cradleProps.listsize;\n  itemshiftcount = Math.abs(itemshiftcount);\n  var rowshiftcount = Math.ceil(itemshiftcount / crosscount); //+ boundaryrowcount\n\n  var headrowcount, tailrowcount;\n  headrowcount = Math.ceil(headcontent.length / crosscount);\n  tailrowcount = Math.ceil(tailcontent.length / crosscount);\n  var pendingcontentoffset; // lookahead to new cradleReferenceIndex\n\n  var headchangecount, tailchangecount; // the output instructions for getUIContentList\n  // anticipaate add to one end, clip from the other        \n\n  var additemcount = 0;\n  var cliprowcount = 0,\n      clipitemcount = 0;\n\n  if (scrollforward) {\n    // clip from head; add to tail; scroll forward head is direction of scroll\n    // adjust clipitemcount\n    if (headrowcount + rowshiftcount > cradleProps.runwaycount) {\n      var rowdiff = headrowcount + rowshiftcount - cradleProps.runwaycount;\n      cliprowcount = rowdiff;\n      clipitemcount = cliprowcount * crosscount;\n    }\n\n    additemcount = clipitemcount; // maintain constant cradle count\n\n    pendingcontentoffset = cradleReferenceIndex + clipitemcount; // after clip\n\n    var proposedtailindex = pendingcontentoffset + cradlerowcount * crosscount - 1; // modelcontentlist.length - 1\n    // adkjust changes for list boundaries\n\n    if (proposedtailindex > listsize - 1) {\n      var diffitemcount = proposedtailindex - (listsize - 1); // items outside range\n\n      additemcount -= diffitemcount; // adjust the addcontent accordingly\n\n      var diffrows = Math.floor(diffitemcount / crosscount); // number of full rows to leave in place\n\n      var diffrowitems = diffrows * crosscount; // derived number of items to leave in place\n\n      clipitemcount -= diffrowitems; // apply adjustment to netshift\n\n      if (additemcount <= 0) {\n        // nothing to do\n        additemcount = 0;\n      }\n\n      if (clipitemcount <= 0) {\n        clipitemcount = 0;\n      }\n    }\n\n    headchangecount = -clipitemcount;\n    tailchangecount = additemcount;\n  } else {\n    // scroll backward, in direction of tail; clip from tail, add to head\n    var intersectionindexes = []; // headcount will be less than minimum (runwaycount), so a shift can be accomplished[]\n\n    if (headrowcount - rowshiftcount < cradleProps.runwaycount) {\n      // calculate clip for tail\n      var rowshortfall = cradleProps.runwaycount - (headrowcount - rowshiftcount);\n      cliprowcount = rowshortfall;\n      var tailrowitemcount = tailcontent.length % crosscount;\n      if (tailrowitemcount == 0) tailrowitemcount = crosscount;\n      clipitemcount = tailrowitemcount;\n\n      if (tailrowcount > 1) {\n        if (cliprowcount > tailrowcount) {\n          cliprowcount = tailrowcount;\n        }\n\n        if (cliprowcount > 1) {\n          clipitemcount += (cliprowcount - 1) * crosscount;\n        }\n      } // compenstate with additemcount\n\n\n      additemcount = cliprowcount * crosscount;\n    }\n\n    var proposedindexoffset = cradleReferenceIndex - additemcount;\n\n    if (proposedindexoffset < 0) {\n      var diffitemcount = -proposedindexoffset;\n      var diffrows = Math.ceil(diffitemcount / crosscount); // number of full rows to leave in place\n\n      var diffrowitems = diffrows * crosscount;\n      additemcount -= diffitemcount;\n      clipitemcount -= diffrowitems;\n\n      if (additemcount <= 0) {\n        additemcount = 0;\n      }\n\n      if (clipitemcount <= 0) {\n        clipitemcount = 0;\n      }\n    }\n\n    headchangecount = additemcount;\n    tailchangecount = -clipitemcount;\n  }\n\n  return [headchangecount, tailchangecount];\n}; // update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\n\nexports.getUIContentList = function (_a) {\n  var contentCount = _a.contentCount,\n      crosscount = _a.crosscount,\n      // cradleitemshift,\n  // content,\n  cradleReferenceIndex = _a.cradleReferenceIndex,\n      headchangecount = _a.headchangecount,\n      tailchangecount = _a.tailchangecount,\n      cradleProps = _a.cradleProps,\n      contentlist = _a.localContentList,\n      callbacks = _a.callbacks,\n      observer = _a.observer,\n      cradleRowcount = _a.cradleRowcount;\n  var orientation = cradleProps.orientation,\n      cellHeight = cradleProps.cellHeight,\n      cellWidth = cradleProps.cellWidth,\n      getItem = cradleProps.getItem,\n      placeholder = cradleProps.placeholder,\n      listsize = cradleProps.listsize;\n\n  var localContentlist = __spreadArrays(contentlist);\n\n  var tailindexoffset = cradleReferenceIndex + contentlist.length; // let headindexoffset = cradleReferenceIndex\n\n  var returnContentlist;\n  var headContentlist = [];\n  var topconstraint = cradleReferenceIndex - headchangecount,\n      bottomconstraint = cradleReferenceIndex - headchangecount + (contentCount + 1); // TODO: validate \"+1\"\n  // console.log('topconstraint, bottomconstraint, cradleReferenceIndex, contentCount, headchangecount, tailchangecount', \n  //     topconstraint, bottomconstraint, cradleReferenceIndex, contentCount, headchangecount, tailchangecount)\n\n  if (headchangecount >= 0) {\n    for (var index = cradleReferenceIndex - headchangecount; index < cradleReferenceIndex; index++) {\n      if (!(index >= topconstraint && index <= bottomconstraint)) {\n        continue;\n      }\n\n      headContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(0, -headchangecount);\n  }\n\n  var tailContentlist = [];\n\n  if (tailchangecount >= 0) {\n    for (var index = tailindexoffset; index < tailindexoffset + tailchangecount; index++) {\n      if (!(index >= topconstraint && index <= bottomconstraint)) {\n        continue;\n      }\n\n      tailContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(tailchangecount, -tailchangecount);\n  }\n\n  returnContentlist = headContentlist.concat(localContentlist, tailContentlist); // console.log('components of getcontentlist: returnContentList, headContentlist, localContentlist, tailContentlist', \n  //     returnContentlist, headContentlist, localContentlist, tailContentlist)\n\n  return returnContentlist;\n}; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\n\nexports.allocateContentList = function (_a) {\n  var contentlist = _a.contentlist,\n      // of cradle, in items (React components)\n  spineReferenceIndex = _a.spineReferenceIndex;\n  var offsetindex = contentlist[0].props.index;\n  var headitemcount;\n  headitemcount = spineReferenceIndex - offsetindex;\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\n\nvar emitItem = function emitItem(_a) {\n  var index = _a.index,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      observer = _a.observer,\n      callbacks = _a.callbacks,\n      getItem = _a.getItem,\n      listsize = _a.listsize,\n      placeholder = _a.placeholder;\n  return react_1[\"default\"].createElement(itemshell_1[\"default\"], {\n    key: index,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    index: index,\n    observer: observer,\n    callbacks: callbacks,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder\n  });\n}; // ========================================================================================\n// ------------------------------------[ styles ]------------------------------------------\n// ========================================================================================\n\n\nexports.setCradleGridStyles = function (_a) {\n  var orientation = _a.orientation,\n      headstylesobject = _a.headCradleStyles,\n      tailstylesobject = _a.tailCradleStyles,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      crosscount = _a.crosscount,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth;\n\n  var headstyles = __assign({}, headstylesobject);\n\n  var tailstyles = __assign({}, tailstylesobject);\n\n  headstyles.gridGap = gap + 'px';\n  tailstyles.gridGap = gap + 'px';\n\n  if (orientation == 'horizontal') {\n    headstyles.padding = padding + \"px 0 \" + padding + \"px \" + padding + \"px\";\n    headstyles.width = 'auto';\n    headstyles.height = '100%';\n    headstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    headstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    headstyles.gridTemplateColumns = 'none';\n    tailstyles.padding = padding + \"px \" + padding + \"px \" + padding + \"px 0\";\n    tailstyles.width = 'auto';\n    tailstyles.height = '100%';\n    tailstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    tailstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    tailstyles.gridTemplateColumns = 'none';\n  } else if (orientation == 'vertical') {\n    headstyles.padding = padding + \"px \" + padding + \"px 0 \" + padding + \"px\";\n    headstyles.width = '100%';\n    headstyles.height = 'auto';\n    headstyles.gridAutoFlow = 'row';\n    headstyles.gridTemplateRows = 'none';\n    headstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n    tailstyles.padding = \"0 \" + padding + \"px \" + padding + \"px \" + padding + \"px\";\n    tailstyles.width = '100%';\n    tailstyles.height = 'auto';\n    tailstyles.gridAutoFlow = 'row';\n    tailstyles.gridTemplateRows = 'none';\n    tailstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n  }\n\n  return [headstyles, tailstyles];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGVmdW5jdGlvbnMudHN4PzA4YWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBLElBQU0sT0FBTyxHQUFHLHlCQUFoQjs7QUFFYSwyQkFBbUIsVUFDeEIsRUFEd0IsRUFDMkQ7TUFBbEYsa0M7TUFBZ0Isb0M7TUFBaUIsOEI7TUFBYyw0QjtNQUFhLDRCO01BQWEsc0I7QUFHOUUsTUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FBVyxjQUFjLENBQUMsSUFBZixFQUFYLENBQXRCO0FBQ0EsaUJBQWUsQ0FBQyxJQUFoQixDQUFxQixVQUFDLENBQUQsRUFBRyxDQUFILEVBQUk7QUFDckIsV0FBUSxDQUFDLEdBQUcsQ0FBTCxHQUFRLENBQUMsQ0FBVCxHQUFXLENBQWxCO0FBQ0gsR0FGRDtBQUdBLE1BQUksZUFBZSxHQUFHLEVBQXRCOztBQUNBLE9BQWlCLGlDQUFqQixFQUFpQixzQkFBakIsRUFBaUIsSUFBakIsRUFBMkI7QUFBdEIsUUFBSSxJQUFJLGlCQUFSO0FBQ0QsbUJBQWUsQ0FBQyxJQUFoQixDQUFxQixRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFaLENBQTdCO0FBQ0g7O0FBRUQsTUFBSSxJQUFJLEdBQUcsRUFBWDtBQUNBLE1BQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxTQUFaLEdBQXdCLFlBQVksQ0FBQyxTQUFyRDtBQUFBLE1BQ0ksVUFBVSxHQUFHLFdBQVcsQ0FBQyxVQUFaLEdBQXlCLFlBQVksQ0FBQyxVQUR2RDtBQUVBLE1BQUksb0JBQW9CLEdBQUcsQ0FBQyxlQUFlLENBQUMsU0FBNUM7QUFBQSxNQUNJLHFCQUFxQixHQUFHLENBQUMsZUFBZSxDQUFDLFVBRDdDO0FBQUEsTUFFSSxjQUFjLEdBQUcsZUFBZSxDQUFDLFlBRnJD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QyxPQUFYLEdBQXdCLE9BQU8sUUFBUCxHQUFhLE9BQWIsR0FBb0IsT0FBcEIsR0FBNEIsT0FBNUIsR0FBbUMsSUFBM0Q7QUFFQSxjQUFVLENBQUMsS0FBWCxHQUFtQixNQUFuQjtBQUNBLGNBQVUsQ0FBQyxNQUFYLEdBQW9CLE1BQXBCO0FBQ0EsY0FBVSxDQUFDLFlBQVgsR0FBMEIsS0FBMUI7QUFFQSxjQUFVLENBQUMsZ0JBQVgsR0FBOEIsTUFBOUI7QUFDQSxjQUFVLENBQUMsbUJBQVgsR0FBaUMsU0FBUyxHQUFDLDZCQUEyQixTQUEzQixHQUFvQyxXQUFyQyxHQUFpRCxNQUEzRjtBQUVBLGNBQVUsQ0FBQyxPQUFYLEdBQXFCLE9BQUssT0FBTCxHQUFZLEtBQVosR0FBa0IsT0FBbEIsR0FBeUIsS0FBekIsR0FBK0IsT0FBL0IsR0FBc0MsSUFBM0Q7QUFFQSxjQUFVLENBQUMsS0FBWCxHQUFtQixNQUFuQjtBQUNBLGNBQVUsQ0FBQyxNQUFYLEdBQW9CLE1BQXBCO0FBQ0EsY0FBVSxDQUFDLFlBQVgsR0FBMEIsS0FBMUI7QUFFQSxjQUFVLENBQUMsZ0JBQVgsR0FBOEIsTUFBOUI7QUFDQSxjQUFVLENBQUMsbUJBQVgsR0FBaUMsU0FBUyxHQUFDLDZCQUEyQixTQUEzQixHQUFvQyxXQUFyQyxHQUFpRCxNQUEzRjtBQUVIOztBQUVELFNBQU8sQ0FBQyxVQUFELEVBQVksVUFBWixDQUFQO0FBRVAsQ0FwRVkiLCJmaWxlIjoiLi9zcmMvY3JhZGxlZnVuY3Rpb25zLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNyYWRsZWZ1bmN0aW9ucy50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTVVBQT1JUSU5HIEZVTkNUSU9OUyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBJdGVtU2hlbGwgZnJvbSAnLi9pdGVtc2hlbGwnXG5cbmltcG9ydCB7IGRldGVjdCB9IGZyb20gJ2RldGVjdC1icm93c2VyJ1xuXG5jb25zdCBicm93c2VyID0gZGV0ZWN0KClcblxuZXhwb3J0IGNvbnN0IGNhbGNWaXNpYmxlSXRlbXMgPSAoXG4gICAgICAgIHtpdGVtRWxlbWVudE1hcCwgdmlld3BvcnRFbGVtZW50LCBzcGluZUVsZW1lbnQsIGhlYWRFbGVtZW50LCBvcmllbnRhdGlvbiwgaGVhZGxpc3R9XG4gICAgKSA9PiB7XG5cbiAgICBsZXQgaXRlbWxpc3RpbmRleGVzID0gQXJyYXkuZnJvbShpdGVtRWxlbWVudE1hcC5rZXlzKCkpXG4gICAgaXRlbWxpc3RpbmRleGVzLnNvcnQoKGEsYik9PntcbiAgICAgICAgcmV0dXJuIChhIDwgYik/LTE6MVxuICAgIH0pXG4gICAgbGV0IGhlYWRsaXN0aW5kZXhlcyA9IFtdXG4gICAgZm9yIChsZXQgaXRlbSBvZiBoZWFkbGlzdCkge1xuICAgICAgICBoZWFkbGlzdGluZGV4ZXMucHVzaChwYXJzZUludChpdGVtLnByb3BzLmluZGV4KSlcbiAgICB9XG5cbiAgICBsZXQgbGlzdCA9IFtdXG4gICAgbGV0IGNyYWRsZVRvcCA9IGhlYWRFbGVtZW50Lm9mZnNldFRvcCArIHNwaW5lRWxlbWVudC5vZmZzZXRUb3AsIFxuICAgICAgICBjcmFkbGVMZWZ0ID0gaGVhZEVsZW1lbnQub2Zmc2V0TGVmdCArIHNwaW5lRWxlbWVudC5vZmZzZXRMZWZ0XG4gICAgbGV0IHNjcm9sbGJsb2NrVG9wT2Zmc2V0ID0gLXZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AsIFxuICAgICAgICBzY3JvbGxibG9ja0xlZnRPZmZzZXQgPSAtdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgdmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgdmlld3BvcnRUb3BPZmZzZXQgPSAtc2Nyb2xsYmxvY2tUb3BPZmZzZXQsXG4gICAgICAgIHZpZXdwb3J0Qm90dG9tT2Zmc2V0ID0gLXNjcm9sbGJsb2NrVG9wT2Zmc2V0ICsgdmlld3BvcnRIZWlnaHRcblxuICAgIGZvciAobGV0IGluZGV4IG9mIGl0ZW1saXN0aW5kZXhlcykge1xuXG4gICAgICAgIGxldCBlbGVtZW50ID0gaXRlbUVsZW1lbnRNYXAuZ2V0KGluZGV4KS5jdXJyZW50XG4gICAgICAgIGxldCBpbmhlYWRsaXN0ID0gaGVhZGxpc3RpbmRleGVzLmluY2x1ZGVzKGluZGV4KVxuICAgICAgICBsZXQgdG9wID0gaW5oZWFkbGlzdD8oZWxlbWVudC5vZmZzZXRUb3ApOigoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP2hlYWRFbGVtZW50Lm9mZnNldEhlaWdodDowKSArIGVsZW1lbnQub2Zmc2V0VG9wKSwgXG4gICAgICAgICAgICBsZWZ0ID0gaW5oZWFkbGlzdD8oZWxlbWVudC5vZmZzZXRMZWZ0KTooKChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpP2hlYWRFbGVtZW50Lm9mZnNldFdpZHRoOjApICsgZWxlbWVudC5vZmZzZXRMZWZ0KSwgXG4gICAgICAgICAgICB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICByaWdodCA9IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodFxuXG4gICAgICAgIGxldCBpdGVtVG9wT2Zmc2V0ID0gc2Nyb2xsYmxvY2tUb3BPZmZzZXQgKyBjcmFkbGVUb3AgKyB0b3AsIC8vIG9mZnNldCBmcm9tIHRvcCBvZiB2aWV3cG9ydFxuICAgICAgICAgICAgaXRlbUJvdHRvbU9mZnNldCA9IHNjcm9sbGJsb2NrVG9wT2Zmc2V0ICsgY3JhZGxlVG9wICsgYm90dG9tLCAvLyBvZmZzZXQgZnJvbSB0b3Agb2Ygdmlld3BvcnRcbiAgICAgICAgICAgIGl0ZW1MZWZ0T2Zmc2V0ID0gc2Nyb2xsYmxvY2tMZWZ0T2Zmc2V0ICsgY3JhZGxlTGVmdCArIGxlZnQsIFxuICAgICAgICAgICAgaXRlbVJpZ2h0T2Zmc2V0ID0gc2Nyb2xsYmxvY2tMZWZ0T2Zmc2V0ICsgY3JhZGxlTGVmdCArIHJpZ2h0IFxuXG5cbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlIC8vIGRlZmF1bHRcblxuICAgICAgICBsZXQgdG9wUG9ydGlvbixcbiAgICAgICAgICAgIGJvdHRvbVBvcnRpb24sXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbixcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvblxuXG4gICAgICAgIGlmICgoaXRlbVRvcE9mZnNldCA8IDApICYmIChpdGVtQm90dG9tT2Zmc2V0ID4gMCkpIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbiA9IGl0ZW1Cb3R0b21PZmZzZXRcbiAgICAgICAgICAgIHRvcFBvcnRpb24gPSBib3R0b21Qb3J0aW9uIC0gaGVpZ2h0XG5cbiAgICAgICAgfSBlbHNlIGlmICgoaXRlbVRvcE9mZnNldCA+PSAwKSAmJiAoaXRlbUJvdHRvbU9mZnNldCA8IHZpZXdwb3J0SGVpZ2h0KSkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICB0b3BQb3J0aW9uID0gaGVpZ2h0XG4gICAgICAgICAgICBib3R0b21Qb3J0aW9uID0gMFxuXG4gICAgICAgIH0gZWxzZSBpZiAoKGl0ZW1Ub3BPZmZzZXQgPiAwKSAmJiAoKGl0ZW1Ub3BPZmZzZXQgLSB2aWV3cG9ydEhlaWdodCkgPCAwKSkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICB0b3BQb3J0aW9uID0gdmlld3BvcnRIZWlnaHQgLSBpdGVtVG9wT2Zmc2V0XG4gICAgICAgICAgICBib3R0b21Qb3J0aW9uID0gdG9wUG9ydGlvbiAtIGhlaWdodFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSBjb250aW51ZVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbUxlZnRPZmZzZXQgPCAwICYmIGl0ZW1SaWdodE9mZnNldCA+IDApIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICByaWdodFBvcnRpb24gPSBpdGVtUmlnaHRPZmZzZXRcbiAgICAgICAgICAgIGxlZnRQb3J0aW9uID0gcmlnaHRQb3J0aW9uIC0gd2lkdGhcblxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1MZWZ0T2Zmc2V0ID49IDAgJiYgaXRlbVJpZ2h0T2Zmc2V0IDwgdmlld3BvcnRXaWR0aCkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSAmJiAoaXNWaXNpYmxlID0gdHJ1ZSlcbiAgICAgICAgICAgIGxlZnRQb3J0aW9uID0gd2lkdGhcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvbiA9IDBcblxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1MZWZ0T2Zmc2V0ID4gMCAmJiAoaXRlbUxlZnRPZmZzZXQgLSB2aWV3cG9ydFdpZHRoKSA8IDApIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbiA9IHZpZXdwb3J0V2lkdGggLSBpdGVtTGVmdE9mZnNldFxuICAgICAgICAgICAgcmlnaHRQb3J0aW9uID0gbGVmdFBvcnRpb24gLSB3aWR0aFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIGNvbnRpbnVlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2ZXJ0aWNhbFJhdGlvID0gKHRvcFBvcnRpb24gPiAwKT90b3BQb3J0aW9uL2hlaWdodDpib3R0b21Qb3J0aW9uL2hlaWdodCxcbiAgICAgICAgICAgIGhvcml6b250YWxSYXRpbyA9IChsZWZ0UG9ydGlvbiA+IDApP2xlZnRQb3J0aW9uL3dpZHRoOnJpZ2h0UG9ydGlvbi9oZWlnaHRcblxuICAgICAgICBsZXQgaXRlbURhdGEgPSB7XG5cbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXNWaXNpYmxlLFxuXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcblxuICAgICAgICAgICAgaXRlbVRvcE9mZnNldCxcbiAgICAgICAgICAgIGl0ZW1Cb3R0b21PZmZzZXQsXG4gICAgICAgICAgICB0b3BQb3J0aW9uLFxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbixcblxuICAgICAgICAgICAgaXRlbUxlZnRPZmZzZXQsXG4gICAgICAgICAgICBpdGVtUmlnaHRPZmZzZXQsXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbixcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvbixcblxuICAgICAgICAgICAgdmVydGljYWxSYXRpbyxcbiAgICAgICAgICAgIGhvcml6b250YWxSYXRpbyxcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW1EYXRhKVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Rcbn1cblxuZXhwb3J0IGNvbnN0IGdldFNjcm9sbFJlZmVyZW5jZUluZGV4RGF0YSA9ICh7XG5cbiAgICAgICAgdmlld3BvcnREYXRhLFxuICAgICAgICBjcmFkbGVQcm9wcyxcbiAgICAgICAgY3Jvc3Njb3VudCxcblxuICAgIH0pID0+IHtcblxuICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50XG4gICAgbGV0IHtvcmllbnRhdGlvbiwgbGlzdHNpemV9ID0gY3JhZGxlUHJvcHNcbiAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0ICsgY3JhZGxlUHJvcHMuZ2FwXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcblxuICAgIH1cblxuICAgIGxldCByZWZlcmVuY2VzY3JvbGxvZmZzZXQgPSBjZWxsTGVuZ3RoIC0gKHNjcm9sbFBvcyAlIGNlbGxMZW5ndGgpXG4gICAgaWYgKHJlZmVyZW5jZXNjcm9sbG9mZnNldCA9PSAoY2VsbExlbmd0aCArIGNyYWRsZVByb3BzLnBhZGRpbmcpKSB7XG4gICAgICAgIHJlZmVyZW5jZXNjcm9sbG9mZnNldCA9IDBcbiAgICB9XG5cbiAgICBsZXQgcmVmZXJlbmNlcm93aW5kZXggPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVByb3BzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG4gICAgbGV0IHNwaW5lUmVmZXJlbmNlSW5kZXggPSByZWZlcmVuY2Vyb3dpbmRleCAqIGNyb3NzY291bnRcbiAgICBzcGluZVJlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4oc3BpbmVSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG4gICAgbGV0IGRpZmYgPSBzcGluZVJlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudFxuICAgIHNwaW5lUmVmZXJlbmNlSW5kZXggLT0gZGlmZlxuXG4gICAgbGV0IHJlZmVyZW5jZUluZGV4RGF0YSA9IHtcbiAgICAgICAgaW5kZXg6c3BpbmVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgc3BpbmVvZmZzZXQ6cmVmZXJlbmNlc2Nyb2xsb2Zmc2V0XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUluZGV4RGF0YS5pbmRleCA9PSAwKSByZWZlcmVuY2VJbmRleERhdGEuc3BpbmVvZmZzZXQgPSAwIC8vIGRlZmVuc2l2ZVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZUluZGV4RGF0YVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMgPSAoeyAvLyBjYWxsZWQgZnJvbSBzZXRDcmFkbGVDb250ZW50IG9ubHlcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHJ1bndheWNvdW50LFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpc2libGV0YXJnZXRpbmRleG9mZnNldDpyZWZlcmVuY2VvZmZzZXQsXG4gICAgICAgIHRhcmdldFZpZXdwb3J0T2Zmc2V0LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgdmlld3BvcnRFbGVtZW50LFxuICAgIH0pID0+IHtcblxuICAgIC8vIHJlY29uY2lsZSBzcGluZVJlZmVyZW5jZUluZGV4IHRvIGNyb3NzY291bnQgY29udGV4dFxuICAgIGxldCBkaWZmID0gcmVmZXJlbmNlb2Zmc2V0ICUgY3Jvc3Njb3VudFxuICAgIHJlZmVyZW5jZW9mZnNldCAtPSBkaWZmXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tWyBjYWxjIGJhc2ljIGlucHV0czogY2VsbExlbmd0aCwgY29udGVudENvdW50LiBdLS0tLS0tLS0tLVxuXG4gICAgbGV0IGNlbGxMZW5ndGgsdmlld3BvcnRsZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICB2aWV3cG9ydGxlbmd0aCA9IHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0bGVuZ3RoID0gdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgfVxuICAgIC8vIGxldCB2aWV3cG9ydHJvd3MgPSBNYXRoLmZsb29yKHZpZXdwb3J0bGVuZ3RoIC8gY2VsbExlbmd0aClcblxuICAgIGxldCB2aWV3cG9ydHJvd3MgPSB2aWV3cG9ydFJvd2NvdW50XG5cbiAgICBsZXQgY29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50IFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgbGVhZGluZ2l0ZW1jb3VudCwgcmVmZXJlbmNlb2Zmc2V0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IHJ1bndheWl0ZW1jb3VudCA9IHJ1bndheWNvdW50ICogY3Jvc3Njb3VudFxuICAgIHJ1bndheWl0ZW1jb3VudCA9IE1hdGgubWluKHJ1bndheWl0ZW1jb3VudCwgcmVmZXJlbmNlb2Zmc2V0KSAvLyBmb3IgbGlzdCBoZWFkXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjcmFkbGVSZWZlcmVuY2VJbmRleCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbGVhZGluZyBlZGdlXG4gICAgbGV0IGNyYWRsZVJlZmVyZW5jZUluZGV4ID0gcmVmZXJlbmNlb2Zmc2V0IC0gcnVud2F5aXRlbWNvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS1bIGFkanVzdCBjcmFkbGVSZWZlcmVuY2VJbmRleCBmb3IgdW5kZXJmbG93IF0tLS0tLS0tLS0tLS1cblxuICAgIGRpZmYgPSAwIC8vIHJlc2V0XG4gICAgbGV0IGluZGV4c2hpZnQgPSAwIC8vIGFkanVzdG1lbnQgaWYgb3ZlcnNob290IGhlYWRcbiAgICBpZiAoY3JhZGxlUmVmZXJlbmNlSW5kZXggPCAwKSB7XG4gICAgICAgIGRpZmYgPSBjcmFkbGVSZWZlcmVuY2VJbmRleFxuICAgICAgICBpbmRleHNoaWZ0ID0gTWF0aC5mbG9vcihjcmFkbGVSZWZlcmVuY2VJbmRleCAvIGNyb3NzY291bnQpICogY3Jvc3Njb3VudFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCArPSBpbmRleHNoaWZ0XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tWyBhZGp1c3QgY3JhZGxlUmVmZXJlbmNlSW5kZXggYW5kIGNvbnRlbnRDb3VudCBmb3IgbGlzdHNpemUgb3ZlcmZsb3cgXS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IHNwaW5lT2Zmc2V0ID0gdGFyZ2V0Vmlld3BvcnRPZmZzZXQgJSBjZWxsTGVuZ3RoXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjc3MgcG9zaXRpb25pbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgdGFyZ2V0cm93b2Zmc2V0ID0gTWF0aC5jZWlsKHJlZmVyZW5jZW9mZnNldC9jcm9zc2NvdW50KVxuICAgIGxldCBzY3JvbGxibG9ja29mZnNldCA9ICh0YXJnZXRyb3dvZmZzZXQgKiBjZWxsTGVuZ3RoKSArIHBhZGRpbmcgLy8gZ2FwXG4gICAgbGV0IHNwaW5lYWRqdXN0bWVudFxuXG4gICAgaWYgKHRhcmdldHJvd29mZnNldCA9PSAwKSB7XG4gICAgICAgIHNjcm9sbGJsb2Nrb2Zmc2V0ID0gMFxuICAgICAgICBzcGluZU9mZnNldCA9IDAgLy8gcGFkZGluZ1xuICAgICAgICBzcGluZWFkanVzdG1lbnQgPSBwYWRkaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3BpbmVhZGp1c3RtZW50ID0gMDsgLy9nYXA7XG5cbiAgICAgICAgW2NyYWRsZVJlZmVyZW5jZUluZGV4LCBjb250ZW50Q291bnQsIHJlZmVyZW5jZW9mZnNldCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0XSA9IGFkanVzdFNwaW5lT2Zmc2V0Rm9yTWF4UmVmaW5kZXgoe1xuICAgICAgICAgICAgcmVmZXJlbmNlb2Zmc2V0LFxuICAgICAgICAgICAgc3BpbmVPZmZzZXQsXG4gICAgICAgICAgICBzY3JvbGxibG9ja29mZnNldCwgICAgICAgICAgICBcbiAgICAgICAgICAgIHRhcmdldHJvd29mZnNldCxcbiAgICAgICAgICAgIHZpZXdwb3J0bGVuZ3RoLFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICB2aWV3cG9ydHJvd3MsXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgY2VsbExlbmd0aCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIGNvbnRlbnRDb3VudCxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBkZWJ1Z2dlclxuXG4gICAgLy8gY29uc29sZS5sb2coJ2NyYWRsZVJlZmVyZW5jZUluZGV4LCByZWZlcmVuY2VvZmZzZXQsIGNvbnRlbnRDb3VudCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0LCBzcGluZWFkanVzdG1lbnQnLFxuICAgIC8vICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBzcGluZU9mZnNldCwgc3BpbmVhZGp1c3RtZW50KVxuXG4gICAgcmV0dXJuIHtjcmFkbGVSZWZlcmVuY2VJbmRleCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBzcGluZU9mZnNldCwgc3BpbmVhZGp1c3RtZW50fSAvLyBzdW1tYXJpemUgcmVxdWlyZW1lbnRzIG1lc3NhZ2VcblxufVxuXG5jb25zdCBhZGp1c3RTcGluZU9mZnNldEZvck1heFJlZmluZGV4ID0gKHtcblxuICAgIGxpc3RzaXplLFxuICAgIGNyb3NzY291bnQsXG4gICAgY29udGVudENvdW50LFxuXG4gICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgcmVmZXJlbmNlb2Zmc2V0LFxuICAgIHRhcmdldHJvd29mZnNldCxcblxuICAgIHNjcm9sbGJsb2Nrb2Zmc2V0LFxuICAgIHNwaW5lT2Zmc2V0LFxuXG4gICAgdmlld3BvcnRsZW5ndGgsXG4gICAgdmlld3BvcnRyb3dzLFxuXG4gICAgY2VsbExlbmd0aCxcbiAgICBwYWRkaW5nLFxuICAgIGdhcCxcblxufSkgPT4ge1xuXG4gICAgbGV0IGFjdGl2ZWxpc3RpdGVtY291bnQgPSBjcmFkbGVSZWZlcmVuY2VJbmRleCArIGNvbnRlbnRDb3VudFxuICAgIGxldCBhY3RpdmVsaXN0cm93Y291bnQgPSBNYXRoLmNlaWwoYWN0aXZlbGlzdGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuICAgIGxldCBsaXN0cm93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIC8vIG1lbW9zXG4gICAgbGV0IG9yaWdpbmFsY3JhZGxlb2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXhcbiAgICBsZXQgb3JpZ2luYWxyZWZlcmVuY2VvZmZzZXQgPSByZWZlcmVuY2VvZmZzZXRcbiAgICBsZXQgb3JpZ2luYWxzcGluZU9mZnNldCA9IHNwaW5lT2Zmc2V0XG5cbiAgICBpZiAoYWN0aXZlbGlzdHJvd2NvdW50ID4gbGlzdHJvd2NvdW50KSB7XG4gICAgICAgIGxldCBkaWZmcm93cyA9IGFjdGl2ZWxpc3Ryb3djb3VudCAtIGxpc3Ryb3djb3VudFxuICAgICAgICBsZXQgZGlmZiA9IGRpZmZyb3dzICogY3Jvc3Njb3VudFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCAtPSBkaWZmXG4gICAgICAgIGFjdGl2ZWxpc3Ryb3djb3VudCAtPSBkaWZmcm93c1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JhZGxlcmVmZXJlbmNlIG9yaWdpbmFsLCBhZGp1c3RtZW50LCByb3dzLCBpdGVtcywgcmVzdWx0JywgXG4gICAgICAgICAgICAvLyBvcmlnaW5hbGNyYWRsZW9mZnNldCwgZGlmZiwgZGlmZnJvd3MsIGNyYWRsZVJlZmVyZW5jZUluZGV4KVxuICAgIH1cblxuICAgIC8vIGxldCB0ZXN0bGlzdHJvd2NvdW50ID0gTWF0aC5jZWlsKChjcmFkbGVSZWZlcmVuY2VJbmRleCArIGNvbnRlbnRDb3VudCArIDEpL2Nyb3NzY291bnQpXG4gICAgaWYgKGFjdGl2ZWxpc3Ryb3djb3VudCA9PSBsaXN0cm93Y291bnQpIHtcbiAgICAgICAgbGV0IGRpZmYgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIGNvbnRlbnRDb3VudCAtPSAoY3Jvc3Njb3VudCAtIGRpZmYpXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZpbmFsIHJvdyBhZGp1c3RtZW50IHRocm91Z2ggYWN0aXZlbGlzdHJvd2NvdW50LCBsaXN0cm93Y291bnQsIGxpc3RzaXplLCBjb250ZW50Q291bnQsIGNyb3NzY291bnQsIGRpZmYnLFxuICAgICAgICAvLyBhY3RpdmVsaXN0cm93Y291bnQsIGxpc3Ryb3djb3VudCwgbGlzdHNpemUsIGNvbnRlbnRDb3VudCwgY3Jvc3Njb3VudCwgZGlmZilcbiAgICB9XG5cbiAgICBsZXQgbWF4cmVmaW5kZXhyb3cgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudCkgLSB2aWV3cG9ydHJvd3MgKyAxXG4gICAgLy8gY29uc29sZS5sb2coJ3RhcmdldHJvd29mZnNldCwgbWF4cmVmaW5kZXhyb3cnLCB0YXJnZXRyb3dvZmZzZXQsIG1heHJlZmluZGV4cm93KVxuICAgIGlmICh0YXJnZXRyb3dvZmZzZXQgPiBtYXhyZWZpbmRleHJvdykge1xuICAgICAgICB0YXJnZXRyb3dvZmZzZXQgPSBtYXhyZWZpbmRleHJvd1xuXG4gICAgICAgIHJlZmVyZW5jZW9mZnNldCA9ICh0YXJnZXRyb3dvZmZzZXQgKiBjcm9zc2NvdW50KVxuXG4gICAgICAgIHNjcm9sbGJsb2Nrb2Zmc2V0ID0gKHRhcmdldHJvd29mZnNldCAqIGNlbGxMZW5ndGgpICsgZ2FwXG5cbiAgICAgICAgc3BpbmVPZmZzZXQgPSB2aWV3cG9ydGxlbmd0aCAtICgodmlld3BvcnRyb3dzICogY2VsbExlbmd0aCkgKyBwYWRkaW5nICsgZ2FwKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0YXJnZXRyb3cgYWRqdXN0bWVudDogdGFyZ2V0cm93b2Zmc2V0LCByZWZlcmVuY2VvZmZzZXQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBzcGluZU9mZnNldCcsXG4gICAgICAgIC8vICAgICB0YXJnZXRyb3dvZmZzZXQsIHJlZmVyZW5jZW9mZnNldCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0KVxuICAgIH1cblxuICAgIC8vIGRlYnVnZ2VyXG5cbiAgICByZXR1cm4gW2NyYWRsZVJlZmVyZW5jZUluZGV4LCBjb250ZW50Q291bnQsIHJlZmVyZW5jZW9mZnNldCwgc2Nyb2xsYmxvY2tvZmZzZXQsIHNwaW5lT2Zmc2V0XVxuXG59XG5cbi8vIGZpbHRlciBvdXQgaXRlbXMgdGhhdCBub3QgcHJveGltYXRlIHRvIHRoZSBzcGluZVxuZXhwb3J0IGNvbnN0IGlzb2xhdGVSZWxldmFudEludGVyc2VjdGlvbnMgPSAoe1xuICAgIGludGVyc2VjdGlvbnMsXG4gICAgY3JhZGxlQ29udGVudCxcbiAgICAvLyBoZWFkY29udGVudCwgXG4gICAgLy8gdGFpbGNvbnRlbnQsXG4gICAgaXRlbU9ic2VydmVyVGhyZXNob2xkLFxuICAgIHNjcm9sbGZvcndhcmQsXG59KSA9PiB7XG5cbiAgICBsZXQgaGVhZGNvbnRlbnQgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbFxuICAgIGxldCB0YWlsY29udGVudCA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsXG5cbiAgICBsZXQgaGVhZGluZGV4ZXMgPSBbXSwgXG4gICAgICAgIHRhaWxpbmRleGVzID0gW10sXG4gICAgICAgIGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzID0gW10sXG4gICAgICAgIGhlYWRpbnRlcnNlY3Rpb25zID0gW10sXG4gICAgICAgIHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzID0gW10sXG4gICAgICAgIHRhaWxpbnRlcnNlY3Rpb25zID0gW10sXG4gICAgICAgIGludGVyc2VjdGluZzphbnkgPSB7fSxcbiAgICAgICAgZmlsdGVyZWRpbnRlcnNlY3Rpb25zID0gW11cblxuICAgIC8vIGNvbGxlY3QgbGlzdHMgb2YgaW5kZXhlcy4uLlxuICAgIC8vIGhlYWRpbmRleGVzLCB0YWlsaW5kZXhlc1xuICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiBoZWFkY29udGVudCkge1xuICAgICAgICBoZWFkaW5kZXhlcy5wdXNoKGNvbXBvbmVudC5wcm9wcy5pbmRleClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGFpbGNvbnRlbnQpIHtcbiAgICAgICAgdGFpbGluZGV4ZXMucHVzaChjb21wb25lbnQucHJvcHMuaW5kZXgpXG4gICAgfVxuXG4gICAgbGV0IGR1cGxpY2F0ZXM6YW55ID0ge31cbiAgICBsZXQgaW50ZXJzZWN0aW9uc3B0ciA9IDBcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBpbnRlcnNlY3Rpb25zKSB7XG5cbiAgICAgICAgbGV0IGluZGV4ID0gcGFyc2VJbnQoZW50cnkudGFyZ2V0LmRhdGFzZXQuaW5kZXgpXG4gICAgICAgIGxldCBoZWFkcHRyLCB0YWlscHRyXG4gICAgICAgIGlmICh0YWlsaW5kZXhlcy5pbmNsdWRlcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbmluZGV4ZXMucHVzaChpbmRleClcbiAgICAgICAgICAgIHRhaWxpbnRlcnNlY3Rpb25zLnB1c2goZW50cnkpXG4gICAgICAgICAgICB0YWlscHRyID0gdGFpbGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMSAvLyB1c2VkIGZvciBkdXBsaWNhdGUgcmVzb2x1dGlvblxuXG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZGluZGV4ZXMuaW5jbHVkZXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgIGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzLnB1c2goaW5kZXgpXG4gICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9ucy5wdXNoKGVudHJ5KVxuICAgICAgICAgICAgaGVhZHB0ciA9IGhlYWRpbnRlcnNlY3Rpb25zLmxlbmd0aCAtIDEgLy8gdXNlZCBmb3IgZHVwbGljYXRlIHJlc29sdXRpb25cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6IHVua25vd24gaW50ZXJzZWN0aW9uIGVsZW1lbnQsIGFib3J0aW5nIGlzb2xhdGVSZWxldmFudEludGVyc2VjdGlvbnMnLGVudHJ5KVxuICAgICAgICAgICAgcmV0dXJuIC8vIHNob3VsZG4ndCBoYXBwZW47IGdpdmUgdXBcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJhdGlvXG4gICAgICAgIGlmIChicm93c2VyICYmIGJyb3dzZXIubmFtZSA9PSAnc2FmYXJpJykge1xuICAgICAgICAgICAgcmF0aW8gPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF0aW8gPSBNYXRoLnJvdW5kKGVudHJ5LmludGVyc2VjdGlvblJhdGlvICogMTAwMCkvMTAwMFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNhbGNpbnRlcnNlY3RpbmcgPSAocmF0aW8gPj0gaXRlbU9ic2VydmVyVGhyZXNob2xkKVxuICAgICAgICBsZXQgaW9iaiA9IHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaW50ZXJzZWN0aW5nOmNhbGNpbnRlcnNlY3RpbmcsICAvLyB0byBhY2NvbW1vZGF0ZSBicm93c2VyIGRpZmZlcmVuY2VzXG4gICAgICAgICAgICBpc0ludGVyc2VjdGluZzplbnRyeS5pc0ludGVyc2VjdGluZyxcbiAgICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgICAgb3JpZ2luYWxyYXRpbzplbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyxcbiAgICAgICAgICAgIHRpbWU6ZW50cnkudGltZSxcbiAgICAgICAgICAgIGhlYWRwdHIsXG4gICAgICAgICAgICB0YWlscHRyLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc3B0cixcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyc2VjdGluZ1tpbmRleF0pIHsgLy8gbmV3IGl0ZW1cbiAgICAgICAgICAgIGludGVyc2VjdGluZ1tpbmRleF0gPSBpb2JqXG4gICAgICAgIH0gZWxzZSB7IC8vIGR1cGxpY2F0ZSBpdGVtXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW50ZXJzZWN0aW5nW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyID0gW2ludGVyc2VjdGluZ1tpbmRleF1dXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nW2luZGV4XSA9IGFyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJzZWN0aW5nW2luZGV4XS5wdXNoKGlvYmopXG4gICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlc1tpbmRleF0gPSBbXVxuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXNbaW5kZXhdLnB1c2goaW50ZXJzZWN0aW5nW2luZGV4XVswXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cGxpY2F0ZXNbaW5kZXhdLnB1c2goaW9iailcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnNlY3Rpb25zcHRyKytcblxuICAgIH1cbiAgICAvLyByZXNvbHZlIGR1cGxpY2F0ZXMuIEZvciB1bmV2ZW4gbnVtYmVyLCBrZWVwIHRoZSBtb3N0IHJlY2VudFxuICAgIC8vIG90aGVyd2lzZSBkZWxldGUgdGhlbSwgdGhleSBjYW5jZWwgZWFjaCBvdGhlciBvdXQuXG5cbiAgICBsZXQgZHVwbGljYXRlc2xlbmd0aCA9IE9iamVjdC5rZXlzKGR1cGxpY2F0ZXMpLmxlbmd0aFxuICAgIGlmIChkdXBsaWNhdGVzbGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRFVQTElDQVRFUyBmb3VuZCcsIGR1cGxpY2F0ZXNsZW5ndGgsIGR1cGxpY2F0ZXMpXG4gICAgICAgIGxldCBoZWFkaW50ZXJzZWN0aW9uc2RlbGV0ZSA9IFtdLFxuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbnNkZWxldGUgPSBbXVxuXG4gICAgICAgIGZvciAobGV0IGR1cGxpY2F0ZWluZGV4IGluIGR1cGxpY2F0ZXMpIHtcblxuICAgICAgICAgICAgbGV0IGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZXNbZHVwbGljYXRlaW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZS5zb3J0KGR1cGxpY2F0ZWNvbXBhcmUpXG4gICAgICAgICAgICAgICAgbGV0IGVudHJ5ID0gZHVwbGljYXRlLnNsaWNlKGR1cGxpY2F0ZS5sZW5ndGggLTEsMSlcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmdbZW50cnkuaW5kZXhdID0gZW50cnlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGludGVyc2VjdGluZ1tkdXBsaWNhdGVbMF0uaW5kZXhdXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW5nZGVsZXRlLnB1c2goZHVwbGljYXRlWzBdLmluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZW50cnlvYmogb2YgZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRwdHIgPSBlbnRyeW9iai5oZWFkcHRyXG4gICAgICAgICAgICAgICAgbGV0IHRhaWxwdHIgPSBlbnRyeW9iai50YWlscHRyXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRwdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9uc2RlbGV0ZS5wdXNoKGhlYWRwdHIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWlscHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbnNkZWxldGUucHVzaCh0YWlscHRyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGludGVyc2VjdGlvbnNkZWxldGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcyA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzLmZpbHRlcigodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFoZWFkaW50ZXJzZWN0aW9uc2RlbGV0ZS5pbmNsdWRlcyhpbmRleClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9ucyA9IGhlYWRpbnRlcnNlY3Rpb25zLmZpbHRlcigodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFoZWFkaW50ZXJzZWN0aW9uc2RlbGV0ZS5pbmNsdWRlcyhpbmRleClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhaWxpbnRlcnNlY3Rpb25zZGVsZXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbmluZGV4ZXMgPSB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcy5maWx0ZXIoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGFpbGludGVyc2VjdGlvbnNkZWxldGUuaW5jbHVkZXMoaW5kZXgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbnMgPSB0YWlsaW50ZXJzZWN0aW9ucy5maWx0ZXIoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGFpbGludGVyc2VjdGlvbnNkZWxldGUuaW5jbHVkZXMoaW5kZXgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGVhZGludGVyc2VjdGlvbmluZGV4ZXMuc29ydChpbmRleGNvbXBhcmUpXG4gICAgdGFpbGludGVyc2VjdGlvbmluZGV4ZXMuc29ydChpbmRleGNvbXBhcmUpXG5cbiAgICBoZWFkaW50ZXJzZWN0aW9ucy5zb3J0KGVudHJ5Y29tcGFyZSlcbiAgICB0YWlsaW50ZXJzZWN0aW9ucy5zb3J0KGVudHJ5Y29tcGFyZSlcblxuICAgIC8vIHNldCByZWZlcmVuY2UgcG9pbnRzIGluIHJlbGF0aW9uIHRvIHRoZSBzcGluZVxuICAgIGxldCBoZWFkaW5kZXggPSBoZWFkaW5kZXhlc1toZWFkaW5kZXhlcy5sZW5ndGggLSAxXVxuICAgIGxldCB0YWlsaW5kZXggPSB0YWlsaW5kZXhlc1swXVxuICAgIGxldCBoZWFkcHRyID0gaGVhZGludGVyc2VjdGlvbmluZGV4ZXMuaW5kZXhPZihoZWFkaW5kZXgpXG4gICAgbGV0IHRhaWxwdHIgPSB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcy5pbmRleE9mKHRhaWxpbmRleClcblxuICAgIC8vIGZpbHRlciBvdXQgaXRlbXMgdGhhdCByZWdpc3RlciBvbmx5IGJlY2F1c2UgdGhleSBoYXZlIGp1c3QgYmVlbiBtb3ZlZFxuICAgIGlmIChoZWFkcHRyICE9PSAoaGVhZGludGVyc2VjdGlvbmluZGV4ZXMubGVuZ3RoIC0gMSkpIHsgXG4gICAgICAgIGhlYWRwdHIgPSAtMVxuICAgIH1cblxuICAgIGlmICh0YWlscHRyICE9PTApIHsgXG4gICAgICAgIHRhaWxwdHIgPSAtMVxuICAgIH1cbiAgICBpZiAoKGhlYWRwdHIgPiAtMSkgJiYgKHRhaWxwdHIgPiAtMSkpIHsgLy8gZWRnZSBjYXNlXG5cbiAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcbiAgICAgICAgICAgIGhlYWRwdHIgPSAtMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFpbHB0ciA9IC0xXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNvbGxlY3Qgbm90aWZpY2F0aW9ucyB0byBtYWluIHRocmVhZCAoZmlsdGVyZWQgaW50ZXJzZWN0aW9ucylcbiAgICAvLyBmb3Igc2Nyb2xsYmFja3dhcmRcbiAgICBsZXQgaGVhZHJlZmluZGV4LCB0YWlscmVmaW5kZXggLy8gZm9yIHJldHVyblxuICAgIGlmICghc2Nyb2xsZm9yd2FyZCAmJiAoaGVhZHB0ciA+PSAwKSkge1xuICAgICAgICBoZWFkcmVmaW5kZXggPSBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlc1toZWFkcHRyXVxuICAgICAgICBsZXQgcmVmaW5kZXggPSBoZWFkcmVmaW5kZXggKyAxXG4gICAgICAgIGxldCByZWZpbnRlcnNlY3RpbmcgPSBpbnRlcnNlY3RpbmdbcmVmaW5kZXggLSAxXS5pbnRlcnNlY3RpbmdcblxuICAgICAgICBmb3IgKGxldCBwdHIgPSBoZWFkcHRyOyBwdHIgPj0gMDsgcHRyLS0pIHtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gaGVhZGludGVyc2VjdGlvbmluZGV4ZXNbcHRyXVxuXG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBjb250aW51aXR5IGFuZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgaWYgKCgoaW5kZXggKyAxKSA9PSByZWZpbmRleCkgJiYgKGludGVyc2VjdGluZ1tpbmRleF0uaW50ZXJzZWN0aW5nID09IHJlZmludGVyc2VjdGluZykpIHtcblxuICAgICAgICAgICAgICAgIGZpbHRlcmVkaW50ZXJzZWN0aW9ucy5wdXNoKGhlYWRpbnRlcnNlY3Rpb25zW3B0cl0pXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZmluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tyZWZpbmRleF0uaW50ZXJzZWN0aW5nXG5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2Nyb2xsZm9yd2FyZFxuICAgIGlmIChzY3JvbGxmb3J3YXJkICYmICh0YWlscHRyID49IDApKSB7XG4gICAgICAgIHRhaWxyZWZpbmRleCA9IHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzW3RhaWxwdHJdXG4gICAgICAgIGxldCByZWZpbmRleCA9IHRhaWxyZWZpbmRleCAtIDFcbiAgICAgICAgbGV0IHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tyZWZpbmRleCArIDFdLmludGVyc2VjdGluZ1xuXG4gICAgICAgIGZvciAobGV0IHB0ciA9IHRhaWxwdHI7IHB0ciA8IHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzLmxlbmd0aDsgcHRyKyspIHtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGFpbGludGVyc2VjdGlvbmluZGV4ZXNbcHRyXVxuXG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBjb250aW51aXR5IGFuZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgaWYgKCgoaW5kZXggLSAxKSA9PSByZWZpbmRleCkgJiYgKGludGVyc2VjdGluZ1tpbmRleF0uaW50ZXJzZWN0aW5nID09IHJlZmludGVyc2VjdGluZykpIHtcblxuICAgICAgICAgICAgICAgIGZpbHRlcmVkaW50ZXJzZWN0aW9ucy5wdXNoKHRhaWxpbnRlcnNlY3Rpb25zW3B0cl0pXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZmluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tpbmRleF0uaW50ZXJzZWN0aW5nXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlcmVkaW50ZXJzZWN0aW9ucy5zb3J0KGVudHJ5Y29tcGFyZSkgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBpbnRlZ3JhdGVkIGludG8gdGhlIGNvZGUgYWJvdmVcblxuICAgIHJldHVybiBmaWx0ZXJlZGludGVyc2VjdGlvbnMgXG5cbn1cblxubGV0IGluZGV4Y29tcGFyZSA9IChhLGIpID0+IHtcbiAgICBsZXQgcmV0dmFsID0gKGEgPCBiKT8tMToxXG4gICAgcmV0dXJuIHJldHZhbFxufVxuXG5sZXQgZW50cnljb21wYXJlID0gKGEsYikgPT4ge1xuICAgIGxldCByZXR2YWwgPSAocGFyc2VJbnQoYS50YXJnZXQuZGF0YXNldC5pbmRleCkgPCBwYXJzZUludChiLnRhcmdldC5kYXRhc2V0LmluZGV4KSk/IC0xOjFcbiAgICByZXR1cm4gcmV0dmFsXG59XG5cbmxldCBkdXBsaWNhdGVjb21wYXJlID0gKGEsYikgPT4ge1xuICAgIGxldCByZXR2YWwgPSAoYS50aW1lIDwgYi50aW1lKT8tMToxXG59XG5cbmV4cG9ydCBjb25zdCBjYWxjQ29udGVudFNoaWZ0cyA9ICh7IC8vIGNhbGxlZCBvbmx5IGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgIGNyYWRsZVByb3BzLFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuICAgIGNyYWRsZUNvbnRlbnQsXG4gICAgY3JhZGxlQ29uZmlnLFxuICAgIHZpZXdwb3J0RWxlbWVudCxcbiAgICBpdGVtRWxlbWVudHMsXG4gICAgaW50ZXJzZWN0aW9ucyxcbiAgICBzY3JvbGxmb3J3YXJkLFxufSkgPT4ge1xuXG4gICAgLy8gdW5wYWNrXG4gICAgbGV0IHsgZ2FwLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgcnVud2F5Y291bnQgfSA9IGNyYWRsZVByb3BzXG5cbiAgICBsZXQgc3BpbmVFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuc3BpbmUuY3VycmVudFxuICAgIGxldCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWQuY3VycmVudFxuICAgIGxldCB0YWlsRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWwuY3VycmVudFxuXG4gICAgbGV0IGNyYWRsZWNvbnRlbnRsaXN0ID0gY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbFxuICAgIGxldCBoZWFkY29udGVudGxpc3QgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbFxuICAgIGxldCB0YWlsY29udGVudGxpc3QgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbFxuXG4gICAgbGV0IHsgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIGl0ZW1PYnNlcnZlclRocmVzaG9sZCB9ID0gY3JhZGxlQ29uZmlnXG5cbiAgICAvLyAtLS0tLS0tIGNhbGN1bGF0ZSBjcmFkbGVib3VuZGFyeSBhbmQgYm91bmRhcnkgcm93IGFuZCBpdGVtIGNvdW50IGZvciBvdmVyc2hvb3RcbiAgICBcbiAgICBsZXQgc3RhcnRpbmdzcGluZW9mZnNldCwgaGVhZGJsb2Nrb2Zmc2V0LCB0YWlsYmxvY2tvZmZzZXQsIHZpZXdwb3J0bGVuZ3RoXG4gICAgbGV0IHZpZXdwb3J0Z2FwbGVuZ3RoXG5cbiAgICBsZXQgY2VsbExlbmd0aCA9IChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9jZWxsSGVpZ2h0ICsgZ2FwOmNlbGxXaWR0aCArIGdhcFxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBzdGFydGluZ3NwaW5lb2Zmc2V0ID0gc3BpbmVFbGVtZW50Lm9mZnNldFRvcCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgaGVhZGJsb2Nrb2Zmc2V0ID0gaGVhZEVsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgIHRhaWxibG9ja29mZnNldCA9IHRhaWxFbGVtZW50Lm9mZnNldFRvcCAvLyBhbHdheXMgMFxuICAgICAgICB2aWV3cG9ydGxlbmd0aCA9IHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHRcblxuICAgICAgICAvLyBtZWFzdXJlIGFueSBnYXAgYmV0d2VlbiB0aGUgY3JhZGxlIGFuZCB0aGUgdmlld3BvcnQgYm91bmRhcnlcbiAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuICAgICAgICAgICAgdmlld3BvcnRnYXBsZW5ndGggPSB2aWV3cG9ydGxlbmd0aCAtIChzdGFydGluZ3NwaW5lb2Zmc2V0ICsgdGFpbEVsZW1lbnQub2Zmc2V0SGVpZ2h0KVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0Z2FwbGVuZ3RoID0gc3RhcnRpbmdzcGluZW9mZnNldCAtIGhlYWRFbGVtZW50Lm9mZnNldEhlaWdodFxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIGhvcml6b250YWxcblxuICAgICAgICBzdGFydGluZ3NwaW5lb2Zmc2V0ID0gc3BpbmVFbGVtZW50Lm9mZnNldExlZnQgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICBoZWFkYmxvY2tvZmZzZXQgPSBoZWFkRWxlbWVudC5vZmZzZXRMZWZ0XG4gICAgICAgIHRhaWxibG9ja29mZnNldCA9IHRhaWxFbGVtZW50Lm9mZnNldExlZnQgLy8gYWx3YXlzIDBcbiAgICAgICAgdmlld3BvcnRsZW5ndGggPSB2aWV3cG9ydEVsZW1lbnQub2Zmc2V0V2lkdGhcblxuICAgICAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuXG4gICAgICAgICAgICB2aWV3cG9ydGdhcGxlbmd0aCA9IHZpZXdwb3J0bGVuZ3RoIC0gKHN0YXJ0aW5nc3BpbmVvZmZzZXQgKyB0YWlsRWxlbWVudC5vZmZzZXRXaWR0aClcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2aWV3cG9ydGdhcGxlbmd0aCA9IHN0YXJ0aW5nc3BpbmVvZmZzZXQgLSBoZWFkRWxlbWVudC5vZmZzZXRXaWR0aFxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlld3BvcnRnYXBsZW5ndGggPCAwKSB2aWV3cG9ydGdhcGxlbmd0aCA9IDBcbiAgICBpZiAodmlld3BvcnRnYXBsZW5ndGggPiB2aWV3cG9ydGxlbmd0aCkgdmlld3BvcnRnYXBsZW5ndGggPSAwIC8vIHJlcG9zaXRpb24gc2hvdWxkIGhhdmUga2lja2VkIGluXG5cbiAgICBsZXQgb3ZlcnNob290cm93Y291bnQgPSAodmlld3BvcnRnYXBsZW5ndGggPT0gMCk/MDpNYXRoLmNlaWwodmlld3BvcnRnYXBsZW5ndGgvY2VsbExlbmd0aCkgLy8gcm93cyB0byBmaWxsIHZpZXdwb3J0XG5cbiAgICBjb25zb2xlLmxvZygnLS0+IG92ZXJzaG9vdHJvd2NvdW50ID0gdmlld3BvcnRnYXBsZW5ndGgvY2VsbExlbmd0aDsgc2Nyb2xsZm9yd2FyZCcsb3ZlcnNob290cm93Y291bnQsIHZpZXdwb3J0Z2FwbGVuZ3RoLCBjZWxsTGVuZ3RoLCBzY3JvbGxmb3J3YXJkKVxuICAgIC8vIGV4dHJhIHJvd3MgZm9yIHJ1bndheVxuICAgIGlmIChvdmVyc2hvb3Ryb3djb3VudCkge1xuICAgICAgICBvdmVyc2hvb3Ryb3djb3VudCArPSBydW53YXljb3VudFxuICAgIH1cbiAgICBsZXQgb3ZlcnNob290aXRlbWNvdW50ID0gb3ZlcnNob290cm93Y291bnQgKiBjcm9zc2NvdW50XG5cbiAgICAvLyBsZXQgdW5pbmNsdWRlZGhlYWRpdGVtcyA9IDBcbiAgICBpZiAoIXNjcm9sbGZvcndhcmQgJiYgKG92ZXJzaG9vdGl0ZW1jb3VudCAhPSAwKSkgeyAvLyBuZWdhdGlvbiBvZiB2YWx1ZXMgZm9yIHNjcm9sbCBiYWNrd2FyZFxuICAgICAgICBvdmVyc2hvb3RpdGVtY291bnQgPSAtb3ZlcnNob290aXRlbWNvdW50XG4gICAgICAgIG92ZXJzaG9vdHJvd2NvdW50ID0gLW92ZXJzaG9vdHJvd2NvdW50XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgIGNhbGN1bGF0ZSBpdGVtc2hpZnRjb3VudCBpbmNsdWRuZyBvdmVyc2hvb3QgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNoaWZ0IGl0ZW0gY291bnQgaXMgdGhlIG51bWJlciBvZiBpdGVtcyB0aGUgdmlydHVhbCBjcmFkbGUgc2hpZnRzLCBhY2NvcmRpbmcgdG8gb2JzZXJ2ZXIgbm90aWNlc1xuXG4gICAgbGV0IGZvcndhcmRjb3VudCA9IDAsIGJhY2t3YXJkY291bnQgPSAwXG4gICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuICAgICAgICBiYWNrd2FyZGNvdW50ID0gaW50ZXJzZWN0aW9ucy5sZW5ndGhcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yd2FyZGNvdW50ID0gaW50ZXJzZWN0aW9ucy5sZW5ndGhcblxuICAgIH1cblxuICAgIGxldCBpdGVtc2hpZnRjb3VudCA9IGJhY2t3YXJkY291bnQgLSBmb3J3YXJkY291bnQgKyBvdmVyc2hvb3RpdGVtY291bnRcblxuICAgIGNvbnNvbGUubG9nKCdpdGVtc2hpZnRjb3VudCA9IGJhY2t3YXJkY291bnQgLSBmb3J3YXJkY291bnQgKyBvdmVyc2hvb3RpdGVtY291bnQnLFxuICAgICAgICBpdGVtc2hpZnRjb3VudCwgYmFja3dhcmRjb3VudCwgZm9yd2FyZGNvdW50LCBvdmVyc2hvb3RpdGVtY291bnQpXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgcmV0dXJuIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IHByZXZpb3VzcmVmZXJlbmNlaW5kZXggPSB0YWlsY29udGVudGxpc3RbMF0ucHJvcHMuaW5kZXhcblxuICAgIGxldCBwcmV2aW91c2NyYWRsZWluZGV4ID0gY3JhZGxlY29udGVudGxpc3RbMF0ucHJvcHMuaW5kZXhcblxuICAgIGxldCBuZXdjcmFkbGVpbmRleCA9IHByZXZpb3VzY3JhZGxlaW5kZXggKyBpdGVtc2hpZnRjb3VudFxuICAgIGxldCBuZXdyZWZlcmVuY2VpbmRleCA9IHByZXZpb3VzcmVmZXJlbmNlaW5kZXggKyBpdGVtc2hpZnRjb3VudFxuXG4gICAgY29uc29sZS5sb2coJysrKyBuZXdyZWZlcmVuY2VpbmRleCA9IHByZXZpb3VzcmVmZXJlbmNlaW5kZXggKyBpdGVtc2hpZnRjb3VudCcsIFxuICAgICAgICBuZXdyZWZlcmVuY2VpbmRleCwgcHJldmlvdXNyZWZlcmVuY2VpbmRleCwgaXRlbXNoaWZ0Y291bnQpXG5cbiAgICAvLyAtLS0gaGVhZCBiYXNlZCBhZGp1c3RtZW50c1xuICAgIC8vIHJlc2V0IGNyYWRsZWluZGV4IHRvIGJlIHJlbGF0aXZlIHRvIHJlZmVyZW5jZWluZGV4IGJ5IHJ1bndheWNvdW50XG4gICAgaWYgKChuZXdyZWZlcmVuY2VpbmRleCAtIG5ld2NyYWRsZWluZGV4KSA8IChydW53YXljb3VudCAqIGNyb3NzY291bnQpKSB7XG4gICAgICAgIG5ld2NyYWRsZWluZGV4ID0gbmV3cmVmZXJlbmNlaW5kZXggLSAocnVud2F5Y291bnQgKiBjcm9zc2NvdW50KVxuICAgIH1cbiAgICAvLyBjb3JyZWN0IGNyYWRsZWluZGV4IHVuZGVyc2hvb3RcbiAgICBpZiAobmV3Y3JhZGxlaW5kZXggPCAwKSB7XG4gICAgICAgIG5ld2NyYWRsZWluZGV4ID0gMFxuICAgIH1cblxuICAgIGlmIChuZXdyZWZlcmVuY2VpbmRleCA8IDApIHtcbiAgICAgICAgbmV3cmVmZXJlbmNlaW5kZXggPSAwXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ3ByZXZpb3VzY3JhZGxlaW5kZXgsIHByZXZpb3VzcmVmZXJlbmNlaW5kZXgsIG5ld2NyYWRsZWluZGV4LCBuZXdyZWZlcmVuY2VpbmRleCcsXG4gICAgICAgIHByZXZpb3VzY3JhZGxlaW5kZXgsIHByZXZpb3VzcmVmZXJlbmNlaW5kZXgsIG5ld2NyYWRsZWluZGV4LCBuZXdyZWZlcmVuY2VpbmRleClcblxuICAgIC8vIC0tIHRhaWxiYXNlZCBhZGp1c3RtZW50c1xuICAgIGxldCBjcmFkbGVpdGVtY291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICBsZXQgY3JhZGxlYWRqdXN0bWVudCA9IGxpc3RzaXplICUgY3Jvc3Njb3VudFxuICAgIGlmIChjcmFkbGVhZGp1c3RtZW50KSBjcmFkbGVhZGp1c3RtZW50ID0gY3Jvc3Njb3VudCAtIGNyYWRsZWFkanVzdG1lbnRcbiAgICBjb25zb2xlLmxvZygnY3JhZGxlaXRlbWNvdW50LCBjcmFkbGVhZGp1c3RtZW50LCBjcm9zc2NvdW50LCBsaXN0c2l6ZScsXG4gICAgICAgIGNyYWRsZWl0ZW1jb3VudCwgY3JhZGxlYWRqdXN0bWVudCwgY3Jvc3Njb3VudCwgbGlzdHNpemUpXG4gICAgaWYgKChuZXdjcmFkbGVpbmRleCArIGNyYWRsZWl0ZW1jb3VudCkgPiAobGlzdHNpemUpKSB7XG4gICAgICAgIGxldCBkaWZmID0gbGlzdHNpemUgLSAobmV3Y3JhZGxlaW5kZXggKyBjcmFkbGVpdGVtY291bnQpXG4gICAgICAgIG5ld2NyYWRsZWluZGV4IC09IGRpZmZcbiAgICB9XG5cbiAgICBsZXQgdmlld3BvcnRmdWxscm93cyA9IE1hdGguZmxvb3Iodmlld3BvcnRsZW5ndGgvY2VsbExlbmd0aClcbiAgICBsZXQgdGFyZ2V0aW5kZXhyb3cgPSBuZXdyZWZlcmVuY2VpbmRleC9jcm9zc2NvdW50IC8vIDAtYmFzZWRcbiAgICBsZXQgbWF4cmVmaW5kZXhyb3cgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudCkgLSB2aWV3cG9ydGZ1bGxyb3dzXG4gICAgaWYgKHRhcmdldGluZGV4cm93ID49IG1heHJlZmluZGV4cm93KSB7XG4gICAgICAgIG5ld3JlZmVyZW5jZWluZGV4ID0gKG1heHJlZmluZGV4cm93ICogY3Jvc3Njb3VudCkgLy8gKCh0YXJnZXRpbmRleHJvdyAtIG1heHJlZmluZGV4cm93KSAqIGNyb3NzY291bnQpXG4gICAgICAgIGNvbnNvbGUubG9nKCc+Pj5zZXR0aW5nIHJlZmVyZW5jZWluZGV4IHRvIG1heHJlZmluZGV4cm93JyxuZXdyZWZlcmVuY2VpbmRleClcbiAgICB9XG5cbiAgICBsZXQgY3JhZGxlaXRlbXNoaWZ0Y291bnQgPSBuZXdjcmFkbGVpbmRleCAtIHByZXZpb3VzY3JhZGxlaW5kZXhcbiAgICBsZXQgcmVmZXJlbmNlaXRlbXNoaWZ0Y291bnQgPSBuZXdyZWZlcmVuY2VpbmRleCAtIHByZXZpb3VzcmVmZXJlbmNlaW5kZXhcblxuICAgIGxldCByZWZlcmVuY2Vyb3dzaGlmdCA9IHJlZmVyZW5jZWl0ZW1zaGlmdGNvdW50L2Nyb3NzY291bnRcbiAgICBsZXQgcmVmZXJlbmNlcGl4ZWxzaGlmdCA9IHJlZmVyZW5jZXJvd3NoaWZ0ICogY2VsbExlbmd0aFxuXG4gICAgbGV0IHNwaW5lT2Zmc2V0ID0gc3RhcnRpbmdzcGluZW9mZnNldCArIHJlZmVyZW5jZXBpeGVsc2hpZnRcblxuICAgIGNvbnNvbGUubG9nKCdzcGluZU9mZnNldCA9IHN0YXJ0aW5nc3BpbmVvZmZzZXQgKyByZWZlcmVuY2VwaXhlbHNoaWZ0OyByZWZlcmVuY2Vyb3dzaGlmdCcsXG4gICAgICAgIHNwaW5lT2Zmc2V0LCBzdGFydGluZ3NwaW5lb2Zmc2V0LCByZWZlcmVuY2VwaXhlbHNoaWZ0LCByZWZlcmVuY2Vyb3dzaGlmdClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdhZGp1c3RlZCBzcGluZU9mZnNldCwgY3Jvc3Njb3VudCwgY2VsbExlbmd0aCwgcmVmZXJlbmNlaXRlbXNoaWZ0Y291bnQsIHJlZmVyZW5jZXJvd3NoaWZ0JywgXG4gICAgLy8gICAgIHNwaW5lT2Zmc2V0LCBjcm9zc2NvdW50LCBjZWxsTGVuZ3RoLCByZWZlcmVuY2VpdGVtc2hpZnRjb3VudCwgcmVmZXJlbmNlcm93c2hpZnQpXG5cbiAgICBjcmFkbGVpdGVtY291bnQgLT0gY3JhZGxlYWRqdXN0bWVudFxuXG4gICAgcmV0dXJuIFtuZXdjcmFkbGVpbmRleCwgY3JhZGxlaXRlbXNoaWZ0Y291bnQsIG5ld3JlZmVyZW5jZWluZGV4LCByZWZlcmVuY2VpdGVtc2hpZnRjb3VudCwgc3BpbmVPZmZzZXQsIGNyYWRsZWl0ZW1jb3VudF1cblxufVxuXG5leHBvcnQgY29uc3QgY2FsY0hlYWRBbmRUYWlsQ2hhbmdlcyA9IChcbiAgICB7XG4gICAgICAgIGNyYWRsZVByb3BzLFxuICAgICAgICBpdGVtc2hpZnRjb3VudCxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgIHRhaWxjb250ZW50LFxuICAgICAgICBzY3JvbGxmb3J3YXJkLFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgY3JhZGxlcm93Y291bnQsXG4gICAgICAgIC8vIGxpc3RzaXplLFxuICAgIH0pID0+IHtcblxuICAgIGxldCBsaXN0c2l6ZSA9IGNyYWRsZVByb3BzLmxpc3RzaXplXG4gICAgaXRlbXNoaWZ0Y291bnQgPSBNYXRoLmFicyhpdGVtc2hpZnRjb3VudCkgXG4gICAgbGV0IHJvd3NoaWZ0Y291bnQgPSBNYXRoLmNlaWwoaXRlbXNoaWZ0Y291bnQvY3Jvc3Njb3VudCkgLy8rIGJvdW5kYXJ5cm93Y291bnRcblxuICAgIGxldCBoZWFkcm93Y291bnQsIHRhaWxyb3djb3VudFxuICAgIGhlYWRyb3djb3VudCA9IE1hdGguY2VpbChoZWFkY29udGVudC5sZW5ndGgvY3Jvc3Njb3VudClcbiAgICB0YWlscm93Y291bnQgPSBNYXRoLmNlaWwodGFpbGNvbnRlbnQubGVuZ3RoL2Nyb3NzY291bnQpXG5cbiAgICBsZXQgcGVuZGluZ2NvbnRlbnRvZmZzZXQgLy8gbG9va2FoZWFkIHRvIG5ldyBjcmFkbGVSZWZlcmVuY2VJbmRleFxuXG4gICAgbGV0IGhlYWRjaGFuZ2Vjb3VudCwgdGFpbGNoYW5nZWNvdW50IC8vIHRoZSBvdXRwdXQgaW5zdHJ1Y3Rpb25zIGZvciBnZXRVSUNvbnRlbnRMaXN0XG5cbiAgICAvLyBhbnRpY2lwYWF0ZSBhZGQgdG8gb25lIGVuZCwgY2xpcCBmcm9tIHRoZSBvdGhlciAgICAgICAgXG4gICAgbGV0IGFkZGl0ZW1jb3VudCA9IDBcbiAgICBsZXQgY2xpcHJvd2NvdW50ID0gMCwgY2xpcGl0ZW1jb3VudCA9IDBcblxuICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7IC8vIGNsaXAgZnJvbSBoZWFkOyBhZGQgdG8gdGFpbDsgc2Nyb2xsIGZvcndhcmQgaGVhZCBpcyBkaXJlY3Rpb24gb2Ygc2Nyb2xsXG5cbiAgICAgICAgLy8gYWRqdXN0IGNsaXBpdGVtY291bnRcbiAgICAgICAgaWYgKChoZWFkcm93Y291bnQgKyByb3dzaGlmdGNvdW50KSA+IChjcmFkbGVQcm9wcy5ydW53YXljb3VudCkpIHtcblxuICAgICAgICAgICAgbGV0IHJvd2RpZmYgPSAoaGVhZHJvd2NvdW50ICsgcm93c2hpZnRjb3VudCkgLSAoY3JhZGxlUHJvcHMucnVud2F5Y291bnQpXG4gICAgICAgICAgICBjbGlwcm93Y291bnQgPSByb3dkaWZmXG4gICAgICAgICAgICBjbGlwaXRlbWNvdW50ID0gKGNsaXByb3djb3VudCAqIGNyb3NzY291bnQpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFkZGl0ZW1jb3VudCA9IGNsaXBpdGVtY291bnQgLy8gbWFpbnRhaW4gY29uc3RhbnQgY3JhZGxlIGNvdW50XG5cbiAgICAgICAgcGVuZGluZ2NvbnRlbnRvZmZzZXQgPSBjcmFkbGVSZWZlcmVuY2VJbmRleCArIGNsaXBpdGVtY291bnQgLy8gYWZ0ZXIgY2xpcFxuXG4gICAgICAgIGxldCBwcm9wb3NlZHRhaWxpbmRleCA9IHBlbmRpbmdjb250ZW50b2Zmc2V0ICsgKGNyYWRsZXJvd2NvdW50ICogY3Jvc3Njb3VudCkgLSAxIC8vIG1vZGVsY29udGVudGxpc3QubGVuZ3RoIC0gMVxuXG4gICAgICAgIC8vIGFka2p1c3QgY2hhbmdlcyBmb3IgbGlzdCBib3VuZGFyaWVzXG4gICAgICAgIGlmICgocHJvcG9zZWR0YWlsaW5kZXgpID4gKGxpc3RzaXplIC0xKSApIHtcblxuICAgICAgICAgICAgbGV0IGRpZmZpdGVtY291bnQgPSAocHJvcG9zZWR0YWlsaW5kZXggLSAobGlzdHNpemUgLTEpKSAvLyBpdGVtcyBvdXRzaWRlIHJhbmdlXG4gICAgICAgICAgICBhZGRpdGVtY291bnQgLT0gZGlmZml0ZW1jb3VudCAvLyBhZGp1c3QgdGhlIGFkZGNvbnRlbnQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGRpZmZyb3dzID0gTWF0aC5mbG9vcihkaWZmaXRlbWNvdW50L2Nyb3NzY291bnQpIC8vIG51bWJlciBvZiBmdWxsIHJvd3MgdG8gbGVhdmUgaW4gcGxhY2VcbiAgICAgICAgICAgIGxldCBkaWZmcm93aXRlbXMgPSAoZGlmZnJvd3MgKiBjcm9zc2NvdW50KSAgLy8gZGVyaXZlZCBudW1iZXIgb2YgaXRlbXMgdG8gbGVhdmUgaW4gcGxhY2VcblxuICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCAtPSBkaWZmcm93aXRlbXMgLy8gYXBwbHkgYWRqdXN0bWVudCB0byBuZXRzaGlmdFxuXG4gICAgICAgICAgICBpZiAoYWRkaXRlbWNvdW50IDw9MCkgeyAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgICAgICAgICBhZGRpdGVtY291bnQgPSAwXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGlwaXRlbWNvdW50IDw9MCApIHtcblxuICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgPSAwXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkY2hhbmdlY291bnQgPSAtY2xpcGl0ZW1jb3VudFxuICAgICAgICB0YWlsY2hhbmdlY291bnQgPSBhZGRpdGVtY291bnRcblxuICAgIH0gZWxzZSB7IC8vIHNjcm9sbCBiYWNrd2FyZCwgaW4gZGlyZWN0aW9uIG9mIHRhaWw7IGNsaXAgZnJvbSB0YWlsLCBhZGQgdG8gaGVhZFxuXG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb25pbmRleGVzID0gW11cblxuICAgICAgICAvLyBoZWFkY291bnQgd2lsbCBiZSBsZXNzIHRoYW4gbWluaW11bSAocnVud2F5Y291bnQpLCBzbyBhIHNoaWZ0IGNhbiBiZSBhY2NvbXBsaXNoZWRbXVxuICAgICAgICBpZiAoKGhlYWRyb3djb3VudCAtIHJvd3NoaWZ0Y291bnQpIDwgKGNyYWRsZVByb3BzLnJ1bndheWNvdW50KSkge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGNsaXAgZm9yIHRhaWxcbiAgICAgICAgICAgIGxldCByb3dzaG9ydGZhbGwgPSAoY3JhZGxlUHJvcHMucnVud2F5Y291bnQpIC0gKGhlYWRyb3djb3VudCAtIHJvd3NoaWZ0Y291bnQpXG5cbiAgICAgICAgICAgIGNsaXByb3djb3VudCA9IHJvd3Nob3J0ZmFsbFxuICAgICAgICAgICAgbGV0IHRhaWxyb3dpdGVtY291bnQgPSAodGFpbGNvbnRlbnQubGVuZ3RoICUgY3Jvc3Njb3VudClcblxuICAgICAgICAgICAgaWYgKHRhaWxyb3dpdGVtY291bnQgPT0gMCkgdGFpbHJvd2l0ZW1jb3VudCA9IGNyb3NzY291bnRcblxuICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IHRhaWxyb3dpdGVtY291bnRcbiAgICAgICAgICAgIGlmICh0YWlscm93Y291bnQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpcHJvd2NvdW50ID4gdGFpbHJvd2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXByb3djb3VudCA9IHRhaWxyb3djb3VudFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjbGlwcm93Y291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgKz0gKChjbGlwcm93Y291bnQgLTEpICogY3Jvc3Njb3VudClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29tcGVuc3RhdGUgd2l0aCBhZGRpdGVtY291bnRcbiAgICAgICAgICAgIGFkZGl0ZW1jb3VudCA9IChjbGlwcm93Y291bnQgKiBjcm9zc2NvdW50KVxuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHJvcG9zZWRpbmRleG9mZnNldCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4IC0gYWRkaXRlbWNvdW50XG5cbiAgICAgICAgaWYgKHByb3Bvc2VkaW5kZXhvZmZzZXQgPCAwKSB7XG5cbiAgICAgICAgICAgIGxldCBkaWZmaXRlbWNvdW50ID0gLXByb3Bvc2VkaW5kZXhvZmZzZXRcbiAgICAgICAgICAgIGxldCBkaWZmcm93cyA9IE1hdGguY2VpbChkaWZmaXRlbWNvdW50L2Nyb3NzY291bnQpIC8vIG51bWJlciBvZiBmdWxsIHJvd3MgdG8gbGVhdmUgaW4gcGxhY2VcbiAgICAgICAgICAgIGxldCBkaWZmcm93aXRlbXMgPSAoZGlmZnJvd3MgKiBjcm9zc2NvdW50KVxuXG4gICAgICAgICAgICBhZGRpdGVtY291bnQgLT0gZGlmZml0ZW1jb3VudFxuICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCAtPSBkaWZmcm93aXRlbXNcblxuICAgICAgICAgICAgaWYgKGFkZGl0ZW1jb3VudCA8PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBhZGRpdGVtY291bnQgPSAwXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbGlwaXRlbWNvdW50IDw9IDApIHtcblxuICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgPSAwXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRjaGFuZ2Vjb3VudCA9IGFkZGl0ZW1jb3VudFxuICAgICAgICB0YWlsY2hhbmdlY291bnQgPSAtY2xpcGl0ZW1jb3VudFxuXG4gICAgfVxuICAgIHJldHVybiBbaGVhZGNoYW5nZWNvdW50LHRhaWxjaGFuZ2Vjb3VudF1cblxufVxuXG4vLyB1cGRhdGUgY29udGVudFxuLy8gYWRkcyBpdGVtc2hlbGxzIGF0IGVuZCBvZiBjb250ZW50bGlzdCBhY2NvcmRpbmcgdG8gaGVhZGluZGV4Y291bnQgYW5kIHRhaWxpbmRlc2NvdW50LFxuLy8gb3IgaWYgaW5kZXhjb3VudCB2YWx1ZXMgYXJlIDwwIHJlbW92ZXMgdGhlbS5cbmV4cG9ydCBjb25zdCBnZXRVSUNvbnRlbnRMaXN0ID0gKHsgXG5cbiAgICAgICAgY29udGVudENvdW50LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAvLyBjcmFkbGVpdGVtc2hpZnQsXG4gICAgICAgIC8vIGNvbnRlbnQsXG4gICAgICAgIGNyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgaGVhZGNoYW5nZWNvdW50LCBcbiAgICAgICAgdGFpbGNoYW5nZWNvdW50LCBcbiAgICAgICAgY3JhZGxlUHJvcHMsXG4gICAgICAgIGxvY2FsQ29udGVudExpc3Q6Y29udGVudGxpc3QsXG4gICAgICAgIGNhbGxiYWNrcyxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgIH0pID0+IHtcblxuICAgIGxldCB7IG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBsaXN0c2l6ZSB9ID0gY3JhZGxlUHJvcHNcblxuICAgIGxldCBsb2NhbENvbnRlbnRsaXN0ID0gWy4uLmNvbnRlbnRsaXN0XVxuICAgIGxldCB0YWlsaW5kZXhvZmZzZXQgPSBjcmFkbGVSZWZlcmVuY2VJbmRleCArIGNvbnRlbnRsaXN0Lmxlbmd0aFxuICAgIC8vIGxldCBoZWFkaW5kZXhvZmZzZXQgPSBjcmFkbGVSZWZlcmVuY2VJbmRleFxuICAgIGxldCByZXR1cm5Db250ZW50bGlzdFxuXG4gICAgbGV0IGhlYWRDb250ZW50bGlzdCA9IFtdXG5cbiAgICBsZXQgdG9wY29uc3RyYWludCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4IC0gaGVhZGNoYW5nZWNvdW50LFxuICAgIGJvdHRvbWNvbnN0cmFpbnQgPSAoY3JhZGxlUmVmZXJlbmNlSW5kZXggLSBoZWFkY2hhbmdlY291bnQpICsgKGNvbnRlbnRDb3VudCArIDEpIC8vIFRPRE86IHZhbGlkYXRlIFwiKzFcIlxuXG4gICAgLy8gY29uc29sZS5sb2coJ3RvcGNvbnN0cmFpbnQsIGJvdHRvbWNvbnN0cmFpbnQsIGNyYWRsZVJlZmVyZW5jZUluZGV4LCBjb250ZW50Q291bnQsIGhlYWRjaGFuZ2Vjb3VudCwgdGFpbGNoYW5nZWNvdW50JywgXG4gICAgLy8gICAgIHRvcGNvbnN0cmFpbnQsIGJvdHRvbWNvbnN0cmFpbnQsIGNyYWRsZVJlZmVyZW5jZUluZGV4LCBjb250ZW50Q291bnQsIGhlYWRjaGFuZ2Vjb3VudCwgdGFpbGNoYW5nZWNvdW50KVxuXG4gICAgaWYgKGhlYWRjaGFuZ2Vjb3VudCA+PSAwKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBjcmFkbGVSZWZlcmVuY2VJbmRleCAtIGhlYWRjaGFuZ2Vjb3VudDsgaW5kZXggPCAoY3JhZGxlUmVmZXJlbmNlSW5kZXgpOyBpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGlmICghKChpbmRleCA+PSB0b3Bjb25zdHJhaW50KSAmJiAoaW5kZXggPD0gYm90dG9tY29uc3RyYWludCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGVtaXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlciwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbG9jYWxDb250ZW50bGlzdC5zcGxpY2UoIDAsIC1oZWFkY2hhbmdlY291bnQgKVxuXG4gICAgfVxuXG4gICAgbGV0IHRhaWxDb250ZW50bGlzdCA9IFtdXG5cbiAgICBpZiAodGFpbGNoYW5nZWNvdW50ID49IDApIHtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRhaWxpbmRleG9mZnNldDsgaW5kZXggPCAodGFpbGluZGV4b2Zmc2V0ICsgdGFpbGNoYW5nZWNvdW50KTsgaW5kZXgrKykge1xuXG4gICAgICAgICAgICBpZiAoISgoaW5kZXggPj0gdG9wY29uc3RyYWludCkgJiYgKGluZGV4IDw9IGJvdHRvbWNvbnN0cmFpbnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWlsQ29udGVudGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBlbWl0SXRlbShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSh0YWlsY2hhbmdlY291bnQsLXRhaWxjaGFuZ2Vjb3VudClcblxuICAgIH1cblxuICAgIHJldHVybkNvbnRlbnRsaXN0ID0gaGVhZENvbnRlbnRsaXN0LmNvbmNhdChsb2NhbENvbnRlbnRsaXN0LHRhaWxDb250ZW50bGlzdClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdjb21wb25lbnRzIG9mIGdldGNvbnRlbnRsaXN0OiByZXR1cm5Db250ZW50TGlzdCwgaGVhZENvbnRlbnRsaXN0LCBsb2NhbENvbnRlbnRsaXN0LCB0YWlsQ29udGVudGxpc3QnLCBcbiAgICAvLyAgICAgcmV0dXJuQ29udGVudGxpc3QsIGhlYWRDb250ZW50bGlzdCwgbG9jYWxDb250ZW50bGlzdCwgdGFpbENvbnRlbnRsaXN0KVxuXG4gICAgcmV0dXJuIHJldHVybkNvbnRlbnRsaXN0XG59XG5cbi8vIGJ1dHRlcmZseSBtb2RlbC4gTGVhZGluZyAoaGVhZCkgYWxsIG9yIHBhcnRpYWxseSBoaWRkZW47IHRhaWwsIHZpc2libGUgcGx1cyBmb2xsb3dpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIHNwaW5lUmVmZXJlbmNlSW5kZXgsIC8vIGZpcnN0IHRhaWwgaXRlbVxuXG4gICAgfVxuKSA9PiB7XG5cbiAgICBsZXQgb2Zmc2V0aW5kZXggPSBjb250ZW50bGlzdFswXS5wcm9wcy5pbmRleFxuXG4gICAgbGV0IGhlYWRpdGVtY291bnRcblxuICAgIGhlYWRpdGVtY291bnQgPSAoc3BpbmVSZWZlcmVuY2VJbmRleCAtIG9mZnNldGluZGV4KVxuXG4gICAgbGV0IGhlYWRsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoMCxoZWFkaXRlbWNvdW50KVxuICAgIGxldCB0YWlsbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKGhlYWRpdGVtY291bnQpXG5cbiAgICByZXR1cm4gW2hlYWRsaXN0LHRhaWxsaXN0XVxuXG59XG5cbmNvbnN0IGVtaXRJdGVtID0gKHtcbiAgICBpbmRleCwgXG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgb2JzZXJ2ZXIsIFxuICAgIGNhbGxiYWNrcywgXG4gICAgZ2V0SXRlbSwgXG4gICAgbGlzdHNpemUsIFxuICAgIHBsYWNlaG9sZGVyXG59KSA9PiB7XG5cbiAgICByZXR1cm4gPEl0ZW1TaGVsbFxuICAgICAgICBrZXkgPSB7aW5kZXh9IFxuICAgICAgICBvcmllbnRhdGlvbiA9IHtvcmllbnRhdGlvbn1cbiAgICAgICAgY2VsbEhlaWdodCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgIGNlbGxXaWR0aCA9IHsgY2VsbFdpZHRoIH1cbiAgICAgICAgaW5kZXggPSB7aW5kZXh9XG4gICAgICAgIG9ic2VydmVyID0ge29ic2VydmVyfVxuICAgICAgICBjYWxsYmFja3MgPSB7Y2FsbGJhY2tzfVxuICAgICAgICBnZXRJdGVtID0ge2dldEl0ZW19XG4gICAgICAgIGxpc3RzaXplID0ge2xpc3RzaXplfVxuICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgIC8+ICAgIFxuXG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0eWxlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBzZXRDcmFkbGVHcmlkU3R5bGVzID0gKHtcblxuICAgIG9yaWVudGF0aW9uLCBcbiAgICBoZWFkQ3JhZGxlU3R5bGVzOmhlYWRzdHlsZXNvYmplY3QsIFxuICAgIHRhaWxDcmFkbGVTdHlsZXM6dGFpbHN0eWxlc29iamVjdCxcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIGdhcCxcbiAgICBwYWRkaW5nLCBcbiAgICBjcm9zc2NvdW50LCBcbiAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgdmlld3BvcnR3aWR0aFxuXG59KSA9PiB7XG5cbiAgICAgICAgbGV0IGhlYWRzdHlsZXMgPSB7Li4uaGVhZHN0eWxlc29iamVjdH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgICAgICBsZXQgdGFpbHN0eWxlcyA9IHsuLi50YWlsc3R5bGVzb2JqZWN0fSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG5cbiAgICAgICAgaGVhZHN0eWxlcy5ncmlkR2FwID0gZ2FwICsgJ3B4J1xuXG4gICAgICAgIHRhaWxzdHlsZXMuZ3JpZEdhcCA9IGdhcCArICdweCdcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggMCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAnY29sdW1uJ1xuICAgICAgICAgICAgLy8gZXhwbGljdCBjcm9zc2NvdW50IG5leHQgbGluZSBhcyB3b3JrYXJvdW5kIGZvciBGRiBwcm9ibGVtIC0gXG4gICAgICAgICAgICAvLyAgICAgc2V0cyBsZW5ndGggb2YgaG9yaXogY3JhZGxlIGl0ZW1zIGluIG9uZSBsaW5lIChyb3cpLCBub3QgbXVsdGktcm93IGNvbmZpZ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gY2VsbEhlaWdodD9gcmVwZWF0KCR7Y3Jvc3Njb3VudH0sIG1pbm1heCgke2NlbGxIZWlnaHR9cHgsIDFmcikpYDonYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9ICdub25lJ1xuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMGBcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ2NvbHVtbidcbiAgICAgICAgICAgIC8vIGV4cGxpY3QgY3Jvc3Njb3VudCBuZXh0IGxpbmUgYXMgd29ya2Fyb3VuZCBmb3IgRkYgcHJvYmxlbSAtIFxuICAgICAgICAgICAgLy8gICAgIHNldHMgbGVuZ3RoIG9mIGhvcml6IGNyYWRsZSBpdGVtcyBpbiBvbmUgbGluZSAocm93KSwgbm90IG11bHRpLXJvdyBjb25maWdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IGNlbGxIZWlnaHQ/YHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsSGVpZ2h0fXB4LCAxZnIpKWA6J2F1dG8nXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSAnbm9uZSdcblxuICAgICAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdyb3cnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9ICdub25lJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gY2VsbFdpZHRoP2ByZXBlYXQoYXV0by1maXQsIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgOidhdXRvJ1xuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLnBhZGRpbmcgPSBgMCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5oZWlnaHQgPSAnYXV0bydcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ3JvdydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gJ25vbmUnXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBjZWxsV2lkdGg/YHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KCR7Y2VsbFdpZHRofXB4LCAxZnIpKWA6J2F1dG8nXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbaGVhZHN0eWxlcyx0YWlsc3R5bGVzXVxuICAgICAgICBcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradlefunctions.tsx\n");

/***/ }),

/***/ "./src/infinitegridscroller.tsx":
/*!**************************************!*\
  !*** ./src/infinitegridscroller.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // infinitegridscroller.tsx\n// copyright (c) 2019 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __importDefault(__webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\"));\n\nvar scrollblock_1 = __importDefault(__webpack_require__(/*! ./scrollblock */ \"./src/scrollblock.tsx\"));\n\nvar cradle_1 = __importDefault(__webpack_require__(/*! ./cradle */ \"./src/cradle.tsx\"));\n/*\n    BACKLOG:\n    - cache: none/preload/keepload\n*/\n// ===================================[ INITIALIZE ]===========================\n\n/*\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the scrollblock, which in turn contains the cradle\n        - a component that contains displayed (or nearly displayed) items.\n    The items are skeletons which contain the host content components.\n\n    Scrollblock virtually represents the entirety of the list, and of course scrolls\n    Cradle contains the list items, and is 'virtualiized' -- it appears as\n      though it is the full scrollblock, but in fact it is only slightly larger than\n      the viewport.\n    - individual items are framed by ItemShell, managed by Cradle\n\n    Overall the infinitegridscroller manages the often asynchronous interactions of the\n    components of the mechanism\n*/\n\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  var orientation = props.orientation,\n      // vertical or horizontal\n  gap = props.gap,\n      // space between grid cells, not including the leading and trailing edges\n  padding = props.padding,\n      // the space between the items and the viewport, applied to the cradle\n  cellHeight = props.cellHeight,\n      // the outer pixel height - literal for vertical; approximate for horizontal\n  cellWidth = props.cellWidth,\n      // the outer pixel width - literal for horizontal; approximate for vertical\n  runway = props.runway,\n      // the number of items outside the view of each side of the viewport \n  // -- gives time to assemble before display\n  listsize = props.listsize,\n      // the exact number of the size of the virtual list\n  indexOffset = props.indexOffset,\n      // the 0-based starting index of the list, when first loaded\n  getItem = props.getItem,\n      // function provided by host - parameter is index number, set by system; return value is \n  // host-selected component or promise of a component\n  functions = props.functions,\n      // properties with direct access to some component utilites, optional\n  placeholder = props.placeholder,\n      // a sparse component to stand in for content until the content arrives; \n  // optional, replaces default\n  styles = props.styles,\n      // passive style over-rides (eg. color, opacity) for viewport, scrollblock, cradle, or scrolltracker\n  // to come...\n  // cache = \"preload\", \"keepload\", \"none\"\n  // dense, // boolean (only with preload)\n  layout = props.layout; // defaults\n\n  (_a = functions) !== null && _a !== void 0 ? _a : functions = {};\n  (_b = gap) !== null && _b !== void 0 ? _b : gap = 0;\n  (_c = padding) !== null && _c !== void 0 ? _c : padding = 0;\n  (_d = runway) !== null && _d !== void 0 ? _d : runway = 3;\n  (_e = indexOffset) !== null && _e !== void 0 ? _e : indexOffset = 0;\n  (_f = listsize) !== null && _f !== void 0 ? _f : listsize = 0;\n  (_g = layout) !== null && _g !== void 0 ? _g : layout = 'uniform'; // constraints\n\n  indexOffset = Math.max(0, indexOffset); // non-negative\n\n  indexOffset = Math.min(listsize, indexOffset); // not larger than list\n\n  if (!['horizontal', 'vertical'].includes(orientation)) {\n    orientation = 'vertical';\n  } // convert to pixels\n  // let runwaylength = (orientation == 'vertical')?(runway * (cellHeight + gap)):(runway * (cellWidth + gap))\n  // runwaylength && (runwaylength += (padding * 2))\n\n\n  return react_1[\"default\"].createElement(viewport_1[\"default\"], {\n    orientation: orientation,\n    cellWidth: cellHeight,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    functions: functions,\n    styles: styles\n  }, react_1[\"default\"].createElement(scrollblock_1[\"default\"], {\n    listsize: listsize,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    orientation: orientation,\n    functions: functions,\n    styles: styles\n  }, react_1[\"default\"].createElement(cradle_1[\"default\"], {\n    gap: gap,\n    padding: padding,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    listsize: listsize,\n    indexOffset: indexOffset,\n    orientation: orientation,\n    // runwaylength = { runwaylength } \n    getItem: getItem,\n    functions: functions,\n    placeholder: placeholder,\n    styles: styles,\n    runwaycount: runway\n  })));\n};\n\nexports[\"default\"] = InfiniteGridScroller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUVBOzs7O0FBS0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTSxvQkFBb0IsR0FBRyxTQUF2QixvQkFBdUIsQ0FBQyxLQUFELEVBQU07OztBQUUzQjtBQUFBLE1BQWE7QUFDYixpQkFEQTtBQUFBLE1BQ0s7QUFDTCx5QkFGQTtBQUFBLE1BRVM7QUFDVCwrQkFIQTtBQUFBLE1BR1k7QUFDWiw2QkFKQTtBQUFBLE1BSVc7QUFDWCx1QkFMQTtBQUFBLE1BS1E7QUFDSjtBQUNKLDJCQVBBO0FBQUEsTUFPVTtBQUNWLGlDQVJBO0FBQUEsTUFRYTtBQUNiLHlCQVRBO0FBQUEsTUFTUztBQUNMO0FBQ0osNkJBWEE7QUFBQSxNQVdXO0FBQ1gsaUNBWkE7QUFBQSxNQVlhO0FBQ1Q7QUFDSix1QkFkQTtBQUFBLE1BY1E7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFsQkEsQ0FGMkIsQ0F1Qi9COztBQUNBLHVCQUFXLElBQVgsSUFBVyxhQUFYLEdBQVcsRUFBWCxHQUFlLFNBQVMsR0FBRyxFQUEzQjtBQUNBLGlCQUFLLElBQUwsSUFBSyxhQUFMLEdBQUssRUFBTCxHQUFTLEdBQUcsR0FBRyxDQUFmO0FBQ0EscUJBQVMsSUFBVCxJQUFTLGFBQVQsR0FBUyxFQUFULEdBQWEsT0FBTyxHQUFHLENBQXZCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLENBQXJCO0FBQ0EseUJBQWEsSUFBYixJQUFhLGFBQWIsR0FBYSxFQUFiLEdBQWlCLFdBQVcsR0FBRyxDQUEvQjtBQUNBLHNCQUFVLElBQVYsSUFBVSxhQUFWLEdBQVUsRUFBVixHQUFjLFFBQVEsR0FBRyxDQUF6QjtBQUNBLG9CQUFRLElBQVIsSUFBUSxhQUFSLEdBQVEsRUFBUixHQUFZLE1BQU0sR0FBRyxTQUFyQixDQTlCK0IsQ0ErQi9COztBQUNBLGFBQVcsR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBVyxXQUFYLENBQWQsQ0FoQytCLENBZ0NPOztBQUN0QyxhQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxRQUFULEVBQW1CLFdBQW5CLENBQWQsQ0FqQytCLENBaUNlOztBQUM5QyxNQUFJLENBQUMsQ0FBQyxZQUFELEVBQWMsVUFBZCxFQUEwQixRQUExQixDQUFtQyxXQUFuQyxDQUFMLEVBQXNEO0FBQ2xELGVBQVcsR0FBRyxVQUFkO0FBQ0gsR0FwQzhCLENBcUMvQjtBQUNBO0FBQ0E7OztBQUVBLFNBQU8saUNBQUMscUJBQUQsRUFBUztBQUVaLGVBQVcsRUFBSyxXQUZKO0FBR1osYUFBUyxFQUFLLFVBSEY7QUFJWixjQUFVLEVBQUssVUFKSDtBQUtaLE9BQUcsRUFBSyxHQUxJO0FBTVosV0FBTyxFQUFLLE9BTkE7QUFPWixhQUFTLEVBQUssU0FQRjtBQVFaLFVBQU0sRUFBSztBQVJDLEdBQVQsRUFXSCxpQ0FBQyx3QkFBRCxFQUFZO0FBRVIsWUFBUSxFQUFLLFFBRkw7QUFHUixhQUFTLEVBQUssU0FITjtBQUlSLGNBQVUsRUFBSyxVQUpQO0FBS1IsT0FBRyxFQUFLLEdBTEE7QUFNUixXQUFPLEVBQUssT0FOSjtBQU9SLGVBQVcsRUFBSyxXQVBSO0FBUVIsYUFBUyxFQUFLLFNBUk47QUFTUixVQUFNLEVBQUs7QUFUSCxHQUFaLEVBYUksaUNBQUMsbUJBQUQsRUFBTztBQUVILE9BQUcsRUFBSyxHQUZMO0FBR0gsV0FBTyxFQUFLLE9BSFQ7QUFJSCxhQUFTLEVBQUssU0FKWDtBQUtILGNBQVUsRUFBSyxVQUxaO0FBTUgsWUFBUSxFQUFLLFFBTlY7QUFPSCxlQUFXLEVBQUssV0FQYjtBQVFILGVBQVcsRUFBSyxXQVJiO0FBU0g7QUFDQSxXQUFPLEVBQUssT0FWVDtBQVdILGFBQVMsRUFBSyxTQVhYO0FBWUgsZUFBVyxFQUFLLFdBWmI7QUFhSCxVQUFNLEVBQUssTUFiUjtBQWNILGVBQVcsRUFBSztBQWRiLEdBQVAsQ0FiSixDQVhHLENBQVA7QUE2Q0gsQ0F0RkQ7O0FBd0ZBLHFCQUFlLG9CQUFmIiwiZmlsZSI6Ii4vc3JjL2luZmluaXRlZ3JpZHNjcm9sbGVyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGluZmluaXRlZ3JpZHNjcm9sbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5IEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnXG5pbXBvcnQgU2Nyb2xsYmxvY2sgZnJvbSAnLi9zY3JvbGxibG9jaydcbmltcG9ydCBDcmFkbGUgZnJvbSAnLi9jcmFkbGUnXG5cbi8qXG4gICAgQkFDS0xPRzogXG4gICAgLSBjYWNoZTogbm9uZS9wcmVsb2FkL2tlZXBsb2FkXG4qL1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaRSBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qXG4gICAgVGhlIGpvYiBvZiBJbmZpbml0ZUdyaWRTY3JvbGxlciBpcyB0byBwYXNzIHBhcmFtZXRlcnMgdG8gZGVwZW5kZW50cy5cbiAgICBWaWV3cG9ydCBjb250YWlucyB0aGUgc2Nyb2xsYmxvY2ssIHdoaWNoIGluIHR1cm4gY29udGFpbnMgdGhlIGNyYWRsZSBcbiAgICAgICAgLSBhIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIGRpc3BsYXllZCAob3IgbmVhcmx5IGRpc3BsYXllZCkgaXRlbXMuIFxuICAgIFRoZSBpdGVtcyBhcmUgc2tlbGV0b25zIHdoaWNoIGNvbnRhaW4gdGhlIGhvc3QgY29udGVudCBjb21wb25lbnRzLlxuXG4gICAgU2Nyb2xsYmxvY2sgdmlydHVhbGx5IHJlcHJlc2VudHMgdGhlIGVudGlyZXR5IG9mIHRoZSBsaXN0LCBhbmQgb2YgY291cnNlIHNjcm9sbHNcbiAgICBDcmFkbGUgY29udGFpbnMgdGhlIGxpc3QgaXRlbXMsIGFuZCBpcyAndmlydHVhbGlpemVkJyAtLSBpdCBhcHBlYXJzIGFzXG4gICAgICB0aG91Z2ggaXQgaXMgdGhlIGZ1bGwgc2Nyb2xsYmxvY2ssIGJ1dCBpbiBmYWN0IGl0IGlzIG9ubHkgc2xpZ2h0bHkgbGFyZ2VyIHRoYW5cbiAgICAgIHRoZSB2aWV3cG9ydC5cbiAgICAtIGluZGl2aWR1YWwgaXRlbXMgYXJlIGZyYW1lZCBieSBJdGVtU2hlbGwsIG1hbmFnZWQgYnkgQ3JhZGxlXG5cbiAgICBPdmVyYWxsIHRoZSBpbmZpbml0ZWdyaWRzY3JvbGxlciBtYW5hZ2VzIHRoZSBvZnRlbiBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIG9mIHRoZSBcbiAgICBjb21wb25lbnRzIG9mIHRoZSBtZWNoYW5pc21cbiovXG5jb25zdCBJbmZpbml0ZUdyaWRTY3JvbGxlciA9IChwcm9wcykgPT4ge1xuICAgIGxldCB7IFxuICAgICAgICBvcmllbnRhdGlvbiwgLy8gdmVydGljYWwgb3IgaG9yaXpvbnRhbFxuICAgICAgICBnYXAsIC8vIHNwYWNlIGJldHdlZW4gZ3JpZCBjZWxscywgbm90IGluY2x1ZGluZyB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgZWRnZXNcbiAgICAgICAgcGFkZGluZywgLy8gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBjZWxsSGVpZ2h0LCAvLyB0aGUgb3V0ZXIgcGl4ZWwgaGVpZ2h0IC0gbGl0ZXJhbCBmb3IgdmVydGljYWw7IGFwcHJveGltYXRlIGZvciBob3Jpem9udGFsXG4gICAgICAgIGNlbGxXaWR0aCwgLy8gdGhlIG91dGVyIHBpeGVsIHdpZHRoIC0gbGl0ZXJhbCBmb3IgaG9yaXpvbnRhbDsgYXBwcm94aW1hdGUgZm9yIHZlcnRpY2FsXG4gICAgICAgIHJ1bndheSwgLy8gdGhlIG51bWJlciBvZiBpdGVtcyBvdXRzaWRlIHRoZSB2aWV3IG9mIGVhY2ggc2lkZSBvZiB0aGUgdmlld3BvcnQgXG4gICAgICAgICAgICAvLyAtLSBnaXZlcyB0aW1lIHRvIGFzc2VtYmxlIGJlZm9yZSBkaXNwbGF5XG4gICAgICAgIGxpc3RzaXplLCAvLyB0aGUgZXhhY3QgbnVtYmVyIG9mIHRoZSBzaXplIG9mIHRoZSB2aXJ0dWFsIGxpc3RcbiAgICAgICAgaW5kZXhPZmZzZXQsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuICAgICAgICBnZXRJdGVtLCAvLyBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0IC0gcGFyYW1ldGVyIGlzIGluZGV4IG51bWJlciwgc2V0IGJ5IHN5c3RlbTsgcmV0dXJuIHZhbHVlIGlzIFxuICAgICAgICAgICAgLy8gaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICBmdW5jdGlvbnMsIC8vIHByb3BlcnRpZXMgd2l0aCBkaXJlY3QgYWNjZXNzIHRvIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzLCBvcHRpb25hbFxuICAgICAgICBwbGFjZWhvbGRlciwgLy8gYSBzcGFyc2UgY29tcG9uZW50IHRvIHN0YW5kIGluIGZvciBjb250ZW50IHVudGlsIHRoZSBjb250ZW50IGFycml2ZXM7IFxuICAgICAgICAgICAgLy8gb3B0aW9uYWwsIHJlcGxhY2VzIGRlZmF1bHRcbiAgICAgICAgc3R5bGVzLCAvLyBwYXNzaXZlIHN0eWxlIG92ZXItcmlkZXMgKGVnLiBjb2xvciwgb3BhY2l0eSkgZm9yIHZpZXdwb3J0LCBzY3JvbGxibG9jaywgY3JhZGxlLCBvciBzY3JvbGx0cmFja2VyXG4gICAgICAgIC8vIHRvIGNvbWUuLi5cbiAgICAgICAgLy8gY2FjaGUgPSBcInByZWxvYWRcIiwgXCJrZWVwbG9hZFwiLCBcIm5vbmVcIlxuICAgICAgICAvLyBkZW5zZSwgLy8gYm9vbGVhbiAob25seSB3aXRoIHByZWxvYWQpXG4gICAgICAgIGxheW91dCwgLy8gdW5pZm9ybSwgdmFyaWFibGVcbiAgICB9ID0gcHJvcHNcblxuICAgIC8vIGRlZmF1bHRzXG4gICAgZnVuY3Rpb25zICE/PyAoZnVuY3Rpb25zID0ge30pXG4gICAgZ2FwICE/PyAoZ2FwID0gMClcbiAgICBwYWRkaW5nICE/PyAocGFkZGluZyA9IDApXG4gICAgcnVud2F5ICE/PyAocnVud2F5ID0gMylcbiAgICBpbmRleE9mZnNldCAhPz8gKGluZGV4T2Zmc2V0ID0gMClcbiAgICBsaXN0c2l6ZSAhPz8gKGxpc3RzaXplID0gMClcbiAgICBsYXlvdXQgIT8/IChsYXlvdXQgPSAndW5pZm9ybScpXG4gICAgLy8gY29uc3RyYWludHNcbiAgICBpbmRleE9mZnNldCA9IE1hdGgubWF4KDAsaW5kZXhPZmZzZXQpIC8vIG5vbi1uZWdhdGl2ZVxuICAgIGluZGV4T2Zmc2V0ID0gTWF0aC5taW4obGlzdHNpemUsIGluZGV4T2Zmc2V0KSAvLyBub3QgbGFyZ2VyIHRoYW4gbGlzdFxuICAgIGlmICghWydob3Jpem9udGFsJywndmVydGljYWwnXS5pbmNsdWRlcyhvcmllbnRhdGlvbikpIHtcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIC8vIGNvbnZlcnQgdG8gcGl4ZWxzXG4gICAgLy8gbGV0IHJ1bndheWxlbmd0aCA9IChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT8ocnVud2F5ICogKGNlbGxIZWlnaHQgKyBnYXApKToocnVud2F5ICogKGNlbGxXaWR0aCArIGdhcCkpXG4gICAgLy8gcnVud2F5bGVuZ3RoICYmIChydW53YXlsZW5ndGggKz0gKHBhZGRpbmcgKiAyKSlcblxuICAgIHJldHVybiA8Vmlld3BvcnQgXG5cbiAgICAgICAgb3JpZW50YXRpb24gPSB7IG9yaWVudGF0aW9uIH0gXG4gICAgICAgIGNlbGxXaWR0aCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBnYXAgPSB7IGdhcCB9XG4gICAgICAgIHBhZGRpbmcgPSB7IHBhZGRpbmcgfVxuICAgICAgICBmdW5jdGlvbnMgPSB7IGZ1bmN0aW9ucyB9XG4gICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzIH1cbiAgICA+XG4gICAgXG4gICAgICAgIDxTY3JvbGxibG9ja1xuXG4gICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsV2lkdGggfVxuICAgICAgICAgICAgY2VsbEhlaWdodCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgICAgICBnYXAgPSB7IGdhcH1cbiAgICAgICAgICAgIHBhZGRpbmcgPSB7IHBhZGRpbmcgfVxuICAgICAgICAgICAgb3JpZW50YXRpb24gPSB7IG9yaWVudGF0aW9uIH1cbiAgICAgICAgICAgIGZ1bmN0aW9ucyA9IHsgZnVuY3Rpb25zIH1cbiAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzIH1cblxuICAgICAgICA+XG5cbiAgICAgICAgICAgIDxDcmFkbGUgXG5cbiAgICAgICAgICAgICAgICBnYXAgPSB7IGdhcCB9XG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHsgcGFkZGluZyB9XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsV2lkdGggfVxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgaW5kZXhPZmZzZXQgPSB7IGluZGV4T2Zmc2V0IH1cbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfVxuICAgICAgICAgICAgICAgIC8vIHJ1bndheWxlbmd0aCA9IHsgcnVud2F5bGVuZ3RoIH0gXG4gICAgICAgICAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zID0geyBmdW5jdGlvbnMgfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXMgfVxuICAgICAgICAgICAgICAgIHJ1bndheWNvdW50ID0geyBydW53YXkgfVxuXG4gICAgICAgICAgICAvPlxuXG4gICAgICAgIDwvU2Nyb2xsYmxvY2s+XG4gICAgPC9WaWV3cG9ydD5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbmZpbml0ZUdyaWRTY3JvbGxlclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n");

/***/ }),

/***/ "./src/itemshell.tsx":
/*!***************************!*\
  !*** ./src/itemshell.tsx ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // itemframe.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ \"./node_modules/requestidlecallback/index.js\");\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar placeholder_1 = __importDefault(__webpack_require__(/*! ./placeholder */ \"./src/placeholder.tsx\"));\n\nvar ItemShell = function ItemShell(props) {\n  var orientation = props.orientation,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      index = props.index,\n      observer = props.observer,\n      callbacks = props.callbacks,\n      getItem = props.getItem,\n      listsize = props.listsize,\n      placeholder = props.placeholder;\n\n  var _a = react_1.useState(null),\n      content = _a[0],\n      saveContent = _a[1];\n\n  var _b = react_1.useState(null),\n      error = _b[0],\n      saveError = _b[1];\n\n  var _c = react_1.useState({\n    overflow: 'hidden'\n  }),\n      styles = _c[0],\n      saveStyles = _c[1];\n\n  var shellRef = react_1.useRef(null);\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // initialize\n\n  react_1.useEffect(function () {\n    var itemrequest = {\n      current: null\n    };\n    var requestidlecallback = window['requestIdleCallback'] ? window['requestIdleCallback'] : requestidlecallback_1.requestIdleCallback;\n    var cancelidlecallback = window['cancelIdleCallback'] ? window['cancelIdleCallback'] : requestidlecallback_1.cancelIdleCallback;\n\n    if (getItem) {\n      itemrequest.current = requestidlecallback(function () {\n        var value = getItem(index);\n\n        if (value && value.then) {\n          value.then(function (value) {\n            if (isMounted()) {\n              saveContent(value);\n              saveError(null);\n            }\n          })[\"catch\"](function (e) {\n            if (isMounted()) {\n              saveContent(null);\n              saveError(e);\n            }\n          });\n        } else {\n          if (isMounted()) {\n            if (value) {\n              saveContent(value);\n              saveError(null);\n            } else {\n              saveError(true);\n              saveContent(null);\n            }\n          }\n        }\n      }, {\n        timeout: 200\n      });\n    }\n\n    return function () {\n      var requesthandle = itemrequest.current;\n      cancelidlecallback(requesthandle);\n    };\n  }, []); // initialize\n\n  react_1.useEffect(function () {\n    var localcalls = callbacks;\n    localcalls.getElementData && localcalls.getElementData(getElementData(), 'register');\n    return function () {\n      localcalls.getElementData && localcalls.getElementData(getElementData(), 'unregister');\n    };\n  }, [callbacks]);\n  react_1.useEffect(function () {\n    observer.observe(shellRef.current);\n    return function () {\n      observer.unobserve(shellRef.current);\n    };\n  }, [observer]);\n  react_1.useEffect(function () {\n    var newStyles = getShellStyles(orientation, cellHeight, cellWidth, styles);\n\n    if (isMounted()) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth]); // cradle ondemand callback parameter value\n\n  var getElementData = react_1.useCallback(function () {\n    return [index, shellRef];\n  }, []); // placeholder handling\n\n  var customholderRef = react_1.useRef(placeholder ? react_1[\"default\"].createElement(placeholder, {\n    index: index,\n    listsize: listsize\n  }) : null);\n  return react_1[\"default\"].createElement(\"div\", {\n    ref: shellRef,\n    \"data-index\": index,\n    style: styles\n  }, styles.width ? content ? content : customholderRef.current ? customholderRef.current : react_1[\"default\"].createElement(placeholder_1[\"default\"], {\n    index: index,\n    listsize: listsize,\n    error: error\n  }) : null);\n}; // ItemShell\n// TODO: memoize this\n\n\nvar getShellStyles = function getShellStyles(orientation, cellHeight, cellWidth, styles) {\n  var styleset = Object.assign({\n    position: 'relative'\n  }, styles);\n\n  if (orientation == 'horizontal') {\n    styleset.width = cellWidth ? cellWidth + 'px' : 'auto';\n    styleset.height = 'auto';\n  } else if (orientation === 'vertical') {\n    styleset.width = 'auto';\n    styleset.height = cellHeight ? cellHeight + 'px' : 'auto';\n  }\n\n  return styleset;\n};\n\nexports[\"default\"] = ItemShell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pdGVtc2hlbGwudHN4P2ZhYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQU0sU0FBUyxHQUFHLFNBQVosU0FBWSxDQUFDLEtBQUQsRUFBTTtBQUNiO0FBQUEsTUFBYSw2QkFBYjtBQUFBLE1BQXlCLDJCQUF6QjtBQUFBLE1BQW9DLG1CQUFwQztBQUFBLE1BQTJDLHlCQUEzQztBQUFBLE1BQXFELDJCQUFyRDtBQUFBLE1BQWdFLHVCQUFoRTtBQUFBLE1BQXlFLHlCQUF6RTtBQUFBLE1BQW1GLCtCQUFuRjs7QUFFRDtBQUFBLE1BQUMsZUFBRDtBQUFBLE1BQVUsbUJBQVY7O0FBQ0E7QUFBQSxNQUFDLGFBQUQ7QUFBQSxNQUFRLGlCQUFSOztBQUNBOztBQUFBO0FBQUEsTUFBQyxjQUFEO0FBQUEsTUFBUSxrQkFBUjs7QUFHTixNQUFNLFFBQVEsR0FBRyxlQUFPLElBQVAsQ0FBakI7QUFFQSxNQUFNLFNBQVMsR0FBRyxvQ0FBbEIsQ0FWb0IsQ0FZcEI7O0FBQ0Esb0JBQVU7QUFDTixRQUFJLFdBQVcsR0FBRztBQUFDLGFBQU8sRUFBQztBQUFULEtBQWxCO0FBQ0EsUUFBSSxtQkFBbUIsR0FBRyxNQUFNLENBQUMscUJBQUQsQ0FBTixHQUE4QixNQUFNLENBQUMscUJBQUQsQ0FBcEMsR0FBNEQseUNBQXRGO0FBQ0EsUUFBSSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsb0JBQUQsQ0FBTixHQUE2QixNQUFNLENBQUMsb0JBQUQsQ0FBbkMsR0FBMEQsd0NBQW5GOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1QsaUJBQVcsQ0FBQyxPQUFaLEdBQXNCLG1CQUFtQixDQUFDO0FBRXRDLFlBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFELENBQW5COztBQUNBLFlBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxJQUFuQixF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QUEwQixTQUExQixFQUFxQyxNQUFyQyxFQUEyQztBQUU5RCxNQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjO0FBQUMsWUFBUSxFQUFDO0FBQVYsR0FBZCxFQUFvQyxNQUFwQyxDQUFmOztBQUNBLE1BQUksV0FBVyxJQUFJLFlBQW5CLEVBQWlDO0FBQzdCLFlBQVEsQ0FBQyxLQUFULEdBQWlCLFNBQVMsR0FBRSxTQUFTLEdBQUcsSUFBZCxHQUFvQixNQUE5QztBQUNBLFlBQVEsQ0FBQyxNQUFULEdBQWtCLE1BQWxCO0FBQ0gsR0FIRCxNQUdPLElBQUksV0FBVyxLQUFLLFVBQXBCLEVBQWdDO0FBQ25DLFlBQVEsQ0FBQyxLQUFULEdBQWlCLE1BQWpCO0FBQ0EsWUFBUSxDQUFDLE1BQVQsR0FBa0IsVUFBVSxHQUFFLFVBQVUsR0FBRyxJQUFmLEdBQXFCLE1BQWpEO0FBQ0g7O0FBRUQsU0FBTyxRQUFQO0FBRUgsQ0FiRDs7QUFlQSxxQkFBZSxTQUFmIiwiZmlsZSI6Ii4vc3JjL2l0ZW1zaGVsbC50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpdGVtZnJhbWUudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQge3JlcXVlc3RJZGxlQ2FsbGJhY2ssIGNhbmNlbElkbGVDYWxsYmFja30gZnJvbSAncmVxdWVzdGlkbGVjYWxsYmFjaydcblxuaW1wb3J0IHVzZUlzTW91bnRlZCBmcm9tICdyZWFjdC1pcy1tb3VudGVkLWhvb2snXG5cbmltcG9ydCBQbGFjZWhvbGRlciBmcm9tICcuL3BsYWNlaG9sZGVyJ1xuXG5jb25zdCBJdGVtU2hlbGwgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7b3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgaW5kZXgsIG9ic2VydmVyLCBjYWxsYmFja3MsIGdldEl0ZW0sIGxpc3RzaXplLCBwbGFjZWhvbGRlcn0gPSBwcm9wc1xuICAgIFxuICAgIGNvbnN0IFtjb250ZW50LCBzYXZlQ29udGVudF0gPSB1c2VTdGF0ZShudWxsKVxuICAgIGNvbnN0IFtlcnJvciwgc2F2ZUVycm9yXSA9IHVzZVN0YXRlKG51bGwpXG4gICAgY29uc3QgW3N0eWxlcyxzYXZlU3R5bGVzXSA9IHVzZVN0YXRlKHtcbiAgICAgICAgb3ZlcmZsb3c6J2hpZGRlbicsXG4gICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzKVxuICAgIGNvbnN0IHNoZWxsUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKVxuXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBpdGVtcmVxdWVzdCA9IHtjdXJyZW50Om51bGx9XG4gICAgICAgIGxldCByZXF1ZXN0aWRsZWNhbGxiYWNrID0gd2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ10/d2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ106cmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAgICBsZXQgY2FuY2VsaWRsZWNhbGxiYWNrID0gd2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXT93aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddOmNhbmNlbElkbGVDYWxsYmFja1xuICAgICAgICBpZiAoZ2V0SXRlbSkge1xuICAgICAgICAgICAgaXRlbXJlcXVlc3QuY3VycmVudCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soKCk9PiB7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRJdGVtKGluZGV4KVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNvbnRlbnQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUVycm9yKG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNvbnRlbnQobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDb250ZW50KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVFcnJvcihudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29udGVudChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSx7dGltZW91dDoyMDB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0aGFuZGxlID0gaXRlbXJlcXVlc3QuY3VycmVudFxuICAgICAgICAgICAgY2FuY2VsaWRsZWNhbGxiYWNrKHJlcXVlc3RoYW5kbGUpXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgbGV0IGxvY2FsY2FsbHMgPSBjYWxsYmFja3NcblxuICAgICAgICBsb2NhbGNhbGxzLmdldEVsZW1lbnREYXRhICYmIGxvY2FsY2FsbHMuZ2V0RWxlbWVudERhdGEoZ2V0RWxlbWVudERhdGEoKSwncmVnaXN0ZXInKVxuXG4gICAgICAgIHJldHVybiAoKCk9PntcblxuICAgICAgICAgICAgbG9jYWxjYWxscy5nZXRFbGVtZW50RGF0YSAmJiBsb2NhbGNhbGxzLmdldEVsZW1lbnREYXRhKGdldEVsZW1lbnREYXRhKCksJ3VucmVnaXN0ZXInKVxuXG4gICAgICAgIH0pXG5cbiAgICB9LFtjYWxsYmFja3NdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShzaGVsbFJlZi5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShzaGVsbFJlZi5jdXJyZW50KVxuXG4gICAgICAgIH1cblxuICAgIH0sW29ic2VydmVyXSlcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGxldCBuZXdTdHlsZXMgPSBnZXRTaGVsbFN0eWxlcyhvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBzdHlsZXMpXG4gICAgICAgIGlmIChpc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgc2F2ZVN0eWxlcyhuZXdTdHlsZXMpXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uLGNlbGxIZWlnaHQsY2VsbFdpZHRoXSlcblxuICAgIC8vIGNyYWRsZSBvbmRlbWFuZCBjYWxsYmFjayBwYXJhbWV0ZXIgdmFsdWVcbiAgICBjb25zdCBnZXRFbGVtZW50RGF0YSA9IHVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIHJldHVybiBbaW5kZXgsIHNoZWxsUmVmXVxuICAgIH0sW10pXG5cbiAgICAvLyBwbGFjZWhvbGRlciBoYW5kbGluZ1xuICAgIGNvbnN0IGN1c3RvbWhvbGRlclJlZiA9IHVzZVJlZihwbGFjZWhvbGRlcj9SZWFjdC5jcmVhdGVFbGVtZW50KHBsYWNlaG9sZGVyLCB7aW5kZXgsIGxpc3RzaXplfSk6bnVsbClcblxuICAgIHJldHVybiA8ZGl2IHJlZiA9IHsgc2hlbGxSZWYgfSBkYXRhLWluZGV4ID0ge2luZGV4fSBzdHlsZSA9IHtzdHlsZXN9PlxuICAgICAgICB7c3R5bGVzLndpZHRoP1xuICAgICAgICAgICAgY29udGVudD9cbiAgICAgICAgICAgICAgICBjb250ZW50OmN1c3RvbWhvbGRlclJlZi5jdXJyZW50P1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21ob2xkZXJSZWYuY3VycmVudDo8UGxhY2Vob2xkZXIgaW5kZXggPSB7aW5kZXh9IGxpc3RzaXplID0ge2xpc3RzaXplfSBlcnJvciA9IHtlcnJvcn0vPlxuICAgICAgICA6bnVsbH1cbiAgICA8L2Rpdj5cblxufSAvLyBJdGVtU2hlbGxcblxuLy8gVE9ETzogbWVtb2l6ZSB0aGlzXG5jb25zdCBnZXRTaGVsbFN0eWxlcyA9IChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBzdHlsZXMpID0+IHtcblxuICAgIGxldCBzdHlsZXNldCA9IE9iamVjdC5hc3NpZ24oe3Bvc2l0aW9uOidyZWxhdGl2ZSd9LHN0eWxlcylcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHN0eWxlc2V0LndpZHRoID0gY2VsbFdpZHRoPyhjZWxsV2lkdGggKyAncHgnKTonYXV0bydcbiAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzdHlsZXNldC53aWR0aCA9ICdhdXRvJ1xuICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSBjZWxsSGVpZ2h0PyhjZWxsSGVpZ2h0ICsgJ3B4Jyk6J2F1dG8nXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2V0XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSXRlbVNoZWxsXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/itemshell.tsx\n");

/***/ }),

/***/ "./src/placeholder.tsx":
/*!*****************************!*\
  !*** ./src/placeholder.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // placeholder.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Placeholder = function Placeholder(_a) {\n  var index = _a.index,\n      listsize = _a.listsize,\n      error = _a.error;\n  var stylesRef = react_1.useRef({\n    position: 'relative',\n    boxSizing: 'border-box',\n    backgroundColor: 'cyan',\n    border: '2px solid black',\n    height: '100%',\n    width: '100%'\n  });\n  var itemStylesRef = react_1.useRef({\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    padding: '3px',\n    opacity: .5,\n    borderRadius: '8px',\n    backgroundColor: 'white',\n    margin: '3px',\n    fontSize: 'smaller'\n  });\n  return react_1[\"default\"].createElement(\"div\", {\n    style: stylesRef.current\n  }, !error ? react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, index + 1, \"/\", listsize) : react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, \"item is not available at this time\"));\n};\n\nexports[\"default\"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9wbGFjZWhvbGRlci50c3g/MTEzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQUF5QjtNQUF2QixnQjtNQUFPLHNCO01BQVUsZ0I7QUFFbkMsTUFBTSxTQUFTLEdBQUcsZUFBTztBQUNyQixZQUFRLEVBQUMsVUFEWTtBQUVyQixhQUFTLEVBQUMsWUFGVztBQUdyQixtQkFBZSxFQUFDLE1BSEs7QUFJckIsVUFBTSxFQUFDLGlCQUpjO0FBS3JCLFVBQU0sRUFBQyxNQUxjO0FBTXJCLFNBQUssRUFBQztBQU5lLEdBQVAsQ0FBbEI7QUFRQSxNQUFNLGFBQWEsR0FBRyxlQUNsQjtBQUNJLFlBQVEsRUFBQyxVQURiO0FBRUksT0FBRyxFQUFDLENBRlI7QUFHSSxRQUFJLEVBQUMsQ0FIVDtBQUlJLFdBQU8sRUFBQyxLQUpaO0FBS0ksV0FBTyxFQUFDLEVBTFo7QUFNSSxnQkFBWSxFQUFDLEtBTmpCO0FBT0ksbUJBQWUsRUFBQyxPQVBwQjtBQVFJLFVBQU0sRUFBQyxLQVJYO0FBU0ksWUFBUSxFQUFDO0FBVGIsR0FEa0IsQ0FBdEI7QUFjQSxTQUFPO0FBQUssU0FBSyxFQUFJLFNBQVMsQ0FBQztBQUF4QixLQUNELENBQUMsS0FBRCxHQUNFO0FBQUssU0FBSyxFQUFJLGFBQWEsQ0FBQztBQUE1QixLQUFzQyxLQUFLLEdBQUcsQ0FBOUMsRSxHQUFBLEVBQWtELFFBQWxELENBREYsR0FFRTtBQUFLLFNBQUssRUFBSSxhQUFhLENBQUM7QUFBNUIsS0FBbUMsb0NBQW5DLENBSEQsQ0FBUDtBQU9ILENBL0JEOztBQWlDQSxxQkFBZSxXQUFmIiwiZmlsZSI6Ii4vc3JjL3BsYWNlaG9sZGVyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgUGxhY2Vob2xkZXIgPSAoe2luZGV4LCBsaXN0c2l6ZSwgZXJyb3J9KSA9PiB7XG5cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J2N5YW4nLFxuICAgICAgICBib3JkZXI6JzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgIHdpZHRoOicxMDAlJ1xuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcylcbiAgICBjb25zdCBpdGVtU3R5bGVzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOjAsXG4gICAgICAgICAgICBsZWZ0OjAsXG4gICAgICAgICAgICBwYWRkaW5nOiczcHgnLFxuICAgICAgICAgICAgb3BhY2l0eTouNSxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czonOHB4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLCBcbiAgICAgICAgICAgIG1hcmdpbjonM3B4JyxcbiAgICAgICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgKVxuXG4gICAgcmV0dXJuIDxkaXYgc3R5bGUgPSB7c3R5bGVzUmVmLmN1cnJlbnR9PlxuICAgICAgICB7ICFlcnJvcj9cbiAgICAgICAgICAgIDxkaXYgc3R5bGUgPSB7aXRlbVN0eWxlc1JlZi5jdXJyZW50fT57aW5kZXggKyAxfS97bGlzdHNpemV9PC9kaXY+OlxuICAgICAgICAgICAgPGRpdiBzdHlsZSA9IHtpdGVtU3R5bGVzUmVmLmN1cnJlbnR9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWU8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICA8L2Rpdj5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxhY2Vob2xkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/placeholder.tsx\n");

/***/ }),

/***/ "./src/scrollblock.tsx":
/*!*****************************!*\
  !*** ./src/scrollblock.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // scrollblock.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\");\n\nvar Scrollblock = function Scrollblock(_a) {\n  var children = _a.children,\n      listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      functions = _a.functions,\n      styles = _a.styles; // -------------------------[ context and state ]-------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n\n  var _b = react_1.useState('prepare'),\n      blockstate = _b[0],\n      setBlockState = _b[1]; // -----------------------------------[ data heap ]-------------------------\n\n\n  var scrollBlockLengthRef = react_1.useRef(null);\n  var scrollblockRef = react_1.useRef(null);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    backgroundColor: 'white',\n    position: 'relative'\n  }, styles === null || styles === void 0 ? void 0 : styles.cradle));\n\n  var _c = react_1.useState(divlinerstyleRef.current),\n      divlinerstyle = _c[0],\n      saveDivlinerstyle = _c[1]; // to trigger render\n\n\n  var viewportDimensions = viewportData.viewportDimensions,\n      itemobserver = viewportData.itemobserver,\n      isResizing = viewportData.isResizing;\n  var top = viewportDimensions.top,\n      right = viewportDimensions.right,\n      bottom = viewportDimensions.bottom,\n      left = viewportDimensions.left,\n      width = viewportDimensions.width,\n      height = viewportDimensions.height; // state engine\n\n  react_1.useEffect(function () {\n    switch (blockstate) {\n      case 'prepare':\n        {\n          setBlockState('render');\n          break;\n        }\n    }\n  }, [blockstate]);\n  react_1.useLayoutEffect(function () {\n    updateBlockLength();\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, scrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBlockLength = react_1.useCallback(function () {\n    var scrollblocklength = calcScrollblockLength({\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width\n    });\n    scrollBlockLengthRef.current = scrollblocklength;\n  }, [listsize, cellHeight, cellWidth, gap, padding, orientation, height, width]);\n  return blockstate != 'prepare' ? react_1[\"default\"].createElement(\"div\", {\n    ref: scrollblockRef,\n    style: divlinerstyleRef.current\n  }, children) : null;\n}; // Scrollblock\n// all the parameters affect the length\n\n\nvar calcScrollblockLength = function calcScrollblockLength(_a) {\n  var listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth; // dependents of orientation\n\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == 'vertical') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap;\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  var listlength = Math.ceil(listsize / crosscount);\n  var straightlength = listlength * cellLength - (listlength > 0 ? gap : 0) + padding * 2;\n  return straightlength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, scrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current);\n  var height;\n  var width;\n\n  if (orientation == 'horizontal') {\n    height = '100%';\n    width = scrollblocklengthRef.current + 'px';\n  } else if (orientation == 'vertical') {\n    height = scrollblocklengthRef.current + 'px';\n    width = '100%';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};\n\nexports[\"default\"] = Scrollblock;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGxibG9jay50c3g/MmZhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQVVuQjtNQVRHLHNCO01BQ0Esc0I7TUFDQSwwQjtNQUNBLHdCO01BQ0EsWTtNQUNBLG9CO01BQ0EsNEI7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FFRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxtQkFBVywwQkFBWCxDQUFyQjs7QUFDTTtBQUFBLE1BQUMsa0JBQUQ7QUFBQSxNQUFZLHFCQUFaLENBSlQsQ0FNRzs7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxlQUFPLElBQVAsQ0FBN0I7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLElBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQ0E7QUFFSSxtQkFBZSxFQUFDLE9BRnBCO0FBR0ksWUFBUSxFQUFDO0FBSGIsR0FEQSxFQU0wQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsTUFObEMsQ0FEcUIsQ0FBekI7O0FBVU07QUFBQSxNQUFDLHFCQUFEO0FBQUEsTUFBZSx5QkFBZixDQW5CVCxDQW1CZ0Y7OztBQUV2RTtBQUFBLE1BQW9CLHdDQUFwQjtBQUFBLE1BQWtDLG9DQUFsQztBQUNBO0FBQUEsTUFBSyxnQ0FBTDtBQUFBLE1BQVksa0NBQVo7QUFBQSxNQUFvQiw4QkFBcEI7QUFBQSxNQUEwQixnQ0FBMUI7QUFBQSxNQUFpQyxrQ0FBakMsQ0F0QlQsQ0F3Qkc7O0FBQ0Esb0JBQVU7QUFDTixZQUFRLFVBQVI7QUFDSSxXQUFLLFNBQUw7QUFBZ0I7QUFDWix1QkFBYSxDQUFDLFFBQUQsQ0FBYjtBQUNBO0FBQ0g7QUFKTDtBQU1ILEdBUEQsRUFPRSxDQUFDLFVBQUQsQ0FQRjtBQVNBLDBCQUFnQjtBQUVaLHFCQUFpQjtBQUNqQixvQkFBZ0IsQ0FBQyxPQUFqQixHQUEyQix1QkFBdUIsQ0FBQyxXQUFELEVBQWEsZ0JBQWIsRUFBOEIsb0JBQTlCLENBQWxEO0FBQ0EscUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsT0FBbEIsQ0FBakI7QUFFSCxHQU5ELEVBTUUsQ0FDRSxXQURGLEVBRUUsTUFGRixFQUdFLEtBSEYsRUFJRSxRQUpGLEVBS0UsVUFMRixFQU1FLFNBTkYsRUFPRSxHQVBGLEVBUUUsT0FSRixDQU5GO0FBaUJBLE1BQU0saUJBQWlCLEdBQUcsb0JBQ3RCO0FBQ0ksUUFBSSxpQkFBaUIsR0FDakIscUJBQXFCLENBQ2pCO0FBQ0ksY0FBUSxVQURaO0FBRUksZ0JBQVUsWUFGZDtBQUdJLGVBQVMsV0FIYjtBQUlJLFNBQUcsS0FKUDtBQUtJLGFBQU8sU0FMWDtBQU1JLGlCQUFXLGFBTmY7QUFPSSxvQkFBYyxFQUFDLE1BUG5CO0FBUUksbUJBQWEsRUFBQztBQVJsQixLQURpQixDQUR6QjtBQWNBLHdCQUFvQixDQUFDLE9BQXJCLEdBQStCLGlCQUEvQjtBQUVILEdBbEJxQixFQWtCcEIsQ0FDRSxRQURGLEVBRUUsVUFGRixFQUdFLFNBSEYsRUFJRSxHQUpGLEVBS0UsT0FMRixFQU1FLFdBTkYsRUFPRSxNQVBGLEVBUUUsS0FSRixDQWxCb0IsQ0FBMUI7QUE4QkEsU0FBUSxVQUFVLElBQUksU0FBZixHQUNGO0FBQUssT0FBRyxFQUFJLGNBQVo7QUFBNEIsU0FBSyxFQUFFLGdCQUFnQixDQUFDO0FBQXBELEtBQThELFFBQTlELENBREUsR0FFRixJQUZMO0FBSUgsQ0EvRkQsQyxDQStGRTtBQUVGOzs7QUFDQSxJQUFNLHFCQUFxQixHQUFHLFNBQXhCLHFCQUF3QixDQUFDLEVBQUQsRUFTekI7TUFSRCxzQjtNQUNBLDBCO01BQ0Esd0I7TUFDQSxZO01BQ0Esb0I7TUFDQSw0QjtNQUNBLGtDO01BQ0EsZ0MsQ0FDQyxDQUVEOztBQUNBLE1BQUksV0FBSjtBQUNBLE1BQUksVUFBSjtBQUNBLE1BQUksbUJBQUo7O0FBQ0EsTUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFFM0IsZUFBVyxHQUFHLFNBQVMsR0FBRyxHQUExQjtBQUNBLGNBQVUsR0FBRyxVQUFVLEdBQUcsR0FBMUI7QUFDQSx1QkFBbUIsR0FBRyxhQUF0QjtBQUVILEdBTkQsTUFNTztBQUVILGVBQVcsR0FBRyxVQUFVLEdBQUcsR0FBM0I7QUFDQSxjQUFVLEdBQUcsU0FBUyxHQUFHLEdBQXpCO0FBQ0EsdUJBQW1CLEdBQUcsY0FBdEI7QUFFSCxHQWxCQSxDQW1CRDs7O0FBQ0EscUJBQW1CLElBQUssT0FBTyxHQUFHLENBQWxDO0FBQ0EscUJBQW1CLElBQUksR0FBdkI7QUFFQSxNQUFJLG1CQUFtQixHQUFHLFdBQTFCLEVBQXVDLG1CQUFtQixHQUFHLFdBQXRCLENBdkJ0QyxDQXVCd0U7O0FBQ3pFLE1BQUksVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsbUJBQW1CLEdBQUMsV0FBL0IsQ0FBakI7QUFFQSxNQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBTCxDQUFVLFFBQVEsR0FBQyxVQUFuQixDQUFqQjtBQUVBLE1BQUksY0FBYyxHQUFJLFVBQVUsR0FBRyxVQUFkLElBQThCLFVBQVUsR0FBRyxDQUFkLEdBQWlCLEdBQWpCLEdBQXFCLENBQWxELElBQXdELE9BQU8sR0FBRyxDQUF2RjtBQUVBLFNBQU8sY0FBUDtBQUVILENBekNEOztBQTJDQSxJQUFNLHVCQUF1QixHQUFHLFNBQTFCLHVCQUEwQixDQUFDLFdBQUQsRUFBYSxTQUFiLEVBQXVCLG9CQUF2QixFQUEyQztBQUV2RSxNQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjLEVBQWQsRUFBaUIsU0FBUyxDQUFDLE9BQTNCLENBQWxCO0FBQ0EsTUFBSSxNQUFKO0FBQ0EsTUFBSSxLQUFKOztBQUNBLE1BQUksV0FBVyxJQUFJLFlBQW5CLEVBQWlDO0FBQzdCLFVBQU0sR0FBRyxNQUFUO0FBQ0EsU0FBSyxHQUFHLG9CQUFvQixDQUFDLE9BQXJCLEdBQStCLElBQXZDO0FBQ0gsR0FIRCxNQUdPLElBQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBQ2xDLFVBQU0sR0FBRyxvQkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUF4QztBQUNBLFNBQUssR0FBRyxNQUFSO0FBQ0g7O0FBQ0QsYUFBVyxDQUFDLE1BQVosR0FBcUIsTUFBckI7QUFDQSxhQUFXLENBQUMsS0FBWixHQUFvQixLQUFwQjtBQUVBLFNBQU8sV0FBUDtBQUNILENBaEJEOztBQWtCQSxxQkFBZSxXQUFmIiwiZmlsZSI6Ii4vc3JjL3Njcm9sbGJsb2NrLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGJsb2NrLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vdmlld3BvcnQnXG5cbmNvbnN0IFNjcm9sbGJsb2NrID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICBsaXN0c2l6ZSwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBnYXAsIFxuICAgIHBhZGRpbmcsIFxuICAgIG9yaWVudGF0aW9uLCBcbiAgICBmdW5jdGlvbnMsIFxuICAgIHN0eWxlcyBcbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3Qgdmlld3BvcnREYXRhID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG4gICAgY29uc3QgW2Jsb2Nrc3RhdGUsc2V0QmxvY2tTdGF0ZV0gPSB1c2VTdGF0ZSgncHJlcGFyZScpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZGF0YSBoZWFwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3Qgc2Nyb2xsQmxvY2tMZW5ndGhSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBzY3JvbGxibG9ja1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICAgICAgXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcywgc3R5bGVzPy5jcmFkbGUpXG5cbiAgICApXG4gICAgY29uc3QgW2RpdmxpbmVyc3R5bGUsc2F2ZURpdmxpbmVyc3R5bGVdID0gdXNlU3RhdGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KSAvLyB0byB0cmlnZ2VyIHJlbmRlclxuXG4gICAgbGV0IHsgdmlld3BvcnREaW1lbnNpb25zLCBpdGVtb2JzZXJ2ZXIsIGlzUmVzaXppbmcgfSA9IHZpZXdwb3J0RGF0YVxuICAgIGxldCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gdmlld3BvcnREaW1lbnNpb25zXG5cbiAgICAvLyBzdGF0ZSBlbmdpbmVcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgc3dpdGNoIChibG9ja3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlJzoge1xuICAgICAgICAgICAgICAgIHNldEJsb2NrU3RhdGUoJ3JlbmRlcicpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sW2Jsb2Nrc3RhdGVdKVxuICAgIFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgdXBkYXRlQmxvY2tMZW5ndGgoKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyhvcmllbnRhdGlvbixkaXZsaW5lcnN0eWxlUmVmLHNjcm9sbEJsb2NrTGVuZ3RoUmVmKVxuICAgICAgICBzYXZlRGl2bGluZXJzdHlsZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgY29uc3QgdXBkYXRlQmxvY2tMZW5ndGggPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGJsb2NrbGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgY2FsY1Njcm9sbGJsb2NrTGVuZ3RoKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQ6aGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDp3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgc2Nyb2xsQmxvY2tMZW5ndGhSZWYuY3VycmVudCA9IHNjcm9sbGJsb2NrbGVuZ3RoXG5cbiAgICAgICAgfSxbXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICBdXG4gICAgKVxuXG4gICAgcmV0dXJuIChibG9ja3N0YXRlICE9ICdwcmVwYXJlJylcbiAgICAgICAgPzxkaXYgcmVmID0ge3Njcm9sbGJsb2NrUmVmfSBzdHlsZT17ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fT57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDpudWxsXG5cbn0gLy8gU2Nyb2xsYmxvY2tcblxuLy8gYWxsIHRoZSBwYXJhbWV0ZXJzIGFmZmVjdCB0aGUgbGVuZ3RoXG5jb25zdCBjYWxjU2Nyb2xsYmxvY2tMZW5ndGggPSAoe1xuICAgIGxpc3RzaXplLCBcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIGdhcCwgXG4gICAgcGFkZGluZywgXG4gICAgb3JpZW50YXRpb24sIFxuICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gZGVwZW5kZW50cyBvZiBvcmllbnRhdGlvblxuICAgIGxldCBjcm9zc2xlbmd0aFxuICAgIGxldCBjZWxsTGVuZ3RoXG4gICAgbGV0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydHdpZHRoIFxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcblxuICAgIH1cbiAgICAvLyBhZGp1c3RtZW50cyB0byB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCAtPSAocGFkZGluZyAqIDIpXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCArPSBnYXBcblxuICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoIDwgY3Jvc3NsZW5ndGgpIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBjcm9zc2xlbmd0aCAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZVxuICAgIGxldCBjcm9zc2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydGNyb3NzbGVuZ3RoL2Nyb3NzbGVuZ3RoKVxuXG4gICAgbGV0IGxpc3RsZW5ndGggPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIGxldCBzdHJhaWdodGxlbmd0aCA9IChsaXN0bGVuZ3RoICogY2VsbExlbmd0aCkgLSAoKGxpc3RsZW5ndGggPiAwKT9nYXA6MCkgKyAocGFkZGluZyAqIDIpXG5cbiAgICByZXR1cm4gc3RyYWlnaHRsZW5ndGhcblxufVxuXG5jb25zdCB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyA9IChvcmllbnRhdGlvbixzdHlsZXNSZWYsc2Nyb2xsYmxvY2tsZW5ndGhSZWYpID0+IHtcblxuICAgIGxldCBsb2NhbHN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sc3R5bGVzUmVmLmN1cnJlbnQpIGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICBsZXQgaGVpZ2h0IFxuICAgIGxldCB3aWR0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgIHdpZHRoID0gc2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gc2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbGJsb2NrXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scrollblock.tsx\n");

/***/ }),

/***/ "./src/scrolltracker.tsx":
/*!*******************************!*\
  !*** ./src/scrolltracker.tsx ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // scrolltracker.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar ScrollTracker = function ScrollTracker(_a) {\n  var top = _a.top,\n      left = _a.left,\n      offset = _a.offset,\n      listsize = _a.listsize,\n      styles = _a.styles;\n  var trackdata = offset + 1 + \"/\" + listsize;\n  var styleRef = react_1.useRef(Object.assign({\n    top: top + 'px',\n    left: left + 'px',\n    position: 'fixed',\n    zIndex: 3,\n    backgroundColor: 'white',\n    border: '1px solid gray',\n    borderRadius: '10px',\n    fontSize: 'smaller',\n    padding: '3px'\n  }, styles === null || styles === void 0 ? void 0 : styles.scrolltracker));\n  return react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'scrolltracker',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports[\"default\"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGx0cmFja2VyLnRzeD9mZjgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQSxJQUFNLGFBQWEsR0FBRyxTQUFoQixhQUFnQixDQUFDLEVBQUQsRUFBd0M7TUFBckMsWTtNQUFLLGM7TUFBTSxrQjtNQUFRLHNCO01BQVUsa0I7QUFFbEQsTUFBSSxTQUFTLEdBQU0sTUFBTSxHQUFHLENBQVQsR0FBVSxHQUFWLEdBQWMsUUFBakM7QUFFQSxNQUFJLFFBQVEsR0FBRyxlQUFPLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDaEMsT0FBRyxFQUFFLEdBQUcsR0FBRyxJQURxQjtBQUVoQyxRQUFJLEVBQUUsSUFBSSxHQUFHLElBRm1CO0FBR2hDLFlBQVEsRUFBQyxPQUh1QjtBQUloQyxVQUFNLEVBQUMsQ0FKeUI7QUFLaEMsbUJBQWUsRUFBQyxPQUxnQjtBQU1oQyxVQUFNLEVBQUUsZ0JBTndCO0FBT2hDLGdCQUFZLEVBQUMsTUFQbUI7QUFRaEMsWUFBUSxFQUFDLFNBUnVCO0FBU2hDLFdBQU8sRUFBQztBQVR3QixHQUFkLEVBVUcsTUFBTSxTQUFOLFVBQU0sV0FBTixHQUFNLE1BQU4sU0FBTSxDQUFFLGFBVlgsQ0FBUCxDQUFmO0FBWUEsU0FBTztBQUFBLGlCQUFpQixlQUFqQjtBQUFpQyxTQUFLLEVBQUksUUFBUSxDQUFDO0FBQW5ELEtBQThELFNBQTlELENBQVA7QUFDSCxDQWpCRDs7QUFtQkEscUJBQWUsYUFBZiIsImZpbGUiOiIuL3NyYy9zY3JvbGx0cmFja2VyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmfSBmcm9tICdyZWFjdCdcblxuY29uc3QgU2Nyb2xsVHJhY2tlciA9ICh7IHRvcCwgbGVmdCwgb2Zmc2V0LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGxldCB0cmFja2RhdGEgPSBgJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfWBcblxuICAgIGxldCBzdHlsZVJlZiA9IHVzZVJlZihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246J2ZpeGVkJyxcbiAgICAgICAgekluZGV4OjMsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgZ3JheScsXG4gICAgICAgIGJvcmRlclJhZGl1czonMTBweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgcGFkZGluZzonM3B4J1xuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyxzdHlsZXM/LnNjcm9sbHRyYWNrZXIpKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS1uYW1lID0gJ3Njcm9sbHRyYWNrZXInIHN0eWxlID0ge3N0eWxlUmVmLmN1cnJlbnR9ID57dHJhY2tkYXRhfTwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxUcmFja2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scrolltracker.tsx\n");

/***/ }),

/***/ "./src/viewport.tsx":
/*!**************************!*\
  !*** ./src/viewport.tsx ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // viewport.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible portal of the list being shown\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nexports.ViewportContext = react_1[\"default\"].createContext(null);\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"]; // control constant\n\nvar RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE = 250;\n\nvar Viewport = function Viewport(_a) {\n  // -----------------------[ initialize ]------------------\n  var children = _a.children,\n      orientation = _a.orientation,\n      cellWidth = _a.cellWidth,\n      cellHeight = _a.cellHeight,\n      gap = _a.gap,\n      padding = _a.padding,\n      functions = _a.functions,\n      styles = _a.styles; // processing state\n\n  var _b = react_1.useState('prepare'),\n      portstate = _b[0],\n      setPortState = _b[1];\n\n  var portstateRef = react_1.useRef(null);\n  portstateRef.current = portstate;\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // data heap\n\n  var timeoutidRef = react_1.useRef(null);\n  var viewportdivRef = react_1.useRef(undefined);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    position: 'absolute',\n    // height:'100%',\n    // width:'100%',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    overflow: 'auto',\n    // WebkitOverflowScrolling:'touch',\n    backgroundColor: 'red'\n  }, styles === null || styles === void 0 ? void 0 : styles.viewport));\n  var resizeTimeridRef = react_1.useRef(null);\n  var isResizingRef = react_1.useRef(false);\n  var viewportDataRef = react_1.useRef(null);\n  var resizeObserverRef = react_1.useRef(null); // initialize\n\n  react_1.useEffect(function () {\n    resizeObserverRef.current = new LocalResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportdivRef.current);\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var resizeCallback = react_1.useCallback(function (entries) {\n    if (portstateRef.current == 'prepare') return;\n    var target = entries[0].target;\n\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = true;\n      return;\n    }\n\n    if (!isResizingRef.current) {\n      isResizingRef.current = true; // below is a realtime message to cradle.onScroll\n      // to stop updating the referenceIndexData, and to the item observer to stop\n      // triggering responses (anticipating reset of cradle content based on resize)\n\n      viewportDataRef.current.isResizing = true;\n      if (isMounted()) setPortState('resizing');\n    }\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMounted()) setPortState('resize');\n    }, RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE);\n  }, []); // ----------------------------------[ calculate ]--------------------------------\n  // calculated values\n\n  divlinerstyleRef.current = react_1.useMemo(function () {\n    var mincrosslength = calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding);\n\n    var styles = __assign({}, divlinerstyleRef.current);\n\n    if (orientation == 'vertical') {\n      styles.minWidth = mincrosslength + 'px';\n      styles.minHeight = 'auto';\n    } else {\n      styles.minWidth = 'auto';\n      styles.minHeight = mincrosslength + 'px';\n    }\n\n    return styles;\n  }, [orientation, cellWidth, cellHeight, padding]); // TODO: gap?\n\n  var viewportClientRect;\n\n  if (viewportdivRef.current) {\n    viewportClientRect = viewportdivRef.current.getBoundingClientRect();\n  } else {\n    viewportClientRect = {};\n  }\n\n  var top = viewportClientRect.top,\n      right = viewportClientRect.right,\n      bottom = viewportClientRect.bottom,\n      left = viewportClientRect.left; // set context data for children\n\n  viewportDataRef.current = react_1.useMemo(function () {\n    var width, height, localViewportData;\n\n    if (!(top === undefined)) {\n      //proxy\n      width = right - left;\n      height = bottom - top;\n      localViewportData = {\n        viewportDimensions: {\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n          width: width,\n          height: height\n        },\n        elementref: viewportdivRef,\n        isResizing: isResizingRef.current\n      };\n    }\n\n    return localViewportData;\n  }, [orientation, top, right, bottom, left, isResizingRef.current]); // --------------------[ state processing ]---------------------------\n\n  react_1.useEffect(function () {\n    switch (portstate) {\n      case 'prepare':\n      case 'resize':\n        {\n          setPortState('render');\n          break;\n        }\n    }\n  }, [portstate]); // ----------------------[ render ]--------------------------------\n\n  return react_1[\"default\"].createElement(exports.ViewportContext.Provider, {\n    value: viewportDataRef.current\n  }, react_1[\"default\"].createElement(\"div\", {\n    style: divlinerstyleRef.current,\n    ref: viewportdivRef\n  }, portstate != 'prepare' ? children : null));\n}; // Viewport\n// establish minimum width/height for the viewport -- approximately one item\n\n\nvar calcMinViewportCrossLength = function calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding) {\n  var crosslength, cellLength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellWidth;\n  } else {\n    cellLength = cellHeight;\n  }\n\n  crosslength = cellLength + padding * 2;\n  return crosslength;\n};\n\nexports[\"default\"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy92aWV3cG9ydC50c3g/MGRlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7O0FBRWEsMEJBQWtCLG1CQUFNLGFBQU4sQ0FBb0IsSUFBcEIsQ0FBbEI7O0FBRWI7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQsQyxDQUVBOztBQUNBLElBQU0saUNBQWlDLEdBQUcsR0FBMUM7O0FBRUEsSUFBTSxRQUFRLEdBQUcsU0FBWCxRQUFXLENBQUMsRUFBRCxFQVNoQjtBQUVHO01BVkEsc0I7TUFDQSw0QjtNQUNBLHdCO01BQ0EsMEI7TUFDQSxZO01BQ0Esb0I7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FJRzs7QUFDTTtBQUFBLE1BQUMsaUJBQUQ7QUFBQSxNQUFXLG9CQUFYOztBQUNOLE1BQU0sWUFBWSxHQUFHLGVBQU8sSUFBUCxDQUFyQjtBQUNBLGNBQVksQ0FBQyxPQUFiLEdBQXVCLFNBQXZCO0FBQ0EsTUFBTSxTQUFTLEdBQUcsb0NBQWxCLENBUkgsQ0FTRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxlQUFPLElBQVAsQ0FBckI7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLFNBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDZCxZQUFRLEVBQUMsVUFESztBQUVkO0FBQ0E7QUFDQSxPQUFHLEVBQUMsQ0FKVTtBQUtkLFNBQUssRUFBQyxDQUxRO0FBTWQsVUFBTSxFQUFDLENBTk87QUFPZCxRQUFJLEVBQUMsQ0FQUztBQVFkLFlBQVEsRUFBQyxNQVJLO0FBU2Q7QUFDQSxtQkFBZSxFQUFDO0FBVkYsR0FBZCxFQVdxQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsUUFY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QUFJLFdBQUosRUFBaUIsVUFBakI7O0FBQ0EsTUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFDM0IsY0FBVSxHQUFHLFNBQWI7QUFDSCxHQUZELE1BRU87QUFDSCxjQUFVLEdBQUcsVUFBYjtBQUNIOztBQUNELGFBQVcsR0FBRyxVQUFVLEdBQUksT0FBTyxHQUFHLENBQXRDO0FBQ0EsU0FBTyxXQUFQO0FBQ0gsQ0FURDs7QUFXQSxxQkFBZSxRQUFmIiwiZmlsZSI6Ii4vc3JjL3ZpZXdwb3J0LnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXdwb3J0LnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2Ygdmlld3BvcnQgaXMgdG8gcHJvdmlkZSBkYXRhIHRvIGl0cyBjaGlsZHJlbiAoc2Nyb2xsYmxvY2sgYW5kIGNyYWRsZSksIFxuICAgIGFuZCBhY3QgYXMgdGhlIHZpc2libGUgcG9ydGFsIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZUNhbGxiYWNrfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IFZpZXdwb3J0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuaW1wb3J0IHVzZUlzTW91bnRlZCBmcm9tICdyZWFjdC1pcy1tb3VudGVkLWhvb2snXG5cbmltcG9ydCBSZXNpemVPYnNlcnZlclBvbHlmaWxsIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCdcblxuY29uc3QgTG9jYWxSZXNpemVPYnNlcnZlciA9IHdpbmRvd1snUmVzaXplT2JzZXJ2ZXInXSB8fCBSZXNpemVPYnNlcnZlclBvbHlmaWxsXG5cbi8vIGNvbnRyb2wgY29uc3RhbnRcbmNvbnN0IFJFU0laRV9USU1FT1VUX0ZPUl9PTkFGVEVSU1JFU0laRSA9IDI1MFxuXG5jb25zdCBWaWV3cG9ydCA9ICh7XG4gICAgY2hpbGRyZW4sIFxuICAgIG9yaWVudGF0aW9uLCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGdhcCwgXG4gICAgcGFkZGluZywgXG4gICAgZnVuY3Rpb25zLCBcbiAgICBzdHlsZXMsXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgY29uc3QgW3BvcnRzdGF0ZSxzZXRQb3J0U3RhdGVdID0gdXNlU3RhdGUoJ3ByZXBhcmUnKVxuICAgIGNvbnN0IHBvcnRzdGF0ZVJlZiA9IHVzZVJlZihudWxsKVxuICAgIHBvcnRzdGF0ZVJlZi5jdXJyZW50ID0gcG9ydHN0YXRlXG4gICAgY29uc3QgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKClcbiAgICAvLyBkYXRhIGhlYXBcbiAgICBjb25zdCB0aW1lb3V0aWRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB2aWV3cG9ydGRpdlJlZiA9IHVzZVJlZih1bmRlZmluZWQpXG4gICAgY29uc3QgZGl2bGluZXJzdHlsZVJlZiA9IHVzZVJlZihcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgIC8vIGhlaWdodDonMTAwJScsXG4gICAgICAgIC8vIHdpZHRoOicxMDAlJyxcbiAgICAgICAgdG9wOjAsXG4gICAgICAgIHJpZ2h0OjAsXG4gICAgICAgIGJvdHRvbTowLFxuICAgICAgICBsZWZ0OjAsXG4gICAgICAgIG92ZXJmbG93OidhdXRvJyxcbiAgICAgICAgLy8gV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6J3RvdWNoJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOidyZWQnLFxuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyxzdHlsZXM/LnZpZXdwb3J0KSlcbiAgICBjb25zdCByZXNpemVUaW1lcmlkUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgaXNSZXNpemluZ1JlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCB2aWV3cG9ydERhdGFSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBMb2NhbFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRkaXZSZWYuY3VycmVudClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCByZXNpemVDYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKT0+e1xuXG4gICAgICAgIGlmIChwb3J0c3RhdGVSZWYuY3VycmVudCA9PSAncHJlcGFyZScpIHJldHVyblxuXG4gICAgICAgIGxldCB0YXJnZXQgPSBlbnRyaWVzWzBdLnRhcmdldFxuXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gdHJ1ZSBcbiAgICAgICAgICAgICAgICAvLyBiZWxvdyBpcyBhIHJlYWx0aW1lIG1lc3NhZ2UgdG8gY3JhZGxlLm9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgLy8gdG8gc3RvcCB1cGRhdGluZyB0aGUgcmVmZXJlbmNlSW5kZXhEYXRhLCBhbmQgdG8gdGhlIGl0ZW0gb2JzZXJ2ZXIgdG8gc3RvcFxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJpbmcgcmVzcG9uc2VzIChhbnRpY2lwYXRpbmcgcmVzZXQgb2YgY3JhZGxlIGNvbnRlbnQgYmFzZWQgb24gcmVzaXplKVxuICAgICAgICAgICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IHRydWVcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQoKSkgc2V0UG9ydFN0YXRlKCdyZXNpemluZycpXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQoKSkgc2V0UG9ydFN0YXRlKCdyZXNpemUnKVxuXG4gICAgICAgIH0sUkVTSVpFX1RJTUVPVVRfRk9SX09OQUZURVJTUkVTSVpFKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBtaW5jcm9zc2xlbmd0aCA9IGNhbGNNaW5WaWV3cG9ydENyb3NzTGVuZ3RoKG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHBhZGRpbmcpXG4gICAgICAgIGxldCBzdHlsZXMgPSB7Li4uZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzdHlsZXMubWluV2lkdGggPSBtaW5jcm9zc2xlbmd0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlcy5taW5IZWlnaHQgPSAnYXV0bydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5taW5XaWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9IG1pbmNyb3NzbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlc1xuXG4gICAgfSxbb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcGFkZGluZ10pIC8vIFRPRE86IGdhcD9cblxuICAgIGxldCB2aWV3cG9ydENsaWVudFJlY3RcbiAgICBpZiAodmlld3BvcnRkaXZSZWYuY3VycmVudCkge1xuICAgICAgICB2aWV3cG9ydENsaWVudFJlY3QgPSB2aWV3cG9ydGRpdlJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmlld3BvcnRDbGllbnRSZWN0ID0ge31cbiAgICB9XG4gICAgbGV0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gdmlld3BvcnRDbGllbnRSZWN0XG5cbiAgICAvLyBzZXQgY29udGV4dCBkYXRhIGZvciBjaGlsZHJlblxuICAgIHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCBsb2NhbFZpZXdwb3J0RGF0YVxuICAgICAgICBpZiAoISh0b3AgPT09IHVuZGVmaW5lZCkpIHsgLy9wcm94eVxuICAgICAgICAgICAgd2lkdGggPSAocmlnaHQgLSBsZWZ0KVxuICAgICAgICAgICAgaGVpZ2h0ID0gKGJvdHRvbSAtIHRvcClcbiAgICAgICAgICAgIGxvY2FsVmlld3BvcnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczp7dG9wLHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgICAgICAgICAgIGVsZW1lbnRyZWY6dmlld3BvcnRkaXZSZWYsXG4gICAgICAgICAgICAgICAgaXNSZXNpemluZzppc1Jlc2l6aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmlld3BvcnREYXRhXG5cbiAgICB9LFtvcmllbnRhdGlvbiwgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBpc1Jlc2l6aW5nUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIHByb2Nlc3NpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBzd2l0Y2ggKHBvcnRzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAncHJlcGFyZSc6XG4gICAgICAgICAgICBjYXNlICdyZXNpemUnOiB7XG4gICAgICAgICAgICAgICAgc2V0UG9ydFN0YXRlKCdyZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFtwb3J0c3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJldHVybiA8Vmlld3BvcnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyB2aWV3cG9ydERhdGFSZWYuY3VycmVudCB9PlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgc3R5bGUgPSB7ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fVxuICAgICAgICAgICAgcmVmID0ge3ZpZXdwb3J0ZGl2UmVmfVxuICAgICAgICA+XG4gICAgICAgICAgICB7IChwb3J0c3RhdGUgIT0gJ3ByZXBhcmUnKT9jaGlsZHJlbjpudWxsIH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9WaWV3cG9ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgXG59IC8vIFZpZXdwb3J0XG5cbi8vIGVzdGFibGlzaCBtaW5pbXVtIHdpZHRoL2hlaWdodCBmb3IgdGhlIHZpZXdwb3J0IC0tIGFwcHJveGltYXRlbHkgb25lIGl0ZW1cbmNvbnN0IGNhbGNNaW5WaWV3cG9ydENyb3NzTGVuZ3RoID0gKG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHBhZGRpbmcpID0+IHtcbiAgICBsZXQgY3Jvc3NsZW5ndGgsIGNlbGxMZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHRcbiAgICB9XG4gICAgY3Jvc3NsZW5ndGggPSBjZWxsTGVuZ3RoICsgKHBhZGRpbmcgKiAyKVxuICAgIHJldHVybiBjcm9zc2xlbmd0aFxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/viewport.tsx\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci9leHRlcm5hbCBcIlJlYWN0XCI/YzQ4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJyZWFjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });
});