/*! For license information please see build.js.LICENSE.txt */
!function(e,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],I):"object"==typeof exports?exports["react-infinite-grid-scroller"]=I(require("react"),require("react-dom")):e["react-infinite-grid-scroller"]=I(e.react,e["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n    Anything else is treated as an error\n\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned from getItem, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its scroller that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical index in the list) and a session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n\n    One CellFrame at a time is designated as the host of the two triggerLines with the isTriggerCell flag.\n    The triggerlines trigger an update of the Cradle through an IntersectionObserver.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\nvar defaultPlaceholderMessages = {\n  loading: \'(loading...)\',\n  retrieving: \'(retrieving from cache)\',\n  "null": \'end of list\',\n  undefined: \'host returned "undefined"\',\n  invalid: \'invalid React element\'\n};\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n    cellHeight = _ref.cellHeight,\n    cellWidth = _ref.cellWidth,\n    cellMinHeight = _ref.cellMinHeight,\n    cellMinWidth = _ref.cellMinWidth,\n    layout = _ref.layout,\n    getItem = _ref.getItem,\n    listsize = _ref.listsize,\n    placeholder = _ref.placeholder,\n    itemID = _ref.itemID,\n    index = _ref.index,\n    instanceID = _ref.instanceID,\n    scrollerID = _ref.scrollerID,\n    isTriggercell = _ref.isTriggercell,\n    placeholderFrameStyles = _ref.placeholderFrameStyles,\n    placeholderLinerStyles = _ref.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref.placeholderErrorLinerStyles,\n    placeholderMessages = _ref.placeholderMessages,\n    usePlaceholder = _ref.usePlaceholder;\n  var coreConfigRef = (0, react_1.useRef)(null);\n  coreConfigRef.current = {\n    orientation: orientation,\n    layout: layout,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight\n  };\n  // ----------------------[ setup ]----------------------\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n    scrollerPropertiesRef = cradleContext.scrollerPropertiesRef,\n    nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n    itemExceptionCallback = cradleContext.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef;\n  // style change generates state refresh\n  var stylesRef = (0, react_1.useRef)({});\n  var holderStylesRef = (0, react_1.useRef)({});\n  var placeholderMessagesRef = (0, react_1.useRef)(null);\n  placeholderMessagesRef.current = (0, react_1.useMemo)(function () {\n    var newMessages = Object.assign(Object.assign({}, defaultPlaceholderMessages), placeholderMessages);\n    return newMessages;\n  }, [placeholderMessages]);\n  // processing state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameState = _ref3[0],\n    setFrameState = _ref3[1];\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState;\n  // DOM ref\n  var frameRef = (0, react_1.useRef)(null);\n  // to track unmount interrupt\n  var isMountedRef = (0, react_1.useRef)(true);\n  // cache data\n  var portalMetadataRef = (0, react_1.useRef)(null);\n  // the placeholder to use\n  var placeholderRef = (0, react_1.useRef)(null);\n  // the session itemID to use; could be updated by parent\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID;\n  var cellFrameDataRef = (0, react_1.useRef)(null);\n  cellFrameDataRef.current = {\n    itemID: itemID,\n    index: index\n  };\n  // fetch error\n  var errorRef = (0, react_1.useRef)(false);\n  // placeholder message\n  var messageRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // for unmount\n  (0, react_1.useEffect)(function () {\n    return function () {\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.removeRequestedPortal(index);\n    };\n  }, []);\n  // refresh content if itemID changes\n  (0, react_1.useLayoutEffect)(function () {\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]);\n  // ----------------- [ placeholder definition ] -------------------------\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, messageRef.current, errorRef.current, usePlaceholder]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      key: \'placeholder\',\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userLinerStyles: placeholderLinerStyles,\n      userErrorFrameStyles: placeholderErrorFrameStyles,\n      userErrorLinerStyles: placeholderErrorLinerStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current, usePlaceholder, placeholderFrameStyles, placeholderLinerStyles, placeholderErrorFrameStyles, placeholderErrorLinerStyles]);\n  // ---------------- [ requestidlecallback config ] ------------------------\n  var requestidlecallback =\n  // requestIdleCallback\n  window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback =\n  // cancelIdleCallback\n  window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null);\n  // --------------------[ processing ]-----------------\n  // set styles\n  (0, react_1.useEffect)(function () {\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, stylesRef.current);\n    var newHolderStyles = getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight);\n    if (isMountedRef.current) {\n      stylesRef.current = newStyles;\n      holderStylesRef.current = newHolderStyles;\n    }\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        {\n          setFrameState(\'working\'); // \'getusercontent\' will be called\n          break;\n        }\n      case \'working\':\n        {\n          setFrameState(\'getusercontent\'); // delay paint while working\n          break;\n        }\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID);\n          var _coreConfigRef$curren = coreConfigRef.current,\n            _layout = _coreConfigRef$curren.layout,\n            _orientation = _coreConfigRef$curren.orientation,\n            _cellWidth = _coreConfigRef$curren.cellWidth,\n            _cellHeight = _coreConfigRef$curren.cellHeight;\n          if (cached) {\n            messageRef.current = placeholderMessagesRef.current.retrieving;\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheHandler.getPortalMetadata(_itemID);\n              // get OutPortal node\n              portalMetadataRef.current.scrollerProperties.cellFrameDataRef = cellFrameDataRef;\n              portalNodeRef.current = portalMetadataRef.current.portalNode;\n              setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n              setFrameState(\'retrieved\');\n            }\n          } else {\n            messageRef.current = placeholderMessagesRef.current.loading;\n            // setFrameState(\'fetching\')\n            // reserve space in the cache\n            cacheHandler.registerRequestedPortal(index);\n            // enqueue the fetch\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, isValidElement, content, scrollerProperties;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return getItem(index, _itemID);\n                      case 3:\n                        usercontent = _context.sent;\n                        if (usercontent === null) returnvalue = usercontent;\n                        if (usercontent === undefined) {\n                          error = new Error(placeholderMessagesRef.current.undefined);\n                        }\n                        _context.next = 12;\n                        break;\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context["catch"](0);\n                        returnvalue = usercontent = undefined;\n                        error = _context.t0;\n                      case 12:\n                        // process the return value\n                        if (usercontent !== null && usercontent !== undefined) {\n                          isValidElement = react_1["default"].isValidElement(usercontent);\n                          if (!isValidElement) {\n                            returnvalue = usercontent;\n                            usercontent = undefined;\n                            error = new Error(placeholderMessagesRef.current.invalid);\n                          }\n                        }\n                        if (!isMountedRef.current) {\n                          _context.next = 26;\n                          break;\n                        }\n                        if (!(usercontent !== null && usercontent !== undefined)) {\n                          _context.next = 25;\n                          break;\n                        }\n                        // if usercontent is otherwise disallowed, let error handling deal with it.\n                        scrollerProperties = {\n                          cellFrameDataRef: cellFrameDataRef,\n                          scrollerPropertiesRef: scrollerPropertiesRef\n                        };\n                        if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                          content = react_1["default"].cloneElement(usercontent, {\n                            scrollerProperties: scrollerProperties\n                          });\n                        } else {\n                          content = usercontent;\n                        }\n                        _context.next = 19;\n                        return cacheHandler.createPortal(content, index, _itemID, scrollerProperties);\n                      case 19:\n                        portalMetadataRef.current = _context.sent;\n                        portalNodeRef.current = portalMetadataRef.current.portalNode;\n                        setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n                        isMountedRef.current && setFrameState(\'inserting\');\n                        _context.next = 26;\n                        break;\n                      case 25:\n                        // null or undefined; handle non-component value\n                        if (usercontent === null) {\n                          // truncate listsize at this index\n                          itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(placeholderMessagesRef.current["null"]));\n                          nullItemSetMaxListsize(index);\n                        } else {\n                          // usercontent === undefined, meaning an error has occurred\n                          // change placeholder message to error message\n                          errorRef.current = error;\n                          // notify the host\n                          itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                          isMountedRef.current && setFrameState(\'error\');\n                        }\n                      case 26:\n                      case "end":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n          break;\n        }\n      case \'inserting\':\n      case \'retrieved\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n    }\n  }, [frameState]);\n  // Note: the contentholder type layer is included to provide an anchor for the triggerlines.\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: stylesRef.current\n  }, frameState != \'setup\' ? react_1["default"].createElement("div", {\n    "data-type": \'contentholder\',\n    style: holderStylesRef.current\n  }, frameState != \'ready\' ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    key: \'portal\',\n    node: portalNodeRef.current\n  })) : react_1["default"].createElement("div", null), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\n//(frameState != \'setup\') && \nexports["default"] = CellFrame;\n// utilities\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\',\n    overflow: \'visible\'\n  });\n  if (orientation === \'vertical\') {\n    styleset.width = null;\n    if (layout == \'uniform\') {\n      styleset.height = cellHeight + \'px\';\n      styleset.minHeight = null;\n      styleset.maxHeight = null;\n    } else {\n      // \'variable\'\n      styleset.height = null;\n      styleset.minHeight = cellMinHeight + \'px\';\n      styleset.maxHeight = cellHeight + \'px\';\n    }\n  } else {\n    // \'horizontal\'\n    styleset.height = null;\n    if (layout == \'uniform\') {\n      styleset.width = cellWidth + \'px\';\n      styleset.minWidth = null;\n      styleset.maxWidth = null;\n    } else {\n      // \'variable\'\n      styleset.width = null;\n      styleset.minWidth = cellMinWidth + \'px\';\n      styleset.maxWidth = cellWidth + \'px\';\n    }\n  }\n  return styleset;\n};\nvar getContentHolderStyles = function getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight) {\n  var styles = {};\n  if (layout == \'uniform\') {\n    styles = {\n      inset: \'0px\',\n      position: \'absolute\',\n      height: null,\n      width: null,\n      minWidth: null,\n      minHeight: null\n    };\n  } else {\n    // variable\n    styles.inset = null;\n    styles.position = null;\n    if (orientation == \'vertical\') {\n      styles.width = \'100%\';\n      styles.height = null;\n      styles.minWidth = null;\n      styles.minHeight = cellMinHeight + \'px\';\n    } else {\n      styles.width = null;\n      styles.height = \'100%\';\n      styles.minWidth = cellMinWidth + \'px\';\n      styles.minHeight = null;\n    }\n  }\n  return styles;\n};\n// see also some base styles set in cachehandler\nvar setContainerStyles = function setContainerStyles(container, layout, orientation, cellWidth, cellHeight) {\n  container.style.overflow = \'hidden\';\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n    container.style.maxWidth = null;\n    container.style.maxHeight = null;\n    container.style.height = null;\n    container.style.width = null;\n  } else {\n    // variable\n    container.style.inset = null;\n    container.style.position = null;\n    if (orientation == \'vertical\') {\n      container.style.width = \'100%\';\n      container.style.height = null;\n      container.style.maxWidth = null;\n      container.style.maxHeight = cellHeight + \'px\';\n    } else {\n      container.style.width = null;\n      container.style.height = \'100%\';\n      container.style.maxWidth = cellWidth + \'px\';\n      container.style.maxHeight = null;\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2VsbEZyYW1lLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUFBLCtDQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQVNBLDBIQUEyRSxDQUFDO0FBRTVFLHNJQUFnRCxDQUFDO0FBRWpELDJIQUFpRCxDQUFDO0FBRWxEO0FBRUEsSUFBTUEsMEJBQTBCLEdBQUc7RUFDL0JDLE9BQU8sRUFBQyxjQUFjO0VBQ3RCQyxVQUFVLEVBQUMseUJBQXlCO0VBQ3BDLFFBQUssYUFBYTtFQUNsQkMsU0FBUyxFQUFDLDJCQUEyQjtFQUNyQ0MsT0FBTyxFQUFDO0NBQ1g7QUFFRCxJQUFNQyxTQUFTLEdBQUcsU0FBWkEsU0FBUyxPQXFCVjtFQUFBLElBcEJEQyxXQUFXLFFBQVhBLFdBQVc7SUFDWEMsVUFBVSxRQUFWQSxVQUFVO0lBQ1ZDLFNBQVMsUUFBVEEsU0FBUztJQUNUQyxhQUFhLFFBQWJBLGFBQWE7SUFDYkMsWUFBWSxRQUFaQSxZQUFZO0lBQ1pDLE1BQU0sUUFBTkEsTUFBTTtJQUNOQyxPQUFPLFFBQVBBLE9BQU87SUFDUEMsUUFBUSxRQUFSQSxRQUFRO0lBQ1JDLFdBQVcsUUFBWEEsV0FBVztJQUNYQyxNQUFNLFFBQU5BLE1BQU07SUFDTkMsS0FBSyxRQUFMQSxLQUFLO0lBQ0xDLFVBQVUsUUFBVkEsVUFBVTtJQUNWQyxVQUFVLFFBQVZBLFVBQVU7SUFDVkMsYUFBYSxRQUFiQSxhQUFhO0lBQ2JDLHNCQUFzQixRQUF0QkEsc0JBQXNCO0lBQ3RCQyxzQkFBc0IsUUFBdEJBLHNCQUFzQjtJQUN0QkMsMkJBQTJCLFFBQTNCQSwyQkFBMkI7SUFDM0JDLDJCQUEyQixRQUEzQkEsMkJBQTJCO0lBQzNCQyxtQkFBbUIsUUFBbkJBLG1CQUFtQjtJQUNuQkMsY0FBYyxRQUFkQSxjQUFjO0VBR2QsSUFBTUMsYUFBYSxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ2xDQSxhQUFhLENBQUNDLE9BQU8sR0FBRztJQUNwQnJCLFdBQVcsRUFBWEEsV0FBVztJQUNYSyxNQUFNLEVBQU5BLE1BQU07SUFDTkgsU0FBUyxFQUFUQSxTQUFTO0lBQ1RELFVBQVUsRUFBVkE7R0FDSDtFQUVEO0VBRUEsSUFBTXFCLGFBQWEsR0FBRyxzQkFBVSxFQUFDQyxzQkFBYSxDQUFDO0VBRS9DLElBQ0lDLFlBQVksR0FNWkYsYUFBYSxDQU5iRSxZQUFZO0lBQ1pDLHFCQUFxQixHQUtyQkgsYUFBYSxDQUxiRyxxQkFBcUI7SUFDckJDLHNCQUFzQixHQUl0QkosYUFBYSxDQUpiSSxzQkFBc0I7SUFDdEJDLHFCQUFxQixHQUdyQkwsYUFBYSxDQUhiSyxxQkFBcUI7SUFDckJDLG9CQUFvQixHQUVwQk4sYUFBYSxDQUZiTSxvQkFBb0I7SUFDcEJDLDBCQUEwQixHQUMxQlAsYUFBYSxDQURiTywwQkFBMEI7RUFHOUI7RUFDQSxJQUFNQyxTQUFTLEdBQUcsa0JBQU0sRUFBQyxFQUFFLENBQUM7RUFDNUIsSUFBTUMsZUFBZSxHQUFHLGtCQUFNLEVBQUMsRUFBRSxDQUFDO0VBRWxDLElBQU1DLHNCQUFzQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBRTVDQSxzQkFBc0IsQ0FBQ1gsT0FBTyxHQUFHLG1CQUFPLEVBQUMsWUFBSztJQUV6QyxJQUFNWSxXQUFXLG1DQUFPdkMsMEJBQTBCLEdBQUl3QixtQkFBbUIsQ0FBQztJQUUxRSxPQUFPZSxXQUFXO0VBRXRCLENBQUMsRUFBQyxDQUFDZixtQkFBbUIsQ0FBQyxDQUFDO0VBRXhCO0VBQ0EsWUFBb0Msb0JBQVEsRUFBQyxPQUFPLENBQUM7SUFBQTtJQUE5Q2dCLFVBQVU7SUFBRUMsYUFBYTtFQUNoQyxJQUFNQyxhQUFhLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDbENBLGFBQWEsQ0FBQ2YsT0FBTyxHQUFHYSxVQUFVO0VBRWxDO0VBQ0EsSUFBTUcsUUFBUSxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQzdCO0VBQ0EsSUFBTUMsWUFBWSxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ2pDO0VBQ0EsSUFBTUMsaUJBQWlCLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDdEM7RUFDQSxJQUFNQyxjQUFjLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDbkM7RUFDQSxJQUFNQyxTQUFTLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDOUJBLFNBQVMsQ0FBQ3BCLE9BQU8sR0FBR1osTUFBTTtFQUMxQixJQUFNaUMsZ0JBQWdCLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDckNBLGdCQUFnQixDQUFDckIsT0FBTyxHQUFHO0lBQ3ZCWixNQUFNLEVBQU5BLE1BQU07SUFDTkMsS0FBSyxFQUFMQTtHQUNIO0VBQ0Q7RUFDQSxJQUFNaUMsUUFBUSxHQUFHLGtCQUFNLEVBQUMsS0FBSyxDQUFDO0VBQzlCO0VBQ0EsSUFBTUMsVUFBVSxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBRS9CLHFCQUFTLEVBQUMsWUFBSTtJQUVWTixZQUFZLENBQUNqQixPQUFPLEdBQUcsSUFBSTtJQUUzQixPQUFPLFlBQUs7TUFFUmlCLFlBQVksQ0FBQ2pCLE9BQU8sR0FBRyxLQUFLO0lBRWhDLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUw7RUFDQSxxQkFBUyxFQUFDLFlBQUk7SUFFVixPQUFPLFlBQUs7TUFFUndCLGtCQUFrQixDQUFDQyx3QkFBd0IsQ0FBQ3pCLE9BQU8sQ0FBQztNQUVwREcsWUFBWSxDQUFDdUIscUJBQXFCLENBQUNyQyxLQUFLLENBQUM7SUFFN0MsQ0FBQztFQUVMLENBQUMsRUFBQyxFQUFFLENBQUM7RUFFTDtFQUNBLDJCQUFlLEVBQUMsWUFBSTtJQUVoQixJQUFJNEIsWUFBWSxDQUFDakIsT0FBTyxFQUFFYyxhQUFhLENBQUMsZ0JBQWdCLENBQUM7RUFFN0QsQ0FBQyxFQUFDLENBQUMxQixNQUFNLENBQUMsQ0FBQztFQUVYO0VBRUEsSUFBTXVDLGlCQUFpQixHQUFHLG1CQUFPLEVBQUMsWUFBSztJQUVuQyxJQUFJLENBQUM3QixjQUFjLEVBQUUsT0FBTyxJQUFJO0lBRWhDLE9BQU9YLFdBQVcsR0FDZHlDLGtCQUFLLENBQUNDLGFBQWEsQ0FBQzFDLFdBQVcsRUFDM0I7TUFBQ0UsS0FBSyxFQUFMQSxLQUFLO01BQUVILFFBQVEsRUFBUkEsUUFBUTtNQUFFNEMsT0FBTyxFQUFDUCxVQUFVLENBQUN2QixPQUFPO01BQUUrQixLQUFLLEVBQUNULFFBQVEsQ0FBQ3RCO0lBQU8sQ0FBQyxDQUFDLEdBQzFFLElBQUk7RUFFWixDQUFDLEVBQUMsQ0FDRVgsS0FBSyxFQUNMRixXQUFXLEVBQ1hELFFBQVEsRUFDUnFDLFVBQVUsQ0FBQ3ZCLE9BQU8sRUFDbEJzQixRQUFRLENBQUN0QixPQUFPLEVBQ2hCRixjQUFjLENBQ2pCLENBQUM7RUFFRnFCLGNBQWMsQ0FBQ25CLE9BQU8sR0FBRyxtQkFBTyxFQUFDLFlBQUk7SUFFakMsSUFBSSxDQUFDRixjQUFjLEVBQUUsT0FBTyxJQUFJO0lBRWhDLElBQU1YLFdBQVcsR0FDYndDLGlCQUFpQixHQUNiQSxpQkFBaUIsR0FDakJDLGlDQUFDSSx3QkFBVztNQUNSQyxHQUFHLEVBQUcsYUFBYTtNQUNuQjVDLEtBQUssRUFBS0EsS0FBSztNQUNmSCxRQUFRLEVBQUtBLFFBQVE7TUFDckI0QyxPQUFPLEVBQUtQLFVBQVUsQ0FBQ3ZCLE9BQU87TUFDOUIrQixLQUFLLEVBQUtULFFBQVEsQ0FBQ3RCLE9BQU87TUFDMUJrQyxlQUFlLEVBQUt6QyxzQkFBc0I7TUFDMUMwQyxlQUFlLEVBQUt6QyxzQkFBc0I7TUFDMUMwQyxvQkFBb0IsRUFBS3pDLDJCQUEyQjtNQUNwRDBDLG9CQUFvQixFQUFLekM7SUFBMkIsRUFDdEQ7SUFFVixPQUFPVCxXQUFXO0VBRXRCLENBQUMsRUFBRSxDQUNDRSxLQUFLLEVBQ0xzQyxpQkFBaUIsRUFDakJ6QyxRQUFRLEVBQ1JxQyxVQUFVLENBQUN2QixPQUFPLEVBQ2xCc0IsUUFBUSxDQUFDdEIsT0FBTyxFQUNoQkYsY0FBYyxFQUNkTCxzQkFBc0IsRUFDdEJDLHNCQUFzQixFQUN0QkMsMkJBQTJCLEVBQzNCQywyQkFBMkIsQ0FDOUIsQ0FBQztFQUVGO0VBRUEsSUFBTTBDLG1CQUFtQjtFQUFHO0VBQ3hCQyxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FDekJBLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUM3QkMseUNBQW1CO0VBRTNCLElBQU1oQixrQkFBa0I7RUFBRztFQUN2QmUsTUFBTSxDQUFDLG9CQUFvQixDQUFDLEdBQ3hCQSxNQUFNLENBQUMsb0JBQW9CLENBQUMsR0FDNUJDLHdDQUFrQjtFQUUxQixJQUFNZix3QkFBd0IsR0FBRyxrQkFBTSxFQUFDLElBQUksQ0FBQztFQUU3QztFQUVBO0VBQ0EscUJBQVMsRUFBQyxZQUFJO0lBRVYsSUFBTWdCLFNBQVMsR0FBR0MsY0FBYyxDQUM1Qi9ELFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUV5QixTQUFTLENBQUNULE9BQU8sQ0FBQztJQUUvRixJQUFNMkMsZUFBZSxHQUFHQyxzQkFBc0IsQ0FBQzVELE1BQU0sRUFBRUwsV0FBVyxFQUFFSSxZQUFZLEVBQUVELGFBQWEsQ0FBQztJQUVoRyxJQUFJbUMsWUFBWSxDQUFDakIsT0FBTyxFQUFFO01BRXRCUyxTQUFTLENBQUNULE9BQU8sR0FBR3lDLFNBQVM7TUFDN0IvQixlQUFlLENBQUNWLE9BQU8sR0FBRzJDLGVBQWU7O0VBSWpELENBQUMsRUFBQyxDQUFDaEUsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLE1BQU0sQ0FBQyxDQUFDO0VBRTVFLElBQU02RCxhQUFhLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFFbEMsMkJBQWUsRUFBQyxZQUFLO0lBRWpCLFFBQVFoQyxVQUFVO01BRWQsS0FBSyxPQUFPO1FBQUU7VUFFVkMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxFQUFDO1VBRXpCOztNQUlKLEtBQUssU0FBUztRQUFFO1VBRVpBLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFDO1VBRWhDOztNQUlKLEtBQUssZ0JBQWdCO1FBQUU7VUFFbkIsSUFBTTFCLE9BQU0sR0FBR2dDLFNBQVMsQ0FBQ3BCLE9BQU87VUFDaEMsSUFBTThDLE1BQU0sR0FBRzNDLFlBQVksQ0FBQzRDLFNBQVMsQ0FBQzNELE9BQU0sQ0FBQztVQUM3Qyw0QkFLSVcsYUFBYSxDQUFDQyxPQUFPO1lBSnJCaEIsT0FBTSx5QkFBTkEsTUFBTTtZQUNOTCxZQUFXLHlCQUFYQSxXQUFXO1lBQ1hFLFVBQVMseUJBQVRBLFNBQVM7WUFDVEQsV0FBVSx5QkFBVkEsVUFBVTtVQUdkLElBQUlrRSxNQUFNLEVBQUU7WUFFUnZCLFVBQVUsQ0FBQ3ZCLE9BQU8sR0FBR1csc0JBQXNCLENBQUNYLE9BQU8sQ0FBQ3pCLFVBQVU7WUFFOUQsSUFBSTBDLFlBQVksQ0FBQ2pCLE9BQU8sRUFBRTtjQUV0QjtjQUNBa0IsaUJBQWlCLENBQUNsQixPQUFPLEdBQUdHLFlBQVksQ0FBQzZDLGlCQUFpQixDQUFDNUQsT0FBTSxDQUFDO2NBQ2xFO2NBQ0E4QixpQkFBaUIsQ0FBQ2xCLE9BQU8sQ0FBQ2lELGtCQUFrQixDQUFDNUIsZ0JBQWdCLEdBQUdBLGdCQUFnQjtjQUNoRndCLGFBQWEsQ0FBQzdDLE9BQU8sR0FBR2tCLGlCQUFpQixDQUFDbEIsT0FBTyxDQUFDa0QsVUFBVTtjQUM1REMsa0JBQWtCLENBQ2ROLGFBQWEsQ0FBQzdDLE9BQU8sQ0FBQ29ELE9BQU8sRUFBRXBFLE9BQU0sRUFBRUwsWUFBVyxFQUFFRSxVQUFTLEVBQUVELFdBQVUsQ0FBQztjQUU5RWtDLGFBQWEsQ0FBQyxXQUFXLENBQUM7O1dBSWpDLE1BQU07WUFFSFMsVUFBVSxDQUFDdkIsT0FBTyxHQUFHVyxzQkFBc0IsQ0FBQ1gsT0FBTyxDQUFDMUIsT0FBTztZQUUzRDtZQUVBO1lBQ0E2QixZQUFZLENBQUNrRCx1QkFBdUIsQ0FBQ2hFLEtBQUssQ0FBQztZQUUzQztZQUNBb0Msd0JBQXdCLENBQUN6QixPQUFPLEdBQUdzQyxtQkFBbUIsQ0FBQztjQUFBLE9BQVVnQjtnQkFBQTtnQkFBQTtrQkFBQTtvQkFBQTtzQkFBQTt3QkFBQTt3QkFBQTt3QkFNM0MsT0FBTXJFLE9BQU8sQ0FBQ0ksS0FBSyxFQUFFRCxPQUFNLENBQUM7c0JBQUE7d0JBQTFDbUUsV0FBVzt3QkFFWCxJQUFJQSxXQUFXLEtBQUssSUFBSSxFQUFFQyxXQUFXLEdBQUdELFdBQVc7d0JBRW5ELElBQUlBLFdBQVcsS0FBSy9FLFNBQVMsRUFBRTswQkFFM0J1RCxLQUFLLEdBQUcsSUFBSTBCLEtBQUssQ0FBQzlDLHNCQUFzQixDQUFDWCxPQUFPLENBQUN4QixTQUFTLENBQUM7O3dCQUU5RDt3QkFBQTtzQkFBQTt3QkFBQTt3QkFBQTt3QkFJRGdGLFdBQVcsR0FBR0QsV0FBVyxHQUFHL0UsU0FBUzt3QkFDckN1RCxLQUFLLGNBQUk7c0JBQUE7d0JBR2I7d0JBQ0EsSUFBS3dCLFdBQVcsS0FBSyxJQUFJLElBQU1BLFdBQVcsS0FBSy9FLFNBQVUsRUFBRTswQkFFakRrRixjQUFjLEdBQUc5QixrQkFBSyxDQUFDOEIsY0FBYyxDQUFDSCxXQUFXLENBQUM7MEJBQ3hELElBQUksQ0FBQ0csY0FBYyxFQUFFOzRCQUVqQkYsV0FBVyxHQUFHRCxXQUFXOzRCQUN6QkEsV0FBVyxHQUFHL0UsU0FBUzs0QkFDdkJ1RCxLQUFLLEdBQUcsSUFBSTBCLEtBQUssQ0FBQzlDLHNCQUFzQixDQUFDWCxPQUFPLENBQUN2QixPQUFPLENBQUM7Ozt3QkFJaEUsS0FFR3dDLFlBQVksQ0FBQ2pCLE9BQU87MEJBQUE7MEJBQUE7d0JBQUE7d0JBQUEsTUFFZnVELFdBQVcsS0FBSyxJQUFJLElBQU1BLFdBQVcsS0FBSy9FLFNBQVU7MEJBQUE7MEJBQUE7d0JBQUE7d0JBRXJEO3dCQUVNeUUsa0JBQWtCLEdBQUc7MEJBQ3ZCNUIsZ0JBQWdCLEVBQWhCQSxnQkFBZ0I7MEJBQ2hCakIscUJBQXFCLEVBQXJCQTt5QkFDSDt3QkFDRCxJQUFJLGlCQUFXLENBQUN1RCxLQUFLLDBDQUFFQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsRUFBRTswQkFDekRDLE9BQU8sR0FBR2pDLGtCQUFLLENBQUNrQyxZQUFZLENBQUNQLFdBQVcsRUFDcEM7NEJBQ0lOLGtCQUFrQixFQUFsQkE7MkJBQ0gsQ0FDSjt5QkFDSixNQUFNOzBCQUNIWSxPQUFPLEdBQUdOLFdBQVc7O3dCQUN4Qjt3QkFFMkIsT0FBTXBELFlBQVksQ0FBQzRELFlBQVksQ0FBQ0YsT0FBTyxFQUFFeEUsS0FBSyxFQUFFRCxPQUFNLEVBQUU2RCxrQkFBa0IsQ0FBQztzQkFBQTt3QkFBdkcvQixpQkFBaUIsQ0FBQ2xCLE9BQU87d0JBRXpCNkMsYUFBYSxDQUFDN0MsT0FBTyxHQUFHa0IsaUJBQWlCLENBQUNsQixPQUFPLENBQUNrRCxVQUFVO3dCQUM1REMsa0JBQWtCLENBQ2ROLGFBQWEsQ0FBQzdDLE9BQU8sQ0FBQ29ELE9BQU8sRUFBRXBFLE9BQU0sRUFBRUwsWUFBVyxFQUFFRSxVQUFTLEVBQUVELFdBQVUsQ0FBQzt3QkFFOUVxQyxZQUFZLENBQUNqQixPQUFPLElBQUljLGFBQWEsQ0FBQyxXQUFXLENBQUM7d0JBQUE7d0JBQUE7c0JBQUE7d0JBRTdDO3dCQUVMLElBQUl5QyxXQUFXLEtBQUssSUFBSSxFQUFFOzBCQUV0QjswQkFDQWpELHFCQUFxQixJQUNqQkEscUJBQXFCLENBQ2pCakIsS0FBSyxFQUFFRCxPQUFNLEVBQUVvRSxXQUFXLEVBQUUsV0FBVyxFQUNuQyxJQUFJQyxLQUFLLENBQUM5QyxzQkFBc0IsQ0FBQ1gsT0FBTyxRQUFLLENBQUMsQ0FDckQ7MEJBQ0xLLHNCQUFzQixDQUFDaEIsS0FBSyxDQUFDO3lCQUVoQyxNQUFNOzBCQUFFOzBCQUVMOzBCQUNBaUMsUUFBUSxDQUFDdEIsT0FBTyxHQUFHK0IsS0FBSzswQkFDeEI7MEJBQ0F6QixxQkFBcUIsSUFDakJBLHFCQUFxQixDQUNqQmpCLEtBQUssRUFBRUQsT0FBTSxFQUFFb0UsV0FBVyxFQUFFLFdBQVcsRUFBRXpCLEtBQUssQ0FDakQ7MEJBRUxkLFlBQVksQ0FBQ2pCLE9BQU8sSUFBSWMsYUFBYSxDQUFDLE9BQU8sQ0FBQzs7c0JBQ2pEO3NCQUFBO3dCQUFBO29CQUFBO2tCQUFBO2dCQUFBO2NBQUEsQ0FNWjtZQUFBLEdBQUM7Y0FBQ2tELE9BQU8sRUFBQ3pEO1lBQW9CLENBQUMsQ0FBQzs7VUFJckM7O01BR0osS0FBSyxXQUFXO01BQ2hCLEtBQUssV0FBVztRQUFFO1VBRWRPLGFBQWEsQ0FBQyxPQUFPLENBQUM7VUFFdEI7O0lBRUg7RUFJVCxDQUFDLEVBQUUsQ0FBQ0QsVUFBVSxDQUFDLENBQUM7RUFFaEI7RUFDQSxPQUFPZTtJQUVIcUMsR0FBRyxFQUFLakQsUUFBUTtJQUFBLGFBQ0osV0FBVztJQUFBLG1CQUNIekIsVUFBVTtJQUFBLGNBQ2ZGLEtBQUs7SUFBQSxtQkFDQUMsVUFBVTtJQUM5QjRFLEtBQUssRUFBS3pELFNBQVMsQ0FBQ1Q7RUFBTyxHQUl6QmEsVUFBVSxJQUFJLE9BQU8sR0FDbEJlO0lBQUEsYUFBaUIsZUFBZTtJQUFDc0MsS0FBSyxFQUFJeEQsZUFBZSxDQUFDVjtFQUFPLEdBQzNEYSxVQUFVLElBQUksT0FBTyxHQUN4Qk0sY0FBYyxDQUFDbkIsT0FBTyxHQUN0QjRCLGlDQUFDdUMsZ0NBQVM7SUFBQ2xDLEdBQUcsRUFBRyxRQUFRO0lBQUNtQyxJQUFJLEVBQUt2QixhQUFhLENBQUM3QztFQUFPLEVBQUksQ0FDMUQsR0FBRTRCLDZDQUFXLEVBQ3JCcEMsYUFBYSxHQUNYZ0IsMEJBQTBCLENBQUNSLE9BQU8sR0FDbEMsSUFBSSxDQUdOO0FBRVYsQ0FBQyxFQUFDO0FBQ0Y7QUFDQXFFLGtCQUFBQSxHQUFlM0YsU0FBUztBQUV4QjtBQUNBLElBQU1nRSxjQUFjLEdBQ2hCLFNBREVBLGNBQWMsQ0FDZi9ELFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUVzRixNQUFNLEVBQUk7RUFFcEYsSUFBTUMsUUFBUSxtQ0FBT0QsTUFBTTtJQUFDRSxRQUFRLEVBQUMsVUFBVTtJQUFFQyxRQUFRLEVBQUM7RUFBUyxFQUFDO0VBRXBFLElBQUk5RixXQUFXLEtBQUssVUFBVSxFQUFFO0lBRTVCNEYsUUFBUSxDQUFDRyxLQUFLLEdBQUcsSUFBSTtJQUNyQixJQUFJMUYsTUFBTSxJQUFJLFNBQVMsRUFBRTtNQUVyQnVGLFFBQVEsQ0FBQ0ksTUFBTSxHQUFHL0YsVUFBVSxHQUFHLElBQUk7TUFDbkMyRixRQUFRLENBQUNLLFNBQVMsR0FBRyxJQUFJO01BQ3pCTCxRQUFRLENBQUNNLFNBQVMsR0FBRyxJQUFJO0tBRTVCLE1BQU07TUFBRTtNQUVMTixRQUFRLENBQUNJLE1BQU0sR0FBRyxJQUFJO01BQ3RCSixRQUFRLENBQUNLLFNBQVMsR0FBRzlGLGFBQWEsR0FBRyxJQUFJO01BQ3pDeUYsUUFBUSxDQUFDTSxTQUFTLEdBQUdqRyxVQUFVLEdBQUcsSUFBSTs7R0FJN0MsTUFBTTtJQUFFO0lBRUwyRixRQUFRLENBQUNJLE1BQU0sR0FBRyxJQUFJO0lBQ3RCLElBQUkzRixNQUFNLElBQUksU0FBUyxFQUFFO01BRXJCdUYsUUFBUSxDQUFDRyxLQUFLLEdBQUc3RixTQUFTLEdBQUcsSUFBSTtNQUNqQzBGLFFBQVEsQ0FBQ08sUUFBUSxHQUFHLElBQUk7TUFDeEJQLFFBQVEsQ0FBQ1EsUUFBUSxHQUFHLElBQUk7S0FFM0IsTUFBTTtNQUFFO01BRUxSLFFBQVEsQ0FBQ0csS0FBSyxHQUFHLElBQUk7TUFDckJILFFBQVEsQ0FBQ08sUUFBUSxHQUFHL0YsWUFBWSxHQUFHLElBQUk7TUFDdkN3RixRQUFRLENBQUNRLFFBQVEsR0FBR2xHLFNBQVMsR0FBRyxJQUFJOzs7RUFNNUMsT0FBTzBGLFFBQVE7QUFFbkIsQ0FBQztBQUVELElBQU0zQixzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXNCLENBQUk1RCxNQUFNLEVBQUNMLFdBQVcsRUFBQ0ksWUFBWSxFQUFFRCxhQUFhLEVBQUs7RUFDL0UsSUFBSXdGLE1BQU0sR0FBdUIsRUFBRTtFQUNuQyxJQUFJdEYsTUFBTSxJQUFJLFNBQVMsRUFBRTtJQUNyQnNGLE1BQU0sR0FBRztNQUNMVSxLQUFLLEVBQUMsS0FBSztNQUNYUixRQUFRLEVBQUMsVUFBVTtNQUNuQkcsTUFBTSxFQUFDLElBQUk7TUFDWEQsS0FBSyxFQUFDLElBQUk7TUFDVkksUUFBUSxFQUFDLElBQUk7TUFDYkYsU0FBUyxFQUFDO0tBQ2I7R0FDSixNQUFNO0lBQUU7SUFDTE4sTUFBTSxDQUFDVSxLQUFLLEdBQUcsSUFBSTtJQUNuQlYsTUFBTSxDQUFDRSxRQUFRLEdBQUcsSUFBSTtJQUN0QixJQUFJN0YsV0FBVyxJQUFJLFVBQVUsRUFBRTtNQUMzQjJGLE1BQU0sQ0FBQ0ksS0FBSyxHQUFHLE1BQU07TUFDckJKLE1BQU0sQ0FBQ0ssTUFBTSxHQUFHLElBQUk7TUFDcEJMLE1BQU0sQ0FBQ1EsUUFBUSxHQUFHLElBQUk7TUFDdEJSLE1BQU0sQ0FBQ00sU0FBUyxHQUFHOUYsYUFBYSxHQUFHLElBQUk7S0FDMUMsTUFBTTtNQUNId0YsTUFBTSxDQUFDSSxLQUFLLEdBQUcsSUFBSTtNQUNuQkosTUFBTSxDQUFDSyxNQUFNLEdBQUcsTUFBTTtNQUN0QkwsTUFBTSxDQUFDUSxRQUFRLEdBQUcvRixZQUFZLEdBQUcsSUFBSTtNQUNyQ3VGLE1BQU0sQ0FBQ00sU0FBUyxHQUFHLElBQUk7OztFQUcvQixPQUFPTixNQUFNO0FBQ2pCLENBQUM7QUFFRDtBQUNBLElBQU1uQixrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQWtCLENBQUk4QixTQUFTLEVBQUVqRyxNQUFNLEVBQUVMLFdBQVcsRUFBRUUsU0FBUyxFQUFFRCxVQUFVLEVBQUk7RUFFakZxRyxTQUFTLENBQUNmLEtBQUssQ0FBQ08sUUFBUSxHQUFHLFFBQVE7RUFFbkMsSUFBSXpGLE1BQU0sSUFBSSxTQUFTLEVBQUU7SUFFckJpRyxTQUFTLENBQUNmLEtBQUssQ0FBQ2MsS0FBSyxHQUFHLEtBQUs7SUFDN0JDLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDTSxRQUFRLEdBQUcsVUFBVTtJQUNyQ1MsU0FBUyxDQUFDZixLQUFLLENBQUNhLFFBQVEsR0FBRyxJQUFJO0lBQy9CRSxTQUFTLENBQUNmLEtBQUssQ0FBQ1csU0FBUyxHQUFHLElBQUk7SUFDaENJLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDUyxNQUFNLEdBQUcsSUFBSTtJQUM3Qk0sU0FBUyxDQUFDZixLQUFLLENBQUNRLEtBQUssR0FBRyxJQUFJO0dBRS9CLE1BQU07SUFBRTtJQUVMTyxTQUFTLENBQUNmLEtBQUssQ0FBQ2MsS0FBSyxHQUFHLElBQUk7SUFDNUJDLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDTSxRQUFRLEdBQUcsSUFBSTtJQUUvQixJQUFJN0YsV0FBVyxJQUFJLFVBQVUsRUFBRTtNQUUzQnNHLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDUSxLQUFLLEdBQUcsTUFBTTtNQUM5Qk8sU0FBUyxDQUFDZixLQUFLLENBQUNTLE1BQU0sR0FBRyxJQUFJO01BQzdCTSxTQUFTLENBQUNmLEtBQUssQ0FBQ2EsUUFBUSxHQUFHLElBQUk7TUFDL0JFLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDVyxTQUFTLEdBQUdqRyxVQUFVLEdBQUcsSUFBSTtLQUVoRCxNQUFNO01BRUhxRyxTQUFTLENBQUNmLEtBQUssQ0FBQ1EsS0FBSyxHQUFHLElBQUk7TUFDNUJPLFNBQVMsQ0FBQ2YsS0FBSyxDQUFDUyxNQUFNLEdBQUcsTUFBTTtNQUMvQk0sU0FBUyxDQUFDZixLQUFLLENBQUNhLFFBQVEsR0FBR2xHLFNBQVMsR0FBRyxJQUFJO01BQzNDb0csU0FBUyxDQUFDZixLQUFLLENBQUNXLFNBQVMsR0FBRyxJQUFJOzs7QUFLNUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvQ2VsbEZyYW1lLnRzeD9mMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbGxGcmFtZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2YgQ2VsbEZyYW1lIGlzIHRvIGZldGNoIHVzZXIgY29udGVudCBmcm9tIHRoZSBjYWNoZSwgb3IgZnJvbSB0aGUgaG9zdCAodXNpbmcgZ2V0SXRlbSkuXG4gICAgV2hpbGUgYW4gaXRlbSBpcyBiZWluZyBmZXRjaGVkLCBDZWxsRnJhbWUgcHJlc2VudHMgYSBwbGFjZWhvbGRlciAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGFuIFxuICAgIGltcG9ydGVkIGN1c3RvbSB2ZXJzaW9uKS4gSWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gZmV0Y2hpbmcgY29udGVudCB0aGVuIHRoZSBwbGFjZWhvbGRlciBpcyB1c2VkXG4gICAgdG8gcHJlc2VudCB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuIElmIGEgbmV3IGl0ZW1JRCBpcyBzZXQgYnkgdGhlIHBhcmVudCAodG8gc3luY2hyb25pemUgd2l0aCBhbiBhbHRlcmVkXG4gICAgY2FjaGUpLCB0aGVuIENlbGxGcmFtZSByZXBsYWNlcyB0aGUgb2xkIGl0ZW0gd2l0aCB0aGUgbmV3IGl0ZW0uXG5cbiAgICBnZXRJdGVtICh3aGljaCBpcyBhIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBob3N0KSBjYW4gcmV0dXJuIG9uZSBvZiBzZXZlcmFsIHZhbHVlczpcbiAgICAgICAgLSBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgICAtIGEgcHJvbWlzZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICAtIG51bGxcbiAgICAgICAgLSB1bmRlZmluZWRcbiAgICBBbnl0aGluZyBlbHNlIGlzIHRyZWF0ZWQgYXMgYW4gZXJyb3JcblxuICAgIGlmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCwgdGhlbiB0aGUgcHJvbWlzZSByZXR1cm5zIGEgUmVhY3QgY29tcG9uZW50LCBudWxsIG9yIHVuZGVmaW5lZC5cblxuICAgIElmIGEgdmFsaWQgcmVhY3QgY29tcG9uZW50IGlzIHJldHVybmVkIGZyb20gZ2V0SXRlbSwgdGhlbiBpdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlIGNhY2hlLCBhbmQgcmVuZGVyZWQgaW4gdGhlXG4gICAgQ2VsbEZyYW1lLiBJZiBudWxsIGlzIHJldHVybmVkLCB0aGVuIENlbGxGcmFtZSBzZW5kcyBhIG1lc3NhZ2UgdG8gaXRzIHNjcm9sbGVyIHRoYXQgdGhlIGhvc3QgaGFzIFxuICAgIGluZGljYXRlZCB0aGUgdGhlIGl0ZW0gYmVpbmcgZmV0Y2hlZCBpbnN0ZWFkIHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGUgbGlzdCwgYW5kIHRoZSBsaXN0c2l6ZSBzaG91bGRcbiAgICBiZSBhZGp1c3RlZCBhY2NvcmRpbmdseS4gQW55IG90aGVyIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvciwgYW5kIHByZXNlbnRlZFxuICAgIGFzIHN1Y2ggdG8gdGhlIHVzZXIgdGhyb3VnaCB0aGUgcGxhY2Vob2xkZXIgY29tcG9uZW50LlxuXG4gICAgZ2V0SXRlbSBzZW5kcyB0aGUgaW5kZXggKGxvZ2ljYWwgaW5kZXggaW4gdGhlIGxpc3QpIGFuZCBhIHNlc3Npb24gaXRlbUlEIHRvIHRoZSBob3N0LCBzbyB0aGF0XG4gICAgdGhlIGhvc3QgY2FuIHN5bmMgaXRzIG93biB0cmFja2luZyB3aXRoIHRoZSBzY3JvbGxlci5cblxuICAgIE9uZSBDZWxsRnJhbWUgYXQgYSB0aW1lIGlzIGRlc2lnbmF0ZWQgYXMgdGhlIGhvc3Qgb2YgdGhlIHR3byB0cmlnZ2VyTGluZXMgd2l0aCB0aGUgaXNUcmlnZ2VyQ2VsbCBmbGFnLiBcbiAgICBUaGUgdHJpZ2dlcmxpbmVzIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBDcmFkbGUgdGhyb3VnaCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlci5cbiovXG5cbmltcG9ydCBSZWFjdCwge1xuICAgIHVzZVJlZiwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDb250ZXh0IFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHtyZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2t9IGZyb20gJ3JlcXVlc3RpZGxlY2FsbGJhY2snIC8vIHBvbHlmaWxsIGlmIG5lZWRlZFxuXG5pbXBvcnQgeyBPdXRQb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCcgLy8gZmV0Y2ggZnJvbSBjYWNoZVxuXG5pbXBvcnQgUGxhY2Vob2xkZXIgZnJvbSAnLi9jZWxsZnJhbWUvUGxhY2Vob2xkZXInIC8vIGRlZmF1bHRcblxuaW1wb3J0IHsgQ3JhZGxlQ29udGV4dCB9IGZyb20gJy4vQ3JhZGxlJ1xuXG5jb25zdCBkZWZhdWx0UGxhY2Vob2xkZXJNZXNzYWdlcyA9IHtcbiAgICBsb2FkaW5nOicobG9hZGluZy4uLiknLFxuICAgIHJldHJpZXZpbmc6JyhyZXRyaWV2aW5nIGZyb20gY2FjaGUpJyxcbiAgICBudWxsOidlbmQgb2YgbGlzdCcsXG4gICAgdW5kZWZpbmVkOidob3N0IHJldHVybmVkIFwidW5kZWZpbmVkXCInLFxuICAgIGludmFsaWQ6J2ludmFsaWQgUmVhY3QgZWxlbWVudCcsXG59XG5cbmNvbnN0IENlbGxGcmFtZSA9ICh7XG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgY2VsbE1pbkhlaWdodCxcbiAgICBjZWxsTWluV2lkdGgsXG4gICAgbGF5b3V0LFxuICAgIGdldEl0ZW0sIC8vIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGhvc3RcbiAgICBsaXN0c2l6ZSwgLy8gZm9yIGZlZWRiYWNrIGluIHBsYWNlaG9sZGVyXG4gICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsbHkgcHJvdmlkZWQgYnkgaG9zdFxuICAgIGl0ZW1JRCwgLy8gc2Vzc2lvbiBpdGVtSURcbiAgICBpbmRleCwgLy8gbG9naWNhbCBpbmRleCBpbiBpbmZpbml0ZSBsaXN0XG4gICAgaW5zdGFuY2VJRCwgLy8gQ2VsbEZyYW1lIHNlc3Npb24gSURcbiAgICBzY3JvbGxlcklELCAvLyBzY3JvbGxlciBJRCAoZm9yIGRlYnVnZ2luZylcbiAgICBpc1RyaWdnZXJjZWxsLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgdXNlUGxhY2Vob2xkZXIsXG59KSA9PiB7XG5cbiAgICBjb25zdCBjb3JlQ29uZmlnUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29yZUNvbmZpZ1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxIZWlnaHRcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGV4dCA9IHVzZUNvbnRleHQoQ3JhZGxlQ29udGV4dClcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZiwgLy8gZm9yIHRoZSB1c2VyIGNvbnRlbnQsIGlmIHJlcXVlc3RlZFxuICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplLCAvLyBmb3IgaW50ZXJuYWwgbm90aWZpY2F0aW9uIG9mIGVuZC1vZi1saXN0XG4gICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjaywgLy8gZm9yIG5vdGlmaWNhdGlvbiB0byBob3N0IG9mIGVycm9yXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULCAvLyB0byBvcHRpbWl6ZSByZXF1ZXN0SWRsZUNhbGxiYWNrXG4gICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLFxuICAgIH0gPSBjcmFkbGVDb250ZXh0XG4gICAgXG4gICAgLy8gc3R5bGUgY2hhbmdlIGdlbmVyYXRlcyBzdGF0ZSByZWZyZXNoXG4gICAgY29uc3Qgc3R5bGVzUmVmID0gdXNlUmVmKHt9KVxuICAgIGNvbnN0IGhvbGRlclN0eWxlc1JlZiA9IHVzZVJlZih7fSlcblxuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYgPSB1c2VSZWYobnVsbClcblxuICAgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbmV3TWVzc2FnZXMgPSB7Li4uZGVmYXVsdFBsYWNlaG9sZGVyTWVzc2FnZXMsLi4ucGxhY2Vob2xkZXJNZXNzYWdlc31cblxuICAgICAgICByZXR1cm4gbmV3TWVzc2FnZXNcblxuICAgIH0sW3BsYWNlaG9sZGVyTWVzc2FnZXNdKVxuXG4gICAgLy8gcHJvY2Vzc2luZyBzdGF0ZVxuICAgIGNvbnN0IFtmcmFtZVN0YXRlLCBzZXRGcmFtZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgZnJhbWVTdGF0ZVJlZiA9IHVzZVJlZihudWxsKVxuICAgIGZyYW1lU3RhdGVSZWYuY3VycmVudCA9IGZyYW1lU3RhdGVcblxuICAgIC8vIERPTSByZWZcbiAgICBjb25zdCBmcmFtZVJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHRvIHRyYWNrIHVubW91bnQgaW50ZXJydXB0XG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG4gICAgLy8gY2FjaGUgZGF0YVxuICAgIGNvbnN0IHBvcnRhbE1ldGFkYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdGhlIHBsYWNlaG9sZGVyIHRvIHVzZVxuICAgIGNvbnN0IHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdGhlIHNlc3Npb24gaXRlbUlEIHRvIHVzZTsgY291bGQgYmUgdXBkYXRlZCBieSBwYXJlbnRcbiAgICBjb25zdCBpdGVtSURSZWYgPSB1c2VSZWYobnVsbClcbiAgICBpdGVtSURSZWYuY3VycmVudCA9IGl0ZW1JRFxuICAgIGNvbnN0IGNlbGxGcmFtZURhdGFSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjZWxsRnJhbWVEYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGl0ZW1JRCxcbiAgICAgICAgaW5kZXhcbiAgICB9XG4gICAgLy8gZmV0Y2ggZXJyb3JcbiAgICBjb25zdCBlcnJvclJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICAvLyBwbGFjZWhvbGRlciBtZXNzYWdlXG4gICAgY29uc3QgbWVzc2FnZVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyBmb3IgdW5tb3VudFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNhbmNlbGlkbGVjYWxsYmFjayhyZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudClcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gcmVmcmVzaCBjb250ZW50IGlmIGl0ZW1JRCBjaGFuZ2VzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpXG5cbiAgICB9LFtpdGVtSURdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gWyBwbGFjZWhvbGRlciBkZWZpbml0aW9uIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3VzdG9tcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBpZiAoIXVzZVBsYWNlaG9sZGVyKSByZXR1cm4gbnVsbCAgICAgICAgXG5cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChwbGFjZWhvbGRlciwgXG4gICAgICAgICAgICAgICAge2luZGV4LCBsaXN0c2l6ZSwgbWVzc2FnZTptZXNzYWdlUmVmLmN1cnJlbnQsIGVycm9yOmVycm9yUmVmLmN1cnJlbnR9KTpcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIFxuICAgIH0sW1xuICAgICAgICBpbmRleCwgXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCwgXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQsIFxuICAgICAgICB1c2VQbGFjZWhvbGRlclxuICAgIF0pXG5cbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGlmICghdXNlUGxhY2Vob2xkZXIpIHJldHVybiBudWxsXG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBcbiAgICAgICAgICAgIGN1c3RvbXBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgICAgIGN1c3RvbXBsYWNlaG9sZGVyOlxuICAgICAgICAgICAgICAgIDxQbGFjZWhvbGRlciBcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJ3BsYWNlaG9sZGVyJ1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH0gXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7IG1lc3NhZ2VSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0geyBlcnJvclJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckZyYW1lU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckxpbmVyU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckVycm9yRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJFcnJvckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMgfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyXG5cbiAgICB9LCBbXG4gICAgICAgIGluZGV4LCBcbiAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXIsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCwgXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQsXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBbIHJlcXVlc3RpZGxlY2FsbGJhY2sgY29uZmlnIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCByZXF1ZXN0aWRsZWNhbGxiYWNrID0gLy8gcmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAgICB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXT9cbiAgICAgICAgICAgIHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFja1xuXG4gICAgY29uc3QgY2FuY2VsaWRsZWNhbGxiYWNrID0gLy8gY2FuY2VsSWRsZUNhbGxiYWNrXG4gICAgICAgIHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ10/XG4gICAgICAgICAgICB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgICBjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gc2V0IHN0eWxlc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IG5ld1N0eWxlcyA9IGdldEZyYW1lU3R5bGVzKFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLCBsYXlvdXQsIHN0eWxlc1JlZi5jdXJyZW50KVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3SG9sZGVyU3R5bGVzID0gZ2V0Q29udGVudEhvbGRlclN0eWxlcyhsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsTWluV2lkdGgsIGNlbGxNaW5IZWlnaHQpXG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHN0eWxlc1JlZi5jdXJyZW50ID0gbmV3U3R5bGVzXG4gICAgICAgICAgICBob2xkZXJTdHlsZXNSZWYuY3VycmVudCA9IG5ld0hvbGRlclN0eWxlc1xuXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0XSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoZnJhbWVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3dvcmtpbmcnKSAvLyAnZ2V0dXNlcmNvbnRlbnQnIHdpbGwgYmUgY2FsbGVkXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dvcmtpbmcnOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpIC8vIGRlbGF5IHBhaW50IHdoaWxlIHdvcmtpbmdcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldHVzZXJjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaXRlbUlEUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZUhhbmRsZXIuaGFzUG9ydGFsKGl0ZW1JRClcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9ID0gY29yZUNvbmZpZ1JlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50LnJldHJpZXZpbmdcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBjYWNoZUhhbmRsZXIuZ2V0UG9ydGFsTWV0YWRhdGEoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IE91dFBvcnRhbCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LnNjcm9sbGVyUHJvcGVydGllcy5jZWxsRnJhbWVEYXRhUmVmID0gY2VsbEZyYW1lRGF0YVJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250YWluZXJTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50LmVsZW1lbnQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodClcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmV0cmlldmVkJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5sb2FkaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0RnJhbWVTdGF0ZSgnZmV0Y2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2VydmUgc3BhY2UgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZWdpc3RlclJlcXVlc3RlZFBvcnRhbChpbmRleClcblxuICAgICAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soYXN5bmMgKCk9PntcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbHVlLCB1c2VyY29udGVudCwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50LnVuZGVmaW5lZClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IFJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5pbnZhbGlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXJjb250ZW50IGlzIG90aGVyd2lzZSBkaXNhbGxvd2VkLCBsZXQgZXJyb3IgaGFuZGxpbmcgZGVhbCB3aXRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZyYW1lRGF0YVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQucHJvcHM/Lmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudCh1c2VyY29udGVudCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50ID0gYXdhaXQgY2FjaGVIYW5kbGVyLmNyZWF0ZVBvcnRhbChjb250ZW50LCBpbmRleCwgaXRlbUlELCBzY3JvbGxlclByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRhaW5lclN0eWxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudC5lbGVtZW50LCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0RnJhbWVTdGF0ZSgnaW5zZXJ0aW5nJylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG51bGwgb3IgdW5kZWZpbmVkOyBoYW5kbGUgbm9uLWNvbXBvbmVudCB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSBsaXN0c2l6ZSBhdCB0aGlzIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5udWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IHVuZGVmaW5lZCwgbWVhbmluZyBhbiBlcnJvciBoYXMgb2NjdXJyZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHBsYWNlaG9sZGVyIG1lc3NhZ2UgdG8gZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RpZnkgdGhlIGhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAnY2VsbEZyYW1lJywgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldEZyYW1lU3RhdGUoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSx7dGltZW91dDpJRExFQ0FMTEJBQ0tfVElNRU9VVH0pXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdpbnNlcnRpbmcnOlxuICAgICAgICAgICAgY2FzZSAncmV0cmlldmVkJzoge1xuXG4gICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sIFtmcmFtZVN0YXRlXSlcblxuICAgIC8vIE5vdGU6IHRoZSBjb250ZW50aG9sZGVyIHR5cGUgbGF5ZXIgaXMgaW5jbHVkZWQgdG8gcHJvdmlkZSBhbiBhbmNob3IgZm9yIHRoZSB0cmlnZ2VybGluZXMuXG4gICAgcmV0dXJuIDxkaXYgXG5cbiAgICAgICAgcmVmID0geyBmcmFtZVJlZiB9IFxuICAgICAgICBkYXRhLXR5cGUgPSAnY2VsbGZyYW1lJyBcbiAgICAgICAgZGF0YS1zY3JvbGxlcmlkID0geyBzY3JvbGxlcklEIH0gXG4gICAgICAgIGRhdGEtaW5kZXggPSB7IGluZGV4IH0gXG4gICAgICAgIGRhdGEtaW5zdGFuY2VpZCA9IHsgaW5zdGFuY2VJRCB9IFxuICAgICAgICBzdHlsZSA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuXG4gICAgPlxuXG4gICAgICAgIHsoZnJhbWVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICg8ZGl2IGRhdGEtdHlwZSA9ICdjb250ZW50aG9sZGVyJyBzdHlsZSA9IHtob2xkZXJTdHlsZXNSZWYuY3VycmVudH0+IFxuICAgICAgICAgICAgICAgIHsoKGZyYW1lU3RhdGUgIT0gJ3JlYWR5Jyk/XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudDpcbiAgICAgICAgICAgICAgICA8T3V0UG9ydGFsIGtleSA9ICdwb3J0YWwnIG5vZGUgPSB7IHBvcnRhbE5vZGVSZWYuY3VycmVudCB9Lz4pfVxuICAgICAgICAgICAgPC9kaXY+KTo8ZGl2PjwvZGl2Pn1cbiAgICAgICAgeyhpc1RyaWdnZXJjZWxsP1xuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYuY3VycmVudDpcbiAgICAgICAgICAgIG51bGwpXG4gICAgICAgIH1cblxuICAgIDwvZGl2PlxuXG59IC8vIENlbGxGcmFtZVxuLy8oZnJhbWVTdGF0ZSAhPSAnc2V0dXAnKSAmJiBcbmV4cG9ydCBkZWZhdWx0IENlbGxGcmFtZVxuXG4vLyB1dGlsaXRpZXNcbmNvbnN0IGdldEZyYW1lU3R5bGVzID0gXG4gICAgKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0LCBzdHlsZXMpID0+IHtcblxuICAgIGNvbnN0IHN0eWxlc2V0ID0gey4uLnN0eWxlcyxwb3NpdGlvbjoncmVsYXRpdmUnLCBvdmVyZmxvdzondmlzaWJsZSd9XG5cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBzdHlsZXNldC53aWR0aCA9IG51bGxcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbkhlaWdodCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heEhlaWdodCA9IG51bGxcblxuICAgICAgICB9IGVsc2UgeyAvLyAndmFyaWFibGUnXG5cbiAgICAgICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhIZWlnaHQgPSBjZWxsSGVpZ2h0ICsgJ3B4J1xuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gbnVsbFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBzdHlsZXNldC53aWR0aCA9IGNlbGxXaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbldpZHRoID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzZXQubWF4V2lkdGggPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBzdHlsZXNldC53aWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbldpZHRoID0gY2VsbE1pbldpZHRoICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWF4V2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2V0XG5cbn1cblxuY29uc3QgZ2V0Q29udGVudEhvbGRlclN0eWxlcyA9IChsYXlvdXQsb3JpZW50YXRpb24sY2VsbE1pbldpZHRoLCBjZWxsTWluSGVpZ2h0ICkgPT4ge1xuICAgIGxldCBzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IHt9XG4gICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICAgICAgc3R5bGVzID0ge1xuICAgICAgICAgICAgaW5zZXQ6JzBweCcsXG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgaGVpZ2h0Om51bGwsXG4gICAgICAgICAgICB3aWR0aDpudWxsLFxuICAgICAgICAgICAgbWluV2lkdGg6bnVsbCxcbiAgICAgICAgICAgIG1pbkhlaWdodDpudWxsLFxuICAgICAgICB9XG4gICAgfSBlbHNlIHsgLy8gdmFyaWFibGVcbiAgICAgICAgc3R5bGVzLmluc2V0ID0gbnVsbFxuICAgICAgICBzdHlsZXMucG9zaXRpb24gPSBudWxsXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIHN0eWxlcy5oZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXMubWluV2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXMubWluSGVpZ2h0ID0gY2VsbE1pbkhlaWdodCArICdweCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy53aWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHN0eWxlcy5taW5XaWR0aCA9IGNlbGxNaW5XaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlcy5taW5IZWlnaHQgPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlc1xufVxuXG4vLyBzZWUgYWxzbyBzb21lIGJhc2Ugc3R5bGVzIHNldCBpbiBjYWNoZWhhbmRsZXJcbmNvbnN0IHNldENvbnRhaW5lclN0eWxlcyA9IChjb250YWluZXIsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCkgPT4ge1xuXG4gICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbidcblxuICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmluc2V0ID0gJzBweCcgXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gbnVsbFxuICAgICAgICBjb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gbnVsbFxuICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbnVsbFxuICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBudWxsXG5cbiAgICB9IGVsc2UgeyAvLyB2YXJpYWJsZVxuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5pbnNldCA9IG51bGwgXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IG51bGxcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4V2lkdGggPSBudWxsXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBudWxsXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4V2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gbnVsbFxuXG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbImRlZmF1bHRQbGFjZWhvbGRlck1lc3NhZ2VzIiwibG9hZGluZyIsInJldHJpZXZpbmciLCJ1bmRlZmluZWQiLCJpbnZhbGlkIiwiQ2VsbEZyYW1lIiwib3JpZW50YXRpb24iLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImxheW91dCIsImdldEl0ZW0iLCJsaXN0c2l6ZSIsInBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiaW5kZXgiLCJpbnN0YW5jZUlEIiwic2Nyb2xsZXJJRCIsImlzVHJpZ2dlcmNlbGwiLCJwbGFjZWhvbGRlckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJMaW5lclN0eWxlcyIsInBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyIsInBsYWNlaG9sZGVyTWVzc2FnZXMiLCJ1c2VQbGFjZWhvbGRlciIsImNvcmVDb25maWdSZWYiLCJjdXJyZW50IiwiY3JhZGxlQ29udGV4dCIsIkNyYWRsZV8xIiwiY2FjaGVIYW5kbGVyIiwic2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsIml0ZW1FeGNlcHRpb25DYWxsYmFjayIsIklETEVDQUxMQkFDS19USU1FT1VUIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYiLCJzdHlsZXNSZWYiLCJob2xkZXJTdHlsZXNSZWYiLCJwbGFjZWhvbGRlck1lc3NhZ2VzUmVmIiwibmV3TWVzc2FnZXMiLCJmcmFtZVN0YXRlIiwic2V0RnJhbWVTdGF0ZSIsImZyYW1lU3RhdGVSZWYiLCJmcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInBvcnRhbE1ldGFkYXRhUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJpdGVtSURSZWYiLCJjZWxsRnJhbWVEYXRhUmVmIiwiZXJyb3JSZWYiLCJtZXNzYWdlUmVmIiwiY2FuY2VsaWRsZWNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFja0lkUmVmIiwicmVtb3ZlUmVxdWVzdGVkUG9ydGFsIiwiY3VzdG9tcGxhY2Vob2xkZXIiLCJyZWFjdF8xIiwiY3JlYXRlRWxlbWVudCIsIm1lc3NhZ2UiLCJlcnJvciIsIlBsYWNlaG9sZGVyXzEiLCJrZXkiLCJ1c2VyRnJhbWVTdHlsZXMiLCJ1c2VyTGluZXJTdHlsZXMiLCJ1c2VyRXJyb3JGcmFtZVN0eWxlcyIsInVzZXJFcnJvckxpbmVyU3R5bGVzIiwicmVxdWVzdGlkbGVjYWxsYmFjayIsIndpbmRvdyIsInJlcXVlc3RpZGxlY2FsbGJhY2tfMSIsIm5ld1N0eWxlcyIsImdldEZyYW1lU3R5bGVzIiwibmV3SG9sZGVyU3R5bGVzIiwiZ2V0Q29udGVudEhvbGRlclN0eWxlcyIsInBvcnRhbE5vZGVSZWYiLCJjYWNoZWQiLCJoYXNQb3J0YWwiLCJnZXRQb3J0YWxNZXRhZGF0YSIsInNjcm9sbGVyUHJvcGVydGllcyIsInBvcnRhbE5vZGUiLCJzZXRDb250YWluZXJTdHlsZXMiLCJlbGVtZW50IiwicmVnaXN0ZXJSZXF1ZXN0ZWRQb3J0YWwiLCJfX2F3YWl0ZXIiLCJ1c2VyY29udGVudCIsInJldHVybnZhbHVlIiwiRXJyb3IiLCJpc1ZhbGlkRWxlbWVudCIsInByb3BzIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlUG9ydGFsIiwidGltZW91dCIsInJlZiIsInN0eWxlIiwicmVhY3RfcmV2ZXJzZV9wb3J0YWxfMSIsIm5vZGUiLCJleHBvcnRzIiwic3R5bGVzIiwic3R5bGVzZXQiLCJwb3NpdGlvbiIsIm92ZXJmbG93Iiwid2lkdGgiLCJoZWlnaHQiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiaW5zZXQiLCJjb250YWluZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// Cradle.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers (class instances), and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the ~30 state changes of the system.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be vertical or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'headwards' (up or left) in the Cradle, and\n    below which the cradle content expands 'tailwards' (doen or right). The Cradle content is held in\n    two CSS grids (children of the axis): one above or left (the 'head' grid), and one below or right,\n    of the position of the axis (the 'tail' grid).\n\n    The axis is kept near the leading (headward) edge of the visible cell rows of the Viewport\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is usually\n            the first item in the head section of the Cradle, unless the cradle shows the very top of the\n            list, in which case the cradleReferenceIndex is the same as the AxisReferenceIndex)\n        - axisViewportPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll (Viewport scrollTop or scrollLeft) of the\n            ScrollBlock\n    \n    Overscroll handling (repositioning):\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle (including its two content grids) has entirely passed\n        out of the viewport, then the Cradle component is replaced by a ScrollTracker (or by null if\n        the host takes responsibility for feedback). The ScrollTracker displays to the user the relative\n        location in the virtual list at the edge of the viewport during repositioning. When the scrolling\n        stops Cradle recreates the cradle content, according to the final position of the repositioning\n        process.\n\n    Cradle changes are activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\");\n// popup position tracker for repositioning\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\"));\n// support code; process handlers\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\"));\n// cacheHandler is imported as a property; instantiated at the root\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ./InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// for children\nexports.CradleContext = react_1[\"default\"].createContext(null);\n// component\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n    runwaySize = _ref.runwaySize,\n    listsize = _ref.listsize,\n    startingIndex = _ref.startingIndex,\n    getItem = _ref.getItem,\n    placeholder = _ref.placeholder,\n    placeholderMessages = _ref.placeholderMessages,\n    userCallbacks = _ref.userCallbacks,\n    styles = _ref.styles,\n    triggerlineOffset = _ref.triggerlineOffset,\n    cache = _ref.cache,\n    cacheMax = _ref.cacheMax,\n    scrollerID = _ref.scrollerID,\n    cacheHandler = _ref.cacheHandler,\n    usePlaceholder = _ref.usePlaceholder,\n    useScrollTracker = _ref.useScrollTracker,\n    showAxis = _ref.showAxis,\n    ONAFTERSCROLL_TIMEOUT = _ref.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _ref.VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerProperties = _ref.scrollerProperties;\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    cellMinHeight = gridSpecs.cellMinHeight,\n    cellMinWidth = gridSpecs.cellMinWidth,\n    layout = gridSpecs.layout;\n  // get viewport context\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n  // flags\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false);\n  // trigger control\n  var triggerHistoryRef = (0, react_1.useRef)({\n    previousReferenceName: null\n  });\n  //  viewport dimensions and cached state\n  var getViewportDimensions = function getViewportDimensions() {\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    return {\n      width: viewportElement.offsetWidth,\n      height: viewportElement.offsetHeight\n    };\n  };\n  // two sources; could use some reconciliation\n  var viewportDimensions = ViewportContextProperties.viewportDimensions; // for scrollTracker\n  var _getViewportDimension = getViewportDimensions(),\n    viewportheight = _getViewportDimension.height,\n    viewportwidth = _getViewportDimension.width; // viewportDimensions\n  // cache test\n  // zero width and height means the component must be in portal (cache) state\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n  // cradle state\n  var _ref2 = (0, react_1.useState)('setup'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    cradleState = _ref3[0],\n    setCradleState = _ref3[1];\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n  cradleStateRef.current = cradleState;\n  // if (!scrollerProperties) {\n  // console.log('==> cradleState','-'+scrollerID+'-', cradleState)\n  // console.log('-- index',~'+scrollerProperties?.cellFrameDataRef.current.index+'~')\n  // }\n  // cradle scaffold element refs\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null);\n  // layout bundle\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  });\n  // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n  var crosscount = (0, react_1.useMemo)(function () {\n    if (isCachedRef.current) return 0;\n    var viewportcrosslength = orientation == 'vertical' ? viewportwidth : viewportheight;\n    // cross length of viewport (gap to match crossLength)\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]);\n  // various row counts\n  var _ref4 = (0, react_1.useMemo)(function () {\n      var viewportLength = orientation == 'vertical' ? viewportheight : viewportwidth;\n      var baseRowLength;\n      if (layout == 'uniform') {\n        if (orientation == 'vertical') {\n          baseRowLength = cellHeight;\n        } else {\n          baseRowLength = cellWidth;\n        }\n      } else {\n        // layout == 'variable'\n        if (orientation == 'vertical') {\n          baseRowLength = cellMinHeight;\n        } else {\n          baseRowLength = cellMinWidth;\n        }\n      }\n      baseRowLength += gap;\n      var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n      var listRowcount = Math.ceil(listsize / crosscount);\n      var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n      var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n      var runwayRowcount;\n      if (calculatedCradleRowcount >= cradleRowcount) {\n        runwayRowcount = runwaySize;\n      } else {\n        var diff = cradleRowcount - calculatedCradleRowcount;\n        runwayRowcount -= Math.floor(diff / 2);\n        runwayRowcount = Math.max(0, runwayRowcount);\n      }\n      var itemcount = cradleRowcount * crosscount;\n      if (itemcount > listsize) {\n        itemcount = listsize;\n        cradleRowcount = Math.ceil(itemcount / crosscount);\n      }\n      return [cradleRowcount, viewportRowcount, listRowcount, runwayRowcount];\n    }, [orientation, gap,\n    // padding,\n    cellWidth, cellHeight, cellMinWidth, cellMinHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount, layout]),\n    _ref5 = _slicedToArray(_ref4, 4),\n    cradleRowcount = _ref5[0],\n    viewportRowcount = _ref5[1],\n    listRowcount = _ref5[2],\n    runwayRowcount = _ref5[3];\n  // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    repositioningIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningIndexCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionCallback\n  });\n  // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessages,\n    usePlaceholder: usePlaceholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    // control values\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    scrollerProperties: scrollerProperties\n  };\n  var scrollerPropertiesRef = (0, react_1.useRef)(null);\n  // passed to cellFrame content (user content) if requested\n  scrollerPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    crosscount: crosscount\n  };\n  // configuration properties to share with handlers\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    triggerHistoryRef: triggerHistoryRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  };\n  // placeholder in cradleParameters to make available individual handlers\n  var handlersRef = (0, react_1.useRef)(null);\n  // cradle parameters MASTER BUNDLE\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters;\n  // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  }\n  // make handlers directly available to cradle code below\n  var _handlersRef$current = handlersRef.current,\n    interruptHandler = _handlersRef$current.interruptHandler,\n    scrollHandler = _handlersRef$current.scrollHandler,\n    contentHandler = _handlersRef$current.contentHandler,\n    layoutHandler = _handlersRef$current.layoutHandler,\n    serviceHandler = _handlersRef$current.serviceHandler,\n    stylesHandler = _handlersRef$current.stylesHandler;\n  // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n  /*\n      Intercept change in caching status:\n      when a component is cached in a portal (in the React virtual DOM), including the transition of\n      being moved from one cellFrame to another when crossing the Cradle axis,\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n  \n      This supports InfiniteGridScroller components to be cached as content.\n  \n      The restore scrollPos action must be the first priority to hide these scrollPos adjustments\n      from the user.\n  */\n  var restoreScrollPos = function restoreScrollPos() {\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var blockScrollPos = cradlePositionData.blockScrollPos;\n    var blockXScrollPos = cradlePositionData.blockXScrollPos;\n    if (blockScrollPos !== null) {\n      var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n      viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n      viewportElement[cradlePositionData.blockXScrollProperty] = blockXScrollPos;\n    }\n  };\n  if (isCacheChange && !isCachedRef.current) {\n    restoreScrollPos();\n  }\n  // change state for entering or leaving cache\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached');\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n      if (hasBeenRenderedRef.current) {\n        setCradleState('rerenderfromcache');\n      } else {\n        setCradleState('firstrenderfromcache');\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]);\n  // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  //send call-in functions to host\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.functionsCallback) return;\n    var scrollToIndex = serviceHandler.scrollToIndex,\n      reload = serviceHandler.reload,\n      setListsize = serviceHandler.setListsize,\n      clearCache = serviceHandler.clearCache,\n      getCacheIndexMap = serviceHandler.getCacheIndexMap,\n      getCacheItemMap = serviceHandler.getCacheItemMap,\n      getCradleIndexMap = serviceHandler.getCradleIndexMap,\n      remapIndexes = serviceHandler.remapIndexes,\n      moveIndex = serviceHandler.moveIndex,\n      insertIndex = serviceHandler.insertIndex,\n      removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToIndex: scrollToIndex,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.functionsCallback(functions);\n  }, []);\n  // initialize window scroll listeners\n  (0, react_1.useEffect)(function () {\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []);\n  // iOS Safari requires special handling - it ignores assignments to scrollLeft/scrollTop during scrolling\n  (0, react_1.useEffect)(function () {\n    var layout = cradleInheritedPropertiesRef.current.layout;\n    if (!(0, InfiniteGridScroller_1.isSafariIOS)() || layout == 'uniform') return;\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.iOSonScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.iOSonScroll);\n    };\n  }, []);\n  // observer support\n  /*\n      There are two interection observers: one for the two cradle grids, and another for triggerlines;\n          both against the viewport.\n  */\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n      triggerlinesIntersect = interruptHandler.triggerlinesIntersect;\n    // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements();\n    // triggerobserver triggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n    var triggerobserver = triggerlinesIntersect.createObserver();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n    };\n  }, []);\n  // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // inernal callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize;\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n        deleteListCallback = _serviceHandler$callb.deleteListCallback,\n        changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n      cacheHandler.changeListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []);\n  // caching change\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n    if (cradleStateRef.current == 'setup') return;\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var _dListCallback;\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]);\n  // trigger viewportresizing response based on viewport state\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    // movement to and from cache is independent of ui viewportresizing\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    }\n    // complete viewportresizing mode\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]);\n  // reconfigure for changed size parameters\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [listsize, cellHeight, cellWidth, gap, padding, triggerlineOffset, layout, runwaySize]);\n  // a new getItem function implies the need to reload\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reload');\n  }, [getItem]);\n  // pivot triggered on change of orientation\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n    layoutHandler.cradlePositionData.blockXScrollProperty = orientation == \"horizontal\" ? \"scrollTop\" : \"scrollLeft\";\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      layoutHandler.cradlePositionData.blockXScrollPos = 0;\n      return;\n    }\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n      layout = _cradleInheritedPrope.layout,\n      gap = _cradleInheritedPrope.gap;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    if (layout == 'uniform') {\n      var _cradleInheritedPrope2 = cradleInheritedPropertiesRef.current,\n        _cellWidth = _cradleInheritedPrope2.cellWidth,\n        _cellHeight = _cradleInheritedPrope2.cellHeight,\n        _gap = _cradleInheritedPrope2.gap;\n      // get previous ratio\n      var previousCellPixelLength = (orientation == 'vertical' ? _cellWidth : _cellHeight) + _gap;\n      var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n      var previousratio = previousAxisOffset / previousCellPixelLength;\n      var pivotCellPixelLength = (orientation == 'vertical' ? _cellHeight : _cellWidth) + _gap;\n      var pivotAxisOffset = previousratio * pivotCellPixelLength;\n      cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    } else {\n      cradlePositionData.targetAxisViewportPixelOffset = gap;\n    }\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]);\n  // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n  var _ref6 = (0, react_1.useMemo)(function () {\n      return stylesHandler.getCradleStyles({\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        cellMinHeight: cellMinHeight,\n        cellMinWidth: cellMinWidth,\n        gap: gap,\n        padding: padding,\n        viewportheight: viewportheight,\n        viewportwidth: viewportwidth,\n        crosscount: crosscount,\n        userstyles: styles,\n        triggerlineOffset: triggerlineOffset,\n        layout: layout\n      });\n    }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset, layout]),\n    _ref7 = _slicedToArray(_ref6, 6),\n    cradleHeadStyle = _ref7[0],\n    cradleTailStyle = _ref7[1],\n    cradleAxisStyle = _ref7[2],\n    cradleDividerStyle = _ref7[3],\n    triggercellTriggerlineHeadStyle = _ref7[4],\n    triggercellTriggerlineTailStyle = _ref7[5];\n  // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (about 30 states), using named states\n  // useLayoutEffect for suppressing flashes\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.renderPortalLists();\n            }\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n          cacheHandler.preload(finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n          break;\n        }\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true;\n          // avoid recursive cradle intersection interrupts\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n          if (scrollHandler.isScrolling) {\n            setCradleState('repositioningRender'); // toggles with repositioningContinuation\n          } else {\n            setCradleState('finishreposition');\n          }\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n      /*\n          the following 11 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts', with a detour for variable layout\n          to reconfigure the scrollblock\n      */\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reload':\n        {\n          if (isCachedRef.current) {\n            setCradleState('cached');\n            break;\n          }\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = [];\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n          interruptHandler.triggerlinesIntersect.disconnect();\n          interruptHandler.cradleIntersect.disconnect();\n          if (_layout == 'variable') {\n            // restore base config to scrollblock\n            // already done for reposition\n            cradleState != 'finishreposition' && layoutHandler.restoreBaseScrollblockConfig();\n          }\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          }\n          // set data\n          contentHandler.setCradleContent(cradleState);\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          }\n          // synchronize cache if necessary\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalLists();\n            }\n          }\n          // prepare the cycle for preparerender\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents;\n          // update virtual DOM\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n          break;\n        }\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements was delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements();\n          setCradleState('restoreinterrupts'); // to restore interrupts\n          break;\n        }\n      case 'restoreinterrupts':\n        {\n          // normalize\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          contentHandler.updateCradleContent();\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n          if (_layout2 == 'uniform') {\n            interruptHandler.triggerlinesIntersect.connectElements();\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            // setCradleState('reconnectupdatedcontent')\n            setCradleState('ready');\n          } else {\n            // 'variable' content requiring reconfiguration\n            setCradleState('refreshDOMupdateforvariability');\n          }\n          break;\n        }\n      // ---------------------[ adjust scrollblock for set variable content ]--------------\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n      case 'preparesetforvariability':\n        {\n          setTimeout(function () {\n            if (isMountedRef.current) {\n              contentHandler.adjustScrollblockForVariability('setcradle');\n              setCradleState('finishsetforvariability');\n            }\n          }, VARIABLE_MEASUREMENTS_TIMEOUT);\n          break;\n        }\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n      // ------------------------[ adjust scrollblock for update variable content ]--------------\n      case 'refreshDOMupdateforvariability':\n        {\n          // extra cycle to allow for DOM synchronizion with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n      case 'adjustupdateforvariability':\n        {\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability('updatecradle');\n            setCradleState('finishupdateforvariability');\n          }, 0);\n          break;\n        }\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseCradleIntersectionObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      // support for various host service requests; syncs cradle content with cache changes\n      case 'applycellframechanges':\n        {\n          // user intervention\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          var portalItemHoldForDeleteList = cacheHandler.portalItemHoldForDeleteList;\n          if (portalItemHoldForDeleteList && portalItemHoldForDeleteList.length) {\n            var _iterator = _createForOfIteratorHelper(portalItemHoldForDeleteList),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n                cacheHandler.removePartitionPortal(item.partitionID, item.itemID);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            cacheHandler.renderPortalLists();\n          }\n          setCradleState('ready');\n          break;\n        }\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]);\n  // standard rendering states (3 states)\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]);\n  // ==========================[ RENDER ]===========================\n  var scrollAxisReferenceIndex = layoutHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollIndexRef = (0, react_1.useRef)(scrollAxisReferenceIndex);\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!['repositioningContinuation', 'repositioningRender', 'finishreposition'].includes(cradleState)) {\n      return null;\n    }\n    if (scrollAxisReferenceIndex != scrollIndexRef.current) {\n      scrollIndexRef.current = scrollAxisReferenceIndex;\n      var repositioningIndexCallback = serviceHandler.callbacks.repositioningIndexCallback;\n      repositioningIndexCallback && repositioningIndexCallback(scrollAxisReferenceIndex);\n    }\n    if (!useScrollTracker) return null;\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles, useScrollTracker]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'headtrigger',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'tailtrigger',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionCallback: serviceHandler.callbacks.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  });\n  // display the cradle components, the ScrollTracker, or null\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ?\n  // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\nexports[\"default\"] = Cradle;\n// utility\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  cacheHandler.cradleParameters = cradleParameters;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ3JhZGxlLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlEQTtBQVVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDYUEscUJBQWEsR0FBR0Msa0JBQUssQ0FBQ0MsYUFBYSxDQUFDLElBQUksQ0FBQztBQUV0RDtBQUNBLElBQU1DLE1BQU0sR0FBRyxTQUFUQSxNQUFNLE9BNEJIO0VBQUEsSUEzQkRDLFNBQVMsUUFBVEEsU0FBUztJQUVUQyxVQUFVLFFBQVZBLFVBQVU7SUFDVkMsUUFBUSxRQUFSQSxRQUFRO0lBQ1JDLGFBQWEsUUFBYkEsYUFBYTtJQUNiQyxPQUFPLFFBQVBBLE9BQU87SUFDUEMsV0FBVyxRQUFYQSxXQUFXO0lBQ1hDLG1CQUFtQixRQUFuQkEsbUJBQW1CO0lBQ25CQyxhQUFhLFFBQWJBLGFBQWE7SUFDYkMsTUFBTSxRQUFOQSxNQUFNO0lBQ05DLGlCQUFpQixRQUFqQkEsaUJBQWlCO0lBQ2pCQyxLQUFLLFFBQUxBLEtBQUs7SUFDTEMsUUFBUSxRQUFSQSxRQUFRO0lBRVJDLFVBQVUsUUFBVkEsVUFBVTtJQUVWQyxZQUFZLFFBQVpBLFlBQVk7SUFFWkMsY0FBYyxRQUFkQSxjQUFjO0lBQ2RDLGdCQUFnQixRQUFoQkEsZ0JBQWdCO0lBQ2hCQyxRQUFRLFFBQVJBLFFBQVE7SUFDUkMscUJBQXFCLFFBQXJCQSxxQkFBcUI7SUFDckJDLG9CQUFvQixRQUFwQkEsb0JBQW9CO0lBQ3BCQyxrQkFBa0IsUUFBbEJBLGtCQUFrQjtJQUNsQkMsNkJBQTZCLFFBQTdCQSw2QkFBNkI7SUFDN0JDLGtCQUFrQixRQUFsQkEsa0JBQWtCO0VBSXRCO0VBRUE7RUFDQSxJQUVJQyxXQUFXLEdBU1h0QixTQUFTLENBVFRzQixXQUFXO0lBQ1hDLEdBQUcsR0FRSHZCLFNBQVMsQ0FSVHVCLEdBQUc7SUFDSEMsT0FBTyxHQU9QeEIsU0FBUyxDQVBUd0IsT0FBTztJQUNQQyxVQUFVLEdBTVZ6QixTQUFTLENBTlR5QixVQUFVO0lBQ1ZDLFNBQVMsR0FLVDFCLFNBQVMsQ0FMVDBCLFNBQVM7SUFDVEMsYUFBYSxHQUliM0IsU0FBUyxDQUpUMkIsYUFBYTtJQUNiQyxZQUFZLEdBR1o1QixTQUFTLENBSFQ0QixZQUFZO0lBQ1pDLE1BQU0sR0FFTjdCLFNBQVMsQ0FGVDZCLE1BQU07RUFJVjtFQUNBLElBQU1DLHlCQUF5QixHQUFHLHNCQUFVLEVBQUNDLDBCQUFlLENBQUM7RUFFN0QsSUFBTUMsNEJBQTRCLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDakRBLDRCQUE0QixDQUFDQyxPQUFPLEdBQUdILHlCQUF5QixFQUFDO0VBRWpFO0VBQ0EsSUFBTUksWUFBWSxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ2pDLElBQU1DLFdBQVcsR0FBRyxrQkFBTSxFQUFDLEtBQUssQ0FBQztFQUNqQyxJQUFNQyxZQUFZLEdBQUcsa0JBQU0sRUFBQyxLQUFLLENBQUM7RUFDbEMsSUFBTUMsa0JBQWtCLEdBQUcsa0JBQU0sRUFBQyxLQUFLLENBQUM7RUFFeEM7RUFDQSxJQUFNQyxpQkFBaUIsR0FBRyxrQkFBTSxFQUFDO0lBQzdCQyxxQkFBcUIsRUFBQztHQUN6QixDQUFDO0VBRUY7RUFDQSxJQUFNQyxxQkFBcUIsR0FBRyxTQUF4QkEscUJBQXFCLEdBQVE7SUFDL0IsSUFBTUMsZUFBZSxHQUFHWCx5QkFBeUIsQ0FBQ1ksVUFBVSxDQUFDVCxPQUFPO0lBQ3BFLE9BQU87TUFDSFUsS0FBSyxFQUFDRixlQUFlLENBQUNHLFdBQVc7TUFDakNDLE1BQU0sRUFBQ0osZUFBZSxDQUFDSztLQUMxQjtFQUNMLENBQUM7RUFFRDtFQUNBLElBQVFDLGtCQUFrQixHQUFLakIseUJBQXlCLENBQWhEaUIsa0JBQWtCLENBQThCLENBQUM7RUFDekQsNEJBQXNEUCxxQkFBcUIsRUFBRTtJQUE5RFEsY0FBYyx5QkFBckJILE1BQU07SUFBc0JJLGFBQWEseUJBQW5CTixLQUFLLENBQTBDLENBQUM7RUFFOUU7RUFDQTtFQUNBLElBQU1PLFVBQVUsR0FBS0QsYUFBYSxJQUFJLENBQUMsSUFBTUQsY0FBYyxJQUFJLENBQUc7RUFFbEUsSUFBTUcsYUFBYSxHQUFJRCxVQUFVLElBQUlmLFdBQVcsQ0FBQ0YsT0FBUTtFQUV6RCxJQUFJa0IsYUFBYSxFQUFFO0lBQ2ZmLFlBQVksQ0FBQ0gsT0FBTyxHQUFHRSxXQUFXLENBQUNGLE9BQU87SUFDMUNFLFdBQVcsQ0FBQ0YsT0FBTyxHQUFHaUIsVUFBVTs7RUFHcEM7RUFDQSxZQUFzQyxvQkFBUSxFQUFDLE9BQU8sQ0FBQztJQUFBO0lBQWhERSxXQUFXO0lBQUVDLGNBQWM7RUFDbEMsSUFBTUMsY0FBYyxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDLEVBQUM7RUFDcENBLGNBQWMsQ0FBQ3JCLE9BQU8sR0FBR21CLFdBQVc7RUFFcEM7RUFDSTtFQUNBO0VBQ0o7RUFFQTtFQUNBLElBQU1HLG9CQUFvQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ3pDLElBQU1DLG9CQUFvQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ3pDLElBQU1DLG9CQUFvQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ3pDLElBQU1DLG9DQUFvQyxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQ3pELElBQU1DLG9DQUFvQyxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBRXpEO0VBQ0EsSUFBTUMsaUJBQWlCLEdBQUcsa0JBQU0sRUFDNUI7SUFDSUMsT0FBTyxFQUFDTixvQkFBb0I7SUFDNUJPLE9BQU8sRUFBQ04sb0JBQW9CO0lBQzVCTyxPQUFPLEVBQUNOLG9CQUFvQjtJQUM1Qk8sNkJBQTZCLEVBQUNOLG9DQUFvQztJQUNsRU8sNkJBQTZCLEVBQUNOO0dBQ2pDLENBQ0o7RUFFRDtFQUNBO0VBRUE7RUFDQSxJQUFNTyxVQUFVLEdBQUcsbUJBQU8sRUFBQyxZQUFLO0lBRTVCLElBQUkvQixXQUFXLENBQUNGLE9BQU8sRUFBRSxPQUFPLENBQUM7SUFFakMsSUFBTWtDLG1CQUFtQixHQUNwQjdDLFdBQVcsSUFBSSxVQUFVLEdBQ3RCMkIsYUFBYSxHQUNiRCxjQUFjO0lBRXRCO0lBQ0EsSUFBTW9CLDBCQUEwQixHQUFHRCxtQkFBbUIsR0FBSTNDLE9BQU8sR0FBRyxDQUFFLEdBQUdELEdBQUc7SUFFNUUsSUFBTThDLGVBQWUsR0FDakIsQ0FBRS9DLFdBQVcsSUFBSSxVQUFVLEdBQ3ZCSSxTQUFTLEdBQ1RELFVBQVUsSUFDWkYsR0FBRztJQUVULElBQU0rQyxzQkFBc0IsR0FDeEJDLElBQUksQ0FBQ0MsR0FBRyxDQUFDSCxlQUFlLEVBQUNELDBCQUEwQixDQUFDLEVBQUM7SUFFekQsSUFBTUYsVUFBVSxHQUFHSyxJQUFJLENBQUNFLEtBQUssQ0FBQ0wsMEJBQTBCLEdBQUNFLHNCQUFzQixDQUFDO0lBRWhGLE9BQU9KLFVBQVU7RUFFckIsQ0FBQyxFQUFDLENBQ0U1QyxXQUFXLEVBQ1hDLEdBQUcsRUFDSEMsT0FBTyxFQUNQRSxTQUFTLEVBQ1RELFVBQVUsRUFDVnVCLGNBQWMsRUFDZEMsYUFBYSxDQUNoQixDQUFDO0VBRUY7RUFDQSxZQUtJLG1CQUFPLEVBQUMsWUFBSTtNQUVaLElBQU15QixjQUFjLEdBQ2ZwRCxXQUFXLElBQUksVUFBVSxHQUN0QjBCLGNBQWMsR0FDZEMsYUFBYTtNQUVyQixJQUFJMEIsYUFBYTtNQUNqQixJQUFJOUMsTUFBTSxJQUFJLFNBQVMsRUFBRTtRQUVyQixJQUFJUCxXQUFXLElBQUksVUFBVSxFQUFFO1VBRTNCcUQsYUFBYSxHQUFHbEQsVUFBVTtTQUU3QixNQUFNO1VBRUhrRCxhQUFhLEdBQUdqRCxTQUFTOztPQUloQyxNQUFNO1FBQUU7UUFFTCxJQUFJSixXQUFXLElBQUksVUFBVSxFQUFFO1VBRTNCcUQsYUFBYSxHQUFHaEQsYUFBYTtTQUVoQyxNQUFNO1VBRUhnRCxhQUFhLEdBQUcvQyxZQUFZOzs7TUFNcEMrQyxhQUFhLElBQUlwRCxHQUFHO01BRXBCLElBQU1xRCxnQkFBZ0IsR0FBR0wsSUFBSSxDQUFDTSxJQUFJLENBQUNILGNBQWMsR0FBQ0MsYUFBYSxDQUFDO01BRWhFLElBQU1HLFlBQVksR0FBR1AsSUFBSSxDQUFDTSxJQUFJLENBQUMzRSxRQUFRLEdBQUNnRSxVQUFVLENBQUM7TUFFbkQsSUFBTWEsd0JBQXdCLEdBQUdILGdCQUFnQixHQUFJM0UsVUFBVSxHQUFHLENBQUU7TUFFcEUsSUFBSStFLGNBQWMsR0FBR1QsSUFBSSxDQUFDQyxHQUFHLENBQUNNLFlBQVksRUFBRUMsd0JBQXdCLENBQUM7TUFFckUsSUFBSUUsY0FBYztNQUNsQixJQUFJRix3QkFBd0IsSUFBSUMsY0FBYyxFQUFFO1FBRTVDQyxjQUFjLEdBQUdoRixVQUFVO09BRTlCLE1BQU07UUFFSCxJQUFNaUYsSUFBSSxHQUFJRixjQUFjLEdBQUdELHdCQUF5QjtRQUN4REUsY0FBYyxJQUFJVixJQUFJLENBQUNFLEtBQUssQ0FBQ1MsSUFBSSxHQUFDLENBQUMsQ0FBQztRQUNwQ0QsY0FBYyxHQUFHVixJQUFJLENBQUNZLEdBQUcsQ0FBQyxDQUFDLEVBQUNGLGNBQWMsQ0FBQzs7TUFJL0MsSUFBSUcsU0FBUyxHQUFHSixjQUFjLEdBQUdkLFVBQVU7TUFDM0MsSUFBSWtCLFNBQVMsR0FBR2xGLFFBQVEsRUFBRTtRQUV0QmtGLFNBQVMsR0FBR2xGLFFBQVE7UUFDcEI4RSxjQUFjLEdBQUdULElBQUksQ0FBQ00sSUFBSSxDQUFDTyxTQUFTLEdBQUNsQixVQUFVLENBQUM7O01BSXBELE9BQU8sQ0FDSGMsY0FBYyxFQUNkSixnQkFBZ0IsRUFDaEJFLFlBQVksRUFDWkcsY0FBYyxDQUNqQjtJQUVMLENBQUMsRUFBQyxDQUNFM0QsV0FBVyxFQUNYQyxHQUFHO0lBQ0g7SUFDQUcsU0FBUyxFQUNURCxVQUFVLEVBQ1ZHLFlBQVksRUFDWkQsYUFBYSxFQUNicUIsY0FBYyxFQUNkQyxhQUFhLEVBRWIvQyxRQUFRLEVBQ1JELFVBQVUsRUFDVmlFLFVBQVUsRUFDVnJDLE1BQU0sQ0FDVCxDQUFDO0lBQUE7SUEzRkVtRCxjQUFjO0lBQ2RKLGdCQUFnQjtJQUNoQkUsWUFBWTtJQUNaRyxjQUFjO0VBMEZsQjtFQUVBO0VBQ0EsSUFBTUksb0JBQW9CLEdBQUcsa0JBQU0sRUFDL0I7SUFDSUMsc0JBQXNCLEVBQUMvRSxhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRStFLHNCQUFzQjtJQUM1REMseUJBQXlCLEVBQUNoRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRWdGLHlCQUF5QjtJQUNsRUMsMEJBQTBCLEVBQUNqRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRWlGLDBCQUEwQjtJQUNwRUMsb0JBQW9CLEVBQUNsRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRWtGLG9CQUFvQjtJQUN4REMsa0JBQWtCLEVBQUNuRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRW1GLGtCQUFrQjtJQUNwREMsc0JBQXNCLEVBQUNwRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRW9GLHNCQUFzQjtJQUM1REMscUJBQXFCLEVBQUNyRixhQUFhLGFBQWJBLGFBQWEsdUJBQWJBLGFBQWEsQ0FBRXFGO0dBQ3hDLENBQ0o7RUFFRDtFQUVBO0VBRUEsSUFBTUMsNEJBQTRCLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUMsRUFBQztFQUNsRDtFQUNBQSw0QkFBNEIsQ0FBQzVELE9BQU8sR0FBRztJQUNuQztJQUNBWCxXQUFXLEVBQVhBLFdBQVc7SUFBRUMsR0FBRyxFQUFIQSxHQUFHO0lBQUVDLE9BQU8sRUFBUEEsT0FBTztJQUFFSyxNQUFNLEVBQU5BLE1BQU07SUFDakNKLFVBQVUsRUFBVkEsVUFBVTtJQUFFQyxTQUFTLEVBQVRBLFNBQVM7SUFBRUMsYUFBYSxFQUFiQSxhQUFhO0lBQUVDLFlBQVksRUFBWkEsWUFBWTtJQUNsRDtJQUNBbEIsS0FBSyxFQUFMQSxLQUFLO0lBQUVDLFFBQVEsRUFBUkEsUUFBUTtJQUNmUixhQUFhLEVBQWJBLGFBQWE7SUFDYkMsT0FBTyxFQUFQQSxPQUFPO0lBQ1BDLFdBQVcsRUFBWEEsV0FBVztJQUFFQyxtQkFBbUIsRUFBbkJBLG1CQUFtQjtJQUFFUSxjQUFjLEVBQWRBLGNBQWM7SUFDaERMLGlCQUFpQixFQUFqQkEsaUJBQWlCO0lBQ2pCRyxVQUFVLEVBQVZBLFVBQVU7SUFDVjtJQUNBTCxhQUFhLEVBQWJBLGFBQWE7SUFBRUMsTUFBTSxFQUFOQSxNQUFNO0lBQUVLLFlBQVksRUFBWkEsWUFBWTtJQUNuQztJQUNBSSxxQkFBcUIsRUFBckJBLHFCQUFxQjtJQUFFRSxrQkFBa0IsRUFBbEJBLGtCQUFrQjtJQUN6Q0Usa0JBQWtCLEVBQWxCQTtHQUVIO0VBRUQsSUFBTXlFLHFCQUFxQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQzFDO0VBQ0FBLHFCQUFxQixDQUFDN0QsT0FBTyxHQUFHO0lBQzVCWCxXQUFXLEVBQVhBLFdBQVc7SUFBRUMsR0FBRyxFQUFIQSxHQUFHO0lBQUVDLE9BQU8sRUFBUEEsT0FBTztJQUFFSyxNQUFNLEVBQU5BLE1BQU07SUFDakNKLFVBQVUsRUFBVkEsVUFBVTtJQUFFQyxTQUFTLEVBQVRBLFNBQVM7SUFBRUMsYUFBYSxFQUFiQSxhQUFhO0lBQUVDLFlBQVksRUFBWkEsWUFBWTtJQUNsRDFCLFFBQVEsRUFBUkEsUUFBUTtJQUNSK0UsY0FBYyxFQUFkQSxjQUFjO0lBQ2R2RSxLQUFLLEVBQUxBLEtBQUs7SUFDTEMsUUFBUSxFQUFSQSxRQUFRO0lBQ1JSLGFBQWEsRUFBYkEsYUFBYTtJQUNiK0QsVUFBVSxFQUFWQTtHQUNIO0VBRUQ7RUFDQSxJQUFNNkIsMkJBQTJCLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFDaERBLDJCQUEyQixDQUFDOUQsT0FBTyxHQUFHO0lBRWxDO0lBQ0FpQyxVQUFVLEVBQVZBLFVBQVU7SUFDVmMsY0FBYyxFQUFkQSxjQUFjO0lBQ2RKLGdCQUFnQixFQUFoQkEsZ0JBQWdCO0lBQ2hCRSxZQUFZLEVBQVpBLFlBQVk7SUFDWjVFLFFBQVEsRUFBUkEsUUFBUTtJQUNSK0UsY0FBYyxFQUFkQSxjQUFjO0lBRWQ7SUFDQS9DLFlBQVksRUFBWkEsWUFBWTtJQUNaMEIsaUJBQWlCLEVBQWpCQSxpQkFBaUI7SUFDakJ6QixXQUFXLEVBQVhBLFdBQVc7SUFDWEMsWUFBWSxFQUFaQSxZQUFZO0lBQ1pFLGlCQUFpQixFQUFqQkEsaUJBQWlCO0lBRWpCO0lBQ0FnQixjQUFjLEVBQWRBLGNBQWM7SUFDZEQsY0FBYyxFQUFkQTtHQUNIO0VBRUQ7RUFDQSxJQUFNMkMsV0FBVyxHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBRWhDO0VBQ0EsSUFBTUMsZ0JBQWdCLEdBQUc7SUFDckJELFdBQVcsRUFBWEEsV0FBVztJQUNYaEUsNEJBQTRCLEVBQTVCQSw0QkFBNEI7SUFDNUI2RCw0QkFBNEIsRUFBNUJBLDRCQUE0QjtJQUM1QkMscUJBQXFCLEVBQXJCQSxxQkFBcUI7SUFDckJDLDJCQUEyQixFQUEzQkEsMkJBQTJCO0lBQzNCVixvQkFBb0IsRUFBcEJBO0dBQ0g7RUFFRCxJQUFNYSxtQkFBbUIsR0FBRyxrQkFBTSxFQUFDLElBQUksQ0FBQztFQUN4Q0EsbUJBQW1CLENBQUNqRSxPQUFPLEdBQUdnRSxnQkFBZ0I7RUFFOUM7RUFDQSxJQUFJLENBQUNELFdBQVcsQ0FBQy9ELE9BQU8sRUFBRTtJQUV0QitELFdBQVcsQ0FBQy9ELE9BQU8sR0FBR2tFLGlCQUFpQixDQUFDRixnQkFBZ0IsQ0FBQzs7RUFJN0Q7RUFDQSwyQkFRSUQsV0FBVyxDQUFDL0QsT0FBTztJQVBuQm1FLGdCQUFnQix3QkFBaEJBLGdCQUFnQjtJQUNoQkMsYUFBYSx3QkFBYkEsYUFBYTtJQUViQyxjQUFjLHdCQUFkQSxjQUFjO0lBQ2RDLGFBQWEsd0JBQWJBLGFBQWE7SUFDYkMsY0FBYyx3QkFBZEEsY0FBYztJQUNkQyxhQUFhLHdCQUFiQSxhQUFhO0VBR2pCO0VBRUo7Ozs7Ozs7Ozs7Ozs7RUFjSSxJQUFNQyxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQWdCLEdBQVE7SUFFMUIsSUFBUUMsa0JBQWtCLEdBQUtKLGFBQWEsQ0FBcENJLGtCQUFrQjtJQUUxQixJQUFNQyxjQUFjLEdBQUdELGtCQUFrQixDQUFDQyxjQUFjO0lBQ3hELElBQU1DLGVBQWUsR0FBR0Ysa0JBQWtCLENBQUNFLGVBQWU7SUFDMUQsSUFBSUQsY0FBYyxLQUFLLElBQUksRUFBRTtNQUV6QixJQUFNbkUsZUFBZSxHQUFHVCw0QkFBNEIsQ0FBQ0MsT0FBTyxDQUFDUyxVQUFVLENBQUNULE9BQU87TUFFL0VRLGVBQWUsQ0FBQ2tFLGtCQUFrQixDQUFDRyxtQkFBbUIsQ0FBQyxHQUFHRixjQUFjO01BQ3hFbkUsZUFBZSxDQUFDa0Usa0JBQWtCLENBQUNJLG9CQUFvQixDQUFDLEdBQUdGLGVBQWU7O0VBSWxGLENBQUM7RUFFRCxJQUFJMUQsYUFBYSxJQUFJLENBQUNoQixXQUFXLENBQUNGLE9BQU8sRUFBRTtJQUV2Q3lFLGdCQUFnQixFQUFFOztFQUl0QjtFQUNBLHFCQUFTLEVBQUMsWUFBSTtJQUVWLElBQUlwRCxjQUFjLENBQUNyQixPQUFPLElBQUksT0FBTyxFQUFFLE9BQU0sQ0FBQztJQUU5QyxJQUFJRSxXQUFXLENBQUNGLE9BQU8sSUFBSSxDQUFDRyxZQUFZLENBQUNILE9BQU8sRUFBRTtNQUFFO01BRWhEb0IsY0FBYyxDQUFDLFFBQVEsQ0FBQztLQUUzQixNQUFNLElBQUksQ0FBQ2xCLFdBQVcsQ0FBQ0YsT0FBTyxJQUFJRyxZQUFZLENBQUNILE9BQU8sRUFBRTtNQUFFO01BRXZERyxZQUFZLENBQUNILE9BQU8sR0FBRyxLQUFLO01BRTVCLElBQUlJLGtCQUFrQixDQUFDSixPQUFPLEVBQUU7UUFFNUJvQixjQUFjLENBQUMsbUJBQW1CLENBQUM7T0FFdEMsTUFBTTtRQUVIQSxjQUFjLENBQUMsc0JBQXNCLENBQUM7OztFQU1sRCxDQUFDLEVBQUMsQ0FBQ2xCLFdBQVcsQ0FBQ0YsT0FBTyxFQUFFRyxZQUFZLENBQUNILE9BQU8sQ0FBQyxDQUFDO0VBRTlDO0VBQ0E7RUFFQTtFQUNBLHFCQUFTLEVBQUMsWUFBSTtJQUVWQyxZQUFZLENBQUNELE9BQU8sR0FBRyxJQUFJO0lBQzNCO0lBQ0EsT0FBTyxZQUFLO01BRVJDLFlBQVksQ0FBQ0QsT0FBTyxHQUFHLEtBQUs7SUFFaEMsQ0FBQztFQUVMLENBQUMsRUFBQyxFQUFFLENBQUM7RUFFTDtFQUNBLHFCQUFTLEVBQUMsWUFBSTtJQUVWLElBQUksQ0FBQzFCLGFBQWEsQ0FBQ3lHLGlCQUFpQixFQUFFO0lBRXRDLElBRUlDLGFBQWEsR0FjYlQsY0FBYyxDQWRkUyxhQUFhO01BQ2JDLE1BQU0sR0FhTlYsY0FBYyxDQWJkVSxNQUFNO01BQ05DLFdBQVcsR0FZWFgsY0FBYyxDQVpkVyxXQUFXO01BQ1hDLFVBQVUsR0FXVlosY0FBYyxDQVhkWSxVQUFVO01BRVZDLGdCQUFnQixHQVNoQmIsY0FBYyxDQVRkYSxnQkFBZ0I7TUFDaEJDLGVBQWUsR0FRZmQsY0FBYyxDQVJkYyxlQUFlO01BQ2ZDLGlCQUFpQixHQU9qQmYsY0FBYyxDQVBkZSxpQkFBaUI7TUFFakJDLFlBQVksR0FLWmhCLGNBQWMsQ0FMZGdCLFlBQVk7TUFDWkMsU0FBUyxHQUlUakIsY0FBYyxDQUpkaUIsU0FBUztNQUNUQyxXQUFXLEdBR1hsQixjQUFjLENBSGRrQixXQUFXO01BQ1hDLFdBQVcsR0FFWG5CLGNBQWMsQ0FGZG1CLFdBQVc7SUFJZixJQUFNQyxTQUFTLEdBQUc7TUFFZFgsYUFBYSxFQUFiQSxhQUFhO01BQ2JDLE1BQU0sRUFBTkEsTUFBTTtNQUNOQyxXQUFXLEVBQVhBLFdBQVc7TUFDWEMsVUFBVSxFQUFWQSxVQUFVO01BRVZDLGdCQUFnQixFQUFoQkEsZ0JBQWdCO01BQ2hCQyxlQUFlLEVBQWZBLGVBQWU7TUFDZkMsaUJBQWlCLEVBQWpCQSxpQkFBaUI7TUFDakJDLFlBQVksRUFBWkEsWUFBWTtNQUNaQyxTQUFTLEVBQVRBLFNBQVM7TUFDVEMsV0FBVyxFQUFYQSxXQUFXO01BQ1hDLFdBQVcsRUFBWEE7S0FFSDtJQUVEcEgsYUFBYSxDQUFDeUcsaUJBQWlCLENBQUNZLFNBQVMsQ0FBQztFQUU5QyxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUw7RUFDQSxxQkFBUyxFQUFDLFlBQUs7SUFFWCxJQUFNbkYsZUFBZSxHQUFHVCw0QkFBNEIsQ0FBQ0MsT0FBTyxDQUFDUyxVQUFVLENBQUNULE9BQU87SUFDL0VRLGVBQWUsQ0FBQ29GLGdCQUFnQixDQUFDLFFBQVEsRUFBQ3hCLGFBQWEsQ0FBQ3lCLFFBQVEsQ0FBQztJQUVqRSxPQUFPLFlBQUs7TUFFUnJGLGVBQWUsSUFDWEEsZUFBZSxDQUFDc0YsbUJBQW1CLENBQUMsUUFBUSxFQUFDMUIsYUFBYSxDQUFDeUIsUUFBUSxDQUFDO0lBRTVFLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUw7RUFDQSxxQkFBUyxFQUFDLFlBQUs7SUFFWCxJQUFRakcsTUFBTSxHQUFLZ0UsNEJBQTRCLENBQUM1RCxPQUFPLENBQS9DSixNQUFNO0lBRWQsSUFBSSxDQUFDLHNDQUFXLEdBQUUsSUFBS0EsTUFBTSxJQUFJLFNBQVUsRUFBRTtJQUU3QyxJQUFNWSxlQUFlLEdBQUdULDRCQUE0QixDQUFDQyxPQUFPLENBQUNTLFVBQVUsQ0FBQ1QsT0FBTztJQUMvRVEsZUFBZSxDQUFDb0YsZ0JBQWdCLENBQUMsUUFBUSxFQUFDeEIsYUFBYSxDQUFDMkIsV0FBVyxDQUFDO0lBRXBFLE9BQU8sWUFBSztNQUVSdkYsZUFBZSxJQUNYQSxlQUFlLENBQUNzRixtQkFBbUIsQ0FBQyxRQUFRLEVBQUMxQixhQUFhLENBQUMyQixXQUFXLENBQUM7SUFFL0UsQ0FBQztFQUVMLENBQUMsRUFBQyxFQUFFLENBQUM7RUFFTDtFQUNBOzs7O0VBSUEscUJBQVMsRUFBQyxZQUFJO0lBRVYsSUFDSUMsZUFBZSxHQUVmN0IsZ0JBQWdCLENBRmhCNkIsZUFBZTtNQUNmQyxxQkFBcUIsR0FDckI5QixnQkFBZ0IsQ0FEaEI4QixxQkFBcUI7SUFHekI7SUFDQTtJQUNBO0lBQ0EsSUFBTUMsdUJBQXVCLEdBQUdGLGVBQWUsQ0FBQ0csY0FBYyxFQUFFO0lBQ2hFSCxlQUFlLENBQUNJLGVBQWUsRUFBRTtJQUVqQztJQUNBO0lBQ0E7SUFDQSxJQUFNQyxlQUFlLEdBQUdKLHFCQUFxQixDQUFDRSxjQUFjLEVBQUU7SUFFOUQsT0FBTyxZQUFLO01BRVJELHVCQUF1QixDQUFDSSxVQUFVLEVBQUU7TUFDcENELGVBQWUsQ0FBQ0MsVUFBVSxFQUFFO0lBRWhDLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUw7RUFDQTtFQUVBO0VBQ0E7RUFDQSxJQUFNQyxzQkFBc0IsR0FBRyx1QkFBVyxFQUFDLFVBQUNDLFdBQVcsRUFBSTtJQUN2RCxJQUFNdkksUUFBUSxHQUFHNkYsMkJBQTJCLENBQUM5RCxPQUFPLENBQUMvQixRQUFRO0lBRTdELElBQUl1SSxXQUFXLEdBQUd2SSxRQUFRLEVBQUU7TUFFeEIsNEJBQXVEc0csY0FBYyxDQUFDa0MsU0FBUztRQUF2RWhELGtCQUFrQix5QkFBbEJBLGtCQUFrQjtRQUFFQyxzQkFBc0IseUJBQXRCQSxzQkFBc0I7TUFFbEQsSUFBSWdELGFBQWE7TUFDakIsSUFBSWpELGtCQUFrQixFQUFFO1FBQ3BCaUQsYUFBYSxHQUFHLHVCQUFDQyxVQUFVLEVBQUk7VUFFM0JsRCxrQkFBa0IsQ0FBQyx1QkFBdUIsRUFBQ2tELFVBQVUsQ0FBQztRQUUxRCxDQUFDOztNQUlML0gsWUFBWSxDQUFDZ0ksY0FBYyxDQUFDSixXQUFXLEVBQ25DRSxhQUFhLEVBQ2JoRCxzQkFBc0IsQ0FBQzs7RUFHbkMsQ0FBQyxFQUFDLEVBQUUsQ0FBQztFQUVMO0VBQ0EscUJBQVMsRUFBQyxZQUFJO0lBRVYsSUFBSWpGLEtBQUssSUFBSSxTQUFTLEVBQUU7TUFFcEIyQyxjQUFjLENBQUMsY0FBYyxDQUFDO01BRTlCOztJQUlKLElBQUlDLGNBQWMsQ0FBQ3JCLE9BQU8sSUFBSSxPQUFPLEVBQUU7SUFFdkMsUUFBUXZCLEtBQUs7TUFFVCxLQUFLLFVBQVU7UUFBRTtVQUViLElBQU1vSSxjQUFjLEdBQUd4QyxjQUFjLENBQUN5QyxpQkFBaUIsRUFBRTtVQUV6RCxJQUFRckQsa0JBQWtCLEdBQUtjLGNBQWMsQ0FBQ2tDLFNBQVMsQ0FBL0NoRCxrQkFBa0I7VUFFMUIsSUFBSWlELGFBQWE7VUFDakIsSUFBSWpELGtCQUFrQixFQUFFO1lBQ3BCaUQsYUFBYSxHQUFHLHVCQUFDQyxVQUFVLEVBQUk7Y0FFM0JsRCxrQkFBa0IsQ0FBQyx3QkFBd0IsRUFBQ2tELFVBQVUsQ0FBQztZQUUzRCxDQUFDOztVQUlMLElBQU1qSSxTQUFRLEdBQUdzRixnQkFBZ0IsQ0FBQ0osNEJBQTRCLENBQUM1RCxPQUFPLENBQUN0QixRQUFRO1VBRS9FLElBQUlFLFlBQVksQ0FBQ21JLGNBQWMsQ0FBQ3JJLFNBQVEsRUFBRW1JLGNBQWMsRUFBRUgsYUFBYSxFQUFFL0gsVUFBVSxDQUFDLEVBQUU7WUFFbEZDLFlBQVksQ0FBQ29JLGlCQUFpQixFQUFFOztVQUlwQzVGLGNBQWMsQ0FBQyxlQUFlLENBQUM7VUFFL0I7O01BR0osS0FBSyxRQUFRO1FBQUU7VUFFWCxJQUFNeUYsZUFBYyxHQUFHeEMsY0FBYyxDQUFDeUMsaUJBQWlCLEVBQUU7VUFFekQsSUFBUXJELG1CQUFrQixHQUFLYyxjQUFjLENBQUNrQyxTQUFTLENBQS9DaEQsa0JBQWtCO1VBRTFCLElBQUlpRCxjQUFhO1VBQ2pCLElBQUlqRCxtQkFBa0IsRUFBRTtZQUNwQmlELGNBQWEsR0FBRyx3QkFBQ0MsVUFBVSxFQUFJO2NBRTNCbEQsbUJBQWtCLENBQUMsdUJBQXVCLEVBQUNrRCxVQUFVLENBQUM7WUFFMUQsQ0FBQzs7VUFJTCxJQUFJL0gsWUFBWSxDQUFDcUksa0JBQWtCLENBQUNKLGVBQWMsRUFBRUgsY0FBYSxDQUFDLEVBQUU7WUFFaEU5SCxZQUFZLENBQUNvSSxpQkFBaUIsRUFBRTs7VUFJcEM1RixjQUFjLENBQUMsZUFBZSxDQUFDO1VBRS9COztJQUNIO0VBSVQsQ0FBQyxFQUFDLENBQUMzQyxLQUFLLEVBQUVDLFFBQVEsQ0FBQyxDQUFDO0VBRXBCO0VBQ0EscUJBQVMsRUFBQyxZQUFJO0lBRVYsSUFBSTJDLGNBQWMsQ0FBQ3JCLE9BQU8sSUFBSSxPQUFPLEVBQUU7SUFFdkM7SUFDQSxJQUFJRSxXQUFXLENBQUNGLE9BQU8sSUFBSUcsWUFBWSxDQUFDSCxPQUFPLEVBQUU7TUFFN0M7O0lBSUosSUFBS0QsNEJBQTRCLENBQUNDLE9BQU8sQ0FBQ2tILFVBQVUsSUFDM0M3RixjQUFjLENBQUNyQixPQUFPLElBQUksa0JBQW1CLEVBQUU7TUFFcERtRSxnQkFBZ0IsQ0FBQ2dELGVBQWUsRUFBRTtNQUVsQy9GLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQzs7SUFJdEM7SUFDQSxJQUFJLENBQUNyQiw0QkFBNEIsQ0FBQ0MsT0FBTyxDQUFDa0gsVUFBVSxJQUFLN0YsY0FBYyxDQUFDckIsT0FBTyxJQUFJLGtCQUFtQixFQUFFO01BRXBHb0IsY0FBYyxDQUFDLHNCQUFzQixDQUFDOztFQUk5QyxDQUFDLEVBQUMsQ0FBQ3JCLDRCQUE0QixDQUFDQyxPQUFPLENBQUNrSCxVQUFVLENBQUMsQ0FBQztFQUVwRDtFQUNBLHFCQUFTLEVBQUMsWUFBSTtJQUVWLElBQUk3RixjQUFjLENBQUNyQixPQUFPLElBQUksT0FBTyxFQUFFO0lBRXZDLElBQUlFLFdBQVcsQ0FBQ0YsT0FBTyxFQUFFO0lBRXpCbUUsZ0JBQWdCLENBQUNnRCxlQUFlLEVBQUU7SUFFbEMvRixjQUFjLENBQUMsYUFBYSxDQUFDO0VBRWpDLENBQUMsRUFBQyxDQUNFbkQsUUFBUSxFQUNSdUIsVUFBVSxFQUNWQyxTQUFTLEVBQ1RILEdBQUcsRUFDSEMsT0FBTyxFQUNQZixpQkFBaUIsRUFDakJvQixNQUFNLEVBQ041QixVQUFVLENBQ2IsQ0FBQztFQUVGO0VBQ0EscUJBQVMsRUFBQyxZQUFLO0lBRVgsSUFBSXFELGNBQWMsQ0FBQ3JCLE9BQU8sSUFBSSxPQUFPLEVBQUU7SUFFdkNtRSxnQkFBZ0IsQ0FBQ2dELGVBQWUsRUFBRTtJQUVsQy9GLGNBQWMsQ0FBQyxRQUFRLENBQUM7RUFFNUIsQ0FBQyxFQUFDLENBQUNqRCxPQUFPLENBQUMsQ0FBQztFQUVaO0VBQ0EscUJBQVMsRUFBQyxZQUFJO0lBRVZtRyxhQUFhLENBQUNJLGtCQUFrQixDQUFDRyxtQkFBbUIsR0FDL0N4RixXQUFXLElBQUksVUFBVSxHQUN0QixXQUFXLEdBQ1gsWUFBWTtJQUVwQmlGLGFBQWEsQ0FBQ0ksa0JBQWtCLENBQUNJLG9CQUFvQixHQUNoRHpGLFdBQVcsSUFBSSxZQUFZLEdBQ3hCLFdBQVcsR0FDWCxZQUFZO0lBRXBCLElBQUlnQyxjQUFjLENBQUNyQixPQUFPLElBQUksT0FBTyxFQUFFO01BQ25Dc0UsYUFBYSxDQUFDSSxrQkFBa0IsQ0FBQ0MsY0FBYyxHQUFHLENBQUM7TUFDbkRMLGFBQWEsQ0FBQ0ksa0JBQWtCLENBQUNFLGVBQWUsR0FBRyxDQUFDO01BQ3BEOztJQUlKLElBQUkxRSxXQUFXLENBQUNGLE9BQU8sRUFBRTtNQUNyQkksa0JBQWtCLENBQUNKLE9BQU8sR0FBRyxLQUFLO01BQ2xDOztJQUdKLDRCQUF3QjRELDRCQUE0QixDQUFDNUQsT0FBTztNQUFwREosTUFBTSx5QkFBTkEsTUFBTTtNQUFFTixHQUFHLHlCQUFIQSxHQUFHO0lBQ25CLElBQVFvRixrQkFBa0IsR0FBS0osYUFBYSxDQUFwQ0ksa0JBQWtCO0lBRTFCLElBQUk5RSxNQUFNLElBQUksU0FBUyxFQUFFO01BRXJCLDZCQUlJZ0UsNEJBQTRCLENBQUM1RCxPQUFPO1FBSHBDUCxVQUFTLDBCQUFUQSxTQUFTO1FBQ1RELFdBQVUsMEJBQVZBLFVBQVU7UUFDVkYsSUFBRywwQkFBSEEsR0FBRztNQUdQO01BQ0EsSUFBTThILHVCQUF1QixHQUN6QixDQUFFL0gsV0FBVyxJQUFJLFVBQVUsR0FDdkJJLFVBQVMsR0FDVEQsV0FBVSxJQUNaRixJQUFHO01BRVQsSUFBTStILGtCQUFrQixHQUFHL0MsYUFBYSxDQUFDSSxrQkFBa0IsQ0FBQzRDLDZCQUE2QjtNQUV6RixJQUFNQyxhQUFhLEdBQUdGLGtCQUFrQixHQUFDRCx1QkFBdUI7TUFFaEUsSUFBTUksb0JBQW9CLEdBQ3RCLENBQUVuSSxXQUFXLElBQUksVUFBVSxHQUN2QkcsV0FBVSxHQUNWQyxVQUFTLElBQ1hILElBQUc7TUFFVCxJQUFNbUksZUFBZSxHQUFHRixhQUFhLEdBQUdDLG9CQUFvQjtNQUU1RDlDLGtCQUFrQixDQUFDNEMsNkJBQTZCLEdBQUdoRixJQUFJLENBQUNvRixLQUFLLENBQUNELGVBQWUsQ0FBQztLQUVqRixNQUFNO01BRUgvQyxrQkFBa0IsQ0FBQzRDLDZCQUE2QixHQUFHaEksR0FBRzs7SUFJMUQ2RSxnQkFBZ0IsQ0FBQ2dELGVBQWUsRUFBRTtJQUVsQy9GLGNBQWMsQ0FBQyxPQUFPLENBQUM7RUFFM0IsQ0FBQyxFQUFDLENBQUMvQixXQUFXLENBQUMsQ0FBQztFQUVoQjtFQUVBO0VBQ0EsWUFPSSxtQkFBTyxFQUFDLFlBQUk7TUFFWixPQUFPbUYsYUFBYSxDQUFDbUQsZUFBZSxDQUFDO1FBRWpDdEksV0FBVyxFQUFYQSxXQUFXO1FBQ1hHLFVBQVUsRUFBVkEsVUFBVTtRQUNWQyxTQUFTLEVBQVRBLFNBQVM7UUFDVEMsYUFBYSxFQUFiQSxhQUFhO1FBQ2JDLFlBQVksRUFBWkEsWUFBWTtRQUNaTCxHQUFHLEVBQUhBLEdBQUc7UUFDSEMsT0FBTyxFQUFQQSxPQUFPO1FBQ1B3QixjQUFjLEVBQWRBLGNBQWM7UUFDZEMsYUFBYSxFQUFiQSxhQUFhO1FBQ2JpQixVQUFVLEVBQVZBLFVBQVU7UUFDVjJGLFVBQVUsRUFBQ3JKLE1BQU07UUFDakJDLGlCQUFpQixFQUFqQkEsaUJBQWlCO1FBQ2pCb0IsTUFBTSxFQUFOQTtPQUVILENBQUM7SUFFTixDQUFDLEVBQUMsQ0FFRVAsV0FBVyxFQUNYRyxVQUFVLEVBQ1ZDLFNBQVMsRUFDVEMsYUFBYSxFQUNiQyxZQUFZLEVBQ1pMLEdBQUcsRUFDSEMsT0FBTyxFQUNQd0IsY0FBYyxFQUNkQyxhQUFhLEVBQ2JpQixVQUFVLEVBQ1YxRCxNQUFNLEVBQ05DLGlCQUFpQixFQUNqQm9CLE1BQU0sQ0FFUCxDQUFDO0lBQUE7SUExQ0FpSSxlQUFlO0lBQ2ZDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxrQkFBa0I7SUFDbEJDLCtCQUErQjtJQUMvQkMsK0JBQStCO0VBdUNuQztFQUVBO0VBQ0E7RUFDQSwyQkFBZSxFQUFDLFlBQUk7SUFFaEIsUUFBUS9HLFdBQVc7TUFFZjtNQUNBO01BQ0E7TUFFQSxLQUFLLE9BQU87UUFBRTtVQUFFO1VBRVosSUFBSXlDLDRCQUE0QixDQUFDNUQsT0FBTyxDQUFDdkIsS0FBSyxJQUFJLFNBQVMsRUFBRTtZQUN6RCxJQUFJeUIsV0FBVyxDQUFDRixPQUFPLEVBQUU7Y0FDckJvQixjQUFjLENBQUMsUUFBUSxDQUFDO2FBQzNCLE1BQU07Y0FDSEEsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFDOzs7O1VBR3RDOztNQUlKLEtBQUssa0JBQWtCO1FBQUU7VUFFckI7VUFDQTs7TUFHSixLQUFLLGNBQWM7UUFBRTtVQUVqQixJQUFNK0csYUFBYSxHQUFHLFNBQWhCQSxhQUFhLEdBQVE7WUFFdkIsSUFBTXRCLGNBQWMsR0FBR3hDLGNBQWMsQ0FBQ3lDLGlCQUFpQixFQUFFO1lBRXpELElBQVFyRCxrQkFBa0IsR0FBS2MsY0FBYyxDQUFDa0MsU0FBUyxDQUEvQ2hELGtCQUFrQjtZQUUxQixJQUFJaUQsYUFBYTtZQUNqQixJQUFJakQsa0JBQWtCLEVBQUU7Y0FDcEJpRCxhQUFhLEdBQUcsdUJBQUNDLFVBQVUsRUFBSTtnQkFFM0JsRCxrQkFBa0IsQ0FBQyx3QkFBd0IsRUFBQ2tELFVBQVUsQ0FBQztjQUUzRCxDQUFDOztZQUlMLElBQUkvSCxZQUFZLENBQUNtSSxjQUFjLENBQUNySSxRQUFRLEVBQUVtSSxjQUFjLEVBQUVILGFBQWEsRUFBRS9ILFVBQVUsQ0FBQyxFQUFFO2NBRWxGQyxZQUFZLENBQUNvSSxpQkFBaUIsRUFBRTs7WUFJcEMsSUFBSSxDQUFDOUcsV0FBVyxDQUFDRixPQUFPLEVBQUU7Y0FFdEJvQixjQUFjLENBQUMsZUFBZSxDQUFDO2FBRWxDLE1BQU07Y0FFSEEsY0FBYyxDQUFDLFFBQVEsQ0FBQzs7VUFJaEMsQ0FBQztVQUVEeEMsWUFBWSxDQUFDd0osT0FBTyxDQUFDRCxhQUFhLEVBQUU1QixzQkFBc0IsRUFBRTVILFVBQVUsQ0FBQztVQUV2RTs7TUFHSixLQUFLLFFBQVE7UUFBRTtVQUVYLElBQUksQ0FBQ3dCLFlBQVksQ0FBQ0gsT0FBTyxJQUFJLENBQUNFLFdBQVcsQ0FBQ0YsT0FBTyxFQUFDO1lBRTlDLElBQUlJLGtCQUFrQixDQUFDSixPQUFPLEVBQUU7Y0FFNUJvQixjQUFjLENBQUMsbUJBQW1CLENBQUM7YUFFdEMsTUFBTTtjQUVIQSxjQUFjLENBQUMsc0JBQXNCLENBQUM7O1dBSTdDLENBQUM7VUFFRjs7TUFHSixLQUFLLGlCQUFpQjtRQUFFO1VBRXBCLElBQVFpSCxPQUFPLEdBQUtsRSxnQkFBZ0IsQ0FBNUJrRSxPQUFPO1VBRWZBLE9BQU8sQ0FBQ0MseUJBQXlCLEdBQUcsSUFBSTtVQUV4QztVQUNBRCxPQUFPLENBQUNFLCtCQUErQixHQUFHLElBQUk7VUFDOUNGLE9BQU8sQ0FBQ0cscUJBQXFCLEdBQUcsS0FBSyxFQUFDO1VBRXRDLElBQUlwRSxhQUFhLENBQUNxRSxXQUFXLEVBQUU7WUFFM0JySCxjQUFjLENBQUMscUJBQXFCLENBQUMsRUFBQztXQUV6QyxNQUFNO1lBRUhBLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQzs7VUFJdEM7O01BSUo7TUFFQTs7Ozs7OztNQU9BLEtBQUssYUFBYTtNQUNsQixLQUFLLHNCQUFzQjtNQUMzQixLQUFLLG1CQUFtQjtNQUN4QixLQUFLLFVBQVU7TUFDZixLQUFLLGVBQWU7TUFDcEIsS0FBSyxlQUFlO01BQ3BCLEtBQUssa0JBQWtCO01BQ3ZCLEtBQUssc0JBQXNCO01BQzNCLEtBQUssT0FBTztNQUNaLEtBQUssYUFBYTtNQUNsQixLQUFLLFFBQVE7UUFBRTtVQUVYLElBQUlsQixXQUFXLENBQUNGLE9BQU8sRUFBRTtZQUNyQm9CLGNBQWMsQ0FBQyxRQUFRLENBQUM7WUFDeEI7O1VBR0osSUFBTXNILGNBQWEsR0FBR3JFLGNBQWMsQ0FBQ3NFLE9BQU87VUFFNUNELGNBQWEsQ0FBQ0UsbUJBQW1CLEdBQUcsRUFBRTtVQUN0Q0YsY0FBYSxDQUFDRyxtQkFBbUIsR0FBRyxFQUFFO1VBRXRDLElBQVFqSixPQUFNLEdBQUtnRSw0QkFBNEIsQ0FBQzVELE9BQU8sQ0FBL0NKLE1BQU07VUFFZHVFLGdCQUFnQixDQUFDOEIscUJBQXFCLENBQUNLLFVBQVUsRUFBRTtVQUNuRG5DLGdCQUFnQixDQUFDNkIsZUFBZSxDQUFDTSxVQUFVLEVBQUU7VUFFN0MsSUFBSTFHLE9BQU0sSUFBSSxVQUFVLEVBQUU7WUFBRTtZQUV4QjtZQUNDdUIsV0FBVyxJQUFJLGtCQUFrQixJQUFLbUQsYUFBYSxDQUFDd0UsNEJBQTRCLEVBQUU7O1VBSXZGLElBQUkzSCxXQUFXLElBQUksUUFBUSxFQUFFO1lBQ3pCdkMsWUFBWSxDQUFDdUcsVUFBVSxFQUFFOztVQUc3QjtVQUNBZCxjQUFjLENBQUMwRSxnQkFBZ0IsQ0FBRTVILFdBQVcsQ0FBRTtVQUU5QyxJQUFJQSxXQUFXLElBQUksZUFBZSxFQUFFO1lBRWhDZixrQkFBa0IsQ0FBQ0osT0FBTyxHQUFHLElBQUk7O1VBSXJDO1VBQ0EsSUFBUXZCLE1BQUssR0FBS21GLDRCQUE0QixDQUFDNUQsT0FBTyxDQUE5Q3ZCLEtBQUs7VUFDYixJQUFJQSxNQUFLLElBQUksUUFBUSxFQUFFO1lBRW5CLElBQU1vSSxjQUFjLEdBQUd4QyxjQUFjLENBQUN5QyxpQkFBaUIsRUFBRTtZQUV6RCxJQUFRckQsa0JBQWtCLEdBQUtjLGNBQWMsQ0FBQ2tDLFNBQVMsQ0FBL0NoRCxrQkFBa0I7WUFFMUIsSUFBSWlELGFBQWE7WUFDakIsSUFBSWpELGtCQUFrQixFQUFFO2NBQ3BCaUQsYUFBYSxHQUFHLHVCQUFDQyxVQUFVLEVBQUk7Z0JBRTNCbEQsa0JBQWtCLENBQUMsdUJBQXVCLEVBQUNrRCxVQUFVLENBQUM7Y0FFMUQsQ0FBQzs7WUFJTCxJQUFJL0gsWUFBWSxDQUFDcUksa0JBQWtCLENBQUNKLGNBQWMsRUFBRUgsYUFBYSxDQUFDLEVBQUU7Y0FFaEU5SCxZQUFZLENBQUNvSSxpQkFBaUIsRUFBRTs7O1VBS3hDO1VBQ0EwQixjQUFhLENBQUNNLHFCQUFxQixHQUFHTixjQUFhLENBQUNFLG1CQUFtQjtVQUN2RUYsY0FBYSxDQUFDTyxxQkFBcUIsR0FBR1AsY0FBYSxDQUFDRyxtQkFBbUI7VUFFdkU7VUFDQSxJQUFJakosT0FBTSxJQUFJLFNBQVMsRUFBRTtZQUVyQndCLGNBQWMsQ0FBQyxlQUFlLENBQUM7V0FFbEMsTUFBTTtZQUVIQSxjQUFjLENBQUMsNkJBQTZCLENBQUM7O1VBSWpEOztNQUdKLEtBQUssZUFBZTtRQUFFO1VBQUU7VUFFcEI7VUFDQTtVQUNBK0MsZ0JBQWdCLENBQUM4QixxQkFBcUIsQ0FBQ0csZUFBZSxFQUFFO1VBQ3hEakMsZ0JBQWdCLENBQUM2QixlQUFlLENBQUNJLGVBQWUsRUFBRTtVQUVsRGhGLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFDO1VBRXBDOztNQUdKLEtBQUssbUJBQW1CO1FBQUU7VUFBRTtVQUV4QitDLGdCQUFnQixDQUFDK0UsaUJBQWlCLEVBQUU7VUFFcEM5SCxjQUFjLENBQUMsT0FBTyxDQUFDO1VBRXZCOztNQUlKO01BQ0E7TUFFQTtNQUNBO01BQ0EsS0FBSyxzQkFBc0I7UUFBRTtVQUFFO1VBRTNCaUQsY0FBYyxDQUFDOEUsbUJBQW1CLEVBQUU7VUFFcEMvSCxjQUFjLENBQUMsc0JBQXNCLENBQUM7VUFFdEM7O01BSUosS0FBSyxzQkFBc0I7UUFBRTtVQUFFO1VBRTNCO1VBQ0EsSUFBUTNDLE9BQUssR0FBS3FGLDJCQUEyQixDQUFDOUQsT0FBTyxDQUE3Q3ZCLEtBQUs7VUFDYixJQUFJQSxPQUFLLElBQUksVUFBVSxFQUFFO1lBRXJCNEYsY0FBYyxDQUFDK0UsMEJBQTBCLEVBQUU7O1VBSS9DLElBQVF4SixRQUFNLEdBQUtnRSw0QkFBNEIsQ0FBQzVELE9BQU8sQ0FBL0NKLE1BQU07VUFDZCxJQUFJQSxRQUFNLElBQUksU0FBUyxFQUFFO1lBRXJCdUUsZ0JBQWdCLENBQUM4QixxQkFBcUIsQ0FBQ0csZUFBZSxFQUFFO1lBRXhEO1lBQ0E7WUFDQWhGLGNBQWMsQ0FBQyxPQUFPLENBQUM7V0FFMUIsTUFBTTtZQUFFO1lBRUxBLGNBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQzs7VUFJcEQ7O01BR0o7TUFFQSxLQUFLLDZCQUE2QjtRQUFFO1VBRWhDQSxjQUFjLENBQUMsMEJBQTBCLENBQUM7VUFFMUM7O01BSUosS0FBSywwQkFBMEI7UUFBRTtVQUU3QmlJLFVBQVUsQ0FBQyxZQUFLO1lBRVosSUFBSXBKLFlBQVksQ0FBQ0QsT0FBTyxFQUFFO2NBRXRCcUUsY0FBYyxDQUFDaUYsK0JBQStCLENBQUMsV0FBVyxDQUFDO2NBRTNEbEksY0FBYyxDQUFDLHlCQUF5QixDQUFDOztVQUlqRCxDQUFDLEVBQUVqQyw2QkFBNkIsQ0FBQztVQUVqQzs7TUFJSixLQUFLLHlCQUF5QjtRQUFFO1VBRTVCaUMsY0FBYyxDQUFDLGVBQWUsQ0FBQztVQUUvQjs7TUFHSjtNQUVBLEtBQUssZ0NBQWdDO1FBQUU7VUFFbkM7VUFFQUEsY0FBYyxDQUFDLDRCQUE0QixDQUFDO1VBRTVDOztNQUlKLEtBQUssNEJBQTRCO1FBQUU7VUFFL0JpSSxVQUFVLENBQUMsWUFBSTtZQUVYaEYsY0FBYyxDQUFDaUYsK0JBQStCLENBQUMsY0FBYyxDQUFDO1lBRTlEbEksY0FBYyxDQUFDLDRCQUE0QixDQUFDO1VBRWhELENBQUMsRUFBQyxDQUFDLENBQUM7VUFFSjs7TUFJSixLQUFLLDRCQUE0QjtRQUFFO1VBRS9CO1VBQ0ErQyxnQkFBZ0IsQ0FBQzhCLHFCQUFxQixDQUFDRyxlQUFlLEVBQUU7VUFDeERqQyxnQkFBZ0IsQ0FBQ2tFLE9BQU8sQ0FBQ0UsK0JBQStCLEdBQUcsS0FBSztVQUVoRW5ILGNBQWMsQ0FBQyxPQUFPLENBQUM7VUFFdkI7O01BSUo7TUFFQTtNQUNBLEtBQUssdUJBQXVCO1FBQUU7VUFBRTtVQUU1QnNILGFBQWEsQ0FBQ00scUJBQXFCLEdBQUdOLGFBQWEsQ0FBQ0UsbUJBQW1CO1VBQ3ZFRixhQUFhLENBQUNPLHFCQUFxQixHQUFHUCxhQUFhLENBQUNHLG1CQUFtQjtVQUV2RSxJQUFRVSwyQkFBMkIsR0FBSzNLLFlBQVksQ0FBNUMySywyQkFBMkI7VUFFbkMsSUFBSUEsMkJBQTJCLElBQUlBLDJCQUEyQixDQUFDQyxNQUFNLEVBQUU7WUFBQSwyQ0FFaERELDJCQUEyQjtjQUFBO1lBQUE7Y0FBOUMsb0RBQWdEO2dCQUFBLElBQXJDRSxJQUFJO2dCQUVYN0ssWUFBWSxDQUFDOEsscUJBQXFCLENBQUNELElBQUksQ0FBQ0UsV0FBVyxFQUFFRixJQUFJLENBQUNHLE1BQU0sQ0FBQzs7WUFFcEU7Y0FBQTtZQUFBO2NBQUE7WUFBQTtZQUNEaEwsWUFBWSxDQUFDb0ksaUJBQWlCLEVBQUU7O1VBSXBDNUYsY0FBYyxDQUFDLE9BQU8sQ0FBQztVQUV2Qjs7TUFHSixLQUFLLFlBQVk7UUFBRTtVQUVmaUQsY0FBYyxDQUFDd0YsV0FBVyxFQUFFO1VBQzVCbkIsYUFBYSxDQUFDTSxxQkFBcUIsR0FBRyxFQUFFO1VBQ3hDTixhQUFhLENBQUNPLHFCQUFxQixHQUFHLEVBQUU7VUFDeENySyxZQUFZLENBQUN1RyxVQUFVLEVBQUU7VUFDekIvRCxjQUFjLENBQUMsT0FBTyxDQUFDO1VBRXZCOztJQUNIO0VBSVQsQ0FBQyxFQUFDLENBQUNELFdBQVcsQ0FBQyxDQUFDO0VBRWhCO0VBQ0EscUJBQVMsRUFBQyxZQUFJO0lBRVYsUUFBUUEsV0FBVztNQUVmO01BQ0E7TUFDQSxLQUFLLHFCQUFxQjtRQUFFO1FBQ3hCO01BRUosS0FBSywyQkFBMkI7UUFBRTtRQUM5QkMsY0FBYyxDQUFDLHFCQUFxQixDQUFDO1FBQ3JDO01BRUosS0FBSyxPQUFPO1FBQUU7UUFFVjtJQUFLO0VBSWpCLENBQUMsRUFBQyxDQUFDRCxXQUFXLENBQUMsQ0FBQztFQUVoQjtFQUVBLElBQU0ySSx3QkFBd0IsR0FBR3hGLGFBQWEsQ0FBQ0ksa0JBQWtCLENBQUNxRix3QkFBd0I7RUFDMUYsSUFBTUMsY0FBYyxHQUFHLGtCQUFNLEVBQUNGLHdCQUF3QixDQUFDO0VBQ3ZELElBQU1HLGlCQUFpQixHQUFHLG1CQUFPLEVBQUMsWUFBSztJQUNuQyxJQUFJLENBQUMsQ0FBQywyQkFBMkIsRUFBQyxxQkFBcUIsRUFBQyxrQkFBa0IsQ0FBQyxDQUFDQyxRQUFRLENBQUMvSSxXQUFXLENBQUMsRUFBRTtNQUMvRixPQUFPLElBQUk7O0lBRWYsSUFBSTJJLHdCQUF3QixJQUFJRSxjQUFjLENBQUNoSyxPQUFPLEVBQUU7TUFDcERnSyxjQUFjLENBQUNoSyxPQUFPLEdBQUc4Six3QkFBd0I7TUFDakQsSUFBUXZHLDBCQUEwQixHQUFLZ0IsY0FBYyxDQUFDa0MsU0FBUyxDQUF2RGxELDBCQUEwQjtNQUNsQ0EsMEJBQTBCLElBQUlBLDBCQUEwQixDQUFDdUcsd0JBQXdCLENBQUM7O0lBR3RGLElBQUksQ0FBQ2hMLGdCQUFnQixFQUFFLE9BQU8sSUFBSTtJQUNsQyxJQUFNcUwsV0FBVyxHQUFHO01BQ2hCQyxHQUFHLEVBQUN0SixrQkFBa0IsQ0FBQ3NKLEdBQUcsR0FBRyxDQUFDO01BQzlCQyxJQUFJLEVBQUN2SixrQkFBa0IsQ0FBQ3VKLElBQUksR0FBRyxDQUFDO01BQ2hDUCx3QkFBd0IsRUFBeEJBLHdCQUF3QjtNQUN4QjdMLFFBQVEsRUFBUkEsUUFBUTtNQUNSTSxNQUFNLEVBQU5BO0tBQ0g7SUFDRCxPQUFPNEwsV0FBVztFQUN0QixDQUFDLEVBQ0csQ0FDSWhKLFdBQVcsRUFDWEwsa0JBQWtCLEVBQ2xCZ0osd0JBQXdCLEVBQ3hCN0wsUUFBUSxFQUNSTSxNQUFNLEVBQ05PLGdCQUFnQixDQUNuQixDQUNKO0VBRUQsSUFBTTRKLGFBQWEsR0FBR3JFLGNBQWMsQ0FBQ3NFLE9BQU87RUFFNUMsSUFBTTJCLDBCQUEwQixHQUFHLGtCQUFNLEVBQUMsSUFBSSxDQUFDO0VBQy9DQSwwQkFBMEIsQ0FBQ3RLLE9BQU8sR0FBRyxtQkFBTyxFQUFDLFlBQUk7SUFFN0MsT0FBTyxDQUNIcEM7TUFDSTJNLEdBQUcsRUFBRyxNQUFNO01BQUEsYUFDQSxhQUFhO01BQ3pCQyxLQUFLLEVBQUl2QywrQkFBK0I7TUFDeEN3QyxHQUFHLEVBQUloSjtJQUFvQyxFQUV6QyxFQUNON0Q7TUFDSTJNLEdBQUcsRUFBRyxNQUFNO01BQUEsYUFDQSxhQUFhO01BQ3pCQyxLQUFLLEVBQUl0QywrQkFBK0I7TUFDeEN1QyxHQUFHLEVBQUkvSTtJQUFvQyxFQUV6QyxDQUNUO0VBRUwsQ0FBQyxFQUFDLENBQ0V1RywrQkFBK0IsRUFDL0JDLCtCQUErQixDQUNsQyxDQUFDO0VBRUYsSUFBTXdDLGVBQWUsR0FBRyxrQkFBTSxFQUFDO0lBQzNCN0cscUJBQXFCLEVBQXJCQSxxQkFBcUI7SUFDckJqRixZQUFZLEVBQVpBLFlBQVk7SUFDWjJILHNCQUFzQixFQUF0QkEsc0JBQXNCO0lBQ3RCNUMscUJBQXFCLEVBQUNZLGNBQWMsQ0FBQ2tDLFNBQVMsQ0FBQzlDLHFCQUFxQjtJQUNwRTFFLG9CQUFvQixFQUFwQkEsb0JBQW9CO0lBQ3BCcUwsMEJBQTBCLEVBQTFCQTtHQUNILENBQUM7RUFHRjtFQUNBLE9BQU8xTSxpQ0FBQ0QscUJBQWEsQ0FBQ2dOLFFBQVE7SUFBQ0MsS0FBSyxFQUFLRixlQUFlLENBQUMxSztFQUFPLEdBRTFELENBQUMsMkJBQTJCLEVBQUMscUJBQXFCLENBQUMsQ0FBQ2tLLFFBQVEsQ0FBQy9JLFdBQVcsQ0FBQyxHQUN2RXJDLGdCQUFnQixHQUFDbEIsaUNBQUNpTiwwQkFBYTtJQUMzQlQsR0FBRyxFQUFLSCxpQkFBaUIsQ0FBQ0csR0FBRztJQUM3QkMsSUFBSSxFQUFLSixpQkFBaUIsQ0FBQ0ksSUFBSTtJQUMvQlMsTUFBTSxFQUFLYixpQkFBaUIsQ0FBQ0gsd0JBQXdCO0lBQ3JEN0wsUUFBUSxFQUFLZ00saUJBQWlCLENBQUNoTSxRQUFRO0lBQ3ZDTSxNQUFNLEVBQUswTCxpQkFBaUIsQ0FBQzFMO0VBQU0sRUFDckMsR0FBQyxJQUFJLEdBQ1BYO0lBQUEsYUFDZ0IsYUFBYTtJQUN6QjRNLEtBQUssRUFBS3pDLGVBQWU7SUFDekIwQyxHQUFHLEVBQUtqSjtFQUFvQixHQUUxQnpDLFFBQVE7RUFBRTtFQUNSbkI7SUFBQSxhQUNnQixnQkFBZ0I7SUFDNUI0TSxLQUFLLEVBQUt4QztFQUFrQixFQUUxQixHQUNOLElBQUksRUFFUnBLO0lBQUEsYUFFZ0IsTUFBTTtJQUNsQjZNLEdBQUcsRUFBS25KLG9CQUFvQjtJQUM1QmtKLEtBQUssRUFBSzNDO0VBQWUsR0FJdkIxRyxXQUFXLElBQUksT0FBTyxHQUNwQnVILGFBQWEsQ0FBQ00scUJBQXFCLEdBQ25DLElBQUksQ0FHTixFQUNOcEw7SUFBQSxhQUVnQixNQUFNO0lBQ2xCNk0sR0FBRyxFQUFLbEosb0JBQW9CO0lBQzVCaUosS0FBSyxFQUFLMUM7RUFBZSxHQUl2QjNHLFdBQVcsSUFBSSxPQUFPLEdBQ3BCdUgsYUFBYSxDQUFDTyxxQkFBcUIsR0FDbkMsSUFBSSxDQUdOLENBQ0osQ0FHVztBQUU3QixDQUFDLEVBQUM7QUFFRnRMLGtCQUFBQSxHQUFlRyxNQUFNO0FBRXJCO0FBRUEsSUFBTW9HLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBaUIsQ0FBSUYsZ0JBQWdCLEVBQUk7RUFFM0MsSUFBTStHLGFBQWEsR0FBRyxTQUFoQkEsYUFBYSxDQUFHQyxPQUFPO0lBQUEsT0FBSSxJQUFJQSxPQUFPLENBQUNoSCxnQkFBZ0IsQ0FBQztFQUFBO0VBRTlELElBQVFwRixZQUFZLEdBQUtvRixnQkFBZ0IsQ0FBQ0osNEJBQTRCLENBQUM1RCxPQUFPLENBQXRFcEIsWUFBWTtFQUVwQkEsWUFBWSxDQUFDb0YsZ0JBQWdCLEdBQUdBLGdCQUFnQjtFQUVoRCxPQUFPO0lBRUhwRixZQUFZLEVBQVpBLFlBQVk7SUFDWnVGLGdCQUFnQixFQUFDNEcsYUFBYSxDQUFDRSw2QkFBZ0IsQ0FBQztJQUNoRDdHLGFBQWEsRUFBQzJHLGFBQWEsQ0FBQ0csMEJBQWEsQ0FBQztJQUMxQ0MsWUFBWSxFQUFDSixhQUFhLENBQUNLLHlCQUFZLENBQUM7SUFDeEMvRyxjQUFjLEVBQUMwRyxhQUFhLENBQUNNLDJCQUFjLENBQUM7SUFDNUMvRyxhQUFhLEVBQUN5RyxhQUFhLENBQUNPLDBCQUFhLENBQUM7SUFDMUMvRyxjQUFjLEVBQUN3RyxhQUFhLENBQUNRLDJCQUFjLENBQUM7SUFDNUMvRyxhQUFhLEVBQUN1RyxhQUFhLENBQUNTLDBCQUFhO0dBRTVDO0FBRUwsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvQ3JhZGxlLnRzeD83MTk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyYWRsZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIENyYWRsZSBkb2VzIHRoZSBidWxrIG9mIHRoZSB3b3JrIGZvciB0aGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlci4gSXQgZG9lcyBzbyB3aXRoIHRoZSBoZWxwIG9mXG4gICAgZWlnaHQgcHJvY2VzcyBoYW5kbGVycyAoY2xhc3MgaW5zdGFuY2VzKSwgYW5kIG9uZSBtYWluIHN1Yi1jb21wb25lbnQgLSB0aGUgQ2VsbEZyYW1lLlxuXG4gICAgQ3JhZGxlJ3MgbWFpbiByZXNwb25zaWJpbGl0eSBpcyB0byBtYW5hZ2UgdGhlIH4zMCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBzeXN0ZW0uXG5cbiAgICBUaGUgaWxsdXNpb24gb2YgaW5maW5pdGUgY29udGVudCBpcyBtYWludGFpbmVkIGJ5IHN5bmNocm9uaXppbmcgY2hhbmdlcyBpbiBjcmFkbGUgY29udGVudCB3aXRoIHRoZVxuICAgIENyYWRsZSBsb2NhdGlvbiBpbnNpZGUgdGhlIFNjcm9sbGJsb2NrLCBzdWNoIHRoYXQgYXMgdGhlIFNjcm9sbGJsb2NrIGlzIG1vdmVkLCB0aGUgY3JhZGxlIG1vdmVzIFxuICAgIG9wcG9zaXRlbHkgdG8gc3RheSB2aXNpYmxlIHdpdGhpbiB0aGUgdmlld3BvcnQuXG5cbiAgICBUaGUgU2Nyb2xsYmxvY2sgaXMgc2l6ZWQgdG8gYXBwcm94aW1hdGUgdGhlIGxpc3QgYmVpbmcgdmlld2VkLCBzbyBhcyB0byBoYXZlIGEgc2Nyb2xsIHRodW1iIHNpemUgXG4gICAgYW5kIHBvc2l0aW9uIHdoaWNoIHJlYWxpc3RpY2FsbHkgcmVmbGVjdHMgdGhlIHNpemUgb2YgdGhlIGxpc3QgYmVpbmcgc2hvd24uXG5cbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGNyYWRsZSBpcyBjb250cm9sbGVkIGJ5IGFuICdheGlzJyB3aGljaCBpcyBhIDBweCBoZWlnaHQvd2lkdGggZGl2XG4gICAgKGFsb25nIHRoZSBtZWRpYWwgLSBTY3JvbGxCbG9jayBjYW4gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCkuIFRoZSBwdXJwb3NlIG9mIHRoZSBheGlzIGlzIHRvIFxuICAgIGFjdCBhcyBhICdmb2xkJywgYWJvdmUgd2hpY2ggY3JhZGxlIGNvbnRlbnQgZXhwYW5kcyAnaGVhZHdhcmRzJyAodXAgb3IgbGVmdCkgaW4gdGhlIENyYWRsZSwgYW5kIFxuICAgIGJlbG93IHdoaWNoIHRoZSBjcmFkbGUgY29udGVudCBleHBhbmRzICd0YWlsd2FyZHMnIChkb2VuIG9yIHJpZ2h0KS4gVGhlIENyYWRsZSBjb250ZW50IGlzIGhlbGQgaW4gXG4gICAgdHdvIENTUyBncmlkcyAoY2hpbGRyZW4gb2YgdGhlIGF4aXMpOiBvbmUgYWJvdmUgb3IgbGVmdCAodGhlICdoZWFkJyBncmlkKSwgYW5kIG9uZSBiZWxvdyBvciByaWdodCwgXG4gICAgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBheGlzICh0aGUgJ3RhaWwnIGdyaWQpLlxuXG4gICAgVGhlIGF4aXMgaXMga2VwdCBuZWFyIHRoZSBsZWFkaW5nIChoZWFkd2FyZCkgZWRnZSBvZiB0aGUgdmlzaWJsZSBjZWxsIHJvd3Mgb2YgdGhlIFZpZXdwb3J0XG5cbiAgICBUZWNobmljYWxseSwgdGhlcmUgYXJlIHNldmVyYWwga2V5IHJlZmVyZW5jZSBwb2ludHMgdHJhY2tlZCBieSB0aGUgQ3JhZGxlLiBUaGVzZSBhcmU6XG4gICAgICAgIC0gYXhpc1JlZmVyZW5jZUluZGV4IGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIHRoZSBpdGVtIGNvbnRyb2xsaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgYXhpcy5cbiAgICAgICAgICAgIFRoZSBheGlzUmVmZXJlbmNlSW5kZXggaXMgYWxzbyB1c2VkIHRvIGFsbG9jYXRlIGl0ZW1zIGFib3ZlIChsb3dlciBpbmRleCB2YWx1ZSkgYW5kIGJlbG93IFxuICAgICAgICAgICAgKHNhbWUgb3IgaGlnaGVyIGluZGV4IHZhbHVlKSB0aGUgYXhpcyBmb2xkLiBUaGUgYXhpc1JlZmVybmNlSW5kZXggaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIFxuICAgICAgICAgICAgdGFpbCBzZWN0aW9uIG9mIHRoZSBDcmFkbGUuXG4gICAgICAgIC0gKGNyYWRsZVJlZmVyZW5jZUluZGV4IGlzIGluZmVycmVkIGZyb20gdGhlIGF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIFxuICAgICAgICAgICAgdGhlIGl0ZW0gZGVmaW5pbmcgdGhlIGxlYWRpbmcgYm91bmQgb2YgdGhlIGNyYWRsZSBjb250ZW50LiBUaGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdXN1YWxseSBcbiAgICAgICAgICAgIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBoZWFkIHNlY3Rpb24gb2YgdGhlIENyYWRsZSwgdW5sZXNzIHRoZSBjcmFkbGUgc2hvd3MgdGhlIHZlcnkgdG9wIG9mIHRoZVxuICAgICAgICAgICAgbGlzdCwgaW4gd2hpY2ggY2FzZSB0aGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIEF4aXNSZWZlcmVuY2VJbmRleClcbiAgICAgICAgLSBheGlzVmlld3BvcnRQaXhlbE9mZnNldCAocGl4ZWxzIHRoYXQgcGxhY2UgdGhlIGF4aXMgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0J3MgbGVhZGluZyBlZGdlKVxuICAgICAgICAtIHRoZSBibG9ja1Njcm9sbFBvcywgd2hpY2ggaXMgdGhlIGFtb3VudCBvZiBzY3JvbGwgKFZpZXdwb3J0IHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0KSBvZiB0aGUgXG4gICAgICAgICAgICBTY3JvbGxCbG9ja1xuICAgIFxuICAgIE92ZXJzY3JvbGwgaGFuZGxpbmcgKHJlcG9zaXRpb25pbmcpOlxuICAgICAgICBPd2luZyB0byB0aGUgcG90ZW50aWFsIHJhcGlkaXR5IG9mIHNjcm9sbGluZywgd2hpY2ggaW4gdGhlIGNhc2Ugb2YgbGFyZ2UgbGlzdHMgYW5kIGhlYXZ5IGNvbnRlbnQgXG4gICAgICAgIGNhbiBiZSB0b28gZmFzdCBmb3IgdGhlIHN5c3RlbSB0byBrZWVwIHVwLCB0aGVyZSBpcyBhbiBvdmVyc2Nyb2xsIHByb3RvY29sIGNhbGxlZCAncmVwb3NpdGlvbmluZycuXG5cbiAgICAgICAgSWYgdGhlIG92ZXJzY3JvbGwgaXMgc3VjaCB0aGF0IHRoZSBjcmFkbGUgKGluY2x1ZGluZyBpdHMgdHdvIGNvbnRlbnQgZ3JpZHMpIGhhcyBlbnRpcmVseSBwYXNzZWQgXG4gICAgICAgIG91dCBvZiB0aGUgdmlld3BvcnQsIHRoZW4gdGhlIENyYWRsZSBjb21wb25lbnQgaXMgcmVwbGFjZWQgYnkgYSBTY3JvbGxUcmFja2VyIChvciBieSBudWxsIGlmIFxuICAgICAgICB0aGUgaG9zdCB0YWtlcyByZXNwb25zaWJpbGl0eSBmb3IgZmVlZGJhY2spLiBUaGUgU2Nyb2xsVHJhY2tlciBkaXNwbGF5cyB0byB0aGUgdXNlciB0aGUgcmVsYXRpdmUgXG4gICAgICAgIGxvY2F0aW9uIGluIHRoZSB2aXJ0dWFsIGxpc3QgYXQgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGR1cmluZyByZXBvc2l0aW9uaW5nLiBXaGVuIHRoZSBzY3JvbGxpbmdcbiAgICAgICAgc3RvcHMgQ3JhZGxlIHJlY3JlYXRlcyB0aGUgY3JhZGxlIGNvbnRlbnQsIGFjY29yZGluZyB0byB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIHJlcG9zaXRpb25pbmcgXG4gICAgICAgIHByb2Nlc3MuXG5cbiAgICBDcmFkbGUgY2hhbmdlcyBhcmUgYWN0aXZhdGVkIGJ5IGludGVycnVwdHM6XG4gICAgLSBzY3JvbGxpbmdcbiAgICAtIHJlc2l6aW5nIG9mIHRoZSB2aWV3cG9ydFxuICAgIC0gb2JzZXJ2ZXIgY2FsbGJhY2tzOlxuICAgICAgICAtIGNyYWRsZS92aWV3cG9ydCBpbnRlcnNlY3Rpb24gZm9yIHJlcG9zaXRpb25pbmcgd2hlbiB0aGUgY3JhZGxlIHJhY2VzIG91dCBvZiBzY29wZVxuICAgICAgICAtIHR3byAndHJpZ2dlcmxpbmUnL3ZpZXdwb3J0IGludGVyc2VjdGlvbnMgd2hpY2ggdHJpZ2dlciByb2xsaW5nIG9mIGNvbnRlbnRcbiAgICAgICAgICAgIC0gcm9sbGluZyBjb250ZW50IHRyaWdnZXJzIHJlLWFsbG9jYXRpb24gb2YgY29udGVudCBiZXR3ZWVuIGNyYWRsZSBoZWFkIGFuZCB0YWlsIGdyaWRzXG4gICAgLSBwaXZvdCAtIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIC0gaG9zdCBjaGFuZ2VzIG9mIGNvbmZpZ3VyYXRpb24gc3BlY3MgdGhyb3VnaCBwcm9wZXJ0eSBjaGFuZ2VzIG9yIGRpcmVjdCBzZXJ2aWNlIGNhbGxzXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZVJlZiwgXG4gICAgdXNlQ29udGV4dCwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZU1lbW8sXG4gICAgdXNlQ2FsbGJhY2ssIFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgVmlld3BvcnRDb250ZXh0IH0gZnJvbSAnLi9WaWV3cG9ydCdcblxuLy8gcG9wdXAgcG9zaXRpb24gdHJhY2tlciBmb3IgcmVwb3NpdGlvbmluZ1xuaW1wb3J0IFNjcm9sbFRyYWNrZXIgZnJvbSAnLi9jcmFkbGUvU2Nyb2xsVHJhY2tlcidcblxuLy8gc3VwcG9ydCBjb2RlOyBwcm9jZXNzIGhhbmRsZXJzXG5pbXBvcnQgU2Nyb2xsSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zY3JvbGxoYW5kbGVyJ1xuaW1wb3J0IFN0YXRlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zdGF0ZWhhbmRsZXInXG5pbXBvcnQgQ29udGVudEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvY29udGVudGhhbmRsZXInXG5pbXBvcnQgTGF5b3V0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9sYXlvdXRoYW5kbGVyJ1xuaW1wb3J0IEludGVycnVwdEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvaW50ZXJydXB0aGFuZGxlcidcbmltcG9ydCBTZXJ2aWNlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zZXJ2aWNlaGFuZGxlcidcbmltcG9ydCBTdHlsZXNIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3N0eWxlc2hhbmRsZXInXG4vLyBjYWNoZUhhbmRsZXIgaXMgaW1wb3J0ZWQgYXMgYSBwcm9wZXJ0eTsgaW5zdGFudGlhdGVkIGF0IHRoZSByb290XG5cbmltcG9ydCB7IGlzU2FmYXJpSU9TIH0gZnJvbSAnLi9JbmZpbml0ZUdyaWRTY3JvbGxlcidcblxuLy8gZm9yIGNoaWxkcmVuXG5leHBvcnQgY29uc3QgQ3JhZGxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuLy8gY29tcG9uZW50XG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ3JpZFNwZWNzLFxuICAgICAgICAvLyBiYXNpY3NcbiAgICAgICAgcnVud2F5U2l6ZSwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgc3RhcnRpbmdJbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgIHVzZXJDYWxsYmFja3MsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBjYWNoZU1heCxcbiAgICAgICAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICAvLyBmb3IgaGFuZGxlciBsaXN0XG4gICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgLy8gc3lzdGVtXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyLFxuICAgICAgICBzaG93QXhpcyxcbiAgICAgICAgT05BRlRFUlNDUk9MTF9USU1FT1VULFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLFxuICAgICAgICBWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCxcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLFxuXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBEQVRBIFNFVFVQIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVucGFjayBncmlkU3BlY3NcbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGxheW91dCxcblxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIC8vIGdldCB2aWV3cG9ydCBjb250ZXh0XG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHVzZUNvbnRleHQoVmlld3BvcnRDb250ZXh0KVxuXG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgLy8gZm9yIGNsb3N1cmVzXG5cbiAgICAvLyBmbGFnc1xuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuICAgIGNvbnN0IGlzQ2FjaGVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHdhc0NhY2hlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCBoYXNCZWVuUmVuZGVyZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgICAvLyB0cmlnZ2VyIGNvbnRyb2xcbiAgICBjb25zdCB0cmlnZ2VySGlzdG9yeVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHByZXZpb3VzUmVmZXJlbmNlTmFtZTpudWxsLFxuICAgIH0pXG5cbiAgICAvLyAgdmlld3BvcnQgZGltZW5zaW9ucyBhbmQgY2FjaGVkIHN0YXRlXG4gICAgY29uc3QgZ2V0Vmlld3BvcnREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6dmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OnZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR3byBzb3VyY2VzOyBjb3VsZCB1c2Ugc29tZSByZWNvbmNpbGlhdGlvblxuICAgIGNvbnN0IHsgdmlld3BvcnREaW1lbnNpb25zIH0gPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIC8vIGZvciBzY3JvbGxUcmFja2VyXG4gICAgY29uc3QgeyBoZWlnaHQ6dmlld3BvcnRoZWlnaHQsd2lkdGg6dmlld3BvcnR3aWR0aCB9ID0gZ2V0Vmlld3BvcnREaW1lbnNpb25zKCkgLy8gdmlld3BvcnREaW1lbnNpb25zXG5cbiAgICAvLyBjYWNoZSB0ZXN0XG4gICAgLy8gemVybyB3aWR0aCBhbmQgaGVpZ2h0IG1lYW5zIHRoZSBjb21wb25lbnQgbXVzdCBiZSBpbiBwb3J0YWwgKGNhY2hlKSBzdGF0ZVxuICAgIGNvbnN0IGlzSW5Qb3J0YWwgPSAoKHZpZXdwb3J0d2lkdGggPT0gMCkgJiYgKHZpZXdwb3J0aGVpZ2h0ID09IDApKSBcblxuICAgIGNvbnN0IGlzQ2FjaGVDaGFuZ2UgPSAoaXNJblBvcnRhbCAhPSBpc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UpIHtcbiAgICAgICAgd2FzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0NhY2hlZFJlZi5jdXJyZW50XG4gICAgICAgIGlzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0luUG9ydGFsXG4gICAgfVxuXG4gICAgLy8gY3JhZGxlIHN0YXRlXG4gICAgY29uc3QgW2NyYWRsZVN0YXRlLCBzZXRDcmFkbGVTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuICAgIGNvbnN0IGNyYWRsZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPSBjcmFkbGVTdGF0ZVxuXG4gICAgLy8gaWYgKCFzY3JvbGxlclByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09PiBjcmFkbGVTdGF0ZScsJy0nK3Njcm9sbGVySUQrJy0nLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tIGluZGV4Jyx+JytzY3JvbGxlclByb3BlcnRpZXM/LmNlbGxGcmFtZURhdGFSZWYuY3VycmVudC5pbmRleCsnficpXG4gICAgLy8gfVxuXG4gICAgLy8gY3JhZGxlIHNjYWZmb2xkIGVsZW1lbnQgcmVmc1xuICAgIGNvbnN0IGhlYWRDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdGFpbENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBheGlzQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gbGF5b3V0IGJ1bmRsZVxuICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkUmVmOmhlYWRDcmFkbGVFbGVtZW50UmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWY6dGFpbENyYWRsZUVsZW1lbnRSZWYsIFxuICAgICAgICAgICAgYXhpc1JlZjpheGlzQ3JhZGxlRWxlbWVudFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmOnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmOnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZixcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb25maWd1cmF0aW9uIGNhbGN1bGF0aW9uc1xuXG4gICAgLy8gY3Jvc3Njb3VudCAoYWxzbyBjYWxjdWxhdGVkIGJ5IFNjcm9sbGJsb2NrIGZvciBkZXJpdmluZyBTY3JvbGxibG9jayBsZW5ndGgpXG4gICAgY29uc3QgY3Jvc3Njb3VudCA9IHVzZU1lbW8oKCkgPT4geyAvLyB0aGUgbnVtYmVyIG9mIGNlbGxzIGNyb3NzaW5nIG9yaWVudGF0aW9uXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVybiAwXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRjcm9zc2xlbmd0aCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0d2lkdGg6XG4gICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHRcblxuICAgICAgICAvLyBjcm9zcyBsZW5ndGggb2Ygdmlld3BvcnQgKGdhcCB0byBtYXRjaCBjcm9zc0xlbmd0aClcbiAgICAgICAgY29uc3Qgdmlld3BvcnRjcm9zc2xlbmd0aGZvcmNhbGMgPSB2aWV3cG9ydGNyb3NzbGVuZ3RoIC0gKHBhZGRpbmcgKiAyKSArIGdhcCBcblxuICAgICAgICBjb25zdCBjZWxsY3Jvc3NsZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoOlxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQpIFxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBjZWxsY3Jvc3NsZW5ndGhmb3JjYWxjID0gXG4gICAgICAgICAgICBNYXRoLm1pbihjZWxsY3Jvc3NsZW5ndGgsdmlld3BvcnRjcm9zc2xlbmd0aGZvcmNhbGMpIC8vIHJlc3VsdCBjYW5ub3QgYmUgbGVzcyB0aGFuIDFcblxuICAgICAgICBjb25zdCBjcm9zc2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYy9jZWxsY3Jvc3NsZW5ndGhmb3JjYWxjKVxuXG4gICAgICAgIHJldHVybiBjcm9zc2NvdW50XG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICBdKVxuXG4gICAgLy8gdmFyaW91cyByb3cgY291bnRzXG4gICAgY29uc3QgW1xuICAgICAgICBjcmFkbGVSb3djb3VudCwgXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRMZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoXG5cbiAgICAgICAgbGV0IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsSGVpZ2h0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbFdpZHRoXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBsYXlvdXQgPT0gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxNaW5IZWlnaHRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsTWluV2lkdGhcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBiYXNlUm93TGVuZ3RoICs9IGdhcFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Um93Y291bnQgPSBNYXRoLmNlaWwodmlld3BvcnRMZW5ndGgvYmFzZVJvd0xlbmd0aClcblxuICAgICAgICBjb25zdCBsaXN0Um93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPSB2aWV3cG9ydFJvd2NvdW50ICsgKHJ1bndheVNpemUgKiAyKVxuXG4gICAgICAgIGxldCBjcmFkbGVSb3djb3VudCA9IE1hdGgubWluKGxpc3RSb3djb3VudCwgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50KVxuXG4gICAgICAgIGxldCBydW53YXlSb3djb3VudFxuICAgICAgICBpZiAoY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50ID49IGNyYWRsZVJvd2NvdW50KSB7XG5cbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gcnVud2F5U2l6ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAoY3JhZGxlUm93Y291bnQgLSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCAtPSBNYXRoLmZsb29yKGRpZmYvMilcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gTWF0aC5tYXgoMCxydW53YXlSb3djb3VudClcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW1jb3VudCA9IGNyYWRsZVJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgICAgICBpZiAoaXRlbWNvdW50ID4gbGlzdHNpemUpIHtcblxuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgXVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgLy8gcGFkZGluZyxcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBydW53YXlTaXplLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBsYXlvdXQsXG4gICAgXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGxiYWNrcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gaG9zdCBjYWxsYmFja3MsIHVwYWNrZWQgYnkgc2VydmljZUhhbmRsZXJcbiAgICBjb25zdCBleHRlcm5hbENhbGxiYWNrc1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5yZWZlcmVuY2VJbmRleENhbGxiYWNrLFxuICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5yZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLFxuICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5wcmVsb2FkSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5kZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1bIGJ1bmRsZSBwcm9wZXJ0aWVzIGZvciBoYW5kbGVycyBdLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gYnVuZGxlIGFsbCBjcmFkbGUgcHJvcHMgdG8gcGFzcyB0byBoYW5kbGVycyAtIHVsdGltYXRlbHkgY3JhZGxlUGFyYW1ldGVyc1JlZlxuXG4gICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXMgYW5kIHN1cHBvcnQgY2FsbGJhY2tzXG4gICAgLy8gdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIC8vIGdyaWRTcGVjc1xuICAgICAgICBvcmllbnRhdGlvbiwgZ2FwLCBwYWRkaW5nLCBsYXlvdXQsXG4gICAgICAgIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLFxuICAgICAgICAvLyAuLi5yZXN0XG4gICAgICAgIGNhY2hlLCBjYWNoZU1heCxcbiAgICAgICAgc3RhcnRpbmdJbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBwbGFjZWhvbGRlciwgcGxhY2Vob2xkZXJNZXNzYWdlcywgdXNlUGxhY2Vob2xkZXIsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIHVzZXJDYWxsYmFja3MsIHN0eWxlcywgY2FjaGVIYW5kbGVyLFxuICAgICAgICAvLyBjb250cm9sIHZhbHVlc1xuICAgICAgICBPTkFGVEVSU0NST0xMX1RJTUVPVVQsIE1BWF9DQUNIRV9PVkVSX1JVTiwgXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcblxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbGVyUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHBhc3NlZCB0byBjZWxsRnJhbWUgY29udGVudCAodXNlciBjb250ZW50KSBpZiByZXF1ZXN0ZWRcbiAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb3JpZW50YXRpb24sIGdhcCwgcGFkZGluZywgbGF5b3V0LFxuICAgICAgICBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgfVxuXG4gICAgLy8gY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIHNoYXJlIHdpdGggaGFuZGxlcnNcbiAgICBjb25zdCBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcblxuICAgICAgICAvLyB1cGRhdGVkIHZhbHVlc1xuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG4gICAgICAgIHRyaWdnZXJIaXN0b3J5UmVmLFxuXG4gICAgICAgIC8vIGZvciBzdGF0ZUhhbmRsZXJcbiAgICAgICAgY3JhZGxlU3RhdGVSZWYsXG4gICAgICAgIHNldENyYWRsZVN0YXRlLFxuICAgIH1cblxuICAgIC8vIHBsYWNlaG9sZGVyIGluIGNyYWRsZVBhcmFtZXRlcnMgdG8gbWFrZSBhdmFpbGFibGUgaW5kaXZpZHVhbCBoYW5kbGVyc1xuICAgIGNvbnN0IGhhbmRsZXJzUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBjcmFkbGUgcGFyYW1ldGVycyBNQVNURVIgQlVORExFXG4gICAgY29uc3QgY3JhZGxlUGFyYW1ldGVycyA9IHtcbiAgICAgICAgaGFuZGxlcnNSZWYsXG4gICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGV4dGVybmFsQ2FsbGJhY2tzUmVmLFxuICAgIH1cblxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVQYXJhbWV0ZXJzUmVmLmN1cnJlbnQgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBvbmdvaW5nIHNvdXJjZSBvZiBoYW5kbGVycyAtIG5vdGUgYWxsIEhhbmRsZXJzIGFyZSBnaXZlbiBhbGwgcGFyYW1ldGVycyAoY3JhZGxlUGFyYW1ldGVycylcbiAgICBpZiAoIWhhbmRsZXJzUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICBoYW5kbGVyc1JlZi5jdXJyZW50ID0gZ2V0Q3JhZGxlSGFuZGxlcnMoY3JhZGxlUGFyYW1ldGVycylcblxuICAgIH1cblxuICAgIC8vIG1ha2UgaGFuZGxlcnMgZGlyZWN0bHkgYXZhaWxhYmxlIHRvIGNyYWRsZSBjb2RlIGJlbG93XG4gICAgY29uc3QgeyAvLyBjYWNoZUhhbmRsZXIgYWxyZWFkeSBhdmFpbGFibGVcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgc2Nyb2xsSGFuZGxlcixcbiAgICAgICAgLy8gc3RhdGVIYW5kbGVyLCAvLyBub3QgdXNlZFxuICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgIHN0eWxlc0hhbmRsZXIsXG4gICAgfSA9IGhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09WyBJTlRFUkNFUFQgQ0FDSElORyBTVEFURSBDSEFOR0UgXT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyogICAgXG4gICAgSW50ZXJjZXB0IGNoYW5nZSBpbiBjYWNoaW5nIHN0YXR1czpcbiAgICB3aGVuIGEgY29tcG9uZW50IGlzIGNhY2hlZCBpbiBhIHBvcnRhbCAoaW4gdGhlIFJlYWN0IHZpcnR1YWwgRE9NKSwgaW5jbHVkaW5nIHRoZSB0cmFuc2l0aW9uIG9mIFxuICAgIGJlaW5nIG1vdmVkIGZyb20gb25lIGNlbGxGcmFtZSB0byBhbm90aGVyIHdoZW4gY3Jvc3NpbmcgdGhlIENyYWRsZSBheGlzLCBcbiAgICB0aGUgc2Nyb2xsUG9zIChzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCkgaXMgcmVzZXQgdG8gMCAoemVybykuIFdoZW4gdGhlIHNjcm9sbGVyIGlzIFxuICAgIG1vdmVkIHRvIGEgY2VsbEZyYW1lLCB0aGlzIGNvZGUgdHJpZ2dlcnMgcmVzdG9yYXRpb24gdGhlIHNjcm9sbFBvcyAoc2VlIGNhc2UgJ3BhcmVudGluZ3RyYW5zaXRpb24nXG4gICAgaW4gdGhlIHN0YXRlIG1hbmFnZW1lbnQgc2VjdGlvbiBiZWxvdykuXG5cbiAgICBUaGlzIHN1cHBvcnRzIEluZmluaXRlR3JpZFNjcm9sbGVyIGNvbXBvbmVudHMgdG8gYmUgY2FjaGVkIGFzIGNvbnRlbnQuXG5cbiAgICBUaGUgcmVzdG9yZSBzY3JvbGxQb3MgYWN0aW9uIG11c3QgYmUgdGhlIGZpcnN0IHByaW9yaXR5IHRvIGhpZGUgdGhlc2Ugc2Nyb2xsUG9zIGFkanVzdG1lbnRzXG4gICAgZnJvbSB0aGUgdXNlci5cbiovXG4gICAgXG4gICAgY29uc3QgcmVzdG9yZVNjcm9sbFBvcyA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNvbnN0IGJsb2NrU2Nyb2xsUG9zID0gY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIGNvbnN0IGJsb2NrWFNjcm9sbFBvcyA9IGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3NcbiAgICAgICAgaWYgKGJsb2NrU2Nyb2xsUG9zICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFByb3BlcnR5XSA9IGJsb2NrWFNjcm9sbFBvc1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChpc0NhY2hlQ2hhbmdlICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvcygpICAgICAgICBcblxuICAgIH1cblxuICAgIC8vIGNoYW5nZSBzdGF0ZSBmb3IgZW50ZXJpbmcgb3IgbGVhdmluZyBjYWNoZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVybiAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGludG8gY2FjaGVcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NhY2hlZCcpXG5cbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWNoZWRSZWYuY3VycmVudCAmJiB3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBvdXQgb2YgY2FjaGVcblxuICAgICAgICAgICAgd2FzQ2FjaGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbaXNDYWNoZWRSZWYuY3VycmVudCwgd2FzQ2FjaGVkUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaQVRJT04gZWZmZWN0cyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgYXJlIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcblxuICAgIC8vIGNsZWFyIG1vdW50ZWQgZmxhZyBvbiB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIC8vIHVubW91bnRcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvL3NlbmQgY2FsbC1pbiBmdW5jdGlvbnMgdG8gaG9zdFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICghdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0luZGV4LCBcbiAgICAgICAgICAgIHJlbG9hZCwgXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuXG4gICAgICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgICAgICBtb3ZlSW5kZXgsXG4gICAgICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgICAgIHJlbW92ZUluZGV4LFxuXG4gICAgICAgIH0gPSBzZXJ2aWNlSGFuZGxlclxuXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHtcblxuICAgICAgICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgICAgIHJlbG9hZCxcbiAgICAgICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICAgICAgY2xlYXJDYWNoZSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCxcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgICAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICByZW1vdmVJbmRleCxcblxuICAgICAgICB9XG5cbiAgICAgICAgdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjayhmdW5jdGlvbnMpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc2Nyb2xsIGxpc3RlbmVyc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCAmJiBcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyBpT1MgU2FmYXJpIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmcgLSBpdCBpZ25vcmVzIGFzc2lnbm1lbnRzIHRvIHNjcm9sbExlZnQvc2Nyb2xsVG9wIGR1cmluZyBzY3JvbGxpbmdcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIWlzU2FmYXJpSU9TKCkgfHwgKGxheW91dCA9PSAndW5pZm9ybScpKSByZXR1cm5cblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIuaU9Tb25TY3JvbGwpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50ICYmIFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIuaU9Tb25TY3JvbGwpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIG9ic2VydmVyIHN1cHBvcnRcbiAgICAvKlxuICAgICAgICBUaGVyZSBhcmUgdHdvIGludGVyZWN0aW9uIG9ic2VydmVyczogb25lIGZvciB0aGUgdHdvIGNyYWRsZSBncmlkcywgYW5kIGFub3RoZXIgZm9yIHRyaWdnZXJsaW5lczsgXG4gICAgICAgICAgICBib3RoIGFnYWluc3QgdGhlIHZpZXdwb3J0LlxuICAgICovICAgIFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNyYWRsZUludGVyc2VjdCxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lc0ludGVyc2VjdCxcbiAgICAgICAgfSA9IGludGVycnVwdEhhbmRsZXJcblxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgZm9yIGNyYWRsZSBib2R5XG4gICAgICAgIC8vIHRoaXMgc2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvZiB0aGUgY3JhZGxlIGFnYWluc3QgdGhlIHZpZXdwb3J0LiBXaGVuIHRoZVxuICAgICAgICAvLyBjcmFkbGUgZ29lcyBvdXQgb2YgdGhlIG9ic2VydmVyIHNjb3BlLCB0aGUgJ3JlcG9zaXRpb25pbmdSZW5kZXInIGNyYWRsZSBzdGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGNvbnN0IGNyYWRsZWludGVyc2VjdG9ic2VydmVyID0gY3JhZGxlSW50ZXJzZWN0LmNyZWF0ZU9ic2VydmVyKClcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgLy8gdHJpZ2dlcm9ic2VydmVyIHRyaWdnZXJzIGNyYWRsZSBjb250ZW50IHVwZGF0ZXMgXG4gICAgICAgIC8vICAgICB3aGVuIHRyaWdnZXJsaW5lcyBwYXNzIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAvLyBkZWZlciBjb25uZWN0RWxlbWVudHMgdW50aWwgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzIGhhdmUgYmVlbiBhc3NpZ25lZFxuICAgICAgICBjb25zdCB0cmlnZ2Vyb2JzZXJ2ZXIgPSB0cmlnZ2VybGluZXNJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdHJpZ2dlcm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhbmdlIGxpc3RzaXplLCBjYWNoaW5nLCByZXNpemUgKFVJIHJlc2l6ZSBvZiB0aGUgdmlld3BvcnQpLCByZWNvbmZpZ3VyZSwgb3IgcGl2b3RcblxuICAgIC8vIGluZXJuYWwgY2FsbGJhY2s6IHRoZSBuZXcgbGlzdCBzaXplIHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJyZW50IGxpc3RzaXplXG4gICAgLy8gaW52b2tlZCBpZiBnZXRJdGVtIHJldHVybnMgbnVsbFxuICAgIGNvbnN0IG51bGxJdGVtU2V0TWF4TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobWF4TGlzdHNpemUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdHNpemUgPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5saXN0c2l6ZVxuXG4gICAgICAgIGlmIChtYXhMaXN0c2l6ZSA8IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2dldEl0ZW0gcmV0dXJuZWQgbnVsbCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2hhbmdlTGlzdHNpemUobWF4TGlzdHNpemUsIFxuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjaylcblxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIGNhY2hpbmcgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIGlmIChjYWNoZSA9PSAncHJlbG9hZCcpIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3N0YXJ0cHJlbG9hZCcpXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBzd2l0Y2ggKGNhY2hlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2tlZXBsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1heCA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LmNhY2hlTWF4XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KGNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdHMoKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlY2FjaGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjcmFkbGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjaGFuZ2VjYWNoaW5nJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbY2FjaGUsIGNhY2hlTWF4XSlcblxuICAgIC8vIHRyaWdnZXIgdmlld3BvcnRyZXNpemluZyByZXNwb25zZSBiYXNlZCBvbiB2aWV3cG9ydCBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIC8vIG1vdmVtZW50IHRvIGFuZCBmcm9tIGNhY2hlIGlzIGluZGVwZW5kZW50IG9mIHVpIHZpZXdwb3J0cmVzaXppbmdcbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgfHwgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcpICYmIFxuICAgICAgICAgICAgICAgIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ICE9ICd2aWV3cG9ydHJlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ZpZXdwb3J0cmVzaXppbmcnKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wbGV0ZSB2aWV3cG9ydHJlc2l6aW5nIG1vZGVcbiAgICAgICAgaWYgKCFWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyAmJiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAndmlld3BvcnRyZXNpemluZycpKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h2aWV3cG9ydHJlc2l6ZScpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmddKVxuXG4gICAgLy8gcmVjb25maWd1cmUgZm9yIGNoYW5nZWQgc2l6ZSBwYXJhbWV0ZXJzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVjb25maWd1cmUnKVxuXG4gICAgfSxbXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICBdKVxuXG4gICAgLy8gYSBuZXcgZ2V0SXRlbSBmdW5jdGlvbiBpbXBsaWVzIHRoZSBuZWVkIHRvIHJlbG9hZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbZ2V0SXRlbV0pXG5cbiAgICAvLyBwaXZvdCB0cmlnZ2VyZWQgb24gY2hhbmdlIG9mIG9yaWVudGF0aW9uXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHkgPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpP1xuICAgICAgICAgICAgICAgIFwic2Nyb2xsVG9wXCI6XG4gICAgICAgICAgICAgICAgXCJzY3JvbGxMZWZ0XCJcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQcm9wZXJ0eSA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiKT9cbiAgICAgICAgICAgICAgICBcInNjcm9sbFRvcFwiOlxuICAgICAgICAgICAgICAgIFwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGdhcCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgLy8gZ2V0IHByZXZpb3VzIHJhdGlvXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0NlbGxQaXhlbExlbmd0aCA9IFxuICAgICAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodClcbiAgICAgICAgICAgICAgICArIGdhcFxuXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0F4aXNPZmZzZXQgPSBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c3JhdGlvID0gcHJldmlvdXNBeGlzT2Zmc2V0L3ByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoXG5cbiAgICAgICAgICAgIGNvbnN0IHBpdm90Q2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgICAgIGNvbnN0IHBpdm90QXhpc09mZnNldCA9IHByZXZpb3VzcmF0aW8gKiBwaXZvdENlbGxQaXhlbExlbmd0aFxuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBNYXRoLnJvdW5kKHBpdm90QXhpc09mZnNldClcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBnYXBcblxuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZUF4aXNTdHlsZSxcbiAgICAgICAgY3JhZGxlRGl2aWRlclN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlLFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLmdldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgdXNlcnN0eWxlczpzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgICAgIGxheW91dCxcblxuICAgICAgICB9KVxuXG4gICAgfSxbXG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUQVRFIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZSAoYWJvdXQgMzAgc3RhdGVzKSwgdXNpbmcgbmFtZWQgc3RhdGVzXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGZvciBzdXBwcmVzc2luZyBmbGFzaGVzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29ycyB0byBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhbGwgd29ya2Zsb3cgcmVsYXRlZCwgYnV0XG4gICAgICAgICAgICAvLyByZXNpemUgY291bGQgYmUgYXN5bmNocm9ub3VzIHdoZW4gcm90YXRpbmcgcGhvbmUgZHVyaW5nIHNjcm9sbCBpbnRlcnRpYVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBhc3NpZ25tZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZSAhPSAncHJlbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyJykgLy8gbG9hZCBncmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydHJlc2l6aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgLy8gbm8tb3AsIHdhaXQgZm9yIHJlc2l6aW5nIHRvIGVuZFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cHJlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIucGFyZUNhY2hlVG9NYXgoY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdHMoKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHByZWxvYWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5wcmVsb2FkKGZpbmFsQ2FsbGJhY2ssIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIHNjcm9sbGVySUQpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjYWNoZWQnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXdhc0NhY2hlZFJlZi5jdXJyZW50ICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KXtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB3YWl0IGZvciByZXBhcmVudGluZ1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRyZXBvc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgY3JhZGxlIGludGVyc2VjdGlvbiBpbnRlcnJ1cHRzXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2UgLy8gYmVjYXVzZSBub3cgdW5kZXJ3YXlcblxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxIYW5kbGVyLmlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKSAvLyB0b2dnbGVzIHdpdGggcmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvblxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNocmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldENyYWRsZUNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRoZSBmb2xsb3dpbmcgMTEgY3JhZGxlIHN0YXRlcyBhbGwgcmVzb2x2ZSB3aXRoXG4gICAgICAgICAgICAgICAgYSBjaGFpbiBzdGFydGluZyB3aXRoIHNldENyYWRsZUNvbnRlbnQsIFxuICAgICAgICAgICAgICAgIGNvbnRpbnVpbmcgd2l0aCAncHJlcGFyZXJlbmRlcicsIGFuZCBlbmRpbmcgd2l0aFxuICAgICAgICAgICAgICAgICdyZXN0b3JlaW50ZXJydXB0cycsIHdpdGggYSBkZXRvdXIgZm9yIHZhcmlhYmxlIGxheW91dCBcbiAgICAgICAgICAgICAgICB0byByZWNvbmZpZ3VyZSB0aGUgc2Nyb2xsYmxvY2tcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcmZyb21jYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdyZXJlbmRlcmZyb21jYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdzY3JvbGx0byc6XG4gICAgICAgICAgICBjYXNlICdjaGFuZ2VjYWNoaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHByZWxvYWQnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocmVwb3NpdGlvbic6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2h2aWV3cG9ydHJlc2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdwaXZvdCc6XG4gICAgICAgICAgICBjYXNlICdyZWNvbmZpZ3VyZSc6XG4gICAgICAgICAgICBjYXNlICdyZWxvYWQnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2FjaGVkJylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gY29udGVudEhhbmRsZXIuY29udGVudFxuXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBbXVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScpIHsgLy8gcmVzdG9yZSBiYXNlIGNvbmZpZyB0byBzY3JvbGxibG9ja1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZG9uZSBmb3IgcmVwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAoY3JhZGxlU3RhdGUgIT0gJ2ZpbmlzaHJlcG9zaXRpb24nKSAmJiBsYXlvdXRIYW5kbGVyLnJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnNldENyYWRsZUNvbnRlbnQoIGNyYWRsZVN0YXRlIClcblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSAhPSAnZmluaXNocHJlbG9hZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3luY2hyb25pemUgY2FjaGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09ICdjcmFkbGUnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGN5Y2xlIGZvciBwcmVwYXJlcmVuZGVyXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZpcnR1YWwgRE9NXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVyZW5kZXInOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RFbGVtZW50cyB3YXMgZGVsYXllZCBmb3IgYSBjeWNsZSB0byByZW5kZXIgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3Jlc3RvcmVpbnRlcnJ1cHRzJykgLy8gdG8gcmVzdG9yZSBpbnRlcnJ1cHRzXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZXN0b3JlaW50ZXJydXB0cyc6IHsgLy8gbm9ybWFsaXplXG5cbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnJlc3RvcmVJbnRlcnJ1cHRzKClcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVhayBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBmb2xsb3d1cCBmcm9tIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gc2Nyb2xsIGVmZmVjdHNcblxuICAgICAgICAgICAgLy8gcmVuZGVydXBkYXRlZGNvbnRlbnQgaXMgY2FsbGVkIGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudC4gXG4gICAgICAgICAgICAvLyBpdCBpcyByZXF1aXJlZCB0byBpbnRlZ3JhdGUgY2hhbmdlZCBET00gY29uZmlndXJhdGlvbnMgYmVmb3JlICdyZWFkeScgaXMgZGlzcGxheWVkXG4gICAgICAgICAgICBjYXNlICdyZW5kZXJ1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnVwZGF0ZUNyYWRsZUNvbnRlbnQoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHVwZGF0ZWRjb250ZW50JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNodXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbml6ZSBjYWNoZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5ndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZygpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGxheW91dCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRDcmFkbGVTdGF0ZSgncmVjb25uZWN0dXBkYXRlZGNvbnRlbnQnKVxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJyBjb250ZW50IHJlcXVpcmluZyByZWNvbmZpZ3VyYXRpb25cblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgYWRqdXN0IHNjcm9sbGJsb2NrIGZvciBzZXQgdmFyaWFibGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgY2FzZSAncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVzZXRmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVzZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBnaXZlIHRpbWUgZm9yIERPTSB0byBwcm9kdWNlIGxheW91dFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCdzZXRjcmFkbGUnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNoc2V0Zm9ydmFyaWFiaWxpdHknKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIFZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VUKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNoc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncHJlcGFyZXJlbmRlcicpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBhZGp1c3Qgc2Nyb2xsYmxvY2sgZm9yIHVwZGF0ZSB2YXJpYWJsZSBjb250ZW50IF0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBjYXNlICdyZWZyZXNoRE9NdXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYSBjeWNsZSB0byBhbGxvdyBmb3IgRE9NIHN5bmNocm9uaXppb24gd2l0aCBncmlkIGNoYW5nZXNcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdhZGp1c3R1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+IHsgLy8gYWxsb3cgbW9yZSBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgndXBkYXRlY3JhZGxlJylcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgfSwwKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLVsgdXNlciByZXF1ZXN0cyBdLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciB2YXJpb3VzIGhvc3Qgc2VydmljZSByZXF1ZXN0czsgc3luY3MgY3JhZGxlIGNvbnRlbnQgd2l0aCBjYWNoZSBjaGFuZ2VzXG4gICAgICAgICAgICBjYXNlICdhcHBseWNlbGxmcmFtZWNoYW5nZXMnOiB7IC8vIHVzZXIgaW50ZXJ2ZW50aW9uXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdCB9ID0gY2FjaGVIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBpZiAocG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0ICYmIHBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW1vdmVQYXJ0aXRpb25Qb3J0YWwoaXRlbS5wYXJ0aXRpb25JRCwgaXRlbS5pdGVtSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdHMoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2NsZWFyY2FjaGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5jbGVhckNyYWRsZSgpXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlU3RhdGVdKVxuXG4gICAgLy8gc3RhbmRhcmQgcmVuZGVyaW5nIHN0YXRlcyAoMyBzdGF0ZXMpXG4gICAgdXNlRWZmZWN0KCgpPT4geyBcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmdSZW5kZXIgYW5kIHJlcG9zaXRpb25pbmdDb250aW51YXRpb24gYXJlIHRvZ2dsZWQgdG8gZ2VuZXJhdGUgY29udGludW91cyBcbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmcgcmVuZGVyc1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6IC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6IC8vIHNldCBmcm9tIG9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogLy8gbm8tb3BcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlU3RhdGVdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFJFTkRFUiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXggPSBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICBjb25zdCBzY3JvbGxJbmRleFJlZiA9IHVzZVJlZihzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgpXG4gICAgY29uc3Qgc2Nyb2xsVHJhY2tlckFyZ3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFbJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nLCdyZXBvc2l0aW9uaW5nUmVuZGVyJywnZmluaXNocmVwb3NpdGlvbiddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4ICE9IHNjcm9sbEluZGV4UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNjcm9sbEluZGV4UmVmLmN1cnJlbnQgPSBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHsgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2soc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCF1c2VTY3JvbGxUcmFja2VyKSByZXR1cm4gbnVsbFxuICAgICAgICBjb25zdCB0cmFja2VyYXJncyA9IHtcbiAgICAgICAgICAgIHRvcDp2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgMyxcbiAgICAgICAgICAgIGxlZnQ6dmlld3BvcnREaW1lbnNpb25zLmxlZnQgKyAzLFxuICAgICAgICAgICAgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrZXJhcmdzXG4gICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3JhZGxlU3RhdGUsIFxuICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zLCBcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIsXG4gICAgICAgIF1cbiAgICApXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gY29udGVudEhhbmRsZXIuY29udGVudFxuXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5ID0gJ2hlYWQnXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2hlYWR0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PixcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBrZXkgPSAndGFpbCdcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAndGFpbHRyaWdnZXInXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZX1cbiAgICAgICAgICAgICAgICByZWYgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIF1cblxuICAgIH0sW1xuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlXG4gICAgXSlcblxuICAgIGNvbnN0IGNvbnRleHR2YWx1ZVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsXG4gICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjazpzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MuaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSlcblxuXG4gICAgLy8gZGlzcGxheSB0aGUgY3JhZGxlIGNvbXBvbmVudHMsIHRoZSBTY3JvbGxUcmFja2VyLCBvciBudWxsXG4gICAgcmV0dXJuIDxDcmFkbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBjb250ZXh0dmFsdWVSZWYuY3VycmVudCB9PlxuXG4gICAgICAgIHsoWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSk/XG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MudG9wIH0gXG4gICAgICAgICAgICAgICAgbGVmdCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MubGVmdCB9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3Muc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IH0gXG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnN0eWxlcyB9XG4gICAgICAgICAgICAvPjpudWxsOlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWF4aXMnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZUF4aXNTdHlsZSB9IFxuICAgICAgICAgICAgICAgIHJlZiA9IHsgYXhpc0NyYWRsZUVsZW1lbnRSZWYgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgc2hvd0F4aXM/IC8vIGZvciBkZWJ1Z1xuICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2NyYWRsZS1kaXZpZGVyJyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVEaXZpZGVyU3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0geyBoZWFkQ3JhZGxlRWxlbWVudFJlZiB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVIZWFkU3R5bGUgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHsgdGFpbENyYWRsZUVsZW1lbnRSZWYgfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZVRhaWxTdHlsZSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB7KGNyYWRsZVN0YXRlICE9ICdzZXR1cCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG5cbiAgICA8L0NyYWRsZUNvbnRleHQuUHJvdmlkZXI+XG5cbn0gLy8gQ3JhZGxlXG5cbmV4cG9ydCBkZWZhdWx0IENyYWRsZVxuXG4vLyB1dGlsaXR5XG5cbmNvbnN0IGdldENyYWRsZUhhbmRsZXJzID0gKGNyYWRsZVBhcmFtZXRlcnMpID0+IHtcblxuICAgIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSBoYW5kbGVyID0+IG5ldyBoYW5kbGVyKGNyYWRsZVBhcmFtZXRlcnMpXG5cbiAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgIGNhY2hlSGFuZGxlci5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIGludGVycnVwdEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihJbnRlcnJ1cHRIYW5kbGVyKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNjcm9sbEhhbmRsZXIpLFxuICAgICAgICBzdGF0ZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdGF0ZUhhbmRsZXIpLFxuICAgICAgICBjb250ZW50SGFuZGxlcjpjcmVhdGVIYW5kbGVyKENvbnRlbnRIYW5kbGVyKSxcbiAgICAgICAgbGF5b3V0SGFuZGxlcjpjcmVhdGVIYW5kbGVyKExheW91dEhhbmRsZXIpLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNlcnZpY2VIYW5kbGVyKSxcbiAgICAgICAgc3R5bGVzSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0eWxlc0hhbmRsZXIpLFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWN0XzEiLCJjcmVhdGVDb250ZXh0IiwiQ3JhZGxlIiwiZ3JpZFNwZWNzIiwicnVud2F5U2l6ZSIsImxpc3RzaXplIiwic3RhcnRpbmdJbmRleCIsImdldEl0ZW0iLCJwbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyTWVzc2FnZXMiLCJ1c2VyQ2FsbGJhY2tzIiwic3R5bGVzIiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJjYWNoZSIsImNhY2hlTWF4Iiwic2Nyb2xsZXJJRCIsImNhY2hlSGFuZGxlciIsInVzZVBsYWNlaG9sZGVyIiwidXNlU2Nyb2xsVHJhY2tlciIsInNob3dBeGlzIiwiT05BRlRFUlNDUk9MTF9USU1FT1VUIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCIsInNjcm9sbGVyUHJvcGVydGllcyIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwibGF5b3V0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsImlzTW91bnRlZFJlZiIsImlzQ2FjaGVkUmVmIiwid2FzQ2FjaGVkUmVmIiwiaGFzQmVlblJlbmRlcmVkUmVmIiwidHJpZ2dlckhpc3RvcnlSZWYiLCJwcmV2aW91c1JlZmVyZW5jZU5hbWUiLCJnZXRWaWV3cG9ydERpbWVuc2lvbnMiLCJ2aWV3cG9ydEVsZW1lbnQiLCJlbGVtZW50UmVmIiwid2lkdGgiLCJvZmZzZXRXaWR0aCIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInZpZXdwb3J0RGltZW5zaW9ucyIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsImlzSW5Qb3J0YWwiLCJpc0NhY2hlQ2hhbmdlIiwiY3JhZGxlU3RhdGUiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaGVhZENyYWRsZUVsZW1lbnRSZWYiLCJ0YWlsQ3JhZGxlRWxlbWVudFJlZiIsImF4aXNDcmFkbGVFbGVtZW50UmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmIiwiY3JhZGxlRWxlbWVudHNSZWYiLCJoZWFkUmVmIiwidGFpbFJlZiIsImF4aXNSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmIiwiY3Jvc3Njb3VudCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGgiLCJ2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYyIsImNlbGxjcm9zc2xlbmd0aCIsImNlbGxjcm9zc2xlbmd0aGZvcmNhbGMiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJ2aWV3cG9ydExlbmd0aCIsImJhc2VSb3dMZW5ndGgiLCJ2aWV3cG9ydFJvd2NvdW50IiwiY2VpbCIsImxpc3RSb3djb3VudCIsImNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJkaWZmIiwibWF4IiwiaXRlbWNvdW50IiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsInJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3JhZGxlUGFyYW1ldGVycyIsImNyYWRsZVBhcmFtZXRlcnNSZWYiLCJnZXRDcmFkbGVIYW5kbGVycyIsImludGVycnVwdEhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwiY29udGVudEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJzdHlsZXNIYW5kbGVyIiwicmVzdG9yZVNjcm9sbFBvcyIsImNyYWRsZVBvc2l0aW9uRGF0YSIsImJsb2NrU2Nyb2xsUG9zIiwiYmxvY2tYU2Nyb2xsUG9zIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImJsb2NrWFNjcm9sbFByb3BlcnR5IiwiZnVuY3Rpb25zQ2FsbGJhY2siLCJzY3JvbGxUb0luZGV4IiwicmVsb2FkIiwic2V0TGlzdHNpemUiLCJjbGVhckNhY2hlIiwiZ2V0Q2FjaGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsImdldENyYWRsZUluZGV4TWFwIiwicmVtYXBJbmRleGVzIiwibW92ZUluZGV4IiwiaW5zZXJ0SW5kZXgiLCJyZW1vdmVJbmRleCIsImZ1bmN0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblNjcm9sbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpT1NvblNjcm9sbCIsImNyYWRsZUludGVyc2VjdCIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsImNyYWRsZWludGVyc2VjdG9ic2VydmVyIiwiY3JlYXRlT2JzZXJ2ZXIiLCJjb25uZWN0RWxlbWVudHMiLCJ0cmlnZ2Vyb2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsIm1heExpc3RzaXplIiwiY2FsbGJhY2tzIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJjaGFuZ2VMaXN0c2l6ZSIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJwYXJlQ2FjaGVUb01heCIsInJlbmRlclBvcnRhbExpc3RzIiwibWF0Y2hDYWNoZVRvQ3JhZGxlIiwiaXNSZXNpemluZyIsInBhdXNlSW50ZXJydXB0cyIsInByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoIiwicHJldmlvdXNBeGlzT2Zmc2V0IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJwcmV2aW91c3JhdGlvIiwicGl2b3RDZWxsUGl4ZWxMZW5ndGgiLCJwaXZvdEF4aXNPZmZzZXQiLCJyb3VuZCIsImdldENyYWRsZVN0eWxlcyIsInVzZXJzdHlsZXMiLCJjcmFkbGVIZWFkU3R5bGUiLCJjcmFkbGVUYWlsU3R5bGUiLCJjcmFkbGVBeGlzU3R5bGUiLCJjcmFkbGVEaXZpZGVyU3R5bGUiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZSIsImZpbmFsQ2FsbGJhY2siLCJwcmVsb2FkIiwic2lnbmFscyIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyIiwicmVwb3NpdGlvbmluZ1JlcXVpcmVkIiwiaXNTY3JvbGxpbmciLCJjcmFkbGVDb250ZW50IiwiY29udGVudCIsImhlYWRNb2RlbENvbXBvbmVudHMiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwicmVzdG9yZUJhc2VTY3JvbGxibG9ja0NvbmZpZyIsInNldENyYWRsZUNvbnRlbnQiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJyZXN0b3JlSW50ZXJydXB0cyIsInVwZGF0ZUNyYWRsZUNvbnRlbnQiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInNldFRpbWVvdXQiLCJhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IiwicG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0IiwibGVuZ3RoIiwiaXRlbSIsInJlbW92ZVBhcnRpdGlvblBvcnRhbCIsInBhcnRpdGlvbklEIiwiaXRlbUlEIiwiY2xlYXJDcmFkbGUiLCJzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJzY3JvbGxJbmRleFJlZiIsInNjcm9sbFRyYWNrZXJBcmdzIiwiaW5jbHVkZXMiLCJ0cmFja2VyYXJncyIsInRvcCIsImxlZnQiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZiIsImtleSIsInN0eWxlIiwicmVmIiwiY29udGV4dHZhbHVlUmVmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlNjcm9sbFRyYWNrZXJfMSIsIm9mZnNldCIsImNyZWF0ZUhhbmRsZXIiLCJoYW5kbGVyIiwiaW50ZXJydXB0aGFuZGxlcl8xIiwic2Nyb2xsaGFuZGxlcl8xIiwic3RhdGVIYW5kbGVyIiwic3RhdGVoYW5kbGVyXzEiLCJjb250ZW50aGFuZGxlcl8xIiwibGF5b3V0aGFuZGxlcl8xIiwic2VydmljZWhhbmRsZXJfMSIsInN0eWxlc2hhbmRsZXJfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/InfiniteGridScroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// InfiniteGridScroller.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isSafariIOS = void 0;\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the Scrollblock, which is full size for listsize of given cell height/width.\n    Scrollblock in turn contains the Cradle - a component that contains CellFrames, which contain\n    displayed user content (items) or transitional placeholders.\n\n    Host content is instantiated in a cache of React portals (via cacheHandler). Content is then\n    portal\'d to CellFrames. The cache can be configured to hold more items than the Cradle (limited by\n    device memory). Caching allows host content to maintain state.\n\n    Scrollblock represents the entirety of the list (and is sized accordingly). It is the object that is scrolled.\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as though it scrolls through a filled\n    scrollblock, but in fact it is only slightly larger than the viewport. Content is rotated in and out of the\n    cradle through the cache.\n    \n    Individual host items are framed by CellFrame, which are managed by Cradle.\n\n    Overall the InfiniteGridScroller as a package manages the asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n\n    The Rigs liner (the top level Viewport element) is set with \'display:absolute\' and \'inset:0\', so the user\n    containing block should be styles accordingly.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n// defensive\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ "./node_modules/react-error-boundary/dist/react-error-boundary.umd.js"); // www.npmjs.com/package/react-error-boundary\nvar isSafariIOS = function isSafariIOS() {\n  var is_ios = /iP(ad|od|hone)/i.test(window.navigator.userAgent),\n    is_safari = !!navigator.userAgent.match(/Version\\/[\\d\\.]+.*Safari/);\n  return is_ios && is_safari;\n};\nexports.isSafariIOS = isSafariIOS;\n// based on module template\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n    resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert"\n  }, react_1["default"].createElement("p", null, "Oops! Something went wrong inside react-infinite-grid-scroller."), react_1["default"].createElement("p", null, "Click to cancel the error and continue."), react_1["default"].createElement("button", {\n    onClick: resetErrorBoundary\n  }, "Cancel error"), react_1["default"].createElement("pre", null, error));\n}\n// scroller components\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx"));\n// loaded here to minimize redundant renders in Cradle\nvar cachehandler_1 = __webpack_require__(/*! ./cradle/cachehandler */ "./src/cradle/cachehandler.tsx");\n// -------------------[ global session ID generator ]----------------\nvar globalScrollerID = 0;\n// ===================================[ INITIALIZE ]===========================\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n    cellWidth = props.cellWidth,\n    _props$startingListSi = props.startingListSize,\n    startingListSize = _props$startingListSi === void 0 ? 0 : _props$startingListSi,\n    getItem = props.getItem,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n    _props$gap = props.gap,\n    gap = _props$gap === void 0 ? 0 : _props$gap,\n    _props$padding = props.padding,\n    padding = _props$padding === void 0 ? 0 : _props$padding,\n    _props$layout = props.layout,\n    layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n    _props$cellMinHeight = props.cellMinHeight,\n    cellMinHeight = _props$cellMinHeight === void 0 ? 25 : _props$cellMinHeight,\n    _props$cellMinWidth = props.cellMinWidth,\n    cellMinWidth = _props$cellMinWidth === void 0 ? 25 : _props$cellMinWidth,\n    _props$runwaySize = props.runwaySize,\n    runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n    _props$startingIndex = props.startingIndex,\n    startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n    _props$cache = props.cache,\n    cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n    _props$cacheMax = props.cacheMax,\n    cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n    placeholder = props.placeholder,\n    _props$usePlaceholder = props.usePlaceholder,\n    usePlaceholder = _props$usePlaceholder === void 0 ? true : _props$usePlaceholder,\n    _props$useScrollTrack = props.useScrollTracker,\n    useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n    _props$styles = props.styles,\n    styles = _props$styles === void 0 ? {} : _props$styles,\n    _props$placeholderMes = props.placeholderMessages,\n    placeholderMessages = _props$placeholderMes === void 0 ? {} : _props$placeholderMes,\n    _props$callbacks = props.callbacks,\n    callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n    _props$technical = props.technical,\n    technical = _props$technical === void 0 ? {} : _props$technical,\n    scrollerProperties = props.scrollerProperties;\n  var isMinimalPropsFail = false;\n  if (!(cellWidth && cellHeight && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight, and getItem are required\');\n    isMinimalPropsFail = true;\n  }\n  // ---------------------[ Data setup ]----------------------\n  var originalValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  // avoid null/undefined\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  technical = technical !== null && technical !== void 0 ? technical : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  startingListSize = startingListSize !== null && startingListSize !== void 0 ? startingListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  usePlaceholder = usePlaceholder !== null && usePlaceholder !== void 0 ? usePlaceholder : true;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  cellMinHeight = cellMinHeight !== null && cellMinHeight !== void 0 ? cellMinHeight : 0;\n  cellMinWidth = cellMinWidth !== null && cellMinWidth !== void 0 ? cellMinWidth : 0;\n  cacheMax = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n  cellHeight = +cellHeight;\n  cellWidth = +cellWidth;\n  cellMinHeight = +cellMinHeight;\n  cellMinWidth = +cellMinWidth;\n  gap = +gap;\n  padding = +padding;\n  startingIndex = +startingIndex;\n  startingListSize = +startingListSize;\n  runwaySize = +runwaySize;\n  cacheMax = +cacheMax;\n  var verifiedValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  cellMinHeight = Math.max(cellMinHeight, 25);\n  cellMinWidth = Math.max(cellMinWidth, 25);\n  cellMinHeight = Math.min(cellHeight, cellMinHeight);\n  cellMinWidth = Math.min(cellWidth, cellMinWidth);\n  // prop constraints - non-negative values\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n  startingListSize = Math.max(0, startingListSize);\n  startingIndex = Math.max(0, startingIndex);\n  // package\n  var problems = 0;\n  for (var prop in verifiedValues) {\n    if (isNaN(verifiedValues[prop])) {\n      problems++;\n    }\n  }\n  if (problems) {\n    console.error(\'Error: invalid number - compare originalValues and verifiedValues\', originalValues, verifiedValues);\n  }\n  // enums\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  }\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs);\n  // state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    scrollerState = _ref3[0],\n    setScrollerState = _ref3[1]; // setup, setlistsize, ready\n  // system\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var placeholderMessagesRef = (0, react_1.useRef)(placeholderMessages);\n  var _technical = technical,\n    showAxis = _technical.showAxis,\n    triggerlineOffset = _technical.triggerlineOffset,\n    VIEWPORT_RESIZE_TIMEOUT = _technical.VIEWPORT_RESIZE_TIMEOUT,\n    ONAFTERSCROLL_TIMEOUT = _technical.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _technical.IDLECALLBACK_TIMEOUT,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _technical.VARIABLE_MEASUREMENTS_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _technical.MAX_CACHE_OVER_RUN,\n    CACHE_PARTITION_SIZE = _technical.CACHE_PARTITION_SIZE;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  ONAFTERSCROLL_TIMEOUT = ONAFTERSCROLL_TIMEOUT !== null && ONAFTERSCROLL_TIMEOUT !== void 0 ? ONAFTERSCROLL_TIMEOUT : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 250;\n  VARIABLE_MEASUREMENTS_TIMEOUT = VARIABLE_MEASUREMENTS_TIMEOUT !== null && VARIABLE_MEASUREMENTS_TIMEOUT !== void 0 ? VARIABLE_MEASUREMENTS_TIMEOUT : 250;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE !== null && CACHE_PARTITION_SIZE !== void 0 ? CACHE_PARTITION_SIZE : 30;\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  triggerlineOffset = triggerlineOffset !== null && triggerlineOffset !== void 0 ? triggerlineOffset : 10;\n  if (typeof usePlaceholder != \'boolean\') usePlaceholder = true;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true;\n  // for mount version\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current;\n  // for children\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(startingListSize);\n  var listsize = listsizeRef.current;\n  // tests for React with Object.is for changed properties; avoid re-renders with no change\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  }\n  if (!compareProps(placeholderMessages, placeholderMessagesRef.current)) {\n    placeholderMessagesRef.current = placeholderMessages;\n  }\n  // -------------------------[ Initialization ]-------------------------------\n  (0, react_1.useEffect)(function () {\n    if (scrollerSessionIDRef.current === null) {\n      // defend against React.StrictMode double run\n      scrollerSessionIDRef.current = globalScrollerID++;\n      cacheHandlerRef.current = new cachehandler_1.CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef, CACHE_PARTITION_SIZE);\n    }\n  }, []);\n  // called when getItem returns null, or direct call from user (see serviceHandler)\n  var setListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize;\n    // inform the user\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistsize\');\n  }, []);\n  // ---------------------[ State handling ]------------------------\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n      case \'setlistsize\':\n        setScrollerState(\'ready\');\n    }\n  }, [scrollerState]);\n  // --------------------[ Render ]---------------------\n  if (problems || isMinimalPropsFail) {\n    return react_1["default"].createElement("div", null, "error: see console.");\n  }\n  // component calls are deferred by scrollerState to give cacheHandler a chance to initialize\n  return react_1["default"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {\n      // response tbd; there may not need to be one\n    },\n    onError: function onError(error, info) {\n      console.log(\'react-infinite-grid-scroller captured error\', error);\n    }\n  }, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    // scrollerProperties = { scrollerProperties }\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, listsize && react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessagesRef.current,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    scrollerProperties: scrollerProperties,\n    cacheHandler: cacheHandlerRef.current,\n    usePlaceholder: usePlaceholder,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT: VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerID: scrollerID\n  }))), scrollerState != \'setup\' && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(cachehandler_1.PortalMasterCache, {\n    cacheProps: cacheHandlerRef.current.cacheProps\n  })));\n};\nexports["default"] = InfiniteGridScroller;\n// ----------------------------[ Support ]------------------------------\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\nfunction compareProps(obj1, obj2) {\n  if (!obj1 || !obj2) return false;\n  var keys = Object.keys(obj1);\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTztJQUN4Q3BDLGNBQWMsRUFBS0EsY0FBYztJQUNqQ0MsZ0JBQWdCLEVBQUtBLGdCQUFnQjtJQUNyQ3lCLFFBQVEsRUFBS0EsUUFBUTtJQUNyQkcscUJBQXFCLEVBQUtBLHFCQUFxQjtJQUMvQ0Msb0JBQW9CLEVBQUtBLG9CQUFvQjtJQUM3Q0Usa0JBQWtCLEVBQUtBLGtCQUFrQjtJQUN6Q0QsNkJBQTZCLEVBQUtBLDZCQUE2QjtJQUMvREksVUFBVSxFQUFLQTtFQUFVLEVBRTNCLENBQ1EsQ0FDUCxFQUNUZCxhQUFhLElBQUksT0FBTyxJQUFLMUM7SUFBQSxhQUFpQixXQUFXO0lBQUMyRSxLQUFLLEVBQUtDO0VBQWMsR0FDaEY1RSxpQ0FBQzhELGdDQUFpQjtJQUFDZSxVQUFVLEVBQUluQixlQUFlLENBQUNELE9BQU8sQ0FBQ29CO0VBQVUsRUFBSSxDQUNyRSxDQUNNO0FBQ3BCLENBQUM7QUFFRGpGLGtCQUFBQSxHQUFlUSxvQkFBb0I7QUFFbkM7QUFFQSxJQUFNd0UsY0FBYyxHQUFHO0VBQUNFLE9BQU8sRUFBQztBQUFNLENBQUM7QUFFdkM7QUFDQSxTQUFTakIsWUFBWSxDQUFFa0IsSUFBSSxFQUFDQyxJQUFJO0VBQzVCLElBQUksQ0FBQ0QsSUFBSSxJQUFJLENBQUNDLElBQUksRUFBRSxPQUFPLEtBQUs7RUFDaEMsSUFBTUMsSUFBSSxHQUFHQyxNQUFNLENBQUNELElBQUksQ0FBQ0YsSUFBSSxDQUFDO0VBQzlCLDBCQUFrQkUsSUFBSSw2QkFBRTtJQUFuQixJQUFNRSxHQUFHO0lBQ1YsSUFBSSxDQUFDRCxNQUFNLENBQUNFLEVBQUUsQ0FBQ0wsSUFBSSxDQUFDSSxHQUFHLENBQUMsRUFBQ0gsSUFBSSxDQUFDRyxHQUFHLENBQUMsQ0FBQyxFQUFFO01BQ2pDLE9BQU8sS0FBSzs7O0VBR3BCLE9BQU8sSUFBSTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9JbmZpbml0ZUdyaWRTY3JvbGxlci50c3g/N2Y2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmZpbml0ZUdyaWRTY3JvbGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciA9IFJJR1NcblxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIFNjcm9sbGJsb2NrLCB3aGljaCBpcyBmdWxsIHNpemUgZm9yIGxpc3RzaXplIG9mIGdpdmVuIGNlbGwgaGVpZ2h0L3dpZHRoLlxuICAgIFNjcm9sbGJsb2NrIGluIHR1cm4gY29udGFpbnMgdGhlIENyYWRsZSAtIGEgY29tcG9uZW50IHRoYXQgY29udGFpbnMgQ2VsbEZyYW1lcywgd2hpY2ggY29udGFpbiBcbiAgICBkaXNwbGF5ZWQgdXNlciBjb250ZW50IChpdGVtcykgb3IgdHJhbnNpdGlvbmFsIHBsYWNlaG9sZGVycy4gXG5cbiAgICBIb3N0IGNvbnRlbnQgaXMgaW5zdGFudGlhdGVkIGluIGEgY2FjaGUgb2YgUmVhY3QgcG9ydGFscyAodmlhIGNhY2hlSGFuZGxlcikuIENvbnRlbnQgaXMgdGhlbiBcbiAgICBwb3J0YWwnZCB0byBDZWxsRnJhbWVzLiBUaGUgY2FjaGUgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gaG9sZCBtb3JlIGl0ZW1zIHRoYW4gdGhlIENyYWRsZSAobGltaXRlZCBieSBcbiAgICBkZXZpY2UgbWVtb3J5KS4gQ2FjaGluZyBhbGxvd3MgaG9zdCBjb250ZW50IHRvIG1haW50YWluIHN0YXRlLlxuXG4gICAgU2Nyb2xsYmxvY2sgcmVwcmVzZW50cyB0aGUgZW50aXJldHkgb2YgdGhlIGxpc3QgKGFuZCBpcyBzaXplZCBhY2NvcmRpbmdseSkuIEl0IGlzIHRoZSBvYmplY3QgdGhhdCBpcyBzY3JvbGxlZC5cblxuICAgIENyYWRsZSBjb250YWlucyB0aGUgbGlzdCBpdGVtcywgYW5kIGlzICd2aXJ0dWFsaXplZCcgLS0gaXQgYXBwZWFycyBhcyB0aG91Z2ggaXQgc2Nyb2xscyB0aHJvdWdoIGEgZmlsbGVkIFxuICAgIHNjcm9sbGJsb2NrLCBidXQgaW4gZmFjdCBpdCBpcyBvbmx5IHNsaWdodGx5IGxhcmdlciB0aGFuIHRoZSB2aWV3cG9ydC4gQ29udGVudCBpcyByb3RhdGVkIGluIGFuZCBvdXQgb2YgdGhlIFxuICAgIGNyYWRsZSB0aHJvdWdoIHRoZSBjYWNoZS5cbiAgICBcbiAgICBJbmRpdmlkdWFsIGhvc3QgaXRlbXMgYXJlIGZyYW1lZCBieSBDZWxsRnJhbWUsIHdoaWNoIGFyZSBtYW5hZ2VkIGJ5IENyYWRsZS5cblxuICAgIE92ZXJhbGwgdGhlIEluZmluaXRlR3JpZFNjcm9sbGVyIGFzIGEgcGFja2FnZSBtYW5hZ2VzIHRoZSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIG9mIHRoZSBcbiAgICBjb21wb25lbnRzIG9mIHRoZSBtZWNoYW5pc20uIE1vc3Qgb2YgdGhlIHdvcmsgb2NjdXJzIGluIHRoZSBDcmFkbGUgY29tcG9uZW50LlxuXG4gICAgVGhlIFJpZ3MgbGluZXIgKHRoZSB0b3AgbGV2ZWwgVmlld3BvcnQgZWxlbWVudCkgaXMgc2V0IHdpdGggJ2Rpc3BsYXk6YWJzb2x1dGUnIGFuZCAnaW5zZXQ6MCcsIHNvIHRoZSB1c2VyIFxuICAgIGNvbnRhaW5pbmcgYmxvY2sgc2hvdWxkIGJlIHN0eWxlcyBhY2NvcmRpbmdseS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbi8vIGRlZmVuc2l2ZVxuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeSB9IGZyb20gJ3JlYWN0LWVycm9yLWJvdW5kYXJ5JyAvLyB3d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtZXJyb3ItYm91bmRhcnlcblxuZXhwb3J0IGNvbnN0IGlzU2FmYXJpSU9TID0gKCkgPT4ge1xuICAgIGNvbnN0XG4gICAgICAgIGlzX2lvcyA9IC9pUChhZHxvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgICBpc19zYWZhcmkgPSAhIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC9bXFxkXFwuXSsuKlNhZmFyaS8pXG4gICAgcmV0dXJuICggaXNfaW9zICYmIGlzX3NhZmFyaSApIFxufVxuXG4vLyBiYXNlZCBvbiBtb2R1bGUgdGVtcGxhdGVcbmZ1bmN0aW9uIEVycm9yRmFsbGJhY2soe2Vycm9yLCByZXNldEVycm9yQm91bmRhcnl9KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiByb2xlPVwiYWxlcnRcIj5cbiAgICAgIDxwPk9vcHMhIFNvbWV0aGluZyB3ZW50IHdyb25nIGluc2lkZSByZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLjwvcD5cbiAgICAgIDxwPkNsaWNrIHRvIGNhbmNlbCB0aGUgZXJyb3IgYW5kIGNvbnRpbnVlLjwvcD5cbiAgICAgIDxidXR0b24gb25DbGljaz17IHJlc2V0RXJyb3JCb3VuZGFyeSB9PkNhbmNlbCBlcnJvcjwvYnV0dG9uPlxuICAgICAgPHByZT57ZXJyb3J9PC9wcmU+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuLy8gc2Nyb2xsZXIgY29tcG9uZW50c1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vVmlld3BvcnQnXG5pbXBvcnQgU2Nyb2xsYmxvY2sgZnJvbSAnLi9TY3JvbGxibG9jaydcbmltcG9ydCBDcmFkbGUgZnJvbSAnLi9DcmFkbGUnXG5cbi8vIGxvYWRlZCBoZXJlIHRvIG1pbmltaXplIHJlZHVuZGFudCByZW5kZXJzIGluIENyYWRsZVxuaW1wb3J0IHsgQ2FjaGVIYW5kbGVyLCBQb3J0YWxNYXN0ZXJDYWNoZSB9IGZyb20gJy4vY3JhZGxlL2NhY2hlaGFuZGxlcidcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgZ2xvYmFsIHNlc3Npb24gSUQgZ2VuZXJhdG9yIF0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBnbG9iYWxTY3JvbGxlcklEID0gMFxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaRSBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IEluZmluaXRlR3JpZFNjcm9sbGVyID0gKHByb3BzKSA9PiB7XG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVsgbm9ybWFsaXplIHByb3BlcnRpZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgeyBcblxuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICBjZWxsSGVpZ2h0LCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIGhlaWdodCAtIGxpdGVyYWwgZm9yIHZlcnRpY2FsOyBhcHByb3hpbWF0ZSBmb3IgaG9yaXpvbnRhbFxuICAgICAgICAgICAgLy8gbWF4IGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgY2VsbFdpZHRoLCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIHdpZHRoIC0gbGl0ZXJhbCBmb3IgaG9yaXpvbnRhbDsgYXBwcm94aW1hdGUgZm9yIHZlcnRpY2FsXG4gICAgICAgICAgICAvLyBtYXggZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICBzdGFydGluZ0xpc3RTaXplID0gMCwgLy8gdGhlIHN0YXJnaW5nIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdmlydHVhbCBsaXN0LiBjYW4gYmUgY2hhbmdlZFxuICAgICAgICBnZXRJdGVtLCAvLyByZXF1aXJlZC4gZnVuY3Rpb24gcHJvdmlkZWQgYnkgaG9zdCAtIHBhcmFtZXRlcnMgc2V0IGJ5IHN5c3RlbSBhcmUgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAvLyBhbmQgc2Vzc2lvbiBpdGVtSUQgZm9yIHRyYWNraW5nIGFuZCBtYXRjaGluZzsgXG4gICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudCwgb3IgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICAvLyBncmlkIHNwZWNzOlxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwID0gMCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG4gICAgICAgIHBhZGRpbmcgPSAwLCAvLyB0aGUgYm9yZGVyIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBsYXlvdXQgPSAndW5pZm9ybScsIC8vIHVuaWZvcm0sIHZhcmlhYmxlXG4gICAgICAgIGNlbGxNaW5IZWlnaHQgPSAyNSwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCdcbiAgICAgICAgY2VsbE1pbldpZHRoID0gMjUsIC8vIGZvciBsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAvLyBzY3JvbGxlciBzcGVjczpcbiAgICAgICAgcnVud2F5U2l6ZSA9IDMsIC8vIHRoZSBudW1iZXIgb2Ygcm93cyBvdXRzaWRlIHRoZSB2aWV3IG9mIGVhY2ggc2lkZSBvZiB0aGUgdmlld3BvcnQgXG4gICAgICAgICAgICAvLyAtLSBnaXZlcyB0aW1lIHRvIGFzc2VtYmxlIGNlbGxGcmFtZXMgYmVmb3JlIGRpc3BsYXlcbiAgICAgICAgc3RhcnRpbmdJbmRleCA9IDAsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuXG4gICAgICAgIC8vIHN5c3RlbSBzcGVjczpcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJywgLy8gXCJwcmVsb2FkXCIsIFwia2VlcGxvYWRcIiBvciBcImNyYWRsZVwiXG4gICAgICAgIGNhY2hlTWF4ID0gbnVsbCwgLy8gYWx3YXlzIG1pbmltdW0gY3JhZGxlIGNvbnRlbnQgc2l6ZTsgZmFsc2V5IG1lYW5zIGxpbWl0ZWQgYnkgbGlzdHNpemVcbiAgICAgICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsLiBhIHNwYXJzZSBjb21wb25lbnQgdG8gc3RhbmQgaW4gZm9yIGNvbnRlbnQgdW50aWwgdGhlIGNvbnRlbnQgYXJyaXZlczsgXG4gICAgICAgICAgICAvLyByZXBsYWNlcyBkZWZhdWx0IHBsYWNlaG9sZGVyIGlmIHByZXNlbnRcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIgPSB0cnVlLCAvLyBubyBwbGFjZWhvbGRlciByZW5kZXJlZCBpZiBmYWxzZVxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZSwgLy8gdGhlIGludGVybmFsIGNvbXBvbmVudCB0byBnaXZlIGZlZWRiYWNrIGZvciByZXBvc2l0aW9uaW5nXG5cbiAgICAgICAgLy8gYWR2YW5jZWQgb2JqZWN0c1xuICAgICAgICBzdHlsZXMgPSB7fSwgLy8gb3B0aW9uYWwuIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KTsgaGFzIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB2aWV3cG9ydCwgc2Nyb2xsYmxvY2ssIGNyYWRsZSwgc2Nyb2xsdHJhY2tlciwgcGxhY2Vob2xkZXJmcmFtZSwgXG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlcmVycm9yZnJhbWUsIHBsYWNlaG9sZGVybGluZXIgb3IgcGxhY2Vob2xkZXJlcnJvcmxpbmVyLiBEbyBub3QgbWFrZSBzdHJ1Y3R1cmFsIGNoYW5nZXMhXG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7fSwgLy8gbWVzc2FnZXMgcHJlc2VudGVkIGJ5IGRlZmF1bHQgcGxhY2Vob2xkZXIuIFNlZSBkb2N1bWVudGF0aW9uXG4gICAgICAgIGNhbGxiYWNrcyA9IHt9LCAvLyBvcHRpb25hbC4gY2xvc3VyZXMgdG8gZ2V0IGRpcmVjdCBpbmZvcm1hdGlvbiBzdHJlYW1zIG9mIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzXG4gICAgICAgICAgICAvLyBjYW4gY29udGFpbiBmdW5jdGlvbnNDYWxsYmFjaywgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGludGVybmFsIHNjcm9sbGVyIGZ1bmN0aW9ucyBcbiAgICAgICAgICAgIC8vKG1vc3RseSBjYWNoZSBtYW5hZ2VtZW50KVxuICAgICAgICB0ZWNobmljYWwgPSB7fSwgLy8gb3B0aW9uYWwuIHRlY2huaWNhbCBzZXR0aW5ncyBsaWtlIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUXG5cbiAgICAgICAgLy8gaW5mb3JtYXRpb24gZm9yIGhvc3QgY2VsbCBjb250ZW50XG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcywgLy8gcmVxdWlyZWQgZm9yIGVtYmVkZGVkIHNjcm9sbGVyOyBzaGFyZXMgc2Nyb2xsZXIgc2V0dGluZ3Mgd2l0aCBjb250ZW50XG5cbiAgICB9ID0gcHJvcHNcblxuICAgIGxldCBpc01pbmltYWxQcm9wc0ZhaWwgPSBmYWxzZVxuICAgIGlmICghKGNlbGxXaWR0aCAmJiBjZWxsSGVpZ2h0ICYmIGdldEl0ZW0gKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUklHUzogY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBhbmQgZ2V0SXRlbSBhcmUgcmVxdWlyZWQnKVxuICAgICAgICBpc01pbmltYWxQcm9wc0ZhaWwgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBEYXRhIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlcyA9IHtcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgc3RhcnRpbmdJbmRleCxcbiAgICAgICAgc3RhcnRpbmdMaXN0U2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgfVxuXG4gICAgLy8gYXZvaWQgbnVsbC91bmRlZmluZWRcbiAgICBzdHlsZXMgPSBzdHlsZXMgPz8ge31cbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgPz8ge31cbiAgICB0ZWNobmljYWwgPSB0ZWNobmljYWwgPz8ge31cbiAgICBzdGFydGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleCA/PyAwXG4gICAgc3RhcnRpbmdMaXN0U2l6ZSA9IHN0YXJ0aW5nTGlzdFNpemUgPz8gMFxuICAgIHJ1bndheVNpemUgPSBydW53YXlTaXplID8/IDNcbiAgICB1c2VQbGFjZWhvbGRlciA9IHVzZVBsYWNlaG9sZGVyID8/IHRydWVcbiAgICB1c2VTY3JvbGxUcmFja2VyID0gdXNlU2Nyb2xsVHJhY2tlciA/PyB0cnVlXG4gICAgY2VsbE1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgPz8gMFxuICAgIGNlbGxNaW5XaWR0aCA9IGNlbGxNaW5XaWR0aCA/PyAwXG4gICAgY2FjaGVNYXggPSBjYWNoZU1heCA/PyAwXG5cbiAgICBjZWxsSGVpZ2h0ID0gK2NlbGxIZWlnaHRcbiAgICBjZWxsV2lkdGggPSArY2VsbFdpZHRoXG4gICAgY2VsbE1pbkhlaWdodCA9ICtjZWxsTWluSGVpZ2h0XG4gICAgY2VsbE1pbldpZHRoID0gK2NlbGxNaW5XaWR0aFxuICAgIGdhcCA9ICtnYXBcbiAgICBwYWRkaW5nID0gK3BhZGRpbmdcbiAgICBzdGFydGluZ0luZGV4ID0gK3N0YXJ0aW5nSW5kZXhcbiAgICBzdGFydGluZ0xpc3RTaXplID0gK3N0YXJ0aW5nTGlzdFNpemVcbiAgICBydW53YXlTaXplID0gK3J1bndheVNpemVcbiAgICBjYWNoZU1heCA9ICtjYWNoZU1heFxuXG4gICAgY29uc3QgdmVyaWZpZWRWYWx1ZXMgPSB7XG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsXG4gICAgICAgIHN0YXJ0aW5nTGlzdFNpemUsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNhY2hlTWF4LCAgICAgICAgXG4gICAgfVxuXG4gICAgY2VsbE1pbkhlaWdodCA9IE1hdGgubWF4KGNlbGxNaW5IZWlnaHQsIDI1KVxuICAgIGNlbGxNaW5XaWR0aCA9IE1hdGgubWF4KGNlbGxNaW5XaWR0aCwgMjUpXG4gICAgY2VsbE1pbkhlaWdodCA9IE1hdGgubWluKGNlbGxIZWlnaHQsIGNlbGxNaW5IZWlnaHQpXG4gICAgY2VsbE1pbldpZHRoID0gTWF0aC5taW4oY2VsbFdpZHRoLCBjZWxsTWluV2lkdGgpXG5cbiAgICAvLyBwcm9wIGNvbnN0cmFpbnRzIC0gbm9uLW5lZ2F0aXZlIHZhbHVlc1xuICAgIHJ1bndheVNpemUgPSBNYXRoLm1heCgxLHJ1bndheVNpemUpIC8vIHJ1bndheXNpemUgbXVzdCBiZSBhdCBsZWFzdCAxXG4gICAgc3RhcnRpbmdMaXN0U2l6ZSA9IE1hdGgubWF4KDAsc3RhcnRpbmdMaXN0U2l6ZSlcbiAgICBzdGFydGluZ0luZGV4ID0gTWF0aC5tYXgoMCxzdGFydGluZ0luZGV4KVxuXG4gICAgLy8gcGFja2FnZVxuICAgIGxldCBwcm9ibGVtcyA9IDBcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gdmVyaWZpZWRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZlcmlmaWVkVmFsdWVzW3Byb3BdKSkge1xuICAgICAgICAgICAgcHJvYmxlbXMrK1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIGlmIChwcm9ibGVtcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogaW52YWxpZCBudW1iZXIgLSBjb21wYXJlIG9yaWdpbmFsVmFsdWVzIGFuZCB2ZXJpZmllZFZhbHVlcycsIFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZXMsIHZlcmlmaWVkVmFsdWVzKVxuICAgIH1cblxuICAgIC8vIGVudW1zXG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkgeyBcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIGlmICghWydwcmVsb2FkJywna2VlcGxvYWQnLCdjcmFkbGUnXS5pbmNsdWRlcyhjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJ1xuICAgIH1cbiAgICBpZiAoIVsndW5pZm9ybScsICd2YXJpYWJsZSddLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nXG4gICAgfVxuXG4gICAgY29uc3QgZ3JpZFNwZWNzID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICAvLyBzdGF0ZVxuICAgIGNvbnN0IFtzY3JvbGxlclN0YXRlLCBzZXRTY3JvbGxlclN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCBzZXRsaXN0c2l6ZSwgcmVhZHlcbiAgICAvLyBzeXN0ZW1cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoc3R5bGVzKVxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZihjYWxsYmFja3MpXG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZiA9IHVzZVJlZihwbGFjZWhvbGRlck1lc3NhZ2VzKVxuXG4gICAgbGV0IHtcblxuICAgICAgICBzaG93QXhpcywgLy8gYm9vbGVhbjsgYXhpcyBjYW4gYmUgbWFkZSB2aXNpYmxlIGZvciBkZWJ1Z1xuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCwgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGhlYWQgb3IgdGFpbCBmb3IgY29udGVudCBzaGlmdHMgYWJvdmUvYmVsb3cgYXhpc1xuICAgICAgICAvLyB0aW1lb3V0c1xuICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCxcbiAgICAgICAgT05BRlRFUlNDUk9MTF9USU1FT1VULFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQsXG4gICAgICAgIC8vIHJhdGlvczpcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLCAvLyBtYXggc3RyZWFtaW5nIG92ZXItcnVuIGFzIHJhdGlvIHRvIGNhY2hlTWF4XG4gICAgICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFLCBcblxuICAgIH0gPSB0ZWNobmljYWxcblxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0gVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPz8gMjUwXG4gICAgT05BRlRFUlNDUk9MTF9USU1FT1VUID0gT05BRlRFUlNDUk9MTF9USU1FT1VUID8/IDEwMFxuICAgIElETEVDQUxMQkFDS19USU1FT1VUID0gSURMRUNBTExCQUNLX1RJTUVPVVQgPz8gMjUwXG4gICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgPSBWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCA/PyAyNTBcbiAgICBcbiAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4gPSBNQVhfQ0FDSEVfT1ZFUl9SVU4gPz8gMS41XG4gICAgQ0FDSEVfUEFSVElUSU9OX1NJWkUgPSBDQUNIRV9QQVJUSVRJT05fU0laRSA/PyAzMFxuXG4gICAgaWYgKHR5cGVvZiBzaG93QXhpcyAhPSAnYm9vbGVhbicpIHNob3dBeGlzID0gZmFsc2VcblxuICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgPz8gMTBcblxuICAgIGlmICh0eXBlb2YgdXNlUGxhY2Vob2xkZXIgIT0gJ2Jvb2xlYW4nKSB1c2VQbGFjZWhvbGRlciA9IHRydWVcbiAgICBpZiAodHlwZW9mIHVzZVNjcm9sbFRyYWNrZXIgIT0gJ2Jvb2xlYW4nKSB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuXG4gICAgLy8gZm9yIG1vdW50IHZlcnNpb25cbiAgICBjb25zdCBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbGVySUQgPSBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50XG5cbiAgICAvLyBmb3IgY2hpbGRyZW5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGxpc3RzaXplUmVmID0gdXNlUmVmKHN0YXJ0aW5nTGlzdFNpemUpXG5cbiAgICBjb25zdCBsaXN0c2l6ZSA9IGxpc3RzaXplUmVmLmN1cnJlbnRcblxuICAgIC8vIHRlc3RzIGZvciBSZWFjdCB3aXRoIE9iamVjdC5pcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzOyBhdm9pZCByZS1yZW5kZXJzIHdpdGggbm8gY2hhbmdlXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoZ3JpZFNwZWNzLCBncmlkU3BlY3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgPSBncmlkU3BlY3NcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhzdHlsZXMsIHN0eWxlc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBzdHlsZXNSZWYuY3VycmVudCA9IHN0eWxlc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhjYWxsYmFja3MsIGNhbGxiYWNrc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudCA9IGNhbGxiYWNrc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhwbGFjZWhvbGRlck1lc3NhZ2VzLCBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbml0aWFsaXphdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0ICgoKSA9PiB7XG5cbiAgICAgICAgaWYgKHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQgPT09IG51bGwpIHsgLy8gZGVmZW5kIGFnYWluc3QgUmVhY3QuU3RyaWN0TW9kZSBkb3VibGUgcnVuXG4gICAgICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50ID0gZ2xvYmFsU2Nyb2xsZXJJRCsrXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCA9IG5ldyBDYWNoZUhhbmRsZXIoc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudCwgc2V0TGlzdHNpemUsIGxpc3RzaXplUmVmLCBcbiAgICAgICAgICAgICAgICBDQUNIRV9QQVJUSVRJT05fU0laRSlcbiAgICAgICAgfVxuXG4gICAgfSxbXSk7XG5cbiAgICAvLyBjYWxsZWQgd2hlbiBnZXRJdGVtIHJldHVybnMgbnVsbCwgb3IgZGlyZWN0IGNhbGwgZnJvbSB1c2VyIChzZWUgc2VydmljZUhhbmRsZXIpXG4gICAgY29uc3Qgc2V0TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobGlzdHNpemUpID0+e1xuXG4gICAgICAgIGlmIChsaXN0c2l6ZSA9PSBsaXN0c2l6ZVJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBsaXN0c2l6ZVJlZi5jdXJyZW50ID0gbGlzdHNpemVcblxuICAgICAgICAvLyBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUgJiYgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUobGlzdHNpemUpXG5cbiAgICAgICAgc2V0U2Nyb2xsZXJTdGF0ZSgnc2V0bGlzdHNpemUnKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3RhdGUgaGFuZGxpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHNjcm9sbGVyU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldGxpc3RzaXplJzpcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdyZWFkeScpXG4gICAgICAgIH1cblxuICAgIH0sW3Njcm9sbGVyU3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBpZiAocHJvYmxlbXMgfHwgaXNNaW5pbWFsUHJvcHNGYWlsKSB7XG4gICAgICAgIHJldHVybiA8ZGl2PmVycm9yOiBzZWUgY29uc29sZS48L2Rpdj4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudCBjYWxscyBhcmUgZGVmZXJyZWQgYnkgc2Nyb2xsZXJTdGF0ZSB0byBnaXZlIGNhY2hlSGFuZGxlciBhIGNoYW5jZSB0byBpbml0aWFsaXplXG4gICAgcmV0dXJuIDxFcnJvckJvdW5kYXJ5XG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50PSB7IEVycm9yRmFsbGJhY2sgfVxuICAgICAgICBvblJlc2V0PSB7ICgpID0+IHtcbiAgICAgICAgICAvLyByZXNwb25zZSB0YmQ7IHRoZXJlIG1heSBub3QgbmVlZCB0byBiZSBvbmVcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvciA9IHsoZXJyb3I6IEVycm9yLCBpbmZvOiB7Y29tcG9uZW50U3RhY2s6IHN0cmluZ30pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyIGNhcHR1cmVkIGVycm9yJywgZXJyb3IpXG4gICAgICAgIH19XG4gICAgPlxuXG4gICAgICAgIHsoc2Nyb2xsZXJTdGF0ZSAhPSAnc2V0dXAnKSAmJiA8Vmlld3BvcnRcblxuICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIC8vIHNjcm9sbGVyUHJvcGVydGllcyA9IHsgc2Nyb2xsZXJQcm9wZXJ0aWVzIH1cbiAgICAgICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICAgICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPSB7IFZJRVdQT1JUX1JFU0laRV9USU1FT1VUIH1cblxuICAgICAgICA+XG4gICAgICAgIFxuICAgICAgICAgICAge2xpc3RzaXplICYmIDxTY3JvbGxibG9ja1xuXG4gICAgICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8Q3JhZGxlIFxuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB7IGNhY2hlIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVNYXggPSB7IGNhY2hlTWF4IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNhbGxiYWNrcyA9IHsgY2FsbGJhY2tzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4ID0geyBzdGFydGluZ0luZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bndheVNpemUgPSB7IHJ1bndheVNpemUgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCA9IHsgdHJpZ2dlcmxpbmVPZmZzZXQgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMgPSB7IHNjcm9sbGVyUHJvcGVydGllcyB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyID0geyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVBsYWNlaG9sZGVyID0geyB1c2VQbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB7IHVzZVNjcm9sbFRyYWNrZXIgfVxuICAgICAgICAgICAgICAgICAgICBzaG93QXhpcyA9IHsgc2hvd0F4aXMgfVxuICAgICAgICAgICAgICAgICAgICBPTkFGVEVSU0NST0xMX1RJTUVPVVQgPSB7IE9OQUZURVJTQ1JPTExfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIElETEVDQUxMQkFDS19USU1FT1VUID0geyBJRExFQ0FMTEJBQ0tfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTiA9IHsgTUFYX0NBQ0hFX09WRVJfUlVOIH1cbiAgICAgICAgICAgICAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgPSB7IFZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VUIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG5cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9TY3JvbGxibG9jaz59XG4gICAgICAgIDwvVmlld3BvcnQ+fVxuICAgICAgICB7KHNjcm9sbGVyU3RhdGUgIT0gJ3NldHVwJykgJiYgPGRpdiBkYXRhLXR5cGUgPSAnY2FjaGVyb290JyBzdHlsZSA9IHsgY2FjaGVyb290c3R5bGUgfT5cbiAgICAgICAgICAgIDxQb3J0YWxNYXN0ZXJDYWNoZSBjYWNoZVByb3BzID0ge2NhY2hlSGFuZGxlclJlZi5jdXJyZW50LmNhY2hlUHJvcHN9IC8+XG4gICAgICAgIDwvZGl2Pn1cbiAgICA8L0Vycm9yQm91bmRhcnk+XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluZmluaXRlR3JpZFNjcm9sbGVyXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFN1cHBvcnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjYWNoZXJvb3RzdHlsZSA9IHtkaXNwbGF5Oidub25lJ30vLyBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzIC8vIHN0YXRpYywgb3V0IG9mIHZpZXcgXG5cbi8vIHV0aWxpdHlcbmZ1bmN0aW9uIGNvbXBhcmVQcm9wcyAob2JqMSxvYmoyKSB7XG4gICAgaWYgKCFvYmoxIHx8ICFvYmoyKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqMSlcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG9iajFba2V5XSxvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbImlzU2FmYXJpSU9TIiwiaXNfaW9zIiwidGVzdCIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzX3NhZmFyaSIsIm1hdGNoIiwiZXhwb3J0cyIsIkVycm9yRmFsbGJhY2siLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInJlYWN0XzEiLCJyb2xlIiwib25DbGljayIsImdsb2JhbFNjcm9sbGVySUQiLCJJbmZpbml0ZUdyaWRTY3JvbGxlciIsInByb3BzIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsInN0YXJ0aW5nTGlzdFNpemUiLCJnZXRJdGVtIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwibGF5b3V0IiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsInJ1bndheVNpemUiLCJzdGFydGluZ0luZGV4IiwiY2FjaGUiLCJjYWNoZU1heCIsInBsYWNlaG9sZGVyIiwidXNlUGxhY2Vob2xkZXIiLCJ1c2VTY3JvbGxUcmFja2VyIiwic3R5bGVzIiwicGxhY2Vob2xkZXJNZXNzYWdlcyIsImNhbGxiYWNrcyIsInRlY2huaWNhbCIsInNjcm9sbGVyUHJvcGVydGllcyIsImlzTWluaW1hbFByb3BzRmFpbCIsImNvbnNvbGUiLCJsb2ciLCJvcmlnaW5hbFZhbHVlcyIsInZlcmlmaWVkVmFsdWVzIiwiTWF0aCIsIm1heCIsIm1pbiIsInByb2JsZW1zIiwicHJvcCIsImlzTmFOIiwiaW5jbHVkZXMiLCJncmlkU3BlY3MiLCJncmlkU3BlY3NSZWYiLCJzY3JvbGxlclN0YXRlIiwic2V0U2Nyb2xsZXJTdGF0ZSIsInN0eWxlc1JlZiIsImNhbGxiYWNrc1JlZiIsInBsYWNlaG9sZGVyTWVzc2FnZXNSZWYiLCJzaG93QXhpcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQiLCJPTkFGVEVSU0NST0xMX1RJTUVPVVQiLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIlZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VUIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiQ0FDSEVfUEFSVElUSU9OX1NJWkUiLCJzY3JvbGxlclNlc3Npb25JRFJlZiIsInNjcm9sbGVySUQiLCJjdXJyZW50IiwiY2FjaGVIYW5kbGVyUmVmIiwibGlzdHNpemVSZWYiLCJsaXN0c2l6ZSIsImNvbXBhcmVQcm9wcyIsImNhY2hlaGFuZGxlcl8xIiwic2V0TGlzdHNpemUiLCJuZXdMaXN0c2l6ZSIsInJlYWN0X2Vycm9yX2JvdW5kYXJ5XzEiLCJGYWxsYmFja0NvbXBvbmVudCIsIm9uUmVzZXQiLCJvbkVycm9yIiwiaW5mbyIsIlZpZXdwb3J0XzEiLCJTY3JvbGxibG9ja18xIiwiQ3JhZGxlXzEiLCJ1c2VyQ2FsbGJhY2tzIiwiY2FjaGVIYW5kbGVyIiwic3R5bGUiLCJjYWNoZXJvb3RzdHlsZSIsImNhY2hlUHJvcHMiLCJkaXNwbGF5Iiwib2JqMSIsIm9iajIiLCJrZXlzIiwiT2JqZWN0Iiwia2V5IiwiaXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/InfiniteGridScroller.tsx\n')},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Scrollblock.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element (scrolled by Viewport) of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n    listsize = _ref.listsize,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth;\n  // -------------------------[ context and state ]-------------------------\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  // -----------------------------------[ data heap ]-------------------------\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null);\n  // just for init\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n    _ref3 = _slicedToArray(_ref2, 2),\n    divlinerstyle = _ref3[0],\n    saveDivlinerstyle = _ref3[1]; // to trigger render\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n    width = _ViewportContextPrope.width,\n    height = _ViewportContextPrope.height;\n  // reconfigure\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef, cellWidth, cellHeight, padding);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\nexports["default"] = Scrollblock;\n// any of the parameters can affect the length\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n    viewportheight = _ref4.viewportheight,\n    viewportwidth = _ref4.viewportwidth,\n    listsize = _ref4.listsize,\n    cellHeight = _ref4.cellHeight,\n    cellWidth = _ref4.cellWidth,\n    gap = _ref4.gap,\n    padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  }\n  // adjustments to viewportcrosslength\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  // -------------------[ calculate scrollblock length ]-----------------\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap :\n  // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n  return baselength;\n};\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef, cellWidth, cellHeight, padding) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n  var height, width, minHeight, minWidth;\n  if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n    minWidth = cellWidth + padding * 2 + \'px\';\n    minHeight = null;\n  } else {\n    // orientation == \'horizontal\'\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n    minHeight = cellHeight + padding * 2 + \'px\';\n    minWidth = null;\n  }\n  localstyles.height = height;\n  localstyles.width = width;\n  localstyles.minHeight = minHeight;\n  localstyles.minWidth = minWidth;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF1QixDQUN6QnJCLFdBQVcsRUFBRXFDLFNBQVMsRUFBRUMsd0JBQXdCLEVBQUVsQyxTQUFTLEVBQUVELFVBQVUsRUFBRUQsT0FBTyxFQUFJO0VBRXBGLElBQU1xQyxXQUFXLHFCQUFPRixTQUFTLENBQUN6QixPQUFPLENBQUMsRUFBQztFQUMzQyxJQUFJSyxNQUFNLEVBQUVELEtBQUssRUFBRXdCLFNBQVMsRUFBRUMsUUFBUTtFQUN0QyxJQUFJekMsV0FBVyxJQUFJLFVBQVUsRUFBRTtJQUMzQmlCLE1BQU0sR0FBR3FCLHdCQUF3QixDQUFDMUIsT0FBTyxHQUFHLElBQUk7SUFDaERJLEtBQUssR0FBRyxNQUFNO0lBQ2R5QixRQUFRLEdBQUlyQyxTQUFTLEdBQUlGLE9BQU8sR0FBRyxDQUFFLEdBQUksSUFBSTtJQUM3Q3NDLFNBQVMsR0FBRyxJQUFJO0dBQ25CLE1BQU07SUFBRTtJQUNMdkIsTUFBTSxHQUFHLE1BQU07SUFDZkQsS0FBSyxHQUFHc0Isd0JBQXdCLENBQUMxQixPQUFPLEdBQUcsSUFBSTtJQUMvQzRCLFNBQVMsR0FBSXJDLFVBQVUsR0FBSUQsT0FBTyxHQUFHLENBQUUsR0FBSSxJQUFJO0lBQy9DdUMsUUFBUSxHQUFHLElBQUk7O0VBRW5CRixXQUFXLENBQUN0QixNQUFNLEdBQUdBLE1BQU07RUFDM0JzQixXQUFXLENBQUN2QixLQUFLLEdBQUdBLEtBQUs7RUFDekJ1QixXQUFXLENBQUNDLFNBQVMsR0FBR0EsU0FBUztFQUNqQ0QsV0FBVyxDQUFDRSxRQUFRLEdBQUdBLFFBQVE7RUFFL0IsT0FBT0YsV0FBVztBQUV0QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9TY3JvbGxibG9jay50c3g/M2I2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTY3JvbGxibG9jay50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG5cbiAgICBUaGUgc2Nyb2xsYmxvY2sgcHJvdmlkZXMgdGhlIHNjcm9sbGFibGUgZWxlbWVudCAoc2Nyb2xsZWQgYnkgVmlld3BvcnQpIG9mIHRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyLlxuICAgIEl0IGlzIHNpemVkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY2VsbCBzaXplIGFuZCByb3cgY291bnRzLCBhZGp1c3RlZCBmb3IgdmFyaWFibGUgY3JhZGxlIGNvbnRlbnQuXG4gICAgSXRzIG9ubHkgc3RhdGUgY2hhbmdlIGlzIGNoYW5nZSBvZiBzdHlsZXMuXG5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW99IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL1ZpZXdwb3J0J1xuXG5jb25zdCBTY3JvbGxibG9jayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgbGlzdHNpemUsXG4gICAgZ3JpZFNwZWNzLCBcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbn0pID0+IHtcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIFxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZGF0YSBoZWFwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGp1c3QgZm9yIGluaXRcbiAgICBjb25zdCBsaW5lclN0eWxlID0gdXNlTWVtbygoKSA9PntcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3R5bGVzLnNjcm9sbGJsb2NrLFxuICAgICAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgfVxuXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKGxpbmVyU3R5bGUpXG5cbiAgICBjb25zdCBbZGl2bGluZXJzdHlsZSxzYXZlRGl2bGluZXJzdHlsZV0gPSB1c2VTdGF0ZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpIC8vIHRvIHRyaWdnZXIgcmVuZGVyXG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zXG4gICAgXG4gICAgLy8gcmVjb25maWd1cmVcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHVwZGF0ZUJhc2VCbG9ja0xlbmd0aChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpoZWlnaHQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDp3aWR0aCxcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGRpdmxpbmVyc3R5bGVSZWYsXG4gICAgICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmLFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgc2F2ZURpdmxpbmVyc3R5bGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgXSlcblxuICAgIGNvbnN0IHVwZGF0ZUJhc2VCbG9ja0xlbmd0aCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAobGF5b3V0c3BlY3MpID0+IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYmFzZXNjcm9sbGJsb2NrbGVuZ3RoID0gY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aChsYXlvdXRzcGVjcylcblxuICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmLmN1cnJlbnQgPSBiYXNlc2Nyb2xsYmxvY2tsZW5ndGhcblxuICAgICAgICB9LFtdXG4gICAgKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3Njcm9sbGJsb2NrJyBzdHlsZT17ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fT57Y2hpbGRyZW59PC9kaXY+XG5cbn0gLy8gU2Nyb2xsYmxvY2tcblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsYmxvY2tcblxuLy8gYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGNhbiBhZmZlY3QgdGhlIGxlbmd0aFxuY29uc3QgY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aCA9ICh7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICB2aWV3cG9ydGhlaWdodCxcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIH0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNyb3NzY291bnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vY3Jvc3Njb3VudCBpcyBhbHNvIGNhbGN1bGF0ZWQgYnkgQ3JhZGxlXG5cbiAgICBsZXQgY3Jvc3NsZW5ndGhcbiAgICBsZXQgY2VsbExlbmd0aFxuICAgIGxldCB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnR3aWR0aCBcblxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydGhlaWdodFxuXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0bWVudHMgdG8gdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggLT0gKHBhZGRpbmcgKiAyKVxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggKz0gZ2FwIC8vIHRvIG1hdGNoIGNyb3NzTGVuZ3RoXG5cbiAgICBpZiAodmlld3BvcnRjcm9zc2xlbmd0aCA8IGNyb3NzbGVuZ3RoKSB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gY3Jvc3NsZW5ndGggLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmVcblxuICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGgvY3Jvc3NsZW5ndGgpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgc2Nyb2xsYmxvY2sgbGVuZ3RoIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgbGlzdHJvd2NvdW50ID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3Ryb3djb3VudCAqIGNlbGxMZW5ndGgpIC0gXG4gICAgICAgICgobGlzdHJvd2NvdW50ID4gMCk/XG4gICAgICAgICAgICBnYXA6IC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgMCkgXG4gICAgICAgICsgKHBhZGRpbmcgKiAyKSAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG5cbiAgICByZXR1cm4gYmFzZWxlbmd0aFxuXG59XG5cbmNvbnN0IHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzID0gKFxuICAgIG9yaWVudGF0aW9uLCBzdHlsZXNSZWYsIGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBwYWRkaW5nKSA9PiB7XG5cbiAgICBjb25zdCBsb2NhbHN0eWxlcyA9IHsuLi5zdHlsZXNSZWYuY3VycmVudH0gLy8gbmV3IG9iamVjdFxuICAgIGxldCBoZWlnaHQsIHdpZHRoLCBtaW5IZWlnaHQsIG1pbldpZHRoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgIG1pbldpZHRoID0gKGNlbGxXaWR0aCArIChwYWRkaW5nICogMikpICsgJ3B4J1xuICAgICAgICBtaW5IZWlnaHQgPSBudWxsXG4gICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnXG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgICAgICBtaW5IZWlnaHQgPSAoY2VsbEhlaWdodCArIChwYWRkaW5nICogMikpICsgJ3B4J1xuICAgICAgICBtaW5XaWR0aCA9IG51bGxcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuICAgIGxvY2Fsc3R5bGVzLm1pbkhlaWdodCA9IG1pbkhlaWdodFxuICAgIGxvY2Fsc3R5bGVzLm1pbldpZHRoID0gbWluV2lkdGhcblxuICAgIHJldHVybiBsb2NhbHN0eWxlc1xuXG59XG4iXSwibmFtZXMiOlsiU2Nyb2xsYmxvY2siLCJjaGlsZHJlbiIsImxpc3RzaXplIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRfMSIsImJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZiIsImxpbmVyU3R5bGUiLCJzY3JvbGxibG9jayIsInBvc2l0aW9uIiwiZGl2bGluZXJzdHlsZVJlZiIsImN1cnJlbnQiLCJkaXZsaW5lcnN0eWxlIiwic2F2ZURpdmxpbmVyc3R5bGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInVwZGF0ZUJhc2VCbG9ja0xlbmd0aCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzIiwibGF5b3V0c3BlY3MiLCJiYXNlc2Nyb2xsYmxvY2tsZW5ndGgiLCJjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoIiwicmVhY3RfMSIsInN0eWxlIiwiZXhwb3J0cyIsImNyb3NzbGVuZ3RoIiwiY2VsbExlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGgiLCJjcm9zc2NvdW50IiwiTWF0aCIsImZsb29yIiwibGlzdHJvd2NvdW50IiwiY2VpbCIsImJhc2VsZW5ndGgiLCJzdHlsZXNSZWYiLCJiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYiLCJsb2NhbHN0eWxlcyIsIm1pbkhlaWdodCIsIm1pbldpZHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Viewport.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide viewport data to its children (scrollblock and cradle) through the\n    ViewportContext object, and act as the visible screen portal of the list being shown.\n    If Viewport is resized, it notifies the Cradle to reconfigure.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nexports.ViewportContext = react_1["default"].createContext(null); // for children\n// import { ResizeObserver as ResizeObserverPollyfill } from \'@juggle/resize-observer\'\n// const ResizeObserver = window[\'ResizeObserver\'] || ResizeObserverPollyfill\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation;\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    viewportState = _ref3[0],\n    setViewportState = _ref3[1]; // setup, resizing, resized, ready\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var viewportElementRef = (0, react_1.useRef)(null);\n  // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  });\n  // mark as unmounted\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // --------------------[ viewport resizer interrupt ]-----------------------\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null);\n  // set up resizeObserver\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current);\n    // unmount\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  // used by resizeObserver; generates interrupt\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target;\n    // no need to trigger interrupt on first resize notification\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    }\n    // generate interrupt response, if initiating resize\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true;\n      // new object creation triggers a realtime interrupt message to cradle through context\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    }\n    // finalize resizing after timeout\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []);\n  // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n  var divlinerstyleRef = (0, react_1.useRef)(null);\n  // initialize with inherited styles\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'scroll\',\n      WebkitOverflowScrolling: \'touch\',\n      overflowAnchor: \'none\'\n    });\n  }, [styles.viewport]);\n  // update ViewportContextPropertiesRef; add viewport dimensions\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n      top = _viewportElementRef$c.top,\n      right = _viewportElementRef$c.right,\n      bottom = _viewportElementRef$c.bottom,\n      left = _viewportElementRef$c.left;\n    var width = right - left;\n    var height = bottom - top;\n    // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    };\n    // trigger context change with new object\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]);\n  // --------------------[ state processing ]---------------------------\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]);\n  // ----------------------[ render ]--------------------------------\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjdCLGtCQUFrQixFQUFDO1FBQUN1QixHQUFHLEVBQUhBLEdBQUc7UUFBQ0MsS0FBSyxFQUFMQSxLQUFLO1FBQUVDLE1BQU0sRUFBTkEsTUFBTTtRQUFFQyxJQUFJLEVBQUpBLElBQUk7UUFBRUMsS0FBSyxFQUFMQSxLQUFLO1FBQUVDLE1BQU0sRUFBTkE7TUFBTSxDQUFDO01BQzNEM0IsVUFBVSxFQUFDSixrQkFBa0I7TUFDN0JFLFVBQVUsRUFBQ0ksYUFBYSxDQUFDUjtLQUM1QjtJQUVEO0lBQ0EsSUFBTW1DLGtCQUFrQixtQ0FBT2hDLDRCQUE0QixDQUFDSCxPQUFPLEdBQUtrQyxpQkFBaUIsQ0FBQztJQUUxRixPQUFRQyxrQkFBa0I7RUFFOUIsQ0FBQyxFQUFDLENBQUN2QyxXQUFXLEVBQUVZLGFBQWEsQ0FBQ1IsT0FBTyxFQUFFSCxhQUFhLENBQUMsQ0FBQztFQUV0RDtFQUVBLDJCQUFlLEVBQUMsWUFBSTtJQUNoQixRQUFRQSxhQUFhO01BRWpCLEtBQUssU0FBUztNQUNkLEtBQUssT0FBTztRQUFFO1VBQ1ZDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztVQUN6Qjs7SUFDSDtFQUdULENBQUMsRUFBQyxDQUFDRCxhQUFhLENBQUMsQ0FBQztFQUVsQjtFQUVBLE9BQU9ULGlDQUFDRCx1QkFBZSxDQUFDaUQsUUFBUTtJQUFDQyxLQUFLLEVBQUtsQyw0QkFBNEIsQ0FBQ0g7RUFBTyxHQUMzRVo7SUFBQSxhQUNnQixVQUFVO0lBQUEsbUJBQ0ZNLFVBQVU7SUFDOUI0QyxLQUFLLEVBQUtsQixnQkFBZ0IsQ0FBQ3BCLE9BQU87SUFDbEN1QyxHQUFHLEVBQUtyQztFQUFrQixHQUV2QkwsYUFBYSxJQUFJLE9BQU8sSUFBS04sUUFBUSxDQUN0QyxDQUNpQjtBQUUvQixDQUFDLEVBQUM7QUFFRkosa0JBQUFBLEdBQWVHLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1ZpZXdwb3J0LnRzeD9jODI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXdwb3J0LnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB2aWV3cG9ydCBpcyB0byBwcm92aWRlIHZpZXdwb3J0IGRhdGEgdG8gaXRzIGNoaWxkcmVuIChzY3JvbGxibG9jayBhbmQgY3JhZGxlKSB0aHJvdWdoIHRoZVxuICAgIFZpZXdwb3J0Q29udGV4dCBvYmplY3QsIGFuZCBhY3QgYXMgdGhlIHZpc2libGUgc2NyZWVuIHBvcnRhbCBvZiB0aGUgbGlzdCBiZWluZyBzaG93bi5cbiAgICBJZiBWaWV3cG9ydCBpcyByZXNpemVkLCBpdCBub3RpZmllcyB0aGUgQ3JhZGxlIHRvIHJlY29uZmlndXJlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7XG5cbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlUmVmLCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlTWVtbywgXG4gICAgdXNlQ2FsbGJhY2ssIFxuXG59IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKSAvLyBmb3IgY2hpbGRyZW5cblxuLy8gaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgYXMgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGwgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcidcblxuLy8gY29uc3QgUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3dbJ1Jlc2l6ZU9ic2VydmVyJ10gfHwgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGxcblxuY29uc3QgVmlld3BvcnQgPSAoe1xuXG4gICAgY2hpbGRyZW4sIFxuICAgIGdyaWRTcGVjcyxcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbiAgICAvLyBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG4gICAgXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIC8vIGdhcCxcbiAgICAgICAgLy8gcGFkZGluZyxcbiAgICAgICAgLy8gY2VsbEhlaWdodCxcbiAgICAgICAgLy8gY2VsbFdpZHRoLFxuICAgICAgICAvLyBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICBjb25zdCBbdmlld3BvcnRTdGF0ZSxzZXRWaWV3cG9ydFN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCByZXNpemluZywgcmVzaXplZCwgcmVhZHlcblxuICAgIGNvbnN0IHZpZXdwb3J0U3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gZm9yIHVzZUNhbGxiYWNrIC0+IHJlc2l6ZUNhbGxiYWNrIHNjb3BlXG4gICAgdmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID0gdmlld3BvcnRTdGF0ZVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgaXMgcGFzc2VkIGFzIGEgcmVzaXppbmcgaW50ZXJydXB0ICh0aHJvdWdoIGNvbnRleHQpIHRvIGNoaWxkcmVuXG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgaXNSZXNpemluZzpmYWxzZSwgXG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6bnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6bnVsbFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gbWFyayBhcyB1bm1vdW50ZWRcbiAgICB1c2VFZmZlY3QoKCkgPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHZpZXdwb3J0IHJlc2l6ZXIgaW50ZXJydXB0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVzaXplVGltZXJpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGlzUmVzaXppbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7ICAgIFxuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVudHJpZXNbMF0udGFyZ2V0XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byB0cmlnZ2VyIGludGVycnVwdCBvbiBmaXJzdCByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQgPSAndHJ1ZSdcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJydXB0IHJlc3BvbnNlLCBpZiBpbml0aWF0aW5nIHJlc2l6ZVxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG5cbiAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgY3JlYXRpb24gdHJpZ2dlcnMgYSByZWFsdGltZSBpbnRlcnJ1cHQgbWVzc2FnZSB0byBjcmFkbGUgdGhyb3VnaCBjb250ZXh0XG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxpemUgcmVzaXppbmcgYWZ0ZXIgdGltZW91dFxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNvbmZpZyB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzdHlsZXNcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplIHdpdGggaW5oZXJpdGVkIHN0eWxlc1xuICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIC4uLnN0eWxlcy52aWV3cG9ydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICBpbnNldDowLFxuICAgICAgICAgICAgb3ZlcmZsb3c6J3Njcm9sbCcsLy8nYXV0bycsICdzY3JvbGwnIGZvciBpT1MgU2FmYXJpXG4gICAgICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJywvLyBmb3IgaU9TIFNhZmFyaVxuICAgICAgICAgICAgb3ZlcmZsb3dBbmNob3I6J25vbmUnLCAvLyBjcnVjaWFsIVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH0sW3N0eWxlcy52aWV3cG9ydF0pXG5cbiAgICAvLyB1cGRhdGUgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZjsgYWRkIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZSA9PSAnc2V0dXAnKSByZXR1cm4gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSB2aWV3cG9ydEVsZW1lbnRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBjb25zdCB3aWR0aCA9IChyaWdodCAtIGxlZnQpXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IChib3R0b20gLSB0b3ApXG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIGRpbWVuc2lvbiB1cGRhdGUgcHJvY2VkdXJlIGZvciByZXNpemUuIFxuICAgICAgICAvLyBTZWUgYWxzbyBpbnRlcnJ1cHRoYW5kbGVyLnRzeCBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrIGZvciBjcmFkbGUgaW50ZXJzZWN0aW9uIHVwZGF0ZVxuICAgICAgICBjb25zdCBsb2NhbFZpZXdwb3J0RGF0YSA9IHtcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczp7dG9wLHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgICAgICAgZWxlbWVudFJlZjp2aWV3cG9ydEVsZW1lbnRSZWYsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOmlzUmVzaXppbmdSZWYuY3VycmVudCxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBjaGFuZ2Ugd2l0aCBuZXcgb2JqZWN0XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YW9iamVjdCA9IHsuLi5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsIC4uLmxvY2FsVmlld3BvcnREYXRhfVxuXG4gICAgICAgIHJldHVybiAgdmlld3BvcnRkYXRhb2JqZWN0XG5cbiAgICB9LFtvcmllbnRhdGlvbiwgaXNSZXNpemluZ1JlZi5jdXJyZW50LCB2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzdGF0ZSBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgc3dpdGNoICh2aWV3cG9ydFN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiB7XG4gICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0U3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmV0dXJuIDxWaWV3cG9ydENvbnRleHQuUHJvdmlkZXIgdmFsdWUgPSB7IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCB9PlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgZGF0YS10eXBlID0gJ3ZpZXdwb3J0J1xuICAgICAgICAgICAgZGF0YS1zY3JvbGxlcmlkID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgIHN0eWxlID0geyBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgcmVmID0geyB2aWV3cG9ydEVsZW1lbnRSZWYgfVxuICAgICAgICA+XG4gICAgICAgICAgICB7ICh2aWV3cG9ydFN0YXRlICE9ICdzZXR1cCcpICYmIGNoaWxkcmVuIH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9WaWV3cG9ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgXG59IC8vIFZpZXdwb3J0XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWN0XzEiLCJjcmVhdGVDb250ZXh0IiwiVmlld3BvcnQiLCJjaGlsZHJlbiIsImdyaWRTcGVjcyIsInN0eWxlcyIsInNjcm9sbGVySUQiLCJWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCIsIm9yaWVudGF0aW9uIiwidmlld3BvcnRTdGF0ZSIsInNldFZpZXdwb3J0U3RhdGUiLCJ2aWV3cG9ydFN0YXRlUmVmIiwiY3VycmVudCIsImlzTW91bnRlZFJlZiIsInZpZXdwb3J0RWxlbWVudFJlZiIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJpc1Jlc2l6aW5nIiwidmlld3BvcnREaW1lbnNpb25zIiwiZWxlbWVudFJlZiIsInJlc2l6ZVRpbWVyaWRSZWYiLCJpc1Jlc2l6aW5nUmVmIiwicmVzaXplT2JzZXJ2ZXJSZWYiLCJSZXNpemVPYnNlcnZlciIsInJlc2l6ZUNhbGxiYWNrIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJlbnRyaWVzIiwidGFyZ2V0IiwiZGF0YXNldCIsImluaXRpYWxpemVkIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImRpdmxpbmVyc3R5bGVSZWYiLCJ2aWV3cG9ydCIsInBvc2l0aW9uIiwiaW5zZXQiLCJvdmVyZmxvdyIsIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIiwib3ZlcmZsb3dBbmNob3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsImxvY2FsVmlld3BvcnREYXRhIiwidmlld3BvcnRkYXRhb2JqZWN0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInN0eWxlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Placeholder.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n    listsize = _ref.listsize,\n    message = _ref.message,\n    error = _ref.error,\n    userFrameStyles = _ref.userFrameStyles,\n    userLinerStyles = _ref.userLinerStyles,\n    userErrorFrameStyles = _ref.userErrorFrameStyles,\n    userErrorLinerStyles = _ref.userErrorLinerStyles;\n  var _ref2 = (0, react_1.useMemo)(function () {\n      var uFrameStyles = !error ? userFrameStyles : userErrorFrameStyles;\n      var uLinerStyles = !error ? userLinerStyles : userErrorLinerStyles;\n      var frameStyles = Object.assign(Object.assign({\n        border: \'2px solid black\',\n        backgroundColor: \'cyan\'\n      }, uFrameStyles), {\n        position: \'relative\',\n        boxSizing: \'border-box\',\n        height: \'100%\',\n        width: \'100%\',\n        overflow: \'hidden\'\n      });\n      var linerStyles = Object.assign({\n        position: \'absolute\',\n        top: 0,\n        left: 0,\n        padding: \'3px\',\n        margin: \'3px\',\n        fontSize: \'smaller\'\n      }, uLinerStyles);\n      return [frameStyles, linerStyles];\n    }, [error, userFrameStyles, userLinerStyles, userErrorFrameStyles, userErrorLinerStyles]),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameStyles = _ref3[0],\n    linerStyles = _ref3[1];\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    "data-type": \'placeholderframe\',\n    style: frameStyles\n  }, !error ? react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, "item is not available (", error.message, ")"));\n};\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7OztBQVFBO0FBRUEsSUFBTUEsV0FBVyxHQUFHLFNBQWRBLFdBQVcsT0FTWjtFQUFBLElBUkRDLEtBQUssUUFBTEEsS0FBSztJQUNMQyxRQUFRLFFBQVJBLFFBQVE7SUFDUkMsT0FBTyxRQUFQQSxPQUFPO0lBQ1BDLEtBQUssUUFBTEEsS0FBSztJQUNMQyxlQUFlLFFBQWZBLGVBQWU7SUFDZkMsZUFBZSxRQUFmQSxlQUFlO0lBQ2ZDLG9CQUFvQixRQUFwQkEsb0JBQW9CO0lBQ3BCQyxvQkFBb0IsUUFBcEJBLG9CQUFvQjtFQUdwQixZQUFtQyxtQkFBTyxFQUFDLFlBQUk7TUFFM0MsSUFBTUMsWUFBWSxHQUNiLENBQUNMLEtBQUssR0FDSEMsZUFBZSxHQUNmRSxvQkFBb0I7TUFFNUIsSUFBTUcsWUFBWSxHQUNiLENBQUNOLEtBQUssR0FDSEUsZUFBZSxHQUNmRSxvQkFBb0I7TUFFNUIsSUFBTUcsV0FBVztRQUNiQyxNQUFNLEVBQUMsaUJBQWlCO1FBQ3hCQyxlQUFlLEVBQUM7TUFBTSxHQUNuQkosWUFBWTtRQUNmSyxRQUFRLEVBQUMsVUFBVTtRQUNuQkMsU0FBUyxFQUFDLFlBQVk7UUFDdEJDLE1BQU0sRUFBQyxNQUFNO1FBQ2JDLEtBQUssRUFBQyxNQUFNO1FBQ1pDLFFBQVEsRUFBQztNQUFRLEVBQ3BCO01BQ0QsSUFBTUMsV0FBVztRQUNiTCxRQUFRLEVBQUMsVUFBVTtRQUNuQk0sR0FBRyxFQUFDLENBQUM7UUFDTEMsSUFBSSxFQUFDLENBQUM7UUFDTkMsT0FBTyxFQUFDLEtBQUs7UUFDYkMsTUFBTSxFQUFDLEtBQUs7UUFDWkMsUUFBUSxFQUFDO01BQVMsR0FDZmQsWUFBWSxDQUNsQjtNQUVELE9BQU8sQ0FBQ0MsV0FBVyxFQUFFUSxXQUFXLENBQUM7SUFFckMsQ0FBQyxFQUFFLENBQ0NmLEtBQUssRUFDTEMsZUFBZSxFQUNmQyxlQUFlLEVBQ2ZDLG9CQUFvQixFQUNwQkMsb0JBQW9CLENBQ3ZCLENBQUM7SUFBQTtJQXhDS0csV0FBVztJQUFFUSxXQUFXO0VBMkMvQmhCLE9BQU8sR0FBR0EsT0FBTyxhQUFQQSxPQUFPLGNBQVBBLE9BQU8sR0FBSSxjQUFjO0VBRW5DLE9BQU9zQjtJQUFBLGFBQWlCLGtCQUFrQjtJQUFDQyxLQUFLLEVBQUlmO0VBQVcsR0FDekQsQ0FBQ1AsS0FBSyxHQUNKcUI7SUFBQSxhQUFpQixrQkFBa0I7SUFBQ0MsS0FBSyxFQUFLUDtFQUFXLEdBQUlsQixLQUFLLEdBQUcsQ0FBQyxPQUFHQyxRQUFRLE9BQUdDLE9BQU8sQ0FBTyxHQUNsR3NCO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBS1A7RUFBVyw4QkFBMkJmLEtBQUssQ0FBQ0QsT0FBTyxNQUFRLENBRzNHO0FBQ1YsQ0FBQztBQUVEd0Isa0JBQUFBLEdBQWUzQixXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jZWxsZnJhbWUvUGxhY2Vob2xkZXIudHN4P2JiMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGxhY2Vob2xkZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIHRoZSBkZWZhdWx0IFBsYWNlSG9sZGVyIGlzIHRvIGhvbGQgdGhlIGNvbnRlbnQgZGlzcGxheSB1bnRpbCB0aGUgaG9zdCBjb250ZW50XG4gICAgaXMgcmVjZWl2ZWQuIFRoZSBwbGFjZWhvbGRlciBwcmVzZW50cyBhIHdhaXRpbmcgbWVzc2FnZSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiB0aGUgbG9hZFxuICAgIG9mIHRoZSBob3N0IGNvbnRlbnQgZmFpbGVkLlxuXG4gICAgVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY2FuIGJlIHJlcGxhY2VkIGJ5IGEgcGxhY2Vob2xkZXIgcHJvdmlkZWQgYnkgdGhlIGhvc3QuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VNZW1vfSBmcm9tICdyZWFjdCdcblxuY29uc3QgUGxhY2Vob2xkZXIgPSAoe1xuICAgIGluZGV4LCBcbiAgICBsaXN0c2l6ZSwgXG4gICAgbWVzc2FnZSwgXG4gICAgZXJyb3IsIFxuICAgIHVzZXJGcmFtZVN0eWxlcywgXG4gICAgdXNlckxpbmVyU3R5bGVzLFxuICAgIHVzZXJFcnJvckZyYW1lU3R5bGVzLCBcbiAgICB1c2VyRXJyb3JMaW5lclN0eWxlc1xufSkgPT4ge1xuXG4gICAgY29uc3QgW2ZyYW1lU3R5bGVzLCBsaW5lclN0eWxlc10gPSB1c2VNZW1vKCgpPT57XG5cbiAgICAgICAgY29uc3QgdUZyYW1lU3R5bGVzID0gXG4gICAgICAgICAgICAoIWVycm9yKT9cbiAgICAgICAgICAgICAgICB1c2VyRnJhbWVTdHlsZXM6XG4gICAgICAgICAgICAgICAgdXNlckVycm9yRnJhbWVTdHlsZXNcblxuICAgICAgICBjb25zdCB1TGluZXJTdHlsZXMgPSBcbiAgICAgICAgICAgICghZXJyb3IpP1xuICAgICAgICAgICAgICAgIHVzZXJMaW5lclN0eWxlczpcbiAgICAgICAgICAgICAgICB1c2VyRXJyb3JMaW5lclN0eWxlc1xuXG4gICAgICAgIGNvbnN0IGZyYW1lU3R5bGVzID0ge1xuICAgICAgICAgICAgYm9yZGVyOicycHggc29saWQgYmxhY2snLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOidjeWFuJyxcbiAgICAgICAgICAgIC4uLnVGcmFtZVN0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZScsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOicxMDAlJyxcbiAgICAgICAgICAgIG92ZXJmbG93OidoaWRkZW4nLFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVyU3R5bGVzID0ge1xuICAgICAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDowLFxuICAgICAgICAgICAgbGVmdDowLFxuICAgICAgICAgICAgcGFkZGluZzonM3B4JyxcbiAgICAgICAgICAgIG1hcmdpbjonM3B4JyxcbiAgICAgICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgICAgIC4uLnVMaW5lclN0eWxlcyxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnJhbWVTdHlsZXMsIGxpbmVyU3R5bGVzXVxuXG4gICAgfSwgW1xuICAgICAgICBlcnJvcixcbiAgICAgICAgdXNlckZyYW1lU3R5bGVzLCBcbiAgICAgICAgdXNlckxpbmVyU3R5bGVzLFxuICAgICAgICB1c2VyRXJyb3JGcmFtZVN0eWxlcywgXG4gICAgICAgIHVzZXJFcnJvckxpbmVyU3R5bGVzLFxuICAgIF0pXG5cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlID8/ICcobG9hZGluZy4uLiknXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAncGxhY2Vob2xkZXJmcmFtZScgc3R5bGUgPSB7ZnJhbWVTdHlsZXN9PlxuICAgICAgICB7ICFlcnJvcj9cbiAgICAgICAgICAgIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVybGluZXInIHN0eWxlID0geyBsaW5lclN0eWxlcyB9PntpbmRleCArIDF9L3tsaXN0c2l6ZX0ge21lc3NhZ2V9PC9kaXY+OlxuICAgICAgICAgICAgPGRpdiBkYXRhLXR5cGUgPSAncGxhY2Vob2xkZXJsaW5lcicgc3R5bGUgPSB7IGxpbmVyU3R5bGVzIH0+aXRlbSBpcyBub3QgYXZhaWxhYmxlICh7ZXJyb3IubWVzc2FnZX0pPC9kaXY+XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgPC9kaXY+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYWNlaG9sZGVyIl0sIm5hbWVzIjpbIlBsYWNlaG9sZGVyIiwiaW5kZXgiLCJsaXN0c2l6ZSIsIm1lc3NhZ2UiLCJlcnJvciIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJMaW5lclN0eWxlcyIsInVzZXJFcnJvckZyYW1lU3R5bGVzIiwidXNlckVycm9yTGluZXJTdHlsZXMiLCJ1RnJhbWVTdHlsZXMiLCJ1TGluZXJTdHlsZXMiLCJmcmFtZVN0eWxlcyIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsInBvc2l0aW9uIiwiYm94U2l6aW5nIiwiaGVpZ2h0Iiwid2lkdGgiLCJvdmVyZmxvdyIsImxpbmVyU3R5bGVzIiwidG9wIiwibGVmdCIsInBhZGRpbmciLCJtYXJnaW4iLCJmb250U2l6ZSIsInJlYWN0XzEiLCJzdHlsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// scrolltracker.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n    left = _ref.left,\n    offset = _ref.offset,\n    listsize = _ref.listsize,\n    styles = _ref.styles;\n  var trackdata = "".concat(offset + 1, "/").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFPQTtBQUVBLElBQU1BLGFBQWEsR0FBRyxTQUFoQkEsYUFBYSxPQUErQztFQUFBLElBQXpDQyxHQUFHLFFBQUhBLEdBQUc7SUFBRUMsSUFBSSxRQUFKQSxJQUFJO0lBQUVDLE1BQU0sUUFBTkEsTUFBTTtJQUFFQyxRQUFRLFFBQVJBLFFBQVE7SUFBRUMsTUFBTSxRQUFOQSxNQUFNO0VBRXhELElBQU1DLFNBQVMsYUFBTUgsTUFBTSxHQUFHLENBQUMsY0FBSUMsUUFBUSxDQUFFO0VBRTdDLElBQU1HLFFBQVEsR0FBRyxrQkFBTTtJQUNuQk4sR0FBRyxFQUFFQSxHQUFHLEdBQUcsSUFBSTtJQUNmQyxJQUFJLEVBQUVBLElBQUksR0FBRyxJQUFJO0lBQ2pCTSxRQUFRLEVBQUMsT0FBTztJQUNoQkMsTUFBTSxFQUFDLENBQUM7SUFDUkMsZUFBZSxFQUFDLE9BQU87SUFDdkJDLE1BQU0sRUFBRSxnQkFBZ0I7SUFDeEJDLFlBQVksRUFBQyxNQUFNO0lBQ25CQyxRQUFRLEVBQUMsU0FBUztJQUNsQkMsT0FBTyxFQUFDO0VBQUssR0FDVlQsTUFBTSxDQUFDVSxhQUFhLEVBQ3pCO0VBRUYsT0FBT0M7SUFBQSxhQUFpQixlQUFlO0lBQUNDLEtBQUssRUFBSVYsUUFBUSxDQUFDVztFQUFPLEdBQUlaLFNBQVMsQ0FBTztBQUN6RixDQUFDO0FBRURhLGtCQUFBQSxHQUFlbkIsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4PzBiM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2Nyb2xsdHJhY2tlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2YgU2Nyb2xsVHJhY2tlciBpcyB0byBwcm92aWRlIGZlZWRiYWNrIHRvIHRoZSB1c2VyIG9mIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGVcbiAgICB2aXJ0dWFsIGxpc3QgZHVyaW5nIHJlcG9zaXRpb25nLlxuXG4gICAgU2Nyb2xsVHJhY2tlciBjYW4gYmUgc3VwcHJlc3NlZCBieSB0aGUgaG9zdCAoaW4gZmF2b3VyIG9mIHRoZSBob3N0J3Mgb3duIGxvY2F0aW9uIGZlZWRiYWNrKVxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmfSBmcm9tICdyZWFjdCdcblxuY29uc3QgU2Nyb2xsVHJhY2tlciA9ICh7IHRvcCwgbGVmdCwgb2Zmc2V0LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGNvbnN0IHRyYWNrZGF0YSA9IGAke29mZnNldCArIDF9LyR7bGlzdHNpemV9YFxuXG4gICAgY29uc3Qgc3R5bGVSZWYgPSB1c2VSZWYoe1xuICAgICAgICB0b3A6IHRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjonZml4ZWQnLFxuICAgICAgICB6SW5kZXg6MyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBncmF5JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOicxMHB4JyxcbiAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICBwYWRkaW5nOiczcHgnLFxuICAgICAgICAuLi5zdHlsZXMuc2Nyb2xsdHJhY2tlclxuICAgIH0pXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLW5hbWUgPSAnc2Nyb2xsdHJhY2tlcicgc3R5bGUgPSB7c3R5bGVSZWYuY3VycmVudH0gPnt0cmFja2RhdGF9PC9kaXY+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFRyYWNrZXIiXSwibmFtZXMiOlsiU2Nyb2xsVHJhY2tlciIsInRvcCIsImxlZnQiLCJvZmZzZXQiLCJsaXN0c2l6ZSIsInN0eWxlcyIsInRyYWNrZGF0YSIsInN0eWxlUmVmIiwicG9zaXRpb24iLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJmb250U2l6ZSIsInBhZGRpbmciLCJzY3JvbGx0cmFja2VyIiwicmVhY3RfMSIsInN0eWxlIiwiY3VycmVudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/cachehandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// cachehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PortalMasterCache = exports.CachePartition = exports.CacheHandler = void 0;\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user functionsCallback callback for details. The cacheMax property allows for control of the\n    maximum device memory consumption of the cache.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden cache,\n    from whence the components are pulled into the relevant CellFrames for display. The user components are\n    stored in React portals, with each portal instantiated in a container div (data-type = \'portalwrapper\').\n    These container divs are part of a standard React component list in the real DOM. The contained portals\n    themselves are not part of the real DOM, but are part of React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle without losing state, and the ability to maintain state for\n    complex components which move beyond the scope of the content of the Cradle.\n\n    There is an important side effect to consider. Instantiated components which are removed from the real DOM\n    into the portal of the virtual DOM have their scroll positions, width, and height set to zero. Therefore if\n    components rely on these values for configuration, they must have a way of storing those values in state\n    (notably the Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing scrollerPropertiesRef and cellFrameDataRef\n        - if your component does not scroll, there should be no issues.\n\n    Note that in the following, scrollerID is provided as a paramter to some functions for debug purposes, but not used.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\n// the cache itself is maintained in the root infinitegridscroller component\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, setListsize, listsizeRef, CACHE_PARTITION_SIZE) {\n    var _this = this;\n    _classCallCheck(this, CacheHandler);\n    this.globalItemID = 0;\n    this.globalPartitionID = 0;\n    this.cacheProps = {\n      // item data\n      metadataMap: new Map(),\n      indexToItemIDMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      // partition data\n      partitionMetadataMap: new Map(),\n      // for rendering partitions...\n      partitionMap: new Map(),\n      partitionRenderList: null,\n      partitionRepoForceUpdate: null,\n      partitionModifiedSet: new Set(),\n      partitionPtr: null,\n      scrollerID: null // for debug\n    };\n    // ===========================[ CACHE PARTITION MANAGEMENT ]===============================\n    // partitions are added but not removed\n    this.renderPartitionRepo = function () {\n      _this.cacheProps.partitionRenderList = Array.from(_this.cacheProps.partitionMap.values());\n      _this.cacheProps.partitionRepoForceUpdate(_this.cacheProps.partitionRenderList);\n    };\n    this.addPartition = function () {\n      var partitionID = _this.globalPartitionID++;\n      _this.cacheProps.partitionMetadataMap.set(partitionID, {\n        portalMap: new Map(),\n        mapcount: 0,\n        portalRenderList: null,\n        modified: false,\n        forceUpdate: null,\n        partitionID: partitionID\n      });\n      var resolvefunc = {\n        current: null\n      };\n      var promise = new Promise(function (resolve) {\n        resolvefunc.current = resolve;\n      });\n      var callback = function callback() {\n        resolvefunc.current(partitionID);\n      };\n      _this.cacheProps.partitionMap.set(partitionID, react_1["default"].createElement(exports.CachePartition, {\n        key: partitionID,\n        cacheProps: _this.cacheProps,\n        partitionID: partitionID,\n        callback: callback\n      }));\n      _this.renderPartitionRepo();\n      return promise;\n    };\n    this.addPartitionPortal = function (partitionID, itemID, portal) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap.set(itemID, portal);\n      _this.cacheProps.partitionModifiedSet.add(partitionID);\n    };\n    this.removePartitionPortal = function (partitionID, itemID) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap["delete"](itemID);\n      partitionMetadata.mapcount -= 1;\n      _this.cacheProps.partitionModifiedSet.add(partitionID);\n    };\n    this.renderPartition = function (partitionID) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      if (!partitionMetadata) return;\n      partitionMetadata.portalRenderList = Array.from(partitionMetadata.portalMap.values());\n      // if forceUpdate has not yet been assigned, it is in the works from first call of partition\n      partitionMetadata.forceUpdate && partitionMetadata.forceUpdate(partitionMetadata.portalRenderList);\n    };\n    // set state of the CachePartition component of the scroller to trigger render\n    this.renderPortalLists = function () {\n      var partitionModifiedSet = _this.cacheProps.partitionModifiedSet;\n      if (partitionModifiedSet.size) {\n        partitionModifiedSet.forEach(function (partitionID) {\n          _this.renderPartition(partitionID);\n        });\n        _this.cacheProps.partitionModifiedSet.clear();\n      }\n    };\n    this.clearCache = function () {\n      // clear base data\n      _this.cacheProps.metadataMap.clear();\n      _this.cacheProps.indexToItemIDMap.clear();\n      _this.cacheProps.requestedSet.clear();\n      // clear cache partitions\n      _this.cacheProps.partitionMetadataMap.clear();\n      _this.cacheProps.partitionMap.clear();\n      _this.cacheProps.partitionRenderList = [];\n      _this.cacheProps.partitionModifiedSet.clear();\n      _this.cacheProps.partitionPtr = null;\n      _this.cacheProps.partitionRepoForceUpdate(null);\n    };\n    //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n    this.changeListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      _this.setListsize(newlistsize);\n      // match cache to newlistsize\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n    // ----------------------[ cache size limit enforceent ]------------------\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      var modelLength = cradleIndexList.length;\n      // determine need for paring\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap,\n        requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexMap.size + requestedSet.size <= max) return false;\n      // sort the map keys\n      var mapkeyslist = Array.from(portalIndexMap.keys()),\n        requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      });\n      // get number to pare\n      var mapLength = mapkeys.length,\n        parecount = mapLength - max;\n      // distribute paring proportionally at front and back\n      var headindex = cradleIndexList[0],\n        tailindex = cradleIndexList[modelLength - 1],\n        headpos = mapkeys.indexOf(headindex),\n        tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos,\n        tailroom = mapLength - (tailpos + 1),\n        pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount),\n        tailparecount = parecount - headparecount;\n      // collect indexes to pare\n      var headlist = mapkeys.slice(0, headparecount),\n        taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n      _this.deletePortal(delList, deleteListCallback);\n      return true;\n    };\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var _this$cacheProps = _this.cacheProps,\n        indexToItemIDMap = _this$cacheProps.indexToItemIDMap,\n        requestedSet = _this$cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n      if (indexToItemIDMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n    this.cacheProps.scrollerID = scrollerID; // for debug\n    this.setListsize = setListsize; // passed from InfiniteGridScroller.setListsize(listsize)\n    this.listsizeRef = listsizeRef; // current list size\n    this.CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE;\n  }\n  _createClass(CacheHandler, [{\n    key: "findPartitionWithRoom",\n    value: function findPartitionWithRoom() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var CACHE_PARTITION_SIZE, partitionMetadataMap, partitionPtr, partitionMetadata, _iterator, _step, _step$value, partitionID, _partitionMetadata;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                CACHE_PARTITION_SIZE = this.CACHE_PARTITION_SIZE;\n                partitionMetadataMap = this.cacheProps.partitionMetadataMap;\n                partitionPtr = this.cacheProps.partitionPtr;\n                if (!(partitionPtr !== null)) {\n                  _context.next = 8;\n                  break;\n                }\n                partitionMetadata = partitionMetadataMap.get(partitionPtr);\n                if (!(partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                  _context.next = 8;\n                  break;\n                }\n                partitionMetadata.mapcount += 1;\n                return _context.abrupt("return", partitionPtr);\n              case 8:\n                partitionPtr = null;\n                _iterator = _createForOfIteratorHelper(partitionMetadataMap);\n                _context.prev = 10;\n                _iterator.s();\n              case 12:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 20;\n                  break;\n                }\n                _step$value = _slicedToArray(_step.value, 2), partitionID = _step$value[0], _partitionMetadata = _step$value[1];\n                if (!(_partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                  _context.next = 18;\n                  break;\n                }\n                _partitionMetadata.mapcount += 1;\n                partitionPtr = partitionID;\n                return _context.abrupt("break", 20);\n              case 18:\n                _context.next = 12;\n                break;\n              case 20:\n                _context.next = 25;\n                break;\n              case 22:\n                _context.prev = 22;\n                _context.t0 = _context["catch"](10);\n                _iterator.e(_context.t0);\n              case 25:\n                _context.prev = 25;\n                _iterator.f();\n                return _context.finish(25);\n              case 28:\n                if (!(partitionPtr === null)) {\n                  _context.next = 34;\n                  break;\n                }\n                _context.next = 31;\n                return this.addPartition();\n              case 31:\n                partitionPtr = _context.sent;\n                partitionMetadata = partitionMetadataMap.get(partitionPtr);\n                partitionMetadata.mapcount += 1;\n              case 34:\n                this.cacheProps.partitionPtr = partitionPtr;\n                return _context.abrupt("return", partitionPtr);\n              case 36:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 22, 25, 28]]);\n      }));\n    }\n    // --------------------------------[ preload ]--------------------------------\n  }, {\n    key: "preload",\n    value: function preload(finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n      var cradleParameters = this.cradleParameters;\n      var scrollerPropertiesRef = cradleParameters.scrollerPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n        stateHandler = _cradleParameters$han.stateHandler,\n        serviceHandler = _cradleParameters$han.serviceHandler,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n        cacheMax = cradleInheritedProperties.cacheMax,\n        listsize = cradleInternalProperties.listsize;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      };\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n          preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n          itemExceptionCallback = _serviceHandler$callb.itemExceptionCallback;\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n          if (!indexToItemIDMap.has(index)) {\n            var promise = this.preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n          if (breakloop.current) break;\n        }\n      }\n      Promise.allSettled(promises).then(function () {\n        _this2.renderPortalLists();\n        finalCallback();\n      });\n    }\n    // =========================[ SNAPSHOTS ]=========================\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map(),\n        indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var _iterator2 = _createForOfIteratorHelper(cradleIndexList),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var index = _step2.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n      var _iterator3 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            key = _step3$value[0],\n            value = _step3$value[1];\n          var index = value.index,\n            component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return cachelist;\n    }\n    // ==========================[ SERVICE SUPPORT ]=========================\n    // move is coerced by servicehandler to be within current list bounds\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(toindex, fromindex, fromhighindex) {\n      var _this$cacheProps2 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n        metadataMap = _this$cacheProps2.metadataMap;\n      // ----------- define parameters ---------------\n      var rangeabsoluteincrement = fromhighindex - fromindex + 1,\n        movedirectionalincrement = toindex - fromindex,\n        tohighindex = toindex + (rangeabsoluteincrement - 1);\n      var shiftdirection = movedirectionalincrement > 0 ?\n      // move up in list\n      -1 :\n      // shift down, make room for shiftingindex above\n      1; // shift up, make room for shiftingindex below\n      var orderedindexlist = Array.from(indexToItemIDMap.keys());\n      orderedindexlist.sort(function (a, b) {\n        return a - b;\n      });\n      var toindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= toindex;\n        }),\n        tohighindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= tohighindex;\n        }),\n        fromindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromindex;\n        }),\n        fromhighindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromhighindex;\n        });\n      // ---------------- capture index data to move ----------------\n      var processtomoveList;\n      if (fromindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        processtomoveList = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        processtomoveList = orderedindexlist.slice(fromindexptr);\n      } else {\n        // scope is entirely in view\n        processtomoveList = orderedindexlist.slice(fromindexptr, fromhighindexptr + 1);\n      }\n      var processtomoveMap = new Map();\n      var capturemoveindex = function capturemoveindex(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n      processtomoveList.forEach(capturemoveindex);\n      // ------------- get list of indexes to shift out of the way ---------------\n      var processtoshiftList;\n      if (shiftdirection == 1) {\n        // block is moving down, shift is up; toindex < fromindex\n        if (toindexptr == -1 && fromindexptr == -1) {\n          processtoshiftList = [];\n        } else if (fromindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(toindexptr);\n        } else {\n          processtoshiftList = orderedindexlist.slice(toindexptr, fromindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          processtoshiftList = [];\n        } else if (tohighindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n      if (shiftdirection == 1) processtoshiftList.reverse();\n      // -------------- move indexes out of the way --------------\n      var processedshiftList = [];\n      var processshiftindex = function processshiftindex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = shiftdirection == -1 ? index - rangeabsoluteincrement : index + rangeabsoluteincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedshiftList.push(newIndex);\n      };\n      processtoshiftList.forEach(processshiftindex);\n      // ------------ replace shifted index space with moved indexes ----------\n      var processedmoveList = [];\n      var processmoveindex = function processmoveindex(itemID, index) {\n        var newIndex = index + movedirectionalincrement; // swap\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n      processtomoveMap.forEach(processmoveindex);\n      // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n      var processedIndexes = [].concat(processedshiftList, processedmoveList);\n      return processedIndexes;\n    }\n    // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      var _this$cacheProps3 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps3.indexToItemIDMap,\n        metadataMap = _this$cacheProps3.metadataMap;\n      // ---------- define range parameters ---------------\n      // high range is the highest index number of the insert/remove operation\n      var highrangeindex = highrange !== null && highrange !== void 0 ? highrange : 0;\n      highrangeindex = highrangeindex > index ? highrangeindex : index;\n      var emptyreturn = [[], [], 0];\n      if (increment == -1) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) return emptyreturn;\n      } else {\n        // addition can at most start at the next index above the current list\n        if (index > listsize) return emptyreturn;\n      }\n      // rangecount is the absolute number in the insert/remove range - contiguous\n      var rangecount = highrangeindex - index + 1;\n      // range increment adds sign to rangecount to indicate add/remove\n      var rangeincrement = rangecount * increment;\n      // highPtr, lowPtr, shrinktoPtr within orderedIndexList.\n      var orderedIndexList = Array.from(indexToItemIDMap.keys());\n      orderedIndexList.sort(function (a, b) {\n        return a - b;\n      });\n      // ---------- define boundaries within ordered cache index list ------------\n      // Ptr = index into array, as opposed to index of virtual list\n      // shrinkptr is the location of the bottom of the shrink range for removals\n      var shrinktoIndex = null;\n      var shrinktoPtr = -1;\n      if (increment == -1) {\n        shrinktoIndex = orderedIndexList.at(-1) + rangeincrement;\n        shrinktoIndex = Math.max(highrangeindex + rangeincrement, shrinktoIndex);\n        shrinktoIndex = Math.min(listsize - 1, shrinktoIndex);\n        shrinktoPtr = orderedIndexList.findIndex(function (value) {\n          return value >= shrinktoIndex;\n        });\n      }\n      // lowPtr and highPtr must be within low and high range\n      var lowPtr = orderedIndexList.findIndex(function (value) {\n        return value >= index && value <= highrangeindex;\n      });\n      var reverseIndexList = Array.from(orderedIndexList);\n      reverseIndexList.reverse();\n      var highPtr = reverseIndexList.findIndex(function (value) {\n        return value <= highrangeindex;\n      });\n      if (highPtr != -1) {\n        highPtr = orderedIndexList.length - 1 - highPtr;\n        if (highPtr < lowPtr) highPtr = -1;\n      }\n      // ----------- list indexes to process, replace, and remove, and items to remove --------\n      var indexesToProcessList,\n        // for either insert or remove\n        indexesToReplaceList = [],\n        // for insert the range being inserted\n        indexesToRemoveList = [],\n        // for remove - end of list; the list is shrinking\n        indexesOfItemsToRemoveList = [],\n        // for remove - within the range of indexes being removed\n        itemsToRemoveList = []; // for remove, derived from the previous\n      // get indexesToProcessList\n      if (lowPtr == -1 && highPtr == -1) {\n        // core scope is out of view\n        indexesToProcessList = [];\n      } else {\n        // core scope is partially or fully in view; lowPtr is available\n        if (increment == 1) {\n          indexesToProcessList = orderedIndexList.slice(lowPtr);\n        } else if (highPtr == -1) {\n          // increment == -1; lowPtr is available\n          indexesToProcessList = [];\n        } else {\n          // increment == -1; lowPtr and highPtr are available\n          indexesToProcessList = orderedIndexList.slice(highPtr + 1);\n        }\n      }\n      var portalItemHoldForDeleteList = []; // hold portals for deletion until after after cradle synch\n      if (increment == 1) {\n        // get indexesToReplaceList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesToReplaceList = [];\n        } else if (highPtr == -1) {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n      } else {\n        // get indexesToRemoveList\n        if (shrinktoPtr == -1) {\n          // core scope is out of view\n          indexesToRemoveList = [];\n        } else {\n          indexesToRemoveList = orderedIndexList.slice(shrinktoPtr + 1);\n        }\n        // get indexesOfItemsToRemoveList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesOfItemsToRemoveList = [];\n        } else if (highPtr == -1) {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n        // get itemsToRemoveList\n        var _iterator4 = _createForOfIteratorHelper(indexesOfItemsToRemoveList),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index = _step4.value;\n            itemsToRemoveList.push(indexToItemIDMap.get(_index));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      // ----------- conduct cache operations ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n      if (increment == 1) indexesToProcessList.reverse();\n      var indexesModifiedList = [];\n      // modify index-to-itemid map, and metadata map\n      var processIndex = function processIndex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        indexesModifiedList.push(newIndex);\n      };\n      indexesToProcessList.forEach(processIndex);\n      // delete remaining indexes and items now duplicates\n      if (increment == 1) {\n        var _iterator5 = _createForOfIteratorHelper(indexesToReplaceList),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index2 = _step5.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else {\n        var _iterator6 = _createForOfIteratorHelper(indexesToRemoveList),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _index3 = _step6.value;\n            indexToItemIDMap["delete"](_index3);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        var _iterator7 = _createForOfIteratorHelper(itemsToRemoveList),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var itemID = _step7.value;\n            var _metadataMap$get = metadataMap.get(itemID),\n              partitionID = _metadataMap$get.partitionID;\n            portalItemHoldForDeleteList.push({\n              itemID: itemID,\n              partitionID: partitionID\n            });\n            metadataMap["delete"](itemID);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n      return [indexesModifiedList, indexesToReplaceList, rangeincrement, portalItemHoldForDeleteList];\n    }\n    // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n  }, {\n    key: "registerRequestedPortal",\n    value: function registerRequestedPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: "removeRequestedPortal",\n    value: function removeRequestedPortal(index) {\n      this.cacheProps.requestedSet["delete"](index);\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return this.globalItemID++;\n    }\n    // get new or existing itemID for contentfunctions.createCellFrame\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    }\n    // create new portal\n  }, {\n    key: "createPortal",\n    value: function createPortal(component, index, itemID, scrollerProperties) {\n      var isPreload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this$cradleParameter, layout, cellHeight, cellWidth, orientation, portalNode, partitionID, portal, portalMetadata;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.removeRequestedPortal(index);\n                _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current, layout = _this$cradleParameter.layout, cellHeight = _this$cradleParameter.cellHeight, cellWidth = _this$cradleParameter.cellWidth, orientation = _this$cradleParameter.orientation;\n                portalNode = createPortalNode(index, itemID);\n                _context2.next = 5;\n                return this.findPartitionWithRoom();\n              case 5:\n                partitionID = _context2.sent;\n                portal = react_1["default"].createElement("div", {\n                  "data-type": \'portalwrapper\',\n                  key: itemID,\n                  "data-itemid": itemID,\n                  "data-index": index\n                }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n                  key: itemID,\n                  node: portalNode\n                }, " ", component, " "));\n                this.addPartitionPortal(partitionID, itemID, portal);\n                portalMetadata = {\n                  portalNode: portalNode,\n                  index: index,\n                  itemID: itemID,\n                  scrollerProperties: scrollerProperties,\n                  component: component,\n                  partitionID: partitionID\n                };\n                this.cacheProps.metadataMap.set(itemID, portalMetadata);\n                this.cacheProps.indexToItemIDMap.set(index, itemID);\n                if (!isPreload) this.renderPortalLists();\n                return _context2.abrupt("return", portalMetadata);\n              case 13:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    // used for preloading new item\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                itemID = this.getNewItemID();\n                _context3.prev = 1;\n                _context3.next = 4;\n                return getItem(index, itemID);\n              case 4:\n                usercontent = _context3.sent;\n                if (usercontent === null) returnvalue = usercontent;\n                _context3.next = 12;\n                break;\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3["catch"](1);\n                returnvalue = usercontent = undefined;\n                error = _context3.t0;\n              case 12:\n                if (usercontent !== null && usercontent !== undefined) {\n                  if (!react_1["default"].isValidElement(usercontent)) {\n                    returnvalue = usercontent;\n                    usercontent = undefined;\n                    error = new Error(\'invalid React element\');\n                  }\n                }\n                if (!(usercontent !== null && usercontent !== undefined)) {\n                  _context3.next = 20;\n                  break;\n                }\n                scrollerProperties = {\n                  scrollerPropertiesRef: scrollerPropertiesRef\n                };\n                if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                  content = react_1["default"].cloneElement(usercontent, {\n                    scrollerProperties: scrollerProperties\n                  });\n                } else {\n                  content = usercontent;\n                }\n                // const portalData = \n                _context3.next = 18;\n                return this.createPortal(content, index, itemID, scrollerProperties, true);\n              case 18:\n                _context3.next = 21;\n                break;\n              case 20:\n                if (usercontent === undefined) {\n                  itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', error);\n                } else {\n                  // usercontent === null; last item in list\n                  itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                  maxListsizeInterrupt(index);\n                }\n              case 21:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 8]]);\n      }));\n    }\n    // delete a portal list item\n    // accepts an array of indexes\n  }, {\n    key: "deletePortal",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps4 = this.cacheProps,\n        metadataMap = _this$cacheProps4.metadataMap,\n        indexToItemIDMap = _this$cacheProps4.indexToItemIDMap;\n      var removePartitionPortal = this.removePartitionPortal;\n      var deleteList = [];\n      var _iterator8 = _createForOfIteratorHelper(indexArray),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _index4 = _step8.value;\n          var itemID = indexToItemIDMap.get(_index4);\n          if (itemID === undefined) continue; // async mismatch\n          deleteList.push({\n            index: _index4,\n            itemID: itemID\n          });\n          var _metadataMap$get2 = metadataMap.get(itemID),\n            partitionID = _metadataMap$get2.partitionID;\n          removePartitionPortal(partitionID, itemID);\n          metadataMap["delete"](itemID);\n          indexToItemIDMap["delete"](_index4);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      deleteListCallback && deleteListCallback(deleteList);\n    }\n    // query existence of a portal list item\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortalMetadata",\n    value: function getPortalMetadata(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n  return CacheHandler;\n}();\nexports.CacheHandler = CacheHandler;\n// ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n// see also some styles set in CellFrame\nvar createPortalNode = function createPortalNode(index, itemID) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n};\n// ========================[ Utility components ]==============================\n// portal list component for rapid relisting of updates, using external callback for set state\nvar CachePartition = function CachePartition(_ref) {\n  var cacheProps = _ref.cacheProps,\n    partitionID = _ref.partitionID,\n    callback = _ref.callback;\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalListCounter = _ref3[0],\n    setPortalListCounter = _ref3[1];\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n    _ref5 = _slicedToArray(_ref4, 2),\n    partitionState = _ref5[0],\n    setPartitionState = _ref5[1];\n  var counterRef = (0, react_1.useRef)(portalListCounter);\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null);\n  var partitionMetadata = cacheProps.partitionMetadataMap.get(partitionID);\n  var forceUpdate = (0, react_1.useCallback)(function (portalRenderList) {\n    portalArrayRef.current = portalRenderList;\n    isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    partitionMetadata.forceUpdate = forceUpdate;\n    callback();\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (partitionState) {\n      case \'setup\':\n        {\n          setPartitionState(\'ready\');\n          break;\n        }\n    }\n  }, [partitionState]);\n  return react_1["default"].createElement("div", {\n    key: partitionID,\n    "data-type": \'cachepartition\',\n    "data-partitionid": partitionID\n  }, portalArrayRef.current);\n};\nexports.CachePartition = CachePartition;\nvar PortalMasterCache = function PortalMasterCache(_ref6) {\n  var cacheProps = _ref6.cacheProps;\n  var _ref7 = (0, react_1.useState)(0),\n    _ref8 = _slicedToArray(_ref7, 2),\n    portalCacheCounter = _ref8[0],\n    setPortalCacheCounter = _ref8[1];\n  var counterRef = (0, react_1.useRef)(portalCacheCounter);\n  var _ref9 = (0, react_1.useState)(\'setup\'),\n    _ref10 = _slicedToArray(_ref9, 2),\n    masterState = _ref10[0],\n    setMasterState = _ref10[1];\n  var isMountedRef = (0, react_1.useRef)(true);\n  var partitionArrayRef = (0, react_1.useRef)(null);\n  var partitionRepoForceUpdate = (0, react_1.useCallback)(function (partitionRenderList) {\n    partitionArrayRef.current = partitionRenderList;\n    isMountedRef.current && setPortalCacheCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    cacheProps.partitionRepoForceUpdate = partitionRepoForceUpdate;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (masterState) {\n      case \'setup\':\n        {\n          setMasterState(\'ready\');\n        }\n    }\n  }, [masterState]);\n  return react_1["default"].createElement("div", {\n    "data-type": \'portal-master\'\n  }, partitionArrayRef.current);\n};\nexports.PortalMasterCache = PortalMasterCache;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtJQUU5RCxPQUFPLFlBQUs7TUFFUm9HLFlBQVksQ0FBQ3BGLE9BQU8sR0FBRyxLQUFLO0lBRWhDLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUwscUJBQVMsRUFBQyxZQUFJO0lBRVYsUUFBUThMLFdBQVc7TUFDZixLQUFLLE9BQU87UUFBRTtVQUNWQyxjQUFjLENBQUMsT0FBTyxDQUFDOztJQUMxQjtFQUdULENBQUMsRUFBQyxDQUFDRCxXQUFXLENBQUMsQ0FBQztFQUVoQixPQUFPekw7SUFBQSxhQUFpQjtFQUFlLEdBQUUyTCxpQkFBaUIsQ0FBQ2hNLE9BQU8sQ0FBTztBQUU3RSxDQUFDO0FBN0NZTSx5QkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jYWNoZWhhbmRsZXIudHN4PzllOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FjaGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBtYW5hZ2VzIHRoZSBJbmZpbml0ZUdyaWRTY3JvbGxlciBsaW1pdGVkIChzcGFyc2UpIGNhY2hlLiBJdCBhbHNvIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFxuICAgIHNlcnZpY2VzIHdoaWNoIGFsbG93IHRoZSBob3N0IHRvIGFjdGl2ZWx5IG1hbmFnZSBtYW55IGFzcGVjdHMgb2YgdGhlIGNhY2hlLiBTZWUgZG9jdW1lbnRhdGlvblxuICAgIGFib3V0IHRoZSB1c2VyIGZ1bmN0aW9uc0NhbGxiYWNrIGNhbGxiYWNrIGZvciBkZXRhaWxzLiBUaGUgY2FjaGVNYXggcHJvcGVydHkgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZVxuICAgIG1heGltdW0gZGV2aWNlIG1lbW9yeSBjb25zdW1wdGlvbiBvZiB0aGUgY2FjaGUuXG5cbiAgICBUaGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlciBzdG9yZXMgdXNlciBjZWxsIGNvbnRlbnQgKGNvbXBvbmVudHMpIGluIGEgY2VudHJhbCBoaWRkZW4gY2FjaGUsIFxuICAgIGZyb20gd2hlbmNlIHRoZSBjb21wb25lbnRzIGFyZSBwdWxsZWQgaW50byB0aGUgcmVsZXZhbnQgQ2VsbEZyYW1lcyBmb3IgZGlzcGxheS4gVGhlIHVzZXIgY29tcG9uZW50cyBhcmUgXG4gICAgc3RvcmVkIGluIFJlYWN0IHBvcnRhbHMsIHdpdGggZWFjaCBwb3J0YWwgaW5zdGFudGlhdGVkIGluIGEgY29udGFpbmVyIGRpdiAoZGF0YS10eXBlID0gJ3BvcnRhbHdyYXBwZXInKS4gXG4gICAgVGhlc2UgY29udGFpbmVyIGRpdnMgYXJlIHBhcnQgb2YgYSBzdGFuZGFyZCBSZWFjdCBjb21wb25lbnQgbGlzdCBpbiB0aGUgcmVhbCBET00uIFRoZSBjb250YWluZWQgcG9ydGFscyBcbiAgICB0aGVtc2VsdmVzIGFyZSBub3QgcGFydCBvZiB0aGUgcmVhbCBET00sIGJ1dCBhcmUgcGFydCBvZiBSZWFjdCdzIHZpcnR1YWwgRE9NLlxuXG4gICAgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9wb3J0YWxzLmh0bWwgZm9yIGdlbmVyYWwgaW5mb3JtYXRpb24gYWJvdXQgUmVhY3QgcG9ydGFscy5cbiAgICBTZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtcmV2ZXJzZS1wb3J0YWwgZm9yIHRoZSB1dGlsaXR5IHRoYXQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcbiAgICB1c2VzIHRvIG1hbmFnZSBwb3J0YWxzLlxuXG4gICAgVGhpcyBjYWNoaW5nIGhhcyBtYW55IGFkdmFudGFnZXMsIG5vdGFibHkgdGhlIGFiaWxpdHkgdG8gbW92ZSBjZWxscyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZVxuICAgIGhlYWQgYW5kIHRhaWwgZ3JpZHMgb2YgdGhlIENyYWRsZSB3aXRob3V0IGxvc2luZyBzdGF0ZSwgYW5kIHRoZSBhYmlsaXR5IHRvIG1haW50YWluIHN0YXRlIGZvciBcbiAgICBjb21wbGV4IGNvbXBvbmVudHMgd2hpY2ggbW92ZSBiZXlvbmQgdGhlIHNjb3BlIG9mIHRoZSBjb250ZW50IG9mIHRoZSBDcmFkbGUuIFxuXG4gICAgVGhlcmUgaXMgYW4gaW1wb3J0YW50IHNpZGUgZWZmZWN0IHRvIGNvbnNpZGVyLiBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZWFsIERPTSBcbiAgICBpbnRvIHRoZSBwb3J0YWwgb2YgdGhlIHZpcnR1YWwgRE9NIGhhdmUgdGhlaXIgc2Nyb2xsIHBvc2l0aW9ucywgd2lkdGgsIGFuZCBoZWlnaHQgc2V0IHRvIHplcm8uIFRoZXJlZm9yZSBpZiBcbiAgICBjb21wb25lbnRzIHJlbHkgb24gdGhlc2UgdmFsdWVzIGZvciBjb25maWd1cmF0aW9uLCB0aGV5IG11c3QgaGF2ZSBhIHdheSBvZiBzdG9yaW5nIHRob3NlIHZhbHVlcyBpbiBzdGF0ZSBcbiAgICAobm90YWJseSB0aGUgU2Nyb2xsIFBvcyAtIHNjcm9sbExlZnQgb3Igc2Nyb2xsVG9wKSwgcmVjb2duaXppbmcgd2hlbiB0aGUgY29tcG9uZW50IGNvbWVzIG91dCBvZiB0aGUgcG9ydGFsIGNhY2hlIFxuICAgIGludG8gdGhlIHJlYWwgRE9NICh3aWR0aCBhbmQgaGVpZ2h0IGFyZSB0eXBpY2FsbHkgbm8gbG9uZ2VyIGJvdGggMCksIGFuZCByZXNwb25kaW5nIHRvIGNoYW5nZSBpbiBcbiAgICBjYWNoZSBzdGF0ZSBhcHByb3ByaWF0ZWx5LlxuXG4gICAgVGlwczpcbiAgICAgICAgLSB5b3VyIGNvbXBvbmVudCBpcyBpbiBjYWNoZSB3aGVuIGJvdGggd2lkdGggYW5kIGhlaWdodCA9IDBcbiAgICAgICAgLSB5b3VyIGNvbXBvbmVudCBpcyBvdXQgb2YgY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGJhY2sgdG8gbm9ybWFsXG4gICAgICAgIC0gaWYgeW91IGNyZWF0ZSBhbiBlbXB0eSAnc2Nyb2xsZXJQcm9wZXJ0aWVzJyBwcm9wZXJ0eSBmb3IgeW91ciBjb21wb25lbnQsIENlbGxGcmFtZSB3aWxsXG4gICAgICAgICAgICBzZXQgaXQgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIGFuZCBjZWxsRnJhbWVEYXRhUmVmXG4gICAgICAgIC0gaWYgeW91ciBjb21wb25lbnQgZG9lcyBub3Qgc2Nyb2xsLCB0aGVyZSBzaG91bGQgYmUgbm8gaXNzdWVzLlxuXG4gICAgTm90ZSB0aGF0IGluIHRoZSBmb2xsb3dpbmcsIHNjcm9sbGVySUQgaXMgcHJvdmlkZWQgYXMgYSBwYXJhbXRlciB0byBzb21lIGZ1bmN0aW9ucyBmb3IgZGVidWcgcHVycG9zZXMsIGJ1dCBub3QgdXNlZC5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2t9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgSW5Qb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCdcblxuLy8gdGhlIGNhY2hlIGl0c2VsZiBpcyBtYWludGFpbmVkIGluIHRoZSByb290IGluZmluaXRlZ3JpZHNjcm9sbGVyIGNvbXBvbmVudFxuZXhwb3J0IGNsYXNzIENhY2hlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxlcklELCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYsIENBQ0hFX1BBUlRJVElPTl9TSVpFKSB7XG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5zY3JvbGxlcklEID0gc2Nyb2xsZXJJRCAvLyBmb3IgZGVidWdcbiAgICAgICAgdGhpcy5zZXRMaXN0c2l6ZSA9IHNldExpc3RzaXplIC8vIHBhc3NlZCBmcm9tIEluZmluaXRlR3JpZFNjcm9sbGVyLnNldExpc3RzaXplKGxpc3RzaXplKVxuICAgICAgICB0aGlzLmxpc3RzaXplUmVmID0gbGlzdHNpemVSZWYgLy8gY3VycmVudCBsaXN0IHNpemVcblxuICAgICAgICB0aGlzLkNBQ0hFX1BBUlRJVElPTl9TSVpFID0gQ0FDSEVfUEFSVElUSU9OX1NJWkVcbiAgICB9XG5cbiAgICBnbG9iYWxJdGVtSUQgPSAwXG4gICAgZ2xvYmFsUGFydGl0aW9uSUQgPSAwXG5cbiAgICBjYWNoZVByb3BzID0ge1xuXG4gICAgICAgIC8vIGl0ZW0gZGF0YVxuICAgICAgICBtZXRhZGF0YU1hcDpuZXcgTWFwKCksIC8vIGl0ZW0gPT4ge2luZGV4LCBjb21wb25lbnR9XG4gICAgICAgIGluZGV4VG9JdGVtSURNYXA6bmV3IE1hcCgpLFxuXG4gICAgICAgIC8vIHNvbWUgcG9ydGFscyBtYXkgaGF2ZSBiZWVuIHJlcXVlc3RlZCBieSByZXF1ZXN0aWRsZWNhbGxiYWNrLCBub3QgeWV0IGNyZWF0ZWRcbiAgICAgICAgcmVxdWVzdGVkU2V0Om5ldyBTZXQoKSwgLy8gcmVxdWVzdGVkU2V0IG9mIGluZGV4ZXMgKHRyYW5zaXRpb25hbClcblxuICAgICAgICAvLyBwYXJ0aXRpb24gZGF0YVxuICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YU1hcDpuZXcgTWFwKCksXG4gICAgICAgIC8vIGZvciByZW5kZXJpbmcgcGFydGl0aW9ucy4uLlxuICAgICAgICBwYXJ0aXRpb25NYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgcGFydGl0aW9uUmVuZGVyTGlzdDpudWxsLFxuICAgICAgICBwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGU6bnVsbCxcbiAgICAgICAgcGFydGl0aW9uTW9kaWZpZWRTZXQ6IG5ldyBTZXQoKSxcblxuICAgICAgICBwYXJ0aXRpb25QdHI6bnVsbCwgLy8gYWN0aXZlIHBhcnRpdGlvbiwgZm9yIGZvbGxvd3VwXG5cbiAgICAgICAgc2Nyb2xsZXJJRDpudWxsIC8vIGZvciBkZWJ1Z1xuICAgIH1cblxuICAgIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFXG5cbiAgICBwb3J0YWxJdGVtSG9sZEZvckRlbGV0ZUxpc3QgLy8gYXJyYXkgb2Yge2l0ZW1JRCxwYXJ0aXRpb25JRH1cblxuICAgIGxpc3RzaXplUmVmXG5cbiAgICAvLyBzZXRMaXN0c2l6ZShsaXN0c2l6ZSkgY2F1c2VzIGFuIEluZmluaXRlR3JpZFNjcm9sbGVyIHVzZVN0YXRlIHVwZGF0ZVxuICAgIC8vIG9mIHRoZSBsaXN0c2l6ZSB0aHJvdWdob3V0XG4gICAgc2V0TGlzdHNpemUgLy8gZnVuY3Rpb24gcGFzc2VkIGZyb20gSW5maW5pdGVHcmlkU2Nyb2xsZXJcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVsgQ0FDSEUgUEFSVElUSU9OIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHBhcnRpdGlvbnMgYXJlIGFkZGVkIGJ1dCBub3QgcmVtb3ZlZFxuXG4gICAgcmVuZGVyUGFydGl0aW9uUmVwbyA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uUmVuZGVyTGlzdCA9IEFycmF5LmZyb20odGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1hcC52YWx1ZXMoKSlcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlKHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25SZW5kZXJMaXN0KVxuXG4gICAgfVxuXG4gICAgYWRkUGFydGl0aW9uID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbklEID0gdGhpcy5nbG9iYWxQYXJ0aXRpb25JRCsrXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5zZXQocGFydGl0aW9uSUQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9ydGFsTWFwOm5ldyBNYXAoKSwgXG4gICAgICAgICAgICAgICAgbWFwY291bnQ6MCwgLy8gcG9ydGFsTWFwIHVwZGF0ZSBjYW4gYmUgYXN5bmMsIHNvIG1hcGNvdW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBwb3J0YWxSZW5kZXJMaXN0Om51bGwsIFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOmZhbHNlLFxuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlOm51bGwsXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uSUQsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHJlc29sdmVmdW5jID0ge1xuICAgICAgICAgICAgY3VycmVudDpudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVmdW5jLmN1cnJlbnQgPSByZXNvbHZlXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIHJlc29sdmVmdW5jLmN1cnJlbnQocGFydGl0aW9uSUQpXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NYXAuc2V0KHBhcnRpdGlvbklELFxuICAgICAgICAgICAgPENhY2hlUGFydGl0aW9uIFxuICAgICAgICAgICAgICAgIGtleSA9IHtwYXJ0aXRpb25JRH0gXG4gICAgICAgICAgICAgICAgY2FjaGVQcm9wcyA9IHt0aGlzLmNhY2hlUHJvcHN9IFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbklEID0ge3BhcnRpdGlvbklEfSBcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHsgY2FsbGJhY2sgfSAvPilcblxuICAgICAgICB0aGlzLnJlbmRlclBhcnRpdGlvblJlcG8oKVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlXG5cbiAgICB9XG5cbiAgICBhc3luYyBmaW5kUGFydGl0aW9uV2l0aFJvb20oKSB7XG5cbiAgICAgICAgY29uc3QgeyBDQUNIRV9QQVJUSVRJT05fU0laRSB9ID0gdGhpc1xuXG4gICAgICAgIGNvbnN0IHsgcGFydGl0aW9uTWV0YWRhdGFNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuICAgICAgICBsZXQgeyBwYXJ0aXRpb25QdHIgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGxldCBwYXJ0aXRpb25NZXRhZGF0YVxuICAgICAgICBpZiAocGFydGl0aW9uUHRyICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhID0gcGFydGl0aW9uTWV0YWRhdGFNYXAuZ2V0KHBhcnRpdGlvblB0cilcblxuICAgICAgICAgICAgaWYgKHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50IDwgQ0FDSEVfUEFSVElUSU9OX1NJWkUpIHtcblxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50ICs9IDEgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpdGlvblB0clxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRpdGlvblB0ciA9IG51bGxcbiAgICAgICAgZm9yIChjb25zdCBbcGFydGl0aW9uSUQsIHBhcnRpdGlvbk1ldGFkYXRhXSBvZiBwYXJ0aXRpb25NZXRhZGF0YU1hcCkge1xuXG4gICAgICAgICAgICBpZiAocGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgPCBDQUNIRV9QQVJUSVRJT05fU0laRSkge1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50ICs9IDEgXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uUHRyID0gcGFydGl0aW9uSURcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGl0aW9uUHRyID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHBhcnRpdGlvblB0ciA9IGF3YWl0IHRoaXMuYWRkUGFydGl0aW9uKClcbiAgICAgICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhID0gcGFydGl0aW9uTWV0YWRhdGFNYXAuZ2V0KHBhcnRpdGlvblB0cilcbiAgICAgICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50ICs9IDEgXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25QdHIgPSBwYXJ0aXRpb25QdHJcblxuICAgICAgICByZXR1cm4gcGFydGl0aW9uUHRyXG5cbiAgICB9XG5cbiAgICBhZGRQYXJ0aXRpb25Qb3J0YWwgPSAocGFydGl0aW9uSUQsIGl0ZW1JRCwgcG9ydGFsKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uTWV0YWRhdGEgPSB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTWV0YWRhdGFNYXAuZ2V0KHBhcnRpdGlvbklEKVxuXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLnBvcnRhbE1hcC5zZXQoaXRlbUlELHBvcnRhbClcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTW9kaWZpZWRTZXQuYWRkKHBhcnRpdGlvbklEKVxuXG4gICAgfVxuXG4gICAgcmVtb3ZlUGFydGl0aW9uUG9ydGFsID0gKHBhcnRpdGlvbklELCBpdGVtSUQpID0+IHtcblxuICAgICAgICBjb25zdCBwYXJ0aXRpb25NZXRhZGF0YSA9IHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEucG9ydGFsTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50IC09IDEgXG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1vZGlmaWVkU2V0LmFkZChwYXJ0aXRpb25JRClcblxuICAgIH1cblxuICAgIHJlbmRlclBhcnRpdGlvbiA9IChwYXJ0aXRpb25JRCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1ldGFkYXRhTWFwLmdldChwYXJ0aXRpb25JRClcblxuICAgICAgICBpZiAoIXBhcnRpdGlvbk1ldGFkYXRhKSByZXR1cm5cblxuICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5wb3J0YWxSZW5kZXJMaXN0ID0gIEFycmF5LmZyb20ocGFydGl0aW9uTWV0YWRhdGEucG9ydGFsTWFwLnZhbHVlcygpKVxuXG4gICAgICAgIC8vIGlmIGZvcmNlVXBkYXRlIGhhcyBub3QgeWV0IGJlZW4gYXNzaWduZWQsIGl0IGlzIGluIHRoZSB3b3JrcyBmcm9tIGZpcnN0IGNhbGwgb2YgcGFydGl0aW9uXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLmZvcmNlVXBkYXRlICYmIHBhcnRpdGlvbk1ldGFkYXRhLmZvcmNlVXBkYXRlKHBhcnRpdGlvbk1ldGFkYXRhLnBvcnRhbFJlbmRlckxpc3QpXG5cbiAgICB9XG5cbiAgICAvLyBzZXQgc3RhdGUgb2YgdGhlIENhY2hlUGFydGl0aW9uIGNvbXBvbmVudCBvZiB0aGUgc2Nyb2xsZXIgdG8gdHJpZ2dlciByZW5kZXJcbiAgICByZW5kZXJQb3J0YWxMaXN0cyA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IHBhcnRpdGlvbk1vZGlmaWVkU2V0IH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBpZiAocGFydGl0aW9uTW9kaWZpZWRTZXQuc2l6ZSkge1xuXG4gICAgICAgICAgICBwYXJ0aXRpb25Nb2RpZmllZFNldC5mb3JFYWNoKChwYXJ0aXRpb25JRCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQYXJ0aXRpb24ocGFydGl0aW9uSUQpXG5cbiAgICAgICAgICAgIH0pICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZFNldC5jbGVhcigpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY2xlYXJDYWNoZSA9ICgpID0+IHtcblxuICAgICAgICAvLyBjbGVhciBiYXNlIGRhdGFcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmNsZWFyKClcbiAgICAgICAgLy8gY2xlYXIgY2FjaGUgcGFydGl0aW9uc1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTWV0YWRhdGFNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvblJlbmRlckxpc3QgPSBbXVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTW9kaWZpZWRTZXQuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uUHRyID0gbnVsbFxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlKG51bGwpXG5cbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVQT1NJVE9SWSBBTkQgTElTVCBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBiYXNpYyBvcGVyYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhbmdlTGlzdHNpemUgPSAobmV3bGlzdHNpemUsIGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjaykgPT4ge1xuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgLy8gbWF0Y2ggY2FjaGUgdG8gbmV3bGlzdHNpemVcbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhNYXAgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcFxuICAgICAgICBjb25zdCBtYXBrZXlzTGlzdCA9IEFycmF5LmZyb20ocG9ydGFsSW5kZXhNYXAua2V5cygpKVxuICAgICAgICBtYXBrZXlzTGlzdC5zb3J0KChhLGIpID0+IGEgLSBiKVxuXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RpbmRleCA9IG1hcGtleXNMaXN0LmF0KC0xKVxuXG4gICAgICAgIGlmIChoaWdoZXN0aW5kZXggPiAobmV3bGlzdHNpemUgLTEpKSB7IC8vIHBhcmUgdGhlIGNhY2hlXG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVsaXN0ID0gbWFwa2V5c0xpc3QuZmlsdGVyKChpbmRleCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAobmV3bGlzdHNpemUgLTEpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChwYXJlbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrICYmIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sobmV3bGlzdHNpemUpXG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWNoZSBzaXplIGxpbWl0IGVuZm9yY2VlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbWF0Y2hDYWNoZVRvQ3JhZGxlID0gKGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IEFycmF5LmZyb20odGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuXG4gICAgICAgIGNvbnN0IGRlbGtleXMgPSBtYXBrZXlzLmZpbHRlcihrZXkgPT4gIWNyYWRsZUluZGV4TGlzdC5pbmNsdWRlcyhrZXkpKVxuXG4gICAgICAgIGlmIChkZWxrZXlzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChkZWxrZXlzLCBkZWxldGVMaXN0Q2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHBhcmVDYWNoZVRvTWF4ID0gKGNhY2hlTWF4LCBjcmFkbGVJbmRleExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCA9IHVuZGVmaW5lZCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsTGVuZ3RoID0gY3JhZGxlSW5kZXhMaXN0Lmxlbmd0aFxuXG4gICAgICAgIC8vIGRldGVybWluZSBuZWVkIGZvciBwYXJpbmdcbiAgICAgICAgaWYgKCghY2FjaGVNYXgpIHx8ICghbW9kZWxMZW5ndGgpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChtb2RlbExlbmd0aCwgY2FjaGVNYXgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhNYXAgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcCxcbiAgICAgICAgICAgIHJlcXVlc3RlZFNldCA9IHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXRcblxuICAgICAgICBpZiAoKHBvcnRhbEluZGV4TWFwLnNpemUgKyByZXF1ZXN0ZWRTZXQuc2l6ZSkgPD0gbWF4KSByZXR1cm4gZmFsc2VcblxuICAgICAgICAvLyBzb3J0IHRoZSBtYXAga2V5c1xuICAgICAgICBjb25zdCBtYXBrZXlzbGlzdCA9IEFycmF5LmZyb20ocG9ydGFsSW5kZXhNYXAua2V5cygpKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZGtleXMgPSBBcnJheS5mcm9tKHJlcXVlc3RlZFNldC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IFsuLi5tYXBrZXlzbGlzdCwuLi5yZXF1ZXN0ZWRrZXlzXVxuXG4gICAgICAgIG1hcGtleXMuc29ydCgoYSxiKSA9PiBhIC0gYilcblxuICAgICAgICAvLyBnZXQgbnVtYmVyIHRvIHBhcmVcbiAgICAgICAgY29uc3QgbWFwTGVuZ3RoID0gbWFwa2V5cy5sZW5ndGgsXG4gICAgICAgICAgICBwYXJlY291bnQgPSBtYXBMZW5ndGggLSBtYXhcblxuICAgICAgICAvLyBkaXN0cmlidXRlIHBhcmluZyBwcm9wb3J0aW9uYWxseSBhdCBmcm9udCBhbmQgYmFja1xuICAgICAgICBjb25zdCBoZWFkaW5kZXggPSBjcmFkbGVJbmRleExpc3RbMF0sXG4gICAgICAgICAgICB0YWlsaW5kZXggPSBjcmFkbGVJbmRleExpc3RbbW9kZWxMZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGhlYWRwb3MgPSBtYXBrZXlzLmluZGV4T2YoaGVhZGluZGV4KSxcbiAgICAgICAgICAgIHRhaWxwb3MgPSBtYXBrZXlzLmluZGV4T2YodGFpbGluZGV4KVxuXG4gICAgICAgIGNvbnN0IGhlYWRyb29tID0gaGVhZHBvcyxcbiAgICAgICAgICAgIHRhaWxyb29tID0gbWFwTGVuZ3RoIC0gKHRhaWxwb3MgKyAxKSxcbiAgICAgICAgICAgIHBhcmVyb29tID0gaGVhZHJvb20gKyB0YWlscm9vbVxuXG4gICAgICAgIGNvbnN0IGhlYWRwYXJlY291bnQgPSBNYXRoLmZsb29yKChoZWFkcm9vbS9wYXJlcm9vbSkqcGFyZWNvdW50KSxcbiAgICAgICAgICAgIHRhaWxwYXJlY291bnQgPSBwYXJlY291bnQgLSBoZWFkcGFyZWNvdW50XG5cbiAgICAgICAgLy8gY29sbGVjdCBpbmRleGVzIHRvIHBhcmVcbiAgICAgICAgY29uc3QgaGVhZGxpc3QgPSBtYXBrZXlzLnNsaWNlKDAsaGVhZHBhcmVjb3VudCksXG4gICAgICAgICAgICB0YWlsbGlzdCA9IG1hcGtleXMuc2xpY2UobWFwTGVuZ3RoIC0gdGFpbHBhcmVjb3VudClcblxuICAgICAgICBjb25zdCBkZWxMaXN0ID0gWy4uLmhlYWRsaXN0LC4uLnRhaWxsaXN0XVxuXG4gICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoY2FjaGVNYXgsIGNyYWRsZUxpc3RMZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTikgPT4ge1xuXG4gICAgICAgIGlmICghY2FjaGVNYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAsXG4gICAgICAgICAgICByZXF1ZXN0ZWRTZXQgXG4gICAgICAgIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChjcmFkbGVMaXN0TGVuZ3RoLCBjYWNoZU1heClcblxuICAgICAgICBpZiAoKGluZGV4VG9JdGVtSURNYXAuc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSAoKG1heCkgKiBNQVhfQ0FDSEVfT1ZFUl9SVU4pKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHByZWxvYWQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwcmVsb2FkKGZpbmFsQ2FsbGJhY2ssIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIHNjcm9sbGVySUQpIHtcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCB7IHNjcm9sbGVyUHJvcGVydGllc1JlZiB9ID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgZ2V0SXRlbSwgY2FjaGVNYXggfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICB7IGxpc3RzaXplIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdXG5cbiAgICAgICAgbGV0IGNhY2hlU2l6ZSA9IGNhY2hlTWF4ID8/IDBcblxuICAgICAgICBjYWNoZVNpemUgPSBNYXRoLm1pbihjYWNoZVNpemUsIGxpc3RzaXplKVxuXG4gICAgICAgIGNvbnN0IHByZWxvYWRzaXplID0gXG4gICAgICAgICAgICBjYWNoZVNpemU/XG4gICAgICAgICAgICAgICAgY2FjaGVTaXplOlxuICAgICAgICAgICAgICAgIGxpc3RzaXplXG5cbiAgICAgICAgY29uc3QgYnJlYWtsb29wID0ge1xuICAgICAgICAgICAgY3VycmVudDpmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF4TGlzdHNpemVJbnRlcnJ1cHQgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGJyZWFrbG9vcC5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZShpbmRleClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5kZXhUb0l0ZW1JRE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG5cbiAgICAgICAgICAgIGNvbnN0IHsgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIGl0ZW1FeGNlcHRpb25DYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcmVsb2Fkc2l6ZTsgaW5kZXgrKykge1xuXG4gICAgICAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2sgJiYgcHJlbG9hZEluZGV4Q2FsbGJhY2soaW5kZXgpXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5wcmVsb2FkSXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGlzdHNpemVJbnRlcnJ1cHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJyZWFrbG9vcC5jdXJyZW50KSBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKS50aGVuKFxuICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICBmaW5hbENhbGxiYWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVsgU05BUFNIT1RTIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBnZXRDYWNoZUluZGV4TWFwKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTWFwKHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwKVxuXG4gICAgfVxuXG4gICAgZ2V0Q3JhZGxlSW5kZXhNYXAoY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlTWFwID0gbmV3IE1hcCgpLFxuICAgICAgICAgICAgeyBpbmRleFRvSXRlbUlETWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNyYWRsZUluZGV4TGlzdCkge1xuXG4gICAgICAgICAgICBjcmFkbGVNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmFkbGVNYXBcblxuICAgIH1cblxuICAgIGdldENhY2hlSXRlbU1hcCgpIHtcblxuICAgICAgICBjb25zdCBjYWNoZWxpc3QgPSBuZXcgTWFwKClcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICB9ID0gdmFsdWVcblxuICAgICAgICAgICAgY2FjaGVsaXN0LnNldChrZXkse1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZWxpc3RcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBTRVJWSUNFIFNVUFBPUlQgXT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIG1vdmUgaXMgY29lcmNlZCBieSBzZXJ2aWNlaGFuZGxlciB0byBiZSB3aXRoaW4gY3VycmVudCBsaXN0IGJvdW5kc1xuICAgIG1vdmVJbmRleCh0b2luZGV4LCBmcm9taW5kZXgsIGZyb21oaWdoaW5kZXggKSB7XG5cbiAgICAgICAgY29uc3Qge2luZGV4VG9JdGVtSURNYXAsbWV0YWRhdGFNYXB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gZGVmaW5lIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcmFuZ2VhYnNvbHV0ZWluY3JlbWVudCA9IGZyb21oaWdoaW5kZXggLSBmcm9taW5kZXggKyAxLFxuICAgICAgICAgICAgbW92ZWRpcmVjdGlvbmFsaW5jcmVtZW50ID0gdG9pbmRleCAtIGZyb21pbmRleCxcbiAgICAgICAgICAgIHRvaGlnaGluZGV4ID0gdG9pbmRleCArIChyYW5nZWFic29sdXRlaW5jcmVtZW50IC0gMSlcblxuICAgICAgICBjb25zdCBzaGlmdGRpcmVjdGlvbiA9IFxuICAgICAgICAgICAgKG1vdmVkaXJlY3Rpb25hbGluY3JlbWVudCA+IDApPyAvLyBtb3ZlIHVwIGluIGxpc3RcbiAgICAgICAgICAgICAgICAtMTogLy8gc2hpZnQgZG93biwgbWFrZSByb29tIGZvciBzaGlmdGluZ2luZGV4IGFib3ZlXG4gICAgICAgICAgICAgICAgMSAgIC8vIHNoaWZ0IHVwLCBtYWtlIHJvb20gZm9yIHNoaWZ0aW5naW5kZXggYmVsb3dcblxuICAgICAgICBjb25zdCBvcmRlcmVkaW5kZXhsaXN0ID0gQXJyYXkuZnJvbShpbmRleFRvSXRlbUlETWFwLmtleXMoKSlcbiAgICAgICAgb3JkZXJlZGluZGV4bGlzdC5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgY29uc3QgdG9pbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHRvaW5kZXgpLFxuICAgICAgICAgICAgdG9oaWdoaW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSB0b2hpZ2hpbmRleCksXG4gICAgICAgICAgICBmcm9taW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSBmcm9taW5kZXgpLFxuICAgICAgICAgICAgZnJvbWhpZ2hpbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IGZyb21oaWdoaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBjYXB0dXJlIGluZGV4IGRhdGEgdG8gbW92ZSAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHByb2Nlc3N0b21vdmVMaXN0XG4gICAgICAgIGlmICgoZnJvbWluZGV4cHRyID09IC0xKSAmJiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkpIHsgLy8gc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkgeyAvLyBzY29wZSBpcyBwYXJ0aWFsbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWluZGV4cHRyKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHNjb3BlIGlzIGVudGlyZWx5IGluIHZpZXdcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21pbmRleHB0ciwgZnJvbWhpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3N0b21vdmVNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgY2FwdHVyZW1vdmVpbmRleCA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdC5mb3JFYWNoKGNhcHR1cmVtb3ZlaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBnZXQgbGlzdCBvZiBpbmRleGVzIHRvIHNoaWZ0IG91dCBvZiB0aGUgd2F5IC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBcbiAgICAgICAgbGV0IHByb2Nlc3N0b3NoaWZ0TGlzdFxuICAgICAgICBpZiAoc2hpZnRkaXJlY3Rpb24gPT0gMSkgeyAvLyBibG9jayBpcyBtb3ZpbmcgZG93biwgc2hpZnQgaXMgdXA7IHRvaW5kZXggPCBmcm9taW5kZXhcblxuICAgICAgICAgICAgaWYgKCh0b2luZGV4cHRyID09IC0xKSAmJiAoZnJvbWluZGV4cHRyID09IC0xKSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9taW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UodG9pbmRleHB0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UodG9pbmRleHB0ciwgZnJvbWluZGV4cHRyKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc2hpZnRkaXJlY3Rpb24gPT0gLTE7IGJsb2NrIGlzIG1vdmluZyB1cCwgc2hpZnQgaXMgZG93bjsgZnJvbWluZGV4IDwgdG9pbmRleFxuXG4gICAgICAgICAgICBpZiAodG9oaWdoaW5kZXhwdHIgPT0gLTEgJiYgZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2hpZ2hpbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWhpZ2hpbmRleHB0ciArIDEsIHRvaGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoaWZ0ZGlyZWN0aW9uID09IDEpIHByb2Nlc3N0b3NoaWZ0TGlzdC5yZXZlcnNlKClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBtb3ZlIGluZGV4ZXMgb3V0IG9mIHRoZSB3YXkgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRzaGlmdExpc3QgPSBbXVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NzaGlmdGluZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IFxuICAgICAgICAgICAgICAgIChzaGlmdGRpcmVjdGlvbiA9PSAtMSk/XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC0gcmFuZ2VhYnNvbHV0ZWluY3JlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKyByYW5nZWFic29sdXRlaW5jcmVtZW50XG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIHByb2Nlc3NlZHNoaWZ0TGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QuZm9yRWFjaChwcm9jZXNzc2hpZnRpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gcmVwbGFjZSBzaGlmdGVkIGluZGV4IHNwYWNlIHdpdGggbW92ZWQgaW5kZXhlcyAtLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkbW92ZUxpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzbW92ZWluZGV4ID0gKGl0ZW1JRCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyBtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgLy8gc3dhcFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkbW92ZUxpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5mb3JFYWNoKHByb2Nlc3Ntb3ZlaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS1yZXR1cm4gbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlcyB0byBjYWxsZXIgLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIHN5bmNocm5pemF0aW9uIHdpdGggY3JhZGxlIGNlbGxGcmFtZXNcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleGVzID0gWy4uLnByb2Nlc3NlZHNoaWZ0TGlzdCwuLi5wcm9jZXNzZWRtb3ZlTGlzdF1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhlc1xuXG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0IG9yIHJlbW92ZSBpbmRleGVzOiBtdWNoIG9mIHRoaXMgZGVhbHMgd2l0aCB0aGUgZmFjdCB0aGF0IHRoZSBjYWNoZSBpcyBzcGFyc2UuXG4gICAgaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIGhpZ2hyYW5nZSwgaW5jcmVtZW50LCBsaXN0c2l6ZSkgeyAvLyBpbmNyZW1lbnQgaXMgKzEgb3IgLTFcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAsIG1ldGFkYXRhTWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSByYW5nZSBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhpZ2ggcmFuZ2UgaXMgdGhlIGhpZ2hlc3QgaW5kZXggbnVtYmVyIG9mIHRoZSBpbnNlcnQvcmVtb3ZlIG9wZXJhdGlvblxuICAgICAgICBsZXQgaGlnaHJhbmdlaW5kZXggPSBoaWdocmFuZ2UgPz8gMFxuXG4gICAgICAgIGhpZ2hyYW5nZWluZGV4ID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlaW5kZXggPiBpbmRleCk/XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXg6XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCBlbXB0eXJldHVybiA9IFtbXSxbXSwwXVxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92YWwgbXVzdCBiZSBlbnRpcmVseSB3aXRoaW4gc2NvcGUgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmIChoaWdocmFuZ2VpbmRleCA+IChsaXN0c2l6ZSAtIDEpKSByZXR1cm4gZW1wdHlyZXR1cm5cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBhZGRpdGlvbiBjYW4gYXQgbW9zdCBzdGFydCBhdCB0aGUgbmV4dCBpbmRleCBhYm92ZSB0aGUgY3VycmVudCBsaXN0XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBsaXN0c2l6ZSkgcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhbmdlY291bnQgaXMgdGhlIGFic29sdXRlIG51bWJlciBpbiB0aGUgaW5zZXJ0L3JlbW92ZSByYW5nZSAtIGNvbnRpZ3VvdXNcbiAgICAgICAgY29uc3QgcmFuZ2Vjb3VudCA9IGhpZ2hyYW5nZWluZGV4IC0gaW5kZXggKyAxXG5cbiAgICAgICAgLy8gcmFuZ2UgaW5jcmVtZW50IGFkZHMgc2lnbiB0byByYW5nZWNvdW50IHRvIGluZGljYXRlIGFkZC9yZW1vdmVcbiAgICAgICAgY29uc3QgcmFuZ2VpbmNyZW1lbnQgPSByYW5nZWNvdW50ICogaW5jcmVtZW50XG5cbiAgICAgICAgLy8gaGlnaFB0ciwgbG93UHRyLCBzaHJpbmt0b1B0ciB3aXRoaW4gb3JkZXJlZEluZGV4TGlzdC5cbiAgICAgICAgY29uc3Qgb3JkZXJlZEluZGV4TGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIG9yZGVyZWRJbmRleExpc3Quc29ydCgoYSxiKT0+YS1iKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gZGVmaW5lIGJvdW5kYXJpZXMgd2l0aGluIG9yZGVyZWQgY2FjaGUgaW5kZXggbGlzdCAtLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUHRyID0gaW5kZXggaW50byBhcnJheSwgYXMgb3Bwb3NlZCB0byBpbmRleCBvZiB2aXJ0dWFsIGxpc3RcblxuICAgICAgICAvLyBzaHJpbmtwdHIgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBib3R0b20gb2YgdGhlIHNocmluayByYW5nZSBmb3IgcmVtb3ZhbHNcbiAgICAgICAgbGV0IHNocmlua3RvSW5kZXggPSBudWxsXG4gICAgICAgIGxldCBzaHJpbmt0b1B0ciA9IC0gMVxuICAgICAgICBcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAtIDEpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2hyaW5rdG9JbmRleCA9IG9yZGVyZWRJbmRleExpc3QuYXQoLTEpICsgKHJhbmdlaW5jcmVtZW50KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5tYXgoaGlnaHJhbmdlaW5kZXggKyAocmFuZ2VpbmNyZW1lbnQpLCBzaHJpbmt0b0luZGV4KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5taW4obGlzdHNpemUgLSAxLHNocmlua3RvSW5kZXgpIFxuXG4gICAgICAgICAgICBzaHJpbmt0b1B0ciA9IG9yZGVyZWRJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHNocmlua3RvSW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvd1B0ciBhbmQgaGlnaFB0ciBtdXN0IGJlIHdpdGhpbiBsb3cgYW5kIGhpZ2ggcmFuZ2VcbiAgICAgICAgY29uc3QgbG93UHRyID0gb3JkZXJlZEluZGV4TGlzdC5maW5kSW5kZXgodmFsdWUgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlID49IGluZGV4KSAmJiAodmFsdWUgPD0gaGlnaHJhbmdlaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCByZXZlcnNlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShvcmRlcmVkSW5kZXhMaXN0KVxuICAgICAgICByZXZlcnNlSW5kZXhMaXN0LnJldmVyc2UoKVxuICAgICAgICBsZXQgaGlnaFB0ciA9IHJldmVyc2VJbmRleExpc3QuZmluZEluZGV4KHZhbHVlPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPD0gaGlnaHJhbmdlaW5kZXhcblxuICAgICAgICB9KVxuICAgICAgICBpZiAoaGlnaFB0ciAhPSAtMSkge1xuICAgICAgICAgICAgaGlnaFB0ciA9IChvcmRlcmVkSW5kZXhMaXN0Lmxlbmd0aCAtIDEpIC0gaGlnaFB0clxuICAgICAgICAgICAgaWYgKGhpZ2hQdHIgPCBsb3dQdHIpIGhpZ2hQdHIgPSAtMVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gbGlzdCBpbmRleGVzIHRvIHByb2Nlc3MsIHJlcGxhY2UsIGFuZCByZW1vdmUsIGFuZCBpdGVtcyB0byByZW1vdmUgLS0tLS0tLS1cblxuICAgICAgICBsZXQgaW5kZXhlc1RvUHJvY2Vzc0xpc3QsIC8vIGZvciBlaXRoZXIgaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBbXSwgLy8gZm9yIGluc2VydCB0aGUgcmFuZ2UgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBbXSwgLy8gZm9yIHJlbW92ZSAtIGVuZCBvZiBsaXN0OyB0aGUgbGlzdCBpcyBzaHJpbmtpbmdcbiAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gW10sIC8vIGZvciByZW1vdmUgLSB3aXRoaW4gdGhlIHJhbmdlIG9mIGluZGV4ZXMgYmVpbmcgcmVtb3ZlZFxuICAgICAgICAgICAgaXRlbXNUb1JlbW92ZUxpc3QgPSBbXSAvLyBmb3IgcmVtb3ZlLCBkZXJpdmVkIGZyb20gdGhlIHByZXZpb3VzXG5cbiAgICAgICAgLy8gZ2V0IGluZGV4ZXNUb1Byb2Nlc3NMaXN0XG4gICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IFtdXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gY29yZSBzY29wZSBpcyBwYXJ0aWFsbHkgb3IgZnVsbHkgaW4gdmlldzsgbG93UHRyIGlzIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkgeyAvLyBpbmNyZW1lbnQgPT0gLTE7IGxvd1B0ciBpcyBhdmFpbGFibGVcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW5jcmVtZW50ID09IC0xOyBsb3dQdHIgYW5kIGhpZ2hQdHIgYXJlIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGhpZ2hQdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdCA9IFtdIC8vIGhvbGQgcG9ydGFscyBmb3IgZGVsZXRpb24gdW50aWwgYWZ0ZXIgYWZ0ZXIgY3JhZGxlIHN5bmNoXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzVG9SZXBsYWNlTGlzdFxuICAgICAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIsIGhpZ2hQdHIgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBpZiAoc2hyaW5rdG9QdHIgPT0gLTEpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShzaHJpbmt0b1B0ciArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIsIGhpZ2hQdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBpdGVtc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgaXRlbXNUb1JlbW92ZUxpc3QucHVzaChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gY29uZHVjdCBjYWNoZSBvcGVyYXRpb25zIC0tLS0tLS0tLS1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgaGlnaGVyIGZyb20gdG9wIG9mIGxpc3QgdG8gcHJlc2VydmUgbG93ZXIgdmFsdWVzIGZvciBzdWJzZXF1ZW50IGluY3JlbWVudFxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIGluZGV4ZXNUb1Byb2Nlc3NMaXN0LnJldmVyc2UoKSBcblxuICAgICAgICBjb25zdCBpbmRleGVzTW9kaWZpZWRMaXN0ID0gW11cblxuICAgICAgICAvLyBtb2RpZnkgaW5kZXgtdG8taXRlbWlkIG1hcCwgYW5kIG1ldGFkYXRhIG1hcFxuICAgICAgICBjb25zdCBwcm9jZXNzSW5kZXggPSBpbmRleCA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBpbmRleCArIHJhbmdlaW5jcmVtZW50XG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKS5pbmRleCA9IG5ld0luZGV4XG4gICAgICAgICAgICBpbmRleGVzTW9kaWZpZWRMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0LmZvckVhY2gocHJvY2Vzc0luZGV4KVxuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1haW5pbmcgaW5kZXhlcyBhbmQgaXRlbXMgbm93IGR1cGxpY2F0ZXNcblxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzVG9SZXBsYWNlTGlzdCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzVG9SZW1vdmVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW1JRCBvZiBpdGVtc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0aXRpb25JRCB9ID0gbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgICAgICAgICBwb3J0YWxJdGVtSG9sZEZvckRlbGV0ZUxpc3QucHVzaCh7aXRlbUlELCBwYXJ0aXRpb25JRH0pXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFNYXAuZGVsZXRlKGl0ZW1JRClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0gcmV0dXJucyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXR1cm4gdmFsdWVzIGZvciBjYWxsZXIgdG8gc2VuZCB0byBjb250ZW50aGFuZGxlciBmb3IgY3JhZGxlIHN5bmNocm9uaXphdGlvblxuICAgICAgICByZXR1cm4gW2luZGV4ZXNNb2RpZmllZExpc3QsIGluZGV4ZXNUb1JlcGxhY2VMaXN0LCByYW5nZWluY3JlbWVudCwgcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0XVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIElORElWSURVQUwgUE9SVEFMIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVzZWQgZm9yIHNpemUgY2FsY3VsYXRpb24gaW4gcGFyZUNhY2hlVG9NYXhcbiAgICAvLyByZWdpc3RlcnMgaW5kZXhlcyB3aGVuIHJlcXVlc3RlZCBidXQgYmVmb3JlIHJldHJpZXZlZCBhbmQgZW50ZXJlZCBpbnRvIGNhY2hlXG4gICAgcmVnaXN0ZXJSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmFkZChpbmRleClcblxuICAgIH1cblxuICAgIHJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuZGVsZXRlKGluZGV4KVxuXG4gICAgfVxuXG4gICAgZ2V0TmV3SXRlbUlEKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbEl0ZW1JRCsrXG5cbiAgICB9XG5cbiAgICAvLyBnZXQgbmV3IG9yIGV4aXN0aW5nIGl0ZW1JRCBmb3IgY29udGVudGZ1bmN0aW9ucy5jcmVhdGVDZWxsRnJhbWVcbiAgICBnZXROZXdPckV4aXN0aW5nSXRlbUlEKGluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCBpdGVtSUQgPSBcbiAgICAgICAgICAgIChpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpP1xuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KTpcbiAgICAgICAgICAgICAgICAodGhpcy5nZXROZXdJdGVtSUQoKSlcblxuICAgICAgICByZXR1cm4gaXRlbUlEXG5cbiAgICB9XG5cbiAgICAgLy8gY3JlYXRlIG5ldyBwb3J0YWxcbiAgICBhc3luYyBjcmVhdGVQb3J0YWwoY29tcG9uZW50LCBpbmRleCwgaXRlbUlELCBzY3JvbGxlclByb3BlcnRpZXMsIGlzUHJlbG9hZCA9IGZhbHNlKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgb3JpZW50YXRpb24gfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSUQgPSBhd2FpdCB0aGlzLmZpbmRQYXJ0aXRpb25XaXRoUm9vbSgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsID0gXG4gICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9ICdwb3J0YWx3cmFwcGVyJyBrZXkgPSB7aXRlbUlEfSBkYXRhLWl0ZW1pZCA9IHtpdGVtSUR9IGRhdGEtaW5kZXggPSB7aW5kZXh9PlxuICAgICAgICAgICAgICAgIDxJblBvcnRhbCBrZXkgPSB7aXRlbUlEfSBub2RlID0ge3BvcnRhbE5vZGV9ID4geyBjb21wb25lbnQgfSA8L0luUG9ydGFsPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgdGhpcy5hZGRQYXJ0aXRpb25Qb3J0YWwocGFydGl0aW9uSUQsIGl0ZW1JRCwgcG9ydGFsKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgcG9ydGFsTm9kZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbUlELFxuICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgcGFydGl0aW9uSUQsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuc2V0KGl0ZW1JRCwgcG9ydGFsTWV0YWRhdGEpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgIGlmICghaXNQcmVsb2FkKSB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICByZXR1cm4gcG9ydGFsTWV0YWRhdGFcblxuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHByZWxvYWRpbmcgbmV3IGl0ZW1cbiAgICBwcml2YXRlIGFzeW5jIHByZWxvYWRJdGVtKFxuICAgICAgICBpbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0LFxuICAgICAgICBzY3JvbGxlcklEXG4gICAgKSB7XG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gdGhpcy5nZXROZXdJdGVtSUQoKVxuXG4gICAgICAgIGxldCByZXR1cm52YWx1ZSwgdXNlcmNvbnRlbnQsIGVycm9yXG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzLmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQodXNlcmNvbnRlbnQsIHtzY3JvbGxlclByb3BlcnRpZXN9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29uc3QgcG9ydGFsRGF0YSA9IFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUG9ydGFsKGNvbnRlbnQsIGluZGV4LCBpdGVtSUQsIHNjcm9sbGVyUHJvcGVydGllcywgdHJ1ZSkgLy8gdHJ1ZSA9IGlzUHJlbG9hZFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBlcnJvcilcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IG51bGw7IGxhc3QgaXRlbSBpbiBsaXN0XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBuZXcgRXJyb3IoJ2VuZCBvZiBsaXN0JykpXG5cbiAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdChpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBhIHBvcnRhbCBsaXN0IGl0ZW1cbiAgICAvLyBhY2NlcHRzIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICBkZWxldGVQb3J0YWwoaW5kZXgsIGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuXG4gICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBcbiAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShpbmRleCkpP1xuICAgICAgICAgICAgICAgIFtpbmRleF06XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIFxuICAgICAgICB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgeyByZW1vdmVQYXJ0aXRpb25Qb3J0YWwgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCBkZWxldGVMaXN0ID0gW11cbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleEFycmF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICBpZiAoaXRlbUlEID09PSB1bmRlZmluZWQpIGNvbnRpbnVlIC8vIGFzeW5jIG1pc21hdGNoXG5cbiAgICAgICAgICAgIGRlbGV0ZUxpc3QucHVzaCh7aW5kZXgsaXRlbUlEfSlcbiAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IG1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG5cbiAgICAgICAgICAgIHJlbW92ZVBhcnRpdGlvblBvcnRhbChwYXJ0aXRpb25JRCxpdGVtSUQpXG5cbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2sgJiYgZGVsZXRlTGlzdENhbGxiYWNrKGRlbGV0ZUxpc3QpXG5cbiAgICB9XG5cbiAgICAvLyBxdWVyeSBleGlzdGVuY2Ugb2YgYSBwb3J0YWwgbGlzdCBpdGVtXG4gICAgaGFzUG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuaGFzKGl0ZW1JRClcblxuICAgIH1cblxuICAgIGdldFBvcnRhbE1ldGFkYXRhKGl0ZW1JRCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1BvcnRhbChpdGVtSUQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBmdW5jdGlvbiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBnZXQgYSByZWFjdC1yZXZlcnNlLXBvcnRhbCBJblBvcnRhbCBjb21wb25lbnQsIHdpdGggaXRzIG1ldGFkYXRhXG4vLyB3aXRoIHVzZXIgY29udGVudCBhbmQgY29udGFpbmVyXG4vLyBzZWUgYWxzbyBzb21lIHN0eWxlcyBzZXQgaW4gQ2VsbEZyYW1lXG5cbmNvbnN0IGNyZWF0ZVBvcnRhbE5vZGUgPSAoaW5kZXgsIGl0ZW1JRCkgPT4ge1xuXG4gICAgY29uc3QgcG9ydGFsTm9kZSA9IGNyZWF0ZUh0bWxQb3J0YWxOb2RlKClcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcnRhbE5vZGUuZWxlbWVudFxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBjb250YWluZXIuZGF0YXNldC50eXBlID0gJ2NvbnRlbnRlbnZlbG9wZSdcbiAgICBjb250YWluZXIuZGF0YXNldC5pbmRleCA9IGluZGV4XG4gICAgY29udGFpbmVyLmRhdGFzZXQuY2FjaGVpdGVtaWQgPSBpdGVtSURcblxuICAgIHJldHVybiBwb3J0YWxOb2RlXG5cbn0gICAgIFxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT1bIFV0aWxpdHkgY29tcG9uZW50cyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHBvcnRhbCBsaXN0IGNvbXBvbmVudCBmb3IgcmFwaWQgcmVsaXN0aW5nIG9mIHVwZGF0ZXMsIHVzaW5nIGV4dGVybmFsIGNhbGxiYWNrIGZvciBzZXQgc3RhdGVcbmV4cG9ydCBjb25zdCBDYWNoZVBhcnRpdGlvbiA9ICh7IGNhY2hlUHJvcHMsIHBhcnRpdGlvbklELCBjYWxsYmFjayB9KSA9PiB7XG5cbiAgICBjb25zdCBbcG9ydGFsTGlzdENvdW50ZXIsIHNldFBvcnRhbExpc3RDb3VudGVyXSA9IHVzZVN0YXRlKDApXG5cbiAgICBjb25zdCBbcGFydGl0aW9uU3RhdGUsIHNldFBhcnRpdGlvblN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG5cbiAgICBjb25zdCBjb3VudGVyUmVmID0gdXNlUmVmKHBvcnRhbExpc3RDb3VudGVyKVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCBwb3J0YWxBcnJheVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgcGFydGl0aW9uTWV0YWRhdGEgPSBjYWNoZVByb3BzLnBhcnRpdGlvbk1ldGFkYXRhTWFwLmdldChwYXJ0aXRpb25JRClcblxuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlQ2FsbGJhY2soKHBvcnRhbFJlbmRlckxpc3QpID0+IHtcblxuICAgICAgICBwb3J0YWxBcnJheVJlZi5jdXJyZW50ID0gcG9ydGFsUmVuZGVyTGlzdFxuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldFBvcnRhbExpc3RDb3VudGVyKCsrY291bnRlclJlZi5jdXJyZW50KSAvLyBmb3JjZSByZW5kZXJcblxuICAgIH0sW10pXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5mb3JjZVVwZGF0ZSA9IGZvcmNlVXBkYXRlXG5cbiAgICAgICAgY2FsbGJhY2soKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKSBcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIHN3aXRjaCAocGFydGl0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzoge1xuICAgICAgICAgICAgICAgIHNldFBhcnRpdGlvblN0YXRlKCdyZWFkeScpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxbcGFydGl0aW9uU3RhdGVdKVxuXG4gICAgcmV0dXJuIDxkaXYga2V5ID0ge3BhcnRpdGlvbklEfSBkYXRhLXR5cGUgPSAnY2FjaGVwYXJ0aXRpb24nIGRhdGEtcGFydGl0aW9uaWQgPSB7cGFydGl0aW9uSUR9PlxuICAgICAgICB7cG9ydGFsQXJyYXlSZWYuY3VycmVudH1cbiAgICA8L2Rpdj5cblxufVxuXG5leHBvcnQgY29uc3QgUG9ydGFsTWFzdGVyQ2FjaGUgPSAoeyBjYWNoZVByb3BzIH0pID0+IHtcblxuICAgIGNvbnN0IFtwb3J0YWxDYWNoZUNvdW50ZXIsIHNldFBvcnRhbENhY2hlQ291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuICAgIGNvbnN0IGNvdW50ZXJSZWYgPSB1c2VSZWYocG9ydGFsQ2FjaGVDb3VudGVyKVxuXG4gICAgY29uc3QgW21hc3RlclN0YXRlLCBzZXRNYXN0ZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCBwYXJ0aXRpb25BcnJheVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgcGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlID0gdXNlQ2FsbGJhY2soKHBhcnRpdGlvblJlbmRlckxpc3QpID0+IHtcblxuICAgICAgICBwYXJ0aXRpb25BcnJheVJlZi5jdXJyZW50ID0gcGFydGl0aW9uUmVuZGVyTGlzdFxuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldFBvcnRhbENhY2hlQ291bnRlcigrK2NvdW50ZXJSZWYuY3VycmVudCkgLy8gZm9yY2UgcmVuZGVyXG5cbiAgICB9LFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgY2FjaGVQcm9wcy5wYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUgPSBwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGVcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSkgXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBzd2l0Y2ggKG1hc3RlclN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcbiAgICAgICAgICAgICAgICBzZXRNYXN0ZXJTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFttYXN0ZXJTdGF0ZV0pXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAncG9ydGFsLW1hc3Rlcic+e3BhcnRpdGlvbkFycmF5UmVmLmN1cnJlbnR9PC9kaXY+XG5cbn1cbiJdLCJuYW1lcyI6WyJDYWNoZUhhbmRsZXIiLCJzY3JvbGxlcklEIiwic2V0TGlzdHNpemUiLCJsaXN0c2l6ZVJlZiIsIkNBQ0hFX1BBUlRJVElPTl9TSVpFIiwibWV0YWRhdGFNYXAiLCJNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwicmVxdWVzdGVkU2V0IiwiU2V0IiwicGFydGl0aW9uTWV0YWRhdGFNYXAiLCJwYXJ0aXRpb25NYXAiLCJwYXJ0aXRpb25SZW5kZXJMaXN0IiwicGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlIiwicGFydGl0aW9uTW9kaWZpZWRTZXQiLCJwYXJ0aXRpb25QdHIiLCJjYWNoZVByb3BzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwicGFydGl0aW9uSUQiLCJnbG9iYWxQYXJ0aXRpb25JRCIsInNldCIsInBvcnRhbE1hcCIsIm1hcGNvdW50IiwicG9ydGFsUmVuZGVyTGlzdCIsIm1vZGlmaWVkIiwiZm9yY2VVcGRhdGUiLCJyZXNvbHZlZnVuYyIsImN1cnJlbnQiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsYmFjayIsInJlYWN0XzEiLCJleHBvcnRzIiwia2V5IiwicmVuZGVyUGFydGl0aW9uUmVwbyIsIml0ZW1JRCIsInBvcnRhbCIsInBhcnRpdGlvbk1ldGFkYXRhIiwiZ2V0IiwiYWRkIiwic2l6ZSIsImZvckVhY2giLCJyZW5kZXJQYXJ0aXRpb24iLCJjbGVhciIsIm5ld2xpc3RzaXplIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsInBvcnRhbEluZGV4TWFwIiwibWFwa2V5c0xpc3QiLCJrZXlzIiwic29ydCIsImEiLCJiIiwiaGlnaGVzdGluZGV4IiwiYXQiLCJwYXJlbGlzdCIsImZpbHRlciIsImluZGV4IiwiZGVsZXRlUG9ydGFsIiwiY3JhZGxlSW5kZXhMaXN0IiwibWFwa2V5cyIsImRlbGtleXMiLCJpbmNsdWRlcyIsImxlbmd0aCIsImNhY2hlTWF4IiwidW5kZWZpbmVkIiwibW9kZWxMZW5ndGgiLCJtYXgiLCJNYXRoIiwibWFwa2V5c2xpc3QiLCJyZXF1ZXN0ZWRrZXlzIiwibWFwTGVuZ3RoIiwicGFyZWNvdW50IiwiaGVhZGluZGV4IiwidGFpbGluZGV4IiwiaGVhZHBvcyIsImluZGV4T2YiLCJ0YWlscG9zIiwiaGVhZHJvb20iLCJ0YWlscm9vbSIsInBhcmVyb29tIiwiaGVhZHBhcmVjb3VudCIsImZsb29yIiwidGFpbHBhcmVjb3VudCIsImhlYWRsaXN0Iiwic2xpY2UiLCJ0YWlsbGlzdCIsImRlbExpc3QiLCJjcmFkbGVMaXN0TGVuZ3RoIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiYWRkUGFydGl0aW9uIiwiZmluYWxDYWxsYmFjayIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJjcmFkbGVQYXJhbWV0ZXJzIiwic2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIiwiaGFuZGxlcnNSZWYiLCJzdGF0ZUhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiZ2V0SXRlbSIsImxpc3RzaXplIiwicHJvbWlzZXMiLCJjYWNoZVNpemUiLCJtaW4iLCJwcmVsb2Fkc2l6ZSIsImJyZWFrbG9vcCIsIm1heExpc3RzaXplSW50ZXJydXB0IiwiaXNNb3VudGVkUmVmIiwiY2FsbGJhY2tzIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJoYXMiLCJwcmVsb2FkSXRlbSIsInB1c2giLCJhbGxTZXR0bGVkIiwidGhlbiIsInJlbmRlclBvcnRhbExpc3RzIiwiY3JhZGxlTWFwIiwiY2FjaGVsaXN0IiwidmFsdWUiLCJjb21wb25lbnQiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiZnJvbWhpZ2hpbmRleCIsInJhbmdlYWJzb2x1dGVpbmNyZW1lbnQiLCJtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQiLCJ0b2hpZ2hpbmRleCIsInNoaWZ0ZGlyZWN0aW9uIiwib3JkZXJlZGluZGV4bGlzdCIsInRvaW5kZXhwdHIiLCJmaW5kSW5kZXgiLCJ0b2hpZ2hpbmRleHB0ciIsImZyb21pbmRleHB0ciIsImZyb21oaWdoaW5kZXhwdHIiLCJwcm9jZXNzdG9tb3ZlTGlzdCIsInByb2Nlc3N0b21vdmVNYXAiLCJjYXB0dXJlbW92ZWluZGV4IiwicHJvY2Vzc3Rvc2hpZnRMaXN0IiwicmV2ZXJzZSIsInByb2Nlc3NlZHNoaWZ0TGlzdCIsInByb2Nlc3NzaGlmdGluZGV4IiwibmV3SW5kZXgiLCJwcm9jZXNzZWRtb3ZlTGlzdCIsInByb2Nlc3Ntb3ZlaW5kZXgiLCJwcm9jZXNzZWRJbmRleGVzIiwiaGlnaHJhbmdlIiwiaW5jcmVtZW50IiwiaGlnaHJhbmdlaW5kZXgiLCJlbXB0eXJldHVybiIsInJhbmdlY291bnQiLCJyYW5nZWluY3JlbWVudCIsIm9yZGVyZWRJbmRleExpc3QiLCJzaHJpbmt0b0luZGV4Iiwic2hyaW5rdG9QdHIiLCJsb3dQdHIiLCJyZXZlcnNlSW5kZXhMaXN0IiwiaGlnaFB0ciIsImluZGV4ZXNUb1Byb2Nlc3NMaXN0IiwiaW5kZXhlc1RvUmVwbGFjZUxpc3QiLCJpbmRleGVzVG9SZW1vdmVMaXN0IiwiaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QiLCJpdGVtc1RvUmVtb3ZlTGlzdCIsInBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdCIsImluZGV4ZXNNb2RpZmllZExpc3QiLCJwcm9jZXNzSW5kZXgiLCJnbG9iYWxJdGVtSUQiLCJnZXROZXdJdGVtSUQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJpc1ByZWxvYWQiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJsYXlvdXQiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwib3JpZW50YXRpb24iLCJwb3J0YWxOb2RlIiwiY3JlYXRlUG9ydGFsTm9kZSIsImZpbmRQYXJ0aXRpb25XaXRoUm9vbSIsInJlYWN0X3JldmVyc2VfcG9ydGFsXzEiLCJub2RlIiwiYWRkUGFydGl0aW9uUG9ydGFsIiwicG9ydGFsTWV0YWRhdGEiLCJ1c2VyY29udGVudCIsInJldHVybnZhbHVlIiwiZXJyb3IiLCJpc1ZhbGlkRWxlbWVudCIsIkVycm9yIiwicHJvcHMiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnRlbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVQb3J0YWwiLCJpbmRleEFycmF5IiwiaXNBcnJheSIsInJlbW92ZVBhcnRpdGlvblBvcnRhbCIsImRlbGV0ZUxpc3QiLCJoYXNQb3J0YWwiLCJjb250YWluZXIiLCJlbGVtZW50Iiwic3R5bGUiLCJvdmVyZmxvdyIsImRhdGFzZXQiLCJ0eXBlIiwiY2FjaGVpdGVtaWQiLCJDYWNoZVBhcnRpdGlvbiIsInBvcnRhbExpc3RDb3VudGVyIiwic2V0UG9ydGFsTGlzdENvdW50ZXIiLCJwYXJ0aXRpb25TdGF0ZSIsInNldFBhcnRpdGlvblN0YXRlIiwiY291bnRlclJlZiIsInBvcnRhbEFycmF5UmVmIiwiUG9ydGFsTWFzdGVyQ2FjaGUiLCJwb3J0YWxDYWNoZUNvdW50ZXIiLCJzZXRQb3J0YWxDYWNoZUNvdW50ZXIiLCJtYXN0ZXJTdGF0ZSIsInNldE1hc3RlclN0YXRlIiwicGFydGl0aW9uQXJyYXlSZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/cachehandler.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// contentfunctions.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calcShiftSpecs = exports.getShiftInstruction = exports.getContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    getContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    getShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\"));\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// ======================[ for setCradleContent ]===========================\nvar getContentListRequirements = function getContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n    baseRowLength = _ref.baseRowLength,\n    targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n    cradleInheritedProperties = _ref.cradleInheritedProperties,\n    cradleInternalProperties = _ref.cradleInternalProperties;\n  var padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount,\n    listRowcount = cradleInternalProperties.listRowcount,\n    listsize = cradleInternalProperties.listsize;\n  // align axis reference to first row item\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount;\n  // derive target row\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  // update will compensate if this is too high\n  var maxAxisRowOffset = Math.max(0, listRowcount - 1);\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  }\n  // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount);\n  // trailing edge\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount;\n  // ---------------------[ calc cradle content count ]---------------------\n  var newCradleContentCount = cradleRowcount * crosscount;\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  }\n  // --------------------[ calc css positioning ]-----------------------\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * baseRowLength + padding - targetAxisViewportPixelOffset;\n  // ----------------------[ return required values ]---------------------\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\nexports.getContentListRequirements = getContentListRequirements;\n// ======================[ for updateCradleContent ]===========================\n/*\n    the two triggerlines must straddle the head of the viewport (top or left) so that\n    cradle motion can be detected. Motion is most often caused by scrolling, but\n    can also occur with change of size of cradle content rows.\n\n    getShiftInstruction determines whether the axis should be moved toward the head or tail\n        to restore the straddling position of the two trigger lines. Lots of relative motion.\n\n    'axisheadward' (scrolling down or right) means moving the axis up or left, adjacent items down\n         or right to the tail, dropping trailing tail items, and adding leading head items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'axistailward' (scrolling up or left) means moving the axis down or right, adjacent items up\n         or left to the head, dropping trailing head items, and adding leading tail items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'none' means no shift is required\n*/\nvar getShiftInstruction = function getShiftInstruction(_ref2) {\n  var orientation = _ref2.orientation,\n    triggerlineEntries = _ref2.triggerlineEntries,\n    triggerlineSpan = _ref2.triggerlineSpan,\n    scrollerID = _ref2.scrollerID,\n    isFirstRowTriggerConfig = _ref2.isFirstRowTriggerConfig,\n    viewportBoundingRect = _ref2.viewportBoundingRect,\n    triggerHistoryRef = _ref2.triggerHistoryRef;\n  var triggerData = {\n    headOffset: null,\n    tailOffset: null,\n    span: triggerlineSpan,\n    isFirstRowTriggerConfig: isFirstRowTriggerConfig\n  };\n  // most recent; either triggerline will do\n  var entry = triggerlineEntries[triggerlineEntries.length - 1]; //.at(-1) at not available in iOS 15\n  var referencename = entry.target.dataset.type;\n  entry.referencename = referencename;\n  var span = triggerlineSpan;\n  var intersectrootpos = orientation == 'vertical' ? Math.trunc(entry.rootBounds.y) : Math.trunc(entry.rootBounds.x);\n  // entry.rootBounds.y:\n  // entry.rootBounds.x\n  var boundingrootpos = orientation == 'vertical' ? Math.trunc(viewportBoundingRect.y) : Math.trunc(viewportBoundingRect.x);\n  // viewportBoundingRect.y:\n  // viewportBoundingRect.x\n  // this selection is redundant, but documents what's going on\n  var rootpos = intersectrootpos == boundingrootpos ? intersectrootpos : boundingrootpos; // we're in Safari, zoomed\n  var entrypos = orientation == 'vertical' ? Math.trunc(entry.boundingClientRect.y) : Math.trunc(entry.boundingClientRect.x);\n  // entry.boundingClientRect.y:\n  // entry.boundingClientRect.x\n  var viewportTriggerOffset = entrypos - rootpos;\n  if (referencename == 'headtrigger') {\n    triggerData.headOffset = viewportTriggerOffset;\n    triggerData.tailOffset = viewportTriggerOffset + span;\n  } else {\n    // tailtrigger\n    triggerData.headOffset = viewportTriggerOffset - span;\n    triggerData.tailOffset = viewportTriggerOffset;\n  }\n  var shiftinstruction;\n  var triggerHistory = triggerHistoryRef.current;\n  // since triggers are moved and can share the 0 (zero) offset, an infinite loop can occur\n  // between the head and tail triggers. The following short-circuits that.\n  // Obviously needs work to generalize...\n  if ((0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset == 0 || triggerData.tailOffset == 0) || !(0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset >= -1 && triggerData.headOffset <= 1 || triggerData.tailOffset >= -1 && triggerData.tailOffset <= 1)) {\n    // some browsers do an infinite loop with the same previousReferenceName;\n    // usually alternates\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n      shiftinstruction = 'none';\n    } else {\n      if (triggerData.headOffset >= -1 && triggerData.headOffset <= 1) {\n        // if (triggerData.headOffset == 0) {\n        triggerHistory.previousReferenceName = 'headtrigger';\n      } else {\n        triggerHistory.previousReferenceName = 'tailtrigger';\n      }\n    }\n  } else {\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n    }\n  }\n  if (shiftinstruction) {\n    // will be 'none'\n    return [shiftinstruction, 0]; //triggerViewportReferencePos]\n  }\n\n  if (isFirstRowTriggerConfig) {\n    if (triggerData.headOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  } else {\n    if (triggerData.tailOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else if (triggerData.headOffset >= 0) {\n      shiftinstruction = 'axisheadward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  }\n  var triggerViewportReferencePos = shiftinstruction == 'axistailward' ?\n  // block is scrolling up or left\n  triggerData.tailOffset :\n  // needs to move up or left toward head\n  triggerData.headOffset; // needs to move down or right toward tail\n  return [shiftinstruction, triggerViewportReferencePos];\n};\nexports.getShiftInstruction = getShiftInstruction;\n/*\n    The basic goal of calcContentShoft is to determine the number and direction of rows to shift between\n    the head and tail grids (which determines the new location of the axis), and also to\n    calculate the rolling addition and deletion of cradle content to accommodate the changes.\n\n    The number of rows to shift is determined by the pixel shift required to restore the\n    triggerlines to their straddle configuration around the head (top or left) of the viewport.\n\n    Adjustments are made to accommodate special requirements at the start and end of the virtual list.\n\n    DOM measurements are used where available (to accommodate variable dimension rows), and standard\n    units (cellHeight, cellWidth) used for estimates where necessary.\n*/\n// rowshift is at least 1 by the time this function is reached\n// ie. a shiftinstruction of 'axisheadward' or 'axistailward'\nvar calcShiftSpecs = function calcShiftSpecs(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n    triggerViewportReferencePos = _ref3.triggerViewportReferencePos,\n    scrollPos = _ref3.scrollPos,\n    scrollblockElement = _ref3.scrollblockElement,\n    cradleInheritedProperties = _ref3.cradleInheritedProperties,\n    cradleInternalProperties = _ref3.cradleInternalProperties,\n    cradleContent = _ref3.cradleContent,\n    cradleElements = _ref3.cradleElements;\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n  // configuration data\n  var gap = cradleInheritedProperties.gap,\n    padding = cradleInheritedProperties.padding,\n    orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    layout = cradleInheritedProperties.layout;\n  // cradle elements\n  var axisElement = cradleElements.axisRef.current,\n    headGridElement = cradleElements.headRef.current,\n    tailGridElement = cradleElements.tailRef.current;\n  // cradle contents\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n    tailcontentlist = cradleContent.tailModelComponents;\n  // more config data\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    listsize = cradleInternalProperties.listsize,\n    listRowcount = cradleInternalProperties.listRowcount,\n    viewportRowcount = cradleInternalProperties.viewportRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0,\n    previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0,\n    previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n  var listEndrowOffset = listRowcount - 1;\n  var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n  var spanRowPtr;\n  var spanAxisPixelShift = 0; // in relation to viewport head boundary\n  var inProcessRowPtr = 0;\n  var isListBoundary = false;\n  var totalPixelShift;\n  var finalVariableRowLength; // special case\n  // measure exising rows for variable length cells\n  if (layout == 'variable') {\n    var referenceGridElement =\n    // moving axis (and triggers) toward the reference grid element\n    shiftinstruction == 'axistailward' ?\n    // scrolling up or left\n    tailGridElement : headGridElement;\n    var gridRowLengths = getGridRowLengths(referenceGridElement, orientation, crosscount, gap);\n    if (shiftinstruction == 'axisheadward') {\n      // scrolling down or right; move triggerlines up or left\n      gridRowLengths.reverse(); // head grid row lengths listed from axis toward head\n    }\n\n    var gridRowAggregateSpans = getGridRowAggregateSpans(gridRowLengths); // count pixels where available\n    // ----------------------------[ 2. calculate base row shift ]--------------------------\n    // first try to find position based on known (instantiated) rows\n    if (shiftinstruction == 'axistailward') {\n      // scroll up\n      // tail trigger needs to move down or right until position relative to viewport top or left is positive\n      spanRowPtr = gridRowAggregateSpans.findIndex(function (aggregatespan) {\n        return triggerViewportReferencePos + aggregatespan >= 0;\n      });\n    } else {\n      // 'axisheadward', scrolldown\n      // head trigger needs to move up or left until position relative to viewport top or left is negative\n      spanRowPtr = gridRowAggregateSpans.findIndex(function (aggregatespan) {\n        return triggerViewportReferencePos - aggregatespan <= 0;\n      });\n    }\n    if (!(spanRowPtr == -1)) {\n      // found measureed row for shift\n      spanAxisPixelShift = shiftinstruction == 'axistailward' ? gridRowAggregateSpans[spanRowPtr] :\n      // move axis toward tail from viewport boundary (positive)\n      -gridRowAggregateSpans[spanRowPtr]; // move axis toward head from viewport boundary (negative)\n    } else {\n      // either in boundary, or shy of target\n      isListBoundary = gridRowAggregateSpans.length == 0; // boundary at head of list\n      if (!isListBoundary) {\n        // interim working result\n        inProcessRowPtr = gridRowAggregateSpans.length - 1; // base: failed measured row ptr\n        totalPixelShift = gridRowAggregateSpans[inProcessRowPtr]; // set base of working overshoot\n        finalVariableRowLength = gridRowLengths.at(-1); // for oversize cell adjustment below\n      }\n    }\n  } else {\n    // layout == 'uniform'; use only defined lengths\n    spanRowPtr = -1; // \"not found\", ie not applicable\n    inProcessRowPtr = 0;\n    totalPixelShift = 0;\n  }\n  // uniform layout, or overshoot of instantiated rows; continue with virtual base rows\n  if (spanRowPtr == -1) {\n    if (!isListBoundary) {\n      if (shiftinstruction == 'axistailward') {\n        // scrolling up/left\n        do {\n          totalPixelShift += baseRowLength;\n          inProcessRowPtr++;\n        } while (triggerViewportReferencePos + totalPixelShift < 0);\n        spanAxisPixelShift = totalPixelShift;\n      } else {\n        // axisheadward; scrolling down/right\n        do {\n          totalPixelShift += baseRowLength;\n          inProcessRowPtr++;\n          if (previousAxisRowOffset - inProcessRowPtr == 0) {\n            // stop cycling at head limit\n            break;\n          }\n        } while (triggerViewportReferencePos - totalPixelShift > 0);\n        spanAxisPixelShift = -totalPixelShift;\n      }\n    }\n    // inProcessRowPtr is one greater than spanRowPtr with actual measurements above\n    // this makes them compativle for span conversion (next step)\n    spanRowPtr = inProcessRowPtr - 1;\n  }\n  var spanRowShift =\n  // pick up row shift with or without overshoot\n  shiftinstruction == 'axistailward' ? spanRowPtr + 1 : -(spanRowPtr + 1);\n  // the following two values (axisReferenceRowShift & axisPixelShift), and no other calcs, \n  //     are carried forward in this function.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n  var axisReferenceRowShift = spanRowShift,\n    axisPixelShift = spanAxisPixelShift;\n  // this can only happen with oversized cellLength (ie > viewportLength)\n  //     and only using measured length\n  // axis must be no farther than 1 back of the last row end position\n  if (previousAxisRowOffset + axisReferenceRowShift > listEndrowOffset) {\n    axisReferenceRowShift -= 1;\n    if (layout == 'variable') {\n      axisPixelShift -= finalVariableRowLength; //gridRowLengths.at(-1)\n    } else {\n      axisPixelShift -= baseRowLength;\n    }\n  }\n  // -----------[ 3. calculate current viewport axis offset ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n  var scrollblockAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockOffset =\n  // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n  // currentViewportAxisOffset will be negative (above viewport edge) for scroll block headward \n  //     and positive for scroll block tailward\n  // the pixel distance between the viewport frame and the axis, toward the head\n  var currentViewportAxisOffset = scrollblockAxisOffset + scrollblockOffset - scrollPos;\n  // -------------[ 4. calculate new axis pixel position ]------------------\n  var newAxisViewportPixelOffset = currentViewportAxisOffset + axisPixelShift;\n  // Note: sections 5, 6 and 7 deal entirely with row calculations; no pixels\n  // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n  var cradleReferenceRowshift = axisReferenceRowShift;\n  // base values\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowShift;\n  // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n  if (shiftinstruction == 'axistailward') {\n    // scrolling up/left\n    // a. if scrolling the block headward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling the block headward (revealing tail of list), as the cradle last row offset \n    // approaches max listrow, new cradle offset and cradle row shift have to be adjusted to prevent \n    // shortening of cradle content.\n    // --- start of list adjustment\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1); // extra row for visibility\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    }\n    // --- end of list adjustment: case of being in bounds of trailing runway (end of list)\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n    if (tailrowdiff > 0) {\n      cradleReferenceRowshift -= tailrowdiff;\n      newCradleReferenceRowOffset -= tailrowdiff;\n    }\n  } else {\n    // shiftinstruction == 'axisheadward'; scrolling down/right\n    // c. if scrolling the block down or right (toward revealing head of list), as the cradlerowoffset \n    // hits 0, cradle changes have to be adjusted to prevent shortening of cradle content\n    // d. if scrolling headward near the end of the list, cradle changes have to be adjusted to \n    // accomodate the trailing runway\n    // --- start of list adjustment\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    }\n    if (layout == 'variable' && newAxisReferenceRowOffset == 0) {\n      newAxisViewportPixelOffset = padding;\n    }\n    // --- end of list adjustment; case of in bounds of trailing runway\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n    var _targetCradleEndrowOffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n    var _tailrowdiff = Math.max(0, _targetCradleEndrowOffset - computedNextCradleEndrowOffset);\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset -= _tailrowdiff;\n    }\n  }\n  // ----------------------[ 7. map rows to item references ]----------------------\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowShift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  }\n  // create head and tail change counts\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount;\n  // ---------------------[ 8. return required values ]-------------------\n  return {\n    // newCradleReferenceIndex, \n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisViewportPixelOffset: newAxisViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\nexports.calcShiftSpecs = calcShiftSpecs;\n// supports calcContentShift above\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n  return rowLengths;\n};\n// supports calcContentShift above\nvar getGridRowAggregateSpans = function getGridRowAggregateSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n};\n// =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds CellFrames at end of contentlist according to headindexcount and tailindexcount,\n// or if indexcount values are <0 removes them.\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n    cradleInternalProperties = _ref4.cradleInternalProperties,\n    cacheHandler = _ref4.cacheHandler,\n    cradleContentCount = _ref4.cradleContentCount,\n    cradleReferenceIndex = _ref4.cradleReferenceIndex,\n    listStartChangeCount = _ref4.listStartChangeCount,\n    listEndChangeCount = _ref4.listEndChangeCount,\n    contentlist = _ref4.workingContentList,\n    instanceIdCounterRef = _ref4.instanceIdCounterRef,\n    styles = _ref4.styles,\n    placeholderMessages = _ref4.placeholderMessages;\n  var localContentlist = _toConsumableArray(contentlist);\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n    tailContentlist = [];\n  var deletedtailitems = [],\n    deletedheaditems = [];\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    var referenceIndex = cradleReferenceIndex;\n    var changeCount = listStartChangeCount;\n    if (listStartChangeCount > cradleContentCount) {\n      referenceIndex = cradleReferenceIndex - (listStartChangeCount - cradleContentCount);\n      changeCount = cradleContentCount;\n    }\n    for (var newindex = referenceIndex - changeCount; newindex < referenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    var _referenceIndex = lastindexoffset;\n    var _changeCount = listEndChangeCount;\n    if (listEndChangeCount > cradleContentCount) {\n      _referenceIndex = lastindexoffset + (listEndChangeCount - cradleContentCount);\n      _changeCount = cradleContentCount;\n    }\n    for (var _newindex = _referenceIndex + 1; _newindex < _referenceIndex + 1 + _changeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\nexports.getCellFrameComponentList = getCellFrameComponentList;\n// Leading (head) all or partially hidden; tail, visible plus trailing hidden\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n    axisReferenceIndex = _ref5.axisReferenceIndex,\n    layoutHandler = _ref5.layoutHandler;\n  var _a;\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index,\n    highindex = offsetindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n  if (triggercellIndex !== undefined && offsetindex !== undefined) {\n    //&& \n    if (triggercellIndex >= offsetindex && triggercellIndex <= highindex) {\n      var _triggercellPtr = triggercellIndex - offsetindex;\n      var _triggercellComponent = contentlist[_triggercellPtr];\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n  var triggercellPtr = targetTriggercellIndex - offsetindex;\n  var triggercellComponent = contentlist[triggercellPtr];\n  if (triggercellComponent) {\n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    // defensive; shouldn't happen\n    console.log('FAILURE TO REGISTER TRIGGERCELL:');\n    console.log('axisReferenceIndex, triggercellIndex, offsetindex, highindex, headitemcount, targetTriggercellIndex', axisReferenceIndex, triggercellIndex, offsetindex, highindex, headitemcount, targetTriggercellIndex);\n    console.log('triggercellPtr, triggercellComponent, triggercellComponent?.props.isTriggecell, contentlist\\n', triggercellPtr, triggercellComponent, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell, Object.assign({}, contentlist));\n  }\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\nexports.allocateContentList = allocateContentList;\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\nexports.deletePortals = deletePortals;\n// =====================[ internal, acquire item ]======================\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n    cradleInheritedProperties = _ref6.cradleInheritedProperties,\n    cradleInternalProperties = _ref6.cradleInternalProperties,\n    instanceIdCounterRef = _ref6.instanceIdCounterRef,\n    cacheHandler = _ref6.cacheHandler,\n    placeholderFrameStyles = _ref6.placeholderFrameStyles,\n    placeholderLinerStyles = _ref6.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref6.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref6.placeholderErrorLinerStyles,\n    placeholderMessages = _ref6.placeholderMessages;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    cellMinHeight = cradleInheritedProperties.cellMinHeight,\n    cellMinWidth = cradleInheritedProperties.cellMinWidth,\n    getItem = cradleInheritedProperties.getItem,\n    placeholder = cradleInheritedProperties.placeholder,\n    scrollerID = cradleInheritedProperties.scrollerID,\n    layout = cradleInheritedProperties.layout,\n    usePlaceholder = cradleInheritedProperties.usePlaceholder;\n  var listsize = cradleInternalProperties.listsize;\n  // get new or existing itemID\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    usePlaceholder: usePlaceholder,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderLinerStyles: placeholderLinerStyles,\n    placeholderErrorFrameStyles: placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles: placeholderErrorLinerStyles,\n    placeholderMessages: placeholderMessages\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsRUFBS1QsVUFBVTtJQUNsQjVLLFdBQVcsRUFBS0EsV0FBVztJQUMzQnNDLFVBQVUsRUFBS0EsVUFBVTtJQUN6QkMsU0FBUyxFQUFLQSxTQUFTO0lBQ3ZCc0ksYUFBYSxFQUFLQSxhQUFhO0lBQy9CQyxZQUFZLEVBQUtBLFlBQVk7SUFDN0J0SSxNQUFNLEVBQUtBLE1BQU07SUFDakJjLEtBQUssRUFBS0EsS0FBSztJQUNmeUgsT0FBTyxFQUFLQSxPQUFPO0lBQ25CaE0sUUFBUSxFQUFLQSxRQUFRO0lBQ3JCaU0sV0FBVyxFQUFLQSxXQUFXO0lBQzNCRSxNQUFNLEVBQUtBLE1BQU07SUFDakJOLFVBQVUsRUFBS0EsVUFBVTtJQUN6QnpLLFVBQVUsRUFBS0EsVUFBVTtJQUN6QjJKLGFBQWEsRUFBSyxLQUFLO0lBQ3ZCbUIsY0FBYyxFQUFLQSxjQUFjO0lBQ2pDNUMsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqREUsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqREUsMkJBQTJCLEVBQUtBLDJCQUEyQjtJQUMzREUsMkJBQTJCLEVBQUtBLDJCQUEyQjtJQUMzRGpCLG1CQUFtQixFQUFLQTtFQUFtQixFQUM3QztBQUVOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBjb250ZW50aGFuZGxlciBtb2R1bGUuIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgcGVyZm9ybVxuICAgIHRoZSBkZXRhaWxlZCBjYWxjdWxhdGlvbnMgYW5kIHByb2Nlc3NlcyByZXF1aXJlZCBieSB0aGUgY29udGVudGhhbmRsZXIuXG5cbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyBpcyBjYWxsZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyJ3Mgc2V0Q3JhZGxlQ29udGVudCBmdW5jdGlvbi5cblxuICAgIGdldFNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4uL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcbiAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgbGlzdHNpemUsXG5cbiAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG4gICAgXG4gICAgLy8gYWxpZ24gYXhpcyByZWZlcmVuY2UgdG8gZmlyc3Qgcm93IGl0ZW1cbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbih0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtPSAodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudClcblxuICAgIC8vIGRlcml2ZSB0YXJnZXQgcm93XG4gICAgbGV0IHRhcmdldEF4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICAvLyB1cGRhdGUgd2lsbCBjb21wZW5zYXRlIGlmIHRoaXMgaXMgdG9vIGhpZ2hcbiAgICBjb25zdCBtYXhBeGlzUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCxsaXN0Um93Y291bnQgLSAxKVxuICAgIGlmICh0YXJnZXRBeGlzUm93T2Zmc2V0ID4gbWF4QXhpc1Jvd09mZnNldCkge1xuICAgICAgICB0YXJnZXRBeGlzUm93T2Zmc2V0ID0gbWF4QXhpc1Jvd09mZnNldFxuICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRBeGlzUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZVJlZmVyZW5jZVJvdyAmIEluZGV4IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGxlYWRpbmcgZWRnZVxuICAgIGxldCB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgPSBNYXRoLm1heCgwLHRhcmdldEF4aXNSb3dPZmZzZXQgLSBydW53YXlSb3djb3VudClcblxuICAgIC8vIHRyYWlsaW5nIGVkZ2VcbiAgICBsZXQgdGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID0gdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcblxuICAgIGNvbnN0IGxpc3RFbmRSb3dPZmZzZXQgPSAobGlzdFJvd2NvdW50IC0gMSlcblxuICAgIGlmICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPiAobGlzdEVuZFJvd09mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9ICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgLSBsaXN0RW5kUm93T2Zmc2V0KVxuICAgICAgICB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgLT0gZGlmZlxuICAgICAgICB0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgLT0gZGlmZlxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4ID0gdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZSBjb250ZW50IGNvdW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICBpZiAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID09IGxpc3RFbmRSb3dPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZW5kUm93UmVtYWluZGVyQ291bnQgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgaWYgKGVuZFJvd1JlbWFpbmRlckNvdW50KSB7XG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQgLT0gKGNyb3NzY291bnQgLSBlbmRSb3dSZW1haW5kZXJDb3VudClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNzcyBwb3NpdGlvbmluZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAodGFyZ2V0QXhpc1Jvd09mZnNldCAqIGJhc2VSb3dMZW5ndGgpICsgcGFkZGluZyAtIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZXR1cm4gcmVxdWlyZWQgdmFsdWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIFxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsIFxuICAgIH0gXG5cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PVsgZm9yIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKlxuICAgIHRoZSB0d28gdHJpZ2dlcmxpbmVzIG11c3Qgc3RyYWRkbGUgdGhlIGhlYWQgb2YgdGhlIHZpZXdwb3J0ICh0b3Agb3IgbGVmdCkgc28gdGhhdFxuICAgIGNyYWRsZSBtb3Rpb24gY2FuIGJlIGRldGVjdGVkLiBNb3Rpb24gaXMgbW9zdCBvZnRlbiBjYXVzZWQgYnkgc2Nyb2xsaW5nLCBidXRcbiAgICBjYW4gYWxzbyBvY2N1ciB3aXRoIGNoYW5nZSBvZiBzaXplIG9mIGNyYWRsZSBjb250ZW50IHJvd3MuXG5cbiAgICBnZXRTaGlmdEluc3RydWN0aW9uIGRldGVybWluZXMgd2hldGhlciB0aGUgYXhpcyBzaG91bGQgYmUgbW92ZWQgdG93YXJkIHRoZSBoZWFkIG9yIHRhaWxcbiAgICAgICAgdG8gcmVzdG9yZSB0aGUgc3RyYWRkbGluZyBwb3NpdGlvbiBvZiB0aGUgdHdvIHRyaWdnZXIgbGluZXMuIExvdHMgb2YgcmVsYXRpdmUgbW90aW9uLlxuXG4gICAgJ2F4aXNoZWFkd2FyZCcgKHNjcm9sbGluZyBkb3duIG9yIHJpZ2h0KSBtZWFucyBtb3ZpbmcgdGhlIGF4aXMgdXAgb3IgbGVmdCwgYWRqYWNlbnQgaXRlbXMgZG93blxuICAgICAgICAgb3IgcmlnaHQgdG8gdGhlIHRhaWwsIGRyb3BwaW5nIHRyYWlsaW5nIHRhaWwgaXRlbXMsIGFuZCBhZGRpbmcgbGVhZGluZyBoZWFkIGl0ZW1zIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgdG8gbWFpbnRhaW4gbnVtYmVyIG9mIGNyYWRsZSByb3dzIG9mIGNvbnRlbnQgY29uc3RhbnQuXG5cbiAgICAnYXhpc3RhaWx3YXJkJyAoc2Nyb2xsaW5nIHVwIG9yIGxlZnQpIG1lYW5zIG1vdmluZyB0aGUgYXhpcyBkb3duIG9yIHJpZ2h0LCBhZGphY2VudCBpdGVtcyB1cFxuICAgICAgICAgb3IgbGVmdCB0byB0aGUgaGVhZCwgZHJvcHBpbmcgdHJhaWxpbmcgaGVhZCBpdGVtcywgYW5kIGFkZGluZyBsZWFkaW5nIHRhaWwgaXRlbXMgYXMgbmVjZXNzYXJ5XG4gICAgICAgICB0byBtYWludGFpbiBudW1iZXIgb2YgY3JhZGxlIHJvd3Mgb2YgY29udGVudCBjb25zdGFudC5cblxuICAgICdub25lJyBtZWFucyBubyBzaGlmdCBpcyByZXF1aXJlZFxuKi9cblxuZXhwb3J0IGNvbnN0IGdldFNoaWZ0SW5zdHJ1Y3Rpb24gPSAoe1xuXG4gICAgb3JpZW50YXRpb24sXG4gICAgdHJpZ2dlcmxpbmVFbnRyaWVzLFxuICAgIHRyaWdnZXJsaW5lU3BhbixcbiAgICBzY3JvbGxlcklELCAvLyBmb3IgZGVidWdcbiAgICBcbiAgICAvLyBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZyBpcyB0cnVlIGlmIHRoZSB0cmlnZ2VybGluZXMgYXJlIHdpdGggdGhlIGZpcnN0IHRhaWwgcm93IGluc3RlYWQgb2YgdGhlXG4gICAgLy8gbGFzdCBoZWFkcm93LiBUaGF0IGhhcHBlbnMgKHdvcmthcm91bmQpIHdoZW4gdGhlcmUgYXJlIG5vIGhlYWQgcm93c1xuICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnLCBcblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IG1lYXN1cmUgem9vbWVkIHZhbHVlcyBmb3Igcm9vdGJvdW5kcyBpbiB0cmlnZ2VybGluZUVudHJpZXMsIHNvIHdlIHRha2UgYSBkaXJlY3QgcmVhZGluZ1xuICAgIHZpZXdwb3J0Qm91bmRpbmdSZWN0LCBcbiAgICB0cmlnZ2VySGlzdG9yeVJlZixcblxufSkgPT4ge1xuXG4gICAgY29uc3QgdHJpZ2dlckRhdGEgPSB7XG4gICAgICAgIGhlYWRPZmZzZXQ6bnVsbCxcbiAgICAgICAgdGFpbE9mZnNldDpudWxsLFxuICAgICAgICBzcGFuOnRyaWdnZXJsaW5lU3BhbixcbiAgICAgICAgaXNGaXJzdFJvd1RyaWdnZXJDb25maWdcbiAgICB9XG5cbiAgICAvLyBtb3N0IHJlY2VudDsgZWl0aGVyIHRyaWdnZXJsaW5lIHdpbGwgZG9cbiAgICBjb25zdCBlbnRyeSA9IHRyaWdnZXJsaW5lRW50cmllc1t0cmlnZ2VybGluZUVudHJpZXMubGVuZ3RoIC0gMV0gLy8uYXQoLTEpIGF0IG5vdCBhdmFpbGFibGUgaW4gaU9TIDE1XG4gICAgY29uc3QgcmVmZXJlbmNlbmFtZSA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGVcbiAgICBlbnRyeS5yZWZlcmVuY2VuYW1lID0gcmVmZXJlbmNlbmFtZVxuICAgIGNvbnN0IHNwYW4gPSB0cmlnZ2VybGluZVNwYW5cblxuICAgIGNvbnN0IGludGVyc2VjdHJvb3Rwb3MgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgTWF0aC50cnVuYyhlbnRyeS5yb290Qm91bmRzLnkpOlxuICAgICAgICAgICAgTWF0aC50cnVuYyhlbnRyeS5yb290Qm91bmRzLngpXG4gICAgICAgICAgICAvLyBlbnRyeS5yb290Qm91bmRzLnk6XG4gICAgICAgICAgICAvLyBlbnRyeS5yb290Qm91bmRzLnhcblxuICAgIGNvbnN0IGJvdW5kaW5ncm9vdHBvcyA9XG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIE1hdGgudHJ1bmModmlld3BvcnRCb3VuZGluZ1JlY3QueSk6XG4gICAgICAgICAgICBNYXRoLnRydW5jKHZpZXdwb3J0Qm91bmRpbmdSZWN0LngpXG4gICAgICAgICAgICAvLyB2aWV3cG9ydEJvdW5kaW5nUmVjdC55OlxuICAgICAgICAgICAgLy8gdmlld3BvcnRCb3VuZGluZ1JlY3QueFxuXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgcmVkdW5kYW50LCBidXQgZG9jdW1lbnRzIHdoYXQncyBnb2luZyBvblxuICAgIGNvbnN0IHJvb3Rwb3MgPSBcbiAgICAgICAgKGludGVyc2VjdHJvb3Rwb3MgPT0gYm91bmRpbmdyb290cG9zKT9cbiAgICAgICAgaW50ZXJzZWN0cm9vdHBvczpcbiAgICAgICAgYm91bmRpbmdyb290cG9zIC8vIHdlJ3JlIGluIFNhZmFyaSwgem9vbWVkXG5cbiAgICBjb25zdCBlbnRyeXBvcyA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBNYXRoLnRydW5jKGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC55KTpcbiAgICAgICAgICAgIE1hdGgudHJ1bmMoZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LngpXG4gICAgICAgICAgICAvLyBlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3QueTpcbiAgICAgICAgICAgIC8vIGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC54XG5cbiAgICBjb25zdCB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgPSBlbnRyeXBvcyAtIHJvb3Rwb3NcblxuICAgIGlmIChyZWZlcmVuY2VuYW1lID09ICdoZWFkdHJpZ2dlcicpIHtcblxuICAgICAgICB0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID0gdmlld3BvcnRUcmlnZ2VyT2Zmc2V0XG4gICAgICAgIHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgKyBzcGFuXG5cbiAgICB9IGVsc2UgeyAvLyB0YWlsdHJpZ2dlclxuXG4gICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgLSBzcGFuXG4gICAgICAgIHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXRcblxuICAgIH1cblxuICAgIGxldCBzaGlmdGluc3RydWN0aW9uXG4gICAgXG4gICAgY29uc3QgdHJpZ2dlckhpc3RvcnkgPSB0cmlnZ2VySGlzdG9yeVJlZi5jdXJyZW50O1xuXG4gICAgLy8gc2luY2UgdHJpZ2dlcnMgYXJlIG1vdmVkIGFuZCBjYW4gc2hhcmUgdGhlIDAgKHplcm8pIG9mZnNldCwgYW4gaW5maW5pdGUgbG9vcCBjYW4gb2NjdXJcbiAgICAvLyBiZXR3ZWVuIHRoZSBoZWFkIGFuZCB0YWlsIHRyaWdnZXJzLiBUaGUgZm9sbG93aW5nIHNob3J0LWNpcmN1aXRzIHRoYXQuXG4gICAgLy8gT2J2aW91c2x5IG5lZWRzIHdvcmsgdG8gZ2VuZXJhbGl6ZS4uLlxuICAgIGlmICgoaXNTYWZhcmlJT1MoKSAmJiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA9PSAwIHx8IHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPT0gMCkpIHx8XG4gICAgICAgICghaXNTYWZhcmlJT1MoKSAmJiAoKCh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IC0xKSAmJiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA8PSAxKSkgfHwgXG4gICAgICAgICgodHJpZ2dlckRhdGEudGFpbE9mZnNldCA+PSAtMSkgJiYgKHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPD0gMSkpKSkpIHtcblxuICAgICAgICAvLyBzb21lIGJyb3dzZXJzIGRvIGFuIGluZmluaXRlIGxvb3Agd2l0aCB0aGUgc2FtZSBwcmV2aW91c1JlZmVyZW5jZU5hbWU7XG4gICAgICAgIC8vIHVzdWFsbHkgYWx0ZXJuYXRlc1xuICAgICAgICBpZiAodHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lKSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSA9IG51bGxcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICgodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA+PSAtMSkgJiYgKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPD0gMSkpIHtcblxuICAgICAgICAgICAgLy8gaWYgKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lID0gJ2hlYWR0cmlnZ2VyJ1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lID0gJ3RhaWx0cmlnZ2VyJ1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAodHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lKSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSA9IG51bGxcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24pIHsgLy8gd2lsbCBiZSAnbm9uZSdcblxuICAgICAgICByZXR1cm4gW3NoaWZ0aW5zdHJ1Y3Rpb24sIDBdLy90cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3NdXG5cbiAgICB9XG5cbiAgICBpZiAoaXNGaXJzdFJvd1RyaWdnZXJDb25maWcpIHtcblxuICAgICAgICBpZiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA8PSAwKSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnYXhpc3RhaWx3YXJkJ1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnbm9uZSdcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICh0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0IDw9IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdheGlzdGFpbHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdheGlzaGVhZHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0IHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyA9IFxuICAgICAgICAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJyk/IC8vIGJsb2NrIGlzIHNjcm9sbGluZyB1cCBvciBsZWZ0XG4gICAgICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0OiAvLyBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdG93YXJkIGhlYWRcbiAgICAgICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgLy8gbmVlZHMgdG8gbW92ZSBkb3duIG9yIHJpZ2h0IHRvd2FyZCB0YWlsXG5cblxuICAgIHJldHVybiBbc2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zXVxuXG59XG5cbi8qXG4gICAgVGhlIGJhc2ljIGdvYWwgb2YgY2FsY0NvbnRlbnRTaG9mdCBpcyB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBhbmQgZGlyZWN0aW9uIG9mIHJvd3MgdG8gc2hpZnQgYmV0d2VlblxuICAgIHRoZSBoZWFkIGFuZCB0YWlsIGdyaWRzICh3aGljaCBkZXRlcm1pbmVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGF4aXMpLCBhbmQgYWxzbyB0b1xuICAgIGNhbGN1bGF0ZSB0aGUgcm9sbGluZyBhZGRpdGlvbiBhbmQgZGVsZXRpb24gb2YgY3JhZGxlIGNvbnRlbnQgdG8gYWNjb21tb2RhdGUgdGhlIGNoYW5nZXMuXG5cbiAgICBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gc2hpZnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGl4ZWwgc2hpZnQgcmVxdWlyZWQgdG8gcmVzdG9yZSB0aGUgXG4gICAgdHJpZ2dlcmxpbmVzIHRvIHRoZWlyIHN0cmFkZGxlIGNvbmZpZ3VyYXRpb24gYXJvdW5kIHRoZSBoZWFkICh0b3Agb3IgbGVmdCkgb2YgdGhlIHZpZXdwb3J0LlxuXG4gICAgQWRqdXN0bWVudHMgYXJlIG1hZGUgdG8gYWNjb21tb2RhdGUgc3BlY2lhbCByZXF1aXJlbWVudHMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHZpcnR1YWwgbGlzdC5cblxuICAgIERPTSBtZWFzdXJlbWVudHMgYXJlIHVzZWQgd2hlcmUgYXZhaWxhYmxlICh0byBhY2NvbW1vZGF0ZSB2YXJpYWJsZSBkaW1lbnNpb24gcm93cyksIGFuZCBzdGFuZGFyZFxuICAgIHVuaXRzIChjZWxsSGVpZ2h0LCBjZWxsV2lkdGgpIHVzZWQgZm9yIGVzdGltYXRlcyB3aGVyZSBuZWNlc3NhcnkuXG4qL1xuXG4vLyByb3dzaGlmdCBpcyBhdCBsZWFzdCAxIGJ5IHRoZSB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgcmVhY2hlZFxuLy8gaWUuIGEgc2hpZnRpbnN0cnVjdGlvbiBvZiAnYXhpc2hlYWR3YXJkJyBvciAnYXhpc3RhaWx3YXJkJ1xuZXhwb3J0IGNvbnN0IGNhbGNTaGlmdFNwZWNzID0gKHtcblxuICAgIC8vIGRpcmVjdGlvbiBvZiBjaGFuZ2VcbiAgICBzaGlmdGluc3RydWN0aW9uLFxuICAgIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyxcblxuICAgIC8vIHBvc2l0aW9uYWxcbiAgICBzY3JvbGxQb3MsXG4gICAgc2Nyb2xsYmxvY2tFbGVtZW50LFxuXG4gICAgLy8gcHJvcGVydHkgcmVwb3NcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIC8vIGNyYWRsZSByZXBvc1xuICAgIGNyYWRsZUNvbnRlbnQsXG4gICAgY3JhZGxlRWxlbWVudHMsXG5cbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbmZpZ3VyYXRpb24gZGF0YVxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgLy8gY3JhZGxlIGVsZW1lbnRzXG4gICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG4gICAgICAgIGhlYWRHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudCxcbiAgICAgICAgdGFpbEdyaWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMudGFpbFJlZi5jdXJyZW50XG5cbiAgICAvLyBjcmFkbGUgY29udGVudHNcbiAgICBjb25zdCB7XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzOmNyYWRsZWNvbnRlbnRsaXN0LCBcbiAgICAgICAgdGFpbE1vZGVsQ29tcG9uZW50czp0YWlsY29udGVudGxpc3QsXG4gICAgICAgIC8vIGhlYWRNb2RlbENvbXBvbmVudHM6aGVhZGNvbnRlbnRsaXN0XG5cbiAgICB9ID0gY3JhZGxlQ29udGVudFxuXG4gICAgLy8gbW9yZSBjb25maWcgZGF0YVxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgY29uc3QgcHJldmlvdXNDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChjcmFkbGVjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMCksXG4gICAgICAgIHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4ID0gKHRhaWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMCksXG4gICAgICAgIHByZXZpb3VzQXhpc1Jvd09mZnNldCA9IE1hdGguY2VpbChwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuXG4gICAgY29uc3QgbGlzdEVuZHJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuICAgIGNvbnN0IGJhc2VSb3dMZW5ndGggPVxuICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgIGNlbGxXaWR0aCkgXG4gICAgICAgICsgZ2FwXG5cbiAgICBsZXQgc3BhblJvd1B0clxuICAgIGxldCBzcGFuQXhpc1BpeGVsU2hpZnQgPSAwIC8vIGluIHJlbGF0aW9uIHRvIHZpZXdwb3J0IGhlYWQgYm91bmRhcnlcbiAgICBsZXQgaW5Qcm9jZXNzUm93UHRyID0gMFxuICAgIGxldCBpc0xpc3RCb3VuZGFyeSA9IGZhbHNlXG4gICAgbGV0IHRvdGFsUGl4ZWxTaGlmdFxuICAgIGxldCBmaW5hbFZhcmlhYmxlUm93TGVuZ3RoIC8vIHNwZWNpYWwgY2FzZVxuXG4gICAgLy8gbWVhc3VyZSBleGlzaW5nIHJvd3MgZm9yIHZhcmlhYmxlIGxlbmd0aCBjZWxsc1xuICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgeyBcblxuICAgICAgICBjb25zdCByZWZlcmVuY2VHcmlkRWxlbWVudCA9IC8vIG1vdmluZyBheGlzIChhbmQgdHJpZ2dlcnMpIHRvd2FyZCB0aGUgcmVmZXJlbmNlIGdyaWQgZWxlbWVudFxuICAgICAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpPyAvLyBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICAgICAgICAgIHRhaWxHcmlkRWxlbWVudDpcbiAgICAgICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnRcblxuICAgICAgICBjb25zdCBncmlkUm93TGVuZ3RocyA9IGdldEdyaWRSb3dMZW5ndGhzKHJlZmVyZW5jZUdyaWRFbGVtZW50LCBvcmllbnRhdGlvbiwgY3Jvc3Njb3VudCwgZ2FwKVxuXG4gICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzaGVhZHdhcmQnKSB7IC8vIHNjcm9sbGluZyBkb3duIG9yIHJpZ2h0OyBtb3ZlIHRyaWdnZXJsaW5lcyB1cCBvciBsZWZ0XG5cbiAgICAgICAgICAgIGdyaWRSb3dMZW5ndGhzLnJldmVyc2UoKSAvLyBoZWFkIGdyaWQgcm93IGxlbmd0aHMgbGlzdGVkIGZyb20gYXhpcyB0b3dhcmQgaGVhZFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmlkUm93QWdncmVnYXRlU3BhbnMgPSBnZXRHcmlkUm93QWdncmVnYXRlU3BhbnMoZ3JpZFJvd0xlbmd0aHMpIC8vIGNvdW50IHBpeGVscyB3aGVyZSBhdmFpbGFibGVcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBjYWxjdWxhdGUgYmFzZSByb3cgc2hpZnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gZmlyc3QgdHJ5IHRvIGZpbmQgcG9zaXRpb24gYmFzZWQgb24ga25vd24gKGluc3RhbnRpYXRlZCkgcm93c1xuICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGwgdXBcblxuICAgICAgICAgICAgLy8gdGFpbCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBwb3NpdGl2ZVxuICAgICAgICAgICAgc3BhblJvd1B0ciA9IGdyaWRSb3dBZ2dyZWdhdGVTcGFucy5maW5kSW5kZXgoKGFnZ3JlZ2F0ZXNwYW4pID0+IFxuICAgICAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgKyBhZ2dyZWdhdGVzcGFuKSA+PSAwIClcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7IC8vICdheGlzaGVhZHdhcmQnLCBzY3JvbGxkb3duXG5cbiAgICAgICAgICAgIC8vIGhlYWQgdHJpZ2dlciBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdW50aWwgcG9zaXRpb24gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wIG9yIGxlZnQgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgIHNwYW5Sb3dQdHIgPSBncmlkUm93QWdncmVnYXRlU3BhbnMuZmluZEluZGV4KChhZ2dyZWdhdGVzcGFuKSA9PiBcbiAgICAgICAgICAgICAgICAodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIC0gYWdncmVnYXRlc3BhbikgPD0gMClcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoc3BhblJvd1B0ciA9PSAtMSkpIHsgLy8gZm91bmQgbWVhc3VyZWVkIHJvdyBmb3Igc2hpZnRcbiAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IFxuICAgICAgICAgICAgICAgIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzdGFpbHdhcmQnKT9cbiAgICAgICAgICAgICAgICAgICAgZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zW3NwYW5Sb3dQdHJdOiAvLyBtb3ZlIGF4aXMgdG93YXJkIHRhaWwgZnJvbSB2aWV3cG9ydCBib3VuZGFyeSAocG9zaXRpdmUpXG4gICAgICAgICAgICAgICAgICAgIC1ncmlkUm93QWdncmVnYXRlU3BhbnNbc3BhblJvd1B0cl0gLy8gbW92ZSBheGlzIHRvd2FyZCBoZWFkIGZyb20gdmlld3BvcnQgYm91bmRhcnkgKG5lZ2F0aXZlKVxuICAgICAgICB9IGVsc2UgeyAvLyBlaXRoZXIgaW4gYm91bmRhcnksIG9yIHNoeSBvZiB0YXJnZXRcblxuICAgICAgICAgICAgaXNMaXN0Qm91bmRhcnkgPSAoZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zLmxlbmd0aCA9PSAwKSAvLyBib3VuZGFyeSBhdCBoZWFkIG9mIGxpc3RcblxuICAgICAgICAgICAgaWYgKCFpc0xpc3RCb3VuZGFyeSkgeyAvLyBpbnRlcmltIHdvcmtpbmcgcmVzdWx0XG5cbiAgICAgICAgICAgICAgICBpblByb2Nlc3NSb3dQdHIgPSBncmlkUm93QWdncmVnYXRlU3BhbnMubGVuZ3RoIC0gMSAvLyBiYXNlOiBmYWlsZWQgbWVhc3VyZWQgcm93IHB0clxuICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCA9IGdyaWRSb3dBZ2dyZWdhdGVTcGFuc1tpblByb2Nlc3NSb3dQdHJdIC8vIHNldCBiYXNlIG9mIHdvcmtpbmcgb3ZlcnNob290XG4gICAgICAgICAgICAgICAgZmluYWxWYXJpYWJsZVJvd0xlbmd0aCA9IGdyaWRSb3dMZW5ndGhzLmF0KC0xKSAvLyBmb3Igb3ZlcnNpemUgY2VsbCBhZGp1c3RtZW50IGJlbG93XG5cbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gbGF5b3V0ID09ICd1bmlmb3JtJzsgdXNlIG9ubHkgZGVmaW5lZCBsZW5ndGhzXG5cbiAgICAgICAgc3BhblJvd1B0ciA9IC0xIC8vIFwibm90IGZvdW5kXCIsIGllIG5vdCBhcHBsaWNhYmxlXG5cbiAgICAgICAgaW5Qcm9jZXNzUm93UHRyID0gMFxuICAgICAgICB0b3RhbFBpeGVsU2hpZnQgPSAwXG5cbiAgICB9XG5cbiAgICAvLyB1bmlmb3JtIGxheW91dCwgb3Igb3ZlcnNob290IG9mIGluc3RhbnRpYXRlZCByb3dzOyBjb250aW51ZSB3aXRoIHZpcnR1YWwgYmFzZSByb3dzXG4gICAgaWYgKHNwYW5Sb3dQdHIgPT0gLTEgKSB7IFxuXG4gICAgICAgIGlmICghaXNMaXN0Qm91bmRhcnkpIHtcblxuICAgICAgICAgICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIHVwL2xlZnRcblxuICAgICAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgICAgICB0b3RhbFBpeGVsU2hpZnQgKz0gYmFzZVJvd0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyArIHRvdGFsUGl4ZWxTaGlmdCkgPCAwKSBcblxuICAgICAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IHRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBheGlzaGVhZHdhcmQ7IHNjcm9sbGluZyBkb3duL3JpZ2h0XG5cbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzUm93UHRyKytcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByZXZpb3VzQXhpc1Jvd09mZnNldCAtIGluUHJvY2Vzc1Jvd1B0cikgPT0gMCkgeyAvLyBzdG9wIGN5Y2xpbmcgYXQgaGVhZCBsaW1pdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIC0gdG90YWxQaXhlbFNoaWZ0KSA+IDApXG5cbiAgICAgICAgICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSAtdG90YWxQaXhlbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5Qcm9jZXNzUm93UHRyIGlzIG9uZSBncmVhdGVyIHRoYW4gc3BhblJvd1B0ciB3aXRoIGFjdHVhbCBtZWFzdXJlbWVudHMgYWJvdmVcbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGVtIGNvbXBhdGl2bGUgZm9yIHNwYW4gY29udmVyc2lvbiAobmV4dCBzdGVwKVxuICAgICAgICBzcGFuUm93UHRyID0gaW5Qcm9jZXNzUm93UHRyIC0gMSBcblxuICAgIH1cblxuICAgIGNvbnN0IHNwYW5Sb3dTaGlmdCA9IC8vIHBpY2sgdXAgcm93IHNoaWZ0IHdpdGggb3Igd2l0aG91dCBvdmVyc2hvb3RcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgc3BhblJvd1B0ciArIDE6XG4gICAgICAgICAgICAtKHNwYW5Sb3dQdHIgKyAxKVxuXG4gICAgLy8gdGhlIGZvbGxvd2luZyB0d28gdmFsdWVzIChheGlzUmVmZXJlbmNlUm93U2hpZnQgJiBheGlzUGl4ZWxTaGlmdCksIGFuZCBubyBvdGhlciBjYWxjcywgXG4gICAgLy8gICAgIGFyZSBjYXJyaWVkIGZvcndhcmQgaW4gdGhpcyBmdW5jdGlvbi5cbiAgICAvLyBmb3IgYXhpc1JlZmVyZW5jZVJvd3NoaWZ0OlxuICAgIC8vIG5lZ2F0aXZlIGZvciBtb3Zpbmcgcm93cyBvdXQgb2YgaGVhZCBpbnRvIHRhaWw7XG4gICAgLy8gcG9zaXRpdmUgZm9yIG1vdmluZyByb3dzIG91dCBvZiB0YWlsIGludG8gaGVhZFxuICAgIGxldCBheGlzUmVmZXJlbmNlUm93U2hpZnQgPSBzcGFuUm93U2hpZnQsXG4gICAgICAgIGF4aXNQaXhlbFNoaWZ0ID0gc3BhbkF4aXNQaXhlbFNoaWZ0IFxuXG4gICAgLy8gdGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aCBvdmVyc2l6ZWQgY2VsbExlbmd0aCAoaWUgPiB2aWV3cG9ydExlbmd0aClcbiAgICAvLyAgICAgYW5kIG9ubHkgdXNpbmcgbWVhc3VyZWQgbGVuZ3RoXG4gICAgLy8gYXhpcyBtdXN0IGJlIG5vIGZhcnRoZXIgdGhhbiAxIGJhY2sgb2YgdGhlIGxhc3Qgcm93IGVuZCBwb3NpdGlvblxuICAgIGlmICgocHJldmlvdXNBeGlzUm93T2Zmc2V0ICsgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0KSA+IGxpc3RFbmRyb3dPZmZzZXQpIHtcblxuICAgICAgICBheGlzUmVmZXJlbmNlUm93U2hpZnQgLT0gMVxuICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGF4aXNQaXhlbFNoaWZ0IC09IGZpbmFsVmFyaWFibGVSb3dMZW5ndGggLy9ncmlkUm93TGVuZ3Rocy5hdCgtMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXNQaXhlbFNoaWZ0IC09IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS1bIDMuIGNhbGN1bGF0ZSBjdXJyZW50IHZpZXdwb3J0IGF4aXMgb2Zmc2V0IF0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2FwcyBiZXlvbmQgcmVuZGVyZWQgcm93cyBjYW4gYmUgY2F1c2VkIGJ5IHJhcGlkIHNjcm9sbGluZ1xuXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tBeGlzT2Zmc2V0ID0gXG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldFRvcDpcbiAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldExlZnRcblxuICAgIGNvbnN0IHNjcm9sbGJsb2NrT2Zmc2V0ID0gLy8gdG8gY2FwdHVyZSBjdXJyZW50IHRvcC9sZWZ0IGFkanVzdG1lbnQgdG8gdmlld3BvcnQgZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgIC8vIGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgd2lsbCBiZSBuZWdhdGl2ZSAoYWJvdmUgdmlld3BvcnQgZWRnZSkgZm9yIHNjcm9sbCBibG9jayBoZWFkd2FyZCBcbiAgICAvLyAgICAgYW5kIHBvc2l0aXZlIGZvciBzY3JvbGwgYmxvY2sgdGFpbHdhcmRcbiAgICAvLyB0aGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgZnJhbWUgYW5kIHRoZSBheGlzLCB0b3dhcmQgdGhlIGhlYWRcbiAgICBjb25zdCBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0ID0gXG4gICAgICAgIHNjcm9sbGJsb2NrQXhpc09mZnNldCArIHNjcm9sbGJsb2NrT2Zmc2V0IC0gc2Nyb2xsUG9zXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tWyA0LiBjYWxjdWxhdGUgbmV3IGF4aXMgcGl4ZWwgcG9zaXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCArIGF4aXNQaXhlbFNoaWZ0XG5cbiAgICAvLyBOb3RlOiBzZWN0aW9ucyA1LCA2IGFuZCA3IGRlYWwgZW50aXJlbHkgd2l0aCByb3cgY2FsY3VsYXRpb25zOyBubyBwaXhlbHNcblxuICAgIC8vIC0tLS0tLS0tLS0tLVsgNS4gY2FsYyBuZXcgY3JhZGxlIGFuZCBheGlzIHJlZmVyZW5jZSByb3cgb2Zmc2V0cyBdLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gYmFzZSB2YWx1ZSBmb3IgY3JhZGxlIHJlZmVyZW5jZSBzaGlmdDsgbWF5IGNoYW5nZSBpZiBiZXlvbmQgbGlzdCBib3VuZHNcbiAgICBsZXQgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQgPSBheGlzUmVmZXJlbmNlUm93U2hpZnRcblxuICAgIC8vIGJhc2UgdmFsdWVzXG4gICAgbGV0IG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnRcbiAgICBjb25zdCBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ID0gcHJldmlvdXNBeGlzUm93T2Zmc2V0ICsgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0XG5cbiAgICAvLyAtLS0tLS0tLVsgNi4gYWRqdXN0IGNyYWRsZSBjb250ZW50cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBsaXN0IF0tLS0tLS0tXG4gICAgLy8gLi4udG8gbWFpbnRhaW4gY29uc3RhbnQgbnVtYmVyIG9mIGNyYWRsZSByb3dzXG5cbiAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGxpbmcgdXAvbGVmdFxuXG4gICAgICAgIC8vIGEuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgaGVhZHdhcmQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIG5ldyBjcmFkbGUgcm93IG9mZnNldCBhbmRcbiAgICAgICAgLy8gY3JhZGxlIHJvdyBzaGlmdCBjb3VudCBoYXMgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxlYWRpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gYi4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayBoZWFkd2FyZCAocmV2ZWFsaW5nIHRhaWwgb2YgbGlzdCksIGFzIHRoZSBjcmFkbGUgbGFzdCByb3cgb2Zmc2V0IFxuICAgICAgICAvLyBhcHByb2FjaGVzIG1heCBsaXN0cm93LCBuZXcgY3JhZGxlIG9mZnNldCBhbmQgY3JhZGxlIHJvdyBzaGlmdCBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgXG4gICAgICAgIC8vIHNob3J0ZW5pbmcgb2YgY3JhZGxlIGNvbnRlbnQuXG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQgLSAxKSkgLy8gZXh0cmEgcm93IGZvciB2aXNpYmlsaXR5XG5cbiAgICAgICAgY29uc3QgaGVhZHJvd0RpZmYgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgaWYgKGhlYWRyb3dEaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gaGVhZHJvd0RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IGhlYWRyb3dEaWZmXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OiBjYXNlIG9mIGJlaW5nIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXkgKGVuZCBvZiBsaXN0KVxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0IC0gbGlzdEVuZHJvd09mZnNldClcblxuICAgICAgICBpZiAodGFpbHJvd2RpZmYgPiAwKSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBzaGlmdGluc3RydWN0aW9uID09ICdheGlzaGVhZHdhcmQnOyBzY3JvbGxpbmcgZG93bi9yaWdodFxuXG4gICAgICAgIC8vIGMuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgZG93biBvciByaWdodCAodG93YXJkIHJldmVhbGluZyBoZWFkIG9mIGxpc3QpLCBhcyB0aGUgY3JhZGxlcm93b2Zmc2V0IFxuICAgICAgICAvLyBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmUgdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICAgICAgLy8gZC4gaWYgc2Nyb2xsaW5nIGhlYWR3YXJkIG5lYXIgdGhlIGVuZCBvZiB0aGUgbGlzdCwgY3JhZGxlIGNoYW5nZXMgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBcbiAgICAgICAgLy8gYWNjb21vZGF0ZSB0aGUgdHJhaWxpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IDBcblxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgIG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gcGFkZGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tIGVuZCBvZiBsaXN0IGFkanVzdG1lbnQ7IGNhc2Ugb2YgaW4gYm91bmRzIG9mIHRyYWlsaW5nIHJ1bndheVxuICAgICAgICBjb25zdCBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIChwcmV2aW91c0NyYWRsZVJvd09mZnNldCArIChjcmFkbGVSb3djb3VudCAtMSkgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdClcblxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBNYXRoLm1pbihsaXN0RW5kcm93T2Zmc2V0LCBcbiAgICAgICAgICAgIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpKSlcblxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsIHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldClcblxuICAgICAgICBpZiAodGFpbHJvd2RpZmYgPiAwKSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICs9IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA3LiBtYXAgcm93cyB0byBpdGVtIHJlZmVyZW5jZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCAqIGNyb3NzY291bnQpXG4gICAgY29uc3QgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0ID0gKGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICogY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IG5ld0F4aXNSZWZlcmVuY2VJbmRleCA9IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCA9IGF4aXNSZWZlcmVuY2VSb3dTaGlmdCAqIGNyb3NzY291bnRcblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnQgLy8gYmFzZSBjb3VudFxuICAgIGNvbnN0IGluY2x1ZGVzTGFzdFJvdyA9ICgobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgY3JhZGxlUm93Y291bnQpID49IGxpc3RSb3djb3VudClcbiAgICBpZiAoaW5jbHVkZXNMYXN0Um93KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxzcGFjZXMgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgY29uc3QgaXRlbXNTaG9ydGZhbGwgPSBcbiAgICAgICAgICAgIChwYXJ0aWFsc3BhY2VzID09IDApP1xuICAgICAgICAgICAgICAgIDA6XG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCAtIHBhcnRpYWxzcGFjZXNcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IGl0ZW1zU2hvcnRmYWxsXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGhlYWQgYW5kIHRhaWwgY2hhbmdlIGNvdW50c1xuICAgIGNvbnN0IGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlY29udGVudGxpc3QubGVuZ3RoIC0gbmV3Q3JhZGxlQ29udGVudENvdW50XG5cbiAgICBjb25zdCBsaXN0U3RhcnRDaGFuZ2VDb3VudCA9IC0oY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0KVxuICAgIGNvbnN0IGxpc3RFbmRDaGFuZ2VDb3VudCA9IC1saXN0U3RhcnRDaGFuZ2VDb3VudCAtIGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDguIHJldHVybiByZXF1aXJlZCB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgLy8gbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQsIFxuICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBheGlzUmVmZXJlbmNlSXRlbVNoaWZ0LCBcblxuICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnRcbiAgICB9XG5cbn1cblxuLy8gc3VwcG9ydHMgY2FsY0NvbnRlbnRTaGlmdCBhYm92ZVxuY29uc3QgZ2V0R3JpZFJvd0xlbmd0aHMgPSAoZ3JpZCwgb3JpZW50YXRpb24sIGNyb3NzY291bnQsIGdhcCkgPT4ge1xuXG4gICAgY29uc3Qgcm93TGVuZ3RocyA9IFtdXG4gICAgY29uc3QgZWxlbWVudExpc3QgPSBncmlkLmNoaWxkTm9kZXNcblxuICAgIGxldCBlbGVtZW50UHRyID0gMFxuICAgIGxldCBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJvd2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoKSBcbiAgICAgICAgICAgICsgZ2FwXG4gICAgICAgIHJvd0xlbmd0aHMucHVzaChyb3dsZW5ndGgpXG4gICAgICAgIGVsZW1lbnRQdHIgKz0gY3Jvc3Njb3VudFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cbiAgICB9XG5cbiAgICByZXR1cm4gcm93TGVuZ3Roc1xufVxuXG4vLyBzdXBwb3J0cyBjYWxjQ29udGVudFNoaWZ0IGFib3ZlXG5jb25zdCBnZXRHcmlkUm93QWdncmVnYXRlU3BhbnMgPSAocm93TGVuZ3RocykgPT4ge1xuXG4gICAgY29uc3Qgcm93U3BhbnMgPSBbXVxuICAgIGxldCBzcGFuID0gMFxuICAgIHJvd0xlbmd0aHMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgc3BhbiArPSB2YWx1ZVxuICAgICAgICByb3dTcGFucy5wdXNoKHNwYW4pXG4gICAgfSlcblxuICAgIHJldHVybiByb3dTcGFuc1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIHNoYXJlZCBieSBib3RoIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHVwZGF0ZSBjb250ZW50XG4vLyBhZGRzIENlbGxGcmFtZXMgYXQgZW5kIG9mIGNvbnRlbnRsaXN0IGFjY29yZGluZyB0byBoZWFkaW5kZXhjb3VudCBhbmQgdGFpbGluZGV4Y291bnQsXG4vLyBvciBpZiBpbmRleGNvdW50IHZhbHVlcyBhcmUgPDAgcmVtb3ZlcyB0aGVtLlxuZXhwb3J0IGNvbnN0IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3QgPSAoeyBcblxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LCBcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LCBcbiAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0OmNvbnRlbnRsaXN0LFxuICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgY29uc3QgbGFzdGluZGV4b2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggKyBsb2NhbENvbnRlbnRsaXN0Lmxlbmd0aCAtIDFcblxuICAgIGNvbnN0IGhlYWRDb250ZW50bGlzdCA9IFtdLCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgbGV0IGRlbGV0ZWR0YWlsaXRlbXMgPSBbXSwgZGVsZXRlZGhlYWRpdGVtcyA9IFtdXG5cbiAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuICAgICAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBjcmFkbGVSZWZlcmVuY2VJbmRleFxuICAgICAgICBsZXQgY2hhbmdlQ291bnQgPSBsaXN0U3RhcnRDaGFuZ2VDb3VudFxuICAgICAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPiBjcmFkbGVDb250ZW50Q291bnQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggLSAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgLSBjcmFkbGVDb250ZW50Q291bnQpXG4gICAgICAgICAgICBjaGFuZ2VDb3VudCA9IGNyYWRsZUNvbnRlbnRDb3VudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbmV3aW5kZXggPSByZWZlcmVuY2VJbmRleCAtIGNoYW5nZUNvdW50OyBuZXdpbmRleCA8IHJlZmVyZW5jZUluZGV4OyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVybGluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZXJyb3JmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJlcnJvcmxpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbGV0ZWRoZWFkaXRlbXMgPSBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSggMCwgLWxpc3RTdGFydENoYW5nZUNvdW50IClcblxuICAgIH1cblxuICAgIGlmIChsaXN0RW5kQ2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGxldCByZWZlcmVuY2VJbmRleCA9IGxhc3RpbmRleG9mZnNldFxuICAgICAgICBsZXQgY2hhbmdlQ291bnQgPSBsaXN0RW5kQ2hhbmdlQ291bnRcbiAgICAgICAgaWYgKGxpc3RFbmRDaGFuZ2VDb3VudCA+IGNyYWRsZUNvbnRlbnRDb3VudCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXggPSBsYXN0aW5kZXhvZmZzZXQgKyAobGlzdEVuZENoYW5nZUNvdW50IC0gY3JhZGxlQ29udGVudENvdW50KVxuICAgICAgICAgICAgY2hhbmdlQ291bnQgPSBjcmFkbGVDb250ZW50Q291bnRcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuZXdpbmRleCA9IHJlZmVyZW5jZUluZGV4ICsgMTsgbmV3aW5kZXggPCAocmVmZXJlbmNlSW5kZXggKyAxICsgY2hhbmdlQ291bnQpOyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIHRhaWxDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVybGluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZXJyb3JmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJlcnJvcmxpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbGV0ZWR0YWlsaXRlbXMgPSBsb2NhbENvbnRlbnRsaXN0LnNwbGljZShsaXN0RW5kQ2hhbmdlQ291bnQsLWxpc3RFbmRDaGFuZ2VDb3VudClcblxuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtcyA9IFsuLi5kZWxldGVkaGVhZGl0ZW1zLC4uLmRlbGV0ZWR0YWlsaXRlbXNdXG5cbiAgICBjb25zdCBjb21wb25lbnRMaXN0ID0gWy4uLmhlYWRDb250ZW50bGlzdCwuLi5sb2NhbENvbnRlbnRsaXN0LC4uLnRhaWxDb250ZW50bGlzdF1cblxuICAgIHJldHVybiBbY29tcG9uZW50TGlzdCxkZWxldGVkSXRlbXNdXG5cbn1cblxuLy8gTGVhZGluZyAoaGVhZCkgYWxsIG9yIHBhcnRpYWxseSBoaWRkZW47IHRhaWwsIHZpc2libGUgcGx1cyB0cmFpbGluZyBoaWRkZW5cbmV4cG9ydCBjb25zdCBhbGxvY2F0ZUNvbnRlbnRMaXN0ID0gKFxuICAgIHtcblxuICAgICAgICBjb250ZW50bGlzdCwgLy8gb2YgY3JhZGxlLCBpbiBpdGVtcyAoUmVhY3QgY29tcG9uZW50cylcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCAvLyBmaXJzdCB0YWlsIGl0ZW1cbiAgICAgICAgbGF5b3V0SGFuZGxlcixcblxuICAgIH1cbikgPT4ge1xuXG4gICAgY29uc3QgeyB0cmlnZ2VyY2VsbEluZGV4IH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICBjb25zdCBvZmZzZXRpbmRleCA9IGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCxcbiAgICAgICAgaGlnaGluZGV4ID0gb2Zmc2V0aW5kZXggKyBjb250ZW50bGlzdC5sZW5ndGhcblxuICAgIGNvbnN0IGhlYWRpdGVtY291bnQgPSAoYXhpc1JlZmVyZW5jZUluZGV4IC0gb2Zmc2V0aW5kZXgpXG5cbiAgICBjb25zdCB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4ID0gXG4gICAgICAgIChoZWFkaXRlbWNvdW50ID09IDApP1xuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4OlxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4IC0gMVxuXG4gICAgbGF5b3V0SGFuZGxlci50cmlnZ2VyY2VsbElzSW5UYWlsID0gXG4gICAgICAgIChoZWFkaXRlbWNvdW50ID09IDApP1xuICAgICAgICAgICAgdHJ1ZTpcbiAgICAgICAgICAgIGZhbHNlXG5cbiAgICBpZiAoKHRyaWdnZXJjZWxsSW5kZXggIT09IHVuZGVmaW5lZCkgJiYgKG9mZnNldGluZGV4ICE9PSB1bmRlZmluZWQpKSB7IC8vJiYgXG4gICAgICAgIGlmICgodHJpZ2dlcmNlbGxJbmRleCA+PSBvZmZzZXRpbmRleCkgJiYgKHRyaWdnZXJjZWxsSW5kZXggPD0gaGlnaGluZGV4KSkge1xuICAgICAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGxQdHIgPSB0cmlnZ2VyY2VsbEluZGV4IC0gb2Zmc2V0aW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsQ29tcG9uZW50ID0gY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdXG4gICAgICAgICAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQpIHsgLy8gb3RoZXJ3aXNlIGhhcyBiZWVuIGFzeW5jaHJvbm91c2x5IGNsZWFyZWRcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlcmNlbGxDb21wb25lbnQsIHtpc1RyaWdnZXJjZWxsOmZhbHNlfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyaWdnZXJjZWxsUHRyID0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCAtIG9mZnNldGluZGV4XG4gICAgY29uc3QgdHJpZ2dlcmNlbGxDb21wb25lbnQgPSBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl1cbiAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQpIHtcblxuICAgICAgICBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlcmNlbGxDb21wb25lbnQsIHtpc1RyaWdnZXJjZWxsOnRydWV9KVxuICAgICAgICBsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSW5kZXggPSB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4XG5cbiAgICB9IGVsc2UgeyAvLyBkZWZlbnNpdmU7IHNob3VsZG4ndCBoYXBwZW5cblxuICAgICAgICBjb25zb2xlLmxvZygnRkFJTFVSRSBUTyBSRUdJU1RFUiBUUklHR0VSQ0VMTDonKVxuICAgICAgICBjb25zb2xlLmxvZygnYXhpc1JlZmVyZW5jZUluZGV4LCB0cmlnZ2VyY2VsbEluZGV4LCBvZmZzZXRpbmRleCwgaGlnaGluZGV4LCBoZWFkaXRlbWNvdW50LCB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4JyxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgdHJpZ2dlcmNlbGxJbmRleCwgb2Zmc2V0aW5kZXgsIGhpZ2hpbmRleCwgaGVhZGl0ZW1jb3VudCwgdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleClcbiAgICAgICAgY29uc29sZS5sb2coJ3RyaWdnZXJjZWxsUHRyLCB0cmlnZ2VyY2VsbENvbXBvbmVudCwgdHJpZ2dlcmNlbGxDb21wb25lbnQ/LnByb3BzLmlzVHJpZ2dlY2VsbCwgY29udGVudGxpc3RcXG4nLCBcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsUHRyLCB0cmlnZ2VyY2VsbENvbXBvbmVudCwgdHJpZ2dlcmNlbGxDb21wb25lbnQ/LnByb3BzLmlzVHJpZ2dlY2VsbCwgXG4gICAgICAgICAgICAgICAgey4uLmNvbnRlbnRsaXN0fSlcblxuICAgIH1cblxuICAgIGNvbnN0IGhlYWRsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoMCxoZWFkaXRlbWNvdW50KVxuICAgIGNvbnN0IHRhaWxsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoaGVhZGl0ZW1jb3VudClcblxuICAgIHJldHVybiBbIGhlYWRsaXN0LCB0YWlsbGlzdCBdXG5cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVBvcnRhbHMgPSAoY2FjaGVIYW5kbGVyLCBkZWxldGVMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgIGNvbnN0IGRsaXN0ID0gZGVsZXRlTGlzdC5tYXAoKGl0ZW0pPT57XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcHMuaW5kZXhcbiAgICAgICAgXG4gICAgfSlcblxuICAgIGNhY2hlSGFuZGxlci5kZWxldGVQb3J0YWwoZGxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBpbnRlcm5hbCwgYWNxdWlyZSBpdGVtIF09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGNyZWF0ZUNlbGxGcmFtZSA9ICh7XG4gICAgaW5kZXgsIFxuICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgIGNhY2hlSGFuZGxlcixcbiAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyxcbiAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxufSkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlSUQgPSBpbnN0YW5jZUlkQ291bnRlclJlZi5jdXJyZW50KytcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICBsYXlvdXQsIFxuICAgICAgICB1c2VQbGFjZWhvbGRlcixcblxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCB7IGxpc3RzaXplIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgIC8vIGdldCBuZXcgb3IgZXhpc3RpbmcgaXRlbUlEXG4gICAgY29uc3QgaXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld09yRXhpc3RpbmdJdGVtSUQoaW5kZXgpXG5cbiAgICByZXR1cm4gPENlbGxGcmFtZSBcbiAgICAgICAga2V5ID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgIGNlbGxNaW5IZWlnaHQgPSB7IGNlbGxNaW5IZWlnaHQgfVxuICAgICAgICBjZWxsTWluV2lkdGggPSB7IGNlbGxNaW5XaWR0aCB9XG4gICAgICAgIGxheW91dCA9IHsgbGF5b3V0IH1cbiAgICAgICAgaW5kZXggPSB7IGluZGV4IH1cbiAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgIGl0ZW1JRCA9IHsgaXRlbUlEIH1cbiAgICAgICAgaW5zdGFuY2VJRCA9IHsgaW5zdGFuY2VJRCB9XG4gICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICBpc1RyaWdnZXJjZWxsID0geyBmYWxzZSB9XG4gICAgICAgIHVzZVBsYWNlaG9sZGVyID0geyB1c2VQbGFjZWhvbGRlciB9XG4gICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgfVxuICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckxpbmVyU3R5bGVzIH1cbiAgICAgICAgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMgfVxuICAgICAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyB9XG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7IHBsYWNlaG9sZGVyTWVzc2FnZXMgfVxuICAgIC8+XG5cbn1cbiJdLCJuYW1lcyI6WyJnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsImJhc2VSb3dMZW5ndGgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJwYWRkaW5nIiwiY3Jvc3Njb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJsaXN0Um93Y291bnQiLCJsaXN0c2l6ZSIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRBeGlzUm93T2Zmc2V0IiwiY2VpbCIsIm1heEF4aXNSb3dPZmZzZXQiLCJtYXgiLCJ0YXJnZXRDcmFkbGVSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQiLCJsaXN0RW5kUm93T2Zmc2V0IiwiZGlmZiIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwibmV3Q3JhZGxlQ29udGVudENvdW50IiwiZW5kUm93UmVtYWluZGVyQ291bnQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJleHBvcnRzIiwiZ2V0U2hpZnRJbnN0cnVjdGlvbiIsIm9yaWVudGF0aW9uIiwidHJpZ2dlcmxpbmVFbnRyaWVzIiwidHJpZ2dlcmxpbmVTcGFuIiwic2Nyb2xsZXJJRCIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidmlld3BvcnRCb3VuZGluZ1JlY3QiLCJ0cmlnZ2VySGlzdG9yeVJlZiIsInRyaWdnZXJEYXRhIiwiaGVhZE9mZnNldCIsInRhaWxPZmZzZXQiLCJzcGFuIiwiZW50cnkiLCJsZW5ndGgiLCJyZWZlcmVuY2VuYW1lIiwidGFyZ2V0IiwiZGF0YXNldCIsInR5cGUiLCJpbnRlcnNlY3Ryb290cG9zIiwidHJ1bmMiLCJyb290Qm91bmRzIiwieSIsIngiLCJib3VuZGluZ3Jvb3Rwb3MiLCJyb290cG9zIiwiZW50cnlwb3MiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJ2aWV3cG9ydFRyaWdnZXJPZmZzZXQiLCJzaGlmdGluc3RydWN0aW9uIiwidHJpZ2dlckhpc3RvcnkiLCJjdXJyZW50IiwicHJldmlvdXNSZWZlcmVuY2VOYW1lIiwidHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIiwiY2FsY1NoaWZ0U3BlY3MiLCJzY3JvbGxQb3MiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJjcmFkbGVDb250ZW50IiwiY3JhZGxlRWxlbWVudHMiLCJnYXAiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwibGF5b3V0IiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiaGVhZEdyaWRFbGVtZW50IiwiaGVhZFJlZiIsInRhaWxHcmlkRWxlbWVudCIsInRhaWxSZWYiLCJjcmFkbGVjb250ZW50bGlzdCIsImNyYWRsZU1vZGVsQ29tcG9uZW50cyIsInRhaWxjb250ZW50bGlzdCIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJ2aWV3cG9ydFJvd2NvdW50IiwicHJldmlvdXNDcmFkbGVSZWZlcmVuY2VJbmRleCIsInByb3BzIiwiaW5kZXgiLCJwcmV2aW91c0NyYWRsZVJvd09mZnNldCIsInByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4IiwicHJldmlvdXNBeGlzUm93T2Zmc2V0IiwibGlzdEVuZHJvd09mZnNldCIsInNwYW5Sb3dQdHIiLCJzcGFuQXhpc1BpeGVsU2hpZnQiLCJpblByb2Nlc3NSb3dQdHIiLCJpc0xpc3RCb3VuZGFyeSIsInRvdGFsUGl4ZWxTaGlmdCIsImZpbmFsVmFyaWFibGVSb3dMZW5ndGgiLCJyZWZlcmVuY2VHcmlkRWxlbWVudCIsImdyaWRSb3dMZW5ndGhzIiwiZ2V0R3JpZFJvd0xlbmd0aHMiLCJyZXZlcnNlIiwiZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zIiwiZ2V0R3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zIiwiZmluZEluZGV4IiwiYWdncmVnYXRlc3BhbiIsImF0Iiwic3BhblJvd1NoaWZ0IiwiYXhpc1JlZmVyZW5jZVJvd1NoaWZ0IiwiYXhpc1BpeGVsU2hpZnQiLCJzY3JvbGxibG9ja0F4aXNPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IiwibmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCIsIm5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCIsIm5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQiLCJoZWFkcm93RGlmZiIsInRhcmdldENyYWRsZUVuZHJvd09mZnNldCIsInRhaWxyb3dkaWZmIiwiY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0IiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzUmVmZXJlbmNlSXRlbVNoaWZ0IiwiaW5jbHVkZXNMYXN0Um93IiwicGFydGlhbHNwYWNlcyIsIml0ZW1zU2hvcnRmYWxsIiwiY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsImdyaWQiLCJyb3dMZW5ndGhzIiwiZWxlbWVudExpc3QiLCJjaGlsZE5vZGVzIiwiZWxlbWVudFB0ciIsImVsZW1lbnQiLCJyb3dsZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInB1c2giLCJyb3dTcGFucyIsImZvckVhY2giLCJ2YWx1ZSIsImdldENlbGxGcmFtZUNvbXBvbmVudExpc3QiLCJjYWNoZUhhbmRsZXIiLCJjcmFkbGVDb250ZW50Q291bnQiLCJjcmFkbGVSZWZlcmVuY2VJbmRleCIsImNvbnRlbnRsaXN0Iiwid29ya2luZ0NvbnRlbnRMaXN0IiwiaW5zdGFuY2VJZENvdW50ZXJSZWYiLCJzdHlsZXMiLCJwbGFjZWhvbGRlck1lc3NhZ2VzIiwibG9jYWxDb250ZW50bGlzdCIsImxhc3RpbmRleG9mZnNldCIsImhlYWRDb250ZW50bGlzdCIsInRhaWxDb250ZW50bGlzdCIsImRlbGV0ZWR0YWlsaXRlbXMiLCJkZWxldGVkaGVhZGl0ZW1zIiwicmVmZXJlbmNlSW5kZXgiLCJjaGFuZ2VDb3VudCIsIm5ld2luZGV4IiwiY3JlYXRlQ2VsbEZyYW1lIiwicGxhY2Vob2xkZXJGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyZnJhbWUiLCJwbGFjZWhvbGRlckxpbmVyU3R5bGVzIiwicGxhY2Vob2xkZXJsaW5lciIsInBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyZXJyb3JmcmFtZSIsInBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyIsInBsYWNlaG9sZGVyZXJyb3JsaW5lciIsInNwbGljZSIsImRlbGV0ZWRJdGVtcyIsImNvbXBvbmVudExpc3QiLCJhbGxvY2F0ZUNvbnRlbnRMaXN0IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwibGF5b3V0SGFuZGxlciIsInRyaWdnZXJjZWxsSW5kZXgiLCJvZmZzZXRpbmRleCIsImhpZ2hpbmRleCIsImhlYWRpdGVtY291bnQiLCJ0YXJnZXRUcmlnZ2VyY2VsbEluZGV4IiwidHJpZ2dlcmNlbGxJc0luVGFpbCIsInVuZGVmaW5lZCIsInRyaWdnZXJjZWxsUHRyIiwidHJpZ2dlcmNlbGxDb21wb25lbnQiLCJyZWFjdF8xIiwiY2xvbmVFbGVtZW50IiwiaXNUcmlnZ2VyY2VsbCIsImNvbnNvbGUiLCJsb2ciLCJpc1RyaWdnZWNlbGwiLCJoZWFkbGlzdCIsInNsaWNlIiwidGFpbGxpc3QiLCJkZWxldGVQb3J0YWxzIiwiZGVsZXRlTGlzdCIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRsaXN0IiwibWFwIiwiaXRlbSIsImRlbGV0ZVBvcnRhbCIsImluc3RhbmNlSUQiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwiZ2V0SXRlbSIsInBsYWNlaG9sZGVyIiwidXNlUGxhY2Vob2xkZXIiLCJpdGVtSUQiLCJnZXROZXdPckV4aXN0aW5nSXRlbUlEIiwiQ2VsbEZyYW1lXzEiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// contenthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module supports the setup, rollover and positioning of content in the Cradle.\n\n    There are three key functions in this module: setCradleContent, updateCradleContent, and\n    adjustScrollblockForVariability.\n\n    There are also a few functions which support synchronization of Cradle content with cache\n    content (see internal and external services below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    down (or right), content is removed from the Cradle tail and added to the Cradle head (thus moving the\n    Cradle axis), while new content is added to the tail. When scrolling up (or left), the reverse occurs.\n\n    adjustScrollblockForVariability reconfigures the scrollblock to accommodate variable sized grid rows.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ "./src/cradle/contentfunctions.tsx");\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, ContentHandler);\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    };\n    // Three main public methods - setCradleContent, updateCradleContent, and adjustScrollblockForVariability\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n        cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n        layoutHandler = cradleHandlers.layoutHandler,\n        serviceHandler = cradleHandlers.serviceHandler,\n        scrollHandler = cradleHandlers.scrollHandler;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages;\n      var crosscount = cradleInternalProperties.crosscount,\n        listsize = cradleInternalProperties.listsize,\n        listRowcount = cradleInternalProperties.listRowcount;\n      var workingRequestAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingRequestAxisReferenceIndex -= workingRequestAxisReferenceIndex % crosscount;\n      // reposition at row boundary\n      if ([\'firstrender\', \'firstrenderfromcache\', \'finishreposition\', \'reconfigure\', \'scrollto\'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingRequestAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content;\n      // ----------------------[ 2. get content requirements ]----------------------\n      var baseRowLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      // note that targetAxisReferenceIndex replaces requestedAxisReferenceIndex here\n      var _ref = (0, contentfunctions_1.getContentListRequirements)({\n          // pixel\n          baseRowLength: baseRowLength,\n          targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n          // index\n          targetAxisReferenceIndex: workingRequestAxisReferenceIndex,\n          // resources\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties\n        }),\n        targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n        targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n        cradleContentCount = _ref.newCradleContentCount,\n        scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset;\n      // reset scrollblock Offset and length\n      var scrollblockElement = viewportElement.firstChild;\n      var baselength = listRowcount * baseRowLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (cradleState == \'pivot\') {\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.left = null;\n        } else {\n          scrollblockElement.style.top = null;\n        }\n      }\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // semantics\n      // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          cradleReferenceIndex: targetCradleReferenceIndex,\n          listStartChangeCount: 0,\n          listEndChangeCount: cradleContentCount,\n          workingContentList: workingContentList,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        }),\n        _ref3 = _slicedToArray(_ref2, 1),\n        newcontentlist = _ref3[0];\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: newcontentlist,\n          axisReferenceIndex: targetAxisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref5 = _slicedToArray(_ref4, 2),\n        headcontentlist = _ref5[0],\n        tailcontentlist = _ref5[1];\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, \'setCradleContent\', cstate);\n      }\n      //  ----------------------[ 4. set CSS ]-----------------------\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset;\n      // avoid bogus call to updateCradleContent\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset);\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current,\n        headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n      if (orientation == \'vertical\') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // orientation = \'horizontal\'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = left + \'px\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element\'s scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler.\n    // typically called for scroll action, but can also be called if the triggerLineCell changes\n    // size with variant layout.\n    this.updateCradleContent = function () {\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a;\n      // handler support\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter.cacheHandler,\n        layoutHandler = _this$cradleParameter.layoutHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        interruptHandler = _this$cradleParameter.interruptHandler,\n        serviceHandler = _this$cradleParameter.serviceHandler;\n      var shiftinstruction = interruptHandler.shiftinstruction,\n        triggerViewportReferencePos = interruptHandler.triggerViewportReferencePos;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n        cache = cradleInheritedProperties.cache,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages,\n        layout = cradleInheritedProperties.layout,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        padding = cradleInheritedProperties.padding,\n        gap = cradleInheritedProperties.gap;\n      var crosscount = cradleInternalProperties.crosscount;\n      var scrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      // cradle scaffold and user cells\n      var cradleElements = layoutHandler.elements;\n      var cradleContent = _this.content,\n        modelcontentlist = cradleContent.cradleModelComponents || [];\n      var oldCradleReferenceIndex = ((_a = modelcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      var _ref6 = (0, contentfunctions_1.calcShiftSpecs)({\n          shiftinstruction: shiftinstruction,\n          triggerViewportReferencePos: triggerViewportReferencePos,\n          scrollPos: scrollPos,\n          scrollblockElement: viewportElement.firstChild,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContent: cradleContent,\n          cradleElements: cradleElements\n        }),\n        cradleItemShift = _ref6.cradleReferenceItemShift,\n        axisReferenceIndex = _ref6.newAxisReferenceIndex,\n        axisItemShift = _ref6.axisReferenceItemShift,\n        cradleContentCount = _ref6.newCradleContentCount,\n        listStartChangeCount = _ref6.listStartChangeCount,\n        listEndChangeCount = _ref6.listEndChangeCount,\n        newAxisViewportPixelOffset = _ref6.newAxisViewportPixelOffset;\n      var axisViewportPixelOffset = newAxisViewportPixelOffset;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var isShift = !(axisItemShift == 0 && cradleItemShift == 0);\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with \'renderupdatedcontent\' state in cradle.tsx, or at \'finishupdateforvariability\'\n      //    for variable content\n      interruptHandler.triggerlinesIntersect.disconnect();\n      // abandon option; nothing to do but reposition\n      if (!isShift) {\n        // can happen first row; oversized last row\n        cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n        _this.applyStyling({\n          layout: layout,\n          orientation: orientation,\n          padding: padding,\n          gap: gap,\n          cellHeight: cellHeight,\n          cellWidth: cellWidth,\n          crosscount: crosscount,\n          axisReferenceIndex: axisReferenceIndex,\n          axisViewportPixelOffset: axisViewportPixelOffset,\n          scrollPos: scrollPos,\n          headcontent: cradleContent.headModelComponents,\n          axisElement: axisElement,\n          headElement: headElement\n        });\n        return;\n      }\n      // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect changed content\n      var updatedContentList,\n        deletedContentItems = [];\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref7 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        });\n        var _ref8 = _slicedToArray(_ref7, 2);\n        updatedContentList = _ref8[0];\n        deletedContentItems = _ref8[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n      if (deletedContentItems.length && cache == \'cradle\') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cradle\', deleteList);\n          };\n        }\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      }\n      // ----------------------------------[ 5. allocate cradle content ]--------------------------\n      var _ref9 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: updatedContentList,\n          axisReferenceIndex: axisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref10 = _slicedToArray(_ref9, 2),\n        headcontent = _ref10[0],\n        tailcontent = _ref10[1];\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, \'updateCradleContent\', cstate);\n      }\n      // -------------------------------[ 6. css changes ]-------------------------\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      if (isShift) cacheHandler.renderPortalLists();\n      _this.applyStyling({\n        layout: layout,\n        orientation: orientation,\n        padding: padding,\n        gap: gap,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        crosscount: crosscount,\n        axisReferenceIndex: axisReferenceIndex,\n        axisViewportPixelOffset: axisViewportPixelOffset,\n        scrollPos: scrollPos,\n        headcontent: headcontent,\n        axisElement: axisElement,\n        headElement: headElement\n      });\n      // load new display data\n      cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n      cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n    };\n    // move the offset of the axis\n    this.applyStyling = function (_ref11) {\n      var layout = _ref11.layout,\n        orientation = _ref11.orientation,\n        padding = _ref11.padding,\n        gap = _ref11.gap,\n        cellHeight = _ref11.cellHeight,\n        cellWidth = _ref11.cellWidth,\n        crosscount = _ref11.crosscount,\n        axisReferenceIndex = _ref11.axisReferenceIndex,\n        axisViewportPixelOffset = _ref11.axisViewportPixelOffset,\n        scrollPos = _ref11.scrollPos,\n        headcontent = _ref11.headcontent,\n        axisElement = _ref11.axisElement,\n        headElement = _ref11.headElement;\n      if (layout == \'variable\') return;\n      // --------------\n      // Safari when zoomed drifts (calc precision one presumes). This is a hack to correct that.\n      var preAxisRows = Math.ceil(axisReferenceIndex / crosscount);\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var testScrollPos = baseCellLength * preAxisRows + padding - axisViewportPixelOffset;\n      var scrollDiff = testScrollPos - scrollPos;\n      if (scrollDiff) {\n        axisViewportPixelOffset += scrollDiff;\n      }\n      // --------------\n      var topPos, leftPos; // available for debug\n      if (orientation == \'vertical\') {\n        topPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = topPos + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // \'horizontal\'\n        leftPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = leftPos + \'px\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ===================[ RECONFIGURE THE SCROLLBLOCK FOR VARIABLE CONTENT ]=======================\n    /*\n        blockScrollPos is the amount the scrollBlock is scrolled to reveal the centre of the Cradle\n            at the edge of the Viewport\n        \n        newAxisScrollblockOffset is the exact offset of blockScrollPos, plus the axisViewportOffset\n        \n        axisViewportOffset is the amount the axis is ahead of the Viewport edge\n        \n        the length of the Scrollblock is shortened by the amount the measured tail length differs from the\n            base tail length\n    \n        Called for variable layout only. All DOM elements should have been rendered at this point\n        sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n        to get closer to natural proportions to minimize janky scroll thumb\n    */\n    this.adjustScrollblockForVariability = function (source) {\n      // ----------------------[ setup base values and references ]------------------------\n      // resources...\n      var cradleParameters = _this.cradleParameters,\n        cradleHandlers = cradleParameters.handlersRef.current,\n        ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var layoutHandler = cradleHandlers.layoutHandler,\n        scrollHandler = cradleHandlers.scrollHandler,\n        interruptHandler = cradleHandlers.interruptHandler;\n      var cradleElements = layoutHandler.elements,\n        cradlePositionData = layoutHandler.cradlePositionData;\n      // element references...\n      var viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild,\n        headGridElement = cradleElements.headRef.current,\n        tailGridElement = cradleElements.tailRef.current,\n        axisElement = cradleElements.axisRef.current;\n      // current configurations...\n      var axisReferenceIndex = cradlePositionData.targetAxisReferenceIndex,\n        axisViewportOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth;\n      var crosscount = cradleInternalProperties.crosscount,\n        listRowcount = cradleInternalProperties.listRowcount;\n      // ------------------------[ precursor calculations ]------------------------\n      // rowcounts and row offsets for positioning\n      // listRowcount taken from internal properties above\n      var headRowCount = Math.ceil(headGridElement.childNodes.length / crosscount),\n        tailRowCount = Math.ceil(tailGridElement.childNodes.length / crosscount);\n      // reference rows - cradle first/last; axis; list end\n      var axisReferenceRow = Math.ceil(axisReferenceIndex / crosscount),\n        cradleReferenceRow = axisReferenceRow - headRowCount,\n        cradleLastRow = axisReferenceRow + (tailRowCount - 1),\n        listLastRow = listRowcount - 1;\n      var preCradleRowCount = cradleReferenceRow,\n        postCradleRowCount = listLastRow - cradleLastRow;\n      // base pixel values\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var measuredTailLength = orientation == \'vertical\' ? tailGridElement.offsetHeight : tailGridElement.offsetWidth;\n      var basePostCradlePixelLength = postCradleRowCount * baseCellLength;\n      var computedPostAxisPixelLength = basePostCradlePixelLength + measuredTailLength;\n      // base figures used for preAxis #s for compatibility with repositioning, which uses base figures\n      var basePreAxisPixelLength = (preCradleRowCount + headRowCount) * baseCellLength + padding;\n      // ------------------------[ layout adjustments ]----------------------\n      interruptHandler.signals.pauseCradleIntersectionObserver = true;\n      var computedScrollblockLength = basePreAxisPixelLength + computedPostAxisPixelLength;\n      var blockScrollPos = basePreAxisPixelLength - axisViewportOffset;\n      var newAxisScrollblockOffset = blockScrollPos + axisViewportOffset; // ie. basePreAxisPixelLength, but semantics\n      if (orientation == \'vertical\') {\n        axisElement.style.top = newAxisScrollblockOffset + \'px\';\n        scrollblockElement.style.height = computedScrollblockLength + \'px\';\n      } else {\n        // \'horizontal\'\n        axisElement.style.left = newAxisScrollblockOffset + \'px\';\n        scrollblockElement.style.width = computedScrollblockLength + \'px\';\n      }\n      // -----------------------[ scrollPos adjustment ]-------------------------\n      if (orientation == \'vertical\') {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n      if (!(0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // adjust blockScrollPos directly - most browsers including Safari desktop\n        cradlePositionData.blockScrollPos = blockScrollPos;\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n        scrollHandler.resetScrollData(blockScrollPos);\n      } else {\n        // for Safari iOS\n        // temporarily adjust scrollblockElement offset; iOSonAfterScroll transfers shift to blockScrollPos\n        // - direct change of scrollTop/ScrollLeft in Safari iOS is ignored by the browser momentum engine\n        var startingScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollDiff = blockScrollPos - startingScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = -scrollDiff + \'px\';\n        } else {\n          scrollblockElement.style.left = -scrollDiff + \'px\';\n        }\n      }\n      // check for gotoIndex or resize overshoot\n      if (source == \'setcradle\' && !postCradleRowCount) {\n        var viewportLength = orientation == \'vertical\' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n        var alignedEndPosDiff = axisViewportOffset + measuredTailLength - viewportLength;\n        if (alignedEndPosDiff < 0) {\n          // fill the bottom of the viewport using scrollBy\n          var scrollByY = orientation == \'vertical\' ? alignedEndPosDiff : 0;\n          var scrollByX = orientation == \'vertical\' ? 0 : alignedEndPosDiff;\n          viewportElement.scrollBy(scrollByX, scrollByY);\n        }\n      }\n    };\n    // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cacheMax = _this$cradleParameter2.cacheMax,\n        MAX_CACHE_OVER_RUN = _this$cradleParameter2.MAX_CACHE_OVER_RUN;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      var modelComponentList = _this.content.cradleModelComponents;\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n        scrollerID = cradleInheritedProperties.scrollerID;\n      if (cache == \'keepload\') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n          serviceHandler = cradleHandlers.serviceHandler;\n        var modelIndexList = _this.getModelIndexList();\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cacheMax\', deleteList);\n          };\n        }\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.renderPortalLists();\n        }\n      }\n    };\n    // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      // const { cacheHandler } = this.cradleParameters.handlersRef.current\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n    this.cradleParameters = cradleParameters;\n  }\n  // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n  _createClass(ContentHandler, [{\n    key: "getModelIndexList",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    }\n    // called from service handler\'s remapIndexes, as last step\n  }, {\n    key: "reconcileCellFrames",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n      function processComponent(component, i, array) {\n        var _component$props = component.props,\n          index = _component$props.index,\n          itemID = _component$props.itemID;\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n          if (newItemID != itemID) {\n            // defensive; shouldn\'t happen\n            array[i] = react_1["default"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n      cradleModelComponents.forEach(processComponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports moveIndex and insertRemoveIndex\n  }, {\n    key: "changeCradleItemIDs",\n    value: function changeCradleItemIDs(changeList) {\n      if (changeList.length == 0) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = changeList.indexOf(index);\n        if (ptr != -1) {\n          var itemID = indexToItemIDMap.get(index);\n          array[i] = react_1["default"].cloneElement(component, {\n            itemID: itemID\n          });\n        }\n      }\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports insertRemoveIndex\n  }, {\n    key: "createNewItemIDs",\n    value: function createNewItemIDs(newList) {\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = newList.indexOf(index);\n        if (ptr != -1) {\n          var newItemID = cacheHandler.getNewItemID();\n          array[i] = react_1["default"].cloneElement(component, {\n            itemID: newItemID\n          });\n        }\n      }\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n  }]);\n  return ContentHandler;\n}();\nexports["default"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGtCQUFLLENBQUNDLFlBQVksQ0FBQ1QsU0FBUyxFQUFFO1lBQUNHLE1BQU0sRUFBQ0M7VUFBUyxDQUFDLENBQUM7O01BSXBFO01BRUF2SyxxQkFBcUIsQ0FBQzZLLE9BQU8sQ0FBQ0csZ0JBQWdCLENBQUM7TUFFL0MsSUFBSSxDQUFDdkksT0FBTyxDQUFDeEMsbUJBQW1CLEdBQUdELHFCQUFxQixDQUFDOEssS0FBSyxDQUFDLENBQUMsRUFBQyxJQUFJLENBQUNySSxPQUFPLENBQUN4QyxtQkFBbUIsQ0FBQzhFLE1BQU0sQ0FBQztNQUN6RyxJQUFJLENBQUN0QyxPQUFPLENBQUN2QyxtQkFBbUIsR0FBR0YscUJBQXFCLENBQUM4SyxLQUFLLENBQUMsSUFBSSxDQUFDckksT0FBTyxDQUFDeEMsbUJBQW1CLENBQUM4RSxNQUFNLENBQUM7SUFFM0c7RUFBQztFQUFBO0FBQUE7QUE5M0JMcUcsa0JBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvY29udGVudGhhbmRsZXIudHN4P2E4OWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29udGVudGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBzZXR1cCwgcm9sbG92ZXIgYW5kIHBvc2l0aW9uaW5nIG9mIGNvbnRlbnQgaW4gdGhlIENyYWRsZS4gXG5cbiAgICBUaGVyZSBhcmUgdGhyZWUga2V5IGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZTogc2V0Q3JhZGxlQ29udGVudCwgdXBkYXRlQ3JhZGxlQ29udGVudCwgYW5kXG4gICAgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eS5cblxuICAgIFRoZXJlIGFyZSBhbHNvIGEgZmV3IGZ1bmN0aW9ucyB3aGljaCBzdXBwb3J0IHN5bmNocm9uaXphdGlvbiBvZiBDcmFkbGUgY29udGVudCB3aXRoIGNhY2hlIFxuICAgIGNvbnRlbnQgKHNlZSBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgc2VydmljZXMgYmVsb3cpLlxuXG4gICAgc2V0Q3JhZGxlQ29udGVudCBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSBDcmFkbGUgKGluIHRoZSBzdGF0ZSBtYW5hZ2VyKSwgYW5kIGluc3RhbnRpYXRlcyBuZXcgQ3JhZGxlXG4gICAgY29udGVudCBpbiByZXNwb25zZSB0byB0aGUgc2Nyb2xsZXIgc2V0dXAsIG9yIGNoYW5nZXMgdG8gaXRzIGNvbmZpZ3VyYXRpb24uIHNldENyYWRsZUNvbnRlbnRcbiAgICBjcmVhdGVzIGEgbGlzdCBvZiBDcmFkbGUgY29udGVudCBDZWxsRnJhbWVzLCBhbmQgYWxsb2NhdGVzIHRob3NlIHRvIHRoZSB0d28gQ3JhZGxlIGdyaWRzLiBUaGlzIFxuICAgIHByb2Nlc3Mgb2NjdXJzIGluIHJlc3BvbnNlIHRvIG1hbnkgc3RhdGUgY2hhbmdlcywgc3VjaCBhcyBmaW5pc2hyZXBvc2l0aW9uLCBwaXZvdCwgYSBob3N0IHNjcm9sbHRvXG4gICAgcmVxdWVzdCwgYW5kIG1vcmUuXG5cbiAgICB1cGRhdGVDcmFkbGVDb250ZW50IHJvbGxzIG92ZXIgdGhlIENyYWRsZSBjb250ZW50IGluIHJlc3BvbnNlIHRvIHVzZXIgc2Nyb2xsaW5nLiBXaGVuIHNjcm9sbGluZyBcbiAgICBkb3duIChvciByaWdodCksIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBDcmFkbGUgdGFpbCBhbmQgYWRkZWQgdG8gdGhlIENyYWRsZSBoZWFkICh0aHVzIG1vdmluZyB0aGUgXG4gICAgQ3JhZGxlIGF4aXMpLCB3aGlsZSBuZXcgY29udGVudCBpcyBhZGRlZCB0byB0aGUgdGFpbC4gV2hlbiBzY3JvbGxpbmcgdXAgKG9yIGxlZnQpLCB0aGUgcmV2ZXJzZSBvY2N1cnMuXG5cbiAgICBhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IHJlY29uZmlndXJlcyB0aGUgc2Nyb2xsYmxvY2sgdG8gYWNjb21tb2RhdGUgdmFyaWFibGUgc2l6ZWQgZ3JpZCByb3dzLlxuXG4gICAgVGhlIENyYWRsZSAodGhyb3VnaCB0aGUgY29udGVudGZ1bmN0aW9ucyBtb2R1bGUpIGRlbGVnYXRlcyBmZXRjaGluZyBjb250ZW50IGl0ZW1zIHRvIHRoZSBDZWxsRnJhbWUuXG5cbiAgICBUaGlzIG1vZHVsZSBpcyBzdXBwb3J0ZWQgcHJpbWFyaWx5IGJ5IHRoZSBjb250ZW50ZnVuY3Rpb25zIG1vZHVsZS5cblxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBcbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyxcbiAgICAvLyBnZXRTaGlmdEluc3RydWN0aW9uLFxuICAgIGNhbGNTaGlmdFNwZWNzLFxuICAgIGFsbG9jYXRlQ29udGVudExpc3QsXG4gICAgZGVsZXRlUG9ydGFscyxcbiAgICBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0LCBcblxufSBmcm9tICcuL2NvbnRlbnRmdW5jdGlvbnMnXG5cbmltcG9ydCB7IGlzU2FmYXJpSU9TIH0gZnJvbSAnLi4vSW5maW5pdGVHcmlkU2Nyb2xsZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRIYW5kbGVyIHtcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgIH1cblxuICAgcHVibGljIGNvbnRlbnQgPSB7XG5cbiAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIGhlYWRNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICB0YWlsTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgLy8gdGhlIGZvbGxvd2luZyB0d28gb25seSB1c2VkIGluIGNyYWRsZSBmb3IgcmVuZGVyXG4gICAgICBoZWFkRGlzcGxheUNvbXBvbmVudHM6IFtdLFxuICAgICAgdGFpbERpc3BsYXlDb21wb25lbnRzOiBbXSxcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHJpdmF0ZSBpbnN0YW5jZUlkQ291bnRlclJlZiA9IHtcblxuICAgICAgIGN1cnJlbnQ6MFxuXG4gICAgfVxuICAgIC8vIFRocmVlIG1haW4gcHVibGljIG1ldGhvZHMgLSBzZXRDcmFkbGVDb250ZW50LCB1cGRhdGVDcmFkbGVDb250ZW50LCBhbmQgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFVCBDT05URU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHJlc2V0IHRoZSBjcmFkbGUgd2l0aCBuZXcgY29udGVudCwgaW5jbHVkaW5nIGFsbG9jYXRpb24gYmV0d2VlbiBoZWFkIGFuZCB0YWlsIHBhcnRzIG9mIHRoZSBjcmFkbGVcbiAgICAvLyAtIGNhbGxlZCBvbmx5IGZyb20gdGhlIENyYWRsZSBzdGF0ZSBoYW5kbGVyXG5cbiAgICBwdWJsaWMgc2V0Q3JhZGxlQ29udGVudCA9ICggY3JhZGxlU3RhdGUgKSA9PiB7IC8vIGNyYWRsZVN0YXRlIGluZmx1ZW5jZXMgc29tZSBiZWhhdmlvdXJcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpc1xuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVIYW5kbGVycyA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICAgICAgLy8gaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG5cbiAgICAgICAgfSA9IGNyYWRsZUhhbmRsZXJzXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXggPSBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG5cbiAgICAgICAgbGV0IHsgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAvLyBjYWNoZSxcbiAgICAgICAgICAgIC8vIHNjcm9sbGVySUQsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICAvLyBsYXlvdXQsXG4gICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHtjcm9zc2NvdW50LCBsaXN0c2l6ZSwgbGlzdFJvd2NvdW50fSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGxldCB3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG4gICAgICAgIHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4IC09ICh3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnQpXG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBhdCByb3cgYm91bmRhcnlcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcicsIFxuICAgICAgICAgICAgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJyxcbiAgICAgICAgICAgICdmaW5pc2hyZXBvc2l0aW9uJywgXG4gICAgICAgICAgICAncmVjb25maWd1cmUnLCBcbiAgICAgICAgICAgICdzY3JvbGx0bycsIFxuICAgICAgICBdLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgICh3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKT9cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzpcbiAgICAgICAgICAgICAgICAgICAgZ2FwIC8vIGRlZmF1bHRcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NvbnRlbnRMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGdldCBjb250ZW50IHJlcXVpcmVtZW50cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGJhc2VSb3dMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggcmVwbGFjZXMgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGhlcmVcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgICAgICAvLyBjb3VudHNcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudDpjcmFkbGVDb250ZW50Q291bnQsIFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgc2Nyb2xsUG9zIGJ5IHBpeGVsc1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0OnNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICB9ID0gZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMoe1xuXG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxcbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6d29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyByZXNldCBzY3JvbGxibG9jayBPZmZzZXQgYW5kIGxlbmd0aFxuICAgICAgICBjb25zdCBzY3JvbGxibG9ja0VsZW1lbnQgPSB2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZFxuXG4gICAgICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdFJvd2NvdW50ICogYmFzZVJvd0xlbmd0aCkgLSBnYXAgLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncGl2b3QnKSB7XG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmhlaWdodCA9IGJhc2VsZW5ndGggKyAncHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGJhc2VsZW5ndGggKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IC8vIHNlbWFudGljc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIGdldCBhbmQgY29uZmlnIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIC8vIHJldHVybnMgY29udGVudCBjb25zdHJhaW5lZCBieSBjcmFkbGVSb3djb3VudFxuICAgICAgICBjb25zdCBbbmV3Y29udGVudGxpc3RdLyosZGVsZXRlZGl0ZW1zXSovID0gZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCh7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlciwgICAgICAgICAgICBcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleDp0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50OjAsXG4gICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQ6Y3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0LFxuICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWY6dGhpcy5pbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBbaGVhZGNvbnRlbnRsaXN0LCB0YWlsY29udGVudGxpc3RdID0gYWxsb2NhdGVDb250ZW50TGlzdCh7XG5cbiAgICAgICAgICAgIGNvbnRlbnRsaXN0Om5ld2NvbnRlbnRsaXN0LFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4OnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgXG4gICAgICAgIH0pXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSBuZXdjb250ZW50bGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmIChzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjaykge1xuXG4gICAgICAgICAgICBjb25zdCBjc3RhdGUgPSBjcmFkbGVTdGF0ZVxuXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjayhcblxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsJ3NldENyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDQuIHNldCBDU1MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0IFxuICAgICAgICAvLyBhdm9pZCBib2d1cyBjYWxsIHRvIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgc2Nyb2xsSGFuZGxlci5yZXNldFNjcm9sbERhdGEoc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0KSBcblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID1cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyBcblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGhlYWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wID0gYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50bGlzdC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7Z2FwfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBweCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudGxpc3QubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7Z2FwfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgOlxuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4IDBweCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PVsgVVBEQVRFIENPTlRFTlQgdGhyb3VnaCBzY3JvbGwgXT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdXBkYXRlQ3JhZGxlQ29udGVudCBkb2VzIG5vdCB0b3VjaCB0aGUgdmlld3BvcnQgZWxlbWVudCdzIHNjcm9sbCBwb3NpdGlvbiBmb3IgdGhlIHNjcm9sbGJsb2NrXG4gICAgLy8gaW5zdGVhZCBpdCByZWNvbmZpZ3VyZXMgZWxlbWVudHMgd2l0aGluIHRoZSBjcmFkbGUuIEl0IGlzIGNhbGxlZCBzb2xlbHkgZnJvbVxuICAgIC8vIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrIG9mIGludGVycnVwdEhhbmRsZXIuXG4gICAgLy8gdHlwaWNhbGx5IGNhbGxlZCBmb3Igc2Nyb2xsIGFjdGlvbiwgYnV0IGNhbiBhbHNvIGJlIGNhbGxlZCBpZiB0aGUgdHJpZ2dlckxpbmVDZWxsIGNoYW5nZXNcbiAgICAvLyBzaXplIHdpdGggdmFyaWFudCBsYXlvdXQuXG5cbiAgICBwdWJsaWMgdXBkYXRlQ3JhZGxlQ29udGVudCA9ICgpID0+IHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaGFuZGxlciBzdXBwb3J0XG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsIFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgICAgIFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7c2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zfSA9IGludGVycnVwdEhhbmRsZXJcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgbGF5b3V0LCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHBhZGRpbmcsIGdhcFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgLy8gbGlzdHNpemUsXG4gICAgICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCBzY3JvbGxQb3MgPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgLy8gY3JhZGxlIHNjYWZmb2xkIGFuZCB1c2VyIGNlbGxzXG4gICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gbGF5b3V0SGFuZGxlci5lbGVtZW50c1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBtb2RlbGNvbnRlbnRsaXN0ID0gY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgfHwgW11cblxuICAgICAgICBjb25zdCBvbGRDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChtb2RlbGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAzLiBDYWxjdWxhdGUgc2hpZnRzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY3JhZGxlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgLy8gbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQ6Y3JhZGxlSXRlbVNoaWZ0LCBcbiAgICAgICAgICAgIG5ld0F4aXNSZWZlcmVuY2VJbmRleDpheGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdDpheGlzSXRlbVNoaWZ0LCBcblxuICAgICAgICAgICAgLy8gY291bnRzXG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQ6Y3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4gICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG5cbiAgICAgICAgICAgIC8vIHBpeGVsc1xuICAgICAgICAgICAgbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIFxuXG4gICAgICAgIH0gPSBjYWxjU2hpZnRTcGVjcyh7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MsXG4gICAgICAgICAgICBzY3JvbGxQb3MsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQ6dmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGQsXG5cbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50LFxuICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMsXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICBjb25zdCBpc1NoaWZ0ID0gISgoYXhpc0l0ZW1TaGlmdCA9PSAwKSAmJiAoY3JhZGxlSXRlbVNoaWZ0ID09IDApKVxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgd2lsbCBiZSBtb3ZlZCwgc28gZGlzY29ubmVjdCB0aGVtIGZyb20gdGhlaXIgb2JzZXJ2ZXIuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4LCBvciBhdCAnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknXG4gICAgICAgIC8vICAgIGZvciB2YXJpYWJsZSBjb250ZW50XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIC8vIGFiYW5kb24gb3B0aW9uOyBub3RoaW5nIHRvIGRvIGJ1dCByZXBvc2l0aW9uXG4gICAgICAgIGlmICghaXNTaGlmdCkgeyAvLyBjYW4gaGFwcGVuIGZpcnN0IHJvdzsgb3ZlcnNpemVkIGxhc3Qgcm93XG4gICAgXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxpbmcoe1xuICAgICAgICAgICAgICAgIGxheW91dCwgb3JpZW50YXRpb24sIHBhZGRpbmcsIGdhcCwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBzY3JvbGxQb3MsIFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50OmNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudCwgaGVhZEVsZW1lbnRcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiByZWNvbmZpZ3VyZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb2xsZWN0IGNoYW5nZWQgY29udGVudFxuICAgICAgICBsZXQgdXBkYXRlZENvbnRlbnRMaXN0LCBkZWxldGVkQ29udGVudEl0ZW1zID0gW11cblxuICAgICAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgfHwgbGlzdEVuZENoYW5nZUNvdW50KSB7IC8vIGlmIGVpdGhlciBpcyBub24tMCB0aGVuIG1vZGlmeSBjb250ZW50XG5cbiAgICAgICAgICAgIFt1cGRhdGVkQ29udGVudExpc3QsZGVsZXRlZENvbnRlbnRJdGVtc10gPSBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0KHtcbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdDptb2RlbGNvbnRlbnRsaXN0LFxuICAgICAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleDpvbGRDcmFkbGVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZjp0aGlzLmluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29udGVudExpc3QgPSBtb2RlbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxldGVkQ29udGVudEl0ZW1zLmxlbmd0aCAmJiAoY2FjaGUgPT0gJ2NyYWRsZScpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZVBvcnRhbHMoY2FjaGVIYW5kbGVyLCBkZWxldGVkQ29udGVudEl0ZW1zLCBkTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA1LiBhbGxvY2F0ZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBbaGVhZGNvbnRlbnQsIHRhaWxjb250ZW50XSA9IGFsbG9jYXRlQ29udGVudExpc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudGxpc3Q6dXBkYXRlZENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSB1cGRhdGVkQ29udGVudExpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gaGVhZGNvbnRlbnRcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRcblxuICAgICAgICBpZiAoc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spIHtcblxuICAgICAgICAgICAgY29uc3QgY3N0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsJ3VwZGF0ZUNyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNi4gY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKGlzU2hpZnQpIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgdGhpcy5hcHBseVN0eWxpbmcoe1xuICAgICAgICAgICAgbGF5b3V0LCBvcmllbnRhdGlvbiwgcGFkZGluZywgZ2FwLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBzY3JvbGxQb3MsIFxuICAgICAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgICAgICBheGlzRWxlbWVudCwgaGVhZEVsZW1lbnRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBsb2FkIG5ldyBkaXNwbGF5IGRhdGFcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgIH1cblxuICAgIC8vIG1vdmUgdGhlIG9mZnNldCBvZiB0aGUgYXhpc1xuICAgIHByaXZhdGUgYXBwbHlTdHlsaW5nID0gKHtcbiAgICAgICAgbGF5b3V0LCBvcmllbnRhdGlvbiwgcGFkZGluZywgZ2FwLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIFxuICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgc2Nyb2xsUG9zLCBcbiAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgIGF4aXNFbGVtZW50LCBoZWFkRWxlbWVudFxuICAgIH0pID0+IHtcbiAgICAgICAgXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgcmV0dXJuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2FmYXJpIHdoZW4gem9vbWVkIGRyaWZ0cyAoY2FsYyBwcmVjaXNpb24gb25lIHByZXN1bWVzKS4gVGhpcyBpcyBhIGhhY2sgdG8gY29ycmVjdCB0aGF0LlxuICAgICAgICBjb25zdCBwcmVBeGlzUm93cyA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcbiAgICAgICAgY29uc3QgYmFzZUNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IHRlc3RTY3JvbGxQb3MgPSAoYmFzZUNlbGxMZW5ndGggKiBwcmVBeGlzUm93cykgKyBwYWRkaW5nIC0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IHRlc3RTY3JvbGxQb3MgLSBzY3JvbGxQb3NcblxuICAgICAgICBpZiAoc2Nyb2xsRGlmZikge1xuICAgICAgICAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKz0gc2Nyb2xsRGlmZlxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHRvcFBvcywgbGVmdFBvcyAvLyBhdmFpbGFibGUgZm9yIGRlYnVnXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHRvcFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9IGVsc2UgeyAvLyAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgbGVmdFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRQb3MgKyAncHgnXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJFIFRIRSBTQ1JPTExCTE9DSyBGT1IgVkFSSUFCTEUgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuLyogIFxuICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHRoZSBhbW91bnQgdGhlIHNjcm9sbEJsb2NrIGlzIHNjcm9sbGVkIHRvIHJldmVhbCB0aGUgY2VudHJlIG9mIHRoZSBDcmFkbGVcbiAgICAgICAgYXQgdGhlIGVkZ2Ugb2YgdGhlIFZpZXdwb3J0XG4gICAgXG4gICAgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0IGlzIHRoZSBleGFjdCBvZmZzZXQgb2YgYmxvY2tTY3JvbGxQb3MsIHBsdXMgdGhlIGF4aXNWaWV3cG9ydE9mZnNldFxuICAgIFxuICAgIGF4aXNWaWV3cG9ydE9mZnNldCBpcyB0aGUgYW1vdW50IHRoZSBheGlzIGlzIGFoZWFkIG9mIHRoZSBWaWV3cG9ydCBlZGdlXG4gICAgXG4gICAgdGhlIGxlbmd0aCBvZiB0aGUgU2Nyb2xsYmxvY2sgaXMgc2hvcnRlbmVkIGJ5IHRoZSBhbW91bnQgdGhlIG1lYXN1cmVkIHRhaWwgbGVuZ3RoIGRpZmZlcnMgZnJvbSB0aGUgXG4gICAgICAgIGJhc2UgdGFpbCBsZW5ndGhcblxuICAgIENhbGxlZCBmb3IgdmFyaWFibGUgbGF5b3V0IG9ubHkuIEFsbCBET00gZWxlbWVudHMgc2hvdWxkIGhhdmUgYmVlbiByZW5kZXJlZCBhdCB0aGlzIHBvaW50XG4gICAgc2V0cyBDU1M6IHNjcm9sbGJsb2NrRWxlbWVudCB0b3AgYW5kIGhlaWdodCAob3IgbGVmdCBhbmQgd2lkdGgpLCBhbmQgYXhpc0VsZW1lbnQgdG9wIChvciBsZWZ0KVxuICAgIHRvIGdldCBjbG9zZXIgdG8gbmF0dXJhbCBwcm9wb3J0aW9ucyB0byBtaW5pbWl6ZSBqYW5reSBzY3JvbGwgdGh1bWJcbiovXG5cbiAgICBwdWJsaWMgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSA9IChzb3VyY2UpID0+IHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBiYXNlIHZhbHVlcyBhbmQgcmVmZXJlbmNlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmVzb3VyY2VzLi4uXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpcyxcbiAgICAgICAgICAgIGNyYWRsZUhhbmRsZXJzID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciwgc2Nyb2xsSGFuZGxlciwgaW50ZXJydXB0SGFuZGxlciB9ID0gY3JhZGxlSGFuZGxlcnNcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBlbGVtZW50czogY3JhZGxlRWxlbWVudHMsIFxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhIFxuXG4gICAgICAgIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgLy8gZWxlbWVudCByZWZlcmVuY2VzLi4uXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGN1cnJlbnQgY29uZmlndXJhdGlvbnMuLi5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OiBheGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDogYXhpc1ZpZXdwb3J0T2Zmc2V0LFxuICAgICAgICAgICAgLy8gYmxvY2tTY3JvbGxQb3M6Zm9yd2FyZGVkQmxvY2tTY3JvbGxQb3MsIFxuXG4gICAgICAgIH0gPSBjcmFkbGVQb3NpdGlvbkRhdGFcblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG5cbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCBcblxuICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcmVjdXJzb3IgY2FsY3VsYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByb3djb3VudHMgYW5kIHJvdyBvZmZzZXRzIGZvciBwb3NpdGlvbmluZ1xuICAgICAgICAvLyBsaXN0Um93Y291bnQgdGFrZW4gZnJvbSBpbnRlcm5hbCBwcm9wZXJ0aWVzIGFib3ZlXG4gICAgICAgIGNvbnN0IGhlYWRSb3dDb3VudCA9IE1hdGguY2VpbChoZWFkR3JpZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgvY3Jvc3Njb3VudCksXG4gICAgICAgICAgICB0YWlsUm93Q291bnQgPSBNYXRoLmNlaWwodGFpbEdyaWRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoL2Nyb3NzY291bnQpXG5cbiAgICAgICAgLy8gcmVmZXJlbmNlIHJvd3MgLSBjcmFkbGUgZmlyc3QvbGFzdDsgYXhpczsgbGlzdCBlbmRcbiAgICAgICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvdyA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudCksXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3cgPSBheGlzUmVmZXJlbmNlUm93IC0gaGVhZFJvd0NvdW50LFxuICAgICAgICAgICAgY3JhZGxlTGFzdFJvdyA9IGF4aXNSZWZlcmVuY2VSb3cgKyAodGFpbFJvd0NvdW50IC0gMSksXG4gICAgICAgICAgICBsaXN0TGFzdFJvdyA9IGxpc3RSb3djb3VudCAtIDFcblxuICAgICAgICBjb25zdCBwcmVDcmFkbGVSb3dDb3VudCA9IGNyYWRsZVJlZmVyZW5jZVJvdyxcbiAgICAgICAgICAgIHBvc3RDcmFkbGVSb3dDb3VudCA9IGxpc3RMYXN0Um93IC0gY3JhZGxlTGFzdFJvd1xuXG4gICAgICAgIC8vIGJhc2UgcGl4ZWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IGJhc2VDZWxsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoXG4gICAgICAgICAgICApICsgZ2FwXG5cbiAgICAgICAgY29uc3QgbWVhc3VyZWRUYWlsTGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdGFpbEdyaWRFbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQub2Zmc2V0V2lkdGhcblxuICAgICAgICBjb25zdCBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoID0gcG9zdENyYWRsZVJvd0NvdW50ICogYmFzZUNlbGxMZW5ndGhcblxuICAgICAgICBjb25zdCBjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGggPSBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoICsgbWVhc3VyZWRUYWlsTGVuZ3RoXG5cbiAgICAgICAgLy8gYmFzZSBmaWd1cmVzIHVzZWQgZm9yIHByZUF4aXMgI3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCByZXBvc2l0aW9uaW5nLCB3aGljaCB1c2VzIGJhc2UgZmlndXJlc1xuICAgICAgICBjb25zdCBiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoID0gKChwcmVDcmFkbGVSb3dDb3VudCArIGhlYWRSb3dDb3VudCkgKiBiYXNlQ2VsbExlbmd0aCkgKyBwYWRkaW5nXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBsYXlvdXQgYWRqdXN0bWVudHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWVcblxuICAgICAgICBjb25zdCBjb21wdXRlZFNjcm9sbGJsb2NrTGVuZ3RoID0gYmFzZVByZUF4aXNQaXhlbExlbmd0aCArIGNvbXB1dGVkUG9zdEF4aXNQaXhlbExlbmd0aFxuICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9IGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGggLSBheGlzVmlld3BvcnRPZmZzZXRcbiAgICAgICAgY29uc3QgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ID0gYmxvY2tTY3JvbGxQb3MgKyBheGlzVmlld3BvcnRPZmZzZXQgLy8gaWUuIGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgsIGJ1dCBzZW1hbnRpY3NcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29tcHV0ZWRTY3JvbGxibG9ja0xlbmd0aCkgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU2Nyb2xsYmxvY2tMZW5ndGggKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgc2Nyb2xsUG9zIGFkanVzdG1lbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRSb3dDb3VudD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRSb3dDb3VudD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke2dhcH1weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAwcHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1NhZmFyaUlPUygpKSB7IC8vIGFkanVzdCBibG9ja1Njcm9sbFBvcyBkaXJlY3RseSAtIG1vc3QgYnJvd3NlcnMgaW5jbHVkaW5nIFNhZmFyaSBkZXNrdG9wXG5cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKGJsb2NrU2Nyb2xsUG9zKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBTYWZhcmkgaU9TXG5cbiAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IGFkanVzdCBzY3JvbGxibG9ja0VsZW1lbnQgb2Zmc2V0OyBpT1NvbkFmdGVyU2Nyb2xsIHRyYW5zZmVycyBzaGlmdCB0byBibG9ja1Njcm9sbFBvc1xuICAgICAgICAgICAgLy8gLSBkaXJlY3QgY2hhbmdlIG9mIHNjcm9sbFRvcC9TY3JvbGxMZWZ0IGluIFNhZmFyaSBpT1MgaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlciBtb21lbnR1bSBlbmdpbmVcblxuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdTY3JvbGxQb3MgPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBibG9ja1Njcm9sbFBvcyAtIHN0YXJ0aW5nU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gLXNjcm9sbERpZmYgKyAncHgnXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxEaWZmICsgJ3B4J1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBnb3RvSW5kZXggb3IgcmVzaXplIG92ZXJzaG9vdFxuICAgICAgICBpZiAoKHNvdXJjZSA9PSAnc2V0Y3JhZGxlJykgJiYgIXBvc3RDcmFkbGVSb3dDb3VudCkgeyBcblxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aFxuXG4gICAgICAgICAgICBjb25zdCBhbGlnbmVkRW5kUG9zRGlmZiA9IFxuICAgICAgICAgICAgICAgIGF4aXNWaWV3cG9ydE9mZnNldCArIG1lYXN1cmVkVGFpbExlbmd0aCAtIHZpZXdwb3J0TGVuZ3RoXG5cbiAgICAgICAgICAgIGlmIChhbGlnbmVkRW5kUG9zRGlmZiA8IDApIHsgLy8gZmlsbCB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydCB1c2luZyBzY3JvbGxCeVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnlZID0gXG4gICAgICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduZWRFbmRQb3NEaWZmOlxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnlYID1cbiAgICAgICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduZWRFbmRQb3NEaWZmXG5cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsQnkoc2Nyb2xsQnlYLCBzY3JvbGxCeVkpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFsgSU5URVJOQUwgQ09OVEVOVCBNQU5BR0VNRU5UIFNFUlZJQ0VTIF09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyA9ICgpID0+IHsgXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZU1heCwgTUFYX0NBQ0hFX09WRVJfUlVOIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgbW9kZWxDb21wb25lbnRMaXN0ID0gdGhpcy5jb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50c1xuIFxuICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLmd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nKGNhY2hlTWF4LCBtb2RlbENvbXBvbmVudExpc3QubGVuZ3RoLCBNQVhfQ0FDSEVfT1ZFUl9SVU4gKSkge1xuXG4gICAgICAgICAgICB0aGlzLnBhcmVDYWNoZVRvTWF4KClcblxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBwYXJlQ2FjaGVUb01heCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIHNjcm9sbGVySUQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcbiAgICAgICAgXG4gICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUhhbmRsZXJzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gY3JhZGxlSGFuZGxlcnNcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSB0aGlzLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIEVYVEVSTkFMIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN1cHBvcnRzIGNsZWFyQ2FjaGVcbiAgICBwdWJsaWMgY2xlYXJDcmFkbGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuICAgICAgICAvLyBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2VIYW5kbGVyIGdldENyYWRsZUluZGV4TWFwXG4gICAgLy8gYWxzbyBzdXBwb3J0cyBwYXJlQ2FjaGVUb01heCwgbWF0Y2hDYWNoZVRvQ3JhZGxlXG4gICAgcHVibGljIGdldE1vZGVsSW5kZXhMaXN0KCkge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBpZiAoIWNyYWRsZU1vZGVsQ29tcG9uZW50cykge1xuXG4gICAgICAgICAgICByZXR1cm4gW10gXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5tYXAoKGl0ZW0pPT5pdGVtLnByb3BzLmluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2UgaGFuZGxlcidzIHJlbWFwSW5kZXhlcywgYXMgbGFzdCBzdGVwXG4gICAgcHVibGljIHJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleGVzTGlzdCkge1xuXG4gICAgICAgIGlmICghbW9kaWZpZWRJbmRleGVzTGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzXG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoY29tcG9uZW50LCBpLCBhcnJheSApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIGl0ZW1JRCB9ID0gY29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRleGVzTGlzdC5pbmNsdWRlcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IFxuICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCk/XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtSUQgIT0gaXRlbUlEKSB7IC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGhhcHBlblxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc0NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgbW92ZUluZGV4IGFuZCBpbnNlcnRSZW1vdmVJbmRleFxuICAgIHB1YmxpYyBjaGFuZ2VDcmFkbGVJdGVtSURzKGNoYW5nZUxpc3QpIHtcblxuICAgICAgICBpZiAoY2hhbmdlTGlzdC5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc2NvbXBvbmVudChjb21wb25lbnQsIGksIGFycmF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LnByb3BzLmluZGV4XG5cbiAgICAgICAgICAgIGNvbnN0IHB0ciA9IGNoYW5nZUxpc3QuaW5kZXhPZihpbmRleClcblxuICAgICAgICAgICAgaWYgKHB0ciAhPSAtMSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG5cbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUR9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBpbnNlcnRSZW1vdmVJbmRleFxuICAgIHB1YmxpYyBjcmVhdGVOZXdJdGVtSURzKG5ld0xpc3QpIHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnQoY29tcG9uZW50LCBpLCBhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuICAgICAgICAgICAgY29uc3QgcHRyID0gbmV3TGlzdC5pbmRleE9mKGluZGV4KVxuXG4gICAgICAgICAgICBpZiAocHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtSUQgPSBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUQ6bmV3SXRlbUlEfSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbn0iXSwibmFtZXMiOlsiQ29udGVudEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJjdXJyZW50IiwiY3JhZGxlU3RhdGUiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSGFuZGxlcnMiLCJoYW5kbGVyc1JlZiIsImNhY2hlSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJ2aWV3cG9ydEVsZW1lbnQiLCJlbGVtZW50UmVmIiwicmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJvcmllbnRhdGlvbiIsImdhcCIsInBhZGRpbmciLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwic3R5bGVzIiwicGxhY2Vob2xkZXJNZXNzYWdlcyIsImNyb3NzY291bnQiLCJsaXN0c2l6ZSIsImxpc3RSb3djb3VudCIsIndvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4IiwiTWF0aCIsIm1pbiIsImluY2x1ZGVzIiwid29ya2luZ0NvbnRlbnRMaXN0IiwiY3JhZGxlQ29udGVudCIsImNvbnRlbnQiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVDb250ZW50Q291bnQiLCJuZXdDcmFkbGVDb250ZW50Q291bnQiLCJzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiYmFzZWxlbmd0aCIsInN0eWxlIiwibGVmdCIsInRvcCIsImhlaWdodCIsIndpZHRoIiwiYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VJbmRleCIsImxpc3RTdGFydENoYW5nZUNvdW50IiwibGlzdEVuZENoYW5nZUNvdW50IiwiaW5zdGFuY2VJZENvdW50ZXJSZWYiLCJuZXdjb250ZW50bGlzdCIsImNvbnRlbnRsaXN0IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwiaGVhZGNvbnRlbnRsaXN0IiwidGFpbGNvbnRlbnRsaXN0IiwiY2FsbGJhY2tzIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsImNzdGF0ZSIsImJsb2NrU2Nyb2xsUG9zIiwicmVzZXRTY3JvbGxEYXRhIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJoZWFkRWxlbWVudCIsImhlYWRSZWYiLCJheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCIsImxlbmd0aCIsInN0YXRlSGFuZGxlciIsImludGVycnVwdEhhbmRsZXIiLCJzaGlmdGluc3RydWN0aW9uIiwidHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIiwiY2FjaGUiLCJsYXlvdXQiLCJzY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibW9kZWxjb250ZW50bGlzdCIsIm9sZENyYWRsZVJlZmVyZW5jZUluZGV4IiwicHJvcHMiLCJpbmRleCIsImNyYWRsZUl0ZW1TaGlmdCIsImNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCIsIm5ld0F4aXNSZWZlcmVuY2VJbmRleCIsImF4aXNJdGVtU2hpZnQiLCJheGlzUmVmZXJlbmNlSXRlbVNoaWZ0IiwibmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJpc1NoaWZ0IiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0IiwiZGlzY29ubmVjdCIsImFwcGx5U3R5bGluZyIsImhlYWRjb250ZW50IiwidXBkYXRlZENvbnRlbnRMaXN0IiwiZGVsZXRlZENvbnRlbnRJdGVtcyIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwidGFpbGNvbnRlbnQiLCJjcmFkbGVTdGF0ZVJlZiIsInJlbmRlclBvcnRhbExpc3RzIiwicHJlQXhpc1Jvd3MiLCJjZWlsIiwiYmFzZUNlbGxMZW5ndGgiLCJ0ZXN0U2Nyb2xsUG9zIiwic2Nyb2xsRGlmZiIsInRvcFBvcyIsImxlZnRQb3MiLCJzb3VyY2UiLCJoZWFkR3JpZEVsZW1lbnQiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwiYXhpc1ZpZXdwb3J0T2Zmc2V0IiwiaGVhZFJvd0NvdW50IiwiY2hpbGROb2RlcyIsInRhaWxSb3dDb3VudCIsImF4aXNSZWZlcmVuY2VSb3ciLCJjcmFkbGVSZWZlcmVuY2VSb3ciLCJjcmFkbGVMYXN0Um93IiwibGlzdExhc3RSb3ciLCJwcmVDcmFkbGVSb3dDb3VudCIsInBvc3RDcmFkbGVSb3dDb3VudCIsIm1lYXN1cmVkVGFpbExlbmd0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwiYmFzZVBvc3RDcmFkbGVQaXhlbExlbmd0aCIsImNvbXB1dGVkUG9zdEF4aXNQaXhlbExlbmd0aCIsImJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgiLCJzaWduYWxzIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImNvbXB1dGVkU2Nyb2xsYmxvY2tMZW5ndGgiLCJuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQiLCJzdGFydGluZ1Njcm9sbFBvcyIsInZpZXdwb3J0TGVuZ3RoIiwiYWxpZ25lZEVuZFBvc0RpZmYiLCJzY3JvbGxCeVkiLCJzY3JvbGxCeVgiLCJzY3JvbGxCeSIsImNhY2hlTWF4IiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwibW9kZWxDb21wb25lbnRMaXN0IiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJwYXJlQ2FjaGVUb01heCIsInNjcm9sbGVySUQiLCJtb2RlbEluZGV4TGlzdCIsImdldE1vZGVsSW5kZXhMaXN0IiwibWFwIiwiaXRlbSIsIm1vZGlmaWVkSW5kZXhlc0xpc3QiLCJpbmRleFRvSXRlbUlETWFwIiwiY2FjaGVQcm9wcyIsInByb2Nlc3NDb21wb25lbnQiLCJjb21wb25lbnQiLCJpIiwiYXJyYXkiLCJpdGVtSUQiLCJuZXdJdGVtSUQiLCJoYXMiLCJnZXQiLCJnZXROZXdJdGVtSUQiLCJyZWFjdF8xIiwiY2xvbmVFbGVtZW50IiwiZm9yRWFjaCIsInNsaWNlIiwiY2hhbmdlTGlzdCIsInByb2Nlc3Njb21wb25lbnQiLCJwdHIiLCJpbmRleE9mIiwibmV3TGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n')},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\n// interrupthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleIntersectionObserverCallback: responds to the move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback: responds to crossing of tailward or headward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing interrupts are handled by viewport\n*/\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ \"./src/cradle/contentfunctions.tsx\");\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, InterruptHandler);\n  this.isHeadCradleInView = true;\n  this.isTailCradleInView = true;\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    var _a;\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n    var testrootbounds = entries[0].rootBounds;\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      contentHandler = _this$cradleParameter.contentHandler,\n      stateHandler = _this$cradleParameter.stateHandler,\n      scrollHandler = _this$cradleParameter.scrollHandler,\n      layoutHandler = _this$cradleParameter.layoutHandler;\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n      scrollData.previousupdate = scrollData.currentupdate;\n      scrollData.currentupdate = scrollData.current;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation;\n      var triggerHistoryRef = cradleInternalProperties.triggerHistoryRef,\n        listsize = cradleInternalProperties.listsize,\n        crosscount = cradleInternalProperties.crosscount;\n      var scrollPos = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      var contentLength = orientation == 'vertical' ? viewportElement.scrollHeight : viewportElement.scrollWidth;\n      var viewportLength = orientation == 'vertical' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n      // for browser top or bottom bounce\n      // fractional pixels can cause this to fail, hence Math.floor)\n      if (scrollPos >= 0 || Math.floor(scrollPos + viewportLength) <= contentLength) {\n        var viewportBoundingRect = viewportElement.getBoundingClientRect();\n        var _ref = (0, contentfunctions_1.getShiftInstruction)({\n            scrollerID: cradleInheritedProperties.scrollerID,\n            orientation: orientation,\n            triggerlineEntries: entries,\n            triggerlineSpan: layoutHandler.triggerlineSpan,\n            isFirstRowTriggerConfig: layoutHandler.triggercellIsInTail,\n            viewportBoundingRect: viewportBoundingRect,\n            triggerHistoryRef: triggerHistoryRef\n          }),\n          _ref2 = _slicedToArray(_ref, 2),\n          shiftinstruction = _ref2[0],\n          triggerViewportReferencePos = _ref2[1];\n        if (shiftinstruction == 'axistailward') {\n          // filter out oversize last row\n          var lastListRowOffset = Math.ceil(listsize / crosscount) - 1;\n          var tailcontentlist = contentHandler.content.tailModelComponents;\n          var previousAxisReferenceIndex = ((_a = tailcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n          var previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n          if (lastListRowOffset == previousAxisRowOffset) return;\n        }\n        // none == nothing to do\n        if (shiftinstruction != 'none') {\n          _this.shiftinstruction = shiftinstruction;\n          _this.triggerViewportReferencePos = triggerViewportReferencePos;\n          stateHandler.setCradleState('renderupdatedcontent');\n        }\n      }\n    }\n  };\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler,\n      scrollHandler = _this$cradleParameter2.scrollHandler,\n      layoutHandler = _this$cradleParameter2.layoutHandler;\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (entry.target.dataset.type == 'head') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (_this.signals.repositioningRequired)\n      // start reposition if no other interrupts are underway\n      {\n        _this.isHeadCradleInView = true;\n        _this.isTailCradleInView = true;\n        var cradleState = stateHandler.cradleStateRef.current;\n        if (!['repositioningRender', 'repositioningContinuation', 'finishreposition', 'renderupdatedcontent', 'finishupdatedcontent', 'finishviewportresize'].includes(cradleState) && !ViewportContextProperties.isResizing) {\n          var viewportElement = ViewportContextProperties.elementRef.current;\n          var _this$cradleParameter3 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n            scrollerID = _this$cradleParameter3.scrollerID,\n            layout = _this$cradleParameter3.layout;\n          if (!viewportElement) {\n            console.log('SYSTEM: viewport element not set in cradleIntersectionObserverCallback', scrollerID, ViewportContextProperties);\n            return;\n          }\n          // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n          // and getViewportDimensions in Cradle for width/height\n          var rect = viewportElement.getBoundingClientRect();\n          var top = rect.top,\n            right = rect.right,\n            bottom = rect.bottom,\n            left = rect.left;\n          var width = right - left,\n            height = bottom - top;\n          // update for scrolltracker\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          if (layout == 'variable') {\n            // restore base config to scrollblock\n            layoutHandler.restoreBaseScrollblockConfig();\n            scrollHandler.calcImpliedRepositioningData('restoreBaseScrollblockConfig');\n          }\n          _this.signals.pauseTriggerlinesObserver = true;\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState('startreposition');\n        } else {\n          _this.signals.repositioningRequired = false;\n        }\n      }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.cradleIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n      _this.cradleIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.cradleIntersect.observer.disconnect();\n      _this.cradleIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.triggerlinesIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n      _this.triggerlinesIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.triggerlinesIntersect.observer.disconnect();\n      _this.triggerlinesIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN6Q0QsT0FBTyxDQUFDMEQsK0JBQStCLEdBQUcsS0FBSztJQUMvQzFELE9BQU8sQ0FBQzJHLHlCQUF5QixHQUFHLEtBQUs7SUFDekMzRyxPQUFPLENBQUM0RyxxQkFBcUIsR0FBRyxLQUFLO0VBQ3pDLENBQUM7RUE1VEUsSUFBSSxDQUFDOUcsZ0JBQWdCLEdBQUdBLGdCQUFnQjtBQUUzQyxDQUFDO0FBTkwrRyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBDcmFkbGUgc3RydWN0dXJlIGxpc3RlbmVyczpcbiAgICAtIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2s6IHJlc3BvbmRzIHRvIHRoZSBtb3ZlIG9mIGJvdGggY3JhZGxlIGdyaWRzIG91dHNpZGUgdmlld3BvcnRcbiAgICAgICAgdGhpcyBpbml0aWF0ZXMgdGhlIHJlcG9zaXRpb25pbmcgcHJvdG9jb2xcbiAgICAtIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrOiByZXNwb25kcyB0byBjcm9zc2luZyBvZiB0YWlsd2FyZCBvciBoZWFkd2FyZCB0cmlnZ2VybGluZXNcbiAgICAgICAgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0LCBhbmQgdHJpZ2dlcnMgcm9sbG92ZXIgYW5kIHJlLWFsbG9jYXRpb24gb2YgY3JhZGxlIGNvbnRlbnRcblxuICAgIHZpZXdwb3J0UmVzaXppbmcgaW50ZXJydXB0cyBhcmUgaGFuZGxlZCBieSB2aWV3cG9ydFxuKi9cblxuaW1wb3J0IHsgZ2V0U2hpZnRJbnN0cnVjdGlvbn0gZnJvbSAnLi9jb250ZW50ZnVuY3Rpb25zJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnJ1cHRIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHJpdmF0ZSBpc0hlYWRDcmFkbGVJblZpZXcgPSB0cnVlXG4gICAgcHJpdmF0ZSBpc1RhaWxDcmFkbGVJblZpZXcgPSB0cnVlXG5cbiAgICBwcml2YXRlIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIpIHsgXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0cm9vdGJvdW5kcyA9IGVudHJpZXNbMF0ucm9vdEJvdW5kc1xuICAgICAgICBpZiAoKHRlc3Ryb290Ym91bmRzLndpZHRoID09IDApICYmICh0ZXN0cm9vdGJvdW5kcy5oZWlnaHQgPT0gMCkpIHsgLy8gcmVwYXJlbnRpbmdcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlcixcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gc2Nyb2xsSGFuZGxlclxuXG4gICAgICAgICAgICBzY3JvbGxEYXRhLnByZXZpb3VzdXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlXG4gICAgICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxEYXRhLmN1cnJlbnRcblxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG5cbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgICAgICB0cmlnZ2VySGlzdG9yeVJlZixcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuXG4gICAgICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFBvcyA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFdpZHRoXG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0TGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQub2Zmc2V0SGVpZ2h0OlxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQub2Zmc2V0V2lkdGhcblxuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXIgdG9wIG9yIGJvdHRvbSBib3VuY2VcbiAgICAgICAgICAgIC8vIGZyYWN0aW9uYWwgcGl4ZWxzIGNhbiBjYXVzZSB0aGlzIHRvIGZhaWwsIGhlbmNlIE1hdGguZmxvb3IpXG4gICAgICAgICAgICBpZiAoIChzY3JvbGxQb3MgPj0gMCkgfHwgKE1hdGguZmxvb3Ioc2Nyb2xsUG9zICsgdmlld3BvcnRMZW5ndGgpIDw9IGNvbnRlbnRMZW5ndGgpKSB7IFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRCb3VuZGluZ1JlY3QgPSB2aWV3cG9ydEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IFtzaGlmdGluc3RydWN0aW9uLCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3NdID0gZ2V0U2hpZnRJbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySUQ6IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuc2Nyb2xsZXJJRCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJsaW5lRW50cmllczplbnRyaWVzLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZVNwYW46IGxheW91dEhhbmRsZXIudHJpZ2dlcmxpbmVTcGFuLFxuXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnOmxheW91dEhhbmRsZXIudHJpZ2dlcmNlbGxJc0luVGFpbCxcblxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEJvdW5kaW5nUmVjdCwgLy8gU2FmYXJpIGRvZXNuJ3QgY29ycmVjdGx5IG1lYXN1cmUgem9vbSBmb3Igcm9vdGJvdW5kcyBpbiB0cmlnZ2VybGluZUVudHJpZXNcblxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySGlzdG9yeVJlZixcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJykgeyAvLyBmaWx0ZXIgb3V0IG92ZXJzaXplIGxhc3Qgcm93XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdExpc3RSb3dPZmZzZXQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudCkgLSAxXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFpbGNvbnRlbnRsaXN0ID0gY29udGVudEhhbmRsZXIuY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4ID0gKHRhaWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNBeGlzUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMaXN0Um93T2Zmc2V0ID09IHByZXZpb3VzQXhpc1Jvd09mZnNldCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub25lID09IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiAhPSAnbm9uZScpIHsgXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdGluc3RydWN0aW9uID0gc2hpZnRpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyA9IHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvc1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVuZGVydXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRhIHRyYW5zZmVyIHRvIHVwZGF0ZUNyYWRsZUNvbnRlbnQgdHJpZ2dlcmVkIGJ5IGNsb3NpbmcgYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2sgc2V0Q3JhZGxlU3RhdGUgY2FsbFxuICAgIHNoaWZ0aW5zdHJ1Y3Rpb25cbiAgICB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3NcblxuICAgIHByaXZhdGUgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc2lnbmFscyA9IHRoaXMuc2lnbmFsc1xuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyIFxuXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQuZGF0YXNldC50eXBlID09ICdoZWFkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICgoZW50cnkucm9vdEJvdW5kcy53aWR0aCA9PSAwKSAmJiAoZW50cnkucm9vdEJvdW5kcy5oZWlnaHQgPT0gMCkpIC8vIHJlcGFyZW50aW5nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVGFpbENyYWRsZUluVmlldyA9IFxuICAgICAgICAgICAgICAgICAgICAoZW50cnkuaXNJbnRlcnNlY3RpbmcgIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gKCF0aGlzLmlzSGVhZENyYWRsZUluVmlldyAmJiAhdGhpcy5pc1RhaWxDcmFkbGVJblZpZXcpXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnJlcG9zaXRpb25pbmdSZXF1aXJlZCkgLy8gc3RhcnQgcmVwb3NpdGlvbiBpZiBubyBvdGhlciBpbnRlcnJ1cHRzIGFyZSB1bmRlcndheVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5pc1RhaWxDcmFkbGVJblZpZXcgPSB0cnVlXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIGlmIChcblxuICAgICAgICAgICAgICAgICAgICAhWydyZXBvc2l0aW9uaW5nUmVuZGVyJywncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicsJ2ZpbmlzaHJlcG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbmRlcnVwZGF0ZWRjb250ZW50JywnZmluaXNodXBkYXRlZGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJ10uaW5jbHVkZXMoY3JhZGxlU3RhdGUpICYmXG5cbiAgICAgICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZ1xuXG4gICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELCBcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LCAvLyBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZGRpbmcsIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VsbEhlaWdodCwgY2VsbFdpZHRoLFxuXG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU1lTVEVNOiB2aWV3cG9ydCBlbGVtZW50IG5vdCBzZXQgaW4gY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zIHdpdGggY3JhZGxlIGludGVyc2VjdGlvbi4gU2VlIGFsc28gZGltZW5zaW9uIHVwZGF0ZSBpbiB2aWV3cG9ydC50c3ggZm9yIHJlc2l6ZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBnZXRWaWV3cG9ydERpbWVuc2lvbnMgaW4gQ3JhZGxlIGZvciB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gdmlld3BvcnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IHJlY3RcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdCwgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZm9yIHNjcm9sbHRyYWNrZXJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLnZpZXdwb3J0RGltZW5zaW9ucyA9IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9IFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sodHJ1ZSlcblxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgeyAvLyByZXN0b3JlIGJhc2UgY29uZmlnIHRvIHNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5yZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnKClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGFuZGxlci5jYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhKCdyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnJylcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3N0YXJ0cmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICBwdWJsaWMgY3JhZGxlSW50ZXJzZWN0ID0geyAgICBcbiAgICAgICAgb2JzZXJ2ZXI6bnVsbCwgICAgXG4gICAgICAgIGNhbGxiYWNrOnRoaXMuY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayxcbiAgICAgICAgZGlzY29ubmVjdGVkOnRydWUsXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JhZGxlSW50ZXJzZWN0LmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudGFpbFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDooKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlSW50ZXJzZWN0LmRpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlT2JzZXJ2ZXI6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICAgICAgICAgIHRoaXMuY3JhZGxlSW50ZXJzZWN0LmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHtyb290OlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LCB0aHJlc2hvbGQ6MH1cbiAgICAgICAgICAgICkgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXJcbiAgICAgICAgfVxuICAgIH1cblxuICAgcHVibGljIHRyaWdnZXJsaW5lc0ludGVyc2VjdCA9IHtcbiAgICAgICAgb2JzZXJ2ZXI6bnVsbCxcbiAgICAgICAgY2FsbGJhY2s6dGhpcy5heGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayxcbiAgICAgICAgZGlzY29ubmVjdGVkOnRydWUsXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDooKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmRpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlT2JzZXJ2ZXI6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHtyb290OlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LCB0aHJlc2hvbGQ6MH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHNpZ25hbHMgPSB7XG4gICAgICAgIHJlcG9zaXRpb25pbmdSZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIHBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXI6IGZhbHNlLCBcbiAgICAgICAgcGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlcjpmYWxzZSxcbiAgICAgICAgcGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlcjogZmFsc2UsXG4gICAgICAgIHBhdXNlU2Nyb2xsaW5nRWZmZWN0czogZmFsc2UsXG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgaW52b2tlZCBmb3IgXG4gICAgICAgIGNyYWRsZTpcbiAgICAgICAgLSBjaGFuZ2UgaW50byBjYWNoZVxuICAgICAgICAtIHRyaWdnZXIgY3JhZGxlcmVzaXppbmdcbiAgICAgICAgLSB0cmlnZ2VyIHJlY29uZmlndXJhdGlvblxuICAgICAgICAtIHRyaWdnZXIgcGl2b3RcbiAgICAgICAgc2VydmljZWhhbmRsZXI6XG4gICAgICAgIC0gY2FsbCByZWxvYWRcbiAgICAqL1xuICAgIHB1YmxpYyBwYXVzZUludGVycnVwdHMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpc1xuICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcbiAgICB9XG4gICAgLypcbiAgICAgICAgaW52b2tlZCBmb3JcbiAgICAgICAgY3JhZGxlOlxuICAgICAgICAtIHJlc3RvcmVpbnRlcnJ1cHRzXG4gICAgKi9cbiAgICBwdWJsaWMgcmVzdG9yZUludGVycnVwdHMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpc1xuICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSBmYWxzZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBmYWxzZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSBmYWxzZVxuICAgICAgICBzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IGZhbHNlXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiSW50ZXJydXB0SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJlbnRyaWVzIiwic2lnbmFscyIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJ0ZXN0cm9vdGJvdW5kcyIsInJvb3RCb3VuZHMiLCJ3aWR0aCIsImhlaWdodCIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImNvbnRlbnRIYW5kbGVyIiwic3RhdGVIYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJpc01vdW50ZWRSZWYiLCJzY3JvbGxEYXRhIiwicHJldmlvdXN1cGRhdGUiLCJjdXJyZW50dXBkYXRlIiwidmlld3BvcnRFbGVtZW50IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImVsZW1lbnRSZWYiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsIm9yaWVudGF0aW9uIiwidHJpZ2dlckhpc3RvcnlSZWYiLCJsaXN0c2l6ZSIsImNyb3NzY291bnQiLCJzY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiY29udGVudExlbmd0aCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIiwidmlld3BvcnRMZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIk1hdGgiLCJmbG9vciIsInZpZXdwb3J0Qm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsZXJJRCIsInRyaWdnZXJsaW5lRW50cmllcyIsInRyaWdnZXJsaW5lU3BhbiIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidHJpZ2dlcmNlbGxJc0luVGFpbCIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MiLCJsYXN0TGlzdFJvd09mZnNldCIsImNlaWwiLCJ0YWlsY29udGVudGxpc3QiLCJjb250ZW50IiwidGFpbE1vZGVsQ29tcG9uZW50cyIsInByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4IiwicHJvcHMiLCJpbmRleCIsInByZXZpb3VzQXhpc1Jvd09mZnNldCIsInNldENyYWRsZVN0YXRlIiwic2VydmljZUhhbmRsZXIiLCJwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyIiwiaSIsImxlbmd0aCIsImVudHJ5IiwidGFyZ2V0IiwiZGF0YXNldCIsInR5cGUiLCJpc0hlYWRDcmFkbGVJblZpZXciLCJpc0ludGVyc2VjdGluZyIsImlzVGFpbENyYWRsZUluVmlldyIsInJlcG9zaXRpb25pbmdSZXF1aXJlZCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaW5jbHVkZXMiLCJpc1Jlc2l6aW5nIiwibGF5b3V0IiwiY29uc29sZSIsImxvZyIsInJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiY2FsbGJhY2tzIiwicmVzdG9yZUJhc2VTY3JvbGxibG9ja0NvbmZpZyIsImNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEiLCJvYnNlcnZlciIsImNhbGxiYWNrIiwiY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayIsImRpc2Nvbm5lY3RlZCIsImNvbm5lY3RFbGVtZW50cyIsImNyYWRsZUludGVyc2VjdCIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJvYnNlcnZlIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJkaXNjb25uZWN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3QiLCJ0aHJlc2hvbGQiLCJheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n")},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\n// layouthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the head and tail triggerlines\n    The key control values are the blockScrollPos & blockXScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferenceIndex (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, LayoutHandler);\n    // cradlePositionData controls the relative positions of the scaffold elements\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n      blockXScrollPos: null,\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n      blockXScrollProperty: null,\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToIndex call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // pixels into the viewport\n    };\n    // called by interruptHandler\n    this.restoreBaseScrollblockConfig = function () {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var scrollblockElement = viewportElement.firstChild;\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        orientation = _this$cradleParameter.orientation,\n        padding = _this$cradleParameter.padding,\n        gap = _this$cradleParameter.gap,\n        cellHeight = _this$cradleParameter.cellHeight,\n        cellWidth = _this$cradleParameter.cellWidth;\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n        listRowcount = _this$cradleParameter2.listRowcount,\n        crosscount = _this$cradleParameter2.crosscount;\n      var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        scrollHandler = _this$cradleParameter3.scrollHandler,\n        layoutHandler = _this$cradleParameter3.layoutHandler;\n      var cellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var baselength = listRowcount * cellLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var axisReference = cradlePositionData.targetAxisReferenceIndex;\n      var rowOffset = Math.ceil(axisReference / crosscount);\n      var calculatedBlockScrollPos = rowOffset * cellLength + padding;\n      if ((0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // scrollPos overwritten by Safari iOS momentum engine\n        var originalScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollShift = calculatedBlockScrollPos - originalScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = scrollShift;\n        } else {\n          scrollblockElement.style.left = scrollShift;\n        }\n      } else {\n        viewportElement[cradlePositionData.blockScrollProperty] = calculatedBlockScrollPos;\n      }\n      cradlePositionData.blockScrollPos = calculatedBlockScrollPos;\n      scrollHandler.resetScrollData(calculatedBlockScrollPos);\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n      axisRef = _cradleParameters$cra.axisRef,\n      headRef = _cradleParameters$cra.headRef,\n      tailRef = _cradleParameters$cra.tailRef,\n      triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      var span = orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop :\n      // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n      return span;\n    }\n  }]);\n  return LayoutHandler;\n}();\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2xheW91dGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUFxRCxJQUVoQ0EsYUFBYTtFQUU5Qix1QkFBWUMsZ0JBQWdCO0lBQUE7SUFBQTtJQTBENUI7SUFDTyx1QkFBa0IsR0FBRztNQUV4Qjs7Ozs7Ozs7TUFXQUMsY0FBYyxFQUFDLElBQUk7TUFDbkJDLGVBQWUsRUFBQyxJQUFJO01BRXBCOzs7OztNQU9BQyxtQkFBbUIsRUFBRSxJQUFJO01BQ3pCQyxvQkFBb0IsRUFBRSxJQUFJO01BRTFCOzs7Ozs7Ozs7OztNQVlBQyx3QkFBd0IsRUFBQyxJQUFJO01BRTdCOzs7Ozs7Ozs7OztNQWFBQyw2QkFBNkIsRUFBQyxJQUFJLENBQUU7S0FFdkM7SUFFRDtJQUNPLGlDQUE0QixHQUFHLFlBQUs7TUFFdkMsSUFBTUMseUJBQXlCLEdBQUcsS0FBSSxDQUFDUCxnQkFBZ0IsQ0FBQ1EsNEJBQTRCLENBQUNDLE9BQU87TUFDNUYsSUFBTUMsZUFBZSxHQUFHSCx5QkFBeUIsQ0FBQ0ksVUFBVSxDQUFDRixPQUFPO01BQ3BFLElBQU1HLGtCQUFrQixHQUFHRixlQUFlLENBQUNHLFVBQVU7TUFFckQsNEJBVUksS0FBSSxDQUFDYixnQkFBZ0IsQ0FBQ2MsNEJBQTRCLENBQUNMLE9BQU87UUFQMURNLFdBQVcseUJBQVhBLFdBQVc7UUFDWEMsT0FBTyx5QkFBUEEsT0FBTztRQUNQQyxHQUFHLHlCQUFIQSxHQUFHO1FBQ0hDLFVBQVUseUJBQVZBLFVBQVU7UUFDVkMsU0FBUyx5QkFBVEEsU0FBUztNQUtiLDZCQUdJLEtBQUksQ0FBQ25CLGdCQUFnQixDQUFDb0IsMkJBQTJCLENBQUNYLE9BQU87UUFGekRZLFlBQVksMEJBQVpBLFlBQVk7UUFDWkMsVUFBVSwwQkFBVkEsVUFBVTtNQUdkLDZCQU9JLEtBQUksQ0FBQ3RCLGdCQUFnQixDQUFDdUIsV0FBVyxDQUFDZCxPQUFPO1FBSHpDZSxhQUFhLDBCQUFiQSxhQUFhO1FBQ2JDLGFBQWEsMEJBQWJBLGFBQWE7TUFJakIsSUFBTUMsVUFBVSxHQUNaLENBQUVYLFdBQVcsSUFBSSxVQUFVLEdBQ3ZCRyxVQUFVLEdBQ1ZDLFNBQVMsSUFDWEYsR0FBRztNQUVULElBQU1VLFVBQVUsR0FBSU4sWUFBWSxHQUFHSyxVQUFVLEdBQUlULEdBQUcsQ0FBQztNQUFBLEVBQzlDRCxPQUFPLEdBQUcsQ0FBRSxFQUFDO01BRXBCLElBQUlELFdBQVcsSUFBSSxVQUFVLEVBQUU7UUFFM0JILGtCQUFrQixDQUFDZ0IsS0FBSyxDQUFDQyxHQUFHLEdBQUcsSUFBSTtRQUNuQ2pCLGtCQUFrQixDQUFDZ0IsS0FBSyxDQUFDRSxNQUFNLEdBQUdILFVBQVUsR0FBRyxJQUFJO09BRXRELE1BQU07UUFFSGYsa0JBQWtCLENBQUNnQixLQUFLLENBQUNHLElBQUksR0FBRyxJQUFJO1FBQ3BDbkIsa0JBQWtCLENBQUNnQixLQUFLLENBQUNJLEtBQUssR0FBR0wsVUFBVSxHQUFHLElBQUk7O01BSXRELElBQVFNLGtCQUFrQixHQUFLUixhQUFhLENBQXBDUSxrQkFBa0I7TUFDMUIsSUFBTUMsYUFBYSxHQUFHRCxrQkFBa0IsQ0FBQzVCLHdCQUF3QjtNQUNqRSxJQUFNOEIsU0FBUyxHQUFHQyxJQUFJLENBQUNDLElBQUksQ0FBQ0gsYUFBYSxHQUFDWixVQUFVLENBQUM7TUFDckQsSUFBTWdCLHdCQUF3QixHQUN6QkgsU0FBUyxHQUFHVCxVQUFVLEdBQUlWLE9BQU87TUFHdEMsSUFBSSxzQ0FBVyxHQUFFLEVBQUU7UUFBRTtRQUVqQixJQUFNdUIsaUJBQWlCLEdBQ2xCeEIsV0FBVyxJQUFJLFVBQVUsR0FDdEJMLGVBQWUsQ0FBQzhCLFNBQVMsR0FDekI5QixlQUFlLENBQUMrQixVQUFVO1FBRWxDLElBQU1DLFdBQVcsR0FBR0osd0JBQXdCLEdBQUdDLGlCQUFpQjtRQUVoRSxJQUFJeEIsV0FBVyxJQUFJLFVBQVUsRUFBRTtVQUUzQkgsa0JBQWtCLENBQUNnQixLQUFLLENBQUNDLEdBQUcsR0FBR2EsV0FBVztTQUU3QyxNQUFNO1VBRUg5QixrQkFBa0IsQ0FBQ2dCLEtBQUssQ0FBQ0csSUFBSSxHQUFHVyxXQUFXOztPQUtsRCxNQUFNO1FBRUhoQyxlQUFlLENBQUN1QixrQkFBa0IsQ0FBQzlCLG1CQUFtQixDQUFDLEdBQUdtQyx3QkFBd0I7O01BR3RGTCxrQkFBa0IsQ0FBQ2hDLGNBQWMsR0FBR3FDLHdCQUF3QjtNQUM1RGQsYUFBYSxDQUFDbUIsZUFBZSxDQUFDTCx3QkFBd0IsQ0FBQztJQUUzRCxDQUFDO0lBM01HLElBQUksQ0FBQ3RDLGdCQUFnQixHQUFHQSxnQkFBZ0I7SUFFeEMsNEJBTUlBLGdCQUFnQixDQUFDb0IsMkJBQTJCLENBQUNYLE9BQU8sQ0FBQ21DLGlCQUFpQixDQUFDbkMsT0FBTztNQUw5RW9DLE9BQU8seUJBQVBBLE9BQU87TUFDUEMsT0FBTyx5QkFBUEEsT0FBTztNQUNQQyxPQUFPLHlCQUFQQSxPQUFPO01BQ1BDLDZCQUE2Qix5QkFBN0JBLDZCQUE2QjtNQUM3QkMsNkJBQTZCLHlCQUE3QkEsNkJBQTZCO0lBR2pDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO01BQ1pMLE9BQU8sRUFBUEEsT0FBTztNQUNQQyxPQUFPLEVBQVBBLE9BQU87TUFDUEMsT0FBTyxFQUFQQSxPQUFPO01BQ1BDLDZCQUE2QixFQUE3QkEsNkJBQTZCO01BQzdCQyw2QkFBNkIsRUFBN0JBO0tBQ0g7SUFFRCxJQUNJRSxhQUFhLEdBRWIsSUFBSSxDQUFDbkQsZ0JBQWdCLENBQUNjLDRCQUE0QixDQUFDTCxPQUFPLENBRjFEMEMsYUFBYTtJQUlqQixJQUNJQyxRQUFRLEdBQ1IsSUFBSSxDQUFDcEQsZ0JBQWdCLENBQUNvQiwyQkFBMkIsQ0FBQ1gsT0FBTyxDQUR6RDJDLFFBQVE7SUFHWixJQUFJLENBQUNuQixrQkFBa0IsQ0FBQzVCLHdCQUF3QixHQUMzQytCLElBQUksQ0FBQ2lCLEdBQUcsQ0FBQ0YsYUFBYSxFQUFFQyxRQUFRLEdBQUcsQ0FBQyxDQUFFLElBQUksQ0FBRTtJQUVqRCxJQUFJLENBQUNuQixrQkFBa0IsQ0FBQzNCLDZCQUE2QixHQUFHLENBQUM7RUFFN0Q7RUFBQztJQUFBO0lBQUEsS0FJRCxlQUEwQjtNQUV0QixJQUNJUyxXQUFXLEdBRVgsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQ2MsNEJBQTRCLENBQUNMLE9BQU8sQ0FGMURNLFdBQVc7TUFJZixJQUFNdUMsSUFBSSxHQUFJdkMsV0FBVyxJQUFJLFVBQVUsR0FDbkMsSUFBSSxDQUFDbUMsUUFBUSxDQUFDRCw2QkFBNkIsQ0FBQ3hDLE9BQU8sQ0FBQzhDLFNBQVMsR0FDN0QsSUFBSSxDQUFDTCxRQUFRLENBQUNGLDZCQUE2QixDQUFDdkMsT0FBTyxDQUFDOEMsU0FBUztNQUM3RDtNQUNBLElBQUksQ0FBQ0wsUUFBUSxDQUFDRCw2QkFBNkIsQ0FBQ3hDLE9BQU8sQ0FBQytDLFVBQVUsR0FDOUQsSUFBSSxDQUFDTixRQUFRLENBQUNGLDZCQUE2QixDQUFDdkMsT0FBTyxDQUFDK0MsVUFBVTtNQUVsRSxPQUFPRixJQUFJO0lBQ2Y7RUFBQztFQUFBO0FBQUE7QUF2RExHLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL2xheW91dGhhbmRsZXIudHN4PzA3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGF5b3V0aGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgaG9sZHMgcmVmZXJlbmNlcyB0byBcbiAgICAtIHRoZSBzdHJ1Y3R1cmFsIGVsZW1lbnRzIG9mIHRoZSBjcmFkbGVcbiAgICAtIHRoZSBrZXkgY29udHJvbCB2YWx1ZXMgb2YgdGhlIGNyYWRsZVxuXG4gICAgVGhlIHN0cnVjdHVyYWwgZWxlbWVudHMgYXJlIHRoZSBheGlzLCBoZWFkIChncmlkKSwgdGFpbCAoZ3JpZCksIFxuICAgICAgICBhbmQgdGhlIGhlYWQgYW5kIHRhaWwgdHJpZ2dlcmxpbmVzXG4gICAgVGhlIGtleSBjb250cm9sIHZhbHVlcyBhcmUgdGhlIGJsb2NrU2Nyb2xsUG9zICYgYmxvY2tYU2Nyb2xsUG9zIChzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCksIHRoZSBibG9jayBzY3JvbGxcbiAgICAgICAgcHJvcGVydHkgKFwic2Nyb2xsVG9wXCIgb3IgXCJzY3JvbGxMZWZ0XCIpLCB0aGUgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IChmaXJzdCBpbmRleCBvZiB0aGVcbiAgICAgICAgdGFpbCBibG9jayksIGFuZCB0aGUgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKHBpeGVscyBvZmZzZXQgZnJvbSB0aGUgZWRnZSBvZiB0aGUgXG4gICAgICAgIHZpZXdwb3J0KVxuKi9cblxuaW1wb3J0IHsgaXNTYWZhcmlJT1MgfSBmcm9tICcuLi9JbmZpbml0ZUdyaWRTY3JvbGxlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5b3V0SGFuZGxlciB7IFxuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBheGlzUmVmLCBcbiAgICAgICAgICAgIGhlYWRSZWYsIFxuICAgICAgICAgICAgdGFpbFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYsXG4gICAgICAgIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LmNyYWRsZUVsZW1lbnRzUmVmLmN1cnJlbnRcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgICAgICAgICBheGlzUmVmLFxuICAgICAgICAgICAgaGVhZFJlZixcbiAgICAgICAgICAgIHRhaWxSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleCwgXG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICB0aGlzLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBcbiAgICAgICAgICAgIChNYXRoLm1pbihzdGFydGluZ0luZGV4LChsaXN0c2l6ZSAtIDEpKSB8fCAwKVxuXG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gMFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0IHRyaWdnZXJsaW5lU3BhbigpIHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudC5vZmZzZXRUb3AgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0TGVmdCAtIFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50Lm9mZnNldExlZnRcblxuICAgICAgICByZXR1cm4gc3BhblxuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbEluZGV4XG4gICAgcHVibGljIHRyaWdnZXJjZWxsSXNJblRhaWwgLy8gPSBmYWxzZVxuXG4gICAgLy8gY3JhZGxlUG9zaXRpb25EYXRhIGNvbnRyb2xzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgdGhlIHNjYWZmb2xkIGVsZW1lbnRzXG4gICAgcHVibGljIGNyYWRsZVBvc2l0aW9uRGF0YSA9IHtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgXCJibG9ja1wiID0gY3JhZGxlYmxvY2ssIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRoYXQgaXMgc2Nyb2xsZWRcblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgc2V0IGJ5IHNjcm9sbEhhbmRsZXIgZHVyaW5nIGFuZCBhZnRlciBzY3JvbGxpbmcsXG4gICAgICAgICAgICBhbmQgYnkgc2V0Q3JhZGxlQ29udGVudCBpbiBjb250ZW50SGFuZGxlciwgd2hpY2ggcmVwb3NpdGlvbnMgdGhlIGNyYWRsZS5cblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gY3JhZGxlIGluaXRpYWxpemF0aW9uIGluIHJlc3BvbnNlIHRvIHJlcGFyZW50aW5nIGludGVycnVwdFxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuXG4gICAgICAgICovXG4gICAgICAgIGJsb2NrU2Nyb2xsUG9zOm51bGwsIC8vIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICBibG9ja1hTY3JvbGxQb3M6bnVsbCwgLy8gdGhlIGNyb3NzIHBvc2l0aW9uIGZvciBvdmVyc2l6ZWQgc2Nyb2xsQmxvY2tcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdmFsdWVzIGNhbiBiZSBcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiIChvZiB0aGUgdmlld3BvcnQgZWxlbWVudCkgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBvcmllbnRhdGlvbiByZWNvbmZpZ3VyYXRpb24gZWZmZWN0IGluIGNyYWRsZSBtb2R1bGUuXG5cbiAgICAgICAgICAgIGl0IGlzIHVzZWQgd2hlcmUgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBhYm92ZS5cbiAgICAgICAgKi9cbiAgICAgICAgYmxvY2tTY3JvbGxQcm9wZXJ0eTogbnVsbCxcbiAgICAgICAgYmxvY2tYU2Nyb2xsUHJvcGVydHk6IG51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCBpcyBzZXQgYnlcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIGxheW91dEhhbmRsZXIgKGluaXRpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsSGFuZGxlciAoZHVyaW5nIGFuZCBhZnRlciBzY3JvbGwpXG4gICAgICAgICAgICAgICAgLSBob3N0IHNjcm9sbFRvSW5kZXggY2FsbFxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsVHJhY2tlckFyZ3MgaW4gY3JhZGxlIG1vZHVsZVxuICAgICAgICAgICAgICAgIC0gcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGluIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Om51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHNldCBieVxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gbGF5b3V0SGFuZGxlciAoaW5pdGlhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgLSBzY3JvbGxIYW5kbGVyIChkdXJpbmcgYW5kIGFmdGVyIHNjcm9sbClcbiAgICAgICAgICAgICAgICAtIHBpdm90IGVmZmVjdCAoY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBpbiBjcmFkbGUgbW9kdWxlXG5cbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIHByZXZpb3VzQXhpc09mZnNldCBpbiBwaXZvdCBlZmZlY3RcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDpudWxsLCAvLyBwaXhlbHMgaW50byB0aGUgdmlld3BvcnRcblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBieSBpbnRlcnJ1cHRIYW5kbGVyXG4gICAgcHVibGljIHJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAvLyBzY3JvbGxlcklELCBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIC8vIGxheW91dCBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAvLyBzdGF0ZUhhbmRsZXIsIFxuICAgICAgICAgICAgLy8gc2VydmljZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyIFxuXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdFJvd2NvdW50ICogY2VsbExlbmd0aCkgLSBnYXAgLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYmFzZWxlbmd0aCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGJhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIGNvbnN0IGF4aXNSZWZlcmVuY2UgPSBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNvbnN0IHJvd09mZnNldCA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlL2Nyb3NzY291bnQpXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcyA9IFxuICAgICAgICAgICAgKHJvd09mZnNldCAqIGNlbGxMZW5ndGgpICsgcGFkZGluZ1xuXG5cbiAgICAgICAgaWYgKGlzU2FmYXJpSU9TKCkpIHsgLy8gc2Nyb2xsUG9zIG92ZXJ3cml0dGVuIGJ5IFNhZmFyaSBpT1MgbW9tZW50dW0gZW5naW5lXG5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsUG9zID0gXG4gICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxTaGlmdCA9IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcyAtIG9yaWdpbmFsU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gc2Nyb2xsU2hpZnRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gc2Nyb2xsU2hpZnRcblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvc1xuXG4gICAgICAgIH1cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gY2FsY3VsYXRlZEJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcylcblxuICAgIH1cblxuICAgIHB1YmxpYyBlbGVtZW50c1xuXG59XG5cbiJdLCJuYW1lcyI6WyJMYXlvdXRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImJsb2NrU2Nyb2xsUG9zIiwiYmxvY2tYU2Nyb2xsUG9zIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImJsb2NrWFNjcm9sbFByb3BlcnR5IiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImN1cnJlbnQiLCJ2aWV3cG9ydEVsZW1lbnQiLCJlbGVtZW50UmVmIiwic2Nyb2xsYmxvY2tFbGVtZW50IiwiZmlyc3RDaGlsZCIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJvcmllbnRhdGlvbiIsInBhZGRpbmciLCJnYXAiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwibGlzdFJvd2NvdW50IiwiY3Jvc3Njb3VudCIsImhhbmRsZXJzUmVmIiwic2Nyb2xsSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJjZWxsTGVuZ3RoIiwiYmFzZWxlbmd0aCIsInN0eWxlIiwidG9wIiwiaGVpZ2h0IiwibGVmdCIsIndpZHRoIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYXhpc1JlZmVyZW5jZSIsInJvd09mZnNldCIsIk1hdGgiLCJjZWlsIiwiY2FsY3VsYXRlZEJsb2NrU2Nyb2xsUG9zIiwib3JpZ2luYWxTY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsU2hpZnQiLCJyZXNldFNjcm9sbERhdGEiLCJjcmFkbGVFbGVtZW50c1JlZiIsImF4aXNSZWYiLCJoZWFkUmVmIiwidGFpbFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJlbGVtZW50cyIsInN0YXJ0aW5nSW5kZXgiLCJsaXN0c2l6ZSIsIm1pbiIsInNwYW4iLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// scrollhandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferenceIndex, and\n        targetAxisViewportPixelOffset\n*/\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ScrollHandler);\n  this._isIOSscrolling = false;\n  this.iOSonScroll = function () {\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this._isIOSscrolling) {\n      _this._isIOSscrolling = true;\n      _this._onIOSonAfterScrollTimeout = 1000; // iOS sometimes likes to pause before commencing scrolling\n      clearTimeout(_this._onIOSonAfterScrollTimeout);\n      _this._iOSsetTimeoutTimerid = setTimeout(function () {\n        _this._onIOSonAfterScrollTimeout = 250; // back to more responsive once underway\n      }, 900);\n    }\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    clearTimeout(_this._iOSscrolltimerid);\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockElement = viewportElement.firstChild;\n    var scrollblockLength, viewportLength, blockScrollPos, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollblockLength = viewportElement.scrollHeight;\n      viewportLength = viewportElement.offsetHeight;\n      blockScrollPos = viewportElement.scrollTop;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollblockLength = viewportElement.scrollWidth;\n      viewportLength = viewportElement.offsetWidth;\n      blockScrollPos = viewportElement.scrollLeft;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    if (blockScrollPos - scrollblockOffset < 0 ||\n    // overshoot start\n    scrollblockLength < blockScrollPos - scrollblockOffset + viewportLength) {\n      // overshoot end\n      _this.iOSonAfterScroll(); // immediate halt and adjust\n    } else {\n      _this._iOSscrolltimerid = setTimeout(function () {\n        _this.iOSonAfterScroll(); // deferred halt and adjust\n      }, _this._onIOSonAfterScrollTimeout);\n    }\n  };\n  this.iOSonAfterScroll = function () {\n    _this._isIOSscrolling = false;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var scrollblockElement = viewportElement.firstChild;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockOffset = orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n    var blockScrollPos = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    viewportElement.style.overflow = 'hidden';\n    if (orientation == 'vertical') {\n      viewportElement.scrollTop = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.top = null;\n    } else {\n      // orientation == horizontal\n      viewportElement.scrollLeft = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.left = null;\n    }\n    viewportElement.style.overflow = 'scroll';\n  };\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      scrollerID = _this$cradleParameter.scrollerID,\n      ONAFTERSCROLL_TIMEOUT = _this$cradleParameter.ONAFTERSCROLL_TIMEOUT;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    // const viewportElement = ViewportContextProperties.elementRef.current\n    var viewportElement = e.currentTarget;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollPositionCurrent = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    var scrollXPositionCurrent = orientation == 'horizontal' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    // keep up to date in case of reparenting interrupt\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    cradlePositionData.blockXScrollPos = scrollXPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    // const { contentHandler, serviceHandler } = this.cradleParameters.handlersRef.current\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        _this.calcImpliedRepositioningData('onScroll');\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, ONAFTERSCROLL_TIMEOUT);\n    return false;\n  };\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler;\n    // const ViewportContextProperties = this.cradleParameters.ViewportContextPropertiesRef.current,\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n          break;\n        }\n    }\n    var cache = cradleInheritedProperties.cache;\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n  };\n  // after scroll, but not after repositioning\n  this.updateReferenceData = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter3.stateHandler,\n      layoutHandler = _this$cradleParameter3.layoutHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current,\n      viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var axisViewportPixelOffset;\n    if (cradleProps.orientation == 'vertical') {\n      axisViewportPixelOffset = axisElement.offsetTop + scrollblockElement.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisViewportPixelOffset = axisElement.offsetLeft + scrollblockElement.offsetLeft - viewportElement.scrollLeft;\n    }\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  };\n  // called from finishreposition state change call above\n  // called from updateReferenceData\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollLeft;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollTop;\n      }\n    }\n  };\n  this.calcImpliedRepositioningData = function (source) {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n      cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var crosscount = cradleConfig.crosscount,\n      listsize = cradleConfig.listsize,\n      orientation = cradleProps.orientation;\n    var scrollPos, cellLength, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    var axisPixelOffset = cellLength - (scrollPos + scrollblockOffset) % cellLength;\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRTlELElBQU1hLElBQUksR0FBR0Ysa0JBQWtCLEdBQUdaLFVBQVU7SUFDNUNZLGtCQUFrQixJQUFJRSxJQUFJO0lBRTFCLElBQUlGLGtCQUFrQixJQUFJLENBQUMsRUFBRUwsZUFBZSxHQUFHLENBQUMsRUFBQztJQUVqRCxJQUFRcEMsa0JBQWtCLEdBQUssS0FBSSxDQUFDdEQsZ0JBQWdCLENBQUNFLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDa0QsYUFBYSxDQUE5RUMsa0JBQWtCO0lBRTFCQSxrQkFBa0IsQ0FBQzRDLHdCQUF3QixHQUFHSCxrQkFBa0I7SUFDaEV6QyxrQkFBa0IsQ0FBQ3lCLDZCQUE2QixHQUFHVyxlQUFlO0VBRXRFLENBQUM7RUF0WUcsSUFBSSxDQUFDMUYsZ0JBQWdCLEdBQUdBLGdCQUFnQjtBQUU1QyxDQUFDO0FBTkxtRyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSByZXNwb25zZSB0byBzY3JvbGxpbmcuIEl0IGFsc28gdHJpZ2dlcnMgYW4gb25BZnRlclNjcm9sbCBldmVudCAoYWZ0ZXIgYSB0aW1lb3V0KVxuICAgIEl0J3MgbWFpbiBqb2IgaXMgdG8gbWFpbnRhaW4gcmVjb3JkcyBvZiBzY3JvbGxQb3MsIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaU9Tc2Nyb2xsdGltZXJpZFxuICAgIHByaXZhdGUgX2lPU3NldFRpbWVvdXRUaW1lcmlkXG5cbiAgICBwcml2YXRlIF9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0XG5cbiAgICBwcml2YXRlIF9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICBwdWJsaWMgaU9Tb25TY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5pbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzSU9Tc2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lzSU9Tc2Nyb2xsaW5nID0gdHJ1ZVxuXG4gICAgICAgICAgICB0aGlzLl9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0ID0gMTAwMCAvLyBpT1Mgc29tZXRpbWVzIGxpa2VzIHRvIHBhdXNlIGJlZm9yZSBjb21tZW5jaW5nIHNjcm9sbGluZ1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dClcblxuICAgICAgICAgICAgdGhpcy5faU9Tc2V0VGltZW91dFRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dCA9IDI1MCAvLyBiYWNrIHRvIG1vcmUgcmVzcG9uc2l2ZSBvbmNlIHVuZGVyd2F5XG4gICAgICAgICAgICB9LDkwMClcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faU9Tc2Nyb2xsdGltZXJpZClcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgc2Nyb2xsYmxvY2tMZW5ndGgsIHZpZXdwb3J0TGVuZ3RoLCBibG9ja1Njcm9sbFBvcywgc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrTGVuZ3RoID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3BcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0xlbmd0aCA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxXaWR0aFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoKCBibG9ja1Njcm9sbFBvcyAtIHNjcm9sbGJsb2NrT2Zmc2V0KSA8IDApIHx8IC8vIG92ZXJzaG9vdCBzdGFydFxuICAgICAgICAgICAgKHNjcm9sbGJsb2NrTGVuZ3RoIDwgKGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXQgKyB2aWV3cG9ydExlbmd0aCkpKSB7IC8vIG92ZXJzaG9vdCBlbmRcblxuICAgICAgICAgICAgdGhpcy5pT1NvbkFmdGVyU2Nyb2xsKCkgLy8gaW1tZWRpYXRlIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lPU3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaU9Tb25BZnRlclNjcm9sbCgpIC8vIGRlZmVycmVkIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgICAgICB9LHRoaXMuX29uSU9Tb25BZnRlclNjcm9sbFRpbWVvdXQpXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaU9Tb25BZnRlclNjcm9sbCA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLl9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cblxuICAgICAgICBjb25zdCBzY3JvbGxibG9ja09mZnNldCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9XG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gaG9yaXpvbnRhbFxuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuXG4gICAgICAgIH1cblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyByZXNldFNjcm9sbERhdGEgPSAoc2Nyb2xsUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSB0aGlzXG4gICAgICAgIHNjcm9sbERhdGEuc3RhcnQgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50ID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXMgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IFxuICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlcklELCBPTkFGVEVSU0NST0xMX1RJTUVPVVQgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAvLyBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IGUuY3VycmVudFRhcmdldFxuXG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5vcmllbnRhdGlvblxuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsWFBvc2l0aW9uQ3VycmVudCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY3JvbGx0aW1lcmlkKVxuXG4gICAgICAgIGlmICgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDAgICYmIHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uQ3VycmVudCA8IDApIHsgLy8gZm9yIFNhZmFyaVxuXG4gICAgICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cykge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuc3RhcnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICAvLyBrZWVwIHVwIHRvIGRhdGUgaW4gY2FzZSBvZiByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSBzY3JvbGxYUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzID0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnRcbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICBjb25zdCB7c3RhdGVIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBjb25zdCB7IGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICBpZiAoKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgfHwgKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJykpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSgnb25TY3JvbGwnKVxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsdGltZXJpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJTY3JvbGwoKVxuXG4gICAgICAgIH0sT05BRlRFUlNDUk9MTF9USU1FT1VUKVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgfVxuXG5cbiAgICBwcml2YXRlIG9uQWZ0ZXJTY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdSZW5kZXInOiBcbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nOlxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Njcm9sbFBvcygpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayhmYWxzZSlcbiAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHJlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNjcm9sbERhdGEuc3RhcnQgIT0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgIT0gdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KClcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgc2Nyb2xsLCBidXQgbm90IGFmdGVyIHJlcG9zaXRpb25pbmdcbiAgICBwcml2YXRlIHVwZGF0ZVJlZmVyZW5jZURhdGEgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIGxheW91dEhhbmRsZXIgfSBcbiAgICAgICAgICAgID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgaWYgKGNyYWRsZVByb3BzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRUb3AgKyBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wIC0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldExlZnQgKyBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBmaW5pc2hyZXBvc2l0aW9uIHN0YXRlIGNoYW5nZSBjYWxsIGFib3ZlXG4gICAgLy8gY2FsbGVkIGZyb20gdXBkYXRlUmVmZXJlbmNlRGF0YVxuICAgIHByaXZhdGUgdXBkYXRlQmxvY2tTY3JvbGxQb3MgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHtsYXlvdXRIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoISgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDApICAmJiAodmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tYU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIGNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEgPSAoc291cmNlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVDb25maWcgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgeyBjcm9zc2NvdW50LCBsaXN0c2l6ZSB9ID0gY3JhZGxlQ29uZmlnLFxuICAgICAgICAgICAgeyBvcmllbnRhdGlvbiB9ID0gY3JhZGxlUHJvcHNcblxuICAgICAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoLCBzY3JvbGxibG9ja09mZnNldFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlUHJvcHMuY2VsbEhlaWdodCArIGNyYWRsZVByb3BzLmdhcFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tPZmZzZXQgPSBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrT2Zmc2V0ID0gc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF4aXNQaXhlbE9mZnNldCA9IGNlbGxMZW5ndGggLSAoKHNjcm9sbFBvcyArIHNjcm9sbGJsb2NrT2Zmc2V0KSAlIGNlbGxMZW5ndGgpXG4gICAgICAgIGlmIChheGlzUGl4ZWxPZmZzZXQgPT0gKGNlbGxMZW5ndGggKyBjcmFkbGVQcm9wcy5wYWRkaW5nKSkge1xuICAgICAgICAgICAgYXhpc1BpeGVsT2Zmc2V0ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXhpc1Jvd0luZGV4ID0gTWF0aC5jZWlsKChzY3JvbGxQb3MgLSBjcmFkbGVQcm9wcy5wYWRkaW5nKS9jZWxsTGVuZ3RoKVxuXG4gICAgICAgIGxldCBheGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUm93SW5kZXggKiBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKGF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG5cbiAgICAgICAgY29uc3QgZGlmZiA9IGF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnRcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4IC09IGRpZmZcblxuICAgICAgICBpZiAoYXhpc1JlZmVyZW5jZUluZGV4ID09IDApIGF4aXNQaXhlbE9mZnNldCA9IDAgLy8gZGVmZW5zaXZlXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXJcblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNQaXhlbE9mZnNldFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiU2Nyb2xsSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJzaWduYWxzIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiaW50ZXJydXB0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsIl9pc0lPU3Njcm9sbGluZyIsIl9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiX2lPU3NldFRpbWVvdXRUaW1lcmlkIiwic2V0VGltZW91dCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsIl9pT1NzY3JvbGx0aW1lcmlkIiwib3JpZW50YXRpb24iLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwic2Nyb2xsYmxvY2tFbGVtZW50IiwiZmlyc3RDaGlsZCIsInNjcm9sbGJsb2NrTGVuZ3RoIiwidmlld3BvcnRMZW5ndGgiLCJibG9ja1Njcm9sbFBvcyIsInNjcm9sbGJsb2NrT2Zmc2V0Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwib2Zmc2V0VG9wIiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjcm9sbExlZnQiLCJvZmZzZXRMZWZ0IiwiaU9Tb25BZnRlclNjcm9sbCIsInN0eWxlIiwib3ZlcmZsb3ciLCJ0b3AiLCJsZWZ0Iiwic3RhcnQiLCJwcmV2aW91cyIsInByZXZpb3VzdXBkYXRlIiwiY3VycmVudHVwZGF0ZSIsInNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsRGF0YSIsImUiLCJzY3JvbGxlcklEIiwiT05BRlRFUlNDUk9MTF9USU1FT1VUIiwiY3VycmVudFRhcmdldCIsInNjcm9sbFBvc2l0aW9uQ3VycmVudCIsInNjcm9sbFhQb3NpdGlvbkN1cnJlbnQiLCJfc2Nyb2xsdGltZXJpZCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiaXNTY3JvbGxpbmciLCJsYXlvdXRIYW5kbGVyIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYmxvY2tYU2Nyb2xsUG9zIiwic3RhdGVIYW5kbGVyIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImlzUmVzaXppbmciLCJjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhIiwic2V0Q3JhZGxlU3RhdGUiLCJvbkFmdGVyU2Nyb2xsIiwiY29udGVudEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJ1cGRhdGVCbG9ja1Njcm9sbFBvcyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJpc01vdW50ZWRSZWYiLCJ1cGRhdGVSZWZlcmVuY2VEYXRhIiwiY2FjaGUiLCJwYXJlQ2FjaGVUb01heCIsImNyYWRsZVByb3BzIiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsImF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJzb3VyY2UiLCJjcmFkbGVDb25maWciLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJzY3JvbGxQb3MiLCJjZWxsTGVuZ3RoIiwiY2VsbEhlaWdodCIsImdhcCIsImNlbGxXaWR0aCIsImF4aXNQaXhlbE9mZnNldCIsInBhZGRpbmciLCJheGlzUm93SW5kZXgiLCJNYXRoIiwiY2VpbCIsImF4aXNSZWZlcmVuY2VJbmRleCIsIm1pbiIsImRpZmYiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// servicehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streams, see the constructor.\n\n    The function calls avaiable to the host are:\n\n        scrollToIndex,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n\n        insertIndex,\n        removeIndex,\n        moveIndex,\n        remapIndexes,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions for these in cacheHandler and contentHandler. stateHandler is\n    often invoked by service functions to change Cradle state upon servicing requests.\n*/\nvar isBlank = function isBlank(value) {\n  var testvalue = value !== null && value !== void 0 ? value : '';\n  return testvalue === '';\n};\nvar isNumber = function isNumber(value) {\n  return !isNaN(Number(value)) && !isNaN(parseInt(value));\n};\nvar isInteger = function isInteger(value) {\n  var test = +value;\n  return isNumber(value) && Math.floor(test) == test;\n};\nvar minValue = function minValue(value, _minValue) {\n  if (!isInteger(value) || !isInteger(_minValue)) return false;\n  var testvalue = +value;\n  var testMinValue = +_minValue;\n  return testvalue >= testMinValue;\n};\nvar maxValue = function maxValue(value, _maxValue) {\n  if (!isInteger(value) || !isInteger(_maxValue)) return false;\n  var testvalue = +value;\n  var testMaxValue = +_maxValue;\n  return testvalue <= testMaxValue;\n};\nvar errorMessages = {\n  scrollToIndex: 'integer: required, greater than or equal to 0',\n  setListsize: 'integer: required, greater than or equal to 0',\n  insertFrom: 'insertFrom - integer: required, greater than or equal to 0',\n  insertRange: 'insertRange - blank, or integer greater than or equal to the \"from\" index',\n  removeFrom: 'removeFrom - integer: required, greater than or equal to 0',\n  removeRange: 'removeRange - blank, or integer greater than or equal to the \"from\" index',\n  moveFrom: 'moveFrom - integer: required, greater than or equal to 0',\n  moveRange: 'moveRange - blank, or integer greater than or equal to the \"from\" index',\n  moveTo: 'moveTo - integer: required, greater than or equal to 0'\n};\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ServiceHandler);\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState('reload');\n  };\n  this.scrollToIndex = function (index) {\n    var isInvalid = !isInteger(index) || !minValue(index, 0);\n    index = +index;\n    if (isInvalid) {\n      console.log('RIGS ERROR scrollToIndex(index)):', index, errorMessages.scrollToIndex);\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      layoutHandler = _this$cradleParameter.layoutHandler,\n      stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState('scrollto');\n  };\n  this.setListsize = function (newlistsize) {\n    var isInvalid = !isInteger(newlistsize) || !minValue(newlistsize, 0);\n    newlistsize = +newlistsize;\n    if (isInvalid) {\n      console.log('RIGS ERROR setListsize(newlistsize)', newlistsize, errorMessages.setListsize);\n      return;\n    }\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter2.cacheHandler,\n      stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n      deleteListCallback = _this$callbacks.deleteListCallback,\n      changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback('change list size intervention', deleteList);\n      };\n    }\n    cacheHandler.changeListsize(newlistsize, dListCallback, changeListsizeCallback);\n    if (cache == 'preload' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState('startpreload');\n    }\n  };\n  // ======================[ GET SNAPSHOTS ]========================\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter3.cacheHandler,\n      contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  };\n  // =================[ CACHE MANAGEMENT REQUESTS ]==================\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState('clearcache');\n  };\n  // itemID set to null deletes the indexed item\n  // itemID set to undefined replaces the indexed item\n  // the main purpose is to allow itemsIDs to be remapped to new indexes\n  // operations are on existing cache items only\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter4.cacheHandler,\n      contentHandler = _this$cradleParameter4.contentHandler,\n      stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n      metadataMap = _cacheHandler$cachePr.metadataMap,\n      indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var indexesToReplaceItemIDList = [];\n    var partitionItemsToReplaceList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map();\n    // =====================[ PREPARE ]======================\n    // -----------------------[ isolate indexes for which items should be replaced ]--------------\n    var workingChangeMap = new Map();\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === undefined) {\n        if (indexToItemIDMap.has(index)) {\n          var cacheItemID = indexToItemIDMap.get(index);\n          indexesToReplaceItemIDList.push(index);\n          if (!(cacheItemID === undefined)) {\n            // ignore non-existent indexes\n            var _metadataMap$get = metadataMap.get(cacheItemID),\n              partitionID = _metadataMap$get.partitionID;\n            partitionItemsToReplaceList.push({\n              partitionID: partitionID,\n              itemID: cacheItemID\n            });\n          }\n        } else {\n          errorEntriesMap.set(index, 'index to replace is not in cache');\n        }\n      } else {\n        workingChangeMap.set(index, itemID);\n      }\n    });\n    indexesToReplaceItemIDList.forEach(function (index) {\n      indexToItemIDMap[\"delete\"](index);\n    });\n    // ------------ filter out inoperable indexes and itemIDs ------------\n    var itemsToReplaceSet = new Set();\n    partitionItemsToReplaceList.forEach(function (obj) {\n      itemsToReplaceSet.add(obj.itemID);\n    });\n    // const itemsToReplaceList = Array.from(itemsToReplaceSet)\n    workingChangeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == 'string') {\n          errorEntriesMap.set(index, 'itemID is a string');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, 'itemID is not an integer');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, 'index not in cache');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" has not changed\"));\n        } else if (!metadataMap.has(itemID) || itemsToReplaceSet.has(itemID)) {\n          errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" not in cache, or has been removed\"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    });\n    // -------------- filter out duplicate itemIDs ------------\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" has duplicates (\").concat(count, \")\"));\n        changeIndexToItemIDMap[\"delete\"](index);\n      });\n    }\n    // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n    var originalMap = new Map(); // index => itemID; before change\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    });\n    // ... and from the list of indexes to be deleted\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    });\n    // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID's will be orphaned, but could be remapped.\n    // orphans are resolved below\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap[\"delete\"](index);\n      });\n    }\n    // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n    var processedIndexList = [];\n    // make changes\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n      processedIndexList.push(index);\n    });\n    // -------------- look for and delete item and index orphans --------------------\n    // if the original item's index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item's index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n    var deletedIndexToItemIDMap = new Map();\n    var portalItemHoldForDeleteList = []; // hold deleted portals for deletion until after cradle synch\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        var _metadataMap$get2 = metadataMap.get(originalItemID),\n          partitionID = _metadataMap$get2.partitionID;\n        portalItemHoldForDeleteList.push({\n          itemID: originalItemID,\n          partitionID: partitionID\n        });\n        metadataMap[\"delete\"](originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap[\"delete\"](originalItemIDIndex);\n          }\n        }\n      }\n    });\n    // refresh the changed cache\n    // cacheHandler.cacheProps.partitionModified = true\n    // cacheHandler.renderPortalLists()\n    // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys());\n    // for return information...\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n    contentHandler.createNewItemIDs(indexesToReplaceItemIDList);\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    modifiedIndexList = modifiedIndexList.concat(indexesToReplaceItemIDList);\n    cacheHandler.portalItemHoldForDeleteList = portalItemHoldForDeleteList.concat(partitionItemsToReplaceList);\n    stateHandler.setCradleState('applycellframechanges');\n    // ---------- returns for user information --------------------\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, indexesToReplaceItemIDList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  };\n  // move must be entirely within list bounds\n  // returns list of processed indexes\n  this.moveIndex = function (toindex, fromindex) {\n    var highrange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var isToindexInvalid = !isInteger(toindex) || !minValue(toindex, 0);\n    var isFromindexInvalid = !isInteger(fromindex) || !minValue(fromindex, 0);\n    var isHighrangeInvalid = false;\n    if (!isBlank(highrange) && !isFromindexInvalid) {\n      isHighrangeInvalid = !minValue(highrange, fromindex);\n    }\n    toindex = +toindex;\n    fromindex = +fromindex;\n    highrange = highrange !== null && highrange !== void 0 ? highrange : fromindex;\n    highrange = +highrange;\n    if (isToindexInvalid || isFromindexInvalid || isHighrangeInvalid) {\n      console.log('RIGS ERROR moveIndex(toindex, fromindex, highrange)');\n      isToindexInvalid && console.log(toindex, errorMessages.moveTo);\n      isFromindexInvalid && console.log(fromindex, errorMessages.moveFrom);\n      isHighrangeInvalid && console.log(highrange, errorMessages.moveRange);\n      return null;\n    }\n    // ------------- define parameters ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    // keep within current list size\n    var listbound = listsize - 1;\n    toindex = toindex > listbound ? listbound : toindex;\n    fromindex = fromindex > listbound ? listbound : fromindex;\n    highrange = highrange > listbound ? listbound : highrange;\n    // highrange must be >= fromindex\n    highrange = highrange >= fromindex ? highrange : fromindex;\n    var rangeincrement = highrange - fromindex + 1;\n    var moveincrement = toindex - fromindex;\n    // ---------- constrain parameters --------------\n    if (fromindex == toindex) return []; // nothing to do\n    // move must be in list bounds\n    if (moveincrement > 0) {\n      // move up\n      var targettop = toindex + (rangeincrement - 1);\n      if (targettop > listbound) return []; // out of bounds\n    }\n    // ----------- perform cache and cradle operations -----------\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter5.cacheHandler,\n      contentHandler = _this$cradleParameter5.contentHandler,\n      stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList = cacheHandler.moveIndex(toindex, fromindex, highrange);\n    if (processedIndexList.length) {\n      contentHandler.changeCradleItemIDs(processedIndexList);\n      stateHandler.setCradleState('applycellframechanges');\n    }\n    return processedIndexList;\n  };\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isBlank(rangehighindex) && !isIndexInvalid) {\n      isHighrangeInvalid = !minValue(rangehighindex, index);\n    }\n    index = +index;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log('RIGS ERROR insertIndex(index, rangehighindex)');\n      isIndexInvalid && console.log(index, errorMessages.insertFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.insertRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isBlank(rangehighindex) && !isIndexInvalid) {\n      isHighrangeInvalid = !minValue(rangehighindex, index);\n    }\n    index = +index;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log('RIGS ERROR moveIndex(index, rangehighindex)');\n      isIndexInvalid && console.log(index, errorMessages.removeFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.removeRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  };\n  // shared logic. Returns lists of items changed, and items replaced (new items for insert)\n  // this operation changes the listsize\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    index = index !== null && index !== void 0 ? index : 0;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter6.cacheHandler,\n      contentHandler = _this$cradleParameter6.contentHandler,\n      stateHandler = _this$cradleParameter6.stateHandler;\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n      _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 4),\n      changeList = _cacheHandler$insertR2[0],\n      replaceList = _cacheHandler$insertR2[1],\n      rangeincrement = _cacheHandler$insertR2[2],\n      portalItemHoldForDeleteList = _cacheHandler$insertR2[3];\n    cacheHandler.portalItemHoldForDeleteList = portalItemHoldForDeleteList;\n    contentHandler.changeCradleItemIDs(changeList);\n    if (increment == +1) contentHandler.createNewItemIDs(replaceList);\n    // const { content } = contentHandler\n    stateHandler.setCradleState('applycellframechanges');\n    var changecount = rangeincrement; // semantics\n    var newlistsize = listsize + changecount;\n    _this.setListsize(newlistsize);\n    return [changeList, replaceList];\n  };\n  this.cradleParameters = cradleParameters;\n  // doing this explicitly here for documentation\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n    referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n    preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n    deleteListCallback = _cradleParameters$ext.deleteListCallback,\n    changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n    itemExceptionCallback = _cradleParameters$ext.itemExceptionCallback,\n    repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback,\n    repositioningIndexCallback = _cradleParameters$ext.repositioningIndexCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionCallback: itemExceptionCallback,\n    repositioningFlagCallback: repositioningFlagCallback,\n    repositioningIndexCallback: repositioningIndexCallback\n  };\n  this.callbacks = callbacks;\n});\nexports[\"default\"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGdCQUFnQjtFQUV4QztFQUNBLDRCQVNJQSxnQkFBZ0IsQ0FBQzZHLG9CQUFvQixDQUFDMUcsT0FBTztJQVI3QzJHLHNCQUFzQix5QkFBdEJBLHNCQUFzQjtJQUN0QkMsb0JBQW9CLHlCQUFwQkEsb0JBQW9CO0lBQ3BCNUYsa0JBQWtCLHlCQUFsQkEsa0JBQWtCO0lBQ2xCQyxzQkFBc0IseUJBQXRCQSxzQkFBc0I7SUFDdEI0RixxQkFBcUIseUJBQXJCQSxxQkFBcUI7SUFDckJDLHlCQUF5Qix5QkFBekJBLHlCQUF5QjtJQUN6QkMsMEJBQTBCLHlCQUExQkEsMEJBQTBCO0VBSTlCLElBQU1oRyxTQUFTLEdBQUc7SUFDZDRGLHNCQUFzQixFQUF0QkEsc0JBQXNCO0lBQ3RCQyxvQkFBb0IsRUFBcEJBLG9CQUFvQjtJQUNwQjVGLGtCQUFrQixFQUFsQkEsa0JBQWtCO0lBQ2xCQyxzQkFBc0IsRUFBdEJBLHNCQUFzQjtJQUN0QjRGLHFCQUFxQixFQUFyQkEscUJBQXFCO0lBQ3JCQyx5QkFBeUIsRUFBekJBLHlCQUF5QjtJQUN6QkMsMEJBQTBCLEVBQTFCQTtHQUNIO0VBRUQsSUFBSSxDQUFDaEcsU0FBUyxHQUFHQSxTQUFTO0FBRTdCLENBQUM7QUE5QkxpRyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zZXJ2aWNlaGFuZGxlci50c3g/OWNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgZmllbGRzIHNlcnZpY2UgcmVxdWVzdHMgZnJvbSB0aGUgaG9zdC4gVGhlcmUgYXJlIHR3byBmb3Jtc1xuICAgIC0gc3RyZWFtaW5nIGZyb20gdGhlIHNjcm9sbGVyIHRvIHRoZSBob3N0XG4gICAgLSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSB1c2VyIHRvIHRoZSBzY3JvbGxlclxuXG4gICAgRm9yIHRoZSBsaXN0IG9mIGRhdGEgc3RyZWFtcywgc2VlIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAgIFRoZSBmdW5jdGlvbiBjYWxscyBhdmFpYWJsZSB0byB0aGUgaG9zdCBhcmU6XG5cbiAgICAgICAgc2Nyb2xsVG9JbmRleCwgXG4gICAgICAgIHJlbG9hZCwgXG4gICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICBjbGVhckNhY2hlLCBcblxuICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgZ2V0Q2FjaGVJdGVtTWFwLFxuICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcblxuICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgcmVtb3ZlSW5kZXgsXG4gICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgIFxuICAgIFRoZSBmdW5jdGlvbnMgbGlzdGVkIGFyZSBkZWZpbmVkIGluIHRoaXMgbW9kdWxlLlxuXG4gICAgVGhlcmUgYXJlIGltcG9ydGFudCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBmb3IgdGhlc2UgaW4gY2FjaGVIYW5kbGVyIGFuZCBjb250ZW50SGFuZGxlci4gc3RhdGVIYW5kbGVyIGlzXG4gICAgb2Z0ZW4gaW52b2tlZCBieSBzZXJ2aWNlIGZ1bmN0aW9ucyB0byBjaGFuZ2UgQ3JhZGxlIHN0YXRlIHVwb24gc2VydmljaW5nIHJlcXVlc3RzLlxuKi9cblxuY29uc3QgaXNCbGFuayA9ICh2YWx1ZTphbnkpID0+IHtcbiAgICBjb25zdCB0ZXN0dmFsdWUgPSB2YWx1ZSA/PyAnJ1xuICAgIHJldHVybiB0ZXN0dmFsdWUgPT09ICcnXG59XG5cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlOmFueSkgPT4ge1xuXG4gICAgcmV0dXJuICggXG4gICAgICAgICghaXNOYU4oTnVtYmVyKHZhbHVlKSkpICYmIFxuICAgICAgICAoIWlzTmFOKHBhcnNlSW50KHZhbHVlKSkpIFxuICAgIClcblxufVxuXG5jb25zdCBpc0ludGVnZXIgPSAodmFsdWU6YW55KSA9PiB7XG5cbiAgICBjb25zdCB0ZXN0ID0gK3ZhbHVlXG5cbiAgICByZXR1cm4gKGlzTnVtYmVyKHZhbHVlKSAmJiAoTWF0aC5mbG9vcih0ZXN0KSA9PSB0ZXN0KSlcblxufVxuXG5jb25zdCBtaW5WYWx1ZSA9ICh2YWx1ZTphbnksIG1pblZhbHVlOmFueSkgPT4ge1xuXG4gICAgaWYgKCFpc0ludGVnZXIodmFsdWUpIHx8ICFpc0ludGVnZXIobWluVmFsdWUpKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHRlc3R2YWx1ZSA9ICt2YWx1ZVxuICAgIGNvbnN0IHRlc3RNaW5WYWx1ZSA9ICttaW5WYWx1ZVxuXG4gICAgcmV0dXJuIHRlc3R2YWx1ZSA+PSB0ZXN0TWluVmFsdWVcblxufVxuXG5jb25zdCBtYXhWYWx1ZSA9ICh2YWx1ZTphbnksIG1heFZhbHVlOmFueSkgPT4ge1xuXG4gICAgaWYgKCFpc0ludGVnZXIodmFsdWUpIHx8ICFpc0ludGVnZXIobWF4VmFsdWUpKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHRlc3R2YWx1ZSA9ICt2YWx1ZVxuICAgIGNvbnN0IHRlc3RNYXhWYWx1ZSA9ICttYXhWYWx1ZVxuXG4gICAgcmV0dXJuIHRlc3R2YWx1ZSA8PSB0ZXN0TWF4VmFsdWVcblxufVxuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIHNjcm9sbFRvSW5kZXg6J2ludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG4gICAgc2V0TGlzdHNpemU6J2ludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG4gICAgaW5zZXJ0RnJvbTonaW5zZXJ0RnJvbSAtIGludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG4gICAgaW5zZXJ0UmFuZ2U6J2luc2VydFJhbmdlIC0gYmxhbmssIG9yIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBcImZyb21cIiBpbmRleCcsXG4gICAgcmVtb3ZlRnJvbToncmVtb3ZlRnJvbSAtIGludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG4gICAgcmVtb3ZlUmFuZ2U6J3JlbW92ZVJhbmdlIC0gYmxhbmssIG9yIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBcImZyb21cIiBpbmRleCcsXG4gICAgbW92ZUZyb206J21vdmVGcm9tIC0gaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbiAgICBtb3ZlUmFuZ2U6J21vdmVSYW5nZSAtIGJsYW5rLCBvciBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgXCJmcm9tXCIgaW5kZXgnLFxuICAgIG1vdmVUbzonbW92ZVRvIC0gaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VydmljZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgLy8gZG9pbmcgdGhpcyBleHBsaWNpdGx5IGhlcmUgZm9yIGRvY3VtZW50YXRpb25cbiAgICAgICBjb25zdCB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssIC8vIChpbmRleCwgbG9jYXRpb24sIGNyYWRsZVN0YXRlKVxuICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjaywgLy8gKGluZGV4KVxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssIC8vIChyZWFzb24sIGRlbGV0ZUxpc3QpXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssIC8vIChuZXdsaXN0c2l6ZSlcbiAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLCAvLyAoaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsIGxvY2F0aW9uLCBlcnJvcilcbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjaywgLy8gKGZsYWcpIC8vIGJvb2xlYW5cbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIFxuICAgICAgIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmV4dGVybmFsQ2FsbGJhY2tzUmVmLmN1cnJlbnRcblxuICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjayxcbiAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjayxcbiAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLFxuICAgICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFja1xuICAgICAgIH1cblxuICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIC8vIHNlZSBhYm92ZSBmb3IgbGlzdFxuICAgIHB1YmxpYyBjYWxsYmFja3NcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PVsgR0VORVJBTCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIHJlbG9hZCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0YXRlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGludGVycnVwdEhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVsb2FkJylcblxuICAgIH1cblxuICAgIHB1YmxpYyBzY3JvbGxUb0luZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgY29uc3QgaXNJbnZhbGlkID0gKCFpc0ludGVnZXIoaW5kZXgpIHx8ICFtaW5WYWx1ZShpbmRleCwgMCkpXG5cbiAgICAgICAgaW5kZXggPSAraW5kZXhcblxuICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSSUdTIEVSUk9SIHNjcm9sbFRvSW5kZXgoaW5kZXgpKTonLCBpbmRleCwgZXJyb3JNZXNzYWdlcy5zY3JvbGxUb0luZGV4KVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuICAgICAgICBjb25zdCB7IGxheW91dEhhbmRsZXIsIHN0YXRlSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IGluZGV4XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzY3JvbGx0bycpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0TGlzdHNpemUgPSAobmV3bGlzdHNpemUpID0+IHtcblxuICAgICAgICBjb25zdCBpc0ludmFsaWQgPSAoIWlzSW50ZWdlcihuZXdsaXN0c2l6ZSkgfHwgIW1pblZhbHVlKG5ld2xpc3RzaXplLCAwKSlcblxuICAgICAgICBuZXdsaXN0c2l6ZSA9ICtuZXdsaXN0c2l6ZVxuXG4gICAgICAgIGlmIChpc0ludmFsaWQpIHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1Igc2V0TGlzdHNpemUobmV3bGlzdHNpemUpJywgbmV3bGlzdHNpemUsIGVycm9yTWVzc2FnZXMuc2V0TGlzdHNpemUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjayB9ID0gdGhpcy5jYWxsYmFja3NcblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplOmN1cnJlbnRsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnY2hhbmdlIGxpc3Qgc2l6ZSBpbnRlcnZlbnRpb24nLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLmNoYW5nZUxpc3RzaXplKG5ld2xpc3RzaXplLCBcbiAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrXG4gICAgICAgIClcblxuICAgICAgICBpZiAoKGNhY2hlID09ICdwcmVsb2FkJykgJiYgKG5ld2xpc3RzaXplID4gY3VycmVudGxpc3RzaXplKSkge1xuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBHRVQgU05BUFNIT1RTIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBnZXRDYWNoZUluZGV4TWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJbmRleE1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJdGVtTWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJdGVtTWFwKClcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDcmFkbGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q3JhZGxlSW5kZXhNYXAobW9kZWxJbmRleExpc3QpXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT1bIENBQ0hFIE1BTkFHRU1FTlQgUkVRVUVTVFMgXT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdjbGVhcmNhY2hlJylcblxuICAgIH1cblxuICAgIC8vIGl0ZW1JRCBzZXQgdG8gbnVsbCBkZWxldGVzIHRoZSBpbmRleGVkIGl0ZW1cbiAgICAvLyBpdGVtSUQgc2V0IHRvIHVuZGVmaW5lZCByZXBsYWNlcyB0aGUgaW5kZXhlZCBpdGVtXG4gICAgLy8gdGhlIG1haW4gcHVycG9zZSBpcyB0byBhbGxvdyBpdGVtc0lEcyB0byBiZSByZW1hcHBlZCB0byBuZXcgaW5kZXhlc1xuICAgIC8vIG9wZXJhdGlvbnMgYXJlIG9uIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIG9ubHlcbiAgICBwdWJsaWMgcmVtYXBJbmRleGVzID0gKGNoYW5nZU1hcCkgPT4geyAvLyBpbmRleCA9PiBpdGVtSURcblxuICAgICAgICBpZiAoY2hhbmdlTWFwLnNpemUgPT0gMCkgcmV0dXJuIFtdIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLCAvLyBpdGVtSUQgdG8gY29tcG9uZW50IGRhdGEsIGluY2x1ZGluZyBpbmRleFxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcCAvLyBpbmRleCB0byBpdGVtSURcblxuICAgICAgICB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc1RvRGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0ID0gW11cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBlcnJvckVudHJpZXNNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFBSRVBBUkUgXT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaXNvbGF0ZSBpbmRleGVzIGZvciB3aGljaCBpdGVtcyBzaG91bGQgYmUgcmVwbGFjZWQgXS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NoYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjaGFuZ2VNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVJdGVtSUQgPT09IHVuZGVmaW5lZCkpIHsgLy8gaWdub3JlIG5vbi1leGlzdGVudCBpbmRleGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IG1ldGFkYXRhTWFwLmdldChjYWNoZUl0ZW1JRClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0LnB1c2goe3BhcnRpdGlvbklELCBpdGVtSUQ6Y2FjaGVJdGVtSUR9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCAnaW5kZXggdG8gcmVwbGFjZSBpcyBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHdvcmtpbmdDaGFuZ2VNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdC5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgaW5vcGVyYWJsZSBpbmRleGVzIGFuZCBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGl0ZW1zVG9SZXBsYWNlU2V0ID0gbmV3IFNldCgpXG4gICAgICAgIHBhcnRpdGlvbkl0ZW1zVG9SZXBsYWNlTGlzdC5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgICAgIGl0ZW1zVG9SZXBsYWNlU2V0LmFkZChvYmouaXRlbUlEKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnN0IGl0ZW1zVG9SZXBsYWNlTGlzdCA9IEFycmF5LmZyb20oaXRlbXNUb1JlcGxhY2VTZXQpXG5cbiAgICAgICAgd29ya2luZ0NoYW5nZU1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PntcblxuICAgICAgICAgICAgaWYgKChpdGVtSUQgPT09IG51bGwpIHx8IChpdGVtSUQgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QucHVzaChpbmRleClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGl0ZW1JRCkgPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgYSBzdHJpbmcnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwnaXRlbUlEIGlzIG5vdCBhbiBpbnRlZ2VyJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsICdpbmRleCBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkgPT0gaXRlbUlEKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBub3QgY2hhbmdlZGApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFtZXRhZGF0YU1hcC5oYXMoaXRlbUlEKSB8fCBpdGVtc1RvUmVwbGFjZVNldC5oYXMoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBub3QgaW4gY2FjaGUsIG9yIGhhcyBiZWVuIHJlbW92ZWRgKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBmaWx0ZXIgb3V0IGR1cGxpY2F0ZSBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IG1hcHNpemUgPSBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNpemVcblxuICAgICAgICBjb25zdCBpdGVtSURTZXQgPSBuZXcgU2V0KGNoYW5nZUluZGV4VG9JdGVtSURNYXAudmFsdWVzKCkpXG5cbiAgICAgICAgY29uc3QgaXRlbXNldHNpemUgPSBpdGVtSURTZXQuc2l6ZVxuXG4gICAgICAgIGlmIChtYXBzaXplICE9IGl0ZW1zZXRzaXplKSB7IC8vIHRoZXJlIG11c3QgYmUgZHVwbGljYXRlIGl0ZW1JRHNcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEQ291bnRNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlEQ291bnRNYXAuaGFzKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCAxKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBpdGVtSURDb3VudE1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCArK2NvdW50IClcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZUl0ZW1zTWFwID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBpdGVtSURDb3VudE1hcC5mb3JFYWNoKChjb3VudCxpdGVtSUQpPT57XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlSXRlbXNNYXAuc2V0KGl0ZW1JRCwgY291bnQpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCA9IFtdXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJdGVtc01hcC5oYXMoaXRlbUlEKSkge1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LnB1c2goaW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LmZvckVhY2goKGluZGV4KT0+e1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkdXBsaWNhdGVJdGVtc01hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBkdXBsaWNhdGVzICgke2NvdW50fSlgKVxuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gY2FwdHVyZSBtYXAgYmVmb3JlIGNoYW5nZXMgLS0tLS0tLS0tLVxuICAgICAgICAvLyAuLi4gdGhpcyBtYXAgaXMgdXNlZCBsYXRlciB0byBpZGVudGlmeSBvcnBoYW5lZCBpdGVtIGFuZCBpbmRleCBjYWNoZSByZWNvcmRzIGZvciBkZWxldGlvblxuXG4gICAgICAgIC8vIGZyb20gdGhlIGxpc3Qgb2YgY2hhbmdlc1xuICAgICAgICAvLyBib3RoIHNpZGVzIG9mIGNoYW5nZSBtYXAuLi5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBiZWZvcmUgY2hhbmdlXG4gICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCk9PntcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSkgLy8gaW5kZXggdG8gYmUgbWFwcGVkXG4gICAgICAgICAgICBvcmlnaW5hbE1hcC5zZXQobWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXgsaXRlbUlEKSAvLyB0YXJnZXQgaXRlbUlEXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAuLi4gYW5kIGZyb20gdGhlIGxpc3Qgb2YgaW5kZXhlcyB0byBiZSBkZWxldGVkXG4gICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBPUEVSQVRJT05TIF09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRlbGV0ZSBsaXN0ZWQgaW5kZXhlcyAtLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIGluZGV4ZXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgaXRlbUlEJ3Mgd2lsbCBiZSBvcnBoYW5lZCwgYnV0IGNvdWxkIGJlIHJlbWFwcGVkLlxuICAgICAgICAvLyBvcnBoYW5zIGFyZSByZXNvbHZlZCBiZWxvd1xuXG4gICAgICAgIGlmIChpbmRleGVzVG9EZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gYXBwbHkgZmlsdGVyZWQgY2hhbmdlcyB0byBjYWNoZSBpbmRleCBtYXAgYW5kIGl0ZW1JRCBtYXAgLS0tLS0tLS0tLVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGV2ZXJ5IHJlbWFpbmluZyBpbmRleCBsaXN0ZWQgd2lsbCBjaGFuZ2UgaXRzIG1hcHBpbmdcblxuICAgICAgICAvLyBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICBpdGVtZGF0YS5pbmRleCA9IGluZGV4IC8vIG1vZGlmaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDJcblxuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkTWFwLnNldChpbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBwcm9jZXNzZWRJbmRleExpc3QucHVzaChpbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGxvb2sgZm9yIGFuZCBkZWxldGUgaXRlbSBhbmQgaW5kZXggb3JwaGFucyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luYWwgaXRlbSdzIGluZGV4IGhhcyBub3QgY2hhbmdlZCwgdGhlbiBpdCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIFxuICAgICAgICAvLyAgICAgaXQgaXMgb3JwaGFuZWQsIGFuZCB0aGUgaXRlbSBpcyBkZWxldGVkXG4gICAgICAgIC8vIGlmIHRoZSBpdGVtJ3MgaW5kZXggaGFzIGNoYW5nZWQsIGJ1dCB0aGUgb3JpZ2luYWwgaXRlbSBpbmRleCBtYXAgc3RpbGwgcG9pbnRzIHRvIHRoZSBpdGVtLFxuICAgICAgICAvLyAgICAgdGhlbiB0aGUgaW5kZXggaXMgb3JwaGFuZWQgKGR1cGxpY2F0ZSksIGFuZCBkZWxldGVkXG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBvcnBoYW5lZCBpbmRleFxuICAgICAgICBjb25zdCBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdCA9IFtdIC8vIGhvbGQgZGVsZXRlZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBjcmFkbGUgc3luY2hcblxuICAgICAgICBvcmlnaW5hbE1hcC5mb3JFYWNoKChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JREluZGV4ID0gbWV0YWRhdGFNYXAuZ2V0KG9yaWdpbmFsSXRlbUlEKS5pbmRleFxuXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJdGVtSURJbmRleCA9PSBmaW5hbEl0ZW1JREluZGV4KSB7IC8vIG5vdCByZW1hcHBlZCwgdGhlcmVmb3JlIG9ycGhhbmVkXG5cbiAgICAgICAgICAgICAgICBkZWxldGVkSXRlbUlEVG9JbmRleE1hcC5zZXQob3JpZ2luYWxJdGVtSUQsIG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRpdGlvbklEIH0gPSBtZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0LnB1c2goe2l0ZW1JRDpvcmlnaW5hbEl0ZW1JRCwgcGFydGl0aW9uSUR9KVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JRClcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVtYXBwZWQsIGNoZWNrIGZvciBvcnBoYW5lZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKG9yaWdpbmFsSXRlbUlESW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxJdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEl0ZW1JRCA9PSBvcmlnaW5hbEl0ZW1JRCkgeyAvLyB0aGUgaW5kZXggaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAuc2V0KG9yaWdpbmFsSXRlbUlESW5kZXgsIG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgY2hhbmdlZCBjYWNoZVxuICAgICAgICAvLyBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZCA9IHRydWVcbiAgICAgICAgLy8gY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGFwcGx5IGNoYW5nZXMgdG8gZXh0YW50IGNlbGxGcmFtZXMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHVzZWQgdG8gcmVjb25jaWxlIGNyYWRsZSBjZWxsRnJhbWVzLCBhbmQgYWxzbyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGNvbnN0IHByb2Nlc3NlZEluZGV4TGlzdCA9IEFycmF5LmZyb20ocHJvY2Vzc2VkTWFwLmtleXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAudmFsdWVzKCkpXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICAvLyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uLi4uXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QgPSBBcnJheS5mcm9tKGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLmtleXMoKSkgXG5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kZXhMaXN0ID0gW1xuICAgICAgICAgICAgLi4ucHJvY2Vzc2VkSW5kZXhMaXN0LFxuICAgICAgICAgICAgLi4uaW5kZXhlc1RvRGVsZXRlTGlzdCwgXG4gICAgICAgICAgICAuLi5kZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdFxuICAgICAgICBdXG5cbiAgICAgICAgbW9kaWZpZWRJbmRleExpc3QgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kaWZpZWRJbmRleExpc3QudmFsdWVzKCkpKSAvLyByZW1vdmUgZHVwbGljYXRlc1xuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLmNyZWF0ZU5ld0l0ZW1JRHMoaW5kZXhlc1RvUmVwbGFjZUl0ZW1JRExpc3QpXG5cbiAgICAgICAgY29udGVudEhhbmRsZXIucmVjb25jaWxlQ2VsbEZyYW1lcyhtb2RpZmllZEluZGV4TGlzdClcblxuICAgICAgICBtb2RpZmllZEluZGV4TGlzdCA9IG1vZGlmaWVkSW5kZXhMaXN0LmNvbmNhdChpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdClcblxuICAgICAgICBjYWNoZUhhbmRsZXIucG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0ID0gcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0LmNvbmNhdChwYXJ0aXRpb25JdGVtc1RvUmVwbGFjZUxpc3QpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gcmV0dXJucyBmb3IgdXNlciBpbmZvcm1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBbXG5cbiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIHByb2Nlc3NlZEluZGV4TGlzdCwgXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0LFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCwgXG4gICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJbmRleExpc3QsXG4gICAgICAgICAgICBlcnJvckVudHJpZXNNYXAsIFxuICAgICAgICAgICAgY2hhbmdlTWFwXG5cbiAgICAgICAgXVxuXG4gICAgfVxuXG4gICAgLy8gbW92ZSBtdXN0IGJlIGVudGlyZWx5IHdpdGhpbiBsaXN0IGJvdW5kc1xuICAgIC8vIHJldHVybnMgbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlc1xuICAgIHB1YmxpYyBtb3ZlSW5kZXggPSAodG9pbmRleCwgZnJvbWluZGV4LCBoaWdocmFuZ2UgPSBudWxsKSA9PiB7XG5cblxuICAgICAgICBjb25zdCBpc1RvaW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIodG9pbmRleCkgfHwgIW1pblZhbHVlKHRvaW5kZXgsIDApKVxuICAgICAgICBjb25zdCBpc0Zyb21pbmRleEludmFsaWQgPSAoIWlzSW50ZWdlcihmcm9taW5kZXgpIHx8ICFtaW5WYWx1ZShmcm9taW5kZXgsIDApKVxuICAgICAgICBsZXQgaXNIaWdocmFuZ2VJbnZhbGlkID0gZmFsc2VcbiAgICAgICAgaWYgKCghaXNCbGFuayhoaWdocmFuZ2UpKSAmJiAoIWlzRnJvbWluZGV4SW52YWxpZCkpIHtcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCA9ICFtaW5WYWx1ZShoaWdocmFuZ2UsZnJvbWluZGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgdG9pbmRleCA9ICt0b2luZGV4XG4gICAgICAgIGZyb21pbmRleCA9ICtmcm9taW5kZXhcbiAgICAgICAgaGlnaHJhbmdlID0gaGlnaHJhbmdlID8/IGZyb21pbmRleFxuICAgICAgICBoaWdocmFuZ2UgPSAraGlnaHJhbmdlXG5cbiAgICAgICAgaWYgKGlzVG9pbmRleEludmFsaWQgfHwgaXNGcm9taW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgbW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgaGlnaHJhbmdlKScpXG4gICAgICAgICAgICBpc1RvaW5kZXhJbnZhbGlkICYmIGNvbnNvbGUubG9nKHRvaW5kZXgsIGVycm9yTWVzc2FnZXMubW92ZVRvKVxuICAgICAgICAgICAgaXNGcm9taW5kZXhJbnZhbGlkICYmIGNvbnNvbGUubG9nKGZyb21pbmRleCwgZXJyb3JNZXNzYWdlcy5tb3ZlRnJvbSlcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCAmJiBjb25zb2xlLmxvZyhoaWdocmFuZ2UsIGVycm9yTWVzc2FnZXMubW92ZVJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gZGVmaW5lIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8ga2VlcCB3aXRoaW4gY3VycmVudCBsaXN0IHNpemVcbiAgICAgICAgY29uc3QgbGlzdGJvdW5kID0gbGlzdHNpemUgLSAxXG5cbiAgICAgICAgdG9pbmRleCA9IFxuICAgICAgICAgICAgKHRvaW5kZXggPiBsaXN0Ym91bmQpP1xuICAgICAgICAgICAgICAgIGxpc3Rib3VuZDpcbiAgICAgICAgICAgICAgICB0b2luZGV4XG5cbiAgICAgICAgZnJvbWluZGV4ID0gXG4gICAgICAgICAgICAoZnJvbWluZGV4ID4gbGlzdGJvdW5kKT9cbiAgICAgICAgICAgICAgICBsaXN0Ym91bmQ6XG4gICAgICAgICAgICAgICAgZnJvbWluZGV4XG5cbiAgICAgICAgaGlnaHJhbmdlID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlID4gbGlzdGJvdW5kKT9cbiAgICAgICAgICAgICAgICBsaXN0Ym91bmQ6XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlXG5cbiAgICAgICAgLy8gaGlnaHJhbmdlIG11c3QgYmUgPj0gZnJvbWluZGV4XG4gICAgICAgIGhpZ2hyYW5nZSA9IFxuICAgICAgICAgICAgKGhpZ2hyYW5nZSA+PSBmcm9taW5kZXgpP1xuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZTpcbiAgICAgICAgICAgICAgICBmcm9taW5kZXhcblxuICAgICAgICBjb25zdCByYW5nZWluY3JlbWVudCA9IGhpZ2hyYW5nZSAtIGZyb21pbmRleCArIDFcbiAgICAgICAgY29uc3QgbW92ZWluY3JlbWVudCA9IHRvaW5kZXggLSBmcm9taW5kZXhcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGNvbnN0cmFpbiBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaWYgKGZyb21pbmRleCA9PSB0b2luZGV4KSByZXR1cm4gW10gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIC8vIG1vdmUgbXVzdCBiZSBpbiBsaXN0IGJvdW5kc1xuICAgICAgICBpZiAobW92ZWluY3JlbWVudCA+IDApIHsgLy8gbW92ZSB1cFxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0dG9wID0gdG9pbmRleCArIChyYW5nZWluY3JlbWVudCAtIDEpXG4gICAgICAgICAgICBpZiAodGFyZ2V0dG9wID4gbGlzdGJvdW5kKSByZXR1cm4gW10gLy8gb3V0IG9mIGJvdW5kc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gcGVyZm9ybSBjYWNoZSBhbmQgY3JhZGxlIG9wZXJhdGlvbnMgLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEluZGV4TGlzdCA9IFxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLm1vdmVJbmRleCh0b2luZGV4LCBmcm9taW5kZXgsIGhpZ2hyYW5nZSlcblxuICAgICAgICBpZiAocHJvY2Vzc2VkSW5kZXhMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5jaGFuZ2VDcmFkbGVJdGVtSURzKHByb2Nlc3NlZEluZGV4TGlzdClcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhMaXN0XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgaW5zZXJ0SW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIoaW5kZXgpIHx8ICFtaW5WYWx1ZShpbmRleCwgMCkpXG4gICAgICAgIGxldCBpc0hpZ2hyYW5nZUludmFsaWQgPSBmYWxzZVxuICAgICAgICBpZiAoKCFpc0JsYW5rKHJhbmdlaGlnaGluZGV4KSkgJiYgKCFpc0luZGV4SW52YWxpZCkpIHtcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCA9ICFtaW5WYWx1ZShyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICtpbmRleFxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IHJhbmdlaGlnaGluZGV4ID8/IGluZGV4XG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gK3JhbmdlaGlnaGluZGV4XG5cbiAgICAgICAgaWYgKGlzSW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgaW5zZXJ0SW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4KScpXG4gICAgICAgICAgICBpc0luZGV4SW52YWxpZCAmJiBjb25zb2xlLmxvZyhpbmRleCwgZXJyb3JNZXNzYWdlcy5pbnNlcnRGcm9tKVxuICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkICYmIGNvbnNvbGUubG9nKHJhbmdlaGlnaGluZGV4LCBlcnJvck1lc3NhZ2VzLmluc2VydFJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgKzEpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIoaW5kZXgpIHx8ICFtaW5WYWx1ZShpbmRleCwgMCkpXG4gICAgICAgIGxldCBpc0hpZ2hyYW5nZUludmFsaWQgPSBmYWxzZVxuICAgICAgICBpZiAoKCFpc0JsYW5rKHJhbmdlaGlnaGluZGV4KSkgJiYgKCFpc0luZGV4SW52YWxpZCkpIHtcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCA9ICFtaW5WYWx1ZShyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICtpbmRleFxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IHJhbmdlaGlnaGluZGV4ID8/IGluZGV4XG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gK3JhbmdlaGlnaGluZGV4XG5cbiAgICAgICAgaWYgKGlzSW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCknKVxuICAgICAgICAgICAgaXNJbmRleEludmFsaWQgJiYgY29uc29sZS5sb2coaW5kZXgsIGVycm9yTWVzc2FnZXMucmVtb3ZlRnJvbSlcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCAmJiBjb25zb2xlLmxvZyhyYW5nZWhpZ2hpbmRleCwgZXJyb3JNZXNzYWdlcy5yZW1vdmVSYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRSZW1vdmVJbmRleChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIC0xKVxuXG4gICAgfVxuXG4gICAgLy8gc2hhcmVkIGxvZ2ljLiBSZXR1cm5zIGxpc3RzIG9mIGl0ZW1zIGNoYW5nZWQsIGFuZCBpdGVtcyByZXBsYWNlZCAobmV3IGl0ZW1zIGZvciBpbnNlcnQpXG4gICAgLy8gdGhpcyBvcGVyYXRpb24gY2hhbmdlcyB0aGUgbGlzdHNpemVcbiAgICBwcml2YXRlIGluc2VydFJlbW92ZUluZGV4ID0gKGluZGV4LCByYW5nZWhpZ2hpbmRleCwgaW5jcmVtZW50KSA9PiB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCA/PyAwXG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gcmFuZ2VoaWdoaW5kZXggPz8gaW5kZXhcblxuICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsaW5kZXgpXG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gTWF0aC5tYXgocmFuZ2VoaWdoaW5kZXgsIGluZGV4KVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc3RhdGVIYW5kbGVyIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgW2NoYW5nZUxpc3QsIHJlcGxhY2VMaXN0LCByYW5nZWluY3JlbWVudCwgcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0XSA9IFxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgaW5jcmVtZW50LCBsaXN0c2l6ZSlcblxuICAgICAgICBjYWNoZUhhbmRsZXIucG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0ID0gcG9ydGFsSXRlbUhvbGRGb3JEZWxldGVMaXN0XG5cbiAgICAgICAgY29udGVudEhhbmRsZXIuY2hhbmdlQ3JhZGxlSXRlbUlEcyhjaGFuZ2VMaXN0KVxuXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gKzEpIGNvbnRlbnRIYW5kbGVyLmNyZWF0ZU5ld0l0ZW1JRHMocmVwbGFjZUxpc3QpXG5cbiAgICAgICAgLy8gY29uc3QgeyBjb250ZW50IH0gPSBjb250ZW50SGFuZGxlclxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnYXBwbHljZWxsZnJhbWVjaGFuZ2VzJylcblxuICAgICAgICBjb25zdCBjaGFuZ2Vjb3VudCA9IHJhbmdlaW5jcmVtZW50IC8vIHNlbWFudGljc1xuICAgICAgICBjb25zdCBuZXdsaXN0c2l6ZSA9IGxpc3RzaXplICsgY2hhbmdlY291bnQgXG5cbiAgICAgICAgdGhpcy5zZXRMaXN0c2l6ZShuZXdsaXN0c2l6ZSlcblxuICAgICAgICByZXR1cm4gW2NoYW5nZUxpc3QsIHJlcGxhY2VMaXN0XVxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiaXNCbGFuayIsInZhbHVlIiwidGVzdHZhbHVlIiwiaXNOdW1iZXIiLCJpc05hTiIsIk51bWJlciIsInBhcnNlSW50IiwiaXNJbnRlZ2VyIiwidGVzdCIsIk1hdGgiLCJmbG9vciIsIm1pblZhbHVlIiwidGVzdE1pblZhbHVlIiwibWF4VmFsdWUiLCJ0ZXN0TWF4VmFsdWUiLCJlcnJvck1lc3NhZ2VzIiwic2Nyb2xsVG9JbmRleCIsInNldExpc3RzaXplIiwiaW5zZXJ0RnJvbSIsImluc2VydFJhbmdlIiwicmVtb3ZlRnJvbSIsInJlbW92ZVJhbmdlIiwibW92ZUZyb20iLCJtb3ZlUmFuZ2UiLCJtb3ZlVG8iLCJTZXJ2aWNlSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJzdGF0ZUhhbmRsZXIiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJpbnRlcnJ1cHRIYW5kbGVyIiwicGF1c2VJbnRlcnJ1cHRzIiwic2V0Q3JhZGxlU3RhdGUiLCJpbmRleCIsImlzSW52YWxpZCIsImNvbnNvbGUiLCJsb2ciLCJzaWduYWxzIiwibGF5b3V0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsImNyYWRsZVBvc2l0aW9uRGF0YSIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsIm5ld2xpc3RzaXplIiwiY2FjaGVIYW5kbGVyIiwiY2FsbGJhY2tzIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsImN1cnJlbnRsaXN0c2l6ZSIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImxpc3RzaXplIiwiY2FjaGUiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJjaGFuZ2VMaXN0c2l6ZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJjb250ZW50SGFuZGxlciIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJnZXRDcmFkbGVJbmRleE1hcCIsImNoYW5nZU1hcCIsInNpemUiLCJjYWNoZVByb3BzIiwibWV0YWRhdGFNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwiaW5kZXhlc1RvRGVsZXRlTGlzdCIsImluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0IiwicGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0IiwiY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCIsIk1hcCIsImVycm9yRW50cmllc01hcCIsIndvcmtpbmdDaGFuZ2VNYXAiLCJmb3JFYWNoIiwiaXRlbUlEIiwidW5kZWZpbmVkIiwiaGFzIiwiY2FjaGVJdGVtSUQiLCJnZXQiLCJwdXNoIiwicGFydGl0aW9uSUQiLCJzZXQiLCJpdGVtc1RvUmVwbGFjZVNldCIsIlNldCIsIm9iaiIsImFkZCIsIm1hcHNpemUiLCJpdGVtSURTZXQiLCJ2YWx1ZXMiLCJpdGVtc2V0c2l6ZSIsIml0ZW1JRENvdW50TWFwIiwiY291bnQiLCJkdXBsaWNhdGVJdGVtc01hcCIsImR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QiLCJvcmlnaW5hbE1hcCIsImxlbmd0aCIsInByb2Nlc3NlZEluZGV4TGlzdCIsIml0ZW1kYXRhIiwiZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAiLCJkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCIsInBvcnRhbEl0ZW1Ib2xkRm9yRGVsZXRlTGlzdCIsIm9yaWdpbmFsSXRlbUlEIiwib3JpZ2luYWxJdGVtSURJbmRleCIsImZpbmFsSXRlbUlESW5kZXgiLCJmaW5hbEl0ZW1JRCIsImRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QiLCJBcnJheSIsImZyb20iLCJkZWxldGVkT3JwaGFuZWRJbmRleExpc3QiLCJrZXlzIiwiZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCIsIm1vZGlmaWVkSW5kZXhMaXN0IiwiY3JlYXRlTmV3SXRlbUlEcyIsInJlY29uY2lsZUNlbGxGcmFtZXMiLCJjb25jYXQiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiaGlnaHJhbmdlIiwiaXNUb2luZGV4SW52YWxpZCIsImlzRnJvbWluZGV4SW52YWxpZCIsImlzSGlnaHJhbmdlSW52YWxpZCIsImxpc3Rib3VuZCIsInJhbmdlaW5jcmVtZW50IiwibW92ZWluY3JlbWVudCIsInRhcmdldHRvcCIsIm1vdmVJbmRleCIsImNoYW5nZUNyYWRsZUl0ZW1JRHMiLCJyYW5nZWhpZ2hpbmRleCIsImlzSW5kZXhJbnZhbGlkIiwiaW5zZXJ0UmVtb3ZlSW5kZXgiLCJpbmNyZW1lbnQiLCJtYXgiLCJjaGFuZ2VMaXN0IiwicmVwbGFjZUxpc3QiLCJjaGFuZ2Vjb3VudCIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInByZWxvYWRJbmRleENhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsInJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n")},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// statehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to the cradle state and the state setting for other handlers.\n   It also provides access to the isMountedRef reference.\n*/\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOzs7O0FBRUE7Ozs7QUFBQSxJQUtxQkEsWUFBWSw2QkFFN0Isc0JBQVlDLGdCQUFnQjtFQUFBO0VBRXpCLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBLGdCQUFnQjtFQUV4QyxJQUFNQyxrQkFBa0IsR0FBR0QsZ0JBQWdCLENBQUNFLDJCQUEyQixDQUFDQyxPQUFPO0VBRS9FLElBQUksQ0FBQ0MsY0FBYyxHQUFHSCxrQkFBa0IsQ0FBQ0csY0FBYztFQUN2RCxJQUFJLENBQUNDLGNBQWMsR0FBR0osa0JBQWtCLENBQUNJLGNBQWM7RUFDdkQsSUFBSSxDQUFDQyxZQUFZLEdBQUdMLGtCQUFrQixDQUFDSyxZQUFZO0FBRXRELENBQUM7QUFaTEMsa0JBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvc3RhdGVoYW5kbGVyLnRzeD82Mzk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICBUaGlzIG1vZHVsZSBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGNyYWRsZSBzdGF0ZSBhbmQgdGhlIHN0YXRlIHNldHRpbmcgZm9yIG90aGVyIGhhbmRsZXJzLlxuICAgSXQgYWxzbyBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGlzTW91bnRlZFJlZiByZWZlcmVuY2UuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgY29uc3QgaW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgdGhpcy5zZXRDcmFkbGVTdGF0ZSA9IGludGVybmFsUHJvcGVydGllcy5zZXRDcmFkbGVTdGF0ZVxuICAgICAgIHRoaXMuY3JhZGxlU3RhdGVSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuY3JhZGxlU3RhdGVSZWZcbiAgICAgICB0aGlzLmlzTW91bnRlZFJlZiA9IGludGVybmFsUHJvcGVydGllcy5pc01vdW50ZWRSZWZcbiAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBjcmFkbGVTdGF0ZVJlZlxuICAgIHB1YmxpYyBzZXRDcmFkbGVTdGF0ZVxuICAgIHB1YmxpYyBpc01vdW50ZWRSZWZcblxufVxuIl0sIm5hbWVzIjpbIlN0YXRlSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJpbnRlcm5hbFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJjdXJyZW50Iiwic2V0Q3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImlzTW91bnRlZFJlZiIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// styleshandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        cradledividerstyles\n        triggercelltriggerlineheadstyles,\n        triggercelltriggerlinetailstyles,\n*/\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, StylesHandler);\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      gap = _ref.gap,\n      padding = _ref.padding,\n      crosscount = _ref.crosscount,\n      userstyles = _ref.userstyles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      layout = _ref.layout;\n    var headstyles = _this.getBaseHeadStyles(gap, padding, orientation, userstyles.cradle);\n    var tailstyles = _this.getBaseTailStyles(gap, padding, orientation, userstyles.cradle);\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation);\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gap = tailstyles.gap = gap + 'px';\n    // headstyles.padding set in contentHandler setCradleContent and updateCradleContent\n    if (orientation == 'vertical') {\n      // padding varies\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      // the following are identical for head and tail\n      headstyles.width = tailstyles.width = '100%';\n      headstyles.height = tailstyles.height = 'auto';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = null;\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellWidth, \"px, 1fr))\");\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'row';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = layout == 'uniform' ? null : 'max-content';\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = null;\n    } else {\n      // orientation == 'horizontal'\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      headstyles.width = tailstyles.width = 'auto';\n      headstyles.height = tailstyles.height = '100%';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\");\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = null;\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'column';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = null;\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = layout == 'uniform' ? null : 'max-content';\n    }\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = null;\n      right = null;\n      top = null;\n    } else {\n      bottom = null;\n      left = null;\n      right = 0;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = null;\n      left = null;\n      right = null;\n      top = 0;\n    } else {\n      bottom = null;\n      left = 0;\n      right = null;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n  this.getAxisStyles = function (gap, padding, orientation) {\n    var top, left, width, height; // for axis\n    if (orientation == 'vertical') {\n      top = padding + 'px'; // default\n      left = 'auto';\n      width = '100%';\n      height = 0;\n    } else {\n      top = 'auto';\n      left = padding + 'px'; // default\n      width = 0;\n      height = '100%';\n    }\n    return {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = triggerlineOffset + 'px';\n      right = '0px';\n      bottom = null;\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = null;\n      bottom = '0px';\n      left = triggerlineOffset + 'px';\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = null;\n      right = '0px';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = -(triggerlineOffset + gap) + 'px';\n      bottom = '0px';\n      left = null;\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0IsR0FBR0EsZ0JBQWdCO0FBRTFDLENBQUM7QUFOTHlDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0eWxlc2hhbmRsZXIudHN4PzQ1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGVzaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIENyYWRsZSBjb21wb25lbnQgd2l0aCBvbmUga2V5IGZ1bmN0aW9uOiBnZXRDcmFkbGVTdHlsZXMuXG4gICAgSXQgcmV0dXJucyBhbiBhcnJheSBvZiBzdHlsZSBvYmplY3RzIGZvclxuICAgICAgICBoZWFkc3R5bGVzLFxuICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICBheGlzc3R5bGVzLFxuICAgICAgICBjcmFkbGVkaXZpZGVyc3R5bGVzXG4gICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzLFxuICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5ldGFpbHN0eWxlcyxcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlc0hhbmRsZXIgeyBcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBnZXRDcmFkbGVTdHlsZXMgPSAoe1xuXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIC8vIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIC8vIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgIC8vIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgLy8gdmlld3BvcnR3aWR0aCxcbiAgICAgICAgdXNlcnN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGxheW91dCxcblxuICAgIH0pID0+IHtcblxuICAgICAgICBjb25zdCBoZWFkc3R5bGVzID0gdGhpcy5nZXRCYXNlSGVhZFN0eWxlcyhnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uLCB1c2Vyc3R5bGVzLmNyYWRsZSlcbiAgICAgICAgY29uc3QgdGFpbHN0eWxlcyA9IHRoaXMuZ2V0QmFzZVRhaWxTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IGF4aXNzdHlsZXMgPSB0aGlzLmdldEF4aXNTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbilcblxuICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyA9XG4gICAgICAgICAgICB0aGlzLmdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcClcbiAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMgPSBcbiAgICAgICAgICAgIHRoaXMuZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZXMoXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuXG4gICAgICAgIGNvbnN0IGNyYWRsZWRpdmlkZXJzdHlsZXMgPSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6MSwgXG4gICAgICAgICAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDonMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6JzAgMCA1cHggM3B4IHJlZCdcbiAgICAgICAgICAgIH1cblxuICAgICAgICBoZWFkc3R5bGVzLmdhcCA9IHRhaWxzdHlsZXMuZ2FwID0gZ2FwICsgJ3B4J1xuXG4gICAgICAgIC8vIGhlYWRzdHlsZXMucGFkZGluZyBzZXQgaW4gY29udGVudEhhbmRsZXIgc2V0Q3JhZGxlQ29udGVudCBhbmQgdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAvLyBwYWRkaW5nIHZhcmllc1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGlkZW50aWNhbCBmb3IgaGVhZCBhbmQgdGFpbFxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9IHRhaWxzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuaGVpZ2h0ID0gdGFpbHN0eWxlcy5oZWlnaHQgPSAnYXV0bydcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFxuICAgICAgICAgICAgICAgICAgICBgcmVwZWF0KCR7Y3Jvc3Njb3VudH0sIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvUm93cyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b1Jvd3MgPVxuICAgICAgICAgICAgICAgIChsYXlvdXQgPT0gJ3VuaWZvcm0nKT9cbiAgICAgICAgICAgICAgICAgICAgbnVsbDpcbiAgICAgICAgICAgICAgICAgICAgJ21heC1jb250ZW50J1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9Db2x1bW5zID0gbnVsbFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMGBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9IHRhaWxzdHlsZXMud2lkdGggPSAnYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuaGVpZ2h0ID0gdGFpbHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSBcbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsSGVpZ2h0fXB4LCAxZnIpKWBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvRmxvdyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ2NvbHVtbidcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9Sb3dzID0gdGFpbHN0eWxlcy5ncmlkQXV0b1Jvd3MgPSBudWxsXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9Db2x1bW5zID0gXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IFxuICAgICAgICAgICAgICAgIChsYXlvdXQgPT0gJ3VuaWZvcm0nKT9cbiAgICAgICAgICAgICAgICAgICAgbnVsbDpcbiAgICAgICAgICAgICAgICAgICAgJ21heC1jb250ZW50J1xuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRhaWxzdHlsZXMsXG4gICAgICAgICAgICBheGlzc3R5bGVzLFxuICAgICAgICAgICAgY3JhZGxlZGl2aWRlcnN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMsXG4gICAgICAgIF1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgLy8gdGhlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBzZXR0aW5nIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIGV4cGFuc2lvbiBvZiB0aGUgZ3JpZCBibG9ja1xuICAgIHByaXZhdGUgZ2V0QmFzZUhlYWRTdHlsZXMgPSBcbiAgICAgICAgKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJoZWFkc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAwXG4gICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSAwXG4gICAgICAgICAgICB0b3AgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udXNlcmhlYWRzdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGUgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IHNldHRpbmcgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgZXhwYW5zaW9uIG9mIHRoZSBncmlkIGJsb2NrXG4gICAgcHJpdmF0ZSBnZXRCYXNlVGFpbFN0eWxlcyA9IFxuICAgICAgICAoZ2FwLHBhZGRpbmcsb3JpZW50YXRpb24sdXNlcnRhaWxzdHlsZXMpID0+IHtcblxuICAgICAgICBsZXQgYm90dG9tLCBsZWZ0LCB0b3AsIHJpZ2h0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IG51bGxcbiAgICAgICAgICAgIGxlZnQgPSBudWxsXG4gICAgICAgICAgICByaWdodCA9IG51bGxcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IG51bGxcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9IG51bGxcbiAgICAgICAgICAgIHRvcCA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi51c2VydGFpbHN0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEF4aXNTdHlsZXMgPSBcbiAgICAgICAgKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24pID0+IHtcblxuICAgICAgICBsZXQgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IC8vIGZvciBheGlzXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCcgLy8gZGVmYXVsdFxuICAgICAgICAgICAgbGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9IDBcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nICsgJ3B4JyAvLyBkZWZhdWx0XG4gICAgICAgICAgICB3aWR0aCA9IDBcbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzID0gXG4gICAgICAgIChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAnYWJzb2x1dGUnXG5cbiAgICAgICAgbGV0IHdpZHRoLCBoZWlnaHQsIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gdHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICByaWdodCA9ICcwcHgnXG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gJzBweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB3aWR0aCA9IDBcbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgdG9wID0gJzBweCdcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgYm90dG9tID0gJzBweCdcbiAgICAgICAgICAgIGxlZnQgPSB0cmlnZ2VybGluZU9mZnNldCArICdweCdcblxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIGdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzID0gXG4gICAgICAgIChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAnYWJzb2x1dGUnXG5cbiAgICAgICAgbGV0IHdpZHRoLCBoZWlnaHQsIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSAnMHB4J1xuICAgICAgICAgICAgYm90dG9tID0gLSh0cmlnZ2VybGluZU9mZnNldCArIGdhcCkgKyAncHgnXG4gICAgICAgICAgICBsZWZ0ID0gJzBweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB3aWR0aCA9IDBcbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgdG9wID0gJzBweCdcbiAgICAgICAgICAgIHJpZ2h0ID0gLSh0cmlnZ2VybGluZU9mZnNldCArIGdhcCkgKyAncHgnXG4gICAgICAgICAgICBib3R0b20gPSAnMHB4J1xuICAgICAgICAgICAgbGVmdCA9IG51bGxcblxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJTdHlsZXNIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImdhcCIsInBhZGRpbmciLCJjcm9zc2NvdW50IiwidXNlcnN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwibGF5b3V0IiwiaGVhZHN0eWxlcyIsImdldEJhc2VIZWFkU3R5bGVzIiwiY3JhZGxlIiwidGFpbHN0eWxlcyIsImdldEJhc2VUYWlsU3R5bGVzIiwiYXhpc3N0eWxlcyIsImdldEF4aXNTdHlsZXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzIiwidHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMiLCJnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiZ3JpZFRlbXBsYXRlUm93cyIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkQXV0b0Zsb3ciLCJncmlkQXV0b1Jvd3MiLCJncmlkQXV0b0NvbHVtbnMiLCJ1c2VyaGVhZHN0eWxlcyIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImRpc3BsYXkiLCJncmlkR2FwIiwiYm94U2l6aW5nIiwidXNlcnRhaWxzdHlsZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./node_modules/react-error-boundary/dist/react-error-boundary.umd.js":function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"react\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  var changedArray = function changedArray(a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error;\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React__namespace.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React__namespace.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React__namespace.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function Wrapped(props) {\n      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__namespace.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React__namespace.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError != null) throw givenError;\n    if (error != null) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/sort-type-union-intersection-members: \"off\",\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-error-boundary.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pHLEVBQUUsQ0FDaUk7QUFDbkksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVycm9yLWJvdW5kYXJ5L2Rpc3QvcmVhY3QtZXJyb3ItYm91bmRhcnkudW1kLmpzP2U4OTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdEVycm9yQm91bmRhcnkgPSB7fSwgZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuXG4gIHZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbiAgfShSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoQ29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICB2YXIgV3JhcHBlZCA9IGZ1bmN0aW9uIFdyYXBwZWQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIGVycm9yQm91bmRhcnlQcm9wcywgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTsgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG5cblxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIiArIG5hbWUgKyBcIilcIjtcbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihnaXZlbkVycm9yKSB7XG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobnVsbCksXG4gICAgICAgIGVycm9yID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRFcnJvciA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGlmIChnaXZlbkVycm9yICE9IG51bGwpIHRocm93IGdpdmVuRXJyb3I7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBzZXRFcnJvcjtcbiAgfVxuICAvKlxuICBlc2xpbnRcbiAgICBAdHlwZXNjcmlwdC1lc2xpbnQvc29ydC10eXBlLXVuaW9uLWludGVyc2VjdGlvbi1tZW1iZXJzOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nOiBcIm9mZlwiXG4gICovXG5cbiAgZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbiAgZXhwb3J0cy51c2VFcnJvckhhbmRsZXIgPSB1c2VFcnJvckhhbmRsZXI7XG4gIGV4cG9ydHMud2l0aEVycm9yQm91bmRhcnkgPSB3aXRoRXJyb3JCb3VuZGFyeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\n")},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InPortal": () => (/* binding */ InPortal),\n/* harmony export */   "OutPortal": () => (/* binding */ OutPortal),\n/* harmony export */   "createHtmlPortalNode": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   "createSvgPortalNode": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(e){var I=__webpack_module_cache__[e];if(void 0!==I)return I.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}__webpack_require__.n=e=>{var I=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(e,I)=>{for(var l in I)__webpack_require__.o(I,l)&&!__webpack_require__.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:I[l]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,I)=>Object.prototype.hasOwnProperty.call(e,I),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/InfiniteGridScroller.tsx");return __webpack_exports__})()));