/*! For license information please see build.js.LICENSE.txt */
!function(e,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],I):"object"==typeof exports?exports["react-infinite-grid-scroller"]=I(require("react"),require("react-dom")):e["react-infinite-grid-scroller"]=I(e.react,e["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DOMRectReadOnly": () => (/* binding */ DOMRectReadOnly)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvRE9NUmVjdFJlYWRPbmx5LmpzP2ZkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObservation": () => (/* binding */ ResizeObservation)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === \'inline\';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJGQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzPzQ0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserver\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RkFBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsdUZBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHlGQUFrQztBQUMxQztBQUNBO0FBQ0EsUUFBUSwwRkFBbUM7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlci5qcz9kMDIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n")},"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverBoxOptions": () => (/* binding */ ResizeObserverBoxOptions)\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";\n    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";\n    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLmpzP2U1NTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverController": () => (/* binding */ ResizeObserverController)\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdFQUFvQjtBQUNwRCwrQ0FBK0MsaUVBQWlCO0FBQ2hFLFlBQVksNkRBQVc7QUFDdkIsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQXNCLENBQUMsMkVBQXVCO0FBQzdFO0FBQ0EsWUFBWSw2REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9EQUFvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmpzP2YzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9IGZyb20gJy4vdXRpbHMvc2NoZWR1bGVyJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmF0aW9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZhdGlvbic7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlckRldGFpbCB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJEZXRhaWwnO1xuaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRPYnNlcnZhdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9ic2VydmF0aW9uVGFyZ2V0c1tpXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBuZXcgUmVzaXplT2JzZXJ2ZXJEZXRhaWwocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXJNYXAuc2V0KHJlc2l6ZU9ic2VydmVyLCBkZXRhaWwpO1xuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgIGZpcnN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnB1c2goZGV0YWlsKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMucHVzaChuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvcHRpb25zICYmIG9wdGlvbnMuYm94KSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgxKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIHZhciBpbmRleCA9IGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIGxhc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAxO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGFzdE9ic2VydmF0aW9uICYmIHJlc2l6ZU9ic2VydmVycy5zcGxpY2UocmVzaXplT2JzZXJ2ZXJzLmluZGV4T2YoZGV0YWlsKSwgMSk7XG4gICAgICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAob3QpIHsgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTsgfSk7XG4gICAgICAgIGRldGFpbC5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCBkZXRhaWwuYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverDetail": () => (/* binding */ ResizeObserverDetail)\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanM/NzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverEntry": () => (/* binding */ ResizeObserverEntry)\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanM/NDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverSize": () => (/* binding */ ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcz9jNjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "broadcastActiveObservations": () => (/* binding */ broadcastActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLDhCQUE4Qiw2RUFBcUI7QUFDbkQ7QUFDQSxrQ0FBa0MsbUVBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzP2NhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckVudHJ5JztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJveFNpemUgfSBmcm9tICcuL2NhbGN1bGF0ZUJveFNpemUnO1xudmFyIGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hhbGxvd2VzdERlcHRoID0gSW5maW5pdHk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHJlc2l6ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NPYnNlcnZlcihybykge1xuICAgICAgICBpZiAocm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob3QudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZXB0aCA9IGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIG90Lmxhc3RSZXBvcnRlZFNpemUgPSBjYWxjdWxhdGVCb3hTaXplKG90LnRhcmdldCwgb3Qub2JzZXJ2ZWRCb3gpO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgc2hhbGxvd2VzdERlcHRoKSB7XG4gICAgICAgICAgICAgICAgc2hhbGxvd2VzdERlcHRoID0gdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgcm8uY2FsbGJhY2suY2FsbChyby5vYnNlcnZlciwgZW50cmllcywgcm8ub2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dlc3REZXB0aDtcbn07XG5leHBvcnQgeyBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateBoxSize": () => (/* binding */ calculateBoxSize),\n/* harmony export */   "calculateBoxSizes": () => (/* binding */ calculateBoxSizes)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ "./node_modules/@juggle/resize-observer/lib/utils/global.js");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || \'0\'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === \'border-box\';\n    var switchSizes = verticalRegexp.test(cs.writingMode || \'\');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || \'\');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || \'\');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFnQixJQUFJLHFFQUEwQjtBQUM5RSx3Q0FBd0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxlQUFlLG1FQUFrQjtBQUNqQztBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEMsQ0FBQztBQUNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0dBQWlEO0FBQzlEO0FBQ0EsYUFBYSwwRkFBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcz8xMDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlclNpemUnO1xuaW1wb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH0gZnJvbSAnLi4vRE9NUmVjdFJlYWRPbmx5JztcbmltcG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiB9IGZyb20gJy4uL3V0aWxzL2VsZW1lbnQnO1xuaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi4vdXRpbHMvZnJlZXplJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbCc7XG52YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNjcm9sbFJlZ2V4cCA9IC9hdXRvfHNjcm9sbC87XG52YXIgdmVydGljYWxSZWdleHAgPSAvXnRifHZlcnRpY2FsLztcbnZhciBJRSA9ICgvbXNpZXx0cmlkZW50L2kpLnRlc3QoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgcGFyc2VEaW1lbnNpb24gPSBmdW5jdGlvbiAocGl4ZWwpIHsgcmV0dXJuIHBhcnNlRmxvYXQocGl4ZWwgfHwgJzAnKTsgfTtcbnZhciBzaXplID0gZnVuY3Rpb24gKGlubGluZVNpemUsIGJsb2NrU2l6ZSwgc3dpdGNoU2l6ZXMpIHtcbiAgICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7IGlubGluZVNpemUgPSAwOyB9XG4gICAgaWYgKGJsb2NrU2l6ZSA9PT0gdm9pZCAwKSB7IGJsb2NrU2l6ZSA9IDA7IH1cbiAgICBpZiAoc3dpdGNoU2l6ZXMgPT09IHZvaWQgMCkgeyBzd2l0Y2hTaXplcyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG59O1xudmFyIHplcm9Cb3hlcyA9IGZyZWV6ZSh7XG4gICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGJvcmRlckJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KDAsIDAsIDAsIDApXG59KTtcbnZhciBjYWxjdWxhdGVCb3hTaXplcyA9IGZ1bmN0aW9uICh0YXJnZXQsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIGlmIChmb3JjZVJlY2FsY3VsYXRpb24gPT09IHZvaWQgMCkgeyBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChjYWNoZS5oYXModGFyZ2V0KSAmJiAhZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGlzSGlkZGVuKHRhcmdldCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgemVyb0JveGVzKTtcbiAgICAgICAgcmV0dXJuIHplcm9Cb3hlcztcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcbiAgICB2YXIgcmVtb3ZlUGFkZGluZyA9ICFJRSAmJiBjcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgICB2YXIgc3dpdGNoU2l6ZXMgPSB2ZXJ0aWNhbFJlZ2V4cC50ZXN0KGNzLndyaXRpbmdNb2RlIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsVmVydGljYWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dZIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gIXN2ZyAmJiBzY3JvbGxSZWdleHAudGVzdChjcy5vdmVyZmxvd1ggfHwgJycpO1xuICAgIHZhciBwYWRkaW5nVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdUb3ApO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ1JpZ2h0KTtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nQm90dG9tKTtcbiAgICB2YXIgcGFkZGluZ0xlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0xlZnQpO1xuICAgIHZhciBib3JkZXJUb3AgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbEJvcmRlckFyZWEgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsQm9yZGVyQXJlYSA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxIb3Jpem9udGFsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldEhlaWdodCAtIHZlcnRpY2FsQm9yZGVyQXJlYSAtIHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzID0gIWNhblNjcm9sbFZlcnRpY2FsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpZHRoUmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlckFyZWEgOiAwO1xuICAgIHZhciBoZWlnaHRSZWR1Y3Rpb24gPSByZW1vdmVQYWRkaW5nID8gdmVydGljYWxQYWRkaW5nICsgdmVydGljYWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gc3ZnID8gc3ZnLndpZHRoIDogcGFyc2VEaW1lbnNpb24oY3Mud2lkdGgpIC0gd2lkdGhSZWR1Y3Rpb24gLSB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgY29udGVudEhlaWdodCA9IHN2ZyA/IHN2Zy5oZWlnaHQgOiBwYXJzZURpbWVuc2lvbihjcy5oZWlnaHQpIC0gaGVpZ2h0UmVkdWN0aW9uIC0gaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgYm9yZGVyQm94V2lkdGggPSBjb250ZW50V2lkdGggKyBob3Jpem9udGFsUGFkZGluZyArIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzICsgaG9yaXpvbnRhbEJvcmRlckFyZWE7XG4gICAgdmFyIGJvcmRlckJveEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmcgKyBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzICsgdmVydGljYWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3hlcyA9IGZyZWV6ZSh7XG4gICAgICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoTWF0aC5yb3VuZChjb250ZW50V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSwgTWF0aC5yb3VuZChjb250ZW50SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpbyksIHN3aXRjaFNpemVzKSxcbiAgICAgICAgYm9yZGVyQm94U2l6ZTogc2l6ZShib3JkZXJCb3hXaWR0aCwgYm9yZGVyQm94SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGNvbnRlbnRCb3hTaXplOiBzaXplKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seShwYWRkaW5nTGVmdCwgcGFkZGluZ1RvcCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0KVxuICAgIH0pO1xuICAgIGNhY2hlLnNldCh0YXJnZXQsIGJveGVzKTtcbiAgICByZXR1cm4gYm94ZXM7XG59O1xudmFyIGNhbGN1bGF0ZUJveFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYnNlcnZlZEJveCwgZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgdmFyIF9hID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pLCBib3JkZXJCb3hTaXplID0gX2EuYm9yZGVyQm94U2l6ZSwgY29udGVudEJveFNpemUgPSBfYS5jb250ZW50Qm94U2l6ZSwgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IF9hLmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgc3dpdGNoIChvYnNlcnZlZEJveCkge1xuICAgICAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5ERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1g6XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQk9SREVSX0JPWDpcbiAgICAgICAgICAgIHJldHVybiBib3JkZXJCb3hTaXplO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3hTaXplO1xuICAgIH1cbn07XG5leHBvcnQgeyBjYWxjdWxhdGVCb3hTaXplLCBjYWxjdWxhdGVCb3hTaXplcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateDepthForNode": () => (/* binding */ calculateDepthForNode)\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzP2M5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deliverResizeLoopError\": () => (/* binding */ deliverResizeLoopError)\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2RlbGl2ZXJSZXNpemVMb29wRXJyb3IuanM/YzJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n")},"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "gatherActiveObservationsAtDepth": () => (/* binding */ gatherActiveObservationsAtDepth)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQzJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9nYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoLmpzPzQ1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbnZhciBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMuc3BsaWNlKDAsIHJvLnNraXBwZWRUYXJnZXRzLmxlbmd0aCk7XG4gICAgICAgIHJvLm9ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NUYXJnZXQob3QpIHtcbiAgICAgICAgICAgIGlmIChvdC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5wdXNoKG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasActiveObservations": () => (/* binding */ hasActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyx3RUFBb0IsaUJBQWlCLHFDQUFxQztBQUNyRjtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzP2RkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbnZhciBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasSkippedObservations": () => (/* binding */ hasSkippedObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsd0VBQW9CLGlCQUFpQixzQ0FBc0M7QUFDdEY7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc1NraXBwZWRPYnNlcnZhdGlvbnMuanM/YzEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc1NraXBwZWRPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoID4gMDsgfSk7XG59O1xuZXhwb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserver": () => (/* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver),\n/* harmony export */   "ResizeObserverEntry": () => (/* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry),\n/* harmony export */   "ResizeObserverSize": () => (/* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9leHBvcnRzL3Jlc2l6ZS1vYnNlcnZlci5qcz8xZDFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/element.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isElement\": () => (/* binding */ isElement),\n/* harmony export */   \"isHidden\": () => (/* binding */ isHidden),\n/* harmony export */   \"isReplacedElement\": () => (/* binding */ isReplacedElement),\n/* harmony export */   \"isSVG\": () => (/* binding */ isSVG)\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9lbGVtZW50LmpzPzNjZDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/freeze.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "freeze": () => (/* binding */ freeze)\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvZnJlZXplLmpzP2ZjZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/global.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"global\": () => (/* binding */ global)\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9nbG9iYWwuanM/Y2I3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/process.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "process": () => (/* binding */ process)\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzP2Q0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueMicroTask": () => (/* binding */ queueMicroTask)\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode(\'\');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVNaWNyb1Rhc2suanM/YTk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueResizeObserver": () => (/* binding */ queueResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVSZXNpemVPYnNlcnZlci5qcz9hMzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "resizeObservers": () => (/* binding */ resizeObservers)\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9yZXNpemVPYnNlcnZlcnMuanM/YThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduler\": () => (/* binding */ scheduler),\n/* harmony export */   \"updateCount\": () => (/* binding */ updateCount)\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDREQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDREQUF1QiwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sK0RBQTBCLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n")},"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // CellFrame.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n        - anything else is treated as an error\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its parent that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical position in the list) and session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\n\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\n\n\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\n\n\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\n\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      varHeightMin = _ref.varHeightMin,\n      varWidthMin = _ref.varWidthMin,\n      layout = _ref.layout,\n      getItem = _ref.getItem,\n      listsize = _ref.listsize,\n      placeholder = _ref.placeholder,\n      itemID = _ref.itemID,\n      index = _ref.index,\n      instanceID = _ref.instanceID,\n      scrollerID = _ref.scrollerID,\n      isTriggercell = _ref.isTriggercell,\n      placeholderFrameStyles = _ref.placeholderFrameStyles,\n      placeholderContentStyles = _ref.placeholderContentStyles;\n  // ----------------------[ setup ]----------------------\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n      scrollerPassthroughPropertiesRef = cradleContext.scrollerPassthroughPropertiesRef,\n      nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n      itemExceptionsCallback = cradleContext.itemExceptionsCallback,\n      IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n      triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef; // style change generates state refresh\n\n  var _ref2 = (0, react_1.useState)({\n    overflow: \'visible\'\n  }),\n      _ref3 = _slicedToArray(_ref2, 2),\n      styles = _ref3[0],\n      saveStyles = _ref3[1]; // processing state\n\n\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n      _ref5 = _slicedToArray(_ref4, 2),\n      frameState = _ref5[0],\n      setFrameState = _ref5[1];\n\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState; // DOM ref\n\n  var frameRef = (0, react_1.useRef)(null); // to track unmount interrupt\n\n  var isMountedRef = (0, react_1.useRef)(true); // cache data\n\n  var portalMetadataRef = (0, react_1.useRef)(null); // the placeholder to use\n\n  var placeholderRef = (0, react_1.useRef)(null); // the session itemID to use; could be updated by parent\n\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID; // fetch error\n\n  var errorRef = (0, react_1.useRef)(false); // placeholder message\n\n  var messageRef = (0, react_1.useRef)(null); // for unmount\n\n  (0, react_1.useEffect)(function () {\n    return function () {\n      isMountedRef.current = false;\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.removeRequestedPortal(index);\n    };\n  }, []); // refresh content if itemID changes\n\n  (0, react_1.useEffect)(function () {\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]); // ----------------- [ placeholder definition ] -------------------------\n\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, errorRef.current]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userContentStyles: placeholderContentStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current]); // ---------------- [ requestidlecallback config ] ------------------------\n\n  var requestidlecallback = window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback = window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null); // --------------------[ processing ]-----------------\n  // set styles\n\n  (0, react_1.useEffect)(function () {\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, varHeightMin, varWidthMin, layout, styles);\n\n    if (isMountedRef.current) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  var isReparentingRef = (0, react_1.useRef)(false);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        // no-op\n        break;\n\n      case \'inserting\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID);\n\n          if (cached) {\n            messageRef.current = \'(retrieving from cache)\';\n\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheHandler.getPortal(_itemID); // get OutPortal node\n\n              portalNodeRef.current = portalMetadataRef.current.portalNode; // notify fetched component that reparenting is underway\n\n              portalMetadataRef.current.isReparentingRef.current = true;\n              setFrameState(\'inserting\');\n            }\n          } else {\n            messageRef.current = \'(loading...)\';\n            setFrameState(\'waiting\'); // reserve space in the cache\n\n            cacheHandler.registerRequestedPortal(index); // enqueue the fetch\n\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, content, scrollerProperties;\n\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return getItem(index, _itemID);\n\n                      case 3:\n                        usercontent = _context.sent;\n                        if (usercontent === null) returnvalue = usercontent;\n\n                        if (usercontent === undefined) {\n                          error = new Error(\'host returned "undefined"\');\n                        }\n\n                        _context.next = 12;\n                        break;\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context["catch"](0);\n                        returnvalue = usercontent = undefined;\n                        error = _context.t0;\n\n                      case 12:\n                        // process the return value\n                        if (usercontent !== null && usercontent !== undefined) {\n                          if (!react_1["default"].isValidElement(usercontent)) {\n                            returnvalue = usercontent;\n                            usercontent = undefined;\n                            error = new Error(\'invalid React element\');\n                          }\n                        }\n\n                        if (isMountedRef.current) {\n                          // prepare the content\n                          if (usercontent !== null && usercontent !== undefined) {\n                            // if usercontent is otherwise disallowed, let error handling deal with it.\n                            scrollerProperties = {\n                              isReparentingRef: null,\n                              scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef\n                            };\n\n                            if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                              content = react_1["default"].cloneElement(usercontent, {\n                                scrollerProperties: scrollerProperties\n                              });\n                            } else {\n                              content = usercontent;\n                            }\n\n                            portalMetadataRef.current = cacheHandler.createPortal(content, index, _itemID);\n                            portalNodeRef.current = portalMetadataRef.current.portalNode; // make available to user content\n\n                            scrollerProperties.isReparentingRef = portalMetadataRef.current.isReparentingRef;\n                            isMountedRef.current && setFrameState(\'inserting\');\n                          } else {\n                            // null or undefined; handle non-component value\n                            if (usercontent === null) {\n                              // truncate listsize at this index\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(\'end of list\'));\n                              nullItemSetMaxListsize(index);\n                            } else {\n                              // usercontent === undefined, meaning an error has occurred\n                              // change placeholder message to error message\n                              errorRef.current = error; // notify the host\n\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                              isMountedRef.current && setFrameState(\'error\');\n                            }\n                          }\n                        }\n\n                      case 14:\n                      case "end":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n\n          break;\n        }\n\n      case \'waiting\':\n        {\n          break;\n        }\n    }\n  }, [frameState]);\n  (0, react_1.useEffect)(function () {\n    switch (frameState) {\n      case \'ready\':\n        {\n          // no-op\n          break;\n        }\n    }\n  }, [frameState]); // with \'inserting\' the content is still in cache\n  // the content re-renders with \'ready\' when the height/width have returned to normal after-cache\n  // React re-renders on diff between the two (virtual vs real DOM)\n  // this gives the content component a chance to respond to uncaching\n\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: styles\n  }, ![\'inserting\', \'ready\'].includes(frameState) ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    node: portalNodeRef.current\n  }), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\n// utility\n\n\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, varHeightMin, varWidthMin, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\'\n  });\n\n  if (orientation === \'vertical\') {\n    styleset.width = \'unset\';\n    styleset.height = layout == \'uniform\' ? cellHeight + \'px\' : \'unset\';\n    styleset.minHeight = (layout = \'variable\') ? varHeightMin + \'px\' : \'unset\';\n    styleset.maxHeight = (layout = \'variable\') ? cellHeight + \'px\' : \'unset\';\n  } else {\n    // horizontal\n    styleset.width = layout == \'uniform\' ? cellWidth + \'px\' : \'unset\';\n    styleset.height = \'unset\';\n    styleset.minWidth = (layout = \'variable\') ? varWidthMin + \'px\' : \'unset\';\n    styleset.maxWidth = (layout = \'variable\') ? cellWidth + \'px\' : \'unset\';\n  }\n\n  return styleset;\n};\n\nexports["default"] = CellFrame;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBSCxRQUFRLENBQUNNLFFBQVQsR0FDSSxDQUFDakYsTUFBTSxHQUFHLFVBQVYsSUFDSUQsV0FBVyxHQUFHLElBRGxCLEdBRUksT0FIUjtJQUlBNEUsUUFBUSxDQUFDTyxRQUFULEdBQ0ksQ0FBQ2xGLE1BQU0sR0FBRyxVQUFWLElBQ0lILFNBQVMsR0FBRyxJQURoQixHQUVJLE9BSFI7RUFLSDs7RUFFRCxPQUFPOEUsUUFBUDtBQUVILENBeENEOztBQTBDQVEsa0JBQUFBLEdBQWV6RixTQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DZWxsRnJhbWUudHN4P2YxNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VsbEZyYW1lLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiBDZWxsRnJhbWUgaXMgdG8gZmV0Y2ggdXNlciBjb250ZW50IGZyb20gdGhlIGNhY2hlLCBvciBmcm9tIHRoZSBob3N0ICh1c2luZyBnZXRJdGVtKS5cbiAgICBXaGlsZSBhbiBpdGVtIGlzIGJlaW5nIGZldGNoZWQsIENlbGxGcmFtZSBwcmVzZW50cyBhIHBsYWNlaG9sZGVyIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgYW4gXG4gICAgaW1wb3J0ZWQgY3VzdG9tIHZlcnNpb24pLiBJZiB0aGVyZSBpcyBhbiBlcnJvciBpbiBmZXRjaGluZyBjb250ZW50IHRoZW4gdGhlIHBsYWNlaG9sZGVyIGlzIHVzZWRcbiAgICB0byBwcmVzZW50IHRoZSBlcnJvciB0byB0aGUgdXNlci4gSWYgYSBuZXcgaXRlbUlEIGlzIHNldCBieSB0aGUgcGFyZW50ICh0byBzeW5jaHJvbml6ZSB3aXRoIGFuIGFsdGVyZWRcbiAgICBjYWNoZSksIHRoZW4gQ2VsbEZyYW1lIHJlcGxhY2VzIHRoZSBvbGQgaXRlbSB3aXRoIHRoZSBuZXcgaXRlbS5cblxuICAgIGdldEl0ZW0gKHdoaWNoIGlzIGEgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGhvc3QpIGNhbiByZXR1cm4gb25lIG9mIHNldmVyYWwgdmFsdWVzOlxuICAgICAgICAtIGEgUmVhY3QgY29tcG9uZW50XG4gICAgICAgIC0gYSBwcm9taXNlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIC0gbnVsbFxuICAgICAgICAtIHVuZGVmaW5lZFxuICAgICAgICAtIGFueXRoaW5nIGVsc2UgaXMgdHJlYXRlZCBhcyBhbiBlcnJvclxuICAgIGlmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCwgdGhlbiB0aGUgcHJvbWlzZSByZXR1cm5zIGEgUmVhY3QgY29tcG9uZW50LCBudWxsIG9yIHVuZGVmaW5lZC5cblxuICAgIElmIGEgdmFsaWQgcmVhY3QgY29tcG9uZW50IGlzIHJldHVybmVkLCB0aGVuIGl0IGlzIGluc3RhbnRpYXRlZCBpbiB0aGUgY2FjaGUsIGFuZCByZW5kZXJlZCBpbiB0aGVcbiAgICBDZWxsRnJhbWUuIElmIG51bGwgaXMgcmV0dXJuZWQsIHRoZW4gQ2VsbEZyYW1lIHNlbmRzIGEgbWVzc2FnZSB0byBpdHMgcGFyZW50IHRoYXQgdGhlIGhvc3QgaGFzIFxuICAgIGluZGljYXRlZCB0aGUgdGhlIGl0ZW0gYmVpbmcgZmV0Y2hlZCBpbnN0ZWFkIHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGUgbGlzdCwgYW5kIHRoZSBsaXN0c2l6ZSBzaG91bGRcbiAgICBiZSBhZGp1c3RlZCBhY2NvcmRpbmdseS4gQW55IG90aGVyIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvciwgYW5kIHByZXNlbnRlZFxuICAgIGFzIHN1Y2ggdG8gdGhlIHVzZXIgdGhyb3VnaCB0aGUgcGxhY2Vob2xkZXIgY29tcG9uZW50LlxuXG4gICAgZ2V0SXRlbSBzZW5kcyB0aGUgaW5kZXggKGxvZ2ljYWwgcG9zaXRpb24gaW4gdGhlIGxpc3QpIGFuZCBzZXNzaW9uIGl0ZW1JRCB0byB0aGUgaG9zdCwgc28gdGhhdFxuICAgIHRoZSBob3N0IGNhbiBzeW5jIGl0cyBvd24gdHJhY2tpbmcgd2l0aCB0aGUgc2Nyb2xsZXIuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgICB1c2VSZWYsIFxuICAgIHVzZUVmZmVjdCwgXG4gICAgdXNlTGF5b3V0RWZmZWN0LCBcbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlQ2FsbGJhY2ssIFxuICAgIHVzZU1lbW8sIFxuICAgIHVzZUNvbnRleHQgXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQge3JlcXVlc3RJZGxlQ2FsbGJhY2ssIGNhbmNlbElkbGVDYWxsYmFja30gZnJvbSAncmVxdWVzdGlkbGVjYWxsYmFjaycgLy8gcG9seWZpbGwgaWYgbmVlZGVkXG5cbmltcG9ydCB7IE91dFBvcnRhbCB9IGZyb20gJ3JlYWN0LXJldmVyc2UtcG9ydGFsJyAvLyBmZXRjaCBmcm9tIGNhY2hlXG5cbmltcG9ydCBQbGFjZWhvbGRlciBmcm9tICcuL2NlbGxmcmFtZS9QbGFjZWhvbGRlcicgLy8gZGVmYXVsdFxuXG5pbXBvcnQgeyBDcmFkbGVDb250ZXh0IH0gZnJvbSAnLi9DcmFkbGUnXG5cbmNvbnN0IENlbGxGcmFtZSA9ICh7XG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgdmFySGVpZ2h0TWluLFxuICAgIHZhcldpZHRoTWluLFxuICAgIGxheW91dCxcbiAgICBnZXRJdGVtLCAvLyBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0XG4gICAgbGlzdHNpemUsIC8vIGZvciBmZWVkYmFjayBpbiBwbGFjZWhvbGRlclxuICAgIHBsYWNlaG9sZGVyLCAvLyBvcHRpb25hbGx5IHByb3ZpZGVkIGJ5IGhvc3RcbiAgICBpdGVtSUQsIC8vIHNlc3Npb24gaXRlbUlEXG4gICAgaW5kZXgsIC8vIGxvZ2ljYWwgcG9zaXRpb24gaW4gaW5maW5pdGUgbGlzdFxuICAgIGluc3RhbmNlSUQsIC8vIENlbGxGcmFtZSBzZXNzaW9uIElEXG4gICAgc2Nyb2xsZXJJRCwgLy8gc2Nyb2xsZXIgSUQgKGZvciBkZWJ1Z2dpbmcpXG4gICAgaXNUcmlnZ2VyY2VsbCxcbiAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyQ29udGVudFN0eWxlcyxcbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZXh0ID0gdXNlQ29udGV4dChDcmFkbGVDb250ZXh0KVxuXG4gICAgY29uc3QgeyBcbiAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsIC8vIGZvciB0aGUgdXNlciBjb250ZW50LCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgLy8gZm9yIGludGVybmFsIG5vdGlmaWNhdGlvbiBvZiBlbmQtb2YtbGlzdFxuICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrLCAvLyBvciBub3RpZmljYXRpb24gdG8gaG9zdCBvZiBlcnJvclxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCwgLy8gdG8gb3B0aW1pemUgcmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZixcbiAgICB9ID0gY3JhZGxlQ29udGV4dFxuICAgIFxuICAgIC8vIHN0eWxlIGNoYW5nZSBnZW5lcmF0ZXMgc3RhdGUgcmVmcmVzaFxuICAgIGNvbnN0IFtzdHlsZXMsc2F2ZVN0eWxlc10gPSB1c2VTdGF0ZSh7XG4gICAgICAgIG92ZXJmbG93Oid2aXNpYmxlJyxcbiAgICB9KVxuXG4gICAgLy8gcHJvY2Vzc2luZyBzdGF0ZVxuICAgIGNvbnN0IFtmcmFtZVN0YXRlLCBzZXRGcmFtZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgZnJhbWVTdGF0ZVJlZiA9IHVzZVJlZihudWxsKVxuICAgIGZyYW1lU3RhdGVSZWYuY3VycmVudCA9IGZyYW1lU3RhdGVcblxuICAgIC8vIERPTSByZWZcbiAgICBjb25zdCBmcmFtZVJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHRvIHRyYWNrIHVubW91bnQgaW50ZXJydXB0XG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG4gICAgLy8gY2FjaGUgZGF0YVxuICAgIGNvbnN0IHBvcnRhbE1ldGFkYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdGhlIHBsYWNlaG9sZGVyIHRvIHVzZVxuICAgIGNvbnN0IHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdGhlIHNlc3Npb24gaXRlbUlEIHRvIHVzZTsgY291bGQgYmUgdXBkYXRlZCBieSBwYXJlbnRcbiAgICBjb25zdCBpdGVtSURSZWYgPSB1c2VSZWYobnVsbClcbiAgICBpdGVtSURSZWYuY3VycmVudCA9IGl0ZW1JRFxuICAgIC8vIGZldGNoIGVycm9yXG4gICAgY29uc3QgZXJyb3JSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgLy8gcGxhY2Vob2xkZXIgbWVzc2FnZVxuICAgIGNvbnN0IG1lc3NhZ2VSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGZvciB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgICAgICBjYW5jZWxpZGxlY2FsbGJhY2socmVxdWVzdElkbGVDYWxsYmFja0lkUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW1vdmVSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIHJlZnJlc2ggY29udGVudCBpZiBpdGVtSUQgY2hhbmdlc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkgc2V0RnJhbWVTdGF0ZSgnZ2V0dXNlcmNvbnRlbnQnKVxuXG4gICAgfSxbaXRlbUlEXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tIFsgcGxhY2Vob2xkZXIgZGVmaW5pdGlvbiBdIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGN1c3RvbXBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcj9cbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHBsYWNlaG9sZGVyLCBcbiAgICAgICAgICAgICAgICAgICAge2luZGV4LCBsaXN0c2l6ZSwgbWVzc2FnZTptZXNzYWdlUmVmLmN1cnJlbnQsIGVycm9yOmVycm9yUmVmLmN1cnJlbnR9KTpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBcbiAgICB9LFtpbmRleCwgcGxhY2Vob2xkZXIsbGlzdHNpemUsIGVycm9yUmVmLmN1cnJlbnRdKVxuXG4gICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHVzZU1lbW8oKCk9PntcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IFxuICAgICAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXI/XG4gICAgICAgICAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXI6XG4gICAgICAgICAgICAgICAgPFBsYWNlaG9sZGVyIFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH0gXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7IG1lc3NhZ2VSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0geyBlcnJvclJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckZyYW1lU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbnRlbnRTdHlsZXMgPSB7IHBsYWNlaG9sZGVyQ29udGVudFN0eWxlcyB9XG4gICAgICAgICAgICAgICAgLz5cblxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJcblxuICAgIH0sIFtcbiAgICAgICAgaW5kZXgsIFxuICAgICAgICBjdXN0b21wbGFjZWhvbGRlciwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50LCBcbiAgICAgICAgZXJyb3JSZWYuY3VycmVudFxuICAgIF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFsgcmVxdWVzdGlkbGVjYWxsYmFjayBjb25maWcgXSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHJlcXVlc3RpZGxlY2FsbGJhY2sgPSBcbiAgICAgICAgd2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ10/XG4gICAgICAgICAgICB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXTpcbiAgICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2tcblxuICAgIGNvbnN0IGNhbmNlbGlkbGVjYWxsYmFjayA9IFxuICAgICAgICB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddP1xuICAgICAgICAgICAgd2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXTpcbiAgICAgICAgICAgIGNhbmNlbElkbGVDYWxsYmFja1xuXG4gICAgY29uc3QgcmVxdWVzdElkbGVDYWxsYmFja0lkUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHNldCBzdHlsZXNcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBsZXQgbmV3U3R5bGVzID0gZ2V0RnJhbWVTdHlsZXMoXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB2YXJIZWlnaHRNaW4sIHZhcldpZHRoTWluLCBsYXlvdXQsIHN0eWxlcylcbiAgICAgICAgXG4gICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgc2F2ZVN0eWxlcyhuZXdTdHlsZXMpXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uLGNlbGxIZWlnaHQsY2VsbFdpZHRoXSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBpc1JlcGFyZW50aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKGZyYW1lU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ2luc2VydGluZyc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2dldHVzZXJjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaXRlbUlEUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZUhhbmRsZXIuaGFzUG9ydGFsKGl0ZW1JRClcblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUmVmLmN1cnJlbnQgPSAnKHJldHJpZXZpbmcgZnJvbSBjYWNoZSknXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudCA9IGNhY2hlSGFuZGxlci5nZXRQb3J0YWwoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IE91dFBvcnRhbCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LnBvcnRhbE5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBmZXRjaGVkIGNvbXBvbmVudCB0aGF0IHJlcGFyZW50aW5nIGlzIHVuZGVyd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LmlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnaW5zZXJ0aW5nJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9ICcobG9hZGluZy4uLiknXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnd2FpdGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZSBzcGFjZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soYXN5bmMgKCk9PntcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbHVlLCB1c2VyY29udGVudCwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2hvc3QgcmV0dXJuZWQgXCJ1bmRlZmluZWRcIicpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXJjb250ZW50IGlzIG90aGVyd2lzZSBkaXNhbGxvd2VkLCBsZXQgZXJyb3IgaGFuZGxpbmcgZGVhbCB3aXRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjpudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzPy5oYXNPd25Qcm9wZXJ0eSgnc2Nyb2xsZXJQcm9wZXJ0aWVzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQodXNlcmNvbnRlbnQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB1c2VyY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudCA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNyZWF0ZVBvcnRhbChjb250ZW50LCBpbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHRvIHVzZXIgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZiA9IHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZDsgaGFuZGxlIG5vbi1jb21wb25lbnQgdmFsdWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIG5ldyBFcnJvcignZW5kIG9mIGxpc3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IHVuZGVmaW5lZCwgbWVhbmluZyBhbiBlcnJvciBoYXMgb2NjdXJyZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHBsYWNlaG9sZGVyIG1lc3NhZ2UgdG8gZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RpZnkgdGhlIGhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdjZWxsRnJhbWUnLCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0RnJhbWVTdGF0ZSgnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9LHt0aW1lb3V0OklETEVDQUxMQkFDS19USU1FT1VUfSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dhaXRpbmcnOiB7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtmcmFtZVN0YXRlXSlcblxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChmcmFtZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogeyAvLyBuby1vcFxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2ZyYW1lU3RhdGVdKVxuXG4gICAgLy8gd2l0aCAnaW5zZXJ0aW5nJyB0aGUgY29udGVudCBpcyBzdGlsbCBpbiBjYWNoZVxuICAgIC8vIHRoZSBjb250ZW50IHJlLXJlbmRlcnMgd2l0aCAncmVhZHknIHdoZW4gdGhlIGhlaWdodC93aWR0aCBoYXZlIHJldHVybmVkIHRvIG5vcm1hbCBhZnRlci1jYWNoZVxuICAgIC8vIFJlYWN0IHJlLXJlbmRlcnMgb24gZGlmZiBiZXR3ZWVuIHRoZSB0d28gKHZpcnR1YWwgdnMgcmVhbCBET00pXG4gICAgLy8gdGhpcyBnaXZlcyB0aGUgY29udGVudCBjb21wb25lbnQgYSBjaGFuY2UgdG8gcmVzcG9uZCB0byB1bmNhY2hpbmdcbiAgICByZXR1cm4gPGRpdiBcblxuICAgICAgICByZWYgPSB7IGZyYW1lUmVmIH0gXG4gICAgICAgIGRhdGEtdHlwZSA9ICdjZWxsZnJhbWUnIFxuICAgICAgICBkYXRhLXNjcm9sbGVyaWQgPSB7IHNjcm9sbGVySUQgfSBcbiAgICAgICAgZGF0YS1pbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgZGF0YS1pbnN0YW5jZWlkID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIHN0eWxlID0geyBzdHlsZXMgfVxuXG4gICAgPlxuXG4gICAgICAgIHsgXG4gICAgICAgICAgICAoIVsnaW5zZXJ0aW5nJywncmVhZHknXS5pbmNsdWRlcyhmcmFtZVN0YXRlKSk/XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudDpcbiAgICAgICAgICAgICAgICA8T3V0UG9ydGFsIG5vZGUgPSB7IHBvcnRhbE5vZGVSZWYuY3VycmVudCB9Lz5cbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBpc1RyaWdnZXJjZWxsP1xuICAgICAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxuXG59IC8vIENlbGxGcmFtZVxuXG4vLyB1dGlsaXR5XG5jb25zdCBnZXRGcmFtZVN0eWxlcyA9IChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB2YXJIZWlnaHRNaW4sIHZhcldpZHRoTWluLCBsYXlvdXQsIHN0eWxlcykgPT4ge1xuXG4gICAgbGV0IHN0eWxlc2V0ID0gey4uLnN0eWxlcyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSAndW5zZXQnXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IFxuICAgICAgICAgICAgKGxheW91dCA9PSAndW5pZm9ybScpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgKyAncHgnOlxuICAgICAgICAgICAgICAgICd1bnNldCdcbiAgICAgICAgc3R5bGVzZXQubWluSGVpZ2h0ID1cbiAgICAgICAgICAgIChsYXlvdXQgPSAndmFyaWFibGUnKT9cbiAgICAgICAgICAgICAgICB2YXJIZWlnaHRNaW4gKyAncHgnOlxuICAgICAgICAgICAgICAgICd1bnNldCdcbiAgICAgICAgc3R5bGVzZXQubWF4SGVpZ2h0ID1cbiAgICAgICAgICAgIChsYXlvdXQgPSAndmFyaWFibGUnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAndW5zZXQnXG4gICAgICAgIFxuICAgIH0gZWxzZSB7IC8vIGhvcml6b250YWxcblxuICAgICAgICBzdHlsZXNldC53aWR0aCA9IFxuICAgICAgICAgICAgKGxheW91dCA9PSAndW5pZm9ybScpP1xuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCArICdweCc6XG4gICAgICAgICAgICAgICAgJ3Vuc2V0J1xuICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSAndW5zZXQnXG4gICAgICAgIHN0eWxlc2V0Lm1pbldpZHRoID1cbiAgICAgICAgICAgIChsYXlvdXQgPSAndmFyaWFibGUnKT9cbiAgICAgICAgICAgICAgICB2YXJXaWR0aE1pbiArICdweCc6XG4gICAgICAgICAgICAgICAgJ3Vuc2V0J1xuICAgICAgICBzdHlsZXNldC5tYXhXaWR0aCA9XG4gICAgICAgICAgICAobGF5b3V0ID0gJ3ZhcmlhYmxlJyk/XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAndW5zZXQnXG5cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzZXRcblxufVxuXG5leHBvcnQgZGVmYXVsdCBDZWxsRnJhbWVcbiJdLCJuYW1lcyI6WyJDZWxsRnJhbWUiLCJvcmllbnRhdGlvbiIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJ2YXJIZWlnaHRNaW4iLCJ2YXJXaWR0aE1pbiIsImxheW91dCIsImdldEl0ZW0iLCJsaXN0c2l6ZSIsInBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiaW5kZXgiLCJpbnN0YW5jZUlEIiwic2Nyb2xsZXJJRCIsImlzVHJpZ2dlcmNlbGwiLCJwbGFjZWhvbGRlckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJDb250ZW50U3R5bGVzIiwiY3JhZGxlQ29udGV4dCIsIkNyYWRsZV8xIiwiY2FjaGVIYW5kbGVyIiwic2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYiLCJudWxsSXRlbVNldE1heExpc3RzaXplIiwiaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayIsIklETEVDQUxMQkFDS19USU1FT1VUIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYiLCJvdmVyZmxvdyIsInN0eWxlcyIsInNhdmVTdHlsZXMiLCJmcmFtZVN0YXRlIiwic2V0RnJhbWVTdGF0ZSIsImZyYW1lU3RhdGVSZWYiLCJjdXJyZW50IiwiZnJhbWVSZWYiLCJpc01vdW50ZWRSZWYiLCJwb3J0YWxNZXRhZGF0YVJlZiIsInBsYWNlaG9sZGVyUmVmIiwiaXRlbUlEUmVmIiwiZXJyb3JSZWYiLCJtZXNzYWdlUmVmIiwiY2FuY2VsaWRsZWNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFja0lkUmVmIiwicmVtb3ZlUmVxdWVzdGVkUG9ydGFsIiwiY3VzdG9tcGxhY2Vob2xkZXIiLCJyZWFjdF8xIiwiY3JlYXRlRWxlbWVudCIsIm1lc3NhZ2UiLCJlcnJvciIsIlBsYWNlaG9sZGVyXzEiLCJ1c2VyRnJhbWVTdHlsZXMiLCJ1c2VyQ29udGVudFN0eWxlcyIsInJlcXVlc3RpZGxlY2FsbGJhY2siLCJ3aW5kb3ciLCJyZXF1ZXN0aWRsZWNhbGxiYWNrXzEiLCJuZXdTdHlsZXMiLCJnZXRGcmFtZVN0eWxlcyIsInBvcnRhbE5vZGVSZWYiLCJpc1JlcGFyZW50aW5nUmVmIiwiY2FjaGVkIiwiaGFzUG9ydGFsIiwiZ2V0UG9ydGFsIiwicG9ydGFsTm9kZSIsInJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsIiwiX19hd2FpdGVyIiwidXNlcmNvbnRlbnQiLCJyZXR1cm52YWx1ZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNWYWxpZEVsZW1lbnQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsIl9hIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlUG9ydGFsIiwidGltZW91dCIsInJlZiIsInN0eWxlIiwiaW5jbHVkZXMiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsInN0eWxlc2V0IiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // Cradle.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers, and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the state change flows of the content.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be verticsl or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'upwards' in the Cradle, and below which the\n    cradle content expands 'downwards'. The Cradle content is held in two CSS grids (children of the axis):\n    one above, and one below the position of the axis.\n\n    The axis is always kept near the leading (headward) edge of the visible cellrows of the viewport\n    (there are some edge-case exceptions).\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is the\n            fist item in the head section of the Cradle)\n        - axisPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll of the ScrollBlock\n    \n    Overscroll handling:\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle has entirely passed out of the viewport, then the Cradle\n        is replaced by a ScrollTracker (or by null if the host takes responsibility for feedback).\n        The ScrollTracker shows the relative location in the virtual list at the edge of the viewport\n        during repositioning. When the scrolling stops Cradle recreates the cradle content, according to\n        the final position of the repositioning process.\n\n    Cradle is activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n        - cradle grid resizing responding to variable cell length changes (in 'variable' layout mode)\n            which triggers reconfiguration\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\"); // popup position tracker for repositioning\n\n\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\")); // support code; process handlers\n\n\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\n\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\n\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\n\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\n\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\n\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\n\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\")); // cacheHandler is imported as a property; instantiated at the root\n// for children\n\n\nexports.CradleContext = react_1[\"default\"].createContext(null); // component\n\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n      runwaySize = _ref.runwaySize,\n      listsize = _ref.listsize,\n      startingIndex = _ref.startingIndex,\n      getItem = _ref.getItem,\n      placeholder = _ref.placeholder,\n      userCallbacks = _ref.userCallbacks,\n      styles = _ref.styles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      cache = _ref.cache,\n      cacheMax = _ref.cacheMax,\n      scrollerID = _ref.scrollerID,\n      cacheHandler = _ref.cacheHandler,\n      useScrollTracker = _ref.useScrollTracker,\n      showAxis = _ref.showAxis,\n      MIN_MAX_DELTA_RATIO = _ref.MIN_MAX_DELTA_RATIO,\n      SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _ref.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n      IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n      MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n      TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _ref.TIMEOUT_FOR_VARIABLE_MEASUREMENTS;\n\n  var _a, _b;\n\n  if (listsize == 0) return null; // nothing to do\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      varHeightMin = gridSpecs.varHeightMin,\n      varWidthMin = gridSpecs.varWidthMin,\n      layout = gridSpecs.layout; // get viewport context\n\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n\n  var viewportDimensions = ViewportContextProperties.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width; // state\n\n  var _ref2 = (0, react_1.useState)('setup'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      cradleState = _ref3[0],\n      setCradleState = _ref3[1];\n\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n\n  cradleStateRef.current = cradleState;\n\n  var _ref4 = (0, react_1.useState)('resizeready'),\n      _ref5 = _slicedToArray(_ref4, 2),\n      cradleResizeState = _ref5[0],\n      setCradleResizeState = _ref5[1];\n\n  var cradleResizeStateRef = (0, react_1.useRef)(null); // access by closures\n\n  cradleResizeStateRef.current = cradleResizeState; // console.log('==> cradleState','-'+scrollerID+'-',cradleState)\n  // flags\n\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var parentingTransitionRequiredRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false); // cradle scaffold element refs\n\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null); // const axisTriggerlineCradleElementRef = useRef(null)\n  // const headTriggerlineCradleElementRef = useRef(null)\n\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null); // layout bundle\n\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    // axisTriggerlineRef:axisTriggerlineCradleElementRef,\n    // headTriggerlineRef:headTriggerlineCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  }); // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n\n  var crosscount = (0, react_1.useMemo)(function () {\n    // console.log('recalculating crosscount')\n    var viewportcrosslength = orientation == 'horizontal' ? viewportheight : viewportwidth;\n\n    if (viewportcrosslength == 0) {\n      return 0;\n    } // cross length of viewport (gap to match crossLength)\n\n\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = orientation == 'horizontal' ? cellHeight + gap : cellWidth + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]); // various row counts\n\n  var _ref6 = (0, react_1.useMemo)(function () {\n    // console.log('recalculating row counts')\n    var viewportLength, baseRowLength;\n\n    if (orientation == 'vertical') {\n      viewportLength = viewportheight;\n      baseRowLength = cellHeight;\n    } else {\n      viewportLength = viewportwidth;\n      baseRowLength = cellWidth;\n    }\n\n    baseRowLength += gap;\n    var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n    var viewportVisibleRowcount = Math.floor(viewportLength / baseRowLength);\n    var listRowcount = Math.ceil(listsize / crosscount);\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n    var runwayRowcount;\n\n    if (calculatedCradleRowcount >= cradleRowcount) {\n      runwayRowcount = runwaySize;\n    } else {\n      var diff = cradleRowcount - calculatedCradleRowcount;\n      runwayRowcount -= Math.floor(diff / 2);\n      runwayRowcount = Math.max(0, runwayRowcount);\n    }\n\n    var itemcount = cradleRowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradleRowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradleRowcount, viewportRowcount, viewportVisibleRowcount, listRowcount, runwayRowcount];\n  }, [orientation, gap, // padding,\n  cellWidth, cellHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount]),\n      _ref7 = _slicedToArray(_ref6, 5),\n      cradleRowcount = _ref7[0],\n      viewportRowcount = _ref7[1],\n      viewportVisibleRowcount = _ref7[2],\n      // max number of rows completely visible at once\n  listRowcount = _ref7[3],\n      runwayRowcount = _ref7[4]; // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n\n\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionsCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionsCallback\n  }); // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    varHeightMin: varHeightMin,\n    varWidthMin: varWidthMin,\n    layout: layout,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    MIN_MAX_DELTA_RATIO: MIN_MAX_DELTA_RATIO,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN\n  };\n  var scrollerPassthroughPropertiesRef = (0, react_1.useRef)(null); // passed to cellFrame content (user content) if requested\n\n  scrollerPassthroughPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    varHeightMin: varHeightMin,\n    varWidthMin: varWidthMin,\n    layout: layout,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    triggerlineOffset: triggerlineOffset\n  }; // configuration properties to share with handlers\n\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    viewportVisibleRowcount: viewportVisibleRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState,\n    cradleResizeStateRef: cradleResizeStateRef,\n    setCradleResizeState: setCradleResizeState\n  }; // placeholder in cradleParameters to make available individual handlers\n\n  var handlersRef = (0, react_1.useRef)(null); // cradle parameters MASTER BUNDLE\n\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters; // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  } // make handlers directly available to cradle code below\n\n\n  var _handlersRef$current = handlersRef.current,\n      interruptHandler = _handlersRef$current.interruptHandler,\n      scrollHandler = _handlersRef$current.scrollHandler,\n      stateHandler = _handlersRef$current.stateHandler,\n      contentHandler = _handlersRef$current.contentHandler,\n      layoutHandler = _handlersRef$current.layoutHandler,\n      serviceHandler = _handlersRef$current.serviceHandler,\n      stylesHandler = _handlersRef$current.stylesHandler; // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n\n  /*\n      Intercept change in caching status:\n      when a portal is cached, including the transition of being moved from one cellFrame to another,\n      (and the infinitegridscroller can be a component that is cached),\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n      The restore action must be the first priority to hide the scrollPos changes from the user\n  */\n  // zero width and height means the component must be in portal (cache) state\n\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n\n  var isCachingUnderway = isCachedRef.current || wasCachedRef.current;\n\n  if (isCacheChange || ((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) || ViewportContextProperties.isResizing && isCachingUnderway) {\n    if ((_b = ViewportContextProperties.isReparentingRef) === null || _b === void 0 ? void 0 : _b.current) {\n      ViewportContextProperties.isReparentingRef.current = false; // no longer needed\n\n      parentingTransitionRequiredRef.current = true;\n    }\n\n    if (ViewportContextProperties.isResizing) {\n      // caching op is underway, so cancel\n      ViewportContextProperties.isResizing = false;\n    }\n\n    if (isCacheChange) {\n      // into or out of caching\n      if (isCachedRef.current && !wasCachedRef.current) {\n        // change into cache\n        interruptHandler.pauseInterrupts();\n      }\n    }\n  } // generate state for restoring scrollPos\n\n\n  (0, react_1.useEffect)(function () {\n    // if is cached, then the next effect (for entering or leaving cache) has another turn\n    if (parentingTransitionRequiredRef.current && !isCachedRef.current) {\n      parentingTransitionRequiredRef.current = false;\n      setCradleState('parentingtransition');\n    }\n  }, [parentingTransitionRequiredRef.current]); // change state for entering or leaving cache\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached'); // replaces 'ready' as steady state\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n\n      if (parentingTransitionRequiredRef.current) {\n        parentingTransitionRequiredRef.current = false;\n        setCradleState('parentingtransition');\n      } else {\n        if (hasBeenRenderedRef.current) {\n          setCradleState('rerenderfromcache');\n        } else {\n          setCradleState('firstrenderfromcache');\n        }\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]); // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n\n  (0, react_1.useEffect)(function () {\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []); //send call-in functions to host\n\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.getFunctions) return;\n    var scrollToItem = serviceHandler.scrollToItem,\n        reload = serviceHandler.reload,\n        setListsize = serviceHandler.setListsize,\n        clearCache = serviceHandler.clearCache,\n        getCacheIndexMap = serviceHandler.getCacheIndexMap,\n        getCacheItemMap = serviceHandler.getCacheItemMap,\n        getCradleIndexMap = serviceHandler.getCradleIndexMap,\n        remapIndexes = serviceHandler.remapIndexes,\n        moveIndex = serviceHandler.moveIndex,\n        insertIndex = serviceHandler.insertIndex,\n        removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToItem: scrollToItem,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.getFunctions(functions);\n  }, []); // initialize window scroll listener\n\n  (0, react_1.useEffect)(function () {\n    var viewportdata = ViewportContextPropertiesRef.current;\n    viewportdata.elementRef.current.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportdata.elementRef.current && viewportdata.elementRef.current.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []); // observer support\n\n  /*\n      There are two interection observers: one for the cradle wings, and another for triggerlines;\n          both against the viewport.\n      There is also a resize observer for the cradle wings, to generate responses to size changes of\n          variable cells.\n  */\n\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n        triggerlinesIntersect = interruptHandler.triggerlinesIntersect,\n        cradleResize = interruptHandler.cradleResize; // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements(); // triggerobserver tiggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n\n    var triggerobserver = triggerlinesIntersect.createObserver(); // interruptHandler.triggerlinesIntersect.connectElements()\n    // resize observer generates compensation for changes in cell sizes for variable layout modes\n\n    var cradleresizeobserver = cradleResize.createObserver();\n    cradleResize.connectElements();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n      cradleresizeobserver.disconnect();\n    };\n  }, []); // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize;\n\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n          deleteListCallback = _serviceHandler$callb.deleteListCallback,\n          changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n\n      cacheHandler.changeListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []); // caching change\n\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n\n    if (cradleStateRef.current == 'setup') return;\n\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('changecaching');\n          break;\n        }\n\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n\n          var _dListCallback;\n\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]); // trigger viewportresizing response based on viewport state\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // console.log('isResizing useEffect: cradleState, isResizing, isCached, wasCached',\n    //     cradleStateRef.current,ViewportContextPropertiesRef.current.isResizing,\n    //     isCachedRef.current, wasCachedRef.current)\n    // movement to and from cache is independent of ui viewportresizing\n\n    if (isCachedRef.current || wasCachedRef.current) {\n      // console.log('returning from resize effect for caching state')\n      return;\n    }\n\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    } // complete viewportresizing mode\n\n\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]); // reconfigure for changed size parameters\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [listsize, cellHeight, cellWidth, gap, padding, triggerlineOffset]); // pivot triggered on change of orientation\n\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      return;\n    }\n\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n        cellWidth = _cradleInheritedPrope.cellWidth,\n        cellHeight = _cradleInheritedPrope.cellHeight,\n        gap = _cradleInheritedPrope.gap; // get previous ratio\n\n    var previousCellPixelLength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n    var previousratio = previousAxisOffset / previousCellPixelLength;\n    var pivotCellPixelLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n    var pivotAxisOffset = previousratio * pivotCellPixelLength;\n    layoutHandler.cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]); // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n\n  var _ref8 = (0, react_1.useMemo)(function () {\n    return stylesHandler.getCradleStyles({\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      varHeightMin: varHeightMin,\n      varWidthMin: varWidthMin,\n      gap: gap,\n      padding: padding,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth,\n      crosscount: crosscount,\n      userstyles: styles,\n      triggerlineOffset: triggerlineOffset\n    });\n  }, [orientation, cellHeight, cellWidth, varHeightMin, varWidthMin, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset]),\n      _ref9 = _slicedToArray(_ref8, 6),\n      cradleHeadStyle = _ref9[0],\n      cradleTailStyle = _ref9[1],\n      cradleAxisStyle = _ref9[2],\n      cradleDividerStyle = _ref9[3],\n      triggercellTriggerlineHeadStyle = _ref9[4],\n      triggercellTriggerlineTailStyle = _ref9[5]; // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (19 states), using named states\n  // useLayoutEffect for suppressing flashes\n\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.cacheProps.modified = true;\n              cacheHandler.renderPortalList();\n            }\n\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n\n          cacheHandler.preload(cradleParametersRef.current, finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n\n\n          break;\n        }\n      // moving out of cache into visible DOM tree (cellFrame)\n      // resets scrollPos (scrollLeft/scrollTop) to last UI value\n\n      case 'parentingtransition':\n        {\n          var cradlePositionData = layoutHandler.cradlePositionData; // reset scroll position to previous value\n\n          if (cradlePositionData.blockScrollPos !== null) {\n            var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n            viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n          }\n\n          setCradleState('finishparenting');\n          break;\n        }\n\n      case 'finishparenting':\n        {\n          interruptHandler.restoreInterrupts();\n\n          if (hasBeenRenderedRef.current) {\n            setCradleState('ready'); // setCradleState('restoreinterrupts')\n          } else {\n            setCradleState('firstrenderfromcache');\n          }\n\n          break;\n        }\n\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true; // avoid recursive cradle intersection interrupts\n\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n\n          setCradleState('repositioningRender'); // toggles with repositioningContinuation\n\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n\n      /*\n          the following 11 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts'\n      */\n\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reload':\n        {\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = []; // register new array id for Object.is to trigger react re-processing\n          // cradleContent.headDisplayComponents = []\n          // cradleContent.tailDisplayComponents = []\n\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          } // set data\n\n\n          contentHandler.setCradleContent(cradleState);\n\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          } // synchronize cache if necessary\n\n\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalList();\n            }\n          } // prepare the cycle for preparerender\n\n\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents; // update virtual DOM\n\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n\n          break;\n        }\n\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n\n      case 'preparesetforvariability':\n        {\n          console.log('--\x3esetTimeout for setContent', cradleState);\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability();\n            setCradleState('finishsetforvariability');\n          }, TIMEOUT_FOR_VARIABLE_MEASUREMENTS);\n          break;\n        }\n\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements(); // this can be pre-empted by reparenting, which itself restores interrupts\n\n          setCradleState('restoreinterrupts'); // to restore interrupts\n\n          break;\n        }\n\n      case 'restoreinterrupts':\n        {\n          // normalize or resume cycling\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents; // update virtual DOM\n\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n\n          cacheHandler.renderPortalList();\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n\n          if (_layout2 == 'uniform') {\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            interruptHandler.triggerlinesIntersect.connectElements();\n            interruptHandler.signals.pauseTriggerlinesObserver = false;\n            setCradleState('ready');\n          } else {\n            setCradleState('refreshDOMupdateforvariability');\n          }\n\n          break;\n        }\n\n      case 'refreshDOMupdateforvariability':\n        {\n          // console.log('==> cradleState: refreshDOMupdateforvariability')\n          // extra cycle needed to allow time to synchronize DOM with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n\n      case 'adjustupdateforvariability':\n        {\n          contentHandler.adjustScrollblockForVariability();\n          setCradleState('finishupdateforvariability');\n          break;\n        }\n      // called from onAfterScroll. \n      // This can be called twice in succession with short onAfterScroll timeout\n\n      case 'adjustupdateforvariabilityafterscroll':\n        {\n          contentHandler.adjustScrollblockForVariability('afterscroll');\n          setCradleState('ready');\n          break;\n        }\n\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseTriggerlinesObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      // support for various host service requests; syncs cradle content with cache changes\n\n      case 'applycellframechanges':\n        {\n          // user intervention\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          var portalHoldList = cacheHandler.portalHoldList;\n          var portalMap = cacheHandler.cacheProps.portalMap;\n\n          if (portalHoldList && portalHoldList.length) {\n            var _iterator = _createForOfIteratorHelper(portalHoldList),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var itemID = _step.value;\n                portalMap[\"delete\"](itemID);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n\n          setCradleState('ready');\n          break;\n        }\n\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]); // for cradle resize events; these are asynchronous\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleResizeState) {\n      case 'resizeready':\n        break;\n\n      case 'resizecradle':\n        setCradleResizeState('resizeready');\n        break;\n    }\n  }, [cradleResizeState]); // standard rendering states (3 states)\n\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]); // ==========================[ RENDER ]===========================\n\n  var scrollAxisReferenceIndex = layoutHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!useScrollTracker) return null;\n\n    if (!['repositioningContinuation', 'repositioningRender'].includes(cradleState)) {\n      return null;\n    }\n\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    // console.log('generating triggercell triggerlines')\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'triggercell-triggerline-head',\n      \"data-direction\": 'forward',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'triggercell-triggerline-tail',\n      \"data-direction\": 'backward',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionsCallback: serviceHandler.callbacks.itemExceptionsCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  }); // display the cradle components, the ScrollTracker, or null\n\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ? // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\n\n\nexports[\"default\"] = Cradle; // utility\n\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  cacheHandler.cradleParameters = cradleParameters;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWEsQ0FBQ0UsNkJBQUQsQ0FIM0I7SUFJSG5ILGFBQWEsRUFBQ2lILGFBQWEsQ0FBQ0csMEJBQUQsQ0FKeEI7SUFLSG5ILFlBQVksRUFBQ2dILGFBQWEsQ0FBQ0kseUJBQUQsQ0FMdkI7SUFNSG5ILGNBQWMsRUFBQytHLGFBQWEsQ0FBQ0ssMkJBQUQsQ0FOekI7SUFPSG5ILGFBQWEsRUFBQzhHLGFBQWEsQ0FBQ00sMEJBQUQsQ0FQeEI7SUFRSG5ILGNBQWMsRUFBQzZHLGFBQWEsQ0FBQ08sMkJBQUQsQ0FSekI7SUFTSG5ILGFBQWEsRUFBQzRHLGFBQWEsQ0FBQ1EsMEJBQUQ7RUFUeEIsQ0FBUDtBQWFILENBckJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DcmFkbGUudHN4PzcxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3JhZGxlLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgQ3JhZGxlIGRvZXMgdGhlIGJ1bGsgb2YgdGhlIHdvcmsgZm9yIHRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyLiBJdCBkb2VzIHNvIHdpdGggdGhlIGhlbHAgb2ZcbiAgICBlaWdodCBwcm9jZXNzIGhhbmRsZXJzLCBhbmQgb25lIG1haW4gc3ViLWNvbXBvbmVudCAtIHRoZSBDZWxsRnJhbWUuXG5cbiAgICBDcmFkbGUncyBtYWluIHJlc3BvbnNpYmlsaXR5IGlzIHRvIG1hbmFnZSB0aGUgc3RhdGUgY2hhbmdlIGZsb3dzIG9mIHRoZSBjb250ZW50LlxuXG4gICAgVGhlIGlsbHVzaW9uIG9mIGluZmluaXRlIGNvbnRlbnQgaXMgbWFpbnRhaW5lZCBieSBzeW5jaHJvbml6aW5nIGNoYW5nZXMgaW4gY3JhZGxlIGNvbnRlbnQgd2l0aCB0aGVcbiAgICBDcmFkbGUgbG9jYXRpb24gaW5zaWRlIHRoZSBTY3JvbGxibG9jaywgc3VjaCB0aGF0IGFzIHRoZSBTY3JvbGxibG9jayBpcyBtb3ZlZCwgdGhlIGNyYWRsZSBtb3ZlcyBcbiAgICBvcHBvc2l0ZWx5IHRvIHN0YXkgdmlzaWJsZSB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuXG4gICAgVGhlIFNjcm9sbGJsb2NrIGlzIHNpemVkIHRvIGFwcHJveGltYXRlIHRoZSBsaXN0IGJlaW5nIHZpZXdlZCwgc28gYXMgdG8gaGF2ZSBhIHNjcm9sbCB0aHVtYiBzaXplIFxuICAgIGFuZCBwb3NpdGlvbiB3aGljaCByZWFsaXN0aWNhbGx5IHJlZmxlY3RzIHRoZSBzaXplIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBjcmFkbGUgaXMgY29udHJvbGxlZCBieSBhbiAnYXhpcycgd2hpY2ggaXMgYSAwcHggaGVpZ2h0L3dpZHRoIGRpdlxuICAgIChhbG9uZyB0aGUgbWVkaWFsIC0gU2Nyb2xsQmxvY2sgY2FuIGJlIHZlcnRpY3NsIG9yIGhvcml6b250YWwpLiBUaGUgcHVycG9zZSBvZiB0aGUgYXhpcyBpcyB0byBcbiAgICBhY3QgYXMgYSAnZm9sZCcsIGFib3ZlIHdoaWNoIGNyYWRsZSBjb250ZW50IGV4cGFuZHMgJ3Vwd2FyZHMnIGluIHRoZSBDcmFkbGUsIGFuZCBiZWxvdyB3aGljaCB0aGUgXG4gICAgY3JhZGxlIGNvbnRlbnQgZXhwYW5kcyAnZG93bndhcmRzJy4gVGhlIENyYWRsZSBjb250ZW50IGlzIGhlbGQgaW4gdHdvIENTUyBncmlkcyAoY2hpbGRyZW4gb2YgdGhlIGF4aXMpOiBcbiAgICBvbmUgYWJvdmUsIGFuZCBvbmUgYmVsb3cgdGhlIHBvc2l0aW9uIG9mIHRoZSBheGlzLlxuXG4gICAgVGhlIGF4aXMgaXMgYWx3YXlzIGtlcHQgbmVhciB0aGUgbGVhZGluZyAoaGVhZHdhcmQpIGVkZ2Ugb2YgdGhlIHZpc2libGUgY2VsbHJvd3Mgb2YgdGhlIHZpZXdwb3J0XG4gICAgKHRoZXJlIGFyZSBzb21lIGVkZ2UtY2FzZSBleGNlcHRpb25zKS5cblxuICAgIFRlY2huaWNhbGx5LCB0aGVyZSBhcmUgc2V2ZXJhbCBrZXkgcmVmZXJlbmNlIHBvaW50cyB0cmFja2VkIGJ5IHRoZSBDcmFkbGUuIFRoZXNlIGFyZTpcbiAgICAgICAgLSBheGlzUmVmZXJlbmNlSW5kZXggaXMgdGhlIHZpcnR1YWwgaW5kZXggb2YgdGhlIGl0ZW0gY29udHJvbGxpbmcgdGhlIGxvY2F0aW9uIG9mIHRoZSBheGlzLlxuICAgICAgICAgICAgVGhlIGF4aXNSZWZlcmVuY2VJbmRleCBpcyBhbHNvIHVzZWQgdG8gYWxsb2NhdGUgaXRlbXMgYWJvdmUgKGxvd2VyIGluZGV4IHZhbHVlKSBhbmQgYmVsb3cgXG4gICAgICAgICAgICAoc2FtZSBvciBoaWdoZXIgaW5kZXggdmFsdWUpIHRoZSBheGlzIGZvbGQuIFRoZSBheGlzUmVmZXJuY2VJbmRleCBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgXG4gICAgICAgICAgICB0YWlsIHNlY3Rpb24gb2YgdGhlIENyYWRsZS5cbiAgICAgICAgLSAoY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgaW5mZXJyZWQgZnJvbSB0aGUgYXhpc1JlZmVyZW5jZUluZGV4LCBhbmQgaXMgdGhlIHZpcnR1YWwgaW5kZXggb2YgXG4gICAgICAgICAgICB0aGUgaXRlbSBkZWZpbmluZyB0aGUgbGVhZGluZyBib3VuZCBvZiB0aGUgY3JhZGxlIGNvbnRlbnQuIFRoZSBjcmFkbGVSZWZlcmVuY2VJbmRleCBpcyB0aGUgXG4gICAgICAgICAgICBmaXN0IGl0ZW0gaW4gdGhlIGhlYWQgc2VjdGlvbiBvZiB0aGUgQ3JhZGxlKVxuICAgICAgICAtIGF4aXNQaXhlbE9mZnNldCAocGl4ZWxzIHRoYXQgcGxhY2UgdGhlIGF4aXMgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0J3MgbGVhZGluZyBlZGdlKVxuICAgICAgICAtIHRoZSBibG9ja1Njcm9sbFBvcywgd2hpY2ggaXMgdGhlIGFtb3VudCBvZiBzY3JvbGwgb2YgdGhlIFNjcm9sbEJsb2NrXG4gICAgXG4gICAgT3ZlcnNjcm9sbCBoYW5kbGluZzpcbiAgICAgICAgT3dpbmcgdG8gdGhlIHBvdGVudGlhbCByYXBpZGl0eSBvZiBzY3JvbGxpbmcsIHdoaWNoIGluIHRoZSBjYXNlIG9mIGxhcmdlIGxpc3RzIGFuZCBoZWF2eSBjb250ZW50IFxuICAgICAgICBjYW4gYmUgdG9vIGZhc3QgZm9yIHRoZSBzeXN0ZW0gdG8ga2VlcCB1cCwgdGhlcmUgaXMgYW4gb3ZlcnNjcm9sbCBwcm90b2NvbCBjYWxsZWQgJ3JlcG9zaXRpb25pbmcnLlxuXG4gICAgICAgIElmIHRoZSBvdmVyc2Nyb2xsIGlzIHN1Y2ggdGhhdCB0aGUgY3JhZGxlIGhhcyBlbnRpcmVseSBwYXNzZWQgb3V0IG9mIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGUgQ3JhZGxlXG4gICAgICAgIGlzIHJlcGxhY2VkIGJ5IGEgU2Nyb2xsVHJhY2tlciAob3IgYnkgbnVsbCBpZiB0aGUgaG9zdCB0YWtlcyByZXNwb25zaWJpbGl0eSBmb3IgZmVlZGJhY2spLiBcbiAgICAgICAgVGhlIFNjcm9sbFRyYWNrZXIgc2hvd3MgdGhlIHJlbGF0aXZlIGxvY2F0aW9uIGluIHRoZSB2aXJ0dWFsIGxpc3QgYXQgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IFxuICAgICAgICBkdXJpbmcgcmVwb3NpdGlvbmluZy4gV2hlbiB0aGUgc2Nyb2xsaW5nIHN0b3BzIENyYWRsZSByZWNyZWF0ZXMgdGhlIGNyYWRsZSBjb250ZW50LCBhY2NvcmRpbmcgdG8gXG4gICAgICAgIHRoZSBmaW5hbCBwb3NpdGlvbiBvZiB0aGUgcmVwb3NpdGlvbmluZyBwcm9jZXNzLlxuXG4gICAgQ3JhZGxlIGlzIGFjdGl2YXRlZCBieSBpbnRlcnJ1cHRzOlxuICAgIC0gc2Nyb2xsaW5nXG4gICAgLSByZXNpemluZyBvZiB0aGUgdmlld3BvcnRcbiAgICAtIG9ic2VydmVyIGNhbGxiYWNrczpcbiAgICAgICAgLSBjcmFkbGUvdmlld3BvcnQgaW50ZXJzZWN0aW9uIGZvciByZXBvc2l0aW9uaW5nIHdoZW4gdGhlIGNyYWRsZSByYWNlcyBvdXQgb2Ygc2NvcGVcbiAgICAgICAgLSB0d28gJ3RyaWdnZXJsaW5lJy92aWV3cG9ydCBpbnRlcnNlY3Rpb25zIHdoaWNoIHRyaWdnZXIgcm9sbGluZyBvZiBjb250ZW50XG4gICAgICAgICAgICAtIHJvbGxpbmcgY29udGVudCB0cmlnZ2VycyByZS1hbGxvY2F0aW9uIG9mIGNvbnRlbnQgYmV0d2VlbiBjcmFkbGUgaGVhZCBhbmQgdGFpbCBncmlkc1xuICAgICAgICAtIGNyYWRsZSBncmlkIHJlc2l6aW5nIHJlc3BvbmRpbmcgdG8gdmFyaWFibGUgY2VsbCBsZW5ndGggY2hhbmdlcyAoaW4gJ3ZhcmlhYmxlJyBsYXlvdXQgbW9kZSkgXG4gICAgICAgICAgICB3aGljaCB0cmlnZ2VycyByZWNvbmZpZ3VyYXRpb25cbiAgICAtIHBpdm90IC0gY2hhbmdlIG9mIG9yaWVudGF0aW9uXG4gICAgLSBob3N0IGNoYW5nZXMgb2YgY29uZmlndXJhdGlvbiBzcGVjcyB0aHJvdWdoIHByb3BlcnR5IGNoYW5nZXMgb3IgZGlyZWN0IHNlcnZpY2UgY2FsbHNcbiovXG5cbmltcG9ydCBSZWFjdCwgeyBcbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlUmVmLCBcbiAgICB1c2VDb250ZXh0LCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlTWVtbyxcbiAgICB1c2VDYWxsYmFjaywgXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL1ZpZXdwb3J0J1xuXG4vLyBwb3B1cCBwb3NpdGlvbiB0cmFja2VyIGZvciByZXBvc2l0aW9uaW5nXG5pbXBvcnQgU2Nyb2xsVHJhY2tlciBmcm9tICcuL2NyYWRsZS9TY3JvbGxUcmFja2VyJ1xuXG4vLyBzdXBwb3J0IGNvZGU7IHByb2Nlc3MgaGFuZGxlcnNcbmltcG9ydCBTY3JvbGxIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3Njcm9sbGhhbmRsZXInXG5pbXBvcnQgU3RhdGVIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3N0YXRlaGFuZGxlcidcbmltcG9ydCBDb250ZW50SGFuZGxlciBmcm9tICcuL2NyYWRsZS9jb250ZW50aGFuZGxlcidcbmltcG9ydCBMYXlvdXRIYW5kbGVyIGZyb20gJy4vY3JhZGxlL2xheW91dGhhbmRsZXInXG5pbXBvcnQgSW50ZXJydXB0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyJ1xuaW1wb3J0IFNlcnZpY2VIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3NlcnZpY2VoYW5kbGVyJ1xuaW1wb3J0IFN0eWxlc0hhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc3R5bGVzaGFuZGxlcidcbi8vIGNhY2hlSGFuZGxlciBpcyBpbXBvcnRlZCBhcyBhIHByb3BlcnR5OyBpbnN0YW50aWF0ZWQgYXQgdGhlIHJvb3RcblxuLy8gZm9yIGNoaWxkcmVuXG5leHBvcnQgY29uc3QgQ3JhZGxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuLy8gY29tcG9uZW50XG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ3JpZFNwZWNzLFxuXG4gICAgICAgIHJ1bndheVNpemUsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIFxuICAgICAgICB1c2VyQ2FsbGJhY2tzLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgLy8gZm9yIGhhbmRsZXIgbGlzdFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIC8vIHN5c3RlbVxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyLFxuICAgICAgICBzaG93QXhpcyxcbiAgICAgICAgTUlOX01BWF9ERUxUQV9SQVRJTyxcbiAgICAgICAgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwsXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG4gICAgICAgIFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyxcbiAgICB9KSA9PiB7XG5cbiAgICBpZiAobGlzdHNpemUgPT0gMCkgcmV0dXJuIG51bGwgLy8gbm90aGluZyB0byBkb1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBEQVRBIFNFVFVQIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVucGFjayBncmlkU3BlY3NcbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICB2YXJIZWlnaHRNaW4sXG4gICAgICAgIHZhcldpZHRoTWluLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICAvLyBnZXQgdmlld3BvcnQgY29udGV4dFxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIC8vIGZvciBjbG9zdXJlc1xuXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNcbiAgICBjb25zdCB7IGhlaWdodDp2aWV3cG9ydGhlaWdodCx3aWR0aDp2aWV3cG9ydHdpZHRoIH0gPSB2aWV3cG9ydERpbWVuc2lvbnNcblxuICAgIC8vIHN0YXRlXG4gICAgY29uc3QgW2NyYWRsZVN0YXRlLCBzZXRDcmFkbGVTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuICAgIGNvbnN0IGNyYWRsZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPSBjcmFkbGVTdGF0ZVxuXG4gICAgY29uc3QgW2NyYWRsZVJlc2l6ZVN0YXRlLCBzZXRDcmFkbGVSZXNpemVTdGF0ZV0gPSB1c2VTdGF0ZSgncmVzaXplcmVhZHknKVxuICAgIGNvbnN0IGNyYWRsZVJlc2l6ZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVJlc2l6ZVN0YXRlUmVmLmN1cnJlbnQgPSBjcmFkbGVSZXNpemVTdGF0ZVxuXG4gICAgLy8gY29uc29sZS5sb2coJz09PiBjcmFkbGVTdGF0ZScsJy0nK3Njcm9sbGVySUQrJy0nLGNyYWRsZVN0YXRlKVxuXG4gICAgLy8gZmxhZ3NcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0NhY2hlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCB3YXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IGhhc0JlZW5SZW5kZXJlZFJlZiA9IHVzZVJlZihmYWxzZSlcblxuICAgIC8vIGNyYWRsZSBzY2FmZm9sZCBlbGVtZW50IHJlZnNcbiAgICBjb25zdCBoZWFkQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRhaWxDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgYXhpc0NyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyBjb25zdCBheGlzVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gY29uc3QgaGVhZFRyaWdnZXJsaW5lQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gbGF5b3V0IGJ1bmRsZVxuICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkUmVmOmhlYWRDcmFkbGVFbGVtZW50UmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWY6dGFpbENyYWRsZUVsZW1lbnRSZWYsIFxuICAgICAgICAgICAgYXhpc1JlZjpheGlzQ3JhZGxlRWxlbWVudFJlZixcbiAgICAgICAgICAgIC8vIGF4aXNUcmlnZ2VybGluZVJlZjpheGlzVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmLFxuICAgICAgICAgICAgLy8gaGVhZFRyaWdnZXJsaW5lUmVmOmhlYWRUcmlnZ2VybGluZUNyYWRsZUVsZW1lbnRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZjp0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZjp0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbEVsZW1lbnRSZWYsXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZWQgcHJvcGVydGllcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29uZmlndXJhdGlvbiBjYWxjdWxhdGlvbnNcblxuICAgIC8vIGNyb3NzY291bnQgKGFsc28gY2FsY3VsYXRlZCBieSBTY3JvbGxibG9jayBmb3IgZGVyaXZpbmcgU2Nyb2xsYmxvY2sgbGVuZ3RoKVxuICAgIGNvbnN0IGNyb3NzY291bnQgPSB1c2VNZW1vKCgpID0+IHsgLy8gdGhlIG51bWJlciBvZiBjZWxscyBjcm9zc2luZyBvcmllbnRhdGlvblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVjYWxjdWxhdGluZyBjcm9zc2NvdW50JylcbiAgICAgICAgY29uc3Qgdmlld3BvcnRjcm9zc2xlbmd0aCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQ6XG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aFxuXG4gICAgICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoID09IDApIHtcblxuICAgICAgICAgICAgcmV0dXJuIDBcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3Jvc3MgbGVuZ3RoIG9mIHZpZXdwb3J0IChnYXAgdG8gbWF0Y2ggY3Jvc3NMZW5ndGgpXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjID0gdmlld3BvcnRjcm9zc2xlbmd0aCAtIChwYWRkaW5nICogMikgKyBnYXAgXG5cbiAgICAgICAgY29uc3QgY2VsbGNyb3NzbGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ICsgZ2FwOlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCArIGdhcFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aGZvcmNhbGMgPSBcbiAgICAgICAgICAgIE1hdGgubWluKGNlbGxjcm9zc2xlbmd0aCx2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYykgLy8gcmVzdWx0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMVxuXG4gICAgICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjL2NlbGxjcm9zc2xlbmd0aGZvcmNhbGMpXG5cbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICAvLyB2YXJpb3VzIHJvdyBjb3VudHNcbiAgICBjb25zdCBbXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LCBcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LCAvLyBtYXggbnVtYmVyIG9mIHJvd3MgY29tcGxldGVseSB2aXNpYmxlIGF0IG9uY2VcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICBdID0gdXNlTWVtbygoKT0+IHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVjYWxjdWxhdGluZyByb3cgY291bnRzJylcblxuICAgICAgICBsZXQgdmlld3BvcnRMZW5ndGgsIGJhc2VSb3dMZW5ndGhcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0TGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcbiAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsSGVpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWV3cG9ydExlbmd0aCA9IHZpZXdwb3J0d2lkdGhcbiAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsV2lkdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VSb3dMZW5ndGggKz0gZ2FwXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRSb3djb3VudCA9IE1hdGguY2VpbCh2aWV3cG9ydExlbmd0aC9iYXNlUm93TGVuZ3RoKVxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydExlbmd0aC9iYXNlUm93TGVuZ3RoKVxuXG4gICAgICAgIGNvbnN0IGxpc3RSb3djb3VudCA9IE1hdGguY2VpbChsaXN0c2l6ZS9jcm9zc2NvdW50KVxuXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG5cbiAgICAgICAgbGV0IGNyYWRsZVJvd2NvdW50ID0gTWF0aC5taW4obGlzdFJvd2NvdW50LCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG5cbiAgICAgICAgbGV0IHJ1bndheVJvd2NvdW50XG4gICAgICAgIGlmIChjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPj0gY3JhZGxlUm93Y291bnQpIHtcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gcnVud2F5U2l6ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IChjcmFkbGVSb3djb3VudCAtIGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudClcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50IC09IE1hdGguZmxvb3IoZGlmZi8yKVxuICAgICAgICAgICAgcnVud2F5Um93Y291bnQgPSBNYXRoLm1heCgwLHJ1bndheVJvd2NvdW50KVxuICAgICAgICB9XG4gICAgICAgIGxldCBpdGVtY291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICAgICAgaWYgKGl0ZW1jb3VudCA+IGxpc3RzaXplKSB7XG4gICAgICAgICAgICBpdGVtY291bnQgPSBsaXN0c2l6ZVxuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQgPSBNYXRoLmNlaWwoaXRlbWNvdW50L2Nyb3NzY291bnQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBydW53YXlTaXplLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgIF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxsYmFja3MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGhvc3QgY2FsbGJhY2tzLCB1cGFja2VkIGJ5IHNlcnZpY2VIYW5kbGVyXG4gICAgY29uc3QgZXh0ZXJuYWxDYWxsYmFja3NSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucmVmZXJlbmNlSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayxcbiAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmRlbGV0ZUxpc3RDYWxsYmFjayxcbiAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uY2hhbmdlTGlzdHNpemVDYWxsYmFjayxcbiAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayxcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tWyBidW5kbGUgcHJvcGVydGllcyBmb3IgaGFuZGxlcnMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJ1bmRsZSBhbGwgY3JhZGxlIHByb3BzIHRvIHBhc3MgdG8gaGFuZGxlcnMgLSB1bHRpbWF0ZWx5IGNyYWRsZVBhcmFtZXRlcnNSZWZcbiAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlcyBhbmQgc3VwcG9ydCBjYWxsYmFja3NcbiAgICAvLyB1cCB0byBkYXRlIHZhbHVlc1xuICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgLy8gZ3JpZFNwZWNzXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICB2YXJIZWlnaHRNaW4sXG4gICAgICAgIHZhcldpZHRoTWluLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIC8vIC4uLnJlc3RcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgdXNlckNhbGxiYWNrcyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIE1JTl9NQVhfREVMVEFfUkFUSU8sXG4gICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMLFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG5cbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gcGFzc2VkIHRvIGNlbGxGcmFtZSBjb250ZW50ICh1c2VyIGNvbnRlbnQpIGlmIHJlcXVlc3RlZFxuICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIHZhckhlaWdodE1pbixcbiAgICAgICAgdmFyV2lkdGhNaW4sIFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gc2hhcmUgd2l0aCBoYW5kbGVyc1xuICAgIGNvbnN0IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuXG4gICAgICAgIC8vIHVwZGF0ZWQgdmFsdWVzXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG5cbiAgICAgICAgLy8gZm9yIHN0YXRlSGFuZGxlclxuICAgICAgICBjcmFkbGVTdGF0ZVJlZixcbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUsXG4gICAgICAgIGNyYWRsZVJlc2l6ZVN0YXRlUmVmLFxuICAgICAgICBzZXRDcmFkbGVSZXNpemVTdGF0ZSxcbiAgICB9XG5cbiAgICAvLyBwbGFjZWhvbGRlciBpbiBjcmFkbGVQYXJhbWV0ZXJzIHRvIG1ha2UgYXZhaWxhYmxlIGluZGl2aWR1YWwgaGFuZGxlcnNcbiAgICBjb25zdCBoYW5kbGVyc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gY3JhZGxlIHBhcmFtZXRlcnMgTUFTVEVSIEJVTkRMRVxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnMgPSB7XG4gICAgICAgIGhhbmRsZXJzUmVmLFxuICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLFxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGV4dGVybmFsQ2FsbGJhY2tzUmVmLFxuICAgIH1cblxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVQYXJhbWV0ZXJzUmVmLmN1cnJlbnQgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBvbmdvaW5nIHNvdXJjZSBvZiBoYW5kbGVycyAtIG5vdGUgYWxsIEhhbmRsZXJzIGFyZSBnaXZlbiBhbGwgcGFyYW1ldGVycyAoY3JhZGxlUGFyYW1ldGVycylcbiAgICBpZiAoIWhhbmRsZXJzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaGFuZGxlcnNSZWYuY3VycmVudCA9IGdldENyYWRsZUhhbmRsZXJzKGNyYWRsZVBhcmFtZXRlcnMpXG4gICAgfVxuXG4gICAgLy8gbWFrZSBoYW5kbGVycyBkaXJlY3RseSBhdmFpbGFibGUgdG8gY3JhZGxlIGNvZGUgYmVsb3dcbiAgICBjb25zdCB7IC8vIGNhY2hlSGFuZGxlciBhbHJlYWR5IGF2YWlsYWJsZVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICBzY3JvbGxIYW5kbGVyLFxuICAgICAgICBzdGF0ZUhhbmRsZXIsXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgc3R5bGVzSGFuZGxlcixcbiAgICB9ID0gaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1bIElOVEVSQ0VQVCBDQUNISU5HIFNUQVRFIENIQU5HRSBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKiAgICBcbiAgICBJbnRlcmNlcHQgY2hhbmdlIGluIGNhY2hpbmcgc3RhdHVzOlxuICAgIHdoZW4gYSBwb3J0YWwgaXMgY2FjaGVkLCBpbmNsdWRpbmcgdGhlIHRyYW5zaXRpb24gb2YgYmVpbmcgbW92ZWQgZnJvbSBvbmUgY2VsbEZyYW1lIHRvIGFub3RoZXIsXG4gICAgKGFuZCB0aGUgaW5maW5pdGVncmlkc2Nyb2xsZXIgY2FuIGJlIGEgY29tcG9uZW50IHRoYXQgaXMgY2FjaGVkKSxcbiAgICB0aGUgc2Nyb2xsUG9zIChzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCkgaXMgcmVzZXQgdG8gMCAoemVybykuIFdoZW4gdGhlIHNjcm9sbGVyIGlzIFxuICAgIG1vdmVkIHRvIGEgY2VsbEZyYW1lLCB0aGlzIGNvZGUgdHJpZ2dlcnMgcmVzdG9yYXRpb24gdGhlIHNjcm9sbFBvcyAoc2VlIGNhc2UgJ3BhcmVudGluZ3RyYW5zaXRpb24nXG4gICAgaW4gdGhlIHN0YXRlIG1hbmFnZW1lbnQgc2VjdGlvbiBiZWxvdykuXG4gICAgVGhlIHJlc3RvcmUgYWN0aW9uIG11c3QgYmUgdGhlIGZpcnN0IHByaW9yaXR5IHRvIGhpZGUgdGhlIHNjcm9sbFBvcyBjaGFuZ2VzIGZyb20gdGhlIHVzZXJcbiovXG4gICAgLy8gemVybyB3aWR0aCBhbmQgaGVpZ2h0IG1lYW5zIHRoZSBjb21wb25lbnQgbXVzdCBiZSBpbiBwb3J0YWwgKGNhY2hlKSBzdGF0ZVxuICAgIGNvbnN0IGlzSW5Qb3J0YWwgPSAoKHZpZXdwb3J0d2lkdGggPT0gMCkgJiYgKHZpZXdwb3J0aGVpZ2h0ID09IDApKSBcblxuICAgIGNvbnN0IGlzQ2FjaGVDaGFuZ2UgPSAoaXNJblBvcnRhbCAhPSBpc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UpIHtcbiAgICAgICAgd2FzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0NhY2hlZFJlZi5jdXJyZW50XG4gICAgICAgIGlzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0luUG9ydGFsXG4gICAgfVxuXG4gICAgY29uc3QgaXNDYWNoaW5nVW5kZXJ3YXkgPSAoaXNDYWNoZWRSZWYuY3VycmVudCB8fCB3YXNDYWNoZWRSZWYuY3VycmVudClcblxuICAgIGlmIChcbiAgICAgICAgaXNDYWNoZUNoYW5nZSB8fCBcbiAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50IHx8XG4gICAgICAgIChWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcgJiYgaXNDYWNoaW5nVW5kZXJ3YXkpIFxuICAgICkgeyBcblxuICAgICAgICBpZiAoVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZi5jdXJyZW50ID0gZmFsc2UgLy8gbm8gbG9uZ2VyIG5lZWRlZFxuXG4gICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHsgLy8gY2FjaGluZyBvcCBpcyB1bmRlcndheSwgc28gY2FuY2VsXG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZyA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhY2hlQ2hhbmdlKSB7IC8vIGludG8gb3Igb3V0IG9mIGNhY2hpbmdcblxuICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgc3RhdGUgZm9yIHJlc3RvcmluZyBzY3JvbGxQb3NcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyBpZiBpcyBjYWNoZWQsIHRoZW4gdGhlIG5leHQgZWZmZWN0IChmb3IgZW50ZXJpbmcgb3IgbGVhdmluZyBjYWNoZSkgaGFzIGFub3RoZXIgdHVyblxuICAgICAgICBpZiAocGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgPSBmYWxzZSAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuICAgICAgICB9XG5cbiAgICB9LFtwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyBjaGFuZ2Ugc3RhdGUgZm9yIGVudGVyaW5nIG9yIGxlYXZpbmcgY2FjaGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm4gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50ICYmICF3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBpbnRvIGNhY2hlXG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKSAvLyByZXBsYWNlcyAncmVhZHknIGFzIHN0ZWFkeSBzdGF0ZVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHsgLy8gb3V0IG9mIGNhY2hlXG5cbiAgICAgICAgICAgIHdhc0NhY2hlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IGZhbHNlICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtpc0NhY2hlZFJlZi5jdXJyZW50LCB3YXNDYWNoZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09WyBJTklUSUFMSVpBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWZmZWN0cyBhcmUgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xuXG4gICAgLy8gY2xlYXIgbW91bnRlZCBmbGFnIG9uIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyB1bm1vdW50XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy9zZW5kIGNhbGwtaW4gZnVuY3Rpb25zIHRvIGhvc3RcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoIXVzZXJDYWxsYmFja3MuZ2V0RnVuY3Rpb25zKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIHNjcm9sbFRvSXRlbSwgXG4gICAgICAgICAgICByZWxvYWQsIFxuICAgICAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgICAgICBjbGVhckNhY2hlLCBcblxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCwgXG4gICAgICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcbiAgICAgICAgICAgIHJlbWFwSW5kZXhlcyxcbiAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlSW5kZXgsXG5cbiAgICAgICAgfSA9IHNlcnZpY2VIYW5kbGVyXG5cbiAgICAgICAgY29uc3QgZnVuY3Rpb25zID0ge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0l0ZW0sXG4gICAgICAgICAgICByZWxvYWQsXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdldENhY2hlSW5kZXhNYXAsXG4gICAgICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcbiAgICAgICAgICAgIHJlbWFwSW5kZXhlcyxcbiAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlSW5kZXgsXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHVzZXJDYWxsYmFja3MuZ2V0RnVuY3Rpb25zKGZ1bmN0aW9ucylcblxuICAgIH0sW10pXG5cbiAgICAvLyBpbml0aWFsaXplIHdpbmRvdyBzY3JvbGwgbGlzdGVuZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5vblNjcm9sbClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50ICYmIHZpZXdwb3J0ZGF0YS5lbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyBvYnNlcnZlciBzdXBwb3J0XG5cbiAgICAvKlxuICAgICAgICBUaGVyZSBhcmUgdHdvIGludGVyZWN0aW9uIG9ic2VydmVyczogb25lIGZvciB0aGUgY3JhZGxlIHdpbmdzLCBhbmQgYW5vdGhlciBmb3IgdHJpZ2dlcmxpbmVzOyBcbiAgICAgICAgICAgIGJvdGggYWdhaW5zdCB0aGUgdmlld3BvcnQuXG4gICAgICAgIFRoZXJlIGlzIGFsc28gYSByZXNpemUgb2JzZXJ2ZXIgZm9yIHRoZSBjcmFkbGUgd2luZ3MsIHRvIGdlbmVyYXRlIHJlc3BvbnNlcyB0byBzaXplIGNoYW5nZXMgb2YgXG4gICAgICAgICAgICB2YXJpYWJsZSBjZWxscy5cbiAgICAqLyAgICBcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjcmFkbGVJbnRlcnNlY3QsXG4gICAgICAgICAgICB0cmlnZ2VybGluZXNJbnRlcnNlY3QsXG4gICAgICAgICAgICBjcmFkbGVSZXNpemUsXG4gICAgICAgIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIG9ic2VydmVyIGZvciBjcmFkbGUgYm9keVxuICAgICAgICAvLyB0aGlzIHNldHMgdXAgYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgb2YgdGhlIGNyYWRsZSBhZ2FpbnN0IHRoZSB2aWV3cG9ydC4gV2hlbiB0aGVcbiAgICAgICAgLy8gY3JhZGxlIGdvZXMgb3V0IG9mIHRoZSBvYnNlcnZlciBzY29wZSwgdGhlICdyZXBvc2l0aW9uaW5nUmVuZGVyJyBjcmFkbGUgc3RhdGUgaXMgdHJpZ2dlcmVkLlxuICAgICAgICBjb25zdCBjcmFkbGVpbnRlcnNlY3RvYnNlcnZlciA9IGNyYWRsZUludGVyc2VjdC5jcmVhdGVPYnNlcnZlcigpXG4gICAgICAgIGNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIC8vIHRyaWdnZXJvYnNlcnZlciB0aWdnZXJzIGNyYWRsZSBjb250ZW50IHVwZGF0ZXMgXG4gICAgICAgIC8vICAgICB3aGVuIHRyaWdnZXJsaW5lcyBwYXNzIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAvLyBkZWZlciBjb25uZWN0RWxlbWVudHMgdW50aWwgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzIGhhdmUgYmVlbiBhc3NpZ25lZFxuICAgICAgICBjb25zdCB0cmlnZ2Vyb2JzZXJ2ZXIgPSB0cmlnZ2VybGluZXNJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuICAgICAgICAvLyBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIC8vIHJlc2l6ZSBvYnNlcnZlciBnZW5lcmF0ZXMgY29tcGVuc2F0aW9uIGZvciBjaGFuZ2VzIGluIGNlbGwgc2l6ZXMgZm9yIHZhcmlhYmxlIGxheW91dCBtb2Rlc1xuICAgICAgICBjb25zdCBjcmFkbGVyZXNpemVvYnNlcnZlciA9IGNyYWRsZVJlc2l6ZS5jcmVhdGVPYnNlcnZlcigpXG4gICAgICAgIGNyYWRsZVJlc2l6ZS5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdHJpZ2dlcm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgY3JhZGxlcmVzaXplb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgUkVDT05GSUdVUkFUSU9OIGVmZmVjdHMgXT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBjaGFuZ2UgbGlzdHNpemUsIGNhY2hpbmcsIHJlc2l6ZSAoVUkgcmVzaXplIG9mIHRoZSB2aWV3cG9ydCksIHJlY29uZmlndXJlLCBvciBwaXZvdFxuXG4gICAgLy8gY2FsbGJhY2s6IHRoZSBuZXcgbGlzdCBzaXplIHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJyZW50IGxpc3RzaXplXG4gICAgLy8gaW52b2tlZCBpZiBnZXRJdGVtIHJldHVybnMgbnVsbFxuICAgIGNvbnN0IG51bGxJdGVtU2V0TWF4TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobWF4TGlzdHNpemUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdHNpemUgPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5saXN0c2l6ZVxuXG4gICAgICAgIGlmIChtYXhMaXN0c2l6ZSA8IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2dldEl0ZW0gcmV0dXJuZWQgbnVsbCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2hhbmdlTGlzdHNpemUobWF4TGlzdHNpemUsIFxuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjaylcblxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIGNhY2hpbmcgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIGlmIChjYWNoZSA9PSAncHJlbG9hZCcpIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3N0YXJ0cHJlbG9hZCcpXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBzd2l0Y2ggKGNhY2hlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2tlZXBsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1heCA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LmNhY2hlTWF4XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KGNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlY2FjaGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjcmFkbGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjaGFuZ2VjYWNoaW5nJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbY2FjaGUsIGNhY2hlTWF4XSlcblxuICAgIC8vIHRyaWdnZXIgdmlld3BvcnRyZXNpemluZyByZXNwb25zZSBiYXNlZCBvbiB2aWV3cG9ydCBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpc1Jlc2l6aW5nIHVzZUVmZmVjdDogY3JhZGxlU3RhdGUsIGlzUmVzaXppbmcsIGlzQ2FjaGVkLCB3YXNDYWNoZWQnLFxuICAgICAgICAvLyAgICAgY3JhZGxlU3RhdGVSZWYuY3VycmVudCxWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyxcbiAgICAgICAgLy8gICAgIGlzQ2FjaGVkUmVmLmN1cnJlbnQsIHdhc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgICAgIC8vIG1vdmVtZW50IHRvIGFuZCBmcm9tIGNhY2hlIGlzIGluZGVwZW5kZW50IG9mIHVpIHZpZXdwb3J0cmVzaXppbmdcbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgfHwgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JldHVybmluZyBmcm9tIHJlc2l6ZSBlZmZlY3QgZm9yIGNhY2hpbmcgc3RhdGUnKVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcpICYmIFxuICAgICAgICAgICAgICAgIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ICE9ICd2aWV3cG9ydHJlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ZpZXdwb3J0cmVzaXppbmcnKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wbGV0ZSB2aWV3cG9ydHJlc2l6aW5nIG1vZGVcbiAgICAgICAgaWYgKCFWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyAmJiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAndmlld3BvcnRyZXNpemluZycpKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h2aWV3cG9ydHJlc2l6ZScpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmddKVxuXG4gICAgLy8gcmVjb25maWd1cmUgZm9yIGNoYW5nZWQgc2l6ZSBwYXJhbWV0ZXJzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVjb25maWd1cmUnKVxuXG4gICAgfSxbXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXRcbiAgICBdKVxuXG4gICAgLy8gcGl2b3QgdHJpZ2dlcmVkIG9uIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKT9cInNjcm9sbFRvcFwiOlwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBnZXQgcHJldmlvdXMgcmF0aW9cbiAgICAgICAgY29uc3QgcHJldmlvdXNDZWxsUGl4ZWxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoOlxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc09mZnNldCA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNyYXRpbyA9IHByZXZpb3VzQXhpc09mZnNldC9wcmV2aW91c0NlbGxQaXhlbExlbmd0aFxuXG4gICAgICAgIGNvbnN0IHBpdm90Q2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBwaXZvdEF4aXNPZmZzZXQgPSBwcmV2aW91c3JhdGlvICogcGl2b3RDZWxsUGl4ZWxMZW5ndGhcbiAgICAgICAgXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gTWF0aC5yb3VuZChwaXZvdEF4aXNPZmZzZXQpXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZUF4aXNTdHlsZSxcbiAgICAgICAgY3JhZGxlRGl2aWRlclN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlLFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLmdldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIHZhckhlaWdodE1pbixcbiAgICAgICAgICAgIHZhcldpZHRoTWluLFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgIHVzZXJzdHlsZXM6c3R5bGVzLFxuICAgICAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG5cbiAgICAgICAgfSlcblxuICAgIH0sW1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIHZhckhlaWdodE1pbixcbiAgICAgICAgdmFyV2lkdGhNaW4sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG5cbiAgICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUQVRFIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZSAoMTkgc3RhdGVzKSwgdXNpbmcgbmFtZWQgc3RhdGVzXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGZvciBzdXBwcmVzc2luZyBmbGFzaGVzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29ycyB0byBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhbGwgd29ya2Zsb3cgcmVsYXRlZCwgYnV0XG4gICAgICAgICAgICAvLyByZXNpemUgY291bGQgYmUgYXN5bmNocm9ub3VzIHdoZW4gcm90YXRpbmcgcGhvbmUgZHVyaW5nIHNjcm9sbCBpbnRlcnRpYVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBhc3NpZ25tZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZSAhPSAncHJlbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyJykgLy8gbG9hZCBncmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydHJlc2l6aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgLy8gbm8tb3AsIHdhaXQgZm9yIHJlc2l6aW5nIHRvIGVuZFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cHJlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIucGFyZUNhY2hlVG9NYXgoY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHByZWxvYWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5wcmVsb2FkKGNyYWRsZVBhcmFtZXRlcnNSZWYuY3VycmVudCwgZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRClcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2NhY2hlZCc6IHtcblxuICAgICAgICAgICAgICAgIGlmICghd2FzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlIHdhaXQgZm9yIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3Zpbmcgb3V0IG9mIGNhY2hlIGludG8gdmlzaWJsZSBET00gdHJlZSAoY2VsbEZyYW1lKVxuICAgICAgICAgICAgLy8gcmVzZXRzIHNjcm9sbFBvcyAoc2Nyb2xsTGVmdC9zY3JvbGxUb3ApIHRvIGxhc3QgVUkgdmFsdWVcbiAgICAgICAgICAgIGNhc2UgJ3BhcmVudGluZ3RyYW5zaXRpb24nOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBzY3JvbGwgcG9zaXRpb24gdG8gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3NcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHBhcmVudGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHBhcmVudGluZyc6e1xuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5yZXN0b3JlSW50ZXJydXB0cygpXG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRDcmFkbGVTdGF0ZSgncmVzdG9yZWludGVycnVwdHMnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRyZXBvc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgY3JhZGxlIGludGVyc2VjdGlvbiBpbnRlcnJ1cHRzXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2UgLy8gYmVjYXVzZSBub3cgdW5kZXJ3YXlcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nUmVuZGVyJykgLy8gdG9nZ2xlcyB3aXRoIHJlcG9zaXRpb25pbmdDb250aW51YXRpb25cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgc2V0Q3JhZGxlQ29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdGhlIGZvbGxvd2luZyAxMSBjcmFkbGUgc3RhdGVzIGFsbCByZXNvbHZlIHdpdGhcbiAgICAgICAgICAgICAgICBhIGNoYWluIHN0YXJ0aW5nIHdpdGggc2V0Q3JhZGxlQ29udGVudCwgXG4gICAgICAgICAgICAgICAgY29udGludWluZyB3aXRoICdwcmVwYXJlcmVuZGVyJywgYW5kIGVuZGluZyB3aXRoXG4gICAgICAgICAgICAgICAgJ3Jlc3RvcmVpbnRlcnJ1cHRzJ1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njcm9sbHRvJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5nZWNhY2hpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocHJlbG9hZCc6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2hyZXBvc2l0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJzpcbiAgICAgICAgICAgIGNhc2UgJ3Bpdm90JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSBjb250ZW50SGFuZGxlci5jb250ZW50XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBuZXcgYXJyYXkgaWQgZm9yIE9iamVjdC5pcyB0byB0cmlnZ2VyIHJlYWN0IHJlLXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAvLyBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgLy8gY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnNldENyYWRsZUNvbnRlbnQoIGNyYWRsZVN0YXRlIClcblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSAhPSAnZmluaXNocHJlbG9hZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3luY2hyb25pemUgY2FjaGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09ICdjcmFkbGUnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY3ljbGUgZm9yIHByZXBhcmVyZW5kZXJcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlydHVhbCBET01cbiAgICAgICAgICAgICAgICBjb25zdCB7IGxheW91dCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlZnJlc2hET01zZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwcmVwYXJlc2V0Zm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0+c2V0VGltZW91dCBmb3Igc2V0Q29udGVudCcsIGNyYWRsZVN0YXRlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBuZWVkIGZvciB0aGlzIGlzIHdvcnJpc29tZVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkoKVxuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hzZXRmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICB9LFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVyZW5kZXInOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RFbGVtZW50cyBkZWxheWVkIGZvciBhIGN5Y2xlIHRvIHJlbmRlciB0cmlnZ2VyY2VsbCB0cmlnZ2VybGluZXNcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSBwcmUtZW1wdGVkIGJ5IHJlcGFyZW50aW5nLCB3aGljaCBpdHNlbGYgcmVzdG9yZXMgaW50ZXJydXB0c1xuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXN0b3JlaW50ZXJydXB0cycpIC8vIHRvIHJlc3RvcmUgaW50ZXJydXB0c1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVzdG9yZWludGVycnVwdHMnOiB7IC8vIG5vcm1hbGl6ZSBvciByZXN1bWUgY3ljbGluZ1xuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5yZXN0b3JlSW50ZXJydXB0cygpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZm9sbG93dXAgZnJvbSB1cGRhdGVDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHNjcm9sbCBlZmZlY3RzXG5cbiAgICAgICAgICAgIC8vIHJlbmRlcnVwZGF0ZWRjb250ZW50IGlzIGNhbGxlZCBmcm9tIHVwZGF0ZUNyYWRsZUNvbnRlbnQuIFxuICAgICAgICAgICAgLy8gaXQgaXMgcmVxdWlyZWQgdG8gaW50ZWdyYXRlIGNoYW5nZWQgRE9NIGNvbmZpZ3VyYXRpb25zIGJlZm9yZSAncmVhZHknIGlzIGRpc3BsYXllZFxuICAgICAgICAgICAgY2FzZSAncmVuZGVydXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlydHVhbCBET01cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuXG4gICAgICAgICAgICAgICAgLy8gc3luY2hyb25pemUgY2FjaGVcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtYWN0aXZhdGUgdHJpZ2dlcnM7IHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlZnJlc2hET011cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT4gY3JhZGxlU3RhdGU6IHJlZnJlc2hET011cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYSBjeWNsZSBuZWVkZWQgdG8gYWxsb3cgdGltZSB0byBzeW5jaHJvbml6ZSBET00gd2l0aCBncmlkIGNoYW5nZXNcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdhZGp1c3R1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxsZWQgZnJvbSBvbkFmdGVyU2Nyb2xsLiBcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCB0d2ljZSBpbiBzdWNjZXNzaW9uIHdpdGggc2hvcnQgb25BZnRlclNjcm9sbCB0aW1lb3V0XG4gICAgICAgICAgICBjYXNlICdhZGp1c3R1cGRhdGVmb3J2YXJpYWJpbGl0eWFmdGVyc2Nyb2xsJzoge1xuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgnYWZ0ZXJzY3JvbGwnKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cblxuICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSBmYWxzZVxuXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tWyB1c2VyIHJlcXVlc3RzIF0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHZhcmlvdXMgaG9zdCBzZXJ2aWNlIHJlcXVlc3RzOyBzeW5jcyBjcmFkbGUgY29udGVudCB3aXRoIGNhY2hlIGNoYW5nZXNcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcyc6IHsgLy8gdXNlciBpbnRlcnZlbnRpb25cblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsSG9sZExpc3QgfSA9IGNhY2hlSGFuZGxlclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsTWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRhbEhvbGRMaXN0ICYmIHBvcnRhbEhvbGRMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbUlEIG9mIHBvcnRhbEhvbGRMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjbGVhcmNhY2hlJzoge1xuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuY2xlYXJDcmFkbGUoKVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZVN0YXRlXSlcblxuICAgIC8vIGZvciBjcmFkbGUgcmVzaXplIGV2ZW50czsgdGhlc2UgYXJlIGFzeW5jaHJvbm91c1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlUmVzaXplU3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVzaXplcmVhZHknOlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdyZXNpemVjcmFkbGUnOlxuICAgICAgICAgICAgICAgIHNldENyYWRsZVJlc2l6ZVN0YXRlKCdyZXNpemVyZWFkeScpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlUmVzaXplU3RhdGVdKVxuXG4gICAgLy8gc3RhbmRhcmQgcmVuZGVyaW5nIHN0YXRlcyAoMyBzdGF0ZXMpXG4gICAgdXNlRWZmZWN0KCgpPT4geyBcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmdSZW5kZXIgYW5kIHJlcG9zaXRpb25pbmdDb250aW51YXRpb24gYXJlIHRvZ2dsZWQgdG8gZ2VuZXJhdGUgY29udGludW91cyBcbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmcgcmVuZGVyc1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6IC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6IC8vIHNldCBmcm9tIG9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogLy8gbm8tb3BcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlU3RhdGVdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFJFTkRFUiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXggPSBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICBjb25zdCBzY3JvbGxUcmFja2VyQXJncyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXVzZVNjcm9sbFRyYWNrZXIpIHJldHVybiBudWxsXG4gICAgICAgIGlmICghWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFja2VyYXJncyA9IHtcbiAgICAgICAgICAgIHRvcDp2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgMyxcbiAgICAgICAgICAgIGxlZnQ6dmlld3BvcnREaW1lbnNpb25zLmxlZnQgKyAzLFxuICAgICAgICAgICAgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrZXJhcmdzXG4gICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3JhZGxlU3RhdGUsIFxuICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zLCBcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgXVxuICAgIClcblxuICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSBjb250ZW50SGFuZGxlci5jb250ZW50XG5cbiAgICBjb25zdCB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpPT57XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dlbmVyYXRpbmcgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzJylcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleSA9ICdoZWFkJ1xuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd0cmlnZ2VyY2VsbC10cmlnZ2VybGluZS1oZWFkJ1xuICAgICAgICAgICAgICAgIGRhdGEtZGlyZWN0aW9uID0gJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZX1cbiAgICAgICAgICAgICAgICByZWYgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9kaXY+LFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleSA9ICd0YWlsJ1xuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd0cmlnZ2VyY2VsbC10cmlnZ2VybGluZS10YWlsJ1xuICAgICAgICAgICAgICAgIGRhdGEtZGlyZWN0aW9uID0gJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZVxuICAgIF0pXG5cbiAgICBjb25zdCBjb250ZXh0dmFsdWVSZWYgPSB1c2VSZWYoe1xuICAgICAgICBzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsXG4gICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2s6c2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLml0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZixcbiAgICB9KVxuXG5cbiAgICAvLyBkaXNwbGF5IHRoZSBjcmFkbGUgY29tcG9uZW50cywgdGhlIFNjcm9sbFRyYWNrZXIsIG9yIG51bGxcbiAgICByZXR1cm4gPENyYWRsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWUgPSB7Y29udGV4dHZhbHVlUmVmLmN1cnJlbnR9PlxuXG4gICAgICAgIHsoWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSk/XG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHtzY3JvbGxUcmFja2VyQXJncy50b3B9IFxuICAgICAgICAgICAgICAgIGxlZnQgPSB7c2Nyb2xsVHJhY2tlckFyZ3MubGVmdH0gXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0ge3Njcm9sbFRyYWNrZXJBcmdzLnNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleH0gXG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7c2Nyb2xsVHJhY2tlckFyZ3MubGlzdHNpemV9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0ge3Njcm9sbFRyYWNrZXJBcmdzLnN0eWxlc31cbiAgICAgICAgICAgIC8+Om51bGw6XG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdjcmFkbGUtYXhpcydcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVBeGlzU3R5bGV9IFxuICAgICAgICAgICAgICAgIHJlZiA9IHtheGlzQ3JhZGxlRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IHNob3dBeGlzPyAvLyBmb3IgZGVidWdcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdjcmFkbGUtZGl2aWRlcicgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVEaXZpZGVyU3R5bGV9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+OlxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdoZWFkJ1xuICAgICAgICAgICAgICAgICAgICByZWYgPSB7aGVhZENyYWRsZUVsZW1lbnRSZWZ9IFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVIZWFkU3R5bGV9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB7KGNyYWRsZVN0YXRlICE9ICdzZXR1cCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAndGFpbCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0ge3RhaWxDcmFkbGVFbGVtZW50UmVmfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlVGFpbFN0eWxlfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuXG4gICAgPC9DcmFkbGVDb250ZXh0LlByb3ZpZGVyPlxuXG59IC8vIENyYWRsZVxuXG5leHBvcnQgZGVmYXVsdCBDcmFkbGVcblxuLy8gdXRpbGl0eVxuXG5jb25zdCBnZXRDcmFkbGVIYW5kbGVycyA9IChjcmFkbGVQYXJhbWV0ZXJzKSA9PiB7XG5cbiAgICBjb25zdCBjcmVhdGVIYW5kbGVyID0gaGFuZGxlciA9PiBuZXcgaGFuZGxlcihjcmFkbGVQYXJhbWV0ZXJzKVxuXG4gICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICBjYWNoZUhhbmRsZXIuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoSW50ZXJydXB0SGFuZGxlciksXG4gICAgICAgIHNjcm9sbEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTY3JvbGxIYW5kbGVyKSxcbiAgICAgICAgc3RhdGVIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoU3RhdGVIYW5kbGVyKSxcbiAgICAgICAgY29udGVudEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihDb250ZW50SGFuZGxlciksXG4gICAgICAgIGxheW91dEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihMYXlvdXRIYW5kbGVyKSxcbiAgICAgICAgc2VydmljZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTZXJ2aWNlSGFuZGxlciksXG4gICAgICAgIHN0eWxlc0hhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdHlsZXNIYW5kbGVyKSxcblxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJyZWFjdF8xIiwiY3JlYXRlQ29udGV4dCIsIkNyYWRsZSIsImdyaWRTcGVjcyIsInJ1bndheVNpemUiLCJsaXN0c2l6ZSIsInN0YXJ0aW5nSW5kZXgiLCJnZXRJdGVtIiwicGxhY2Vob2xkZXIiLCJ1c2VyQ2FsbGJhY2tzIiwic3R5bGVzIiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJjYWNoZSIsImNhY2hlTWF4Iiwic2Nyb2xsZXJJRCIsImNhY2hlSGFuZGxlciIsInVzZVNjcm9sbFRyYWNrZXIiLCJzaG93QXhpcyIsIk1JTl9NQVhfREVMVEFfUkFUSU8iLCJTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCIsIklETEVDQUxMQkFDS19USU1FT1VUIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsInZhckhlaWdodE1pbiIsInZhcldpZHRoTWluIiwibGF5b3V0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RGltZW5zaW9ucyIsInZpZXdwb3J0aGVpZ2h0IiwiaGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsIndpZHRoIiwiY3JhZGxlU3RhdGUiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiY3JhZGxlUmVzaXplU3RhdGUiLCJzZXRDcmFkbGVSZXNpemVTdGF0ZSIsImNyYWRsZVJlc2l6ZVN0YXRlUmVmIiwiaXNNb3VudGVkUmVmIiwiaXNDYWNoZWRSZWYiLCJ3YXNDYWNoZWRSZWYiLCJwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYiLCJoYXNCZWVuUmVuZGVyZWRSZWYiLCJoZWFkQ3JhZGxlRWxlbWVudFJlZiIsInRhaWxDcmFkbGVFbGVtZW50UmVmIiwiYXhpc0NyYWRsZUVsZW1lbnRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbEVsZW1lbnRSZWYiLCJjcmFkbGVFbGVtZW50c1JlZiIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiYXhpc1JlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJjcm9zc2NvdW50Iiwidmlld3BvcnRjcm9zc2xlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjIiwiY2VsbGNyb3NzbGVuZ3RoIiwiY2VsbGNyb3NzbGVuZ3RoZm9yY2FsYyIsIk1hdGgiLCJtaW4iLCJmbG9vciIsInZpZXdwb3J0TGVuZ3RoIiwiYmFzZVJvd0xlbmd0aCIsInZpZXdwb3J0Um93Y291bnQiLCJjZWlsIiwidmlld3BvcnRWaXNpYmxlUm93Y291bnQiLCJsaXN0Um93Y291bnQiLCJjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwiZGlmZiIsIm1heCIsIml0ZW1jb3VudCIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uc0NhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiaGFuZGxlcnNSZWYiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlUGFyYW1ldGVyc1JlZiIsImdldENyYWRsZUhhbmRsZXJzIiwiaW50ZXJydXB0SGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiLCJjb250ZW50SGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsInN0eWxlc0hhbmRsZXIiLCJpc0luUG9ydGFsIiwiaXNDYWNoZUNoYW5nZSIsImlzQ2FjaGluZ1VuZGVyd2F5IiwiaXNSZXBhcmVudGluZ1JlZiIsIl9hIiwiaXNSZXNpemluZyIsIl9iIiwicGF1c2VJbnRlcnJ1cHRzIiwiZ2V0RnVuY3Rpb25zIiwic2Nyb2xsVG9JdGVtIiwicmVsb2FkIiwic2V0TGlzdHNpemUiLCJjbGVhckNhY2hlIiwiZ2V0Q2FjaGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsImdldENyYWRsZUluZGV4TWFwIiwicmVtYXBJbmRleGVzIiwibW92ZUluZGV4IiwiaW5zZXJ0SW5kZXgiLCJyZW1vdmVJbmRleCIsImZ1bmN0aW9ucyIsInZpZXdwb3J0ZGF0YSIsImVsZW1lbnRSZWYiLCJhZGRFdmVudExpc3RlbmVyIiwib25TY3JvbGwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JhZGxlSW50ZXJzZWN0IiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0IiwiY3JhZGxlUmVzaXplIiwiY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIiLCJjcmVhdGVPYnNlcnZlciIsImNvbm5lY3RFbGVtZW50cyIsInRyaWdnZXJvYnNlcnZlciIsImNyYWRsZXJlc2l6ZW9ic2VydmVyIiwiZGlzY29ubmVjdCIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJtYXhMaXN0c2l6ZSIsImNhbGxiYWNrcyIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwiY2hhbmdlTGlzdHNpemUiLCJtb2RlbEluZGV4TGlzdCIsImdldE1vZGVsSW5kZXhMaXN0IiwicGFyZUNhY2hlVG9NYXgiLCJjYWNoZVByb3BzIiwibW9kaWZpZWQiLCJyZW5kZXJQb3J0YWxMaXN0IiwibWF0Y2hDYWNoZVRvQ3JhZGxlIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImJsb2NrU2Nyb2xsUG9zIiwicHJldmlvdXNDZWxsUGl4ZWxMZW5ndGgiLCJwcmV2aW91c0F4aXNPZmZzZXQiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsInByZXZpb3VzcmF0aW8iLCJwaXZvdENlbGxQaXhlbExlbmd0aCIsInBpdm90QXhpc09mZnNldCIsInJvdW5kIiwiZ2V0Q3JhZGxlU3R5bGVzIiwidXNlcnN0eWxlcyIsImNyYWRsZUhlYWRTdHlsZSIsImNyYWRsZVRhaWxTdHlsZSIsImNyYWRsZUF4aXNTdHlsZSIsImNyYWRsZURpdmlkZXJTdHlsZSIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGUiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlIiwiZmluYWxDYWxsYmFjayIsInByZWxvYWQiLCJ2aWV3cG9ydEVsZW1lbnQiLCJyZXN0b3JlSW50ZXJydXB0cyIsInNpZ25hbHMiLCJwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJlcG9zaXRpb25pbmdSZXF1aXJlZCIsImNyYWRsZUNvbnRlbnQiLCJjb250ZW50IiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJzZXRDcmFkbGVDb250ZW50IiwiaGVhZERpc3BsYXlDb21wb25lbnRzIiwidGFpbERpc3BsYXlDb21wb25lbnRzIiwiY29uc29sZSIsImxvZyIsInNldFRpbWVvdXQiLCJhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJwb3J0YWxIb2xkTGlzdCIsInBvcnRhbE1hcCIsImxlbmd0aCIsIml0ZW1JRCIsImNsZWFyQ3JhZGxlIiwic2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Iiwic2Nyb2xsVHJhY2tlckFyZ3MiLCJpbmNsdWRlcyIsInRyYWNrZXJhcmdzIiwidG9wIiwibGVmdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmIiwia2V5Iiwic3R5bGUiLCJyZWYiLCJjb250ZXh0dmFsdWVSZWYiLCJQcm92aWRlciIsInZhbHVlIiwiU2Nyb2xsVHJhY2tlcl8xIiwib2Zmc2V0IiwiY3JlYXRlSGFuZGxlciIsImhhbmRsZXIiLCJpbnRlcnJ1cHRoYW5kbGVyXzEiLCJzY3JvbGxoYW5kbGVyXzEiLCJzdGF0ZWhhbmRsZXJfMSIsImNvbnRlbnRoYW5kbGVyXzEiLCJsYXlvdXRoYW5kbGVyXzEiLCJzZXJ2aWNlaGFuZGxlcl8xIiwic3R5bGVzaGFuZGxlcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Scrollblock.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\n\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n      listsize = _ref.listsize,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout; // -------------------------[ context and state ]-------------------------\n\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext); // -----------------------------------[ data heap ]-------------------------\n\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null); // just for init\n\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n      _ref3 = _slicedToArray(_ref2, 2),\n      divlinerstyle = _ref3[0],\n      saveDivlinerstyle = _ref3[1]; // to trigger render\n\n\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n      width = _ViewportContextPrope.width,\n      height = _ViewportContextPrope.height; // reconfigure\n\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\n\n\nexports["default"] = Scrollblock; // any of the parameters can affect the length\n\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n      viewportheight = _ref4.viewportheight,\n      viewportwidth = _ref4.viewportwidth,\n      listsize = _ref4.listsize,\n      cellHeight = _ref4.cellHeight,\n      cellWidth = _ref4.cellWidth,\n      gap = _ref4.gap,\n      padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength); // -------------------[ calculate scrollblock length ]-----------------\n\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap : // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n\n  return baselength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n\n  var height;\n  var width;\n\n  if (orientation == \'horizontal\') {\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n  } else if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBckI7RUFFQSxJQUFNSyxVQUFVLEdBQUlGLFlBQVksR0FBR0wsVUFBaEIsSUFDYkssWUFBWSxHQUFHLENBQWhCLEdBQ0dsQyxHQURILEdBQ1E7RUFDTCxDQUhXLElBSVpDLE9BQU8sR0FBRyxDQUpqQixDQWxDSyxDQXNDZTs7RUFFcEIsT0FBT21DLFVBQVA7QUFFSCxDQW5ERDs7QUFxREEsSUFBTWYsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQixDQUFDdEIsV0FBRCxFQUFjc0MsU0FBZCxFQUF5QkMsd0JBQXpCLEVBQXFEO0VBRWpGLElBQUlDLFdBQVcscUJBQU9GLFNBQVMsQ0FBQ3pCLE9BQWpCLENBQWYsQ0FGaUYsQ0FFeEM7O0VBQ3pDLElBQUlLLE1BQUo7RUFDQSxJQUFJRCxLQUFKOztFQUNBLElBQUlqQixXQUFXLElBQUksWUFBbkIsRUFBaUM7SUFDN0JrQixNQUFNLEdBQUcsTUFBVDtJQUNBRCxLQUFLLEdBQUdzQix3QkFBd0IsQ0FBQzFCLE9BQXpCLEdBQW1DLElBQTNDO0VBQ0gsQ0FIRCxNQUdPLElBQUliLFdBQVcsSUFBSSxVQUFuQixFQUErQjtJQUNsQ2tCLE1BQU0sR0FBR3FCLHdCQUF3QixDQUFDMUIsT0FBekIsR0FBbUMsSUFBNUM7SUFDQUksS0FBSyxHQUFHLE1BQVI7RUFDSDs7RUFDRHVCLFdBQVcsQ0FBQ3RCLE1BQVosR0FBcUJBLE1BQXJCO0VBQ0FzQixXQUFXLENBQUN2QixLQUFaLEdBQW9CQSxLQUFwQjtFQUVBLE9BQU91QixXQUFQO0FBQ0gsQ0FoQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1Njcm9sbGJsb2NrLnRzeD8zYjY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNjcm9sbGJsb2NrLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcblxuICAgIFRoZSBzY3JvbGxibG9jayBwcm92aWRlcyB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IG9mIHRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyLlxuICAgIEl0IGlzIHNpemVkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY2VsbCBzaXplIGFuZCByb3cgY291bnRzLCBhZGp1c3RlZCBmb3IgdmFyaWFibGUgY3JhZGxlIGNvbnRlbnQuXG4gICAgSXRzIG9ubHkgc3RhdGUgY2hhbmdlIGlzIGNoYW5nZSBvZiBzdHlsZXMuXG5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW99IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL1ZpZXdwb3J0J1xuXG5jb25zdCBTY3JvbGxibG9jayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgbGlzdHNpemUsXG4gICAgZ3JpZFNwZWNzLCBcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbn0pID0+IHtcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY29udGV4dCBhbmQgc3RhdGUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBkYXRhIGhlYXAgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8ganVzdCBmb3IgaW5pdFxuICAgIGNvbnN0IGxpbmVyU3R5bGUgPSB1c2VNZW1vKCgpID0+e1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdHlsZXMuc2Nyb2xsYmxvY2ssXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICB9XG5cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYobGluZXJTdHlsZSlcblxuICAgIGNvbnN0IFtkaXZsaW5lcnN0eWxlLHNhdmVEaXZsaW5lcnN0eWxlXSA9IHVzZVN0YXRlKGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCkgLy8gdG8gdHJpZ2dlciByZW5kZXJcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy52aWV3cG9ydERpbWVuc2lvbnNcbiAgICBcbiAgICAvLyByZWNvbmZpZ3VyZVxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgdXBkYXRlQmFzZUJsb2NrTGVuZ3RoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0OmhlaWdodCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoOndpZHRoLFxuICAgICAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IFxuICAgICAgICAgICAgdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMoXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgZGl2bGluZXJzdHlsZVJlZixcbiAgICAgICAgICAgICAgICBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWZcbiAgICAgICAgICAgIClcbiAgICAgICAgc2F2ZURpdmxpbmVyc3R5bGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgXSlcblxuICAgIGNvbnN0IHVwZGF0ZUJhc2VCbG9ja0xlbmd0aCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAobGF5b3V0c3BlY3MpID0+IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYmFzZXNjcm9sbGJsb2NrbGVuZ3RoID0gY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aChsYXlvdXRzcGVjcylcblxuICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmLmN1cnJlbnQgPSBiYXNlc2Nyb2xsYmxvY2tsZW5ndGhcblxuICAgICAgICB9LFtdXG4gICAgKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3Njcm9sbGJsb2NrJyBzdHlsZT17ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fT57Y2hpbGRyZW59PC9kaXY+XG5cbn0gLy8gU2Nyb2xsYmxvY2tcblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsYmxvY2tcblxuLy8gYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGNhbiBhZmZlY3QgdGhlIGxlbmd0aFxuY29uc3QgY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aCA9ICh7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICB2aWV3cG9ydGhlaWdodCxcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIH0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNyb3NzY291bnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vY3Jvc3Njb3VudCBpcyBhbHNvIGNhbGN1bGF0ZWQgYnkgQ3JhZGxlXG5cbiAgICBsZXQgY3Jvc3NsZW5ndGhcbiAgICBsZXQgY2VsbExlbmd0aFxuICAgIGxldCB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnR3aWR0aCBcblxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydGhlaWdodFxuXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0bWVudHMgdG8gdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggLT0gKHBhZGRpbmcgKiAyKVxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggKz0gZ2FwIC8vIHRvIG1hdGNoIGNyb3NzTGVuZ3RoXG5cbiAgICBpZiAodmlld3BvcnRjcm9zc2xlbmd0aCA8IGNyb3NzbGVuZ3RoKSB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gY3Jvc3NsZW5ndGggLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmVcblxuICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGgvY3Jvc3NsZW5ndGgpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgc2Nyb2xsYmxvY2sgbGVuZ3RoIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgbGlzdHJvd2NvdW50ID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3Ryb3djb3VudCAqIGNlbGxMZW5ndGgpIC0gXG4gICAgICAgICgobGlzdHJvd2NvdW50ID4gMCk/XG4gICAgICAgICAgICBnYXA6IC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgMCkgXG4gICAgICAgICsgKHBhZGRpbmcgKiAyKSAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG5cbiAgICByZXR1cm4gYmFzZWxlbmd0aFxuXG59XG5cbmNvbnN0IHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzID0gKG9yaWVudGF0aW9uLCBzdHlsZXNSZWYsIGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZikgPT4ge1xuXG4gICAgbGV0IGxvY2Fsc3R5bGVzID0gey4uLnN0eWxlc1JlZi5jdXJyZW50fSAvLyBuZXcgb2JqZWN0XG4gICAgbGV0IGhlaWdodCBcbiAgICBsZXQgd2lkdGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBoZWlnaHQgPSBiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG59XG4iXSwibmFtZXMiOlsiU2Nyb2xsYmxvY2siLCJjaGlsZHJlbiIsImxpc3RzaXplIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRfMSIsImJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZiIsImxpbmVyU3R5bGUiLCJzY3JvbGxibG9jayIsInBvc2l0aW9uIiwiZGl2bGluZXJzdHlsZVJlZiIsImN1cnJlbnQiLCJkaXZsaW5lcnN0eWxlIiwic2F2ZURpdmxpbmVyc3R5bGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInVwZGF0ZUJhc2VCbG9ja0xlbmd0aCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzIiwibGF5b3V0c3BlY3MiLCJiYXNlc2Nyb2xsYmxvY2tsZW5ndGgiLCJjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoIiwicmVhY3RfMSIsInN0eWxlIiwiZXhwb3J0cyIsImNyb3NzbGVuZ3RoIiwiY2VsbExlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGgiLCJjcm9zc2NvdW50IiwiTWF0aCIsImZsb29yIiwibGlzdHJvd2NvdW50IiwiY2VpbCIsImJhc2VsZW5ndGgiLCJzdHlsZXNSZWYiLCJiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYiLCJsb2NhbHN0eWxlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Viewport.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible screen portal of the list being shown.\n    If it is resized, it notifies the Cradle to reconfigure.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nexports.ViewportContext = react_1["default"].createContext(null); // for children\n\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js");\n\nvar ResizeObserver = window[\'ResizeObserver\'] || resize_observer_1.ResizeObserver;\n\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID,\n      scrollerProperties = _ref.scrollerProperties,\n      VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout;\n\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      viewportState = _ref3[0],\n      setViewportState = _ref3[1]; // setup, resizing, resized, ready\n\n\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true); // monitor for unmounted\n\n  var viewportElementRef = (0, react_1.useRef)(null); // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  // initialize\n\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isReparentingRef: scrollerProperties === null || scrollerProperties === void 0 ? void 0 : scrollerProperties.isReparentingRef,\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  }); // mark as unmounted\n\n  (0, react_1.useEffect)(function () {\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []); // --------------------[ viewport resizer interrupt ]-----------------------\n\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null); // set up resizeObserver\n\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current); // unmount\n\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []); // used by resizeObserver; generates interrupt\n\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    // console.log(\'Viewport: resizeCallback\')\n    // if ((!isMountedRef.current) || (!viewportElementRef.current)) return\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target; // no need to trigger interrupt on first resize notification\n\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    } // generate interrupt response, if initiating resize\n\n\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true; // new object creation triggers a realtime interrupt message to cradle through context\n\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    } // finalize resizing after timeout\n\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []); // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n\n  var divlinerstyleRef = (0, react_1.useRef)(null); // initialize with inherited styles\n\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'auto\'\n    });\n  }, [styles.viewport]); // update ViewportContextPropertiesRef; add viewport dimensions\n\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n        top = _viewportElementRef$c.top,\n        right = _viewportElementRef$c.right,\n        bottom = _viewportElementRef$c.bottom,\n        left = _viewportElementRef$c.left;\n\n    var width = right - left;\n    var height = bottom - top; // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    }; // trigger context change with new object\n\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]); // --------------------[ state processing ]---------------------------\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]); // ----------------------[ render ]--------------------------------\n\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\n\n\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXVKRDs7RUFFQSw2QkFBZ0IsWUFBSTtJQUNoQixRQUFRQSxhQUFSO01BRUksS0FBSyxTQUFMO01BQ0EsS0FBSyxPQUFMO1FBQWM7VUFDVkMsZ0JBQWdCLENBQUMsT0FBRCxDQUFoQjtVQUNBO1FBQ0g7SUFOTDtFQVNILENBVkQsRUFVRSxDQUFDRCxhQUFELENBVkYsRUF6SkMsQ0FxS0Q7O0VBRUEsT0FBT2xCLGlDQUFDRCx3QkFBZ0J5RCxRQUFqQixFQUF5QjtJQUFDQyxLQUFLLEVBQUtqQyw0QkFBNEIsQ0FBQ0g7RUFBeEMsQ0FBekIsRUFDSHJCO0lBQUEsYUFDZ0IsVUFEaEI7SUFDMEIsbUJBQ0hTLFVBRnZCO0lBR0lpRCxLQUFLLEVBQUloQixnQkFBZ0IsQ0FBQ3JCLE9BSDlCO0lBSUlzQyxHQUFHLEVBQUlwQztFQUpYLEdBTU9MLGFBQWEsSUFBSSxPQUFsQixJQUE4QlosUUFOcEMsQ0FERyxDQUFQO0FBV0gsQ0EzTEQsQyxDQTJMRTs7O0FBRUZQLGtCQUFBQSxHQUFlTSxRQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9WaWV3cG9ydC50c3g/YzgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3cG9ydC50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2Ygdmlld3BvcnQgaXMgdG8gcHJvdmlkZSBkYXRhIHRvIGl0cyBjaGlsZHJlbiAoc2Nyb2xsYmxvY2sgYW5kIGNyYWRsZSksXG4gICAgYW5kIGFjdCBhcyB0aGUgdmlzaWJsZSBzY3JlZW4gcG9ydGFsIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuICAgIElmIGl0IGlzIHJlc2l6ZWQsIGl0IG5vdGlmaWVzIHRoZSBDcmFkbGUgdG8gcmVjb25maWd1cmUuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHtcblxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VSZWYsIFxuICAgIHVzZUVmZmVjdCwgXG4gICAgdXNlTGF5b3V0RWZmZWN0LCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDYWxsYmFjaywgXG4gICAgdXNlQ29udGV4dFxuXG59IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKSAvLyBmb3IgY2hpbGRyZW5cblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgYXMgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGwgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcidcblxuY29uc3QgUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3dbJ1Jlc2l6ZU9ic2VydmVyJ10gfHwgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGxcblxuY29uc3QgVmlld3BvcnQgPSAoe1xuXG4gICAgY2hpbGRyZW4sIFxuICAgIGdyaWRTcGVjcyxcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbiAgICBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG4gICAgXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICBjb25zdCBbdmlld3BvcnRTdGF0ZSxzZXRWaWV3cG9ydFN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCByZXNpemluZywgcmVzaXplZCwgcmVhZHlcblxuICAgIGNvbnN0IHZpZXdwb3J0U3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gZm9yIHVzZUNhbGxiYWNrIC0+IHJlc2l6ZUNhbGxiYWNrIHNjb3BlXG4gICAgdmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID0gdmlld3BvcnRTdGF0ZVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpIC8vIG1vbml0b3IgZm9yIHVubW91bnRlZFxuXG4gICAgY29uc3Qgdmlld3BvcnRFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIGlzIHBhc3NlZCBhcyBhIHJlc2l6aW5nIGludGVycnVwdCAodGhyb3VnaCBjb250ZXh0KSB0byBjaGlsZHJlblxuICAgIC8vIGluaXRpYWxpemVcbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBpc1JlcGFyZW50aW5nUmVmOnNjcm9sbGVyUHJvcGVydGllcz8uaXNSZXBhcmVudGluZ1JlZiwgXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOmZhbHNlLCBcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczpudWxsLFxuICAgICAgICAgICAgZWxlbWVudFJlZjpudWxsXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyBtYXJrIGFzIHVubW91bnRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PntcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHZpZXdwb3J0IHJlc2l6ZXIgaW50ZXJydXB0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVzaXplVGltZXJpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGlzUmVzaXppbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7ICAgIFxuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnQ6IHJlc2l6ZUNhbGxiYWNrJylcbiAgICAgICAgLy8gaWYgKCghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHx8ICghdmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpKSByZXR1cm5cblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVudHJpZXNbMF0udGFyZ2V0XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byB0cmlnZ2VyIGludGVycnVwdCBvbiBmaXJzdCByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQgPSAndHJ1ZSdcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJydXB0IHJlc3BvbnNlLCBpZiBpbml0aWF0aW5nIHJlc2l6ZVxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG5cbiAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgY3JlYXRpb24gdHJpZ2dlcnMgYSByZWFsdGltZSBpbnRlcnJ1cHQgbWVzc2FnZSB0byBjcmFkbGUgdGhyb3VnaCBjb250ZXh0XG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxpemUgcmVzaXppbmcgYWZ0ZXIgdGltZW91dFxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNvbmZpZyB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzdHlsZXNcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplIHdpdGggaW5oZXJpdGVkIHN0eWxlc1xuICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdHlsZXMudmlld3BvcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgaW5zZXQ6MCxcbiAgICAgICAgICAgIG92ZXJmbG93OidhdXRvJyxcbiAgICAgICAgfVxuXG4gICAgfSxbc3R5bGVzLnZpZXdwb3J0XSlcblxuICAgIC8vIHVwZGF0ZSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmOyBhZGQgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGlmICh2aWV3cG9ydFN0YXRlID09ICdzZXR1cCcpIHJldHVybiBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7dG9wLCByaWdodCwgYm90dG9tLCBsZWZ0fSA9IHZpZXdwb3J0RWxlbWVudFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGNvbnN0IHdpZHRoID0gKHJpZ2h0IC0gbGVmdClcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGJvdHRvbSAtIHRvcClcblxuICAgICAgICAvLyB0aGlzIGlzIGEgZGltZW5zaW9uIHVwZGF0ZSBwcm9jZWR1cmUgZm9yIHJlc2l6ZS4gXG4gICAgICAgIC8vIFNlZSBhbHNvIGludGVycnVwdGhhbmRsZXIudHN4IGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgZm9yIGNyYWRsZSBpbnRlcnNlY3Rpb24gdXBkYXRlXG4gICAgICAgIGNvbnN0IGxvY2FsVmlld3BvcnREYXRhID0ge1xuICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zOnt0b3AscmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0sXG4gICAgICAgICAgICBlbGVtZW50UmVmOnZpZXdwb3J0RWxlbWVudFJlZixcbiAgICAgICAgICAgIGlzUmVzaXppbmc6aXNSZXNpemluZ1JlZi5jdXJyZW50LFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjb250ZXh0IGNoYW5nZSB3aXRoIG5ldyBvYmplY3RcbiAgICAgICAgY29uc3Qgdmlld3BvcnRkYXRhb2JqZWN0ID0gey4uLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCwgLi4ubG9jYWxWaWV3cG9ydERhdGF9XG5cbiAgICAgICAgcmV0dXJuICB2aWV3cG9ydGRhdGFvYmplY3RcblxuICAgIH0sW29yaWVudGF0aW9uLCBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQsIHZpZXdwb3J0U3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIHByb2Nlc3NpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFxuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBzd2l0Y2ggKHZpZXdwb3J0U3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVzaXplZCc6XG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcbiAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKCdyZWFkeScpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSxbdmlld3BvcnRTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZW5kZXIgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXR1cm4gPFZpZXdwb3J0Q29udGV4dC5Qcm92aWRlciB2YWx1ZSA9IHsgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50IH0+XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICBkYXRhLXR5cGUgPSAndmlld3BvcnQnXG4gICAgICAgICAgICBkYXRhLXNjcm9sbGVyaWQgPSB7c2Nyb2xsZXJJRH1cbiAgICAgICAgICAgIHN0eWxlID0ge2RpdmxpbmVyc3R5bGVSZWYuY3VycmVudH1cbiAgICAgICAgICAgIHJlZiA9IHt2aWV3cG9ydEVsZW1lbnRSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsgKHZpZXdwb3J0U3RhdGUgIT0gJ3NldHVwJykgJiYgY2hpbGRyZW4gfVxuICAgICAgICA8L2Rpdj5cbiAgICA8L1ZpZXdwb3J0Q29udGV4dC5Qcm92aWRlcj5cbiAgICBcbn0gLy8gVmlld3BvcnRcblxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnRcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwicmVhY3RfMSIsImNyZWF0ZUNvbnRleHQiLCJSZXNpemVPYnNlcnZlciIsIndpbmRvdyIsInJlc2l6ZV9vYnNlcnZlcl8xIiwiVmlld3BvcnQiLCJjaGlsZHJlbiIsImdyaWRTcGVjcyIsInN0eWxlcyIsInNjcm9sbGVySUQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJ2aWV3cG9ydFN0YXRlIiwic2V0Vmlld3BvcnRTdGF0ZSIsInZpZXdwb3J0U3RhdGVSZWYiLCJjdXJyZW50IiwiaXNNb3VudGVkUmVmIiwidmlld3BvcnRFbGVtZW50UmVmIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImlzUmVwYXJlbnRpbmdSZWYiLCJpc1Jlc2l6aW5nIiwidmlld3BvcnREaW1lbnNpb25zIiwiZWxlbWVudFJlZiIsInJlc2l6ZVRpbWVyaWRSZWYiLCJpc1Jlc2l6aW5nUmVmIiwicmVzaXplT2JzZXJ2ZXJSZWYiLCJyZXNpemVDYWxsYmFjayIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsInRhcmdldCIsImRhdGFzZXQiLCJpbml0aWFsaXplZCIsIk9iamVjdCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJkaXZsaW5lcnN0eWxlUmVmIiwidmlld3BvcnQiLCJwb3NpdGlvbiIsImluc2V0Iiwib3ZlcmZsb3ciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsImxvY2FsVmlld3BvcnREYXRhIiwidmlld3BvcnRkYXRhb2JqZWN0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInN0eWxlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Placeholder.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n      listsize = _ref.listsize,\n      message = _ref.message,\n      error = _ref.error,\n      userFrameStyles = _ref.userFrameStyles,\n      userContentStyles = _ref.userContentStyles;\n  var frameStylesRef = (0, react_1.useRef)(Object.assign(Object.assign({\n    border: \'2px solid black\',\n    backgroundColor: \'cyan\'\n  }, userFrameStyles), {\n    position: \'relative\',\n    boxSizing: \'border-box\',\n    height: \'100%\',\n    width: \'100%\'\n  }));\n  var contentStylesRef = (0, react_1.useRef)(Object.assign({\n    position: \'absolute\',\n    top: 0,\n    left: 0,\n    padding: \'3px\',\n    opacity: .5,\n    borderRadius: \'8px\',\n    backgroundColor: \'white\',\n    margin: \'3px\',\n    fontSize: \'smaller\'\n  }, userContentStyles));\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    style: frameStylesRef.current\n  }, !error ? react_1["default"].createElement("div", {\n    style: contentStylesRef.current\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    style: contentStylesRef.current\n  }, "item is not available (", error.message, ")"));\n};\n\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTs7QUFFQSxJQUFNQSxXQUFXLEdBQUcsU0FBZEEsV0FBYyxPQUEwRTtFQUFBLElBQXhFQyxLQUF3RSxRQUF4RUEsS0FBd0U7RUFBQSxJQUFqRUMsUUFBaUUsUUFBakVBLFFBQWlFO0VBQUEsSUFBdkRDLE9BQXVELFFBQXZEQSxPQUF1RDtFQUFBLElBQTlDQyxLQUE4QyxRQUE5Q0EsS0FBOEM7RUFBQSxJQUF2Q0MsZUFBdUMsUUFBdkNBLGVBQXVDO0VBQUEsSUFBdEJDLGlCQUFzQixRQUF0QkEsaUJBQXNCO0VBRTFGLElBQU1DLGNBQWMsR0FBRyxvQkFBTUM7SUFDekJDLE1BQU0sRUFBQyxpQkFEa0I7SUFFekJDLGVBQWUsRUFBQztFQUZTLEdBR3RCTCxlQUhzQixHQUdQO0lBQ2xCTSxRQUFRLEVBQUMsVUFEUztJQUVsQkMsU0FBUyxFQUFDLFlBRlE7SUFHbEJDLE1BQU0sRUFBQyxNQUhXO0lBSWxCQyxLQUFLLEVBQUM7RUFKWSxDQUhPLENBQU4sQ0FBdkI7RUFTQSxJQUFNQyxnQkFBZ0IsR0FBRyxvQkFBTVA7SUFDM0JHLFFBQVEsRUFBQyxVQURrQjtJQUUzQkssR0FBRyxFQUFDLENBRnVCO0lBRzNCQyxJQUFJLEVBQUMsQ0FIc0I7SUFJM0JDLE9BQU8sRUFBQyxLQUptQjtJQUszQkMsT0FBTyxFQUFDLEVBTG1CO0lBTTNCQyxZQUFZLEVBQUMsS0FOYztJQU8zQlYsZUFBZSxFQUFDLE9BUFc7SUFRM0JXLE1BQU0sRUFBQyxLQVJvQjtJQVMzQkMsUUFBUSxFQUFDO0VBVGtCLEdBVXhCaEIsaUJBVndCLENBQU4sQ0FBekI7RUFhQUgsT0FBTyxHQUFHQSxPQUFPLFNBQVAsV0FBTyxXQUFQLGFBQVcsY0FBckI7RUFFQSxPQUFPb0I7SUFBS0MsS0FBSyxFQUFJakIsY0FBYyxDQUFDa0I7RUFBN0IsR0FDRCxDQUFDckIsS0FBRCxHQUNFbUI7SUFBS0MsS0FBSyxFQUFLVCxnQkFBZ0IsQ0FBQ1U7RUFBaEMsR0FBMkN4QixLQUFLLEdBQUcsQ0FBbkQsT0FBdURDLFFBQXZELE9BQWtFQyxPQUFsRSxDQURGLEdBRUVvQjtJQUFLQyxLQUFLLEVBQUtULGdCQUFnQixDQUFDVTtFQUFoQyw4QkFBa0VyQixLQUFLLENBQUNELE9BQXhFLE1BSEQsQ0FBUDtBQU9ILENBakNEOztBQW1DQXVCLGtCQUFBQSxHQUFlMUIsV0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB0aGUgZGVmYXVsdCBQbGFjZUhvbGRlciBpcyB0byBob2xkIHRoZSBjb250ZW50IGRpc3BsYXkgdW50aWwgdGhlIGhvc3QgY29udGVudFxuICAgIGlzIHJlY2VpdmVkLiBUaGUgcGxhY2Vob2xkZXIgcHJlc2VudHMgYSB3YWl0aW5nIG1lc3NhZ2UsIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGxvYWRcbiAgICBvZiB0aGUgaG9zdCBjb250ZW50IGZhaWxlZC5cblxuICAgIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNhbiBiZSByZXBsYWNlZCBieSBhIHBsYWNlaG9sZGVyIHByb3ZpZGVkIGJ5IHRoZSBob3N0LlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFBsYWNlaG9sZGVyID0gKHtpbmRleCwgbGlzdHNpemUsIG1lc3NhZ2UsIGVycm9yLCB1c2VyRnJhbWVTdHlsZXMsIHVzZXJDb250ZW50U3R5bGVzfSkgPT4ge1xuXG4gICAgY29uc3QgZnJhbWVTdHlsZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBib3JkZXI6JzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgIC4uLnVzZXJGcmFtZVN0eWxlcyxcbiAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgIH0pXG4gICAgY29uc3QgY29udGVudFN0eWxlc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgIHRvcDowLFxuICAgICAgICBsZWZ0OjAsXG4gICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgIG9wYWNpdHk6LjUsXG4gICAgICAgIGJvcmRlclJhZGl1czonOHB4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsIFxuICAgICAgICBtYXJnaW46JzNweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgLi4udXNlckNvbnRlbnRTdHlsZXMsXG4gICAgfSlcblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlID8/ICcobG9hZGluZy4uLiknXG5cbiAgICByZXR1cm4gPGRpdiBzdHlsZSA9IHtmcmFtZVN0eWxlc1JlZi5jdXJyZW50fT5cbiAgICAgICAgeyAhZXJyb3I/XG4gICAgICAgICAgICA8ZGl2IHN0eWxlID0geyBjb250ZW50U3R5bGVzUmVmLmN1cnJlbnQgfT57aW5kZXggKyAxfS97bGlzdHNpemV9IHttZXNzYWdlfTwvZGl2PjpcbiAgICAgICAgICAgIDxkaXYgc3R5bGUgPSB7IGNvbnRlbnRTdHlsZXNSZWYuY3VycmVudCB9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSAoe2Vycm9yLm1lc3NhZ2V9KTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJuYW1lcyI6WyJQbGFjZWhvbGRlciIsImluZGV4IiwibGlzdHNpemUiLCJtZXNzYWdlIiwiZXJyb3IiLCJ1c2VyRnJhbWVTdHlsZXMiLCJ1c2VyQ29udGVudFN0eWxlcyIsImZyYW1lU3R5bGVzUmVmIiwiT2JqZWN0IiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwicG9zaXRpb24iLCJib3hTaXppbmciLCJoZWlnaHQiLCJ3aWR0aCIsImNvbnRlbnRTdHlsZXNSZWYiLCJ0b3AiLCJsZWZ0IiwicGFkZGluZyIsIm9wYWNpdHkiLCJib3JkZXJSYWRpdXMiLCJtYXJnaW4iLCJmb250U2l6ZSIsInJlYWN0XzEiLCJzdHlsZSIsImN1cnJlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // scrolltracker.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      offset = _ref.offset,\n      listsize = _ref.listsize,\n      styles = _ref.styles;\n  var trackdata = "".concat(offset + 1, "/").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0FBT0E7O0FBRUEsSUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixPQUE0QztFQUFBLElBQXpDQyxHQUF5QyxRQUF6Q0EsR0FBeUM7RUFBQSxJQUFwQ0MsSUFBb0MsUUFBcENBLElBQW9DO0VBQUEsSUFBOUJDLE1BQThCLFFBQTlCQSxNQUE4QjtFQUFBLElBQXRCQyxRQUFzQixRQUF0QkEsUUFBc0I7RUFBQSxJQUFaQyxNQUFZLFFBQVpBLE1BQVk7RUFFOUQsSUFBSUMsU0FBUyxhQUFNSCxNQUFNLEdBQUcsQ0FBZixjQUFvQkMsUUFBcEIsQ0FBYjtFQUVBLElBQUlHLFFBQVEsR0FBRyxvQkFBTUM7SUFDakJQLEdBQUcsRUFBRUEsR0FBRyxHQUFHLElBRE07SUFFakJDLElBQUksRUFBRUEsSUFBSSxHQUFHLElBRkk7SUFHakJPLFFBQVEsRUFBQyxPQUhRO0lBSWpCQyxNQUFNLEVBQUMsQ0FKVTtJQUtqQkMsZUFBZSxFQUFDLE9BTEM7SUFNakJDLE1BQU0sRUFBRSxnQkFOUztJQU9qQkMsWUFBWSxFQUFDLE1BUEk7SUFRakJDLFFBQVEsRUFBQyxTQVJRO0lBU2pCQyxPQUFPLEVBQUM7RUFUUyxHQVVkVixNQUFNLENBQUNXLGFBVk8sQ0FBTixDQUFmO0VBYUEsT0FBT0M7SUFBQSxhQUFpQixlQUFqQjtJQUFpQ0MsS0FBSyxFQUFJWCxRQUFRLENBQUNZO0VBQW5ELEdBQThEYixTQUE5RCxDQUFQO0FBQ0gsQ0FsQkQ7O0FBb0JBYyxrQkFBQUEsR0FBZXBCLGFBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9TY3JvbGxUcmFja2VyLnRzeD8wYjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIFNjcm9sbFRyYWNrZXIgaXMgdG8gcHJvdmlkZSBmZWVkYmFjayB0byB0aGUgdXNlciBvZiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlXG4gICAgdmlydHVhbCBsaXN0IGR1cmluZyByZXBvc2l0aW9uZy5cblxuICAgIFNjcm9sbFRyYWNrZXIgY2FuIGJlIHN1cHByZXNzZWQgYnkgdGhlIGhvc3QgKGluIGZhdm91ciBvZiB0aGUgaG9zdCdzIG93biBsb2NhdGlvbiBmZWVkYmFjaylcbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFNjcm9sbFRyYWNrZXIgPSAoeyB0b3AsIGxlZnQsIG9mZnNldCwgbGlzdHNpemUsIHN0eWxlcyB9KSA9PiB7XG5cbiAgICBsZXQgdHJhY2tkYXRhID0gYCR7b2Zmc2V0ICsgMX0vJHtsaXN0c2l6ZX1gXG5cbiAgICBsZXQgc3R5bGVSZWYgPSB1c2VSZWYoe1xuICAgICAgICB0b3A6IHRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjonZml4ZWQnLFxuICAgICAgICB6SW5kZXg6MyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBncmF5JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOicxMHB4JyxcbiAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICBwYWRkaW5nOiczcHgnLFxuICAgICAgICAuLi5zdHlsZXMuc2Nyb2xsdHJhY2tlclxuICAgIH0pXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLW5hbWUgPSAnc2Nyb2xsdHJhY2tlcicgc3R5bGUgPSB7c3R5bGVSZWYuY3VycmVudH0gPnt0cmFja2RhdGF9PC9kaXY+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFRyYWNrZXIiXSwibmFtZXMiOlsiU2Nyb2xsVHJhY2tlciIsInRvcCIsImxlZnQiLCJvZmZzZXQiLCJsaXN0c2l6ZSIsInN0eWxlcyIsInRyYWNrZGF0YSIsInN0eWxlUmVmIiwiT2JqZWN0IiwicG9zaXRpb24iLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJmb250U2l6ZSIsInBhZGRpbmciLCJzY3JvbGx0cmFja2VyIiwicmVhY3RfMSIsInN0eWxlIiwiY3VycmVudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/cachehandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // cachehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PortalList = exports.CacheHandler = void 0;\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user getFunctions callback for details. Note that large caches of complex components\n    can impair performance. This can be optimized with the cacheMax property.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden portal cache\n    for each InfiniteGridScroller root, from whence the components are pulled into the relevant CellFrames\n    for display. The user components are stored in React portals, with each portal instantiated in\n    a container div (\'portalwrapper\'). These container divs are included in a standard React component\n    list in the real DOM. The contained portals themselves are not part of the real DOM, but are part of\n    React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle, and the ability to maintain state for complex components\n    which move beyond the scope of the content of the Cradle. But there is an important side effect.\n    Instantiated components which are removed from the real DOM (into the portal of the virtual DOM)\n    have their scroll positions, width, and height set to zero. Therefore if components rely on these\n    values for configuration, they must have a way of storing values in state (notably the\n    Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing isReparentingRef and scrollerPassthroughPropertiesRef\n        - isReparentingRef.current provides an up-to-date boolean indicating whether the component is\n            currently being \'reparented\' into the real DOM. Set the value back to false once you\'ve\n            detected it. After reparenting (after the width and height are back to normal) is when\n            you should restore scrollPos (scrollTop or scrollLeft) to what it was.\n        - if your component does not scroll, there should be no issues.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\n\nvar globalItemID = 0; // global scroller data, organized by session scrollerID\n// the cache itself is maintained in the root infinitegridscroller component\n\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, setListsize, listsizeRef) {\n    var _this = this;\n\n    _classCallCheck(this, CacheHandler);\n\n    this.cacheProps = {\n      setListState: null,\n      modified: false,\n      metadataMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      portalMap: new Map(),\n      indexToItemIDMap: new Map(),\n      portalList: null,\n      scrollerID: null\n    }; //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n\n    this.changeListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      _this.setListsize(newlistsize); // match cache to newlistsize\n\n\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n\n    this.clearCache = function () {\n      // keep the setListState callback\n      _this.cacheProps.portalMap.clear();\n\n      _this.cacheProps.metadataMap.clear();\n\n      _this.cacheProps.indexToItemIDMap.clear();\n\n      _this.cacheProps.requestedSet.clear();\n\n      _this.cacheProps.portalList = null;\n      _this.cacheProps.modified = true;\n\n      _this.renderPortalList(); // trigger display update\n\n    }; // set state of the PortalList component of the scroller to trigger render\n\n\n    this.renderPortalList = function () {\n      if (_this.cacheProps.modified) {\n        _this.cacheProps.portalList = Array.from(_this.cacheProps.portalMap.values());\n        _this.cacheProps.modified = false;\n      }\n\n      _this.cacheProps.setListState(); // trigger display update\n\n    }; // ----------------------[ cache size limit enforceent ]------------------\n\n\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      var modelLength = cradleIndexList.length; // determine need for paring\n\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexList = _this.cacheProps.indexToItemIDMap;\n      var requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexList.size + requestedSet.size <= max) return false; // sort the map keys\n\n      var mapkeyslist = Array.from(portalIndexList.keys());\n      var requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      }); // get number to pare\n\n      var mapLength = mapkeys.length;\n      var parecount = mapLength - max; // distribute paring proportionally at front and back\n\n      var headindex = cradleIndexList[0];\n      var tailindex = cradleIndexList[modelLength - 1];\n      var headpos = mapkeys.indexOf(headindex);\n      var tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos;\n      var tailroom = mapLength - (tailpos + 1);\n      var pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount);\n      var tailparecount = parecount - headparecount; // collect indexes to pare\n\n      var headlist = mapkeys.slice(0, headparecount);\n      var taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n\n      _this.deletePortal(delList, deleteListCallback);\n\n      return true;\n    };\n\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var portalMap = _this.cacheProps.portalMap;\n      var requestedSet = _this.cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n\n      if (portalMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    this.cacheProps.scrollerID = scrollerID;\n    this.setListsize = setListsize; // passed from infinitegridscroller setListsize(listsize)\n\n    this.listsizeRef = listsizeRef;\n  } // --------------------------------[ preload ]--------------------------------\n\n\n  _createClass(CacheHandler, [{\n    key: "preload",\n    value: function preload(cradleParameters, finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n\n      var scrollerPassthroughPropertiesRef = cradleParameters.scrollerPassthroughPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n          stateHandler = _cradleParameters$han.stateHandler,\n          serviceHandler = _cradleParameters$han.serviceHandler;\n      var cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n          cacheMax = cradleInheritedProperties.cacheMax;\n      var listsize = cradleInternalProperties.listsize;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      }; // serviceHandler.callbacks.preloadIndexCallback\n\n\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n            preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n            itemExceptionsCallback = _serviceHandler$callb.itemExceptionsCallback;\n\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n\n          if (!indexToItemIDMap.has(index)) {\n            var promise = this.preloadItem(index, getItem, scrollerPassthroughPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n\n          if (breakloop.current) break;\n        }\n      }\n\n      Promise.allSettled(promises).then(function () {\n        _this2.cacheProps.modified = true;\n\n        _this2.renderPortalList();\n\n        finalCallback();\n      });\n    } // =========================[ SNAPSHOTS ]=========================\n\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map();\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n\n      var _iterator = _createForOfIteratorHelper(cradleIndexList),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n\n      var _iterator2 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              value = _step2$value[1];\n\n          var index = value.index,\n              component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return cachelist;\n    } // ==========================[ SERVICE SUPPORT ]=========================\n    // move is coerced by servicehandler to be within current list bounds\n\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(toindex, fromindex, fromhighindex) {\n      var _this$cacheProps = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps.indexToItemIDMap,\n          metadataMap = _this$cacheProps.metadataMap; // ----------- define parameters ---------------\n\n      var rangeabsoluteincrement = fromhighindex - fromindex + 1;\n      var movedirectionalincrement = toindex - fromindex;\n      var tohighindex = toindex + (rangeabsoluteincrement - 1);\n      var shiftdirection = movedirectionalincrement > 0 ? // move up in list\n      -1 : // shift down, make room for shiftingindex above\n      1; // shift up, make room for shiftingindex below\n\n      var orderedindexlist = Array.from(indexToItemIDMap.keys());\n      orderedindexlist.sort(function (a, b) {\n        return a - b;\n      });\n      var toindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= toindex;\n      });\n      var tohighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= tohighindex;\n      });\n      var fromindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromindex;\n      });\n      var fromhighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromhighindex;\n      }); // ---------------- capture index data to move ----------------\n\n      var processtomoveList;\n\n      if (fromindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        processtomoveList = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        processtomoveList = orderedindexlist.slice(fromindexptr);\n      } else {\n        // scope is entirely in view\n        processtomoveList = orderedindexlist.slice(fromindexptr, fromhighindexptr + 1);\n      }\n\n      var processtomoveMap = new Map();\n\n      var capturemoveindex = function capturemoveindex(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n\n      processtomoveList.forEach(capturemoveindex); // ------------- get list of indexes to shift out of the way ---------------\n\n      var processtoshiftList;\n\n      if (shiftdirection == 1) {\n        // block is moving down, shift is up; toindex < fromindex\n        if (toindexptr == -1 && fromindexptr == -1) {\n          processtoshiftList = [];\n        } else if (fromindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(toindexptr);\n        } else {\n          processtoshiftList = orderedindexlist.slice(toindexptr, fromindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          processtoshiftList = [];\n        } else if (tohighindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n\n      if (shiftdirection == 1) processtoshiftList.reverse(); // -------------- move indexes out of the way --------------\n\n      var processedshiftList = [];\n\n      var processshiftindex = function processshiftindex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = shiftdirection == -1 ? index - rangeabsoluteincrement : index + rangeabsoluteincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedshiftList.push(newIndex);\n      };\n\n      processtoshiftList.forEach(processshiftindex); // ------------ replace shifted index space with moved indexes ----------\n\n      var processedmoveList = [];\n\n      var processmoveindex = function processmoveindex(itemID, index) {\n        var newIndex = index + movedirectionalincrement; // swap\n\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n\n      processtomoveMap.forEach(processmoveindex); // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n\n      var processedIndexes = [].concat(processedshiftList, processedmoveList);\n      return processedIndexes;\n    } // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      var _this$cacheProps2 = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n          metadataMap = _this$cacheProps2.metadataMap,\n          portalMap = _this$cacheProps2.portalMap; // ---------- define range parameters ---------------\n      // high range is the highest index number of the insert/remove operation\n\n      var highrangeindex = highrange !== null && highrange !== void 0 ? highrange : 0;\n      highrangeindex = highrangeindex > index ? highrangeindex : index;\n      var emptyreturn = [[], [], 0];\n\n      if (increment == -1) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) return emptyreturn;\n      } else {\n        // addition can at most start at the next index above the current list\n        if (index > listsize) return emptyreturn;\n      } // rangecount is the absolute number in the insert/remove range - contiguous\n\n\n      var rangecount = highrangeindex - index + 1; // range increment adds sign to rangecount to indicate add/remove\n\n      var rangeincrement = rangecount * increment; // highPtr, lowPtr, shrinktoPtr within orderedIndexList.\n\n      var orderedIndexList = Array.from(indexToItemIDMap.keys());\n      orderedIndexList.sort(function (a, b) {\n        return a - b;\n      }); // ---------- define boundaries within ordered cache index list ------------\n      // Ptr = index into array, as opposed to index of virtual list\n      // shrinkptr is the location of the bottom of the shrink range for removals\n\n      var shrinktoIndex = null;\n      var shrinktoPtr = -1;\n\n      if (increment == -1) {\n        shrinktoIndex = orderedIndexList.at(-1) + rangeincrement;\n        shrinktoIndex = Math.max(highrangeindex + rangeincrement, shrinktoIndex);\n        shrinktoIndex = Math.min(listsize - 1, shrinktoIndex);\n        shrinktoPtr = orderedIndexList.findIndex(function (value) {\n          return value >= shrinktoIndex;\n        });\n      } // lowPtr and highPtr must be within low and high range\n\n\n      var lowPtr = orderedIndexList.findIndex(function (value) {\n        return value >= index && value <= highrangeindex;\n      });\n      var reverseIndexList = Array.from(orderedIndexList);\n      reverseIndexList.reverse();\n      var highPtr = reverseIndexList.findIndex(function (value) {\n        return value <= highrangeindex;\n      });\n\n      if (highPtr != -1) {\n        highPtr = orderedIndexList.length - 1 - highPtr;\n        if (highPtr < lowPtr) highPtr = -1;\n      } // ----------- list indexes to process, replace, and remove, and items to remove --------\n\n\n      var indexesToProcessList,\n          // for either insert or remove\n      indexesToReplaceList = [],\n          // for insert the range being inserted\n      indexesToRemoveList = [],\n          // for remove - end of list; the list is shrinking\n      indexesOfItemsToRemoveList = [],\n          // for remove - within the range of indexes being removed\n      itemsToRemoveList = []; // for remove, derived from the previous\n      // get indexesToProcessList\n\n      if (lowPtr == -1 && highPtr == -1) {\n        // core scope is out of view\n        indexesToProcessList = [];\n      } else {\n        // core scope is partially or fully in view; lowPtr is available\n        if (increment == 1) {\n          indexesToProcessList = orderedIndexList.slice(lowPtr);\n        } else if (highPtr == -1) {\n          // increment == -1; lowPtr is available\n          indexesToProcessList = [];\n        } else {\n          // increment == -1; lowPtr and highPtr are available\n          indexesToProcessList = orderedIndexList.slice(highPtr + 1);\n        }\n      }\n\n      var portalHoldList = []; // hold portals for deletion until after after cradle synch\n\n      if (increment == 1) {\n        // get indexesToReplaceList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesToReplaceList = [];\n        } else if (highPtr == -1) {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n      } else {\n        // get indexesToRemoveList\n        if (shrinktoPtr == -1) {\n          // core scope is out of view\n          indexesToRemoveList = [];\n        } else {\n          indexesToRemoveList = orderedIndexList.slice(shrinktoPtr + 1);\n        } // get indexesOfItemsToRemoveList\n\n\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesOfItemsToRemoveList = [];\n        } else if (highPtr == -1) {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        } // get itemsToRemoveList\n\n\n        var _iterator3 = _createForOfIteratorHelper(indexesOfItemsToRemoveList),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _index = _step3.value;\n            itemsToRemoveList.push(indexToItemIDMap.get(_index));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } // ----------- conduct cache operations ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n\n\n      if (increment == 1) indexesToProcessList.reverse();\n      var indexesModifiedList = []; // modify index-to-itemid map, and metadata map\n\n      var processIndex = function processIndex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        indexesModifiedList.push(newIndex);\n      };\n\n      indexesToProcessList.forEach(processIndex); // delete remaining indexes and items now duplicates\n\n      if (increment == 1) {\n        var _iterator4 = _createForOfIteratorHelper(indexesToReplaceList),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index2 = _step4.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(indexesToRemoveList),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index3 = _step5.value;\n            indexToItemIDMap["delete"](_index3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        var _iterator6 = _createForOfIteratorHelper(itemsToRemoveList),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var itemID = _step6.value;\n            metadataMap["delete"](itemID);\n            portalHoldList.push(itemID);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n\n\n      return [indexesModifiedList, indexesToReplaceList, rangeincrement, portalHoldList];\n    } // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n\n  }, {\n    key: "registerRequestedPortal",\n    value: function registerRequestedPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: "removeRequestedPortal",\n    value: function removeRequestedPortal(index) {\n      this.cacheProps.requestedSet["delete"](index);\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return globalItemID++;\n    } // get new or existing itemID for contentfunctions.createCellFrame\n\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    } // create new portal\n\n  }, {\n    key: "createPortal",\n    value: function createPortal(component, index, itemID) {\n      var isPreload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.removeRequestedPortal(index);\n      var _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current,\n          layout = _this$cradleParameter.layout,\n          cellHeight = _this$cradleParameter.cellHeight,\n          cellWidth = _this$cradleParameter.cellWidth,\n          orientation = _this$cradleParameter.orientation;\n      var portalNode = createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth); // div wrapper to avoid memory leak\n\n      this.cacheProps.portalMap.set(itemID, react_1["default"].createElement("div", {\n        "data-type": \'portalwrapper\',\n        key: itemID,\n        "data-itemid": itemID,\n        "data-index": index\n      }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n        key: itemID,\n        node: portalNode\n      }, " ", component, " ")));\n      this.cacheProps.modified = true;\n      var portalMetadata = {\n        portalNode: portalNode,\n        isReparentingRef: {\n          current: false\n        },\n        index: index,\n        itemID: itemID,\n        component: component\n      };\n      this.cacheProps.metadataMap.set(itemID, portalMetadata);\n      this.cacheProps.indexToItemIDMap.set(index, itemID);\n      if (!isPreload) this.renderPortalList();\n      return portalMetadata;\n    } // used for preloading new item\n\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(index, getItem, scrollerPassthroughPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties, portalData;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                itemID = this.getNewItemID();\n                _context.prev = 1;\n                _context.next = 4;\n                return getItem(index, itemID);\n\n              case 4:\n                usercontent = _context.sent;\n                if (usercontent === null) returnvalue = usercontent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context["catch"](1);\n                returnvalue = usercontent = undefined;\n                error = _context.t0;\n\n              case 12:\n                if (usercontent !== null && usercontent !== undefined) {\n                  if (!react_1["default"].isValidElement(usercontent)) {\n                    returnvalue = usercontent;\n                    usercontent = undefined;\n                    error = new Error(\'invalid React element\');\n                  }\n                }\n\n                if (usercontent !== null && usercontent !== undefined) {\n                  scrollerProperties = {\n                    isReparentingRef: null,\n                    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef\n                  };\n\n                  if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                    content = react_1["default"].cloneElement(usercontent, {\n                      scrollerProperties: scrollerProperties\n                    });\n                  } else {\n                    content = usercontent;\n                  }\n\n                  portalData = this.createPortal(content, index, itemID, true); // true = isPreload\n                  // make available to user content\n\n                  scrollerProperties.isReparentingRef = portalData.isReparentingRef;\n                } else {\n                  if (usercontent === undefined) {\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, \'preload\', error);\n                  } else {\n                    // usercontent === null; last item in list\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                    maxListsizeInterrupt(index);\n                  }\n                }\n\n              case 14:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 8]]);\n      }));\n    } // delete a portal list item\n    // accepts an array of indexes\n\n  }, {\n    key: "deletePortal",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps3 = this.cacheProps,\n          metadataMap = _this$cacheProps3.metadataMap,\n          portalMap = _this$cacheProps3.portalMap,\n          indexToItemIDMap = _this$cacheProps3.indexToItemIDMap;\n      var deleteList = [];\n\n      var _iterator7 = _createForOfIteratorHelper(indexArray),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n          var itemID = indexToItemIDMap.get(i);\n          deleteList.push({\n            index: i,\n            itemID: itemID\n          });\n          metadataMap["delete"](itemID);\n          portalMap["delete"](itemID);\n          indexToItemIDMap["delete"](i);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this.cacheProps.modified = true;\n      deleteListCallback && deleteListCallback(deleteList);\n    } // query existence of a portal list item\n\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortal",\n    value: function getPortal(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n\n  return CacheHandler;\n}();\n\nexports.CacheHandler = CacheHandler; // ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n\nvar createPortalNode = function createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n  } else {\n    container.style.inset = \'unset\';\n    container.style.position = \'unset\';\n  }\n\n  var maxWidth = container.style.maxWidth = orientation == \'horizontal\' ? layout == \'variable\' ? cellWidth + \'px\' : \'unset\' : \'unset\';\n  container.style.maxHeight = orientation == \'vertical\' ? layout == \'variable\' ? cellHeight + \'px\' : \'unset\' : \'unset\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n}; // ========================[ Utility component ]==============================\n// portal list component for rapid relisting of updates, using external callback for set state\n\n\nvar PortalList = function PortalList(_ref) {\n  var cacheProps = _ref.cacheProps;\n\n  var _ref2 = (0, react_1.useState)(0),\n      _ref3 = _slicedToArray(_ref2, 2),\n      portalListCounter = _ref3[0],\n      setPortalListCounter = _ref3[1];\n\n  var counterRef = (0, react_1.useRef)(null);\n  counterRef.current = portalListCounter;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null); // const cachedivRef = useRef(null)\n\n  (0, react_1.useEffect)(function () {\n    cacheProps.setListState = function () {\n      portalArrayRef.current = cacheProps.portalList;\n      isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n    };\n\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return portalArrayRef.current;\n};\n\nexports.PortalList = PortalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NhY2hlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7OzsrQ0FEQSxvSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7O0FBRUE7O0FBRUEsSUFBSUEsWUFBWSxHQUFHLENBQW5CLEMsQ0FFQTtBQUNBOztJQUNhQyxZO0VBRVQsc0JBQVlDLFVBQVosRUFBd0JDLFdBQXhCLEVBQXFDQyxXQUFyQyxFQUFnRDtJQUFBOztJQUFBOztJQU1oRCxrQkFBYTtNQUNUQyxZQUFZLEVBQUMsSUFESjtNQUVUQyxRQUFRLEVBQUMsS0FGQTtNQUlUQyxXQUFXLEVBQUMsSUFBSUMsR0FBSixFQUpIO01BS1Q7TUFDQUMsWUFBWSxFQUFDLElBQUlDLEdBQUosRUFOSjtNQU9UQyxTQUFTLEVBQUMsSUFBSUgsR0FBSixFQVBEO01BUVRJLGdCQUFnQixFQUFDLElBQUlKLEdBQUosRUFSUjtNQVVUSyxVQUFVLEVBQUMsSUFWRjtNQVlUWCxVQUFVLEVBQUM7SUFaRixDQUFiLENBTmdELENBK0JoRDtJQUVBOztJQUVBLHNCQUFpQixVQUFDWSxXQUFELEVBQWNDLGtCQUFkLEVBQWtDQyxzQkFBbEMsRUFBNEQ7TUFFekUsS0FBSSxDQUFDYixXQUFMLENBQWlCVyxXQUFqQixFQUZ5RSxDQUl6RTs7O01BQ0EsSUFBTUcsY0FBYyxHQUFHLEtBQUksQ0FBQ0MsVUFBTCxDQUFnQk4sZ0JBQXZDO01BQ0EsSUFBTU8sV0FBVyxHQUFHQyxLQUFLLENBQUNDLElBQU4sQ0FBV0osY0FBYyxDQUFDSyxJQUFmLEVBQVgsQ0FBcEI7TUFDQUgsV0FBVyxDQUFDSSxJQUFaLENBQWlCLFVBQUNDLENBQUQsRUFBR0MsQ0FBSDtRQUFBLE9BQVNE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LG9CQUFPLElBQVAsQ0FBckI7RUFDQSxJQUFNK0csY0FBYyxHQUFHLG9CQUFPLElBQVAsQ0FBdkIsQ0FSeUMsQ0FTekM7O0VBRUEsdUJBQVUsWUFBSTtJQUVWdEwsVUFBVSxDQUFDYixZQUFYLEdBQTBCLFlBQUk7TUFFMUJtTSxjQUFjLENBQUM5SCxPQUFmLEdBQXlCeEQsVUFBVSxDQUFDTCxVQUFwQztNQUVBNEUsWUFBWSxDQUFDZixPQUFiLElBQXdCNEgsb0JBQW9CLENBQUMsRUFBRUMsVUFBVSxDQUFDN0gsT0FBZCxDQUE1QyxDQUowQixDQUl5QztJQUV0RSxDQU5EOztJQVFBLE9BQU8sWUFBSztNQUVSZSxZQUFZLENBQUNmLE9BQWIsR0FBdUIsS0FBdkI7SUFFSCxDQUpEO0VBTUgsQ0FoQkQsRUFnQkUsRUFoQkY7RUFrQkEsT0FBTzhILGNBQWMsQ0FBQzlILE9BQXRCO0FBRUgsQ0EvQk07O0FBQU04RyxrQkFBQUEsR0FBVVksVUFBViIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL2NhY2hlaGFuZGxlci50c3g/OWU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjYWNoZWhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIG1hbmFnZXMgdGhlIEluZmluaXRlR3JpZFNjcm9sbGVyIGxpbWl0ZWQgKHNwYXJzZSkgY2FjaGUuIEl0IGFsc28gcHJvdmlkZXMgc3VwcG9ydCBmb3IgXG4gICAgc2VydmljZXMgd2hpY2ggYWxsb3cgdGhlIGhvc3QgdG8gYWN0aXZlbHkgbWFuYWdlIG1hbnkgYXNwZWN0cyBvZiB0aGUgY2FjaGUuIFNlZSBkb2N1bWVudGF0aW9uXG4gICAgYWJvdXQgdGhlIHVzZXIgZ2V0RnVuY3Rpb25zIGNhbGxiYWNrIGZvciBkZXRhaWxzLiBOb3RlIHRoYXQgbGFyZ2UgY2FjaGVzIG9mIGNvbXBsZXggY29tcG9uZW50c1xuICAgIGNhbiBpbXBhaXIgcGVyZm9ybWFuY2UuIFRoaXMgY2FuIGJlIG9wdGltaXplZCB3aXRoIHRoZSBjYWNoZU1heCBwcm9wZXJ0eS5cblxuICAgIFRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyIHN0b3JlcyB1c2VyIGNlbGwgY29udGVudCAoY29tcG9uZW50cykgaW4gYSBjZW50cmFsIGhpZGRlbiBwb3J0YWwgY2FjaGUgXG4gICAgZm9yIGVhY2ggSW5maW5pdGVHcmlkU2Nyb2xsZXIgcm9vdCwgZnJvbSB3aGVuY2UgdGhlIGNvbXBvbmVudHMgYXJlIHB1bGxlZCBpbnRvIHRoZSByZWxldmFudCBDZWxsRnJhbWVzIFxuICAgIGZvciBkaXNwbGF5LiBUaGUgdXNlciBjb21wb25lbnRzIGFyZSBzdG9yZWQgaW4gUmVhY3QgcG9ydGFscywgd2l0aCBlYWNoIHBvcnRhbCBpbnN0YW50aWF0ZWQgaW5cbiAgICBhIGNvbnRhaW5lciBkaXYgKCdwb3J0YWx3cmFwcGVyJykuIFRoZXNlIGNvbnRhaW5lciBkaXZzIGFyZSBpbmNsdWRlZCBpbiBhIHN0YW5kYXJkIFJlYWN0IGNvbXBvbmVudCBcbiAgICBsaXN0IGluIHRoZSByZWFsIERPTS4gVGhlIGNvbnRhaW5lZCBwb3J0YWxzIHRoZW1zZWx2ZXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWFsIERPTSwgYnV0IGFyZSBwYXJ0IG9mIFxuICAgIFJlYWN0J3MgdmlydHVhbCBET00uXG5cbiAgICBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3BvcnRhbHMuaHRtbCBmb3IgZ2VuZXJhbCBpbmZvcm1hdGlvbiBhYm91dCBSZWFjdCBwb3J0YWxzLlxuICAgIFNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZWFjdC1yZXZlcnNlLXBvcnRhbCBmb3IgdGhlIHV0aWxpdHkgdGhhdCBJbmZpbml0ZUdyaWRTY3JvbGxlclxuICAgIHVzZXMgdG8gbWFuYWdlIHBvcnRhbHMuXG5cbiAgICBUaGlzIGNhY2hpbmcgaGFzIG1hbnkgYWR2YW50YWdlcywgbm90YWJseSB0aGUgYWJpbGl0eSB0byBtb3ZlIGNlbGxzIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlXG4gICAgaGVhZCBhbmQgdGFpbCBncmlkcyBvZiB0aGUgQ3JhZGxlLCBhbmQgdGhlIGFiaWxpdHkgdG8gbWFpbnRhaW4gc3RhdGUgZm9yIGNvbXBsZXggY29tcG9uZW50cyBcbiAgICB3aGljaCBtb3ZlIGJleW9uZCB0aGUgc2NvcGUgb2YgdGhlIGNvbnRlbnQgb2YgdGhlIENyYWRsZS4gQnV0IHRoZXJlIGlzIGFuIGltcG9ydGFudCBzaWRlIGVmZmVjdC5cbiAgICBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZWFsIERPTSAoaW50byB0aGUgcG9ydGFsIG9mIHRoZSB2aXJ0dWFsIERPTSlcbiAgICBoYXZlIHRoZWlyIHNjcm9sbCBwb3NpdGlvbnMsIHdpZHRoLCBhbmQgaGVpZ2h0IHNldCB0byB6ZXJvLiBUaGVyZWZvcmUgaWYgY29tcG9uZW50cyByZWx5IG9uIHRoZXNlIFxuICAgIHZhbHVlcyBmb3IgY29uZmlndXJhdGlvbiwgdGhleSBtdXN0IGhhdmUgYSB3YXkgb2Ygc3RvcmluZyB2YWx1ZXMgaW4gc3RhdGUgKG5vdGFibHkgdGhlIFxuICAgIFNjcm9sbCBQb3MgLSBzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCksIHJlY29nbml6aW5nIHdoZW4gdGhlIGNvbXBvbmVudCBjb21lcyBvdXQgb2YgdGhlIHBvcnRhbCBjYWNoZSBcbiAgICBpbnRvIHRoZSByZWFsIERPTSAod2lkdGggYW5kIGhlaWdodCBhcmUgdHlwaWNhbGx5IG5vIGxvbmdlciBib3RoIDApLCBhbmQgcmVzcG9uZGluZyB0byBjaGFuZ2UgaW4gXG4gICAgY2FjaGUgc3RhdGUgYXBwcm9wcmlhdGVseS5cblxuICAgIFRpcHM6XG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgaW4gY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgPSAwXG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgb3V0IG9mIGNhY2hlIHdoZW4gYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbFxuICAgICAgICAtIGlmIHlvdSBjcmVhdGUgYW4gZW1wdHkgJ3Njcm9sbGVyUHJvcGVydGllcycgcHJvcGVydHkgZm9yIHlvdXIgY29tcG9uZW50LCBDZWxsRnJhbWUgd2lsbFxuICAgICAgICAgICAgc2V0IGl0IHRvIGFuIG9iamVjdCBjb250YWluaW5nIGlzUmVwYXJlbnRpbmdSZWYgYW5kIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmXG4gICAgICAgIC0gaXNSZXBhcmVudGluZ1JlZi5jdXJyZW50IHByb3ZpZGVzIGFuIHVwLXRvLWRhdGUgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBcbiAgICAgICAgICAgIGN1cnJlbnRseSBiZWluZyAncmVwYXJlbnRlZCcgaW50byB0aGUgcmVhbCBET00uIFNldCB0aGUgdmFsdWUgYmFjayB0byBmYWxzZSBvbmNlIHlvdSd2ZSBcbiAgICAgICAgICAgIGRldGVjdGVkIGl0LiBBZnRlciByZXBhcmVudGluZyAoYWZ0ZXIgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGJhY2sgdG8gbm9ybWFsKSBpcyB3aGVuXG4gICAgICAgICAgICB5b3Ugc2hvdWxkIHJlc3RvcmUgc2Nyb2xsUG9zIChzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCkgdG8gd2hhdCBpdCB3YXMuXG4gICAgICAgIC0gaWYgeW91ciBjb21wb25lbnQgZG9lcyBub3Qgc2Nyb2xsLCB0aGVyZSBzaG91bGQgYmUgbm8gaXNzdWVzLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgY3JlYXRlSHRtbFBvcnRhbE5vZGUsIEluUG9ydGFsIH0gZnJvbSAncmVhY3QtcmV2ZXJzZS1wb3J0YWwnXG5cbmxldCBnbG9iYWxJdGVtSUQgPSAwXG5cbi8vIGdsb2JhbCBzY3JvbGxlciBkYXRhLCBvcmdhbml6ZWQgYnkgc2Vzc2lvbiBzY3JvbGxlcklEXG4vLyB0aGUgY2FjaGUgaXRzZWxmIGlzIG1haW50YWluZWQgaW4gdGhlIHJvb3QgaW5maW5pdGVncmlkc2Nyb2xsZXIgY29tcG9uZW50XG5leHBvcnQgY2xhc3MgQ2FjaGVIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHNjcm9sbGVySUQsIHNldExpc3RzaXplLCBsaXN0c2l6ZVJlZikge1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMuc2Nyb2xsZXJJRCA9IHNjcm9sbGVySURcbiAgICAgICAgdGhpcy5zZXRMaXN0c2l6ZSA9IHNldExpc3RzaXplIC8vIHBhc3NlZCBmcm9tIGluZmluaXRlZ3JpZHNjcm9sbGVyIHNldExpc3RzaXplKGxpc3RzaXplKVxuICAgICAgICB0aGlzLmxpc3RzaXplUmVmID0gbGlzdHNpemVSZWZcbiAgICB9XG5cbiAgICBjYWNoZVByb3BzID0ge1xuICAgICAgICBzZXRMaXN0U3RhdGU6bnVsbCxcbiAgICAgICAgbW9kaWZpZWQ6ZmFsc2UsXG5cbiAgICAgICAgbWV0YWRhdGFNYXA6bmV3IE1hcCgpLCAvLyBpdGVtID0+IHtpbmRleCwgY29tcG9uZW50fVxuICAgICAgICAvLyBzb21lIHBvcnRhbHMgbWF5IGhhdmUgYmVlbiByZXF1ZXN0ZWQgYnkgcmVxdWVzdGlkbGVjYWxsYmFjaywgbm90IHlldCBjcmVhdGVkXG4gICAgICAgIHJlcXVlc3RlZFNldDpuZXcgU2V0KCksIC8vIHJlcXVlc3RlZFNldCBvZiBpbmRleGVzXG4gICAgICAgIHBvcnRhbE1hcDpuZXcgTWFwKCksIC8vIGluZGV4ID0+IEluUG9ydGFsXG4gICAgICAgIGluZGV4VG9JdGVtSURNYXA6bmV3IE1hcCgpLFxuXG4gICAgICAgIHBvcnRhbExpc3Q6bnVsbCxcblxuICAgICAgICBzY3JvbGxlcklEOm51bGxcbiAgICB9XG5cbiAgICBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwb3J0YWxIb2xkTGlzdFxuXG4gICAgbGlzdHNpemVSZWZcblxuICAgIC8vIHNldExpc3RzaXplKGxpc3RzaXplKSBjYXVzZXMgYW4gSW5maW5pdGVHcmlkU2Nyb2xsZXIgdXNlU3RhdGUgdXBkYXRlXG4gICAgLy8gb2YgdGhlIGxpc3RzaXplIHRocm91Z2hvdXRcbiAgICBzZXRMaXN0c2l6ZSBcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09WyBSRVBPU0lUT1JZIEFORCBMSVNUIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGJhc2ljIG9wZXJhdGlvbnMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFuZ2VMaXN0c2l6ZSA9IChuZXdsaXN0c2l6ZSwgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgdGhpcy5zZXRMaXN0c2l6ZShuZXdsaXN0c2l6ZSlcblxuICAgICAgICAvLyBtYXRjaCBjYWNoZSB0byBuZXdsaXN0c2l6ZVxuICAgICAgICBjb25zdCBwb3J0YWxJbmRleE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG4gICAgICAgIGNvbnN0IG1hcGtleXNMaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleE1hcC5rZXlzKCkpXG4gICAgICAgIG1hcGtleXNMaXN0LnNvcnQoKGEsYikgPT4gYSAtIGIpXG5cbiAgICAgICAgY29uc3QgaGlnaGVzdGluZGV4ID0gbWFwa2V5c0xpc3QuYXQoLTEpXG5cbiAgICAgICAgaWYgKGhpZ2hlc3RpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSkpIHsgLy8gcGFyZSB0aGUgY2FjaGVcblxuICAgICAgICAgICAgY29uc3QgcGFyZWxpc3QgPSBtYXBrZXlzTGlzdC5maWx0ZXIoKGluZGV4KT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKHBhcmVsaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgJiYgY2hhbmdlTGlzdHNpemVDYWxsYmFjayhuZXdsaXN0c2l6ZSlcblxuICAgIH1cblxuICAgIGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG5cbiAgICAgICAgLy8ga2VlcCB0aGUgc2V0TGlzdFN0YXRlIGNhbGxiYWNrXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxNYXAuY2xlYXIoKSBcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBvcnRhbExpc3QgPSBudWxsXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcblxuICAgICAgICB0aGlzLnJlbmRlclBvcnRhbExpc3QoKSAvLyB0cmlnZ2VyIGRpc3BsYXkgdXBkYXRlXG5cbiAgICB9XG5cbiAgICAvLyBzZXQgc3RhdGUgb2YgdGhlIFBvcnRhbExpc3QgY29tcG9uZW50IG9mIHRoZSBzY3JvbGxlciB0byB0cmlnZ2VyIHJlbmRlclxuICAgIHJlbmRlclBvcnRhbExpc3QgPSAoKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBvcnRhbExpc3QgPSBBcnJheS5mcm9tKHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxNYXAudmFsdWVzKCkpXG4gICAgICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnNldExpc3RTdGF0ZSgpIC8vIHRyaWdnZXIgZGlzcGxheSB1cGRhdGVcblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhY2hlIHNpemUgbGltaXQgZW5mb3JjZWVudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBtYXRjaENhY2hlVG9DcmFkbGUgPSAoY3JhZGxlSW5kZXhMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgICAgICBjb25zdCBtYXBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgZGVsa2V5cyA9IG1hcGtleXMuZmlsdGVyKGtleSA9PiAhY3JhZGxlSW5kZXhMaXN0LmluY2x1ZGVzKGtleSkpXG5cbiAgICAgICAgaWYgKGRlbGtleXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbGtleXMsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcGFyZUNhY2hlVG9NYXggPSAoY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEID0gdW5kZWZpbmVkKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbW9kZWxMZW5ndGggPSBjcmFkbGVJbmRleExpc3QubGVuZ3RoXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5lZWQgZm9yIHBhcmluZ1xuICAgICAgICBpZiAoKCFjYWNoZU1heCkgfHwgKCFtb2RlbExlbmd0aCkpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KG1vZGVsTGVuZ3RoLCBjYWNoZU1heClcblxuICAgICAgICBjb25zdCBwb3J0YWxJbmRleExpc3QgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcFxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRTZXQgPSB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgaWYgKChwb3J0YWxJbmRleExpc3Quc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSBtYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIG1hcCBrZXlzXG4gICAgICAgIGNvbnN0IG1hcGtleXNsaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleExpc3Qua2V5cygpKVxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRrZXlzID0gQXJyYXkuZnJvbShyZXF1ZXN0ZWRTZXQua2V5cygpKVxuXG4gICAgICAgIGNvbnN0IG1hcGtleXMgPSBbLi4ubWFwa2V5c2xpc3QsLi4ucmVxdWVzdGVka2V5c11cblxuICAgICAgICBtYXBrZXlzLnNvcnQoKGEsYikgPT4gYSAtIGIpXG5cbiAgICAgICAgLy8gZ2V0IG51bWJlciB0byBwYXJlXG4gICAgICAgIGNvbnN0IG1hcExlbmd0aCA9IG1hcGtleXMubGVuZ3RoXG4gICAgICAgIGNvbnN0IHBhcmVjb3VudCA9IG1hcExlbmd0aCAtIG1heFxuXG4gICAgICAgIC8vIGRpc3RyaWJ1dGUgcGFyaW5nIHByb3BvcnRpb25hbGx5IGF0IGZyb250IGFuZCBiYWNrXG4gICAgICAgIGNvbnN0IGhlYWRpbmRleCA9IGNyYWRsZUluZGV4TGlzdFswXVxuICAgICAgICBjb25zdCB0YWlsaW5kZXggPSBjcmFkbGVJbmRleExpc3RbbW9kZWxMZW5ndGggLSAxXVxuICAgICAgICBjb25zdCBoZWFkcG9zID0gbWFwa2V5cy5pbmRleE9mKGhlYWRpbmRleClcbiAgICAgICAgY29uc3QgdGFpbHBvcyA9IG1hcGtleXMuaW5kZXhPZih0YWlsaW5kZXgpXG5cbiAgICAgICAgY29uc3QgaGVhZHJvb20gPSBoZWFkcG9zXG4gICAgICAgIGNvbnN0IHRhaWxyb29tID0gbWFwTGVuZ3RoIC0gKHRhaWxwb3MgKyAxKVxuICAgICAgICBjb25zdCBwYXJlcm9vbSA9IGhlYWRyb29tICsgdGFpbHJvb21cblxuICAgICAgICBjb25zdCBoZWFkcGFyZWNvdW50ID0gTWF0aC5mbG9vcigoaGVhZHJvb20vcGFyZXJvb20pKnBhcmVjb3VudClcbiAgICAgICAgY29uc3QgdGFpbHBhcmVjb3VudCA9IHBhcmVjb3VudCAtIGhlYWRwYXJlY291bnRcblxuICAgICAgICAvLyBjb2xsZWN0IGluZGV4ZXMgdG8gcGFyZVxuICAgICAgICBjb25zdCBoZWFkbGlzdCA9IG1hcGtleXMuc2xpY2UoMCxoZWFkcGFyZWNvdW50KVxuICAgICAgICBjb25zdCB0YWlsbGlzdCA9IG1hcGtleXMuc2xpY2UobWFwTGVuZ3RoIC0gdGFpbHBhcmVjb3VudClcblxuICAgICAgICBjb25zdCBkZWxMaXN0ID0gWy4uLmhlYWRsaXN0LC4uLnRhaWxsaXN0XVxuXG4gICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoY2FjaGVNYXgsIGNyYWRsZUxpc3RMZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTikgPT4ge1xuXG4gICAgICAgIGlmICghY2FjaGVNYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxNYXBcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkU2V0ID0gdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldFxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGNyYWRsZUxpc3RMZW5ndGgsIGNhY2hlTWF4KVxuXG4gICAgICAgIGlmICgocG9ydGFsTWFwLnNpemUgKyByZXF1ZXN0ZWRTZXQuc2l6ZSkgPD0gKChtYXgpICogTUFYX0NBQ0hFX09WRVJfUlVOKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcHJlbG9hZCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZWxvYWQoY3JhZGxlUGFyYW1ldGVycywgZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRCkge1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYgfSA9IGNyYWRsZVBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGdldEl0ZW0sIGNhY2hlTWF4IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW11cblxuICAgICAgICBsZXQgY2FjaGVTaXplID0gY2FjaGVNYXggPz8gMFxuXG4gICAgICAgIGNhY2hlU2l6ZSA9IE1hdGgubWluKGNhY2hlU2l6ZSwgbGlzdHNpemUpXG5cbiAgICAgICAgY29uc3QgcHJlbG9hZHNpemUgPSBcbiAgICAgICAgICAgIGNhY2hlU2l6ZT9cbiAgICAgICAgICAgICAgICBjYWNoZVNpemU6XG4gICAgICAgICAgICAgICAgbGlzdHNpemVcblxuICAgICAgICBjb25zdCBicmVha2xvb3AgPSB7XG4gICAgICAgICAgICBjdXJyZW50OmZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhMaXN0c2l6ZUludGVycnVwdCA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgYnJlYWtsb29wLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnByZWxvYWRJbmRleENhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5kZXhUb0l0ZW1JRE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG5cbiAgICAgICAgICAgIGNvbnN0IHsgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJlbG9hZHNpemU7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrICYmIHByZWxvYWRJbmRleENhbGxiYWNrKGluZGV4KVxuICAgICAgICAgICAgICAgIGlmICghaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucHJlbG9hZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChicmVha2xvb3AuY3VycmVudCkgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcykudGhlbihcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgZmluYWxDYWxsYmFjaygpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1bIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZ2V0Q2FjaGVJbmRleE1hcCgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IE1hcCh0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcClcblxuICAgIH1cblxuICAgIGdldENyYWRsZUluZGV4TWFwKGNyYWRsZUluZGV4TGlzdCkge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgICAgIGNyYWRsZU1hcC5zZXQoaW5kZXgsIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyYWRsZU1hcFxuXG4gICAgfVxuXG4gICAgZ2V0Q2FjaGVJdGVtTWFwKCkge1xuXG4gICAgICAgIGNvbnN0IGNhY2hlbGlzdCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIH0gPSB2YWx1ZVxuXG4gICAgICAgICAgICBjYWNoZWxpc3Quc2V0KGtleSx7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlbGlzdFxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gbW92ZSBpcyBjb2VyY2VkIGJ5IHNlcnZpY2VoYW5kbGVyIHRvIGJlIHdpdGhpbiBjdXJyZW50IGxpc3QgYm91bmRzXG4gICAgbW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgZnJvbWhpZ2hpbmRleCApIHtcblxuICAgICAgICBjb25zdCB7aW5kZXhUb0l0ZW1JRE1hcCxtZXRhZGF0YU1hcH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBkZWZpbmUgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCByYW5nZWFic29sdXRlaW5jcmVtZW50ID0gZnJvbWhpZ2hpbmRleCAtIGZyb21pbmRleCArIDFcbiAgICAgICAgY29uc3QgbW92ZWRpcmVjdGlvbmFsaW5jcmVtZW50ID0gdG9pbmRleCAtIGZyb21pbmRleFxuXG4gICAgICAgIGNvbnN0IHRvaGlnaGluZGV4ID0gdG9pbmRleCArIChyYW5nZWFic29sdXRlaW5jcmVtZW50IC0gMSlcblxuICAgICAgICBjb25zdCBzaGlmdGRpcmVjdGlvbiA9IFxuICAgICAgICAgICAgKG1vdmVkaXJlY3Rpb25hbGluY3JlbWVudCA+IDApPyAvLyBtb3ZlIHVwIGluIGxpc3RcbiAgICAgICAgICAgICAgICAtMTogLy8gc2hpZnQgZG93biwgbWFrZSByb29tIGZvciBzaGlmdGluZ2luZGV4IGFib3ZlXG4gICAgICAgICAgICAgICAgMSAgIC8vIHNoaWZ0IHVwLCBtYWtlIHJvb20gZm9yIHNoaWZ0aW5naW5kZXggYmVsb3dcblxuICAgICAgICBjb25zdCBvcmRlcmVkaW5kZXhsaXN0ID0gQXJyYXkuZnJvbShpbmRleFRvSXRlbUlETWFwLmtleXMoKSlcbiAgICAgICAgb3JkZXJlZGluZGV4bGlzdC5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgY29uc3QgdG9pbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHRvaW5kZXgpXG4gICAgICAgIGNvbnN0IHRvaGlnaGluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gdG9oaWdoaW5kZXgpXG4gICAgICAgIGNvbnN0IGZyb21pbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IGZyb21pbmRleClcbiAgICAgICAgY29uc3QgZnJvbWhpZ2hpbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IGZyb21oaWdoaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBjYXB0dXJlIGluZGV4IGRhdGEgdG8gbW92ZSAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHByb2Nlc3N0b21vdmVMaXN0XG4gICAgICAgIGlmICgoZnJvbWluZGV4cHRyID09IC0xKSAmJiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkpIHsgLy8gc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkgeyAvLyBzY29wZSBpcyBwYXJ0aWFsbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWluZGV4cHRyKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHNjb3BlIGlzIGVudGlyZWx5IGluIHZpZXdcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21pbmRleHB0ciwgZnJvbWhpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3N0b21vdmVNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgY2FwdHVyZW1vdmVpbmRleCA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdC5mb3JFYWNoKGNhcHR1cmVtb3ZlaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBnZXQgbGlzdCBvZiBpbmRleGVzIHRvIHNoaWZ0IG91dCBvZiB0aGUgd2F5IC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBcbiAgICAgICAgbGV0IHByb2Nlc3N0b3NoaWZ0TGlzdFxuICAgICAgICBpZiAoc2hpZnRkaXJlY3Rpb24gPT0gMSkgeyAvLyBibG9jayBpcyBtb3ZpbmcgZG93biwgc2hpZnQgaXMgdXA7IHRvaW5kZXggPCBmcm9taW5kZXhcblxuICAgICAgICAgICAgaWYgKCh0b2luZGV4cHRyID09IC0xKSAmJiAoZnJvbWluZGV4cHRyID09IC0xKSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9taW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UodG9pbmRleHB0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UodG9pbmRleHB0ciwgZnJvbWluZGV4cHRyKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc2hpZnRkaXJlY3Rpb24gPT0gLTE7IGJsb2NrIGlzIG1vdmluZyB1cCwgc2hpZnQgaXMgZG93bjsgZnJvbWluZGV4IDwgdG9pbmRleFxuXG4gICAgICAgICAgICBpZiAodG9oaWdoaW5kZXhwdHIgPT0gLTEgJiYgZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2hpZ2hpbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWhpZ2hpbmRleHB0ciArIDEsIHRvaGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoaWZ0ZGlyZWN0aW9uID09IDEpIHByb2Nlc3N0b3NoaWZ0TGlzdC5yZXZlcnNlKClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBtb3ZlIGluZGV4ZXMgb3V0IG9mIHRoZSB3YXkgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRzaGlmdExpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzc2hpZnRpbmRleCA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcblxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBcbiAgICAgICAgICAgICAgICAoc2hpZnRkaXJlY3Rpb24gPT0gLTEpP1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtIHJhbmdlYWJzb2x1dGVpbmNyZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICsgcmFuZ2VhYnNvbHV0ZWluY3JlbWVudFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKS5pbmRleCA9IG5ld0luZGV4XG4gICAgICAgICAgICBwcm9jZXNzZWRzaGlmdExpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0LmZvckVhY2gocHJvY2Vzc3NoaWZ0aW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIHJlcGxhY2Ugc2hpZnRlZCBpbmRleCBzcGFjZSB3aXRoIG1vdmVkIGluZGV4ZXMgLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZG1vdmVMaXN0ID0gW11cbiAgICAgICAgY29uc3QgcHJvY2Vzc21vdmVpbmRleCA9IChpdGVtSUQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgbW92ZWRpcmVjdGlvbmFsaW5jcmVtZW50IC8vIHN3YXBcblxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5zZXQobmV3SW5kZXgsIGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIHByb2Nlc3NlZG1vdmVMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3N0b21vdmVNYXAuZm9yRWFjaChwcm9jZXNzbW92ZWluZGV4KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tcmV0dXJuIGxpc3Qgb2YgcHJvY2Vzc2VkIGluZGV4ZXMgdG8gY2FsbGVyIC0tLS0tLS0tXG4gICAgICAgIC8vIGZvciBzeW5jaHJuaXphdGlvbiB3aXRoIGNyYWRsZSBjZWxsRnJhbWVzXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkSW5kZXhlcyA9IFsuLi5wcm9jZXNzZWRzaGlmdExpc3QsLi4ucHJvY2Vzc2VkbW92ZUxpc3RdXG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEluZGV4ZXNcblxuICAgIH1cblxuICAgIC8vIGluc2VydCBvciByZW1vdmUgaW5kZXhlczogbXVjaCBvZiB0aGlzIGRlYWxzIHdpdGggdGhlIGZhY3QgdGhhdCB0aGUgY2FjaGUgaXMgc3BhcnNlLlxuICAgIGluc2VydFJlbW92ZUluZGV4KGluZGV4LCBoaWdocmFuZ2UsIGluY3JlbWVudCwgbGlzdHNpemUpIHsgLy8gaW5jcmVtZW50IGlzICsxIG9yIC0xXG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwLCBtZXRhZGF0YU1hcCwgcG9ydGFsTWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSByYW5nZSBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhpZ2ggcmFuZ2UgaXMgdGhlIGhpZ2hlc3QgaW5kZXggbnVtYmVyIG9mIHRoZSBpbnNlcnQvcmVtb3ZlIG9wZXJhdGlvblxuICAgICAgICBsZXQgaGlnaHJhbmdlaW5kZXggPSBoaWdocmFuZ2UgPz8gMFxuXG4gICAgICAgIGhpZ2hyYW5nZWluZGV4ID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlaW5kZXggPiBpbmRleCk/XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXg6XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCBlbXB0eXJldHVybiA9IFtbXSxbXSwwXVxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92YWwgbXVzdCBiZSBlbnRpcmVseSB3aXRoaW4gc2NvcGUgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmIChoaWdocmFuZ2VpbmRleCA+IChsaXN0c2l6ZSAtIDEpKSByZXR1cm4gZW1wdHlyZXR1cm5cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBhZGRpdGlvbiBjYW4gYXQgbW9zdCBzdGFydCBhdCB0aGUgbmV4dCBpbmRleCBhYm92ZSB0aGUgY3VycmVudCBsaXN0XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBsaXN0c2l6ZSkgcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhbmdlY291bnQgaXMgdGhlIGFic29sdXRlIG51bWJlciBpbiB0aGUgaW5zZXJ0L3JlbW92ZSByYW5nZSAtIGNvbnRpZ3VvdXNcbiAgICAgICAgY29uc3QgcmFuZ2Vjb3VudCA9IGhpZ2hyYW5nZWluZGV4IC0gaW5kZXggKyAxXG5cbiAgICAgICAgLy8gcmFuZ2UgaW5jcmVtZW50IGFkZHMgc2lnbiB0byByYW5nZWNvdW50IHRvIGluZGljYXRlIGFkZC9yZW1vdmVcbiAgICAgICAgY29uc3QgcmFuZ2VpbmNyZW1lbnQgPSByYW5nZWNvdW50ICogaW5jcmVtZW50XG5cbiAgICAgICAgLy8gaGlnaFB0ciwgbG93UHRyLCBzaHJpbmt0b1B0ciB3aXRoaW4gb3JkZXJlZEluZGV4TGlzdC5cbiAgICAgICAgY29uc3Qgb3JkZXJlZEluZGV4TGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIG9yZGVyZWRJbmRleExpc3Quc29ydCgoYSxiKT0+YS1iKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gZGVmaW5lIGJvdW5kYXJpZXMgd2l0aGluIG9yZGVyZWQgY2FjaGUgaW5kZXggbGlzdCAtLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUHRyID0gaW5kZXggaW50byBhcnJheSwgYXMgb3Bwb3NlZCB0byBpbmRleCBvZiB2aXJ0dWFsIGxpc3RcblxuICAgICAgICAvLyBzaHJpbmtwdHIgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBib3R0b20gb2YgdGhlIHNocmluayByYW5nZSBmb3IgcmVtb3ZhbHNcbiAgICAgICAgbGV0IHNocmlua3RvSW5kZXggPSBudWxsXG4gICAgICAgIGxldCBzaHJpbmt0b1B0ciA9IC0gMVxuICAgICAgICBcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAtIDEpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2hyaW5rdG9JbmRleCA9IG9yZGVyZWRJbmRleExpc3QuYXQoLTEpICsgKHJhbmdlaW5jcmVtZW50KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5tYXgoaGlnaHJhbmdlaW5kZXggKyAocmFuZ2VpbmNyZW1lbnQpLCBzaHJpbmt0b0luZGV4KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5taW4obGlzdHNpemUgLSAxLHNocmlua3RvSW5kZXgpIFxuXG4gICAgICAgICAgICBzaHJpbmt0b1B0ciA9IG9yZGVyZWRJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHNocmlua3RvSW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvd1B0ciBhbmQgaGlnaFB0ciBtdXN0IGJlIHdpdGhpbiBsb3cgYW5kIGhpZ2ggcmFuZ2VcbiAgICAgICAgY29uc3QgbG93UHRyID0gb3JkZXJlZEluZGV4TGlzdC5maW5kSW5kZXgodmFsdWUgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlID49IGluZGV4KSAmJiAodmFsdWUgPD0gaGlnaHJhbmdlaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCByZXZlcnNlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShvcmRlcmVkSW5kZXhMaXN0KVxuICAgICAgICByZXZlcnNlSW5kZXhMaXN0LnJldmVyc2UoKVxuICAgICAgICBsZXQgaGlnaFB0ciA9IHJldmVyc2VJbmRleExpc3QuZmluZEluZGV4KHZhbHVlPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPD0gaGlnaHJhbmdlaW5kZXhcblxuICAgICAgICB9KVxuICAgICAgICBpZiAoaGlnaFB0ciAhPSAtMSkge1xuICAgICAgICAgICAgaGlnaFB0ciA9IChvcmRlcmVkSW5kZXhMaXN0Lmxlbmd0aCAtIDEpIC0gaGlnaFB0clxuICAgICAgICAgICAgaWYgKGhpZ2hQdHIgPCBsb3dQdHIpIGhpZ2hQdHIgPSAtMVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gbGlzdCBpbmRleGVzIHRvIHByb2Nlc3MsIHJlcGxhY2UsIGFuZCByZW1vdmUsIGFuZCBpdGVtcyB0byByZW1vdmUgLS0tLS0tLS1cblxuICAgICAgICBsZXQgaW5kZXhlc1RvUHJvY2Vzc0xpc3QsIC8vIGZvciBlaXRoZXIgaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBbXSwgLy8gZm9yIGluc2VydCB0aGUgcmFuZ2UgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBbXSwgLy8gZm9yIHJlbW92ZSAtIGVuZCBvZiBsaXN0OyB0aGUgbGlzdCBpcyBzaHJpbmtpbmdcbiAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0PSBbXSwgLy8gZm9yIHJlbW92ZSAtIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgaW5kZXhlcyBiZWluZyByZW1vdmVkXG4gICAgICAgICAgICBpdGVtc1RvUmVtb3ZlTGlzdCA9IFtdIC8vIGZvciByZW1vdmUsIGRlcml2ZWQgZnJvbSB0aGUgcHJldmlvdXNcblxuICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUHJvY2Vzc0xpc3RcbiAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gW11cblxuICAgICAgICB9IGVsc2UgeyAvLyBjb3JlIHNjb3BlIGlzIHBhcnRpYWxseSBvciBmdWxseSBpbiB2aWV3OyBsb3dQdHIgaXMgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaWdoUHRyID09IC0xKSB7IC8vIGluY3JlbWVudCA9PSAtMTsgbG93UHRyIGlzIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbmNyZW1lbnQgPT0gLTE7IGxvd1B0ciBhbmQgaGlnaFB0ciBhcmUgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UoaGlnaFB0ciArIDEpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9ydGFsSG9sZExpc3QgPSBbXSAvLyBob2xkIHBvcnRhbHMgZm9yIGRlbGV0aW9uIHVudGlsIGFmdGVyIGFmdGVyIGNyYWRsZSBzeW5jaFxuXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkge1xuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUmVwbGFjZUxpc3RcbiAgICAgICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyLCBoaWdoUHRyICsgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgaWYgKHNocmlua3RvUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2Uoc2hyaW5rdG9QdHIgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3RcbiAgICAgICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyLCBoaWdoUHRyICsgMSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgaXRlbXNUb1JlbW92ZUxpc3RcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIGl0ZW1zVG9SZW1vdmVMaXN0LnB1c2goaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGNvbmR1Y3QgY2FjaGUgb3BlcmF0aW9ucyAtLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGhpZ2hlciBmcm9tIHRvcCBvZiBsaXN0IHRvIHByZXNlcnZlIGxvd2VyIHZhbHVlcyBmb3Igc3Vic2VxdWVudCBpbmNyZW1lbnRcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSBpbmRleGVzVG9Qcm9jZXNzTGlzdC5yZXZlcnNlKCkgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc01vZGlmaWVkTGlzdCA9IFtdXG5cbiAgICAgICAgLy8gbW9kaWZ5IGluZGV4LXRvLWl0ZW1pZCBtYXAsIGFuZCBtZXRhZGF0YSBtYXBcbiAgICAgICAgY29uc3QgcHJvY2Vzc0luZGV4ID0gaW5kZXggPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyByYW5nZWluY3JlbWVudFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgaW5kZXhlc01vZGlmaWVkTGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdC5mb3JFYWNoKHByb2Nlc3NJbmRleClcblxuICAgICAgICAvLyBkZWxldGUgcmVtYWluaW5nIGluZGV4ZXMgYW5kIGl0ZW1zIG5vdyBkdXBsaWNhdGVzXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc1RvUmVwbGFjZUxpc3QpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtSUQgb2YgaXRlbXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsSG9sZExpc3QucHVzaChpdGVtSUQpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlcyBmb3IgY2FsbGVyIHRvIHNlbmQgdG8gY29udGVudGhhbmRsZXIgZm9yIGNyYWRsZSBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgcmV0dXJuIFtpbmRleGVzTW9kaWZpZWRMaXN0LCBpbmRleGVzVG9SZXBsYWNlTGlzdCwgcmFuZ2VpbmNyZW1lbnQsIHBvcnRhbEhvbGRMaXN0XVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIElORElWSURVQUwgUE9SVEFMIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVzZWQgZm9yIHNpemUgY2FsY3VsYXRpb24gaW4gcGFyZUNhY2hlVG9NYXhcbiAgICAvLyByZWdpc3RlcnMgaW5kZXhlcyB3aGVuIHJlcXVlc3RlZCBidXQgYmVmb3JlIHJldHJpZXZlZCBhbmQgZW50ZXJlZCBpbnRvIGNhY2hlXG4gICAgcmVnaXN0ZXJSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmFkZChpbmRleClcblxuICAgIH1cblxuICAgIHJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuZGVsZXRlKGluZGV4KVxuXG4gICAgfVxuXG4gICAgZ2V0TmV3SXRlbUlEKCkge1xuXG4gICAgICAgIHJldHVybiBnbG9iYWxJdGVtSUQrK1xuXG4gICAgfVxuXG4gICAgLy8gZ2V0IG5ldyBvciBleGlzdGluZyBpdGVtSUQgZm9yIGNvbnRlbnRmdW5jdGlvbnMuY3JlYXRlQ2VsbEZyYW1lXG4gICAgZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRChpbmRleCkge1xuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gXG4gICAgICAgICAgICAoaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKT9cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgKHRoaXMuZ2V0TmV3SXRlbUlEKCkpXG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JRFxuXG4gICAgfVxuXG4gICAgIC8vIGNyZWF0ZSBuZXcgcG9ydGFsXG4gICAgY3JlYXRlUG9ydGFsKGNvbXBvbmVudCwgaW5kZXgsIGl0ZW1JRCwgaXNQcmVsb2FkID0gZmFsc2UpIHtcblxuICAgICAgICB0aGlzLnJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleClcblxuICAgICAgICBjb25zdCB7IGxheW91dCwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBvcmllbnRhdGlvbiB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlKGluZGV4LCBpdGVtSUQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aClcblxuICAgICAgICAvLyBkaXYgd3JhcHBlciB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLnNldChpdGVtSUQsXG4gICAgICAgICAgICAgICAgPGRpdiBkYXRhLXR5cGUgPSAncG9ydGFsd3JhcHBlcicga2V5ID0ge2l0ZW1JRH0gZGF0YS1pdGVtaWQgPSB7aXRlbUlEfSBkYXRhLWluZGV4ID0ge2luZGV4fT5cbiAgICAgICAgICAgICAgICAgICAgPEluUG9ydGFsIGtleSA9IHtpdGVtSUR9IG5vZGUgPSB7cG9ydGFsTm9kZX0gPiB7IGNvbXBvbmVudCB9IDwvSW5Qb3J0YWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+KVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcblxuICAgICAgICBjb25zdCBwb3J0YWxNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHBvcnRhbE5vZGUsXG4gICAgICAgICAgICBpc1JlcGFyZW50aW5nUmVmOntcbiAgICAgICAgICAgICAgICBjdXJyZW50OmZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbUlELFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLnNldChpdGVtSUQsIHBvcnRhbE1ldGFkYXRhKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5zZXQoaW5kZXgsIGl0ZW1JRClcblxuICAgICAgICBpZiAoIWlzUHJlbG9hZCkgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICByZXR1cm4gcG9ydGFsTWV0YWRhdGFcblxuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHByZWxvYWRpbmcgbmV3IGl0ZW1cbiAgICBwcml2YXRlIGFzeW5jIHByZWxvYWRJdGVtKFxuICAgICAgICBpbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0LFxuICAgICAgICBzY3JvbGxlcklEXG4gICAgKSB7XG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gdGhpcy5nZXROZXdJdGVtSUQoKVxuXG4gICAgICAgIGxldCByZXR1cm52YWx1ZSwgdXNlcmNvbnRlbnQsIGVycm9yXG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjpudWxsLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzLmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQodXNlcmNvbnRlbnQsIHtzY3JvbGxlclByb3BlcnRpZXN9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcG9ydGFsRGF0YSA9IFxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9ydGFsKGNvbnRlbnQsIGluZGV4LCBpdGVtSUQsIHRydWUpIC8vIHRydWUgPSBpc1ByZWxvYWRcbiAgICAgICAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHRvIHVzZXIgY29udGVudFxuICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLmlzUmVwYXJlbnRpbmdSZWYgPSBwb3J0YWxEYXRhLmlzUmVwYXJlbnRpbmdSZWZcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBlcnJvcilcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IG51bGw7IGxhc3QgaXRlbSBpbiBsaXN0XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAncHJlbG9hZCcsIG5ldyBFcnJvcignZW5kIG9mIGxpc3QnKSlcblxuICAgICAgICAgICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0KGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIGEgcG9ydGFsIGxpc3QgaXRlbVxuICAgIC8vIGFjY2VwdHMgYW4gYXJyYXkgb2YgaW5kZXhlc1xuICAgIGRlbGV0ZVBvcnRhbChpbmRleCwgZGVsZXRlTGlzdENhbGxiYWNrKSB7XG5cbiAgICAgICAgY29uc3QgaW5kZXhBcnJheSA9IFxuICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KGluZGV4KSk/XG4gICAgICAgICAgICAgICAgW2luZGV4XTpcbiAgICAgICAgICAgICAgICBpbmRleFxuXG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICBtZXRhZGF0YU1hcCxcbiAgICAgICAgICAgIHBvcnRhbE1hcCxcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAgXG4gICAgICAgIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCBkZWxldGVMaXN0ID0gW11cbiAgICAgICAgZm9yIChsZXQgaSBvZiBpbmRleEFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpKVxuICAgICAgICAgICAgZGVsZXRlTGlzdC5wdXNoKHtpbmRleDppLGl0ZW1JRH0pXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgcG9ydGFsTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcblxuICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2sgJiYgZGVsZXRlTGlzdENhbGxiYWNrKGRlbGV0ZUxpc3QpXG5cbiAgICB9XG5cbiAgICAvLyBxdWVyeSBleGlzdGVuY2Ugb2YgYSBwb3J0YWwgbGlzdCBpdGVtXG4gICAgaGFzUG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuaGFzKGl0ZW1JRClcblxuICAgIH1cblxuICAgIGdldFBvcnRhbChpdGVtSUQpIHtcblxuICAgICAgICBpZiAodGhpcy5oYXNQb3J0YWwoaXRlbUlEKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFV0aWxpdHkgZnVuY3Rpb24gXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gZ2V0IGEgcmVhY3QtcmV2ZXJzZS1wb3J0YWwgSW5Qb3J0YWwgY29tcG9uZW50LCB3aXRoIGl0cyBtZXRhZGF0YVxuLy8gd2l0aCB1c2VyIGNvbnRlbnQgYW5kIGNvbnRhaW5lclxuY29uc3QgY3JlYXRlUG9ydGFsTm9kZSA9IChpbmRleCwgaXRlbUlELCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgpID0+IHtcblxuICAgIGxldCBwb3J0YWxOb2RlID0gY3JlYXRlSHRtbFBvcnRhbE5vZGUoKVxuXG4gICAgbGV0IGNvbnRhaW5lciA9IHBvcnRhbE5vZGUuZWxlbWVudFxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmluc2V0ID0gJzBweCcgXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSAndW5zZXQnIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAndW5zZXQnXG4gICAgfVxuICAgIGNvbnN0IG1heFdpZHRoID0gXG4gICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gXG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpP1xuICAgICAgICAgICAgKGxheW91dCA9PSAndmFyaWFibGUnKT9cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKyAncHgnOlxuICAgICAgICAgICAgICAgICd1bnNldCdcbiAgICAgICAgICAgIDondW5zZXQnXG4gICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAobGF5b3V0ID09ICd2YXJpYWJsZScpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgKyAncHgnOlxuICAgICAgICAgICAgICAgICd1bnNldCdcbiAgICAgICAgICAgIDondW5zZXQnXG4gICAgY29udGFpbmVyLmRhdGFzZXQudHlwZSA9ICdjb250ZW50ZW52ZWxvcGUnXG4gICAgY29udGFpbmVyLmRhdGFzZXQuaW5kZXggPSBpbmRleFxuICAgIGNvbnRhaW5lci5kYXRhc2V0LmNhY2hlaXRlbWlkID0gaXRlbUlEXG5cbiAgICByZXR1cm4gcG9ydGFsTm9kZVxuXG59ICAgICBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBVdGlsaXR5IGNvbXBvbmVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHBvcnRhbCBsaXN0IGNvbXBvbmVudCBmb3IgcmFwaWQgcmVsaXN0aW5nIG9mIHVwZGF0ZXMsIHVzaW5nIGV4dGVybmFsIGNhbGxiYWNrIGZvciBzZXQgc3RhdGVcbmV4cG9ydCBjb25zdCBQb3J0YWxMaXN0ID0gKHsgY2FjaGVQcm9wcyB9KSA9PiB7XG5cbiAgICBjb25zdCBbcG9ydGFsTGlzdENvdW50ZXIsIHNldFBvcnRhbExpc3RDb3VudGVyXSA9IHVzZVN0YXRlKDApXG5cbiAgICBjb25zdCBjb3VudGVyUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY291bnRlclJlZi5jdXJyZW50ID0gcG9ydGFsTGlzdENvdW50ZXJcblxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuICAgIGNvbnN0IHBvcnRhbEFycmF5UmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gY29uc3QgY2FjaGVkaXZSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNhY2hlUHJvcHMuc2V0TGlzdFN0YXRlID0gKCk9PntcblxuICAgICAgICAgICAgcG9ydGFsQXJyYXlSZWYuY3VycmVudCA9IGNhY2hlUHJvcHMucG9ydGFsTGlzdFxuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRQb3J0YWxMaXN0Q291bnRlcigrK2NvdW50ZXJSZWYuY3VycmVudCkgLy8gZm9yY2UgcmVuZGVyXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKSBcblxuICAgIHJldHVybiBwb3J0YWxBcnJheVJlZi5jdXJyZW50XG5cbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxJdGVtSUQiLCJDYWNoZUhhbmRsZXIiLCJzY3JvbGxlcklEIiwic2V0TGlzdHNpemUiLCJsaXN0c2l6ZVJlZiIsInNldExpc3RTdGF0ZSIsIm1vZGlmaWVkIiwibWV0YWRhdGFNYXAiLCJNYXAiLCJyZXF1ZXN0ZWRTZXQiLCJTZXQiLCJwb3J0YWxNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwicG9ydGFsTGlzdCIsIm5ld2xpc3RzaXplIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsInBvcnRhbEluZGV4TWFwIiwiY2FjaGVQcm9wcyIsIm1hcGtleXNMaXN0IiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJhIiwiYiIsImhpZ2hlc3RpbmRleCIsImF0IiwicGFyZWxpc3QiLCJmaWx0ZXIiLCJpbmRleCIsImRlbGV0ZVBvcnRhbCIsImNsZWFyIiwicmVuZGVyUG9ydGFsTGlzdCIsInZhbHVlcyIsImNyYWRsZUluZGV4TGlzdCIsIm1hcGtleXMiLCJkZWxrZXlzIiwiaW5jbHVkZXMiLCJrZXkiLCJsZW5ndGgiLCJjYWNoZU1heCIsInVuZGVmaW5lZCIsIm1vZGVsTGVuZ3RoIiwibWF4IiwiTWF0aCIsInBvcnRhbEluZGV4TGlzdCIsInNpemUiLCJtYXBrZXlzbGlzdCIsInJlcXVlc3RlZGtleXMiLCJtYXBMZW5ndGgiLCJwYXJlY291bnQiLCJoZWFkaW5kZXgiLCJ0YWlsaW5kZXgiLCJoZWFkcG9zIiwiaW5kZXhPZiIsInRhaWxwb3MiLCJoZWFkcm9vbSIsInRhaWxyb29tIiwicGFyZXJvb20iLCJoZWFkcGFyZWNvdW50IiwiZmxvb3IiLCJ0YWlscGFyZWNvdW50IiwiaGVhZGxpc3QiLCJzbGljZSIsInRhaWxsaXN0IiwiZGVsTGlzdCIsImNyYWRsZUxpc3RMZW5ndGgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJjcmFkbGVQYXJhbWV0ZXJzIiwiZmluYWxDYWxsYmFjayIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsInN0YXRlSGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJnZXRJdGVtIiwibGlzdHNpemUiLCJwcm9taXNlcyIsImNhY2hlU2l6ZSIsIm1pbiIsInByZWxvYWRzaXplIiwiYnJlYWtsb29wIiwibWF4TGlzdHNpemVJbnRlcnJ1cHQiLCJpc01vdW50ZWRSZWYiLCJjYWxsYmFja3MiLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsIml0ZW1FeGNlcHRpb25zQ2FsbGJhY2siLCJoYXMiLCJwcm9taXNlIiwicHJlbG9hZEl0ZW0iLCJwdXNoIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJ0aGVuIiwiY3JhZGxlTWFwIiwic2V0IiwiZ2V0IiwiY2FjaGVsaXN0IiwidmFsdWUiLCJjb21wb25lbnQiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiZnJvbWhpZ2hpbmRleCIsInJhbmdlYWJzb2x1dGVpbmNyZW1lbnQiLCJtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQiLCJ0b2hpZ2hpbmRleCIsInNoaWZ0ZGlyZWN0aW9uIiwib3JkZXJlZGluZGV4bGlzdCIsInRvaW5kZXhwdHIiLCJmaW5kSW5kZXgiLCJ0b2hpZ2hpbmRleHB0ciIsImZyb21pbmRleHB0ciIsImZyb21oaWdoaW5kZXhwdHIiLCJwcm9jZXNzdG9tb3ZlTGlzdCIsInByb2Nlc3N0b21vdmVNYXAiLCJjYXB0dXJlbW92ZWluZGV4IiwiZm9yRWFjaCIsInByb2Nlc3N0b3NoaWZ0TGlzdCIsInJldmVyc2UiLCJwcm9jZXNzZWRzaGlmdExpc3QiLCJwcm9jZXNzc2hpZnRpbmRleCIsIml0ZW1JRCIsIm5ld0luZGV4IiwicHJvY2Vzc2VkbW92ZUxpc3QiLCJwcm9jZXNzbW92ZWluZGV4IiwicHJvY2Vzc2VkSW5kZXhlcyIsImhpZ2hyYW5nZSIsImluY3JlbWVudCIsImhpZ2hyYW5nZWluZGV4IiwiZW1wdHlyZXR1cm4iLCJyYW5nZWNvdW50IiwicmFuZ2VpbmNyZW1lbnQiLCJvcmRlcmVkSW5kZXhMaXN0Iiwic2hyaW5rdG9JbmRleCIsInNocmlua3RvUHRyIiwibG93UHRyIiwicmV2ZXJzZUluZGV4TGlzdCIsImhpZ2hQdHIiLCJpbmRleGVzVG9Qcm9jZXNzTGlzdCIsImluZGV4ZXNUb1JlcGxhY2VMaXN0IiwiaW5kZXhlc1RvUmVtb3ZlTGlzdCIsImluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0IiwiaXRlbXNUb1JlbW92ZUxpc3QiLCJwb3J0YWxIb2xkTGlzdCIsImluZGV4ZXNNb2RpZmllZExpc3QiLCJwcm9jZXNzSW5kZXgiLCJhZGQiLCJnZXROZXdJdGVtSUQiLCJpc1ByZWxvYWQiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJsYXlvdXQiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwib3JpZW50YXRpb24iLCJwb3J0YWxOb2RlIiwiY3JlYXRlUG9ydGFsTm9kZSIsInJlYWN0XzEiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsInBvcnRhbE1ldGFkYXRhIiwiaXNSZXBhcmVudGluZ1JlZiIsInVzZXJjb250ZW50IiwicmV0dXJudmFsdWUiLCJlcnJvciIsImlzVmFsaWRFbGVtZW50IiwiRXJyb3IiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsImhhc093blByb3BlcnR5IiwiY29udGVudCIsImNsb25lRWxlbWVudCIsInBvcnRhbERhdGEiLCJjcmVhdGVQb3J0YWwiLCJpbmRleEFycmF5IiwiaXNBcnJheSIsImRlbGV0ZUxpc3QiLCJpIiwiaGFzUG9ydGFsIiwiZXhwb3J0cyIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzdHlsZSIsIm92ZXJmbG93IiwiaW5zZXQiLCJwb3NpdGlvbiIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwiZGF0YXNldCIsInR5cGUiLCJjYWNoZWl0ZW1pZCIsIlBvcnRhbExpc3QiLCJwb3J0YWxMaXN0Q291bnRlciIsInNldFBvcnRhbExpc3RDb3VudGVyIiwiY291bnRlclJlZiIsInBvcnRhbEFycmF5UmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/cachehandler.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // contentfunctions.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.getGridRowSpans = exports.getGridRowLengths = exports.calcContentShift = exports.getShiftInstruction = exports.getContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    getContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    getShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\")); // ======================[ for setCradleContent ]===========================\n\n\nvar getContentListRequirements = function getContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n      baseRowLength = _ref.baseRowLength,\n      targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n      cradleInheritedProperties = _ref.cradleInheritedProperties,\n      cradleInternalProperties = _ref.cradleInternalProperties;\n  var padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount,\n      listRowcount = cradleInternalProperties.listRowcount,\n      listsize = cradleInternalProperties.listsize,\n      viewportVisibleRowcount = cradleInternalProperties.viewportVisibleRowcount; // align axis reference to first row item\n\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount; // derive target row\n\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  var maxAxisRowOffset = Math.max(0, listRowcount - viewportVisibleRowcount);\n\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  } // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n\n\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount); // trailing edge\n\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount; // ---------------------[ calc cradle content count ]---------------------\n\n  var newCradleContentCount = cradleRowcount * crosscount;\n\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  } // --------------------[ calc css positioning ]-----------------------\n\n\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * baseRowLength + padding - targetAxisViewportPixelOffset; // ----------------------[ return required values ]---------------------\n\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\n\nexports.getContentListRequirements = getContentListRequirements; // ======================[ for updateCradleContent ]===========================\n\n/*\n    - If the top of the cell row moves beyond the viewport boundary, then the\n        content should push the cell boundary up\n    - If the top of the cell row moves into the viewport boundary, then the\n        content should push the cell boundary down\n*/\n// -1 = shift row to head. 1 = shift row to tail. 0 = do not shift a row.\n\nvar getShiftInstruction = function getShiftInstruction(_ref2) {\n  var isBlockScrollingForward = _ref2.isBlockScrollingForward,\n      orientation = _ref2.orientation,\n      triggerlineEntries = _ref2.triggerlineEntries,\n      triggerlineSpan = _ref2.triggerlineSpan,\n      scrollerID = _ref2.scrollerID,\n      oldAxisReferenceIndex = _ref2.oldAxisReferenceIndex,\n      viewportVisibleRowcount = _ref2.viewportVisibleRowcount,\n      crosscount = _ref2.crosscount,\n      listsize = _ref2.listsize,\n      reverseDirection = _ref2.reverseDirection;\n  // console.log('getShiftInstruction: reverseDirection, !isBlockScrollingForward, triggerlineEntries', \n  //     reverseDirection, !isBlockScrollingForward, triggerlineEntries)\n  var direction = isBlockScrollingForward ? 'forward' : 'backward';\n  var entries = triggerlineEntries.filter(function (entry) {\n    // const isIntersecting = entry.isIntersecting\n    var triggerlinename = entry.target.dataset.type;\n    entry.triggerlinename = triggerlinename; // memo for processing and console\n\n    var triggerlinedirection = entry.target.dataset.direction;\n    entry.triggerlinedirection = triggerlinedirection;\n    entry.scrollingforward = isBlockScrollingForward; // memo for console\n\n    var rootpos = orientation == 'vertical' ? entry.rootBounds.y : entry.rootBounds.x;\n    var entrypos = orientation == 'vertical' ? entry.boundingClientRect.y : entry.boundingClientRect.x; // trigger is negative is block is scrolling backward, otherwise positive\n\n    var viewportTriggerOffset = entrypos - rootpos;\n    entry.viewportoffset = viewportTriggerOffset; // console.log('triggerlinename, triggerlinedirection, direction, viewportoffset',\n    //     triggerlinename, triggerlinedirection, direction, viewportoffset)\n    // axis needs to be moved if:\n\n    return (// - axis triggerline goes out of scope, or...\n      direction == 'backward' && (reverseDirection ? triggerlinedirection == 'forward' : triggerlinedirection == 'backward') && viewportTriggerOffset <= 0 || // - head triggerline comes into scope\n      direction == 'forward' && (reverseDirection ? triggerlinedirection == 'backward' : triggerlinedirection == 'forward') && viewportTriggerOffset >= 0\n    );\n  }); // console.log('filtered entries', entries)\n\n  var retval; // the triggerline might have passed through the viewport completely without the\n  // change being triggered, eg. not intersecting, passing through viewport, then\n  //    not intersecting again before being intercepted\n  // in this case we rely on the counterentry to provide information\n\n  if (entries.length == 0) {\n    // short-circuit the evaluation\n    var counterdirection = isBlockScrollingForward ? 'backward' : 'forward';\n    var counterentries = triggerlineEntries.filter(function (entry) {\n      return entry.triggerdirection == counterdirection;\n    });\n\n    if (counterentries.length != 0) {\n      // check for implied trigger - trigger can be bypassed with heavy components\n      var counterentry = counterentries.pop();\n      var countertriggerlinedirection = counterentry.triggerlinedirection;\n      var impliedoffset;\n\n      if (countertriggerlinedirection == 'forward' && (reverseDirection ? direction == 'backward' : direction == 'forward')) {\n        impliedoffset = counterentry.viewportoffsethead + triggerlineSpan;\n\n        if (impliedoffset <= 0) {\n          retval = -1;\n        }\n      } else {\n        impliedoffset = counterentry.viewportoffsethead - triggerlineSpan;\n\n        if (impliedoffset >= 0) {\n          retval = 1;\n        }\n      }\n    }\n\n    retval = 0;\n  } else {\n    // complete the evaluation\n    var entry = entries[0]; // assume one record gets filtered; only paired above on reconnect\n\n    if (direction == 'forward') {\n      retval = 1; // shift row to tail\n    } else {\n      retval = -1; // shift row to head\n    }\n  } // check for last oversize row when scrollbock scrolling toward end\n  // TODO review this logic\n\n\n  if (retval != 0 && !isBlockScrollingForward && viewportVisibleRowcount == 0) {\n    if (listsize - crosscount <= oldAxisReferenceIndex) {\n      retval = 0;\n    }\n  } // console.log('returning shift instruction', retval)\n\n\n  return retval;\n};\n\nexports.getShiftInstruction = getShiftInstruction; // A negative shift instruction is movement into the head, a positive shift is movement into the tail.\n// called only from updateCradleContent\n\nvar calcContentShift = function calcContentShift(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n      cradleInheritedProperties = _ref3.cradleInheritedProperties,\n      cradleInternalProperties = _ref3.cradleInternalProperties,\n      cradleContent = _ref3.cradleContent,\n      cradleElements = _ref3.cradleElements,\n      scrollPos = _ref3.scrollPos,\n      viewportElement = _ref3.viewportElement;\n\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b, _c;\n\n  var isBlockScrollingForward = shiftinstruction > 0;\n  var gap = cradleInheritedProperties.gap,\n      orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      triggerlineOffset = cradleInheritedProperties.triggerlineOffset;\n  var axisElement = cradleElements.axisRef.current,\n      headGridElement = cradleElements.headRef.current,\n      tailGridElement = cradleElements.tailRef.current;\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n      tailcontentlist = cradleContent.tailModelComponents;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      listsize = cradleInternalProperties.listsize,\n      listRowcount = cradleInternalProperties.listRowcount,\n      viewportRowcount = cradleInternalProperties.viewportRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var referenceGridElement = !isBlockScrollingForward ? tailGridElement : headGridElement;\n  var gridRowLengths = (0, exports.getGridRowLengths)(referenceGridElement, orientation, crosscount, gap);\n  if (isBlockScrollingForward) gridRowLengths.reverse();\n  var gridRowSpans = (0, exports.getGridRowSpans)(gridRowLengths);\n  var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n  var firstRowLength = (_a = gridRowLengths[0]) !== null && _a !== void 0 ? _a : baseRowLength; // baseRowLength for start of list\n  // -----------[ 2. calculate axis reference row shift ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n\n  var scrollblockAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockElement = viewportElement.firstChild;\n  var scrollblockOffset = // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft; // currentViewportAxisOffset will be negative (above viewport edge) for scroll block backward \n  //     and positive for scroll block forward\n  // the pixel distance between the viewport frame and the axis, toward the head\n\n  var currentViewportAxisOffset = scrollblockAxisOffset + scrollblockOffset - scrollPos; // the location of the active trigger\n\n  var notionalActiveTriggerPos = !isBlockScrollingForward ? currentViewportAxisOffset + triggerlineOffset : // (firstRowLength === undefined)?\n  //     currentViewportAxisOffset + triggerlineOffset:\n  currentViewportAxisOffset - (firstRowLength - triggerlineOffset);\n  console.log('calcContentShift:!isBlockScrollingForward, currentViewportAxisOffset, notionalActiveTriggerPos', !isBlockScrollingForward, currentViewportAxisOffset, notionalActiveTriggerPos);\n  var spanRowPtr = !isBlockScrollingForward ? gridRowSpans.findIndex(function (span) {\n    return -(span - triggerlineOffset) < notionalActiveTriggerPos;\n  }) : gridRowSpans.findIndex(function (span) {\n    return span - triggerlineOffset > notionalActiveTriggerPos;\n  });\n  var spanPtr, // used to calc spanRowShift below\n  spanAxisPixelShift; // used to calc newAxisPixelOffset below\n\n  if (spanRowPtr == -1) {\n    // overshoot of instantiated rows; continue with virtual rows\n    if (gridRowSpans.length == 0) {\n      spanPtr = -1;\n      spanAxisPixelShift = 0;\n    } else {\n      spanPtr = gridRowSpans.length - 1;\n      var overshootPixelShift = // set base of working total\n      !isBlockScrollingForward ? -(gridRowSpans.at(-1) - triggerlineOffset) : // positive value\n      gridRowSpans.at(-1) - triggerlineOffset; // negative value\n\n      if (!isBlockScrollingForward) {\n        while (overshootPixelShift > notionalActiveTriggerPos) {\n          overshootPixelShift -= baseRowLength;\n          ++spanPtr;\n        }\n\n        spanAxisPixelShift = overshootPixelShift + triggerlineOffset;\n      } else {\n        while (overshootPixelShift < notionalActiveTriggerPos) {\n          overshootPixelShift += baseRowLength;\n          ++spanPtr;\n        }\n\n        spanAxisPixelShift = overshootPixelShift - triggerlineOffset;\n      }\n    }\n  } else {\n    // final values found in instantiated rows\n    spanPtr = spanRowPtr;\n    spanAxisPixelShift = !isBlockScrollingForward ? gridRowSpans[spanPtr] : -gridRowSpans[spanPtr];\n  }\n\n  var spanRowShift = // pick up row shift with or without overshoot\n  !isBlockScrollingForward ? spanPtr + 1 : -(spanPtr + 1); // the following two values, and no other calcs, are carried forward.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n\n  var axisReferenceRowshift = spanRowShift;\n  var axisPixelShift = spanAxisPixelShift; // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n\n  var cradleReferenceRowshift = axisReferenceRowshift;\n  var previousCradleReferenceIndex = ((_b = cradlecontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n  var previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_c = tailcontentlist[0]) === null || _c === void 0 ? void 0 : _c.props.index) || 0;\n  var previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount); // base values\n\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowshift; // sections 6 and 7 deal entirely with row calculations; no pixels\n  // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n\n  var listEndrowOffset = listRowcount - 1;\n\n  if (!isBlockScrollingForward) {\n    // a. if scrolling forward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling forward (toward tail of list), as the cradle last row offset approaches \n    // listrow new cradle offset and cradle row shift have to be adjusted to prevent shortening \n    // of cradle content.\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1);\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    } // case of being in bounds of trailing runway (end of list)\n\n\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n\n    if (tailrowdiff > 0) {\n      newCradleReferenceRowOffset -= tailrowdiff;\n      cradleReferenceRowshift -= tailrowdiff;\n    }\n  } else {\n    // isBlockScrollingForward = scroll backward\n    // c. if scrolling backward (toward head of list), as the cradlerowoffset hits 0, cradle changes have\n    // to be adjusted to prevent shortening of cradle content\n    // d. if scrolling backward near the start of the list, cradle changes have to be adjusted to accomodate\n    // the trailing runway\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    } // case of in bounds of trailing runway (end of list)\n\n\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n    var targetcradleEndrowoffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n\n    var _tailrowdiff = Math.max(0, targetcradleEndrowoffset - computedNextCradleEndrowOffset);\n\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset += _tailrowdiff;\n    }\n  } // ----------------------[ 7. map rows to item references ]----------------------\n\n\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowshift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  } // create head and tail change counts\n\n\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount; // -------------[ 8. calculate new axis pixel position ]------------------\n\n  var newAxisPixelOffset = currentViewportAxisOffset + axisPixelShift; // ---------------------[ 9. return required values ]-------------------\n\n  return {\n    newCradleReferenceIndex: newCradleReferenceIndex,\n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisPixelOffset: newAxisPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\n\nexports.calcContentShift = calcContentShift;\n\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n  var span = 0;\n\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n\n  return rowLengths;\n};\n\nexports.getGridRowLengths = getGridRowLengths;\n\nvar getGridRowSpans = function getGridRowSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n};\n\nexports.getGridRowSpans = getGridRowSpans; // =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n      cradleInternalProperties = _ref4.cradleInternalProperties,\n      cacheHandler = _ref4.cacheHandler,\n      cradleContentCount = _ref4.cradleContentCount,\n      cradleReferenceIndex = _ref4.cradleReferenceIndex,\n      listStartChangeCount = _ref4.listStartChangeCount,\n      listEndChangeCount = _ref4.listEndChangeCount,\n      contentlist = _ref4.workingContentList,\n      instanceIdCounterRef = _ref4.instanceIdCounterRef,\n      styles = _ref4.styles;\n\n  var localContentlist = _toConsumableArray(contentlist);\n\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n      tailContentlist = [];\n  var deletedtailitems = [],\n      deletedheaditems = [];\n\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    for (var newindex = cradleReferenceIndex - listStartChangeCount; newindex < cradleReferenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderContentStyles: styles.placeholdercontent\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    for (var _newindex = lastindexoffset + 1; _newindex < lastindexoffset + 1 + listEndChangeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderContentStyles: styles.placeholdercontent\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\n\nexports.getCellFrameComponentList = getCellFrameComponentList; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n      axisReferenceIndex = _ref5.axisReferenceIndex,\n      layoutHandler = _ref5.layoutHandler;\n\n  var _a;\n\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index;\n  var highindex = offsetindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n\n  if (triggercellIndex !== undefined && offsetindex !== undefined && triggercellIndex != targetTriggercellIndex) {\n    if (triggercellIndex >= offsetindex && triggercellIndex <= highindex) {\n      var _triggercellPtr = triggercellIndex - offsetindex;\n\n      var _triggercellComponent = contentlist[_triggercellPtr];\n\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n\n  var triggercellPtr = targetTriggercellIndex - offsetindex;\n  var triggercellComponent = contentlist[triggercellPtr]; // if !triggercellComponent, is temporarily out of scope; will recycle\n\n  if (triggercellComponent && (triggercellIndex === undefined || triggercellIndex != targetTriggercellIndex || !triggercellComponent.props.isTriggecell)) {\n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    console.log('FAILURE TO REGISTER TRIGGERCELL: \\n', 'triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent?.props.isTriggecell\\n', triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell);\n  }\n\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\n\nexports.allocateContentList = allocateContentList;\n\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\n\nexports.deletePortals = deletePortals; // =====================[ internal, acquire item ]======================\n\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n      cradleInheritedProperties = _ref6.cradleInheritedProperties,\n      cradleInternalProperties = _ref6.cradleInternalProperties,\n      instanceIdCounterRef = _ref6.instanceIdCounterRef,\n      cacheHandler = _ref6.cacheHandler,\n      placeholderFrameStyles = _ref6.placeholderFrameStyles,\n      placeholderContentStyles = _ref6.placeholderContentStyles;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      varHeightMin = cradleInheritedProperties.varHeightMin,\n      varWidthMin = cradleInheritedProperties.varWidthMin,\n      getItem = cradleInheritedProperties.getItem,\n      placeholder = cradleInheritedProperties.placeholder,\n      scrollerID = cradleInheritedProperties.scrollerID,\n      layout = cradleInheritedProperties.layout;\n  var listsize = cradleInternalProperties.listsize; // get new or existing itemID\n\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    varHeightMin: varHeightMin,\n    varWidthMin: varWidthMin,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderContentStyles: placeholderContentStyles\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NvbnRlbnRmdW5jdGlvbnMudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBOztBQUVBLGtHLENBRUE7OztBQUVPLElBQU1BLDBCQUEwQixHQUFHLFNBQTdCQSwwQkFBNkIsT0FXakM7RUFBQSxJQVJEQyx3QkFRQyxRQVJEQSx3QkFRQztFQUFBLElBTkRDLGFBTUMsUUFOREEsYUFNQztFQUFBLElBTERDLDZCQUtDLFFBTERBLDZCQUtDO0VBQUEsSUFIREMseUJBR0MsUUFIREEseUJBR0M7RUFBQSxJQUZEQyx3QkFFQyxRQUZEQSx3QkFFQztFQUVMLElBS0lDLE9BTEosR0FNSUYseUJBTkosQ0FLSUUsT0FMSjtFQVFBLElBRUlDLFVBRkosR0FTSUYsd0JBVEosQ0FFSUUsVUFGSjtFQUFBLElBR0lDLGNBSEosR0FTSUgsd0JBVEosQ0FHSUcsY0FISjtFQUFBLElBSUlDLGNBSkosR0FTSUosd0JBVEosQ0FJSUksY0FKSjtFQUFBLElBS0lDLFlBTEosR0FTSUwsd0JBVEosQ0FLSUssWUFMSjtFQUFBLElBTUlDLFFBTkosR0FTSU4sd0JBVEosQ0FNSU0sUUFOSjtFQUFBLElBT0lDLHVCQVBKLEdBU0lQLHdCQVRKLENBT0lPLHVCQVBKLENBVkssQ0FxQkw7O0VBQ0FYLHdCQUF3QixHQUFHWSxJQUFJLENBQUNDLEdBQUwsQ0FBU2Isd0JBQVQsRUFBa0NVLFFBQVEsR0FBRyxDQUE3QyxDQUEzQjtFQUNBVix3QkFBd0IsSUFBS0Esd0JBQXdCLEdBQUdNLFVBQXhELENBdkJLLENBeUJMOztFQUNBLElBQUlRLG1CQUFtQixHQUFHRixJQUFJLENBQUNHLElBQUwsQ0FBVWYsd0JBQXdCLEdBQUNNLFVBQW5DLENBQTFCO0VBRUEsSUFBTVUsZ0JBQWdCLEdBQUdKLElBQUksQ0FBQ0ssR0FBTCxDQUFTLENBQVQsRUFBV1IsWUFBWSxHQUFHRSx1QkFBMUIsQ0FBekI7O0VBQ0Es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ZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBjb250ZW50aGFuZGxlciBtb2R1bGUuIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgcGVyZm9ybVxuICAgIHRoZSBkZXRhaWxlZCBjYWxjdWxhdGlvbnMgYW5kIHByb2Nlc3NlcyByZXF1aXJlZCBieSB0aGUgY29udGVudGhhbmRsZXIuXG5cbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyBpcyBjYWxsZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyJ3Mgc2V0Q3JhZGxlQ29udGVudCBmdW5jdGlvbi5cblxuICAgIGdldFNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcbiAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIC8vIG9yaWVudGF0aW9uLCBcbiAgICAgICAgLy8gY2VsbEhlaWdodCwgXG4gICAgICAgIC8vIGNlbGxXaWR0aCwgXG4gICAgICAgIC8vIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgdmlld3BvcnRWaXNpYmxlUm93Y291bnQsXG5cbiAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG4gICAgXG4gICAgLy8gYWxpZ24gYXhpcyByZWZlcmVuY2UgdG8gZmlyc3Qgcm93IGl0ZW1cbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbih0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtPSAodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudClcblxuICAgIC8vIGRlcml2ZSB0YXJnZXQgcm93XG4gICAgbGV0IHRhcmdldEF4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBtYXhBeGlzUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCxsaXN0Um93Y291bnQgLSB2aWV3cG9ydFZpc2libGVSb3djb3VudClcbiAgICBpZiAodGFyZ2V0QXhpc1Jvd09mZnNldCA+IG1heEF4aXNSb3dPZmZzZXQpIHtcbiAgICAgICAgdGFyZ2V0QXhpc1Jvd09mZnNldCA9IG1heEF4aXNSb3dPZmZzZXRcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gdGFyZ2V0QXhpc1Jvd09mZnNldCAqIGNyb3NzY291bnRcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjcmFkbGVSZWZlcmVuY2VSb3cgJiBJbmRleCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBsZWFkaW5nIGVkZ2VcbiAgICBsZXQgdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCx0YXJnZXRBeGlzUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQpXG5cbiAgICAvLyB0cmFpbGluZyBlZGdlXG4gICAgbGV0IHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA9IHRhcmdldENyYWRsZVJvd09mZnNldCArIChjcmFkbGVSb3djb3VudCAtIDEpXG5cbiAgICBjb25zdCBsaXN0RW5kUm93T2Zmc2V0ID0gKGxpc3RSb3djb3VudCAtIDEpXG5cbiAgICBpZiAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID4gKGxpc3RFbmRSb3dPZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0IC0gbGlzdEVuZFJvd09mZnNldClcbiAgICAgICAgdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0IC09IGRpZmZcbiAgICAgICAgdGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0IC09IGRpZmZcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCA9IHRhcmdldENyYWRsZVJvd09mZnNldCAqIGNyb3NzY291bnRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjcmFkbGUgY29udGVudCBjb3VudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgbmV3Q3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgaWYgKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA9PSBsaXN0RW5kUm93T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGVuZFJvd1JlbWFpbmRlckNvdW50ID0gbGlzdHNpemUgJSBjcm9zc2NvdW50XG4gICAgICAgIGlmIChlbmRSb3dSZW1haW5kZXJDb3VudCkge1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IChjcm9zc2NvdW50IC0gZW5kUm93UmVtYWluZGVyQ291bnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjc3MgcG9zaXRpb25pbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgKHRhcmdldEF4aXNSb3dPZmZzZXQgKiBiYXNlUm93TGVuZ3RoKSArIHBhZGRpbmcgLSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmV0dXJuIHJlcXVpcmVkIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LCBcbiAgICB9IFxuXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT1bIGZvciB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLypcbiAgICAtIElmIHRoZSB0b3Agb2YgdGhlIGNlbGwgcm93IG1vdmVzIGJleW9uZCB0aGUgdmlld3BvcnQgYm91bmRhcnksIHRoZW4gdGhlIFxuICAgICAgICBjb250ZW50IHNob3VsZCBwdXNoIHRoZSBjZWxsIGJvdW5kYXJ5IHVwXG4gICAgLSBJZiB0aGUgdG9wIG9mIHRoZSBjZWxsIHJvdyBtb3ZlcyBpbnRvIHRoZSB2aWV3cG9ydCBib3VuZGFyeSwgdGhlbiB0aGVcbiAgICAgICAgY29udGVudCBzaG91bGQgcHVzaCB0aGUgY2VsbCBib3VuZGFyeSBkb3duXG4qL1xuLy8gLTEgPSBzaGlmdCByb3cgdG8gaGVhZC4gMSA9IHNoaWZ0IHJvdyB0byB0YWlsLiAwID0gZG8gbm90IHNoaWZ0IGEgcm93LlxuZXhwb3J0IGNvbnN0IGdldFNoaWZ0SW5zdHJ1Y3Rpb24gPSAoe1xuXG4gICAgaXNCbG9ja1Njcm9sbGluZ0ZvcndhcmQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgdHJpZ2dlcmxpbmVFbnRyaWVzLFxuICAgIHRyaWdnZXJsaW5lU3BhbixcbiAgICBzY3JvbGxlcklELCAvLyBmb3IgZGVidWdcbiAgICBcbiAgICAvLyBmb3Igb3ZlcnNpemVkIChvdmVyZmxvdykgY2VsbHNcbiAgICBvbGRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgdmlld3BvcnRWaXNpYmxlUm93Y291bnQsXG4gICAgY3Jvc3Njb3VudCxcbiAgICBsaXN0c2l6ZSxcblxuICAgIC8vIHJldmVyc2VEaXJlY3Rpb24gaXMgdHJ1ZSBpZiB0aGUgdHJpZ2dlcmxpbmVzIGFyZSB3aXRoIHRoZSBmaXJzdCB0YWlsIHJvdyBpbnN0ZWFkIG9mIHRoZVxuICAgIC8vIGxhc3QgaGVhZHJvdy4gVGhhdCBoYXBwZW5zICh3b3JrYXJvdW5kKSB3aGVuIHRoZXJlIGFyZSBubyBoZWFkIHJvd3NcbiAgICByZXZlcnNlRGlyZWN0aW9uLCBcblxufSkgPT4ge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ2dldFNoaWZ0SW5zdHJ1Y3Rpb246IHJldmVyc2VEaXJlY3Rpb24sICFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCwgdHJpZ2dlcmxpbmVFbnRyaWVzJywgXG4gICAgLy8gICAgIHJldmVyc2VEaXJlY3Rpb24sICFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCwgdHJpZ2dlcmxpbmVFbnRyaWVzKVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gXG4gICAgICAgIGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkP1xuICAgICAgICAgICAgJ2ZvcndhcmQnOlxuICAgICAgICAgICAgJ2JhY2t3YXJkJ1xuXG4gICAgY29uc3QgZW50cmllcyA9IHRyaWdnZXJsaW5lRW50cmllcy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgICAvLyBjb25zdCBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgICAgIGNvbnN0IHRyaWdnZXJsaW5lbmFtZSA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGVcbiAgICAgICAgZW50cnkudHJpZ2dlcmxpbmVuYW1lID0gdHJpZ2dlcmxpbmVuYW1lIC8vIG1lbW8gZm9yIHByb2Nlc3NpbmcgYW5kIGNvbnNvbGVcblxuICAgICAgICBjb25zdCB0cmlnZ2VybGluZWRpcmVjdGlvbiA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LmRpcmVjdGlvblxuICAgICAgICBlbnRyeS50cmlnZ2VybGluZWRpcmVjdGlvbiA9IHRyaWdnZXJsaW5lZGlyZWN0aW9uXG5cbiAgICAgICAgZW50cnkuc2Nyb2xsaW5nZm9yd2FyZCA9IGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkIC8vIG1lbW8gZm9yIGNvbnNvbGVcblxuICAgICAgICBjb25zdCByb290cG9zID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZW50cnkucm9vdEJvdW5kcy55OlxuICAgICAgICAgICAgICAgIGVudHJ5LnJvb3RCb3VuZHMueFxuXG4gICAgICAgIGNvbnN0IGVudHJ5cG9zID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0Lnk6XG4gICAgICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnhcblxuICAgICAgICAvLyB0cmlnZ2VyIGlzIG5lZ2F0aXZlIGlzIGJsb2NrIGlzIHNjcm9sbGluZyBiYWNrd2FyZCwgb3RoZXJ3aXNlIHBvc2l0aXZlXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0VHJpZ2dlck9mZnNldCA9IGVudHJ5cG9zIC0gcm9vdHBvc1xuICAgICAgICBlbnRyeS52aWV3cG9ydG9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0cmlnZ2VybGluZW5hbWUsIHRyaWdnZXJsaW5lZGlyZWN0aW9uLCBkaXJlY3Rpb24sIHZpZXdwb3J0b2Zmc2V0JyxcbiAgICAgICAgLy8gICAgIHRyaWdnZXJsaW5lbmFtZSwgdHJpZ2dlcmxpbmVkaXJlY3Rpb24sIGRpcmVjdGlvbiwgdmlld3BvcnRvZmZzZXQpXG5cbiAgICAgICAgLy8gYXhpcyBuZWVkcyB0byBiZSBtb3ZlZCBpZjpcbiAgICAgICAgcmV0dXJuIChcblxuICAgICAgICAgICAgLy8gLSBheGlzIHRyaWdnZXJsaW5lIGdvZXMgb3V0IG9mIHNjb3BlLCBvci4uLlxuICAgICAgICAgICAgZGlyZWN0aW9uID09ICdiYWNrd2FyZCcgJiZcbiAgICAgICAgICAgIChyZXZlcnNlRGlyZWN0aW9uPyh0cmlnZ2VybGluZWRpcmVjdGlvbiA9PSAnZm9yd2FyZCcpOih0cmlnZ2VybGluZWRpcmVjdGlvbiA9PSAnYmFja3dhcmQnKSkgJiZcbiAgICAgICAgICAgIHZpZXdwb3J0VHJpZ2dlck9mZnNldCA8PSAwXG5cbiAgICAgICAgKSB8fCAoXG5cbiAgICAgICAgICAgIC8vIC0gaGVhZCB0cmlnZ2VybGluZSBjb21lcyBpbnRvIHNjb3BlXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT0gJ2ZvcndhcmQnICYmXG4gICAgICAgICAgICAocmV2ZXJzZURpcmVjdGlvbj8odHJpZ2dlcmxpbmVkaXJlY3Rpb24gPT0gJ2JhY2t3YXJkJyk6KHRyaWdnZXJsaW5lZGlyZWN0aW9uID09ICdmb3J3YXJkJykpICYmXG4gICAgICAgICAgICB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgPj0gMFxuXG4gICAgICAgIClcblxuICAgIH0pXG5cbiAgICAvLyBjb25zb2xlLmxvZygnZmlsdGVyZWQgZW50cmllcycsIGVudHJpZXMpXG5cbiAgICBsZXQgcmV0dmFsXG5cbiAgICAvLyB0aGUgdHJpZ2dlcmxpbmUgbWlnaHQgaGF2ZSBwYXNzZWQgdGhyb3VnaCB0aGUgdmlld3BvcnQgY29tcGxldGVseSB3aXRob3V0IHRoZVxuICAgIC8vIGNoYW5nZSBiZWluZyB0cmlnZ2VyZWQsIGVnLiBub3QgaW50ZXJzZWN0aW5nLCBwYXNzaW5nIHRocm91Z2ggdmlld3BvcnQsIHRoZW5cbiAgICAvLyAgICBub3QgaW50ZXJzZWN0aW5nIGFnYWluIGJlZm9yZSBiZWluZyBpbnRlcmNlcHRlZFxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSByZWx5IG9uIHRoZSBjb3VudGVyZW50cnkgdG8gcHJvdmlkZSBpbmZvcm1hdGlvblxuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PSAwKSB7IC8vIHNob3J0LWNpcmN1aXQgdGhlIGV2YWx1YXRpb25cblxuICAgICAgICBjb25zdCBjb3VudGVyZGlyZWN0aW9uID0gXG4gICAgICAgIChpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCk/XG4gICAgICAgICAgICAnYmFja3dhcmQnOiAgICAgICAgXG4gICAgICAgICAgICAnZm9yd2FyZCdcblxuICAgICAgICBjb25zdCBjb3VudGVyZW50cmllcyA9IHRyaWdnZXJsaW5lRW50cmllcy5maWx0ZXIoZW50cnkgPT4gZW50cnkudHJpZ2dlcmRpcmVjdGlvbiA9PSBjb3VudGVyZGlyZWN0aW9uKVxuXG4gICAgICAgIGlmIChjb3VudGVyZW50cmllcy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGltcGxpZWQgdHJpZ2dlciAtIHRyaWdnZXIgY2FuIGJlIGJ5cGFzc2VkIHdpdGggaGVhdnkgY29tcG9uZW50c1xuICAgICAgICAgICAgY29uc3QgY291bnRlcmVudHJ5ID0gIGNvdW50ZXJlbnRyaWVzLnBvcCgpXG4gICAgICAgICAgICBjb25zdCBjb3VudGVydHJpZ2dlcmxpbmVkaXJlY3Rpb24gPSBjb3VudGVyZW50cnkudHJpZ2dlcmxpbmVkaXJlY3Rpb25cblxuICAgICAgICAgICAgbGV0IGltcGxpZWRvZmZzZXRcbiAgICAgICAgICAgIGlmICgoY291bnRlcnRyaWdnZXJsaW5lZGlyZWN0aW9uID09ICdmb3J3YXJkJykgJiZcbiAgICAgICAgICAgICAgICAocmV2ZXJzZURpcmVjdGlvbj8oZGlyZWN0aW9uID09ICdiYWNrd2FyZCcpOihkaXJlY3Rpb24gPT0gJ2ZvcndhcmQnKSkpXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIGltcGxpZWRvZmZzZXQgPSBjb3VudGVyZW50cnkudmlld3BvcnRvZmZzZXRoZWFkICsgdHJpZ2dlcmxpbmVTcGFuXG5cbiAgICAgICAgICAgICAgICBpZiAoaW1wbGllZG9mZnNldCA8PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gLTFcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHsgXG5cbiAgICAgICAgICAgICAgICBpbXBsaWVkb2Zmc2V0ID0gY291bnRlcmVudHJ5LnZpZXdwb3J0b2Zmc2V0aGVhZCAtIHRyaWdnZXJsaW5lU3BhblxuXG4gICAgICAgICAgICAgICAgaWYgKGltcGxpZWRvZmZzZXQgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IDFcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR2YWwgPSAwXG5cbiAgICB9IGVsc2UgeyAvLyBjb21wbGV0ZSB0aGUgZXZhbHVhdGlvblxuXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXSAvLyBhc3N1bWUgb25lIHJlY29yZCBnZXRzIGZpbHRlcmVkOyBvbmx5IHBhaXJlZCBhYm92ZSBvbiByZWNvbm5lY3RcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09ICdmb3J3YXJkJykge1xuXG4gICAgICAgICAgICByZXR2YWwgPSAxIC8vIHNoaWZ0IHJvdyB0byB0YWlsXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dmFsID0gLTEgLy8gc2hpZnQgcm93IHRvIGhlYWRcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbGFzdCBvdmVyc2l6ZSByb3cgd2hlbiBzY3JvbGxib2NrIHNjcm9sbGluZyB0b3dhcmQgZW5kXG4gICAgLy8gVE9ETyByZXZpZXcgdGhpcyBsb2dpY1xuICAgIGlmICgocmV0dmFsICE9MCkgJiYgKCFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCkgJiYgKHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50ID09IDApKSB7XG4gICAgICAgIGlmICgobGlzdHNpemUgLSBjcm9zc2NvdW50KSA8PSBvbGRBeGlzUmVmZXJlbmNlSW5kZXgpIHtcblxuICAgICAgICAgICAgcmV0dmFsID0gMFxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygncmV0dXJuaW5nIHNoaWZ0IGluc3RydWN0aW9uJywgcmV0dmFsKVxuXG4gICAgcmV0dXJuIHJldHZhbFxufVxuXG4vLyBBIG5lZ2F0aXZlIHNoaWZ0IGluc3RydWN0aW9uIGlzIG1vdmVtZW50IGludG8gdGhlIGhlYWQsIGEgcG9zaXRpdmUgc2hpZnQgaXMgbW92ZW1lbnQgaW50byB0aGUgdGFpbC5cbi8vIGNhbGxlZCBvbmx5IGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudFxuZXhwb3J0IGNvbnN0IGNhbGNDb250ZW50U2hpZnQgPSAoe1xuXG4gICAgc2hpZnRpbnN0cnVjdGlvbixcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICBjcmFkbGVDb250ZW50LFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuICAgIHNjcm9sbFBvcywgLy8gb2YgY3JhZGxlIGFnYWluc3Qgdmlld3BvcnQ7IHdoZXJlIHRoZSBjcmFkbGUgbW90aW9uIGludGVyc2VjdHMgdGhlIHZpZXdwb3J0XG4gICAgdmlld3BvcnRFbGVtZW50LFxuXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCA9IChzaGlmdGluc3RydWN0aW9uID4gMClcblxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgZ2FwLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcblxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgaGVhZEdyaWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50LFxuICAgICAgICB0YWlsR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnRcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHM6Y3JhZGxlY29udGVudGxpc3QsIFxuICAgICAgICB0YWlsTW9kZWxDb21wb25lbnRzOnRhaWxjb250ZW50bGlzdCxcblxuICAgIH0gPSBjcmFkbGVDb250ZW50XG5cbiAgICBjb25zdCB7IFxuXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcblxuICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHJlZmVyZW5jZUdyaWRFbGVtZW50ID0gXG4gICAgICAgICFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZD9cbiAgICAgICAgICAgIHRhaWxHcmlkRWxlbWVudDpcbiAgICAgICAgICAgIGhlYWRHcmlkRWxlbWVudFxuXG5cbiAgICBjb25zdCBncmlkUm93TGVuZ3RocyA9IGdldEdyaWRSb3dMZW5ndGhzKHJlZmVyZW5jZUdyaWRFbGVtZW50LCBvcmllbnRhdGlvbiwgY3Jvc3Njb3VudCwgZ2FwKVxuXG4gICAgaWYgKGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkKVxuICAgICAgICBncmlkUm93TGVuZ3Rocy5yZXZlcnNlKClcblxuICAgIGNvbnN0IGdyaWRSb3dTcGFucyA9IGdldEdyaWRSb3dTcGFucyhncmlkUm93TGVuZ3RocylcblxuICAgIGNvbnN0IGJhc2VSb3dMZW5ndGggPVxuICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgIGNlbGxXaWR0aCkgXG4gICAgICAgICsgZ2FwXG5cbiAgICBjb25zdCBmaXJzdFJvd0xlbmd0aCA9IGdyaWRSb3dMZW5ndGhzWzBdID8/IGJhc2VSb3dMZW5ndGggLy8gYmFzZVJvd0xlbmd0aCBmb3Igc3RhcnQgb2YgbGlzdFxuXG4gICAgLy8gLS0tLS0tLS0tLS1bIDIuIGNhbGN1bGF0ZSBheGlzIHJlZmVyZW5jZSByb3cgc2hpZnQgXS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnYXBzIGJleW9uZCByZW5kZXJlZCByb3dzIGNhbiBiZSBjYXVzZWQgYnkgcmFwaWQgc2Nyb2xsaW5nXG5cbiAgICBjb25zdCBzY3JvbGxibG9ja0F4aXNPZmZzZXQgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcbiAgICBjb25zdCBzY3JvbGxibG9ja09mZnNldCA9IC8vIHRvIGNhcHR1cmUgY3VycmVudCB0b3AvbGVmdCBhZGp1c3RtZW50IHRvIHZpZXdwb3J0IGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldFRvcDpcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAvLyBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IHdpbGwgYmUgbmVnYXRpdmUgKGFib3ZlIHZpZXdwb3J0IGVkZ2UpIGZvciBzY3JvbGwgYmxvY2sgYmFja3dhcmQgXG4gICAgLy8gICAgIGFuZCBwb3NpdGl2ZSBmb3Igc2Nyb2xsIGJsb2NrIGZvcndhcmRcbiAgICAvLyB0aGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgZnJhbWUgYW5kIHRoZSBheGlzLCB0b3dhcmQgdGhlIGhlYWRcbiAgICBjb25zdCBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0ID0gXG4gICAgICAgIHNjcm9sbGJsb2NrQXhpc09mZnNldCArIHNjcm9sbGJsb2NrT2Zmc2V0IC0gc2Nyb2xsUG9zXG5cbiAgICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGFjdGl2ZSB0cmlnZ2VyXG4gICAgY29uc3Qgbm90aW9uYWxBY3RpdmVUcmlnZ2VyUG9zID0gXG4gICAgICAgICghaXNCbG9ja1Njcm9sbGluZ0ZvcndhcmQpP1xuICAgICAgICAgICAgY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCArIHRyaWdnZXJsaW5lT2Zmc2V0OlxuICAgICAgICAgICAgLy8gKGZpcnN0Um93TGVuZ3RoID09PSB1bmRlZmluZWQpP1xuICAgICAgICAgICAgLy8gICAgIGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgKyB0cmlnZ2VybGluZU9mZnNldDpcbiAgICAgICAgICAgICAgICBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IC0gKGZpcnN0Um93TGVuZ3RoIC0gdHJpZ2dlcmxpbmVPZmZzZXQpICAgICAgICBcblxuICAgIGNvbnNvbGUubG9nKCdjYWxjQ29udGVudFNoaWZ0OiFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCwgY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCwgbm90aW9uYWxBY3RpdmVUcmlnZ2VyUG9zJyxcbiAgICAgICAgIWlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkLCBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0LCBub3Rpb25hbEFjdGl2ZVRyaWdnZXJQb3MpXG5cbiAgICBjb25zdCBzcGFuUm93UHRyID0gXG4gICAgICAgICghaXNCbG9ja1Njcm9sbGluZ0ZvcndhcmQpP1xuICAgICAgICAgICAgZ3JpZFJvd1NwYW5zLmZpbmRJbmRleCgoc3BhbikgPT4gLShzcGFuIC0gdHJpZ2dlcmxpbmVPZmZzZXQpIDwgbm90aW9uYWxBY3RpdmVUcmlnZ2VyUG9zKTpcbiAgICAgICAgICAgIGdyaWRSb3dTcGFucy5maW5kSW5kZXgoKHNwYW4pID0+IChzcGFuIC0gdHJpZ2dlcmxpbmVPZmZzZXQpID4gbm90aW9uYWxBY3RpdmVUcmlnZ2VyUG9zKVxuXG4gICAgbGV0IHNwYW5QdHIsIC8vIHVzZWQgdG8gY2FsYyBzcGFuUm93U2hpZnQgYmVsb3dcbiAgICAgICAgc3BhbkF4aXNQaXhlbFNoaWZ0IC8vIHVzZWQgdG8gY2FsYyBuZXdBeGlzUGl4ZWxPZmZzZXQgYmVsb3dcbiAgICBpZiAoc3BhblJvd1B0ciA9PSAtMSApIHsgLy8gb3ZlcnNob290IG9mIGluc3RhbnRpYXRlZCByb3dzOyBjb250aW51ZSB3aXRoIHZpcnR1YWwgcm93c1xuICAgICAgICBpZiAoZ3JpZFJvd1NwYW5zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzcGFuUHRyID0gLTFcbiAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IDBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc3BhblB0ciA9IGdyaWRSb3dTcGFucy5sZW5ndGggLSAxXG5cbiAgICAgICAgICAgIGxldCBvdmVyc2hvb3RQaXhlbFNoaWZ0ID0gLy8gc2V0IGJhc2Ugb2Ygd29ya2luZyB0b3RhbFxuICAgICAgICAgICAgICAgICghaXNCbG9ja1Njcm9sbGluZ0ZvcndhcmQpP1xuICAgICAgICAgICAgICAgICAgICAtKGdyaWRSb3dTcGFucy5hdCgtMSkgLSB0cmlnZ2VybGluZU9mZnNldCk6IC8vIHBvc2l0aXZlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGdyaWRSb3dTcGFucy5hdCgtMSkgLSB0cmlnZ2VybGluZU9mZnNldCAvLyBuZWdhdGl2ZSB2YWx1ZVxuXG4gICAgICAgICAgICBpZiAoIWlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkKSB7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3ZlcnNob290UGl4ZWxTaGlmdCA+IG5vdGlvbmFsQWN0aXZlVHJpZ2dlclBvcykge1xuICAgICAgICAgICAgICAgICAgICBvdmVyc2hvb3RQaXhlbFNoaWZ0IC09IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKytzcGFuUHRyXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3BhbkF4aXNQaXhlbFNoaWZ0ID0gb3ZlcnNob290UGl4ZWxTaGlmdCArIHRyaWdnZXJsaW5lT2Zmc2V0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3ZlcnNob290UGl4ZWxTaGlmdCA8IG5vdGlvbmFsQWN0aXZlVHJpZ2dlclBvcykge1xuICAgICAgICAgICAgICAgICAgICBvdmVyc2hvb3RQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKytzcGFuUHRyXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3BhbkF4aXNQaXhlbFNoaWZ0ID0gb3ZlcnNob290UGl4ZWxTaGlmdCAtIHRyaWdnZXJsaW5lT2Zmc2V0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gZmluYWwgdmFsdWVzIGZvdW5kIGluIGluc3RhbnRpYXRlZCByb3dzXG5cbiAgICAgICAgc3BhblB0ciA9IHNwYW5Sb3dQdHJcbiAgICAgICAgc3BhbkF4aXNQaXhlbFNoaWZ0ID0gXG4gICAgICAgICAgICAoIWlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkKT9cbiAgICAgICAgICAgICAgICBncmlkUm93U3BhbnNbc3BhblB0cl06XG4gICAgICAgICAgICAgICAgLWdyaWRSb3dTcGFuc1tzcGFuUHRyXVxuXG4gICAgfVxuXG4gICAgY29uc3Qgc3BhblJvd1NoaWZ0ID0gLy8gcGljayB1cCByb3cgc2hpZnQgd2l0aCBvciB3aXRob3V0IG92ZXJzaG9vdFxuICAgICAgICAoIWlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkKT9cbiAgICAgICAgICAgIHNwYW5QdHIgKyAxOlxuICAgICAgICAgICAgLShzcGFuUHRyICsgMSlcblxuICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIHZhbHVlcywgYW5kIG5vIG90aGVyIGNhbGNzLCBhcmUgY2FycmllZCBmb3J3YXJkLlxuICAgIC8vIGZvciBheGlzUmVmZXJlbmNlUm93c2hpZnQ6XG4gICAgLy8gbmVnYXRpdmUgZm9yIG1vdmluZyByb3dzIG91dCBvZiBoZWFkIGludG8gdGFpbDtcbiAgICAvLyBwb3NpdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIHRhaWwgaW50byBoZWFkXG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvd3NoaWZ0ID0gc3BhblJvd1NoaWZ0XG4gICAgY29uc3QgYXhpc1BpeGVsU2hpZnQgPSBzcGFuQXhpc1BpeGVsU2hpZnQgXG5cbiAgICAvLyAtLS0tLS0tLS0tLS1bIDUuIGNhbGMgbmV3IGNyYWRsZSBhbmQgYXhpcyByZWZlcmVuY2Ugcm93IG9mZnNldHMgXS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJhc2UgdmFsdWUgZm9yIGNyYWRsZSByZWZlcmVuY2Ugc2hpZnQ7IG1heSBjaGFuZ2UgaWYgYmV5b25kIGxpc3QgYm91bmRzXG4gICAgbGV0IGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ID0gYXhpc1JlZmVyZW5jZVJvd3NoaWZ0XG5cbiAgICBjb25zdCBwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKGNyYWRsZWNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4ID0gKHRhaWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcbiAgICBjb25zdCBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIC8vIGJhc2UgdmFsdWVzXG4gICAgbGV0IG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnRcbiAgICBsZXQgbmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCA9IHByZXZpb3VzQXhpc1Jvd09mZnNldCArIGF4aXNSZWZlcmVuY2VSb3dzaGlmdFxuXG4gICAgLy8gc2VjdGlvbnMgNiBhbmQgNyBkZWFsIGVudGlyZWx5IHdpdGggcm93IGNhbGN1bGF0aW9uczsgbm8gcGl4ZWxzXG4gICAgLy8gLS0tLS0tLS1bIDYuIGFkanVzdCBjcmFkbGUgY29udGVudHMgZm9yIHN0YXJ0IGFuZCBlbmQgb2YgbGlzdCBdLS0tLS0tLVxuICAgIC8vIC4uLnRvIG1haW50YWluIGNvbnN0YW50IG51bWJlciBvZiBjcmFkbGUgcm93c1xuXG4gICAgY29uc3QgbGlzdEVuZHJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuXG4gICAgaWYgKCFpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCkge1xuXG4gICAgICAgIC8vIGEuIGlmIHNjcm9sbGluZyBmb3J3YXJkIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBsaXN0LCBuZXcgY3JhZGxlIHJvdyBvZmZzZXQgYW5kXG4gICAgICAgIC8vIGNyYWRsZSByb3cgc2hpZnQgY291bnQgaGFzIHRvIGJlIGFkanVzdGVkIHRvIGFjY29tbW9kYXRlIHRoZSBsZWFkaW5nIHJ1bndheVxuICAgICAgICAvLyBiLiBpZiBzY3JvbGxpbmcgZm9yd2FyZCAodG93YXJkIHRhaWwgb2YgbGlzdCksIGFzIHRoZSBjcmFkbGUgbGFzdCByb3cgb2Zmc2V0IGFwcHJvYWNoZXMgXG4gICAgICAgIC8vIGxpc3Ryb3cgbmV3IGNyYWRsZSBvZmZzZXQgYW5kIGNyYWRsZSByb3cgc2hpZnQgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBwcmV2ZW50IHNob3J0ZW5pbmcgXG4gICAgICAgIC8vIG9mIGNyYWRsZSBjb250ZW50LlxuXG4gICAgICAgIGNvbnN0IHRhcmdldENyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IFxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgKG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgLSBydW53YXlSb3djb3VudCAtIDEpKVxuXG4gICAgICAgIGNvbnN0IGhlYWRyb3dEaWZmID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IC0gdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0XG4gICAgICAgIGlmIChoZWFkcm93RGlmZiA+IDApIHtcblxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IC09IGhlYWRyb3dEaWZmXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBoZWFkcm93RGlmZlxuXG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FzZSBvZiBiZWluZyBpbiBib3VuZHMgb2YgdHJhaWxpbmcgcnVud2F5IChlbmQgb2YgbGlzdClcbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGxpc3RFbmRyb3dPZmZzZXQpXG4gICAgICAgIGlmICh0YWlscm93ZGlmZiA+IDApIHtcblxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSB0YWlscm93ZGlmZlxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkID0gc2Nyb2xsIGJhY2t3YXJkXG5cbiAgICAgICAgLy8gYy4gaWYgc2Nyb2xsaW5nIGJhY2t3YXJkICh0b3dhcmQgaGVhZCBvZiBsaXN0KSwgYXMgdGhlIGNyYWRsZXJvd29mZnNldCBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmVcbiAgICAgICAgLy8gdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG4gICAgICAgIC8vIGQuIGlmIHNjcm9sbGluZyBiYWNrd2FyZCBuZWFyIHRoZSBzdGFydCBvZiB0aGUgbGlzdCwgY3JhZGxlIGNoYW5nZXMgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBhY2NvbW9kYXRlXG4gICAgICAgIC8vIHRoZSB0cmFpbGluZyBydW53YXlcblxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IDBcblxuICAgICAgICB9XG4gICAgICAgIC8vIGNhc2Ugb2YgaW4gYm91bmRzIG9mIHRyYWlsaW5nIHJ1bndheSAoZW5kIG9mIGxpc3QpXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldCA9IFxuICAgICAgICAgICAgKHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0xKSArIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0KVxuICAgICAgICBjb25zdCB0YXJnZXRjcmFkbGVFbmRyb3dvZmZzZXQgPSBNYXRoLm1pbihsaXN0RW5kcm93T2Zmc2V0LCBcbiAgICAgICAgICAgIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpKSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLCB0YXJnZXRjcmFkbGVFbmRyb3dvZmZzZXQgLSBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCArPSB0YWlscm93ZGlmZlxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICs9IHRhaWxyb3dkaWZmXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNy4gbWFwIHJvd3MgdG8gaXRlbSByZWZlcmVuY2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50KVxuICAgIGNvbnN0IGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCA9IChjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAqIGNyb3NzY291bnQpXG5cbiAgICBjb25zdCBuZXdBeGlzUmVmZXJlbmNlSW5kZXggPSBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIGNvbnN0IGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQgPSBheGlzUmVmZXJlbmNlUm93c2hpZnQgKiBjcm9zc2NvdW50XG5cbiAgICBsZXQgbmV3Q3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50IC8vIGJhc2UgY291bnRcbiAgICBjb25zdCBpbmNsdWRlc0xhc3RSb3cgPSAoKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCArIGNyYWRsZVJvd2NvdW50KSA+PSBsaXN0Um93Y291bnQpXG4gICAgaWYgKGluY2x1ZGVzTGFzdFJvdykge1xuICAgICAgICBjb25zdCBwYXJ0aWFsc3BhY2VzID0gbGlzdHNpemUgJSBjcm9zc2NvdW50XG4gICAgICAgIGNvbnN0IGl0ZW1zU2hvcnRmYWxsID0gXG4gICAgICAgICAgICAocGFydGlhbHNwYWNlcyA9PSAwKT9cbiAgICAgICAgICAgICAgICAwOlxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQgLSBwYXJ0aWFsc3BhY2VzXG4gICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSBpdGVtc1Nob3J0ZmFsbFxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBoZWFkIGFuZCB0YWlsIGNoYW5nZSBjb3VudHNcbiAgICBjb25zdCBjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudCA9IGNyYWRsZWNvbnRlbnRsaXN0Lmxlbmd0aCAtIG5ld0NyYWRsZUNvbnRlbnRDb3VudFxuXG4gICAgY29uc3QgbGlzdFN0YXJ0Q2hhbmdlQ291bnQgPSAtKGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdClcbiAgICBjb25zdCBsaXN0RW5kQ2hhbmdlQ291bnQgPSAtbGlzdFN0YXJ0Q2hhbmdlQ291bnQgLSAoY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tWyA4LiBjYWxjdWxhdGUgbmV3IGF4aXMgcGl4ZWwgcG9zaXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgbmV3QXhpc1BpeGVsT2Zmc2V0ID0gY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCArIGF4aXNQaXhlbFNoaWZ0XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDkuIHJldHVybiByZXF1aXJlZCB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0LCBcbiAgICAgICAgbmV3QXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCwgXG4gICAgICAgIG5ld0F4aXNQaXhlbE9mZnNldCwgXG4gICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4gICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudFxuICAgIH1cblxufVxuXG5leHBvcnQgY29uc3QgZ2V0R3JpZFJvd0xlbmd0aHMgPSAoZ3JpZCwgb3JpZW50YXRpb24sIGNyb3NzY291bnQsIGdhcCkgPT4ge1xuXG4gICAgY29uc3Qgcm93TGVuZ3RocyA9IFtdXG4gICAgY29uc3QgZWxlbWVudExpc3QgPSBncmlkLmNoaWxkTm9kZXNcblxuICAgIGxldCBlbGVtZW50UHRyID0gMFxuICAgIGxldCBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cbiAgICBsZXQgc3BhbiA9IDBcblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJvd2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoKSBcbiAgICAgICAgICAgICsgZ2FwXG4gICAgICAgIHJvd0xlbmd0aHMucHVzaChyb3dsZW5ndGgpXG4gICAgICAgIGVsZW1lbnRQdHIgKz0gY3Jvc3Njb3VudFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cbiAgICB9XG5cbiAgICByZXR1cm4gcm93TGVuZ3Roc1xufVxuXG5leHBvcnQgY29uc3QgZ2V0R3JpZFJvd1NwYW5zID0gKHJvd0xlbmd0aHMpID0+IHtcblxuICAgIGNvbnN0IHJvd1NwYW5zID0gW11cbiAgICBsZXQgc3BhbiA9IDBcbiAgICByb3dMZW5ndGhzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHNwYW4gKz0gdmFsdWVcbiAgICAgICAgcm93U3BhbnMucHVzaChzcGFuKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcm93U3BhbnNcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBzaGFyZWQgYnkgYm90aCBzZXRDcmFkbGVDb250ZW50IGFuZCB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB1cGRhdGUgY29udGVudFxuLy8gYWRkcyBpdGVtc2hlbGxzIGF0IGVuZCBvZiBjb250ZW50bGlzdCBhY2NvcmRpbmcgdG8gaGVhZGluZGV4Y291bnQgYW5kIHRhaWxpbmRlc2NvdW50LFxuLy8gb3IgaWYgaW5kZXhjb3VudCB2YWx1ZXMgYXJlIDwwIHJlbW92ZXMgdGhlbS5cbmV4cG9ydCBjb25zdCBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0ID0gKHsgXG5cbiAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCwgXG4gICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCwgXG4gICAgICAgIHdvcmtpbmdDb250ZW50TGlzdDpjb250ZW50bGlzdCxcbiAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgIHN0eWxlcyxcbiAgICB9KSA9PiB7XG5cbiAgICBjb25zdCBsb2NhbENvbnRlbnRsaXN0ID0gWy4uLmNvbnRlbnRsaXN0XVxuICAgIGNvbnN0IGxhc3RpbmRleG9mZnNldCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4ICsgbG9jYWxDb250ZW50bGlzdC5sZW5ndGggLSAxXG5cbiAgICBjb25zdCBoZWFkQ29udGVudGxpc3QgPSBbXSwgdGFpbENvbnRlbnRsaXN0ID0gW11cblxuICAgIGxldCBkZWxldGVkdGFpbGl0ZW1zID0gW10sIGRlbGV0ZWRoZWFkaXRlbXMgPSBbXVxuXG4gICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50ID49IDApIHsgLy8gYWNxdWlyZSBuZXcgaXRlbXNcblxuICAgICAgICBmb3IgKGxldCBuZXdpbmRleCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4IC0gbGlzdFN0YXJ0Q2hhbmdlQ291bnQ7IG5ld2luZGV4IDwgKGNyYWRsZVJlZmVyZW5jZUluZGV4KTsgbmV3aW5kZXgrKykge1xuXG4gICAgICAgICAgICBoZWFkQ29udGVudGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVDZWxsRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Om5ld2luZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNvbnRlbnRTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbGV0ZWRoZWFkaXRlbXMgPSBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSggMCwgLWxpc3RTdGFydENoYW5nZUNvdW50IClcblxuICAgIH1cblxuICAgIGlmIChsaXN0RW5kQ2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gbGFzdGluZGV4b2Zmc2V0ICsgMTsgbmV3aW5kZXggPCAobGFzdGluZGV4b2Zmc2V0ICsgMSArIGxpc3RFbmRDaGFuZ2VDb3VudCk7IG5ld2luZGV4KyspIHtcblxuICAgICAgICAgICAgdGFpbENvbnRlbnRsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2VsbEZyYW1lKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDpuZXdpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkdGFpbGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UobGlzdEVuZENoYW5nZUNvdW50LC1saXN0RW5kQ2hhbmdlQ291bnQpXG5cbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkSXRlbXMgPSBbLi4uZGVsZXRlZGhlYWRpdGVtcywuLi5kZWxldGVkdGFpbGl0ZW1zXVxuXG4gICAgY29uc3QgY29tcG9uZW50TGlzdCA9IFsuLi5oZWFkQ29udGVudGxpc3QsLi4ubG9jYWxDb250ZW50bGlzdCwuLi50YWlsQ29udGVudGxpc3RdXG5cbiAgICByZXR1cm4gW2NvbXBvbmVudExpc3QsZGVsZXRlZEl0ZW1zXVxuXG59XG5cbi8vIGJ1dHRlcmZseSBtb2RlbC4gTGVhZGluZyAoaGVhZCkgYWxsIG9yIHBhcnRpYWxseSBoaWRkZW47IHRhaWwsIHZpc2libGUgcGx1cyBmb2xsb3dpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZmlyc3QgdGFpbCBpdGVtXG4gICAgICAgIGxheW91dEhhbmRsZXIsXG5cbiAgICB9XG4pID0+IHtcblxuICAgIGNvbnN0IHsgdHJpZ2dlcmNlbGxJbmRleCB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgY29uc3Qgb2Zmc2V0aW5kZXggPSBjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXhcbiAgICBjb25zdCBoaWdoaW5kZXggPSBvZmZzZXRpbmRleCArIGNvbnRlbnRsaXN0Lmxlbmd0aFxuXG4gICAgY29uc3QgaGVhZGl0ZW1jb3VudCA9IChheGlzUmVmZXJlbmNlSW5kZXggLSBvZmZzZXRpbmRleClcblxuICAgIGNvbnN0IHRhcmdldFRyaWdnZXJjZWxsSW5kZXggPSBcbiAgICAgICAgKGhlYWRpdGVtY291bnQgPT0gMCk/XG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXg6XG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXggLSAxXG5cbiAgICBsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwgPSBcbiAgICAgICAgKGhlYWRpdGVtY291bnQgPT0gMCk/XG4gICAgICAgICAgICB0cnVlOlxuICAgICAgICAgICAgZmFsc2VcblxuICAgIGlmICgodHJpZ2dlcmNlbGxJbmRleCAhPT0gdW5kZWZpbmVkKSAmJiAob2Zmc2V0aW5kZXggIT09IHVuZGVmaW5lZCkgJiYgXG4gICAgICAgKHRyaWdnZXJjZWxsSW5kZXggIT0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCkpIHtcbiAgICAgICAgaWYgKCh0cmlnZ2VyY2VsbEluZGV4ID49IG9mZnNldGluZGV4KSAmJiAodHJpZ2dlcmNlbGxJbmRleCA8PSBoaWdoaW5kZXgpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbFB0ciA9IHRyaWdnZXJjZWxsSW5kZXggLSBvZmZzZXRpbmRleFxuICAgICAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGxDb21wb25lbnQgPSBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyY2VsbENvbXBvbmVudCkgeyAvLyBvdGhlcndpc2UgaGFzIGJlZW4gYXN5bmNocm9ub3VzbHkgY2xlYXJlZFxuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXSA9IFJlYWN0LmNsb25lRWxlbWVudCh0cmlnZ2VyY2VsbENvbXBvbmVudCwge2lzVHJpZ2dlcmNlbGw6ZmFsc2V9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxQdHIgPSB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4IC0gb2Zmc2V0aW5kZXhcbiAgICBjb25zdCB0cmlnZ2VyY2VsbENvbXBvbmVudCA9IGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXVxuICAgIC8vIGlmICF0cmlnZ2VyY2VsbENvbXBvbmVudCwgaXMgdGVtcG9yYXJpbHkgb3V0IG9mIHNjb3BlOyB3aWxsIHJlY3ljbGVcbiAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQgJiYgKCh0cmlnZ2VyY2VsbEluZGV4ID09PSB1bmRlZmluZWQpIHx8IFxuICAgICAgICAodHJpZ2dlcmNlbGxJbmRleCAhPSB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4ICB8fFxuICAgICAgICAhdHJpZ2dlcmNlbGxDb21wb25lbnQucHJvcHMuaXNUcmlnZ2VjZWxsKSkpIHsgICAgXG4gICAgICAgIGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXSA9IFJlYWN0LmNsb25lRWxlbWVudCh0cmlnZ2VyY2VsbENvbXBvbmVudCwge2lzVHJpZ2dlcmNlbGw6dHJ1ZX0pXG4gICAgICAgIGxheW91dEhhbmRsZXIudHJpZ2dlcmNlbGxJbmRleCA9IHRhcmdldFRyaWdnZXJjZWxsSW5kZXhcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnRkFJTFVSRSBUTyBSRUdJU1RFUiBUUklHR0VSQ0VMTDogXFxuJyxcbiAgICAgICAgICAgICd0cmlnZ2VyY2VsbENvbXBvbmVudCwgdHJpZ2dlcmNlbGxJbmRleCwgdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCwgdHJpZ2dlcmNlbGxDb21wb25lbnQ/LnByb3BzLmlzVHJpZ2dlY2VsbFxcbicsIFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsSW5kZXgsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXgsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGwpXG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGxpc3QgPSBjb250ZW50bGlzdC5zbGljZSgwLGhlYWRpdGVtY291bnQpXG4gICAgY29uc3QgdGFpbGxpc3QgPSBjb250ZW50bGlzdC5zbGljZShoZWFkaXRlbWNvdW50KVxuXG4gICAgcmV0dXJuIFsgaGVhZGxpc3QsIHRhaWxsaXN0IF1cblxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUG9ydGFscyA9IChjYWNoZUhhbmRsZXIsIGRlbGV0ZUxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaykgPT4ge1xuXG4gICAgY29uc3QgZGxpc3QgPSBkZWxldGVMaXN0Lm1hcCgoaXRlbSk9PntcblxuICAgICAgICByZXR1cm4gaXRlbS5wcm9wcy5pbmRleFxuICAgICAgICBcbiAgICB9KVxuXG4gICAgY2FjaGVIYW5kbGVyLmRlbGV0ZVBvcnRhbChkbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIGludGVybmFsLCBhY3F1aXJlIGl0ZW0gXT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY3JlYXRlQ2VsbEZyYW1lID0gKHtcbiAgICBpbmRleCwgXG4gICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgY2FjaGVIYW5kbGVyLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzLFxufSkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlSUQgPSBpbnN0YW5jZUlkQ291bnRlclJlZi5jdXJyZW50KytcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICB2YXJIZWlnaHRNaW4sXG4gICAgICAgIHZhcldpZHRoTWluLFxuICAgICAgICBnZXRJdGVtLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgbGF5b3V0LCBcblxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCB7IGxpc3RzaXplIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgIC8vIGdldCBuZXcgb3IgZXhpc3RpbmcgaXRlbUlEXG4gICAgY29uc3QgaXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld09yRXhpc3RpbmdJdGVtSUQoaW5kZXgpXG5cbiAgICByZXR1cm4gPENlbGxGcmFtZSBcbiAgICAgICAga2V5ID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgIHZhckhlaWdodE1pbiA9IHsgdmFySGVpZ2h0TWluIH1cbiAgICAgICAgdmFyV2lkdGhNaW4gPSB7IHZhcldpZHRoTWluIH1cbiAgICAgICAgbGF5b3V0ID0geyBsYXlvdXQgfVxuICAgICAgICBpbmRleCA9IHsgaW5kZXggfVxuICAgICAgICBnZXRJdGVtID0geyBnZXRJdGVtIH1cbiAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgcGxhY2Vob2xkZXIgPSB7IHBsYWNlaG9sZGVyIH1cbiAgICAgICAgaXRlbUlEID0geyBpdGVtSUQgfVxuICAgICAgICBpbnN0YW5jZUlEID0geyBpbnN0YW5jZUlEIH1cbiAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgIGlzVHJpZ2dlcmNlbGwgPSB7IGZhbHNlIH1cbiAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyA9IHsgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyB9XG4gICAgICAgIHBsYWNlaG9sZGVyQ29udGVudFN0eWxlcyA9IHsgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzIH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwicGFkZGluZyIsImNyb3NzY291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwibGlzdFJvd2NvdW50IiwibGlzdHNpemUiLCJ2aWV3cG9ydFZpc2libGVSb3djb3VudCIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRBeGlzUm93T2Zmc2V0IiwiY2VpbCIsIm1heEF4aXNSb3dPZmZzZXQiLCJtYXgiLCJ0YXJnZXRDcmFkbGVSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQiLCJsaXN0RW5kUm93T2Zmc2V0IiwiZGlmZiIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwibmV3Q3JhZGxlQ29udGVudENvdW50IiwiZW5kUm93UmVtYWluZGVyQ291bnQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJleHBvcnRzIiwiZ2V0U2hpZnRJbnN0cnVjdGlvbiIsImlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkIiwib3JpZW50YXRpb24iLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJ0cmlnZ2VybGluZVNwYW4iLCJzY3JvbGxlcklEIiwib2xkQXhpc1JlZmVyZW5jZUluZGV4IiwicmV2ZXJzZURpcmVjdGlvbiIsImRpcmVjdGlvbiIsImVudHJpZXMiLCJmaWx0ZXIiLCJ0cmlnZ2VybGluZW5hbWUiLCJlbnRyeSIsInRhcmdldCIsImRhdGFzZXQiLCJ0eXBlIiwidHJpZ2dlcmxpbmVkaXJlY3Rpb24iLCJzY3JvbGxpbmdmb3J3YXJkIiwicm9vdHBvcyIsInJvb3RCb3VuZHMiLCJ5IiwieCIsImVudHJ5cG9zIiwiYm91bmRpbmdDbGllbnRSZWN0Iiwidmlld3BvcnRUcmlnZ2VyT2Zmc2V0Iiwidmlld3BvcnRvZmZzZXQiLCJyZXR2YWwiLCJsZW5ndGgiLCJjb3VudGVyZGlyZWN0aW9uIiwiY291bnRlcmVudHJpZXMiLCJ0cmlnZ2VyZGlyZWN0aW9uIiwiY291bnRlcmVudHJ5IiwicG9wIiwiY291bnRlcnRyaWdnZXJsaW5lZGlyZWN0aW9uIiwiaW1wbGllZG9mZnNldCIsInZpZXdwb3J0b2Zmc2V0aGVhZCIsImNhbGNDb250ZW50U2hpZnQiLCJzaGlmdGluc3RydWN0aW9uIiwiY3JhZGxlQ29udGVudCIsImNyYWRsZUVsZW1lbnRzIiwic2Nyb2xsUG9zIiwidmlld3BvcnRFbGVtZW50IiwiZ2FwIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiY3VycmVudCIsImhlYWRHcmlkRWxlbWVudCIsImhlYWRSZWYiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwiY3JhZGxlY29udGVudGxpc3QiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJ0YWlsY29udGVudGxpc3QiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwidmlld3BvcnRSb3djb3VudCIsInJlZmVyZW5jZUdyaWRFbGVtZW50IiwiZ3JpZFJvd0xlbmd0aHMiLCJyZXZlcnNlIiwiZ3JpZFJvd1NwYW5zIiwiZmlyc3RSb3dMZW5ndGgiLCJfYSIsInNjcm9sbGJsb2NrQXhpc09mZnNldCIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0Iiwibm90aW9uYWxBY3RpdmVUcmlnZ2VyUG9zIiwiY29uc29sZSIsImxvZyIsInNwYW5Sb3dQdHIiLCJmaW5kSW5kZXgiLCJzcGFuIiwic3BhblB0ciIsInNwYW5BeGlzUGl4ZWxTaGlmdCIsIm92ZXJzaG9vdFBpeGVsU2hpZnQiLCJhdCIsInNwYW5Sb3dTaGlmdCIsImF4aXNSZWZlcmVuY2VSb3dzaGlmdCIsImF4aXNQaXhlbFNoaWZ0IiwiY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2IiLCJwcm9wcyIsImluZGV4IiwicHJldmlvdXNDcmFkbGVSb3dPZmZzZXQiLCJwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCIsIl9jIiwicHJldmlvdXNBeGlzUm93T2Zmc2V0IiwibmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IiwibmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCIsImxpc3RFbmRyb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQiLCJoZWFkcm93RGlmZiIsInRhcmdldENyYWRsZUVuZHJvd09mZnNldCIsInRhaWxyb3dkaWZmIiwiY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0IiwidGFyZ2V0Y3JhZGxlRW5kcm93b2Zmc2V0IiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzUmVmZXJlbmNlSXRlbVNoaWZ0IiwiaW5jbHVkZXNMYXN0Um93IiwicGFydGlhbHNwYWNlcyIsIml0ZW1zU2hvcnRmYWxsIiwiY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsIm5ld0F4aXNQaXhlbE9mZnNldCIsImdldEdyaWRSb3dMZW5ndGhzIiwiZ3JpZCIsInJvd0xlbmd0aHMiLCJlbGVtZW50TGlzdCIsImNoaWxkTm9kZXMiLCJlbGVtZW50UHRyIiwiZWxlbWVudCIsInJvd2xlbmd0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwicHVzaCIsImdldEdyaWRSb3dTcGFucyIsInJvd1NwYW5zIiwiZm9yRWFjaCIsInZhbHVlIiwiZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCIsImNhY2hlSGFuZGxlciIsImNyYWRsZUNvbnRlbnRDb3VudCIsImNyYWRsZVJlZmVyZW5jZUluZGV4IiwiY29udGVudGxpc3QiLCJ3b3JraW5nQ29udGVudExpc3QiLCJpbnN0YW5jZUlkQ291bnRlclJlZiIsInN0eWxlcyIsImxvY2FsQ29udGVudGxpc3QiLCJsYXN0aW5kZXhvZmZzZXQiLCJoZWFkQ29udGVudGxpc3QiLCJ0YWlsQ29udGVudGxpc3QiLCJkZWxldGVkdGFpbGl0ZW1zIiwiZGVsZXRlZGhlYWRpdGVtcyIsIm5ld2luZGV4IiwiY3JlYXRlQ2VsbEZyYW1lIiwicGxhY2Vob2xkZXJGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyZnJhbWUiLCJwbGFjZWhvbGRlckNvbnRlbnRTdHlsZXMiLCJwbGFjZWhvbGRlcmNvbnRlbnQiLCJzcGxpY2UiLCJkZWxldGVkSXRlbXMiLCJjb21wb25lbnRMaXN0IiwiYWxsb2NhdGVDb250ZW50TGlzdCIsImF4aXNSZWZlcmVuY2VJbmRleCIsImxheW91dEhhbmRsZXIiLCJ0cmlnZ2VyY2VsbEluZGV4Iiwib2Zmc2V0aW5kZXgiLCJoaWdoaW5kZXgiLCJoZWFkaXRlbWNvdW50IiwidGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCIsInRyaWdnZXJjZWxsSXNJblRhaWwiLCJ1bmRlZmluZWQiLCJ0cmlnZ2VyY2VsbFB0ciIsInRyaWdnZXJjZWxsQ29tcG9uZW50IiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImlzVHJpZ2dlcmNlbGwiLCJpc1RyaWdnZWNlbGwiLCJoZWFkbGlzdCIsInNsaWNlIiwidGFpbGxpc3QiLCJkZWxldGVQb3J0YWxzIiwiZGVsZXRlTGlzdCIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRsaXN0IiwibWFwIiwiaXRlbSIsImRlbGV0ZVBvcnRhbCIsImluc3RhbmNlSUQiLCJ2YXJIZWlnaHRNaW4iLCJ2YXJXaWR0aE1pbiIsImdldEl0ZW0iLCJwbGFjZWhvbGRlciIsImxheW91dCIsIml0ZW1JRCIsImdldE5ld09yRXhpc3RpbmdJdGVtSUQiLCJDZWxsRnJhbWVfMSIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // contenthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module supports the setup and rollover of content in the Cradle. There are two key functions\n    in this module: setCradleContent, and updateCradleContent. There are also a few functions which\n    support synchronization of Cradle content with cache content (see internal and external services\n    below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    forward, content is removed from the Cradle head and added to the Cradle tail. When scrolling\n    backward, the reverse occurs.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n*/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ \"./src/cradle/contentfunctions.tsx\");\n\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n\n    _classCallCheck(this, ContentHandler);\n\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    }; // Two main public methods - setCradleContent and updateCradleContent\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      // console.log('setCradleContent: cradleState',cradleState)\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current;\n      var cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n          layoutHandler = cradleHandlers.layoutHandler,\n          serviceHandler = cradleHandlers.serviceHandler,\n          interruptHandler = cradleHandlers.interruptHandler,\n          scrollHandler = cradleHandlers.scrollHandler; // the triggerlines and cradle grids will be moved, so disconnect them from their observers.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n      // console.log('disconnecting triggers in setCradleContent')\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.cradleIntersect.observer.disconnect();\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n          gap = cradleInheritedProperties.gap,\n          padding = cradleInheritedProperties.padding,\n          cellHeight = cradleInheritedProperties.cellHeight,\n          cellWidth = cradleInheritedProperties.cellWidth,\n          cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID,\n          styles = cradleInheritedProperties.styles,\n          layout = cradleInheritedProperties.layout;\n      var crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize;\n      var workingRequestAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingRequestAxisReferenceIndex -= workingRequestAxisReferenceIndex % crosscount; // console.log('workingRequestAxisReferenceIndex', workingRequestAxisReferenceIndex)\n      // reposition at row boundary\n\n      if (['firstrender', 'firstrenderfromcache', 'finishreposition', 'reconfigure', 'scrollto'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingRequestAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content; // ----------------------[ 2. get content requirements ]----------------------\n\n      var baseRowLength = orientation == 'vertical' ? cellHeight + gap : cellWidth + gap; // console.log('setCradleContent: workingRequestAxisReferenceIndex',workingRequestAxisReferenceIndex)\n      // note that targetAxisReferenceIndex replaces requestedAxisReferenceIndex here\n\n      var _ref = (0, contentfunctions_1.getContentListRequirements)({\n        // pixel\n        baseRowLength: baseRowLength,\n        targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n        // index\n        targetAxisReferenceIndex: workingRequestAxisReferenceIndex,\n        // resources\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties\n      }),\n          targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n          targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n          cradleContentCount = _ref.newCradleContentCount,\n          scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset; //         console.log(`setCradleContent: \n      // targetCradleReferenceIndex, \n      // targetAxisReferenceIndex,\n      // cradleContentCount, \n      // scrollblockViewportPixelOffset`,\n      //             targetCradleReferenceIndex, \n      //             targetAxisReferenceIndex,\n      //             cradleContentCount, \n      //             scrollblockViewportPixelOffset\n      //         )\n      // reset scrollblockOffset\n\n\n      var scrollblockElement = viewportElement.firstChild;\n\n      if (orientation == 'vertical') {\n        scrollblockElement.style.top = 'unset';\n      } else {\n        scrollblockElement.style.left = 'unset';\n      } // console.log('setCradleContent: scrollblockOffset', scrollblockOffset)\n\n\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // + scrollblockOffset// semantics\n      // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n        cacheHandler: cacheHandler,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContentCount: cradleContentCount,\n        cradleReferenceIndex: targetCradleReferenceIndex,\n        listStartChangeCount: 0,\n        listEndChangeCount: cradleContentCount,\n        workingContentList: workingContentList,\n        instanceIdCounterRef: _this.instanceIdCounterRef,\n        styles: styles\n      }),\n          _ref3 = _slicedToArray(_ref2, 2),\n          newcontentlist = _ref3[0],\n          deleteditems = _ref3[1];\n\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: newcontentlist,\n        axisReferenceIndex: targetAxisReferenceIndex,\n        layoutHandler: layoutHandler\n      }),\n          _ref5 = _slicedToArray(_ref4, 2),\n          headcontentlist = _ref5[0],\n          tailcontentlist = _ref5[1]; // console.log('setCradleContent: allocateContentList - headcontentlist, tailcontentlist', headcontentlist, tailcontentlist)\n\n\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex; // console.log('setCradleContent: setting targetAxisViewportPixelOffset', axisViewportPixelOffset)\n\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, 'setCradleContent', cstate);\n      } //  ----------------------[ 4. set CSS ]-----------------------\n      // const adjustedScrollblockViewportPixelOffset = scrollblockViewportPixelOffset + scrollblockOffset\n\n\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset; // - scrollblockOffset\n      // avoid bogus call to updateCradleContent\n\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset); // - scrollblockOffset) \n\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset; // console.log('setCradleContent: AxisScrollblockPixelOffset, scrollblockViewportPixelOffset, \\\n      //     axisViewportPixelOffset',AxisScrollblockPixelOffset, scrollblockViewportPixelOffset,\n      //     axisViewportPixelOffset)\n\n      if (orientation == 'vertical') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontentlist.length ? gap + 'px' : 0;\n      } else {\n        // orientation = 'horizontal'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = left + 'px';\n        headElement.style.paddingRight = headcontentlist.length ? gap + 'px' : 0;\n      }\n    }; // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element's scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler\n\n\n    this.updateCradleContent = function (isBlockScrollingForward, triggerlineEntries) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'notifications';\n\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a, _b; // handler support\n\n\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n          cacheHandler = _this$cradleParameter.cacheHandler,\n          scrollHandler = _this$cradleParameter.scrollHandler,\n          layoutHandler = _this$cradleParameter.layoutHandler,\n          stateHandler = _this$cradleParameter.stateHandler,\n          interruptHandler = _this$cradleParameter.interruptHandler,\n          serviceHandler = _this$cradleParameter.serviceHandler; // scroll data\n\n      var scrollData = scrollHandler.scrollData;\n      var scrollPos = scrollData.currentupdate; // first abandon option/3; nothing to do\n\n      if (scrollPos < 0) {\n        // for Safari, FF elastic bounce at top of scroll\n        return;\n      } // cradle scaffold and user cells\n\n\n      var cradleElements = layoutHandler.elements;\n      var cradleContent = _this.content,\n          modelcontentlist = cradleContent.cradleModelComponents || [],\n          oldAxisReferenceIndex = ((_a = cradleContent.tailModelComponents[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      var oldCradleReferenceIndex = ((_b = modelcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n          cache = cradleInheritedProperties.cache,\n          styles = cradleInheritedProperties.styles;\n      var viewportVisibleRowcount = cradleInternalProperties.viewportVisibleRowcount,\n          crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize; // --------------------[ 2. get shift instruction ]-----------------------\n      // -1 is move a row up to the head, +1 is move a row down to the tail, 0 is no shift\n\n      var shiftinstruction = (0, contentfunctions_1.getShiftInstruction)({\n        scrollerID: cradleInheritedProperties.scrollerID,\n        isBlockScrollingForward: isBlockScrollingForward,\n        orientation: orientation,\n        triggerlineEntries: triggerlineEntries,\n        triggerlineSpan: layoutHandler.triggerlineSpan,\n        // for oversized (overflow) cells\n        oldAxisReferenceIndex: oldAxisReferenceIndex,\n        viewportVisibleRowcount: viewportVisibleRowcount,\n        crosscount: crosscount,\n        listsize: listsize,\n        reverseDirection: layoutHandler.triggercellIsInTail\n      }); // second abandon option/3; nothing to do\n\n      if (shiftinstruction == 0) {\n        return;\n      } // console.log('updateCradleContent: shiftinstruction',shiftinstruction)\n      // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      // const cradleInheritedProperties = this.cradleParameters.cradleInheritedPropertiesRef.current\n\n\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n\n      var _ref6 = (0, contentfunctions_1.calcContentShift)({\n        shiftinstruction: shiftinstruction,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContent: cradleContent,\n        cradleElements: cradleElements,\n        scrollPos: scrollPos,\n        viewportElement: viewportElement\n      }),\n          newCradleReferenceIndex = _ref6.newCradleReferenceIndex,\n          cradleItemShift = _ref6.cradleReferenceItemShift,\n          axisReferenceIndex = _ref6.newAxisReferenceIndex,\n          axisItemShift = _ref6.axisReferenceItemShift,\n          cradleContentCount = _ref6.newCradleContentCount,\n          listStartChangeCount = _ref6.listStartChangeCount,\n          listEndChangeCount = _ref6.listEndChangeCount,\n          axisPixelOffset = _ref6.newAxisPixelOffset; // console.log('updateCradleContent: axisItemShift, cradleItemShift',axisItemShift, cradleItemShift)\n      // console.log('updateCradleContent: axisPixelOffset',axisPixelOffset)\n      // third abandon option/3; nothing to do\n\n\n      if (axisItemShift == 0 && cradleItemShift == 0) {\n        // can happen first row\n        return;\n      } // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n      // console.log('disconnecting triggers in updateCradleContent')\n\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true; // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect modified content\n\n      var updatedContentList,\n          deletedContentItems = [];\n\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref7 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles\n        });\n\n        var _ref8 = _slicedToArray(_ref7, 2);\n\n        updatedContentList = _ref8[0];\n        deletedContentItems = _ref8[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n\n      if (deletedContentItems.length && cache == 'cradle') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cradle', deleteList);\n          };\n        }\n\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      } // ----------------------------------[ 5. allocate cradle content ]--------------------------\n\n\n      var _ref9 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: updatedContentList,\n        axisReferenceIndex: axisReferenceIndex,\n        layoutHandler: layoutHandler\n      }),\n          _ref10 = _slicedToArray(_ref9, 2),\n          headcontent = _ref10[0],\n          tailcontent = _ref10[1];\n\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, 'updateCradleContent', cstate);\n      } // -------------------------------[ 6. set css changes ]-------------------------\n\n\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n\n      if (cradleInheritedProperties.orientation == 'vertical') {\n        var topPos = scrollPos + axisPixelOffset;\n        axisElement.style.top = topPos + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      } else {\n        // 'horizontal'\n        var leftPos = scrollPos + axisPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = leftPos + 'px';\n        headElement.style.paddingRight = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      }\n\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex; // console.log('updateCradleContent setting targetAxisViewportPixelOffset', axisPixelOffset)\n\n      cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset; // interruptHandler.triggerlinesIntersect.connectElements()\n      // interruptHandler.signals.pauseTriggerlinesObserver = false\n\n      stateHandler.setCradleState('renderupdatedcontent');\n    }; // ==============================[ RESPOSITION VARIABLE CONTENT ]==========================\n    // all DOM elements should be rendered at this point\n    // sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n\n\n    this.adjustScrollblockForVariability = function () {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'standard';\n      // ----------------------[ setup ]------------------------\n      var cradleParameters = _this.cradleParameters,\n          cradleHandlers = cradleParameters.handlersRef.current,\n          ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n          cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n          cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var layoutHandler = cradleHandlers.layoutHandler,\n          cradleElements = layoutHandler.elements,\n          cradlePositionData = layoutHandler.cradlePositionData;\n      var headGrid = cradleElements.headRef.current,\n          tailGrid = cradleElements.tailRef.current,\n          axisElement = cradleElements.axisRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current,\n          scrollblockElement = viewportElement.firstChild;\n      var orientation = cradleInheritedProperties.orientation,\n          gap = cradleInheritedProperties.gap,\n          padding = cradleInheritedProperties.padding,\n          cellHeight = cradleInheritedProperties.cellHeight,\n          cellWidth = cradleInheritedProperties.cellWidth;\n      var crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize;\n      var scrollblockOffset = // from previous adjustments\n      orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft; // console.log('--\x3e> adjustScrollblockForVariability: source, scrollblockOffset, cradlePositionData',\n      //     source, scrollblockOffset, cradlePositionData)\n\n      var axisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n\n      if (source == 'afterscroll') {\n        // rebalance scrollblockOffset and blockScrollPos\n        if (orientation == 'vertical') {\n          scrollblockElement.style.top = 'unset';\n        } else {\n          scrollblockElement.style.left = 'unset';\n        }\n\n        var _blockScrollPos = cradlePositionData.blockScrollPos -= scrollblockOffset;\n\n        viewportElement[cradlePositionData.blockScrollProperty] = _blockScrollPos;\n        return;\n      }\n\n      if (axisReferenceIndex == 0) {\n        // trigger scrollblockOffset reset; change blockScrollPos\n        var _blockScrollPos2 = padding - cradlePositionData.targetAxisViewportPixelOffset;\n\n        cradlePositionData.blockScrollPos = _blockScrollPos2;\n\n        if (orientation == 'vertical') {\n          scrollblockElement.style.top = 'unset';\n        } else {\n          scrollblockElement.style.left = 'unset';\n        }\n\n        scrollblockOffset = 0;\n      }\n\n      var axisViewportOffset = cradlePositionData.targetAxisViewportPixelOffset,\n          blockScrollPos = cradlePositionData.blockScrollPos; // ------------------------[ calculations ]------------------------\n\n      var headRowCount = Math.ceil(headGrid.childNodes.length / crosscount);\n      var tailRowCount = Math.ceil(tailGrid.childNodes.length / crosscount);\n      var baseCellLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      var baseHeadLength = headRowCount * baseCellLength + padding;\n      var baseTailLength = tailRowCount * baseCellLength + padding - gap;\n      var measuredHeadLength, measuredTailLength;\n\n      if (orientation == 'vertical') {\n        measuredHeadLength = headGrid.offsetHeight;\n        measuredTailLength = tailGrid.offsetHeight;\n      } else {\n        measuredHeadLength = headGrid.offsetWidth;\n        measuredTailLength = tailGrid.offsetWidth;\n      }\n\n      var headDelta = baseHeadLength - measuredHeadLength;\n      var tailDelta = baseTailLength - measuredTailLength;\n      var listrowcount = Math.ceil(listsize / crosscount);\n      var baseblocklength = listrowcount * baseCellLength - gap // no gap below last row\n      + padding * 2; // leading and trailing padding\n      // calculate axis offset delta\n\n      var axisReferenceRow = Math.ceil(axisReferenceIndex / crosscount);\n      var axisScrollblockOffset = blockScrollPos + axisViewportOffset + headDelta + scrollblockOffset;\n      var baseAxisScrollblockOffset = axisReferenceRow * baseCellLength + padding;\n      var axisScrollblockOffsetDelta = baseAxisScrollblockOffset - axisScrollblockOffset;\n      var scrollblockHeight = baseblocklength - headDelta - tailDelta - axisScrollblockOffsetDelta; // -----------------------[ application ]-------------------------\n\n      if (axisReferenceIndex == 0) {\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n      }\n\n      if (orientation == 'vertical') {\n        // the scrollblock top is moved to compensate for the headDelta\n        scrollblockElement.style.top = -headDelta - scrollblockOffset + 'px'; // the axis is moved in the opposite direction to maintain viewport position\n\n        axisElement.style.top = axisScrollblockOffset + 'px'; // the height is adjusted by both deltas, as it controls the scroll length\n\n        scrollblockElement.style.height = scrollblockHeight + 'px';\n      } else {\n        scrollblockElement.style.left = -headDelta - scrollblockOffset + 'px';\n        axisElement.style.left = axisScrollblockOffset + 'px';\n        scrollblockElement.style.width = scrollblockHeight + 'px';\n      }\n    }; // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n\n\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n          cacheMax = _this$cradleParameter2.cacheMax,\n          MAX_CACHE_OVER_RUN = _this$cradleParameter2.MAX_CACHE_OVER_RUN;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      var modelComponentList = _this.content.cradleModelComponents;\n\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID;\n\n      if (cache == 'keepload') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n            serviceHandler = cradleHandlers.serviceHandler;\n\n        var modelIndexList = _this.getModelIndexList();\n\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cacheMax', deleteList);\n          };\n        }\n\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.cacheProps.modified = true;\n          cacheHandler.renderPortalList();\n        }\n      }\n    }; // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n\n\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n\n    this.cradleParameters = cradleParameters;\n  } // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n\n\n  _createClass(ContentHandler, [{\n    key: \"getModelIndexList\",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    } // called from service handler's remapIndexes, as last step\n\n  }, {\n    key: \"reconcileCellFrames\",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n\n      function processComponent(component, i, array) {\n        var _component$props = component.props,\n            index = _component$props.index,\n            itemID = _component$props.itemID;\n\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n\n          if (newItemID != itemID) {\n            // defensive; shouldn't happen\n            array[i] = react_1[\"default\"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n\n      cradleModelComponents.forEach(processComponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports moveIndex and insertRemoveIndex\n\n  }, {\n    key: \"changeCradleItemIDs\",\n    value: function changeCradleItemIDs(changeList) {\n      if (changeList.length == 0) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var _cacheHandler$cachePr = cacheHandler.cacheProps,\n          indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap,\n          metadataMap = _cacheHandler$cachePr.metadataMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = changeList.indexOf(index);\n\n        if (ptr != -1) {\n          var itemID = indexToItemIDMap.get(index);\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: itemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports insertRemoveIndex\n\n  }, {\n    key: \"createNewItemIDs\",\n    value: function createNewItemIDs(newList) {\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = newList.indexOf(index);\n\n        if (ptr != -1) {\n          var newItemID = cacheHandler.getNewItemID();\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: newItemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n  }]);\n\n  return ContentHandler;\n}();\n\nexports[\"default\"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NvbnRlbnRoYW5kbGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O0FBRUE7O0lBWXFCQSxjO0VBRWxCLHdCQUFZQyxnQkFBWixFQUE0QjtJQUFBOztJQUFBOztJQU1yQixlQUFVO01BRWRDLHFCQUFxQixFQUFFLElBRlQ7TUFHZEMsbUJBQW1CLEVBQUUsSUFIUDtNQUlkQyxtQkFBbUIsRUFBRSxJQUpQO01BS2Q7TUFDQUMscUJBQXFCLEVBQUUsRUFOVDtNQU9kQyxxQkFBcUIsRUFBRTtJQVBULENBQVY7SUFhRSw0QkFBdUI7TUFFNUJDLE9BQU8sRUFBQztJQUZvQixDQUF2QixDQW5CbUIsQ0F3QjNCO0lBRUE7SUFFQTtJQUNBOztJQUVPLHdCQUFtQixVQUFFQyxXQUFGLEVBQWtCO01BRXhDO01BRUE7TUFFQSxJQUFRUCxnQkFBUixHQUE2QixLQUE3QixDQUFRQSxnQkFBUjtNQUNBLElBQU1RLHlCQUF5QixHQUFHUixnQkFBZ0IsQ0FBQ1MsNEJBQWpCLENBQThDSCxPQUFoRjtNQUNBLElBQU1JLHlCQUF5QixHQUFHVixnQkFBZ0IsQ0FBQ1csNEJBQWpCLENBQThDTCxPQUFoRjtNQUNBLElBQU1NLHdCQUF3QixHQUFHWixnQkFBZ0IsQ0FBQ2EsMkJBQWpCLENBQTZDUCxPQUE5RTtNQUNBLElBQU1RLGNBQWMsR0FBR2QsZ0JBQWdCLENBQUNlLFdBQWpCLENBQTZCVCxPQUFwRDtNQUVBLElBRUlVLFlBRkosR0FRSUYsY0FSSixDQUVJRSxZQUZKO01BQUEsSUFHSUMsYUFISixHQVFJSCxjQVJKLENBR0lHLGFBSEo7TUFBQSxJQUlJQyxjQUpKLEdBUUlKLGNBUkosQ0FJSUksY0FKSjtNQUFBLElBS0lDLGdCQUxKLEdBUUlMLGNBUkosQ0FLSUssZ0JBTEo7TUFBQSxJQU1JQyxhQU5KLEdBUUlOLGNBUkosQ0FNSU0sYUFOSixDQVp3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O01BQ0EsSUFBUWYscUJBQVIsR0FBa0MsS0FBSytDLE9BQXZDLENBQVEvQyxxQkFBUjs7TUFFQSxTQUFTd0wsZ0JBQVQsQ0FBMEJkLFNBQTFCLEVBQXFDQyxDQUFyQyxFQUF3Q0MsS0FBeEMsRUFBNkM7UUFFekMsSUFBTTNFLEtBQUssR0FBR3lFLFNBQVMsQ0FBQzFFLEtBQVYsQ0FBZ0JDLEtBQTlCO1FBQ0EsSUFBTXdGLEdBQUcsR0FBR0UsT0FBTyxDQUFDRCxPQUFSLENBQWdCekYsS0FBaEIsQ0FBWjs7UUFFQSxJQUFJd0YsR0FBRyxJQUFJLENBQUMsQ0FBWixFQUFlO1VBRVgsSUFBTVgsU0FBUyxHQUFHL0osWUFBWSxDQUFDa0ssWUFBYixFQUFsQjtVQUNBTCxLQUFLLENBQUNELENBQUQsQ0FBTCxHQUFXTyxtQkFBTUMsWUFBTixDQUFtQlQsU0FBbkIsRUFBOEI7WUFBQ0csTUFBTSxFQUFDQztVQUFSLENBQTlCLENBQVg7UUFFSDtNQUVKOztNQUVEOUsscUJBQXFCLENBQUNvTCxPQUF0QixDQUE4QkksZ0JBQTlCO01BRUEsS0FBS3pJLE9BQUwsQ0FBYTlDLG1CQUFiLEdBQW1DRCxxQkFBcUIsQ0FBQ3FMLEtBQXRCLENBQTRCLENBQTVCLEVBQThCLEtBQUt0SSxPQUFMLENBQWE5QyxtQkFBYixDQUFpQ21GLE1BQS9ELENBQW5DO01BQ0EsS0FBS3JDLE9BQUwsQ0FBYTdDLG1CQUFiLEdBQW1DRixxQkFBcUIsQ0FBQ3FMLEtBQXRCLENBQTRCLEtBQUt0SSxPQUFMLENBQWE5QyxtQkFBYixDQUFpQ21GLE1BQTdELENBQW5DO0lBRUg7Ozs7OztBQTUwQkx3RyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50aGFuZGxlci50c3g/YTg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb250ZW50aGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgc3VwcG9ydHMgdGhlIHNldHVwIGFuZCByb2xsb3ZlciBvZiBjb250ZW50IGluIHRoZSBDcmFkbGUuIFRoZXJlIGFyZSB0d28ga2V5IGZ1bmN0aW9uc1xuICAgIGluIHRoaXMgbW9kdWxlOiBzZXRDcmFkbGVDb250ZW50LCBhbmQgdXBkYXRlQ3JhZGxlQ29udGVudC4gVGhlcmUgYXJlIGFsc28gYSBmZXcgZnVuY3Rpb25zIHdoaWNoIFxuICAgIHN1cHBvcnQgc3luY2hyb25pemF0aW9uIG9mIENyYWRsZSBjb250ZW50IHdpdGggY2FjaGUgY29udGVudCAoc2VlIGludGVybmFsIGFuZCBleHRlcm5hbCBzZXJ2aWNlc1xuICAgIGJlbG93KS5cblxuICAgIHNldENyYWRsZUNvbnRlbnQgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gQ3JhZGxlIChpbiB0aGUgc3RhdGUgbWFuYWdlciksIGFuZCBpbnN0YW50aWF0ZXMgbmV3IENyYWRsZVxuICAgIGNvbnRlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIHNjcm9sbGVyIHNldHVwLCBvciBjaGFuZ2VzIHRvIGl0cyBjb25maWd1cmF0aW9uLiBzZXRDcmFkbGVDb250ZW50XG4gICAgY3JlYXRlcyBhIGxpc3Qgb2YgQ3JhZGxlIGNvbnRlbnQgQ2VsbEZyYW1lcywgYW5kIGFsbG9jYXRlcyB0aG9zZSB0byB0aGUgdHdvIENyYWRsZSBncmlkcy4gVGhpcyBcbiAgICBwcm9jZXNzIG9jY3VycyBpbiByZXNwb25zZSB0byBtYW55IHN0YXRlIGNoYW5nZXMsIHN1Y2ggYXMgZmluaXNocmVwb3NpdGlvbiwgcGl2b3QsIGEgaG9zdCBzY3JvbGx0b1xuICAgIHJlcXVlc3QsIGFuZCBtb3JlLlxuXG4gICAgdXBkYXRlQ3JhZGxlQ29udGVudCByb2xscyBvdmVyIHRoZSBDcmFkbGUgY29udGVudCBpbiByZXNwb25zZSB0byB1c2VyIHNjcm9sbGluZy4gV2hlbiBzY3JvbGxpbmcgXG4gICAgZm9yd2FyZCwgY29udGVudCBpcyByZW1vdmVkIGZyb20gdGhlIENyYWRsZSBoZWFkIGFuZCBhZGRlZCB0byB0aGUgQ3JhZGxlIHRhaWwuIFdoZW4gc2Nyb2xsaW5nIFxuICAgIGJhY2t3YXJkLCB0aGUgcmV2ZXJzZSBvY2N1cnMuXG5cbiAgICBUaGUgQ3JhZGxlICh0aHJvdWdoIHRoZSBjb250ZW50ZnVuY3Rpb25zIG1vZHVsZSkgZGVsZWdhdGVzIGZldGNoaW5nIGNvbnRlbnQgaXRlbXMgdG8gdGhlIENlbGxGcmFtZS5cblxuICAgIFRoaXMgbW9kdWxlIGlzIHN1cHBvcnRlZCBwcmltYXJpbHkgYnkgdGhlIGNvbnRlbnRmdW5jdGlvbnMgbW9kdWxlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBcbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyxcbiAgICBnZXRTaGlmdEluc3RydWN0aW9uLFxuICAgIGNhbGNDb250ZW50U2hpZnQsXG4gICAgYWxsb2NhdGVDb250ZW50TGlzdCxcbiAgICBkZWxldGVQb3J0YWxzLFxuICAgIGdldENlbGxGcmFtZUNvbXBvbmVudExpc3QsIFxuICAgIGdldEdyaWRSb3dMZW5ndGhzLFxuICAgIGdldEdyaWRSb3dTcGFucyxcblxufSBmcm9tICcuL2NvbnRlbnRmdW5jdGlvbnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRIYW5kbGVyIHtcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgIH1cblxuICAgcHVibGljIGNvbnRlbnQgPSB7XG5cbiAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIGhlYWRNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICB0YWlsTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgLy8gdGhlIGZvbGxvd2luZyB0d28gb25seSB1c2VkIGluIGNyYWRsZSBmb3IgcmVuZGVyXG4gICAgICBoZWFkRGlzcGxheUNvbXBvbmVudHM6IFtdLFxuICAgICAgdGFpbERpc3BsYXlDb21wb25lbnRzOiBbXSxcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHJpdmF0ZSBpbnN0YW5jZUlkQ291bnRlclJlZiA9IHtcblxuICAgICAgIGN1cnJlbnQ6MFxuXG4gICAgfVxuICAgIC8vIFR3byBtYWluIHB1YmxpYyBtZXRob2RzIC0gc2V0Q3JhZGxlQ29udGVudCBhbmQgdXBkYXRlQ3JhZGxlQ29udGVudFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFVCBDT05URU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHJlc2V0IHRoZSBjcmFkbGUgd2l0aCBuZXcgY29udGVudCwgaW5jbHVkaW5nIGFsbG9jYXRpb24gYmV0d2VlbiBoZWFkIGFuZCB0YWlsIHBhcnRzIG9mIHRoZSBjcmFkbGVcbiAgICAvLyAtIGNhbGxlZCBvbmx5IGZyb20gdGhlIENyYWRsZSBzdGF0ZSBoYW5kbGVyXG5cbiAgICBwdWJsaWMgc2V0Q3JhZGxlQ29udGVudCA9ICggY3JhZGxlU3RhdGUgKSA9PiB7IC8vIGNyYWRsZVN0YXRlIGluZmx1ZW5jZXMgc29tZSBiZWhhdmlvdXJcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBjcmFkbGVTdGF0ZScsY3JhZGxlU3RhdGUpXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQYXJhbWV0ZXJzIH0gPSB0aGlzXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVIYW5kbGVycyA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG5cbiAgICAgICAgfSA9IGNyYWRsZUhhbmRsZXJzXG5cbiAgICAgICAgLy8gdGhlIHRyaWdnZXJsaW5lcyBhbmQgY3JhZGxlIGdyaWRzIHdpbGwgYmUgbW92ZWQsIHNvIGRpc2Nvbm5lY3QgdGhlbSBmcm9tIHRoZWlyIG9ic2VydmVycy5cbiAgICAgICAgLy8gdGhleSBhcmUgcmVjb25uZWN0ZWQgd2l0aCAncmVuZGVydXBkYXRlZGNvbnRlbnQnIHN0YXRlIGluIGNyYWRsZS50c3hcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RpbmcgdHJpZ2dlcnMgaW4gc2V0Q3JhZGxlQ29udGVudCcpXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCA9IGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgbGV0IHsgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3Qge2Nyb3NzY291bnQsIGxpc3RzaXplfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGxldCB3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG4gICAgICAgIHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4IC09ICh3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnQpXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3dvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4Jywgd29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBhdCByb3cgYm91bmRhcnlcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcicsIFxuICAgICAgICAgICAgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJyxcbiAgICAgICAgICAgICdmaW5pc2hyZXBvc2l0aW9uJywgXG4gICAgICAgICAgICAncmVjb25maWd1cmUnLCBcbiAgICAgICAgICAgICdzY3JvbGx0bycsIFxuICAgICAgICBdLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgICh3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKT9cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzpcbiAgICAgICAgICAgICAgICAgICAgZ2FwIC8vIGRlZmF1bHRcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NvbnRlbnRMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGdldCBjb250ZW50IHJlcXVpcmVtZW50cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGJhc2VSb3dMZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAoY2VsbEhlaWdodCArIGdhcCk6XG4gICAgICAgICAgICAgICAgKGNlbGxXaWR0aCArIGdhcClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Q3JhZGxlQ29udGVudDogd29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXgnLHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggcmVwbGFjZXMgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGhlcmVcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgICAgICAvLyBjb3VudHNcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudDpjcmFkbGVDb250ZW50Q291bnQsIFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgc2Nyb2xsUG9zIGJ5IHBpeGVsc1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0OnNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICB9ID0gZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMoe1xuXG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxcbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6d29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgICAgICAgICAgfSlcblxuLy8gICAgICAgICBjb25zb2xlLmxvZyhgc2V0Q3JhZGxlQ29udGVudDogXG4vLyB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4vLyB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4vLyBjcmFkbGVDb250ZW50Q291bnQsIFxuLy8gc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0YCxcbi8vICAgICAgICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbi8vICAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcbi8vICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCwgXG4vLyAgICAgICAgICAgICBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbi8vICAgICAgICAgKVxuXG4gICAgICAgIC8vIHJlc2V0IHNjcm9sbGJsb2NrT2Zmc2V0XG4gICAgICAgIGNvbnN0IHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSAndW5zZXQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9ICd1bnNldCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBzY3JvbGxibG9ja09mZnNldCcsIHNjcm9sbGJsb2NrT2Zmc2V0KVxuXG4gICAgICAgIGNvbnN0IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgLy8gKyBzY3JvbGxibG9ja09mZnNldC8vIHNlbWFudGljc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIGdldCBhbmQgY29uZmlnIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIC8vIHJldHVybnMgY29udGVudCBjb25zdHJhaW5lZCBieSBjcmFkbGVSb3djb3VudFxuICAgICAgICBjb25zdCBbbmV3Y29udGVudGxpc3QsZGVsZXRlZGl0ZW1zXSA9IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3Qoe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsICAgICAgICAgICAgXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6dGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudDowLFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpuZXdjb250ZW50bGlzdCxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDp0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgIFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBhbGxvY2F0ZUNvbnRlbnRMaXN0IC0gaGVhZGNvbnRlbnRsaXN0LCB0YWlsY29udGVudGxpc3QnLCBoZWFkY29udGVudGxpc3QsIHRhaWxjb250ZW50bGlzdClcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IG5ld2NvbnRlbnRsaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGhlYWRjb250ZW50bGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSB0YWlsY29udGVudGxpc3RcblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBzZXR0aW5nIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0JywgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQpXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGxldCBjc3RhdGUgPSBjcmFkbGVTdGF0ZVxuXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjayhcblxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsJ3NldENyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDQuIHNldCBDU1MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY29uc3QgYWRqdXN0ZWRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKyBzY3JvbGxibG9ja09mZnNldFxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCAvLyAtIHNjcm9sbGJsb2NrT2Zmc2V0XG4gICAgICAgIC8vIGF2b2lkIGJvZ3VzIGNhbGwgdG8gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YShzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQpIC8vIC0gc2Nyb2xsYmxvY2tPZmZzZXQpIFxuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPVxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zIFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gbGF5b3V0SGFuZGxlci5lbGVtZW50c1xuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0ID0gXG4gICAgICAgICAgICBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKyBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBBeGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCwgc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcXFxuICAgICAgICAvLyAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQnLEF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0LCBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG4gICAgICAgIC8vICAgICBheGlzVmlld3BvcnRQaXhlbE9mZnNldClcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCBcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgZ2FwICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4J1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudGxpc3QubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBnYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09WyBVUERBVEUgQ09OVEVOVCB0aHJvdWdoIHNjcm9sbCBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1cGRhdGVDcmFkbGVDb250ZW50IGRvZXMgbm90IHRvdWNoIHRoZSB2aWV3cG9ydCBlbGVtZW50J3Mgc2Nyb2xsIHBvc2l0aW9uIGZvciB0aGUgc2Nyb2xsYmxvY2tcbiAgICAvLyBpbnN0ZWFkIGl0IHJlY29uZmlndXJlcyBlbGVtZW50cyB3aXRoaW4gdGhlIGNyYWRsZS4gSXQgaXMgY2FsbGVkIHNvbGVseSBmcm9tXG4gICAgLy8gYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2sgb2YgaW50ZXJydXB0SGFuZGxlclxuXG4gICAgcHVibGljIHVwZGF0ZUNyYWRsZUNvbnRlbnQgPSAoXG4gICAgICAgIGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkLCBcbiAgICAgICAgdHJpZ2dlcmxpbmVFbnRyaWVzLCBcbiAgICAgICAgc291cmNlID0gJ25vdGlmaWNhdGlvbnMnXG4gICAgKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhhbmRsZXIgc3VwcG9ydFxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLCBcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlciwgXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHNjcm9sbCBkYXRhXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gc2Nyb2xsSGFuZGxlclxuXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvcyA9IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZVxuXG4gICAgICAgIC8vIGZpcnN0IGFiYW5kb24gb3B0aW9uLzM7IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKCBzY3JvbGxQb3MgPCAwKSB7IC8vIGZvciBTYWZhcmksIEZGIGVsYXN0aWMgYm91bmNlIGF0IHRvcCBvZiBzY3JvbGxcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyYWRsZSBzY2FmZm9sZCBhbmQgdXNlciBjZWxsc1xuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgbW9kZWxjb250ZW50bGlzdCA9IGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzIHx8IFtdLFxuICAgICAgICAgICAgb2xkQXhpc1JlZmVyZW5jZUluZGV4ID0gKGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1swXT8ucHJvcHMuaW5kZXggfHwgMClcblxuICAgICAgICBjb25zdCBvbGRDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChtb2RlbGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuXG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBnZXQgc2hpZnQgaW5zdHJ1Y3Rpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gLTEgaXMgbW92ZSBhIHJvdyB1cCB0byB0aGUgaGVhZCwgKzEgaXMgbW92ZSBhIHJvdyBkb3duIHRvIHRoZSB0YWlsLCAwIGlzIG5vIHNoaWZ0XG4gICAgICAgIGNvbnN0IHNoaWZ0aW5zdHJ1Y3Rpb24gPSBnZXRTaGlmdEluc3RydWN0aW9uKHtcbiAgICAgICAgICAgIHNjcm9sbGVySUQ6IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuc2Nyb2xsZXJJRCxcbiAgICAgICAgICAgIGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkLFxuICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICB0cmlnZ2VybGluZUVudHJpZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZVNwYW46IGxheW91dEhhbmRsZXIudHJpZ2dlcmxpbmVTcGFuLFxuICAgICAgICAgICAgLy8gZm9yIG92ZXJzaXplZCAob3ZlcmZsb3cpIGNlbGxzXG4gICAgICAgICAgICBvbGRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICBsaXN0c2l6ZSxcblxuICAgICAgICAgICAgcmV2ZXJzZURpcmVjdGlvbjpsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwsXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBzZWNvbmQgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAwKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlQ3JhZGxlQ29udGVudDogc2hpZnRpbnN0cnVjdGlvbicsc2hpZnRpbnN0cnVjdGlvbilcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMy4gQ2FsY3VsYXRlIHNoaWZ0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGNyYWRsZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQ6Y3JhZGxlSXRlbVNoaWZ0LCBcbiAgICAgICAgICAgIG5ld0F4aXNSZWZlcmVuY2VJbmRleDpheGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdDpheGlzSXRlbVNoaWZ0LCBcblxuICAgICAgICAgICAgLy8gY291bnRzXG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQ6Y3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4gICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG5cbiAgICAgICAgICAgIC8vIHBpeGVsc1xuICAgICAgICAgICAgbmV3QXhpc1BpeGVsT2Zmc2V0OmF4aXNQaXhlbE9mZnNldCwgXG5cbiAgICAgICAgfSA9IGNhbGNDb250ZW50U2hpZnQoe1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uLFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQsXG4gICAgICAgICAgICBjcmFkbGVFbGVtZW50cyxcbiAgICAgICAgICAgIHNjcm9sbFBvcyxcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCxcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGVDcmFkbGVDb250ZW50OiBheGlzSXRlbVNoaWZ0LCBjcmFkbGVJdGVtU2hpZnQnLGF4aXNJdGVtU2hpZnQsIGNyYWRsZUl0ZW1TaGlmdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZUNyYWRsZUNvbnRlbnQ6IGF4aXNQaXhlbE9mZnNldCcsYXhpc1BpeGVsT2Zmc2V0KVxuICAgICAgICAvLyB0aGlyZCBhYmFuZG9uIG9wdGlvbi8zOyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICgoYXhpc0l0ZW1TaGlmdCA9PSAwICYmIGNyYWRsZUl0ZW1TaGlmdCA9PSAwKSkgeyAvLyBjYW4gaGFwcGVuIGZpcnN0IHJvd1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHRyaWdnZXJsaW5lcyB3aWxsIGJlIG1vdmVkLCBzbyBkaXNjb25uZWN0IHRoZW0gZnJvbSB0aGVpciBvYnNlcnZlci5cbiAgICAgICAgLy8gdGhleSBhcmUgcmVjb25uZWN0ZWQgd2l0aCAncmVuZGVydXBkYXRlZGNvbnRlbnQnIHN0YXRlIGluIGNyYWRsZS50c3hcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RpbmcgdHJpZ2dlcnMgaW4gdXBkYXRlQ3JhZGxlQ29udGVudCcpXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiByZWNvbmZpZ3VyZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb2xsZWN0IG1vZGlmaWVkIGNvbnRlbnRcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50TGlzdCwgZGVsZXRlZENvbnRlbnRJdGVtcyA9IFtdXG5cbiAgICAgICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50IHx8IGxpc3RFbmRDaGFuZ2VDb3VudCkgeyAvLyBpZiBlaXRoZXIgaXMgbm9uLTAgdGhlbiBtb2RpZnkgY29udGVudFxuXG4gICAgICAgICAgICBbdXBkYXRlZENvbnRlbnRMaXN0LGRlbGV0ZWRDb250ZW50SXRlbXNdID0gZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCh7XG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgICAgICB3b3JraW5nQ29udGVudExpc3Q6bW9kZWxjb250ZW50bGlzdCxcbiAgICAgICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6b2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWY6dGhpcy5pbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50TGlzdCA9IG1vZGVsY29udGVudGxpc3RcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGV0ZWRDb250ZW50SXRlbXMubGVuZ3RoICYmIChjYWNoZSA9PSAnY3JhZGxlJykpIHtcblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlUG9ydGFscyhjYWNoZUhhbmRsZXIsIGRlbGV0ZWRDb250ZW50SXRlbXMsIGRMaXN0Q2FsbGJhY2spXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDUuIGFsbG9jYXRlIGNyYWRsZSBjb250ZW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IFtoZWFkY29udGVudCwgdGFpbGNvbnRlbnRdID0gYWxsb2NhdGVDb250ZW50TGlzdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdDp1cGRhdGVkQ29udGVudExpc3QsXG4gICAgICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IHVwZGF0ZWRDb250ZW50TGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudFxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSB0YWlsY29udGVudFxuXG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGxldCBjc3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjayhcblxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwndXBkYXRlQ3JhZGxlQ29udGVudCcsIGNzdGF0ZSlcbiAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA2LiBzZXQgY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wUG9zID0gc2Nyb2xsUG9zICsgYXhpc1BpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5nYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQb3MgPSBzY3JvbGxQb3MgKyBheGlzUGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBvcyArICdweCdcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnQubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGVDcmFkbGVDb250ZW50IHNldHRpbmcgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQnLCBheGlzUGl4ZWxPZmZzZXQpXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNQaXhlbE9mZnNldFxuXG4gICAgICAgIC8vIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgIC8vIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlbmRlcnVwZGF0ZWRjb250ZW50JylcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVTUE9TSVRJT04gVkFSSUFCTEUgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIGFsbCBET00gZWxlbWVudHMgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IHRoaXMgcG9pbnRcbiAgICAvLyBzZXRzIENTUzogc2Nyb2xsYmxvY2tFbGVtZW50IHRvcCBhbmQgaGVpZ2h0IChvciBsZWZ0IGFuZCB3aWR0aCksIGFuZCBheGlzRWxlbWVudCB0b3AgKG9yIGxlZnQpXG4gICAgcHVibGljIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkgPSAoc291cmNlID0gJ3N0YW5kYXJkJykgPT4ge1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXMsXG4gICAgICAgICAgICBjcmFkbGVIYW5kbGVycyA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGxheW91dEhhbmRsZXIgfSA9IGNyYWRsZUhhbmRsZXJzLFxuICAgICAgICAgICAgeyBlbGVtZW50czpjcmFkbGVFbGVtZW50cywgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3QgaGVhZEdyaWQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB0YWlsR3JpZCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQgPSB2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3QgeyBjcm9zc2NvdW50LCBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgbGV0IHNjcm9sbGJsb2NrT2Zmc2V0ID0gLy8gZnJvbSBwcmV2aW91cyBhZGp1c3RtZW50c1xuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0+PiBhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5OiBzb3VyY2UsIHNjcm9sbGJsb2NrT2Zmc2V0LCBjcmFkbGVQb3NpdGlvbkRhdGEnLFxuICAgICAgICAvLyAgICAgc291cmNlLCBzY3JvbGxibG9ja09mZnNldCwgY3JhZGxlUG9zaXRpb25EYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleDpheGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgIGlmIChzb3VyY2UgPT0gJ2FmdGVyc2Nyb2xsJykgeyAvLyByZWJhbGFuY2Ugc2Nyb2xsYmxvY2tPZmZzZXQgYW5kIGJsb2NrU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9ICd1bnNldCdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSAndW5zZXQnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9IGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyAtPSBzY3JvbGxibG9ja09mZnNldFxuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc1JlZmVyZW5jZUluZGV4ID09IDApIHsgLy8gdHJpZ2dlciBzY3JvbGxibG9ja09mZnNldCByZXNldDsgY2hhbmdlIGJsb2NrU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgIGNvbnN0IGJsb2NrU2Nyb2xsUG9zID0gcGFkZGluZyAtIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSBibG9ja1Njcm9sbFBvc1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSAndW5zZXQnXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gJ3Vuc2V0J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IDBcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6YXhpc1ZpZXdwb3J0T2Zmc2V0LFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MsXG5cbiAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBoZWFkUm93Q291bnQgPSBNYXRoLmNlaWwoaGVhZEdyaWQuY2hpbGROb2Rlcy5sZW5ndGgvY3Jvc3Njb3VudClcbiAgICAgICAgY29uc3QgdGFpbFJvd0NvdW50ID0gTWF0aC5jZWlsKHRhaWxHcmlkLmNoaWxkTm9kZXMubGVuZ3RoL2Nyb3NzY291bnQpXG5cbiAgICAgICAgY29uc3QgYmFzZUNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGhcbiAgICAgICAgICAgICkgKyBnYXBcblxuICAgICAgICBjb25zdCBiYXNlSGVhZExlbmd0aCA9IChoZWFkUm93Q291bnQgKiBiYXNlQ2VsbExlbmd0aCkgKyBwYWRkaW5nXG4gICAgICAgIGNvbnN0IGJhc2VUYWlsTGVuZ3RoID0gKHRhaWxSb3dDb3VudCAqIGJhc2VDZWxsTGVuZ3RoKSArIHBhZGRpbmcgLSBnYXBcblxuICAgICAgICBsZXQgbWVhc3VyZWRIZWFkTGVuZ3RoLCBtZWFzdXJlZFRhaWxMZW5ndGhcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIG1lYXN1cmVkSGVhZExlbmd0aCA9IGhlYWRHcmlkLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgbWVhc3VyZWRUYWlsTGVuZ3RoID0gdGFpbEdyaWQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZWFzdXJlZEhlYWRMZW5ndGggPSBoZWFkR3JpZC5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgbWVhc3VyZWRUYWlsTGVuZ3RoID0gdGFpbEdyaWQub2Zmc2V0V2lkdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhlYWREZWx0YSA9IGJhc2VIZWFkTGVuZ3RoIC0gbWVhc3VyZWRIZWFkTGVuZ3RoXG4gICAgICAgIGNvbnN0IHRhaWxEZWx0YSA9IGJhc2VUYWlsTGVuZ3RoIC0gbWVhc3VyZWRUYWlsTGVuZ3RoXG5cbiAgICAgICAgY29uc3QgbGlzdHJvd2NvdW50ID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG5cbiAgICAgICAgY29uc3QgYmFzZWJsb2NrbGVuZ3RoID0gKGxpc3Ryb3djb3VudCAqIGJhc2VDZWxsTGVuZ3RoKSAtIGdhcCAvLyBubyBnYXAgYmVsb3cgbGFzdCByb3dcbiAgICAgICAgICAgICsgKHBhZGRpbmcgKiAyKSAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGF4aXMgb2Zmc2V0IGRlbHRhXG4gICAgICAgIGNvbnN0IGF4aXNSZWZlcmVuY2VSb3cgPSBNYXRoLmNlaWwoYXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG4gICAgICAgIGNvbnN0IGF4aXNTY3JvbGxibG9ja09mZnNldCA9IFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgKyBheGlzVmlld3BvcnRPZmZzZXQgKyBoZWFkRGVsdGEgKyBzY3JvbGxibG9ja09mZnNldFxuXG4gICAgICAgIGNvbnN0IGJhc2VBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgPSAoYXhpc1JlZmVyZW5jZVJvdyAqIGJhc2VDZWxsTGVuZ3RoKSArIHBhZGRpbmdcbiAgICAgICAgY29uc3QgYXhpc1Njcm9sbGJsb2NrT2Zmc2V0RGVsdGEgPSBiYXNlQXhpc1Njcm9sbGJsb2NrT2Zmc2V0IC0gYXhpc1Njcm9sbGJsb2NrT2Zmc2V0XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tIZWlnaHQgPSBiYXNlYmxvY2tsZW5ndGggLSBoZWFkRGVsdGEgLSB0YWlsRGVsdGEgLSBheGlzU2Nyb2xsYmxvY2tPZmZzZXREZWx0YVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBhcHBsaWNhdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChheGlzUmVmZXJlbmNlSW5kZXggPT0gMCkge1xuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgLy8gdGhlIHNjcm9sbGJsb2NrIHRvcCBpcyBtb3ZlZCB0byBjb21wZW5zYXRlIGZvciB0aGUgaGVhZERlbHRhXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gLSBoZWFkRGVsdGEgLSBzY3JvbGxibG9ja09mZnNldCArICdweCdcbiAgICAgICAgICAgIC8vIHRoZSBheGlzIGlzIG1vdmVkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdG8gbWFpbnRhaW4gdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IGF4aXNTY3JvbGxibG9ja09mZnNldCArICdweCdcbiAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgaXMgYWRqdXN0ZWQgYnkgYm90aCBkZWx0YXMsIGFzIGl0IGNvbnRyb2xzIHRoZSBzY3JvbGwgbGVuZ3RoXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsYmxvY2tIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSAtaGVhZERlbHRhIC0gc2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gYXhpc1Njcm9sbGJsb2NrT2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLndpZHRoID0gc2Nyb2xsYmxvY2tIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBbIElOVEVSTkFMIENPTlRFTlQgTUFOQUdFTUVOVCBTRVJWSUNFUyBdPT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoKSA9PiB7IFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVNYXgsIE1BWF9DQUNIRV9PVkVSX1JVTiB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsQ29tcG9uZW50TGlzdCA9IHRoaXMuY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHNcbiBcbiAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5ndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyhjYWNoZU1heCwgbW9kZWxDb21wb25lbnRMaXN0Lmxlbmd0aCwgTUFYX0NBQ0hFX09WRVJfUlVOICkpIHtcblxuICAgICAgICAgICAgdGhpcy5wYXJlQ2FjaGVUb01heCgpXG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgcGFyZUNhY2hlVG9NYXggPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlLCBzY3JvbGxlcklEIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG4gICAgICAgIFxuICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVIYW5kbGVycyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IGNyYWRsZUhhbmRsZXJzXG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gdGhpcy5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIEVYVEVSTkFMIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN1cHBvcnRzIGNsZWFyQ2FjaGVcbiAgICBwdWJsaWMgY2xlYXJDcmFkbGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2VIYW5kbGVyIGdldENyYWRsZUluZGV4TWFwXG4gICAgLy8gYWxzbyBzdXBwb3J0cyBwYXJlQ2FjaGVUb01heCwgbWF0Y2hDYWNoZVRvQ3JhZGxlXG4gICAgcHVibGljIGdldE1vZGVsSW5kZXhMaXN0KCkge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBpZiAoIWNyYWRsZU1vZGVsQ29tcG9uZW50cykge1xuXG4gICAgICAgICAgICByZXR1cm4gW10gXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5tYXAoKGl0ZW0pPT5pdGVtLnByb3BzLmluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2UgaGFuZGxlcidzIHJlbWFwSW5kZXhlcywgYXMgbGFzdCBzdGVwXG4gICAgcHVibGljIHJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleGVzTGlzdCkge1xuXG4gICAgICAgIGlmICghbW9kaWZpZWRJbmRleGVzTGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzXG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoY29tcG9uZW50LCBpLCBhcnJheSApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIGl0ZW1JRCB9ID0gY29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRleGVzTGlzdC5pbmNsdWRlcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IFxuICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCk/XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtSUQgIT0gaXRlbUlEKSB7IC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGhhcHBlblxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc0NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgbW92ZUluZGV4IGFuZCBpbnNlcnRSZW1vdmVJbmRleFxuICAgIHB1YmxpYyBjaGFuZ2VDcmFkbGVJdGVtSURzKGNoYW5nZUxpc3QpIHtcblxuICAgICAgICBpZiAoY2hhbmdlTGlzdC5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCwgbWV0YWRhdGFNYXAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnQoY29tcG9uZW50LCBpLCBhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuXG4gICAgICAgICAgICBjb25zdCBwdHIgPSBjaGFuZ2VMaXN0LmluZGV4T2YoaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChwdHIgIT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc2NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgaW5zZXJ0UmVtb3ZlSW5kZXhcbiAgICBwdWJsaWMgY3JlYXRlTmV3SXRlbUlEcyhuZXdMaXN0KSB7XG5cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnQoY29tcG9uZW50LCBpLCBhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuICAgICAgICAgICAgY29uc3QgcHRyID0gbmV3TGlzdC5pbmRleE9mKGluZGV4KVxuXG4gICAgICAgICAgICBpZiAocHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtSUQgPSBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUQ6bmV3SXRlbUlEfSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbn0iXSwibmFtZXMiOlsiQ29udGVudEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJjdXJyZW50IiwiY3JhZGxlU3RhdGUiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSGFuZGxlcnMiLCJoYW5kbGVyc1JlZiIsImNhY2hlSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImludGVycnVwdEhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0Iiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiY3JhZGxlSW50ZXJzZWN0IiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsInJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImNhY2hlIiwic2Nyb2xsZXJJRCIsInN0eWxlcyIsImxheW91dCIsImNyb3NzY291bnQiLCJsaXN0c2l6ZSIsIndvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4IiwiTWF0aCIsIm1pbiIsImluY2x1ZGVzIiwid29ya2luZ0NvbnRlbnRMaXN0IiwiY3JhZGxlQ29udGVudCIsImNvbnRlbnQiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVDb250ZW50Q291bnQiLCJuZXdDcmFkbGVDb250ZW50Q291bnQiLCJzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwic3R5bGUiLCJ0b3AiLCJsZWZ0IiwiYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VJbmRleCIsImxpc3RTdGFydENoYW5nZUNvdW50IiwibGlzdEVuZENoYW5nZUNvdW50IiwiaW5zdGFuY2VJZENvdW50ZXJSZWYiLCJuZXdjb250ZW50bGlzdCIsImRlbGV0ZWRpdGVtcyIsImNvbnRlbnRsaXN0IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwiaGVhZGNvbnRlbnRsaXN0IiwidGFpbGNvbnRlbnRsaXN0IiwiY2FsbGJhY2tzIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsImNzdGF0ZSIsImJsb2NrU2Nyb2xsUG9zIiwicmVzZXRTY3JvbGxEYXRhIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJoZWFkRWxlbWVudCIsImhlYWRSZWYiLCJheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCIsInBhZGRpbmdCb3R0b20iLCJsZW5ndGgiLCJwYWRkaW5nUmlnaHQiLCJpc0Jsb2NrU2Nyb2xsaW5nRm9yd2FyZCIsInRyaWdnZXJsaW5lRW50cmllcyIsInNvdXJjZSIsInN0YXRlSGFuZGxlciIsInNjcm9sbERhdGEiLCJzY3JvbGxQb3MiLCJjdXJyZW50dXBkYXRlIiwibW9kZWxjb250ZW50bGlzdCIsIm9sZEF4aXNSZWZlcmVuY2VJbmRleCIsIl9hIiwicHJvcHMiLCJpbmRleCIsIm9sZENyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2IiLCJ2aWV3cG9ydFZpc2libGVSb3djb3VudCIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VybGluZVNwYW4iLCJyZXZlcnNlRGlyZWN0aW9uIiwidHJpZ2dlcmNlbGxJc0luVGFpbCIsIm5ld0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiY3JhZGxlSXRlbVNoaWZ0IiwiY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0IiwibmV3QXhpc1JlZmVyZW5jZUluZGV4IiwiYXhpc0l0ZW1TaGlmdCIsImF4aXNSZWZlcmVuY2VJdGVtU2hpZnQiLCJheGlzUGl4ZWxPZmZzZXQiLCJuZXdBeGlzUGl4ZWxPZmZzZXQiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInVwZGF0ZWRDb250ZW50TGlzdCIsImRlbGV0ZWRDb250ZW50SXRlbXMiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImhlYWRjb250ZW50IiwidGFpbGNvbnRlbnQiLCJjcmFkbGVTdGF0ZVJlZiIsInRvcFBvcyIsImxlZnRQb3MiLCJzZXRDcmFkbGVTdGF0ZSIsImhlYWRHcmlkIiwidGFpbEdyaWQiLCJ0YWlsUmVmIiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwiYXhpc1ZpZXdwb3J0T2Zmc2V0IiwiaGVhZFJvd0NvdW50IiwiY2VpbCIsImNoaWxkTm9kZXMiLCJ0YWlsUm93Q291bnQiLCJiYXNlQ2VsbExlbmd0aCIsImJhc2VIZWFkTGVuZ3RoIiwiYmFzZVRhaWxMZW5ndGgiLCJtZWFzdXJlZEhlYWRMZW5ndGgiLCJtZWFzdXJlZFRhaWxMZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImhlYWREZWx0YSIsInRhaWxEZWx0YSIsImxpc3Ryb3djb3VudCIsImJhc2VibG9ja2xlbmd0aCIsImF4aXNSZWZlcmVuY2VSb3ciLCJheGlzU2Nyb2xsYmxvY2tPZmZzZXQiLCJiYXNlQXhpc1Njcm9sbGJsb2NrT2Zmc2V0IiwiYXhpc1Njcm9sbGJsb2NrT2Zmc2V0RGVsdGEiLCJzY3JvbGxibG9ja0hlaWdodCIsImhlaWdodCIsIndpZHRoIiwiY2FjaGVNYXgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJtb2RlbENvbXBvbmVudExpc3QiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInBhcmVDYWNoZVRvTWF4IiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXAiLCJpdGVtIiwibW9kaWZpZWRJbmRleGVzTGlzdCIsImluZGV4VG9JdGVtSURNYXAiLCJwcm9jZXNzQ29tcG9uZW50IiwiY29tcG9uZW50IiwiaSIsImFycmF5IiwiaXRlbUlEIiwibmV3SXRlbUlEIiwiaGFzIiwiZ2V0IiwiZ2V0TmV3SXRlbUlEIiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImZvckVhY2giLCJzbGljZSIsImNoYW5nZUxpc3QiLCJtZXRhZGF0YU1hcCIsInByb2Nlc3Njb21wb25lbnQiLCJwdHIiLCJpbmRleE9mIiwibmV3TGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n")},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval(" // interrupthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleResizeObserverCallback // responds to resize of the two cradle grids\n        when the cradle is in variable layout\n    - cradleIntersectionObserverCallback // responds to move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback // responds to crossing of forward and backward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing is handled by viewport\n    scrolling interrupts handled by scrollHandler\n*/\n\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ \"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n\nvar ResizeObserver = window['ResizeObserver'] || resize_observer_1.ResizeObserver;\n\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, InterruptHandler);\n\n  this.isTailCradleInView = false;\n  this.isHeadCradleInView = false; // TODO: stub\n\n  this.cradleResizeObserverCallback = function (entries) {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler; // stateHandler.setCradleResizeState('resizecradle')\n\n    if (_this.signals.pauseCradleResizeObserver) return;\n  };\n\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    // console.log('interruptHandler triggerlinecallback', entries)\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n\n    var testrootbounds = entries[0].rootBounds;\n\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter.contentHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        scrollHandler = _this$cradleParameter.scrollHandler,\n        layoutHandler = _this$cradleParameter.layoutHandler;\n\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n\n      if (scrollData.start != scrollData.current || scrollData.current != scrollData.previous) {\n        scrollData.previousupdate = scrollData.currentupdate;\n        scrollData.currentupdate = scrollData.current;\n        var isBlockScrollingForward = scrollData.previous > scrollData.current;\n        contentHandler.updateCradleContent(isBlockScrollingForward, entries, 'triggerlinesObserver');\n      }\n    }\n  };\n\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var _a;\n\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter2.stateHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler;\n\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.type == 'head') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n\n    if (_this.signals.repositioningRequired) // start reposition if no other interrupts are underway\n      {\n        var cradleState = stateHandler.cradleStateRef.current;\n\n        if (!((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) && !(cradleState == 'repositioningRender') && !(cradleState == 'repositioningContinuation') && !(cradleState == 'finishreposition') && !(cradleState == 'renderupdatedcontent') && !(cradleState == 'finishupdatedcontent') && !ViewportContextProperties.isResizing && !(cradleState == 'finishviewportresize')) {\n          var viewportelement = ViewportContextProperties.elementRef.current;\n          var scrollerID = _this.cradleParameters.cradleInheritedPropertiesRef.current.scrollerID;\n\n          if (!viewportelement) {\n            console.log('SYSTEM: viewport element not set in cradleIntersectionObserverCallback', scrollerID, ViewportContextProperties);\n            return;\n          } // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n\n\n          var rect = viewportelement.getBoundingClientRect();\n          var top = rect.top,\n              right = rect.right,\n              bottom = rect.bottom,\n              left = rect.left;\n          var width = right - left,\n              height = bottom - top; // update for scrolltracker\n\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState('startreposition');\n        }\n      }\n  }; // for adjusting to content re-sizing\n\n\n  this.cradleResize = {\n    observer: null,\n    callback: this.cradleResizeObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleResize.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      _this.cradleResize.observer = new ResizeObserver(_this.cradleResize.callback);\n      return _this.cradleResize.observer;\n    }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n\n\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2ludGVycnVwdGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTs7QUFFQSxJQUFNQSxjQUFjLEdBQUdDLE1BQU0sQ0FBQyxnQkFBRCxDQUFOLElBQTRCQyxnQ0FBbkQ7O0lBRXFCQyxnQiw2QkFFakIsMEJBQVlDLGdCQUFaLEVBQTRCO0VBQUE7O0VBQUE7O0VBUXBCLDBCQUFxQixLQUFyQjtFQUNBLDBCQUFxQixLQUFyQixDQVRvQixDQVc1Qjs7RUFDUSxvQ0FBK0IsVUFBQ0MsT0FBRCxFQUFZO0lBRS9DLElBQ0lDLFlBREosR0FFSSxLQUFJLENBQUNGLGdCQUFMLENBQXNCRyxXQUF0QixDQUFrQ0MsT0FGdEMsQ0FDSUYsWUFESixDQUYrQyxDQU0vQzs7SUFDQSxJQUFJLEtBQUksQ0FBQ0csT0FBTCxDQUFhQyx5QkFBakIsRUFBNEM7RUFFL0MsQ0FUTzs7RUFXQSx3Q0FBbUMsVUFBQ0wsT0FBRCxFQUFZO0lBRW5EO0lBRUEsSUFBSSxLQUFJLENBQUNJLE9BQUwsQ0FBYUUseUJBQWpCLEVBQTRDO01BRXhDO0lBRUg7O0lBRUQsSUFBTUMsY0FBYyxHQUFHUCxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdRLFVBQWxDOztJQUNBLElBQUtELGNBQWMsQ0FBQ0UsS0FBZixJQUF3QixDQUF6QixJQUFnQ0YsY0FBYyxDQUFDRyxNQUFmLElBQXlCLENBQTdELEVBQWlFO01BQUU7TUFFL0Q7SUFFSDs7SUFFRCw0QkFLSSxLQUFJLENBQUNYLGdCQUFMLENBQXNCRyxXQUF0QixDQUFrQ0MsT0FMdEM7SUFBQSxJQUNJUSxjQURKLHlCQUNJQSxjQURKO0lBQUEsSUFFSVYsWUFGSix5QkFFSUEsWUFGSjtJQUFBLElBR0lXLGFBSEoseUJBR0lBLGFBSEo7SUFBQSxJQUlJQyxhQUpKLHlCQUlJQSxhQUpKOztJQU9BLElBQUlaLFlBQVksQ0FBQ2EsWUFBYixDQUEwQlgsT0FBOUIsRUFBdUM7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dC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBDcmFkbGUgc3RydWN0dXJlIGxpc3RlbmVyczpcbiAgICAtIGNyYWRsZVJlc2l6ZU9ic2VydmVyQ2FsbGJhY2sgLy8gcmVzcG9uZHMgdG8gcmVzaXplIG9mIHRoZSB0d28gY3JhZGxlIGdyaWRzXG4gICAgICAgIHdoZW4gdGhlIGNyYWRsZSBpcyBpbiB2YXJpYWJsZSBsYXlvdXRcbiAgICAtIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgLy8gcmVzcG9uZHMgdG8gbW92ZSBvZiBib3RoIGNyYWRsZSBncmlkcyBvdXRzaWRlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMgaW5pdGlhdGVzIHRoZSByZXBvc2l0aW9uaW5nIHByb3RvY29sXG4gICAgLSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayAvLyByZXNwb25kcyB0byBjcm9zc2luZyBvZiBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0cmlnZ2VybGluZXNcbiAgICAgICAgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0LCBhbmQgdHJpZ2dlcnMgcm9sbG92ZXIgYW5kIHJlLWFsbG9jYXRpb24gb2YgY3JhZGxlIGNvbnRlbnRcblxuICAgIHZpZXdwb3J0UmVzaXppbmcgaXMgaGFuZGxlZCBieSB2aWV3cG9ydFxuICAgIHNjcm9sbGluZyBpbnRlcnJ1cHRzIGhhbmRsZWQgYnkgc2Nyb2xsSGFuZGxlclxuKi9cblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgYXMgUmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbH0gZnJvbSAnQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXInXG5cbmNvbnN0IFJlc2l6ZU9ic2VydmVyID0gd2luZG93WydSZXNpemVPYnNlcnZlciddIHx8IFJlc2l6ZU9ic2VydmVyUG9seWZpbGxcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJydXB0SGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHByaXZhdGUgaXNUYWlsQ3JhZGxlSW5WaWV3ID0gZmFsc2VcbiAgICBwcml2YXRlIGlzSGVhZENyYWRsZUluVmlldyA9IGZhbHNlXG5cbiAgICAvLyBUT0RPOiBzdHViXG4gICAgcHJpdmF0ZSBjcmFkbGVSZXNpemVPYnNlcnZlckNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVSZXNpemVTdGF0ZSgncmVzaXplY3JhZGxlJylcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyKSByZXR1cm5cblxuICAgIH1cblxuICAgIHByaXZhdGUgYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnRlcnJ1cHRIYW5kbGVyIHRyaWdnZXJsaW5lY2FsbGJhY2snLCBlbnRyaWVzKVxuXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlcikgeyBcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlc3Ryb290Ym91bmRzID0gZW50cmllc1swXS5yb290Qm91bmRzXG4gICAgICAgIGlmICgodGVzdHJvb3Rib3VuZHMud2lkdGggPT0gMCkgJiYgKHRlc3Ryb290Ym91bmRzLmhlaWdodCA9PSAwKSkgeyAvLyByZXBhcmVudGluZ1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGVudEhhbmRsZXIsXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIsXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSBzY3JvbGxIYW5kbGVyXG4gICAgICAgICAgICBpZiAoKHNjcm9sbERhdGEuc3RhcnQgIT0gc2Nyb2xsRGF0YS5jdXJyZW50KSB8fFxuICAgICAgICAgICAgICAgIChzY3JvbGxEYXRhLmN1cnJlbnQgIT0gc2Nyb2xsRGF0YS5wcmV2aW91cykpIHtcblxuICAgICAgICAgICAgICAgIHNjcm9sbERhdGEucHJldmlvdXN1cGRhdGUgPSBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGVcbiAgICAgICAgICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxEYXRhLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkID0gKHNjcm9sbERhdGEucHJldmlvdXMgPiBzY3JvbGxEYXRhLmN1cnJlbnQpXG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci51cGRhdGVDcmFkbGVDb250ZW50KGlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkLCBlbnRyaWVzLCd0cmlnZ2VybGluZXNPYnNlcnZlcicpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc2lnbmFscyA9IHRoaXMuc2lnbmFsc1xuICAgICAgICBjb25zdCB7IHN0YXRlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQuZGF0YXNldC50eXBlID09ICdoZWFkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICgoZW50cnkucm9vdEJvdW5kcy53aWR0aCA9PSAwKSAmJiAoZW50cnkucm9vdEJvdW5kcy5oZWlnaHQgPT0gMCkpIC8vIHJlcGFyZW50aW5nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVGFpbENyYWRsZUluVmlldyA9IFxuICAgICAgICAgICAgICAgICAgICAoZW50cnkuaXNJbnRlcnNlY3RpbmcgIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gKCF0aGlzLmlzSGVhZENyYWRsZUluVmlldyAmJiAhdGhpcy5pc1RhaWxDcmFkbGVJblZpZXcpXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnJlcG9zaXRpb25pbmdSZXF1aXJlZCkgLy8gc3RhcnQgcmVwb3NpdGlvbiBpZiBubyBvdGhlciBpbnRlcnJ1cHRzIGFyZSB1bmRlcndheVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50ICYmXG5cbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpICYmXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAnZmluaXNocmVwb3NpdGlvbicpICYmIFxuXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVuZGVydXBkYXRlZGNvbnRlbnQnKSAmJiBcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdmaW5pc2h1cGRhdGVkY29udGVudCcpICYmXG5cbiAgICAgICAgICAgICAgICAhVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nICYmXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAnZmluaXNodmlld3BvcnRyZXNpemUnKVxuXG4gICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydGVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxlcklEIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3cG9ydGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NZU1RFTTogdmlld3BvcnQgZWxlbWVudCBub3Qgc2V0IGluIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCxWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbnMgd2l0aCBjcmFkbGUgaW50ZXJzZWN0aW9uLiBTZWUgYWxzbyBkaW1lbnNpb24gdXBkYXRlIGluIHZpZXdwb3J0LnRzeCBmb3IgcmVzaXplXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHZpZXdwb3J0ZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gcmVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0LCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZm9yIHNjcm9sbHRyYWNrZXJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLnZpZXdwb3J0RGltZW5zaW9ucyA9IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9IFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sodHJ1ZSlcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3N0YXJ0cmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAvLyBmb3IgYWRqdXN0aW5nIHRvIGNvbnRlbnQgcmUtc2l6aW5nXG4gICBwdWJsaWMgY3JhZGxlUmVzaXplID0ge1xuICAgICAgb2JzZXJ2ZXI6bnVsbCxcbiAgICAgIGNhbGxiYWNrOnRoaXMuY3JhZGxlUmVzaXplT2JzZXJ2ZXJDYWxsYmFjayxcbiAgICAgICAgY29ubmVjdEVsZW1lbnRzOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5jcmFkbGVSZXNpemUub2JzZXJ2ZXJcbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQubGF5b3V0SGFuZGxlci5lbGVtZW50c1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudClcbiAgICAgICAgfSxcbiAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcblxuICAgICAgICB0aGlzLmNyYWRsZVJlc2l6ZS5vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLmNyYWRsZVJlc2l6ZS5jYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JhZGxlUmVzaXplLm9ic2VydmVyXG5cbiAgICAgIH1cbiAgIH1cblxuICAgcHVibGljIGNyYWRsZUludGVyc2VjdCA9IHsgICAgXG4gICAgICAgIG9ic2VydmVyOm51bGwsICAgIFxuICAgICAgICBjYWxsYmFjazp0aGlzLmNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2ssXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICB7cm9vdDpWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCwgdGhyZXNob2xkOjB9XG4gICAgICAgICAgICApICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgIHB1YmxpYyB0cmlnZ2VybGluZXNJbnRlcnNlY3QgPSB7XG4gICAgICAgIG9ic2VydmVyOm51bGwsXG4gICAgICAgIGNhbGxiYWNrOnRoaXMuYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2ssXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIGlmIChjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICB7cm9vdDpWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCwgdGhyZXNob2xkOjB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3Qub2JzZXJ2ZXJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzaWduYWxzID0ge1xuICAgICAgICByZXBvc2l0aW9uaW5nUmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyOiBmYWxzZSwgXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI6ZmFsc2UsXG4gICAgICAgIHBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgICAgICBwYXVzZVNjcm9sbGluZ0VmZmVjdHM6IGZhbHNlLFxuICAgIH1cblxuICAgIC8qXG4gICAgICAgIGludm9rZWQgZm9yIFxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gY2hhbmdlIGludG8gY2FjaGVcbiAgICAgICAgLSB0cmlnZ2VyIGNyYWRsZXJlc2l6aW5nXG4gICAgICAgIC0gdHJpZ2dlciByZWNvbmZpZ3VyYXRpb25cbiAgICAgICAgLSB0cmlnZ2VyIHBpdm90XG4gICAgICAgIHNlcnZpY2VoYW5kbGVyOlxuICAgICAgICAtIGNhbGwgcmVsb2FkXG4gICAgKi9cbiAgICBwdWJsaWMgcGF1c2VJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXNcbiAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSB0cnVlXG4gICAgfVxuICAgIC8qXG4gICAgICAgIGludm9rZWQgZm9yXG4gICAgICAgIGNyYWRsZTpcbiAgICAgICAgLSByZXN0b3JlaW50ZXJydXB0c1xuICAgICovXG4gICAgcHVibGljIHJlc3RvcmVJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXNcbiAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSBmYWxzZVxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwicmVzaXplX29ic2VydmVyXzEiLCJJbnRlcnJ1cHRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImVudHJpZXMiLCJzdGF0ZUhhbmRsZXIiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJzaWduYWxzIiwicGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJ0ZXN0cm9vdGJvdW5kcyIsInJvb3RCb3VuZHMiLCJ3aWR0aCIsImhlaWdodCIsImNvbnRlbnRIYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJpc01vdW50ZWRSZWYiLCJzY3JvbGxEYXRhIiwic3RhcnQiLCJwcmV2aW91cyIsInByZXZpb3VzdXBkYXRlIiwiY3VycmVudHVwZGF0ZSIsImlzQmxvY2tTY3JvbGxpbmdGb3J3YXJkIiwidXBkYXRlQ3JhZGxlQ29udGVudCIsInNlcnZpY2VIYW5kbGVyIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImkiLCJsZW5ndGgiLCJlbnRyeSIsInRhcmdldCIsImRhdGFzZXQiLCJ0eXBlIiwiaXNIZWFkQ3JhZGxlSW5WaWV3IiwiaXNJbnRlcnNlY3RpbmciLCJpc1RhaWxDcmFkbGVJblZpZXciLCJyZXBvc2l0aW9uaW5nUmVxdWlyZWQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImNyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc1JlcGFyZW50aW5nUmVmIiwiX2EiLCJpc1Jlc2l6aW5nIiwidmlld3BvcnRlbGVtZW50IiwiZWxlbWVudFJlZiIsInNjcm9sbGVySUQiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY29uc29sZSIsImxvZyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiY2FsbGJhY2tzIiwic2V0Q3JhZGxlU3RhdGUiLCJvYnNlcnZlciIsImNhbGxiYWNrIiwiY3JhZGxlUmVzaXplT2JzZXJ2ZXJDYWxsYmFjayIsImNvbm5lY3RFbGVtZW50cyIsImNyYWRsZVJlc2l6ZSIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJvYnNlcnZlIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJjcmVhdGVPYnNlcnZlciIsImNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2siLCJjcmFkbGVJbnRlcnNlY3QiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3QiLCJ0aHJlc2hvbGQiLCJheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n")},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // layouthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the forward and backward triggerlines\n    The key control values are the blockScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferenceIndex (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\n\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    _classCallCheck(this, LayoutHandler);\n\n    this.triggercellIsInTail = false; // cradlePositionData controls the relative positions of the scaffold elements\n\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToItem call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // into the viewport\n\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n        axisRef = _cradleParameters$cra.axisRef,\n        headRef = _cradleParameters$cra.headRef,\n        tailRef = _cradleParameters$cra.tailRef,\n        triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n        triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // progression of references: implied->target\n\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      return orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop : // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n    }\n  }]);\n\n  return LayoutHandler;\n}();\n\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2xheW91dGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7SUFhcUJBLGE7RUFFakIsdUJBQVlDLGdCQUFaLEVBQTRCO0lBQUE7O0lBc0RyQiwyQkFBc0IsS0FBdEIsQ0F0RHFCLENBd0Q1Qjs7SUFDTywwQkFBcUI7TUFFeEI7Ozs7Ozs7O01BV0FDLGNBQWMsRUFBQyxJQWJTOztNQWV4Qjs7Ozs7TUFPQUMsbUJBQW1CLEVBQUMsSUF0Qkk7O01Bd0J4Qjs7Ozs7Ozs7Ozs7TUFZQUMsd0JBQXdCLEVBQUMsSUFwQ0Q7O01Bc0N4Qjs7Ozs7Ozs7Ozs7TUFhQUMsNkJBQTZCLEVBQUMsSUFuRE4sQ0FtRFk7O0lBbkRaLENBQXJCO0lBdkRILEtBQUtKLGdCQUFMLEdBQXdCQSxnQkFBeEI7SUFFQSw0QkFNSUEsZ0JBQWdCLENBQUNLLDJCQUFqQixDQUE2Q0MsT0FBN0MsQ0FBcURDLGlCQUFyRCxDQUF1RUQsT0FOM0U7SUFBQSxJQUNJRSxPQURKLHlCQUNJQSxPQURKO0lBQUEsSUFFSUMsT0FGSix5QkFFSUEsT0FGSjtJQUFBLElBR0lDLE9BSEoseUJBR0lBLE9BSEo7SUFBQSxJQUlJQyw2QkFKSix5QkFJSUEsNkJBSko7SUFBQSxJQUtJQyw2QkFMSix5QkFLSUEsNkJBTEo7SUFRQSxLQUFLQyxRQUFMLEdBQWdCO01BQ1pMLE9BQU8sRUFBUEEsT0FEWTtNQUVaQyxPQUFPLEVBQVBBLE9BRlk7TUFHWkMsT0FBTyxFQUFQQSxPQUhZO01BSVpDLDZCQUE2QixFQUE3QkEsNkJBSlk7TUFLWkMsNkJBQTZCLEVBQTdCQTtJQUxZLENBQWhCO0lBUUEsSUFDSUUsYUFESixHQUdJLEtBQUtkLGdCQUFMLENBQXNCZSw0QkFBdEIsQ0FBbURULE9BSHZELENBQ0lRLGFBREo7SUFLQSxJQUNJRSxRQURKLEdBRUksS0FBS2hCLGdCQUFMLENBQXNCSywyQkFBdEIsQ0FBa0RDLE9BRnRELENBQ0lVLFFBREosQ0F6QndCLENBNkJ4Qjs7SUFDQSxLQUFLQyxrQkFBTCxDQUF3QmQsd0JBQXhCLEdBQ0tlLElBQUksQ0FBQ0MsR0FBTCxDQUFTTCxhQUFULEVBQXdCRSxRQUFRLEdBQUcsQ0FBbkMsS0FBMEMsQ0FEL0M7SUFFQSxLQUFLQyxrQkFBTCxDQUF3QmIsNkJBQXhCLEdBQXdELENBQXhEO0VBRUg7Ozs7U0FJRCxlQUEwQjtNQUV0QixJQUNJZ0IsV0FESixHQUdJLEtBQUtwQixnQkFBTCxDQUFzQmUsNEJBQXRCLENBQW1EVCxPQUh2RCxDQUNJYyxXQURKO01BS0EsT0FBUUEsV0FBVyxJQUFJLFVBQWhCLEdBQ0gsS0FBS1AsUUFBTCxDQUFjRCw2QkFBZCxDQUE0Q04sT0FBNUMsQ0FBb0RlLFNBQXBELEdBQ0EsS0FBS1IsUUFBTCxDQUFjRiw2QkFBZCxDQUE0Q0wsT0FBNUMsQ0FBb0RlLFNBRmpELEdBR0g7TUFDQSxLQUFLUixRQUFMLENBQWNELDZCQUFkLENBQTRDTixPQUE1QyxDQUFvRGdCLFVBQXBELEdBQ0EsS0FBS1QsUUFBTCxDQUFjRiw2QkFBZCxDQUE0Q0wsT0FBNUMsQ0FBb0RnQixVQUx4RDtJQU1IOzs7Ozs7QUFyRExDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL2xheW91dGhhbmRsZXIudHN4PzA3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGF5b3V0aGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgaG9sZHMgcmVmZXJlbmNlcyB0byBcbiAgICAtIHRoZSBzdHJ1Y3R1cmFsIGVsZW1lbnRzIG9mIHRoZSBjcmFkbGVcbiAgICAtIHRoZSBrZXkgY29udHJvbCB2YWx1ZXMgb2YgdGhlIGNyYWRsZVxuXG4gICAgVGhlIHN0cnVjdHVyYWwgZWxlbWVudHMgYXJlIHRoZSBheGlzLCBoZWFkIChncmlkKSwgdGFpbCAoZ3JpZCksIFxuICAgICAgICBhbmQgdGhlIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRyaWdnZXJsaW5lc1xuICAgIFRoZSBrZXkgY29udHJvbCB2YWx1ZXMgYXJlIHRoZSBibG9ja1Njcm9sbFBvcyAoc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpLCB0aGUgYmxvY2sgc2Nyb2xsXG4gICAgICAgIHByb3BlcnR5IChcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiKSwgdGhlIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAoZmlyc3QgaW5kZXggb2YgdGhlXG4gICAgICAgIHRhaWwgYmxvY2spLCBhbmQgdGhlIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IChwaXhlbHMgb2Zmc2V0IGZyb20gdGhlIGVkZ2Ugb2YgdGhlIFxuICAgICAgICB2aWV3cG9ydClcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheW91dEhhbmRsZXIgeyBcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYXhpc1JlZiwgXG4gICAgICAgICAgICBoZWFkUmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLFxuICAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5jcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnRzID0ge1xuICAgICAgICAgICAgYXhpc1JlZixcbiAgICAgICAgICAgIGhlYWRSZWYsXG4gICAgICAgICAgICB0YWlsUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZixcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gcHJvZ3Jlc3Npb24gb2YgcmVmZXJlbmNlczogaW1wbGllZC0+dGFyZ2V0XG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IFxuICAgICAgICAgICAgKE1hdGgubWluKHN0YXJ0aW5nSW5kZXgsKGxpc3RzaXplIC0gMSkpIHx8IDApXG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gMFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0IHRyaWdnZXJsaW5lU3BhbigpIHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgcmV0dXJuIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudC5vZmZzZXRUb3AgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0TGVmdCAtIFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50Lm9mZnNldExlZnRcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJpZ2dlcmNlbGxJbmRleFxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbElzSW5UYWlsID0gZmFsc2VcblxuICAgIC8vIGNyYWRsZVBvc2l0aW9uRGF0YSBjb250cm9scyB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIHRoZSBzY2FmZm9sZCBlbGVtZW50c1xuICAgIHB1YmxpYyBjcmFkbGVQb3NpdGlvbkRhdGEgPSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFwiYmxvY2tcIiA9IGNyYWRsZWJsb2NrLCB3aGljaCBpcyB0aGUgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGVkXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHNldCBieSBzY3JvbGxIYW5kbGVyIGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsaW5nLFxuICAgICAgICAgICAgYW5kIGJ5IHNldENyYWRsZUNvbnRlbnQgaW4gY29udGVudEhhbmRsZXIsIHdoaWNoIHJlcG9zaXRpb25zIHRoZSBjcmFkbGUuXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIGNyYWRsZSBpbml0aWFsaXphdGlvbiBpbiByZXNwb25zZSB0byByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICBibG9ja1Njcm9sbFBvczpudWxsLCAvLyB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnRcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdmFsdWVzIGNhbiBiZSBcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiIChvZiB0aGUgdmlld3BvcnQgZWxlbWVudCkgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBvcmllbnRhdGlvbiByZWNvbmZpZ3VyYXRpb24gZWZmZWN0IGluIGNyYWRsZSBtb2R1bGUuXG5cbiAgICAgICAgICAgIGl0IGlzIHVzZWQgd2hlcmUgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBhYm92ZS5cbiAgICAgICAgKi9cbiAgICAgICAgYmxvY2tTY3JvbGxQcm9wZXJ0eTpudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgc2V0IGJ5XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSBsYXlvdXRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gaG9zdCBzY3JvbGxUb0l0ZW0gY2FsbFxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsVHJhY2tlckFyZ3MgaW4gY3JhZGxlIG1vZHVsZVxuICAgICAgICAgICAgICAgIC0gcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGluIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Om51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHNldCBieVxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gbGF5b3V0SGFuZGxlciAoaW5pdGlhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgLSBzY3JvbGxIYW5kbGVyIChkdXJpbmcgYW5kIGFmdGVyIHNjcm9sbClcbiAgICAgICAgICAgICAgICAtIHBpdm90IGVmZmVjdCAoY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBpbiBjcmFkbGUgbW9kdWxlXG5cbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIHByZXZpb3VzQXhpc09mZnNldCBpbiBwaXZvdCBlZmZlY3RcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDpudWxsLCAvLyBpbnRvIHRoZSB2aWV3cG9ydFxuXG4gICAgfVxuXG4gICAgcHVibGljIGVsZW1lbnRzXG5cbn0iXSwibmFtZXMiOlsiTGF5b3V0SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImN1cnJlbnQiLCJjcmFkbGVFbGVtZW50c1JlZiIsImF4aXNSZWYiLCJoZWFkUmVmIiwidGFpbFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJlbGVtZW50cyIsInN0YXJ0aW5nSW5kZXgiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwibGlzdHNpemUiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJNYXRoIiwibWluIiwib3JpZW50YXRpb24iLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(" // scrollhandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferenceIndex, and\n        targetAxisViewportPixelOffset\n*/\n\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ScrollHandler);\n\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        scrollerID = _this$cradleParameter.scrollerID,\n        SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _this$cradleParameter.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current; // const scrollblockElement = viewportElement.firstChild\n    // const top = scrollblockElement.offsetTop\n    // scrollblockElement.style.top = (top + 5) + 'px'\n\n    var scrollPositionCurrent = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData; // keep up to date in case of reparenting interrupt\n\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter2.contentHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler;\n\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        _this.calcImpliedRepositioningData();\n\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n\n    _this._scrolltimerid = setTimeout(function () {\n      // console.log('calling onAfterScroll',SCROLL_TIMEOUT_FOR_ONAFTERSCROLL)\n      _this.onAfterScroll();\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n    return false;\n  };\n\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter3.stateHandler,\n        contentHandler = _this$cradleParameter3.contentHandler,\n        serviceHandler = _this$cradleParameter3.serviceHandler;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n\n          break;\n        }\n    }\n\n    var cache = cradleInheritedProperties.cache,\n        layout = cradleInheritedProperties.layout;\n\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n\n    if (!['repositioningRender', 'repositioningContinuation'].includes(cradleState) && layout == 'variable') {\n      if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n        stateHandler.setCradleState('adjustupdateforvariabilityafterscroll');\n      }\n    }\n  }; // after scroll, but not after repositioning\n\n\n  this.updateReferenceData = function () {\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter4.stateHandler,\n        layoutHandler = _this$cradleParameter4.layoutHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var axisVisiblePixelOffset;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n\n    if (cradleProps.orientation == 'vertical') {\n      axisVisiblePixelOffset = axisElement.offsetTop - viewportElement.scrollTop; // console.log('scrollHandler: updating targetAxisViewportPixelOffset, axisElement.offsetTop, viewportElement.scrollTop', \n      //     axisVisiblePixelOffset, axisElement.offsetTop, viewportElement.scrollTop)\n    } else {\n      axisVisiblePixelOffset = axisElement.offsetLeft - viewportElement.scrollLeft;\n    }\n\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisVisiblePixelOffset;\n\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  }; // called from finishreposition state change call above\n  // called from updateReferenceData\n\n\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n      }\n    }\n  };\n\n  this.calcImpliedRepositioningData = function () {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var crosscount = cradleConfig.crosscount,\n        listsize = cradleConfig.listsize;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var orientation = cradleProps.orientation;\n    var scrollPos, cellLength;\n\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n    }\n\n    var axisPixelOffset = cellLength - scrollPos % cellLength;\n\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex; // console.log('scrollHandler.calcImpliedRepositioningData setting targetAxisViewportPixelOffset',\n    //     axisPixelOffset)\n\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n    var repositioningIndexCallback = _this.cradleParameters.handlersRef.current.serviceHandler.callbacks.repositioningIndexCallback;\n    repositioningIndexCallback && repositioningIndexCallback(axisReferenceIndex);\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZSxHQUFHLENBQWxCLENBakNXLENBaUNTOztJQUVqRCxJQUFReEMsa0JBQVIsR0FBK0IsS0FBSSxDQUFDOUIsZ0JBQUwsQ0FBc0J5QixXQUF0QixDQUFrQ3ZCLE9BQWxDLENBQTBDMkIsYUFBekUsQ0FBUUMsa0JBQVI7SUFDQUEsa0JBQWtCLENBQUNnRCx3QkFBbkIsR0FBOENILGtCQUE5QyxDQXBDd0MsQ0FxQ3hDO0lBQ0E7O0lBQ0E3QyxrQkFBa0IsQ0FBQzhCLDZCQUFuQixHQUFtRFUsZUFBbkQ7SUFDQSxJQUFRUywwQkFBUixHQUNJLEtBQUksQ0FBQy9FLGdCQUFMLENBQXNCeUIsV0FBdEIsQ0FBa0N2QixPQUFsQyxDQUEwQ2tDLGNBQTFDLENBQXlEUyxTQUQ3RCxDQUFRa0MsMEJBQVI7SUFFQUEsMEJBQTBCLElBQUlBLDBCQUEwQixDQUFDSixrQkFBRCxDQUF4RDtFQUVILENBNUNPOztFQTFPSixLQUFLM0UsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUVILEM7O0FBTkxnRixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSByZXNwb25zZSB0byBzY3JvbGxpbmcuIEl0IGFsc28gdHJpZ2dlcnMgYW4gb25BZnRlclNjcm9sbCBldmVudCAoYWZ0ZXIgYSB0aW1lb3V0KVxuICAgIEl0J3MgbWFpbiBqb2IgaXMgdG8gbWFpbnRhaW4gcmVjb3JkcyBvZiBzY3JvbGxQb3MsIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyByZXNldFNjcm9sbERhdGEgPSAoc2Nyb2xsUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSB0aGlzXG4gICAgICAgIHNjcm9sbERhdGEuc3RhcnQgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50ID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXMgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IFxuICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlcklELCBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcbiAgICAgICAgLy8gY29uc3QgdG9wID0gc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldFRvcFxuICAgICAgICAvLyBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gKHRvcCArIDUpICsgJ3B4J1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uQ3VycmVudCA9IFxuICAgICAgICAgICAgKHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY3JvbGx0aW1lcmlkKVxuXG4gICAgICAgIGlmICgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDAgICYmIHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uQ3VycmVudCA8IDApIHsgLy8gZm9yIFNhZmFyaVxuXG4gICAgICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtzaWduYWxzfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmludGVycnVwdEhhbmRsZXJcblxuICAgICAgICBpZiAoc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1Njcm9sbGluZykge1xuXG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxEYXRhLnN0YXJ0ID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuY3VycmVudHVwZGF0ZSA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7bGF5b3V0SGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIC8vIGtlZXAgdXAgdG8gZGF0ZSBpbiBjYXNlIG9mIHJlcGFyZW50aW5nIGludGVycnVwdFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMgPSB0aGlzLnNjcm9sbERhdGEuY3VycmVudFxuICAgICAgICB0aGlzLnNjcm9sbERhdGEuY3VycmVudCA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtzdGF0ZUhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY29udGVudEhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nKSB7XG5cbiAgICAgICAgICAgIGlmICgoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSB8fCAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhKClcbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGxpbmcgb25BZnRlclNjcm9sbCcsU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwpXG5cbiAgICAgICAgICAgIHRoaXMub25BZnRlclNjcm9sbCgpXG5cbiAgICAgICAgfSxTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTClcblxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBvbkFmdGVyU2Nyb2xsID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHtzdGF0ZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlcn0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlU3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6IFxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayAmJiByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrKGZhbHNlKVxuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnZmluaXNocmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc2Nyb2xsRGF0YS5zdGFydCAhPSB0aGlzLnNjcm9sbERhdGEuY3VycmVudCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNjcm9sbERhdGEuY3VycmVudCAhPSB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIGxheW91dCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5wYXJlQ2FjaGVUb01heCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVsncmVwb3NpdGlvbmluZ1JlbmRlcicsJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkgJiZcbiAgICAgICAgICAgIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykpIHtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLnNjcm9sbERhdGEuc3RhcnQgIT0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQpIHx8IFxuICAgICAgICAgICAgICAgICh0aGlzLnNjcm9sbERhdGEuY3VycmVudCAhPSB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMpKSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5YWZ0ZXJzY3JvbGwnKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGFmdGVyIHNjcm9sbCwgYnV0IG5vdCBhZnRlciByZXBvc2l0aW9uaW5nXG4gICAgcHJpdmF0ZSB1cGRhdGVSZWZlcmVuY2VEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBsYXlvdXRIYW5kbGVyIH0gXG4gICAgICAgICAgICA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKCFzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGxldCBheGlzVmlzaWJsZVBpeGVsT2Zmc2V0XG4gICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gbGF5b3V0SGFuZGxlci5lbGVtZW50c1xuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIGlmIChjcmFkbGVQcm9wcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQgPSBheGlzRWxlbWVudC5vZmZzZXRUb3AgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2Nyb2xsSGFuZGxlcjogdXBkYXRpbmcgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIGF4aXNFbGVtZW50Lm9mZnNldFRvcCwgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCcsIFxuICAgICAgICAgICAgLy8gICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQsIGF4aXNFbGVtZW50Lm9mZnNldFRvcCwgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYXhpc1Zpc2libGVQaXhlbE9mZnNldCA9IGF4aXNFbGVtZW50Lm9mZnNldExlZnQgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBmaW5pc2hyZXBvc2l0aW9uIHN0YXRlIGNoYW5nZSBjYWxsIGFib3ZlXG4gICAgLy8gY2FsbGVkIGZyb20gdXBkYXRlUmVmZXJlbmNlRGF0YVxuICAgIHByaXZhdGUgdXBkYXRlQmxvY2tTY3JvbGxQb3MgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHtsYXlvdXRIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoISgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDApICAmJiAodmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbmZpZyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY3Jvc3Njb3VudCwgbGlzdHNpemUgfSA9IGNyYWRsZUNvbmZpZ1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IG9yaWVudGF0aW9uIH0gPSBjcmFkbGVQcm9wc1xuICAgICAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0ICsgY3JhZGxlUHJvcHMuZ2FwXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF4aXNQaXhlbE9mZnNldCA9IGNlbGxMZW5ndGggLSAoc2Nyb2xsUG9zICUgY2VsbExlbmd0aClcbiAgICAgICAgaWYgKGF4aXNQaXhlbE9mZnNldCA9PSAoY2VsbExlbmd0aCArIGNyYWRsZVByb3BzLnBhZGRpbmcpKSB7XG4gICAgICAgICAgICBheGlzUGl4ZWxPZmZzZXQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzUm93SW5kZXggPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVByb3BzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG4gICAgICAgIGxldCBheGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUm93SW5kZXggKiBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKGF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG4gICAgICAgIGNvbnN0IGRpZmYgPSBheGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCAtPSBkaWZmXG5cbiAgICAgICAgaWYgKGF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKSBheGlzUGl4ZWxPZmZzZXQgPSAwIC8vIGRlZmVuc2l2ZVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Njcm9sbEhhbmRsZXIuY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSBzZXR0aW5nIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0JyxcbiAgICAgICAgLy8gICAgIGF4aXNQaXhlbE9mZnNldClcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1BpeGVsT2Zmc2V0XG4gICAgICAgIGNvbnN0IHsgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG4gICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrKGF4aXNSZWZlcmVuY2VJbmRleClcblxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbIlNjcm9sbEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwic3RhcnQiLCJjdXJyZW50IiwicHJldmlvdXMiLCJwcmV2aW91c3VwZGF0ZSIsImN1cnJlbnR1cGRhdGUiLCJzY3JvbGxQb3NpdGlvbiIsInNjcm9sbERhdGEiLCJlIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVySUQiLCJTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsInNjcm9sbFBvc2l0aW9uQ3VycmVudCIsIm9yaWVudGF0aW9uIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImNsZWFyVGltZW91dCIsIl9zY3JvbGx0aW1lcmlkIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzaWduYWxzIiwiaGFuZGxlcnNSZWYiLCJpbnRlcnJ1cHRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiaXNTY3JvbGxpbmciLCJsYXlvdXRIYW5kbGVyIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYmxvY2tTY3JvbGxQb3MiLCJzdGF0ZUhhbmRsZXIiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiY29udGVudEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImlzUmVzaXppbmciLCJjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhIiwic2V0Q3JhZGxlU3RhdGUiLCJzZXRUaW1lb3V0Iiwib25BZnRlclNjcm9sbCIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJ1cGRhdGVCbG9ja1Njcm9sbFBvcyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJpc01vdW50ZWRSZWYiLCJ1cGRhdGVSZWZlcmVuY2VEYXRhIiwiY2FjaGUiLCJsYXlvdXQiLCJwYXJlQ2FjaGVUb01heCIsImluY2x1ZGVzIiwiY3JhZGxlUHJvcHMiLCJheGlzVmlzaWJsZVBpeGVsT2Zmc2V0IiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZUNvbmZpZyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImNyb3NzY291bnQiLCJsaXN0c2l6ZSIsInNjcm9sbFBvcyIsImNlbGxMZW5ndGgiLCJjZWxsSGVpZ2h0IiwiZ2FwIiwiY2VsbFdpZHRoIiwiYXhpc1BpeGVsT2Zmc2V0IiwicGFkZGluZyIsImF4aXNSb3dJbmRleCIsIk1hdGgiLCJjZWlsIiwiYXhpc1JlZmVyZW5jZUluZGV4IiwibWluIiwiZGlmZiIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // servicehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streas, see the constructor.\n\n    The function calls avaiable to the host are:\n        scrollToItem,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n        remapIndexes,\n        moveIndex,\n        insertIndex,\n        removeIndex,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions in cacheHandler and contentHandler. stateHandler is\n    often invoked to change state upon servicing requests.\n*/\n\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ServiceHandler);\n\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState(\'reload\');\n  };\n\n  this.scrollToItem = function (index) {\n    index = Math.max(0, index);\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        layoutHandler = _this$cradleParameter.layoutHandler,\n        stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState(\'scrollto\');\n  };\n\n  this.setListsize = function (newlistsize) {\n    newlistsize = Math.max(0, newlistsize);\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter2.cacheHandler,\n        stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n        deleteListCallback = _this$callbacks.deleteListCallback,\n        changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback(\'change list size intervention\', deleteList);\n      };\n    }\n\n    cacheHandler.changeListsize(newlistsize, dListCallback, changeListsizeCallback);\n\n    if (cache == \'preload\' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState(\'startpreload\');\n    }\n  }; // ======================[ GET SNAPSHOTS ]========================\n\n\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter3.cacheHandler,\n        contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  }; // =================[ CACHE MANAGEMENT REQUESTS ]==================\n\n\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState(\'clearcache\');\n    return true;\n  };\n\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter4.cacheHandler,\n        contentHandler = _this$cradleParameter4.contentHandler,\n        stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n        metadataMap = _cacheHandler$cachePr.metadataMap,\n        portalMap = _cacheHandler$cachePr.portalMap,\n        indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map(); // =====================[ PREPARATION ]======================\n    // ------------ filter out inoperable indexes and itemIDs ------------\n\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == \'string\') {\n          errorEntriesMap.set(index, \'itemID is a string\');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, \'itemID is not an integer\');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, \'index not in cache\');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " has not changed"));\n        } else if (!metadataMap.has(itemID)) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " not in cache"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    }); // -------------- filter out duplicate itemIDs ------------\n\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, "target itemID ".concat(itemID, " has duplicates (").concat(count, ")"));\n        changeIndexToItemIDMap["delete"](index);\n      });\n    } // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n\n\n    var originalMap = new Map(); // index => itemID; before change\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    }); // ... and from the list of indexes to be deleted\n\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    }); // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID\'s will be orphaned, but could be remapped.\n    // orphans are resolved below\n\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap["delete"](index);\n      });\n    } // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n\n\n    var processedIndexList = []; // make changes\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n\n      processedIndexList.push(index);\n    }); // -------------- look for and delete item and index orphans --------------------\n    // if the original item\'s index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item\'s index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n\n    var deletedIndexToItemIDMap = new Map();\n    var portalHoldList = []; // hold deleted portals for deletion until after cradle synch\n\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        metadataMap["delete"](originalItemID);\n        portalHoldList.push(originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap["delete"](originalItemIDIndex);\n          }\n        }\n      }\n    }); // refresh the modified cache\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList(); // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys()); // for return information...\n\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    cacheHandler.portalHoldList = portalHoldList;\n    stateHandler.setCradleState(\'applycellframechanges\'); // ---------- returns for user information --------------------\n\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  }; // move must be entirely within list bounds\n  // returns list of processed indexes\n\n\n  this.moveIndex = function (toindex, fromindex) {\n    var highrange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------- define parameters ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // remove nulls\n\n    toindex = toindex !== null && toindex !== void 0 ? toindex : 0;\n    fromindex = fromindex !== null && fromindex !== void 0 ? fromindex : 0;\n    highrange = highrange !== null && highrange !== void 0 ? highrange : fromindex;\n    toindex = Math.max(0, toindex);\n    fromindex = Math.max(0, fromindex);\n    highrange = Math.max(0, highrange); // keep within current list size\n\n    var listbound = listsize - 1;\n    toindex = toindex > listbound ? listbound : toindex;\n    fromindex = fromindex > listbound ? listbound : fromindex;\n    highrange = highrange > listbound ? listbound : highrange; // highrange must be >= fromindex\n\n    highrange = highrange >= fromindex ? highrange : fromindex;\n    var rangeincrement = highrange - fromindex + 1;\n    var moveincrement = toindex - fromindex; // ---------- constrain parameters --------------\n\n    if (fromindex == toindex) return []; // nothing to do\n    // move must be in list bounds\n\n    if (moveincrement > 0) {\n      // move up\n      var targettop = toindex + (rangeincrement - 1);\n      if (targettop > listbound) return []; // out of bounds\n    } // ----------- perform cache and cradle operations -----------\n\n\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter5.cacheHandler,\n        contentHandler = _this$cradleParameter5.contentHandler,\n        stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList = cacheHandler.moveIndex(toindex, fromindex, highrange);\n\n    if (processedIndexList.length) {\n      cacheHandler.cacheProps.modified = true;\n      cacheHandler.renderPortalList();\n      contentHandler.changeCradleItemIDs(processedIndexList);\n      stateHandler.setCradleState(\'applycellframechanges\');\n    }\n\n    return processedIndexList;\n  };\n\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  }; // shared logic. Returns lists of items changed, and items replaced (new items for insert)\n  // this operation changes the listsize\n\n\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    index = index !== null && index !== void 0 ? index : 0;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter6.cacheHandler,\n        contentHandler = _this$cradleParameter6.contentHandler,\n        stateHandler = _this$cradleParameter6.stateHandler;\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n        _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 4),\n        changeList = _cacheHandler$insertR2[0],\n        replaceList = _cacheHandler$insertR2[1],\n        rangeincrement = _cacheHandler$insertR2[2],\n        portalHoldList = _cacheHandler$insertR2[3];\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList();\n    cacheHandler.portalHoldList = portalHoldList;\n    contentHandler.changeCradleItemIDs(changeList);\n    if (increment == +1) contentHandler.createNewItemIDs(replaceList);\n    var content = contentHandler.content;\n    stateHandler.setCradleState(\'applycellframechanges\');\n    var changecount = rangeincrement; // semantics\n\n    var newlistsize = listsize + changecount;\n\n    _this.setListsize(newlistsize);\n\n    return [changeList, replaceList];\n  };\n\n  this.cradleParameters = cradleParameters; // doing this explicitly here for documentation\n\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n      referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n      preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n      deleteListCallback = _cradleParameters$ext.deleteListCallback,\n      changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n      itemExceptionsCallback = _cradleParameters$ext.itemExceptionsCallback,\n      repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionsCallback: itemExceptionsCallback,\n    repositioningFlagCallback: repositioningFlagCallback\n  };\n  this.callbacks = callbacks;\n});\n\nexports["default"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LHNCQUxKO0VBQUEsSUFNSUMseUJBTkoseUJBTUlBLHlCQU5KO0VBVUEsSUFBTXhGLFNBQVMsR0FBRztJQUNkcUYsc0JBQXNCLEVBQXRCQSxzQkFEYztJQUVkQyxvQkFBb0IsRUFBcEJBLG9CQUZjO0lBR2RyRixrQkFBa0IsRUFBbEJBLGtCQUhjO0lBSWRDLHNCQUFzQixFQUF0QkEsc0JBSmM7SUFLZHFGLHNCQUFzQixFQUF0QkEsc0JBTGM7SUFNZEMseUJBQXlCLEVBQXpCQTtFQU5jLENBQWxCO0VBU0EsS0FBS3hGLFNBQUwsR0FBaUJBLFNBQWpCO0FBRUYsQzs7QUE1Qkx5RixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zZXJ2aWNlaGFuZGxlci50c3g/OWNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgZmllbGRzIHNlcnZpY2UgcmVxdWVzdHMgZnJvbSB0aGUgaG9zdC4gVGhlcmUgYXJlIHR3byBmb3Jtc1xuICAgIC0gc3RyZWFtaW5nIGZyb20gdGhlIHNjcm9sbGVyIHRvIHRoZSBob3N0XG4gICAgLSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSB1c2VyIHRvIHRoZSBzY3JvbGxlclxuXG4gICAgRm9yIHRoZSBsaXN0IG9mIGRhdGEgc3RyZWFzLCBzZWUgdGhlIGNvbnN0cnVjdG9yLlxuXG4gICAgVGhlIGZ1bmN0aW9uIGNhbGxzIGF2YWlhYmxlIHRvIHRoZSBob3N0IGFyZTpcbiAgICAgICAgc2Nyb2xsVG9JdGVtLCBcbiAgICAgICAgcmVsb2FkLCBcbiAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgIGdldENhY2hlSW5kZXhNYXAsIFxuICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgIHJlbW92ZUluZGV4LFxuICAgIFxuICAgIFRoZSBmdW5jdGlvbnMgbGlzdGVkIGFyZSBkZWZpbmVkIGluIHRoaXMgbW9kdWxlLlxuXG4gICAgVGhlcmUgYXJlIGltcG9ydGFudCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBpbiBjYWNoZUhhbmRsZXIgYW5kIGNvbnRlbnRIYW5kbGVyLiBzdGF0ZUhhbmRsZXIgaXNcbiAgICBvZnRlbiBpbnZva2VkIHRvIGNoYW5nZSBzdGF0ZSB1cG9uIHNlcnZpY2luZyByZXF1ZXN0cy5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcnZpY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIC8vIGRvaW5nIHRoaXMgZXhwbGljaXRseSBoZXJlIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICAgY29uc3Qge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgsIGxvY2F0aW9uLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIC8vIChpbmRleClcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLCAvLyAocmVhc29uLCBkZWxldGVMaXN0KVxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLCAvLyAobmV3bGlzdHNpemUpXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssIC8vIChpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgbG9jYXRpb24sIGVycm9yKVxuICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLCAvLyAoZmxhZykgLy8gYm9vbGVhblxuICAgICAgICAgICBcbiAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5leHRlcm5hbENhbGxiYWNrc1JlZi5jdXJyZW50XG5cbiAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgLy8gc2VlIGFib3ZlIGZvciBsaXN0XG4gICAgcHVibGljIGNhbGxiYWNrc1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBHRU5FUkFMIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgcmVsb2FkID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgaW50ZXJydXB0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc2Nyb2xsVG9JdGVtID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLGluZGV4KVxuXG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuICAgICAgICBjb25zdCB7IGxheW91dEhhbmRsZXIsIHN0YXRlSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IGluZGV4XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzY3JvbGx0bycpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0TGlzdHNpemUgPSAobmV3bGlzdHNpemUpID0+IHtcblxuICAgICAgICBuZXdsaXN0c2l6ZSA9IE1hdGgubWF4KDAsbmV3bGlzdHNpemUpXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjayB9ID0gdGhpcy5jYWxsYmFja3NcblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplOmN1cnJlbnRsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnY2hhbmdlIGxpc3Qgc2l6ZSBpbnRlcnZlbnRpb24nLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLmNoYW5nZUxpc3RzaXplKG5ld2xpc3RzaXplLCBcbiAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrXG4gICAgICAgIClcblxuICAgICAgICBpZiAoKGNhY2hlID09ICdwcmVsb2FkJykgJiYgKG5ld2xpc3RzaXplID4gY3VycmVudGxpc3RzaXplKSkge1xuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBHRVQgU05BUFNIT1RTIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBnZXRDYWNoZUluZGV4TWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJbmRleE1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJdGVtTWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJdGVtTWFwKClcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDcmFkbGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q3JhZGxlSW5kZXhNYXAobW9kZWxJbmRleExpc3QpXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT1bIENBQ0hFIE1BTkFHRU1FTlQgUkVRVUVTVFMgXT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdjbGVhcmNhY2hlJylcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgcHVibGljIHJlbWFwSW5kZXhlcyA9IChjaGFuZ2VNYXApID0+IHsgLy8gaW5kZXggPT4gaXRlbUlEXG5cbiAgICAgICAgaWYgKGNoYW5nZU1hcC5zaXplID09IDApIHJldHVybiBbXSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBtZXRhZGF0YU1hcCwgLy8gaXRlbUlEIHRvIGNvbXBvbmVudCBkYXRhLCBpbmNsdWRpbmcgaW5kZXhcbiAgICAgICAgICAgIHBvcnRhbE1hcCwgLy8gdHdpbm5lZCB3aXRoIG1ldGFkYXRhTWFwIGZvciBwb3J0YWxcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAgLy8gaW5kZXggdG8gaXRlbUlEXG5cbiAgICAgICAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzIFxuXG4gICAgICAgIGNvbnN0IGluZGV4ZXNUb0RlbGV0ZUxpc3QgPSBbXVxuICAgICAgICBjb25zdCBjaGFuZ2VJbmRleFRvSXRlbUlETWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGNvbnN0IGVycm9yRW50cmllc01hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgUFJFUEFSQVRJT04gXT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gZmlsdGVyIG91dCBpbm9wZXJhYmxlIGluZGV4ZXMgYW5kIGl0ZW1JRHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY2hhbmdlTWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+e1xuXG4gICAgICAgICAgICBpZiAoKGl0ZW1JRCA9PT0gbnVsbCkgfHwgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvRGVsZXRlTGlzdC5wdXNoKGluZGV4KVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgaXRlbUlEKSA9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsJ2l0ZW1JRCBpcyBhIHN0cmluZycpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgbm90IGFuIGludGVnZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgJ2luZGV4IG5vdCBpbiBjYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSA9PSBpdGVtSUQpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCBgdGFyZ2V0IGl0ZW1JRCAke2l0ZW1JRH0gaGFzIG5vdCBjaGFuZ2VkYClcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1ldGFkYXRhTWFwLmhhcyhpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IG5vdCBpbiBjYWNoZWApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgZHVwbGljYXRlIGl0ZW1JRHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgbWFwc2l6ZSA9IGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2l6ZVxuXG4gICAgICAgIGNvbnN0IGl0ZW1JRFNldCA9IG5ldyBTZXQoY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC52YWx1ZXMoKSlcblxuICAgICAgICBjb25zdCBpdGVtc2V0c2l6ZSA9IGl0ZW1JRFNldC5zaXplXG5cbiAgICAgICAgaWYgKG1hcHNpemUgIT0gaXRlbXNldHNpemUpIHsgLy8gdGhlcmUgbXVzdCBiZSBkdXBsaWNhdGUgaXRlbUlEc1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSURDb3VudE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlEQ291bnRNYXAuaGFzKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCAxKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBpdGVtSURDb3VudE1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCArK2NvdW50IClcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZUl0ZW1zTWFwID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBpdGVtSURDb3VudE1hcC5mb3JFYWNoKChjb3VudCxpdGVtSUQpPT57XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlSXRlbXNNYXAuc2V0KGl0ZW1JRCwgY291bnQpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCA9IFtdXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJdGVtc01hcC5oYXMoaXRlbUlEKSkge1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LnB1c2goaW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LmZvckVhY2goKGluZGV4KT0+e1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkdXBsaWNhdGVJdGVtc01hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBkdXBsaWNhdGVzICgke2NvdW50fSlgKVxuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gY2FwdHVyZSBtYXAgYmVmb3JlIGNoYW5nZXMgLS0tLS0tLS0tLVxuICAgICAgICAvLyAuLi4gdGhpcyBtYXAgaXMgdXNlZCBsYXRlciB0byBpZGVudGlmeSBvcnBoYW5lZCBpdGVtIGFuZCBpbmRleCBjYWNoZSByZWNvcmRzIGZvciBkZWxldGlvblxuXG4gICAgICAgIC8vIGZyb20gdGhlIGxpc3Qgb2YgY2hhbmdlc1xuICAgICAgICAvLyBib3RoIHNpZGVzIG9mIGNoYW5nZSBtYXAuLi5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBiZWZvcmUgY2hhbmdlXG4gICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCk9PntcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSkgLy8gaW5kZXggdG8gYmUgbWFwcGVkXG4gICAgICAgICAgICBvcmlnaW5hbE1hcC5zZXQobWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXgsaXRlbUlEKSAvLyB0YXJnZXQgaXRlbUlEXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAuLi4gYW5kIGZyb20gdGhlIGxpc3Qgb2YgaW5kZXhlcyB0byBiZSBkZWxldGVkXG4gICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBPUEVSQVRJT05TIF09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRlbGV0ZSBsaXN0ZWQgaW5kZXhlcyAtLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIGluZGV4ZXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgaXRlbUlEJ3Mgd2lsbCBiZSBvcnBoYW5lZCwgYnV0IGNvdWxkIGJlIHJlbWFwcGVkLlxuICAgICAgICAvLyBvcnBoYW5zIGFyZSByZXNvbHZlZCBiZWxvd1xuXG4gICAgICAgIGlmIChpbmRleGVzVG9EZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gYXBwbHkgZmlsdGVyZWQgY2hhbmdlcyB0byBjYWNoZSBpbmRleCBtYXAgYW5kIGl0ZW1JRCBtYXAgLS0tLS0tLS0tLVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGV2ZXJ5IHJlbWFpbmluZyBpbmRleCBsaXN0ZWQgd2lsbCBjaGFuZ2UgaXRzIG1hcHBpbmdcblxuICAgICAgICAvLyBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICBpdGVtZGF0YS5pbmRleCA9IGluZGV4IC8vIG1vZGlmaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDJcblxuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkTWFwLnNldChpbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBwcm9jZXNzZWRJbmRleExpc3QucHVzaChpbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGxvb2sgZm9yIGFuZCBkZWxldGUgaXRlbSBhbmQgaW5kZXggb3JwaGFucyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luYWwgaXRlbSdzIGluZGV4IGhhcyBub3QgY2hhbmdlZCwgdGhlbiBpdCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIFxuICAgICAgICAvLyAgICAgaXQgaXMgb3JwaGFuZWQsIGFuZCB0aGUgaXRlbSBpcyBkZWxldGVkXG4gICAgICAgIC8vIGlmIHRoZSBpdGVtJ3MgaW5kZXggaGFzIGNoYW5nZWQsIGJ1dCB0aGUgb3JpZ2luYWwgaXRlbSBpbmRleCBtYXAgc3RpbGwgcG9pbnRzIHRvIHRoZSBpdGVtLFxuICAgICAgICAvLyAgICAgdGhlbiB0aGUgaW5kZXggaXMgb3JwaGFuZWQgKGR1cGxpY2F0ZSksIGFuZCBkZWxldGVkXG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBvcnBoYW5lZCBpbmRleFxuICAgICAgICBjb25zdCBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEhvbGRMaXN0ID0gW10gLy8gaG9sZCBkZWxldGVkIHBvcnRhbHMgZm9yIGRlbGV0aW9uIHVudGlsIGFmdGVyIGNyYWRsZSBzeW5jaFxuXG4gICAgICAgIG9yaWdpbmFsTWFwLmZvckVhY2goKG9yaWdpbmFsSXRlbUlELCBvcmlnaW5hbEl0ZW1JREluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsSXRlbUlESW5kZXggPSBtZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpLmluZGV4XG5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEl0ZW1JREluZGV4ID09IGZpbmFsSXRlbUlESW5kZXgpIHsgLy8gbm90IHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLnNldChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleClcblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JRClcbiAgICAgICAgICAgICAgICBwb3J0YWxIb2xkTGlzdC5wdXNoKG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZW1hcHBlZCwgY2hlY2sgZm9yIG9ycGhhbmVkIGluZGV4XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0l0ZW1JRE1hcC5oYXMob3JpZ2luYWxJdGVtSURJbmRleCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSXRlbUlEID09IG9yaWdpbmFsSXRlbUlEKSB7IC8vIHRoZSBpbmRleCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIHRoZXJlZm9yZSBvcnBoYW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcC5zZXQob3JpZ2luYWxJdGVtSURJbmRleCwgb3JpZ2luYWxJdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyByZWZyZXNoIHRoZSBtb2RpZmllZCBjYWNoZVxuICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gYXBwbHkgY2hhbmdlcyB0byBleHRhbnQgY2VsbEZyYW1lcyAtLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyB0aGVzZSBhcmUgdXNlZCB0byByZWNvbmNpbGUgY3JhZGxlIGNlbGxGcmFtZXMsIGFuZCBhbHNvIGZvciByZXR1cm4gaW5mb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNYXAua2V5cygpKVxuICAgICAgICBjb25zdCBkZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSXRlbUlEVG9JbmRleE1hcC52YWx1ZXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIC8vIGZvciByZXR1cm4gaW5mb3JtYXRpb24uLi5cbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAua2V5cygpKSBcblxuICAgICAgICBsZXQgbW9kaWZpZWRJbmRleExpc3QgPSBbXG4gICAgICAgICAgICAuLi5wcm9jZXNzZWRJbmRleExpc3QsXG4gICAgICAgICAgICAuLi5pbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QsIFxuICAgICAgICAgICAgLi4uZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0XG4gICAgICAgIF1cblxuICAgICAgICBtb2RpZmllZEluZGV4TGlzdCA9IEFycmF5LmZyb20obmV3IFNldChtb2RpZmllZEluZGV4TGlzdC52YWx1ZXMoKSkpIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG5cbiAgICAgICAgY29udGVudEhhbmRsZXIucmVjb25jaWxlQ2VsbEZyYW1lcyhtb2RpZmllZEluZGV4TGlzdClcbiAgICAgICAgY2FjaGVIYW5kbGVyLnBvcnRhbEhvbGRMaXN0ID0gcG9ydGFsSG9sZExpc3RcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSByZXR1cm5zIGZvciB1c2VyIGluZm9ybWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgcmV0dXJuIFtcblxuICAgICAgICAgICAgbW9kaWZpZWRJbmRleExpc3QsIFxuICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QsIFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCwgXG4gICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJbmRleExpc3QsXG4gICAgICAgICAgICBlcnJvckVudHJpZXNNYXAsIFxuICAgICAgICAgICAgY2hhbmdlTWFwXG5cbiAgICAgICAgXVxuXG4gICAgfVxuXG4gICAgLy8gbW92ZSBtdXN0IGJlIGVudGlyZWx5IHdpdGhpbiBsaXN0IGJvdW5kc1xuICAgIC8vIHJldHVybnMgbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlc1xuICAgIHB1YmxpYyBtb3ZlSW5kZXggPSAodG9pbmRleCwgZnJvbWluZGV4LCBoaWdocmFuZ2UgPSBudWxsKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBkZWZpbmUgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyByZW1vdmUgbnVsbHNcbiAgICAgICAgdG9pbmRleCA9IHRvaW5kZXggPz8gMFxuICAgICAgICBmcm9taW5kZXggPSBmcm9taW5kZXggPz8gMFxuICAgICAgICBoaWdocmFuZ2UgPSBoaWdocmFuZ2UgPz8gZnJvbWluZGV4XG5cbiAgICAgICAgdG9pbmRleCA9IE1hdGgubWF4KDAsdG9pbmRleClcbiAgICAgICAgZnJvbWluZGV4ID0gTWF0aC5tYXgoMCxmcm9taW5kZXgpXG4gICAgICAgIGhpZ2hyYW5nZSA9IE1hdGgubWF4KDAsaGlnaHJhbmdlKVxuXG4gICAgICAgIC8vIGtlZXAgd2l0aGluIGN1cnJlbnQgbGlzdCBzaXplXG4gICAgICAgIGNvbnN0IGxpc3Rib3VuZCA9IGxpc3RzaXplIC0gMVxuXG4gICAgICAgIHRvaW5kZXggPSBcbiAgICAgICAgICAgICh0b2luZGV4ID4gbGlzdGJvdW5kKT9cbiAgICAgICAgICAgICAgICBsaXN0Ym91bmQ6XG4gICAgICAgICAgICAgICAgdG9pbmRleFxuXG4gICAgICAgIGZyb21pbmRleCA9IFxuICAgICAgICAgICAgKGZyb21pbmRleCA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIGZyb21pbmRleFxuXG4gICAgICAgIGhpZ2hyYW5nZSA9IFxuICAgICAgICAgICAgKGhpZ2hyYW5nZSA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZVxuXG4gICAgICAgIC8vIGhpZ2hyYW5nZSBtdXN0IGJlID49IGZyb21pbmRleFxuICAgICAgICBoaWdocmFuZ2UgPSBcbiAgICAgICAgICAgIChoaWdocmFuZ2UgPj0gZnJvbWluZGV4KT9cbiAgICAgICAgICAgICAgICBoaWdocmFuZ2U6XG4gICAgICAgICAgICAgICAgZnJvbWluZGV4XG5cbiAgICAgICAgY29uc3QgcmFuZ2VpbmNyZW1lbnQgPSBoaWdocmFuZ2UgLSBmcm9taW5kZXggKyAxXG4gICAgICAgIGNvbnN0IG1vdmVpbmNyZW1lbnQgPSB0b2luZGV4IC0gZnJvbWluZGV4XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBjb25zdHJhaW4gcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChmcm9taW5kZXggPT0gdG9pbmRleCkgcmV0dXJuIFtdIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICAvLyBtb3ZlIG11c3QgYmUgaW4gbGlzdCBib3VuZHNcbiAgICAgICAgaWYgKG1vdmVpbmNyZW1lbnQgPiAwKSB7IC8vIG1vdmUgdXBcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldHRvcCA9IHRvaW5kZXggKyAocmFuZ2VpbmNyZW1lbnQgLSAxKVxuICAgICAgICAgICAgaWYgKHRhcmdldHRvcCA+IGxpc3Rib3VuZCkgcmV0dXJuIFtdIC8vIG91dCBvZiBib3VuZHNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIHBlcmZvcm0gY2FjaGUgYW5kIGNyYWRsZSBvcGVyYXRpb25zIC0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5tb3ZlSW5kZXgodG9pbmRleCwgZnJvbWluZGV4LCBoaWdocmFuZ2UpXG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZEluZGV4TGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmNoYW5nZUNyYWRsZUl0ZW1JRHMocHJvY2Vzc2VkSW5kZXhMaXN0KVxuXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRJbmRleExpc3RcblxuICAgIH1cblxuICAgIHB1YmxpYyBpbnNlcnRJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCArMSlcblxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCAtMSlcblxuICAgIH1cblxuICAgIC8vIHNoYXJlZCBsb2dpYy4gUmV0dXJucyBsaXN0cyBvZiBpdGVtcyBjaGFuZ2VkLCBhbmQgaXRlbXMgcmVwbGFjZWQgKG5ldyBpdGVtcyBmb3IgaW5zZXJ0KVxuICAgIC8vIHRoaXMgb3BlcmF0aW9uIGNoYW5nZXMgdGhlIGxpc3RzaXplXG4gICAgcHJpdmF0ZSBpbnNlcnRSZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIGluY3JlbWVudCkgPT4ge1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggPz8gMFxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IHJhbmdlaGlnaGluZGV4ID8/IGluZGV4XG5cbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLGluZGV4KVxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IE1hdGgubWF4KHJhbmdlaGlnaGluZGV4LCBpbmRleClcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFtjaGFuZ2VMaXN0LCByZXBsYWNlTGlzdCwgcmFuZ2VpbmNyZW1lbnQsIHBvcnRhbEhvbGRMaXN0XSA9IFxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgaW5jcmVtZW50LCBsaXN0c2l6ZSlcblxuICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICBjYWNoZUhhbmRsZXIucG9ydGFsSG9sZExpc3QgPSBwb3J0YWxIb2xkTGlzdFxuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLmNoYW5nZUNyYWRsZUl0ZW1JRHMoY2hhbmdlTGlzdClcblxuICAgICAgICBpZiAoaW5jcmVtZW50ID09ICsxKSBjb250ZW50SGFuZGxlci5jcmVhdGVOZXdJdGVtSURzKHJlcGxhY2VMaXN0KVxuXG4gICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gY29udGVudEhhbmRsZXJcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG5cbiAgICAgICAgY29uc3QgY2hhbmdlY291bnQgPSByYW5nZWluY3JlbWVudCAvLyBzZW1hbnRpY3NcbiAgICAgICAgY29uc3QgbmV3bGlzdHNpemUgPSBsaXN0c2l6ZSArIGNoYW5nZWNvdW50IFxuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgcmV0dXJuIFtjaGFuZ2VMaXN0LCByZXBsYWNlTGlzdF1cblxuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOlsiU2VydmljZUhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwic3RhdGVIYW5kbGVyIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiaW50ZXJydXB0SGFuZGxlciIsInBhdXNlSW50ZXJydXB0cyIsInNldENyYWRsZVN0YXRlIiwiaW5kZXgiLCJNYXRoIiwibWF4Iiwic2lnbmFscyIsImxheW91dEhhbmRsZXIiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJuZXdsaXN0c2l6ZSIsImNhY2hlSGFuZGxlciIsImNhbGxiYWNrcyIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJjdXJyZW50bGlzdHNpemUiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJsaXN0c2l6ZSIsImNhY2hlIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwiY2hhbmdlTGlzdHNpemUiLCJnZXRDYWNoZUluZGV4TWFwIiwiZ2V0Q2FjaGVJdGVtTWFwIiwiY29udGVudEhhbmRsZXIiLCJtb2RlbEluZGV4TGlzdCIsImdldE1vZGVsSW5kZXhMaXN0IiwiZ2V0Q3JhZGxlSW5kZXhNYXAiLCJjaGFuZ2VNYXAiLCJzaXplIiwiY2FjaGVQcm9wcyIsIm1ldGFkYXRhTWFwIiwicG9ydGFsTWFwIiwiaW5kZXhUb0l0ZW1JRE1hcCIsImluZGV4ZXNUb0RlbGV0ZUxpc3QiLCJjaGFuZ2VJbmRleFRvSXRlbUlETWFwIiwiTWFwIiwiZXJyb3JFbnRyaWVzTWFwIiwiZm9yRWFjaCIsIml0ZW1JRCIsInVuZGVmaW5lZCIsInB1c2giLCJzZXQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXMiLCJnZXQiLCJtYXBzaXplIiwiaXRlbUlEU2V0IiwiU2V0IiwidmFsdWVzIiwiaXRlbXNldHNpemUiLCJpdGVtSURDb3VudE1hcCIsImNvdW50IiwiZHVwbGljYXRlSXRlbXNNYXAiLCJkdXBsaWNhdGVzVG9SZW1vdmVMaXN0Iiwib3JpZ2luYWxNYXAiLCJsZW5ndGgiLCJwcm9jZXNzZWRJbmRleExpc3QiLCJpdGVtZGF0YSIsImRlbGV0ZWRJdGVtSURUb0luZGV4TWFwIiwiZGVsZXRlZEluZGV4VG9JdGVtSURNYXAiLCJwb3J0YWxIb2xkTGlzdCIsIm9yaWdpbmFsSXRlbUlEIiwib3JpZ2luYWxJdGVtSURJbmRleCIsImZpbmFsSXRlbUlESW5kZXgiLCJmaW5hbEl0ZW1JRCIsIm1vZGlmaWVkIiwicmVuZGVyUG9ydGFsTGlzdCIsImRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QiLCJBcnJheSIsImZyb20iLCJkZWxldGVkT3JwaGFuZWRJbmRleExpc3QiLCJrZXlzIiwiZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCIsIm1vZGlmaWVkSW5kZXhMaXN0IiwicmVjb25jaWxlQ2VsbEZyYW1lcyIsInRvaW5kZXgiLCJmcm9taW5kZXgiLCJoaWdocmFuZ2UiLCJsaXN0Ym91bmQiLCJyYW5nZWluY3JlbWVudCIsIm1vdmVpbmNyZW1lbnQiLCJ0YXJnZXR0b3AiLCJtb3ZlSW5kZXgiLCJjaGFuZ2VDcmFkbGVJdGVtSURzIiwicmFuZ2VoaWdoaW5kZXgiLCJpbnNlcnRSZW1vdmVJbmRleCIsImluY3JlbWVudCIsImNoYW5nZUxpc3QiLCJyZXBsYWNlTGlzdCIsImNyZWF0ZU5ld0l0ZW1JRHMiLCJjb250ZW50IiwiY2hhbmdlY291bnQiLCJzZXRMaXN0c2l6ZSIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInByZWxvYWRJbmRleENhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n')},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // statehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to cradle states (cradleState and cradleResizeState) and stateSetting\n   functions (setCradleState and setCradleResizeState) for other handlers.\n   It alos provides access to the isMountedRef reference.\n*/\n\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.setCradleResizeState = internalProperties.setCradleResizeState;\n  this.cradleResizeStateRef = internalProperties.cradleResizeStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\n\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0lBTXFCQSxZLDZCQUVqQixzQkFBWUMsZ0JBQVosRUFBNEI7RUFBQTs7RUFFekIsS0FBS0EsZ0JBQUwsR0FBd0JBLGdCQUF4QjtFQUVBLElBQU1DLGtCQUFrQixHQUFHRCxnQkFBZ0IsQ0FBQ0UsMkJBQWpCLENBQTZDQyxPQUF4RTtFQUVBLEtBQUtDLGNBQUwsR0FBc0JILGtCQUFrQixDQUFDRyxjQUF6QztFQUNBLEtBQUtDLGNBQUwsR0FBc0JKLGtCQUFrQixDQUFDSSxjQUF6QztFQUNBLEtBQUtDLG9CQUFMLEdBQTRCTCxrQkFBa0IsQ0FBQ0ssb0JBQS9DO0VBQ0EsS0FBS0Msb0JBQUwsR0FBNEJOLGtCQUFrQixDQUFDTSxvQkFBL0M7RUFDQSxLQUFLQyxZQUFMLEdBQW9CUCxrQkFBa0IsQ0FBQ08sWUFBdkM7QUFFRixDOztBQWRMQyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zdGF0ZWhhbmRsZXIudHN4PzYzOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3RhdGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFjY2VzcyB0byBjcmFkbGUgc3RhdGVzIChjcmFkbGVTdGF0ZSBhbmQgY3JhZGxlUmVzaXplU3RhdGUpIGFuZCBzdGF0ZVNldHRpbmcgXG4gICBmdW5jdGlvbnMgKHNldENyYWRsZVN0YXRlIGFuZCBzZXRDcmFkbGVSZXNpemVTdGF0ZSkgZm9yIG90aGVyIGhhbmRsZXJzLlxuICAgSXQgYWxvcyBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGlzTW91bnRlZFJlZiByZWZlcmVuY2UuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgY29uc3QgaW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgdGhpcy5zZXRDcmFkbGVTdGF0ZSA9IGludGVybmFsUHJvcGVydGllcy5zZXRDcmFkbGVTdGF0ZVxuICAgICAgIHRoaXMuY3JhZGxlU3RhdGVSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuY3JhZGxlU3RhdGVSZWZcbiAgICAgICB0aGlzLnNldENyYWRsZVJlc2l6ZVN0YXRlID0gaW50ZXJuYWxQcm9wZXJ0aWVzLnNldENyYWRsZVJlc2l6ZVN0YXRlXG4gICAgICAgdGhpcy5jcmFkbGVSZXNpemVTdGF0ZVJlZiA9IGludGVybmFsUHJvcGVydGllcy5jcmFkbGVSZXNpemVTdGF0ZVJlZlxuICAgICAgIHRoaXMuaXNNb3VudGVkUmVmID0gaW50ZXJuYWxQcm9wZXJ0aWVzLmlzTW91bnRlZFJlZlxuICAgICAgIFxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHVibGljIGNyYWRsZVN0YXRlUmVmXG4gICAgcHVibGljIHNldENyYWRsZVN0YXRlXG4gICAgcHVibGljIGNyYWRsZVJlc2l6ZVN0YXRlUmVmXG4gICAgcHVibGljIHNldENyYWRsZVJlc2l6ZVN0YXRlXG4gICAgcHVibGljIGlzTW91bnRlZFJlZlxuXG59XG4iXSwibmFtZXMiOlsiU3RhdGVIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImN1cnJlbnQiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwic2V0Q3JhZGxlUmVzaXplU3RhdGUiLCJjcmFkbGVSZXNpemVTdGF0ZVJlZiIsImlzTW91bnRlZFJlZiIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(" // styleshandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        triggerlineaxisstyles,\n        triggerlineheadstyles,\n        cradledividerstyles\n*/\n\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, StylesHandler);\n\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n        cellHeight = _ref.cellHeight,\n        cellWidth = _ref.cellWidth,\n        varHeightMin = _ref.varHeightMin,\n        varWidthMin = _ref.varWidthMin,\n        gap = _ref.gap,\n        padding = _ref.padding,\n        crosscount = _ref.crosscount,\n        viewportheight = _ref.viewportheight,\n        viewportwidth = _ref.viewportwidth,\n        userstyles = _ref.userstyles,\n        triggerlineOffset = _ref.triggerlineOffset;\n\n    var headstyles = _this.getHeadStyles(gap, padding, orientation, userstyles.cradle);\n\n    var tailstyles = _this.getTailStyles(gap, padding, orientation, userstyles.cradle);\n\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation, userstyles.axis);\n\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap); // layoutHandler.triggerlineSpan = this.axisTriggerlineOffset - this.headTriggerlineOffset\n\n\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gridGap = gap + 'px';\n    tailstyles.gridGap = gap + 'px';\n\n    if (orientation == 'horizontal') {\n      headstyles.padding = \"\".concat(padding, \"px 0 \").concat(padding, \"px \").concat(padding, \"px\");\n      headstyles.width = 'auto';\n      headstyles.height = '100%';\n      headstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n      //     sets length of horiz cradle items in one line (row), not multi-row config\n\n      headstyles.gridTemplateRows = cellHeight ? \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\") : 'auto';\n      headstyles.gridTemplateColumns = 'none';\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      tailstyles.width = 'auto';\n      tailstyles.height = '100%';\n      tailstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n      //     sets length of horiz cradle items in one line (row), not multi-row config\n\n      tailstyles.gridTemplateRows = cellHeight ? \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\") : 'auto';\n      tailstyles.gridTemplateColumns = 'none';\n    } else if (orientation == 'vertical') {\n      headstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px 0 \").concat(padding, \"px\");\n      headstyles.width = '100%';\n      headstyles.height = 'auto';\n      headstyles.gridAutoFlow = 'row';\n      headstyles.gridTemplateRows = 'none';\n      headstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fill, minmax(\".concat(cellWidth, \"px, 1fr))\") : 'auto';\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      tailstyles.width = '100%';\n      tailstyles.height = 'auto';\n      tailstyles.gridAutoFlow = 'row';\n      tailstyles.gridTemplateRows = 'none';\n      tailstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fill, minmax(\".concat(cellWidth, \"px, 1fr))\") : 'auto';\n    }\n\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  };\n\n  this.getHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = 'auto';\n      right = 'auto';\n      top = 'auto';\n    } else {\n      bottom = 'auto';\n      left = 'auto';\n      right = 0;\n      top = 'auto';\n    }\n\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  };\n\n  this.getTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 'auto';\n      left = 'auto';\n      right = 'auto';\n      top = 0;\n    } else {\n      bottom = 'auto';\n      left = 0;\n      right = 'auto';\n      top = 'auto';\n    }\n\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      // backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n\n  this.getAxisStyles = function (gap, padding, orientation, useraxisstyles) {\n    var top, left, width, height; // for axis\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n      width = '100%';\n      height = 'auto';\n    } else {\n      top = 'auto';\n      left = padding + 'px';\n      width = 0;\n      height = '100%';\n    }\n\n    return Object.assign(Object.assign({}, useraxisstyles), {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, left;\n\n    if (orientation == 'vertical') {\n      height = '0px';\n      width = '100%';\n      left = 'auto';\n      top = triggerlineOffset + 'px';\n    } else {\n      height = '100%';\n      width = '0px';\n      left = triggerlineOffset + 'px';\n      top = 'auto';\n    }\n\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      left: left\n    };\n  };\n\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, bottom, right;\n\n    if (orientation == 'vertical') {\n      height = '0px';\n      width = '100%';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      right = 'auto';\n    } else {\n      height = '100%';\n      width = '0px';\n      bottom = 'auto';\n      right = -(triggerlineOffset + gap) + 'px';\n    }\n\n    return {\n      position: position,\n      width: width,\n      height: height,\n      bottom: bottom,\n      right: right\n    };\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsS0FBUjtNQUNBUSxNQUFNLEdBQUcsTUFBVDtNQUNBRyxLQUFLLEdBQUcsRUFBRTNCLGlCQUFpQixHQUFHTixHQUF0QixJQUE2QixJQUFyQztJQUVIOztJQUVELE9BQU87TUFFSHFCLFFBQVEsRUFBUkEsUUFGRztNQUdIQyxLQUFLLEVBQUxBLEtBSEc7TUFJSEMsTUFBTSxFQUFOQSxNQUpHO01BS0hPLE1BQU0sRUFBTkEsTUFMRztNQU1IRyxLQUFLLEVBQUxBO0lBTkcsQ0FBUDtFQVNILENBOUJPOztFQTlPTixLQUFLdkMsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUVELEM7O0FBTkw4QyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zdHlsZXNoYW5kbGVyLnRzeD80NWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlc2hhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBDcmFkbGUgY29tcG9uZW50IHdpdGggb25lIGtleSBmdW5jdGlvbjogZ2V0Q3JhZGxlU3R5bGVzLlxuICAgIEl0IHJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyBmb3JcbiAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgdGFpbHN0eWxlcyxcbiAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVheGlzc3R5bGVzLFxuICAgICAgICB0cmlnZ2VybGluZWhlYWRzdHlsZXMsXG4gICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXNcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlc0hhbmRsZXIgeyBcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBnZXRDcmFkbGVTdHlsZXMgPSAoe1xuXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIHZhckhlaWdodE1pbixcbiAgICAgICAgdmFyV2lkdGhNaW4sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHVzZXJzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuXG4gICAgfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGhlYWRzdHlsZXMgPSB0aGlzLmdldEhlYWRTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IHRhaWxzdHlsZXMgPSB0aGlzLmdldFRhaWxTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IGF4aXNzdHlsZXMgPSB0aGlzLmdldEF4aXNTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5heGlzKVxuXG4gICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzID1cbiAgICAgICAgICAgIHRoaXMuZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZXMob3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5ldGFpbHN0eWxlcyA9IFxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyhvcmllbnRhdGlvbixjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApXG5cblxuICAgICAgICAvLyBsYXlvdXRIYW5kbGVyLnRyaWdnZXJsaW5lU3BhbiA9IHRoaXMuYXhpc1RyaWdnZXJsaW5lT2Zmc2V0IC0gdGhpcy5oZWFkVHJpZ2dlcmxpbmVPZmZzZXRcblxuICAgICAgICBjb25zdCBjcmFkbGVkaXZpZGVyc3R5bGVzID0gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgekluZGV4OjEsIFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OicwIDAgNXB4IDNweCByZWQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaGVhZHN0eWxlcy5ncmlkR2FwID0gZ2FwICsgJ3B4J1xuXG4gICAgICAgIHRhaWxzdHlsZXMuZ3JpZEdhcCA9IGdhcCArICdweCdcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggMCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAnY29sdW1uJ1xuICAgICAgICAgICAgLy8gZXhwbGljdCBjcm9zc2NvdW50IG5leHQgbGluZSBhcyB3b3JrYXJvdW5kIGZvciBGRiBwcm9ibGVtIC0gXG4gICAgICAgICAgICAvLyAgICAgc2V0cyBsZW5ndGggb2YgaG9yaXogY3JhZGxlIGl0ZW1zIGluIG9uZSBsaW5lIChyb3cpLCBub3QgbXVsdGktcm93IGNvbmZpZ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodD9cbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsSGVpZ2h0fXB4LCAxZnIpKWA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJ25vbmUnXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwYFxuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAnY29sdW1uJ1xuICAgICAgICAgICAgLy8gZXhwbGljdCBjcm9zc2NvdW50IG5leHQgbGluZSBhcyB3b3JrYXJvdW5kIGZvciBGRiBwcm9ibGVtIC0gXG4gICAgICAgICAgICAvLyAgICAgc2V0cyBsZW5ndGggb2YgaG9yaXogY3JhZGxlIGl0ZW1zIGluIG9uZSBsaW5lIChyb3cpLCBub3QgbXVsdGktcm93IGNvbmZpZ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodD9cbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsSGVpZ2h0fXB4LCAxZnIpKWA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJ25vbmUnXG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSAnbm9uZSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aD9cbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdChhdXRvLWZpbGwsIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0bydcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdyb3cnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9ICdub25lJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoP1xuICAgICAgICAgICAgICAgICAgICBgcmVwZWF0KGF1dG8tZmlsbCwgbWlubWF4KCR7Y2VsbFdpZHRofXB4LCAxZnIpKWA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJ1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRhaWxzdHlsZXMsXG4gICAgICAgICAgICBheGlzc3R5bGVzLFxuICAgICAgICAgICAgY3JhZGxlZGl2aWRlcnN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMsXG4gICAgICAgIF1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRIZWFkU3R5bGVzID0gKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJoZWFkc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAwXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICByaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udXNlcmhlYWRzdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBhbGlnbkNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRhaWxTdHlsZXMgPSAoZ2FwLHBhZGRpbmcsb3JpZW50YXRpb24sdXNlcnRhaWxzdHlsZXMpID0+IHtcblxuICAgICAgICBsZXQgYm90dG9tLCBsZWZ0LCB0b3AsIHJpZ2h0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9ICdhdXRvJ1xuICAgICAgICAgICAgbGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgcmlnaHQgPSAnYXV0bydcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9ICdhdXRvJ1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi51c2VydGFpbHN0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYWxpZ25Db250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICB9IFxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QXhpc1N0eWxlcyA9IChnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uLCB1c2VyYXhpc3N0eWxlcykgPT4ge1xuICAgICAgICBsZXQgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IC8vIGZvciBheGlzXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRvcCA9IHBhZGRpbmcgKyAncHgnXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nICsgJ3B4J1xuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi51c2VyYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZXMgPSAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gJzBweCdcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0b3AgPSB0cmlnZ2VybGluZU9mZnNldCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHdpZHRoID0gJzBweCdcbiAgICAgICAgICAgIGxlZnQgPSB0cmlnZ2VybGluZU9mZnNldCArICdweCdcbiAgICAgICAgICAgIHRvcCA9ICdhdXRvJ1xuXG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIGdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzID0gKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApID0+IHtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICdhYnNvbHV0ZSdcblxuICAgICAgICBsZXQgd2lkdGgsIGhlaWdodCwgYm90dG9tLCByaWdodFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWlnaHQgPSAnMHB4J1xuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGJvdHRvbSA9IC0odHJpZ2dlcmxpbmVPZmZzZXQgKyBnYXApICsgJ3B4J1xuICAgICAgICAgICAgcmlnaHQgPSAnYXV0bydcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHdpZHRoID0gJzBweCdcbiAgICAgICAgICAgIGJvdHRvbSA9ICdhdXRvJ1xuICAgICAgICAgICAgcmlnaHQgPSAtKHRyaWdnZXJsaW5lT2Zmc2V0ICsgZ2FwKSArICdweCdcblxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlN0eWxlc0hhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwib3JpZW50YXRpb24iLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwidmFySGVpZ2h0TWluIiwidmFyV2lkdGhNaW4iLCJnYXAiLCJwYWRkaW5nIiwiY3Jvc3Njb3VudCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVzZXJzdHlsZXMiLCJ0cmlnZ2VybGluZU9mZnNldCIsImhlYWRzdHlsZXMiLCJnZXRIZWFkU3R5bGVzIiwiY3JhZGxlIiwidGFpbHN0eWxlcyIsImdldFRhaWxTdHlsZXMiLCJheGlzc3R5bGVzIiwiZ2V0QXhpc1N0eWxlcyIsImF4aXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzIiwidHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMiLCJnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiZ3JpZEdhcCIsImdyaWRBdXRvRmxvdyIsImdyaWRUZW1wbGF0ZVJvd3MiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwidXNlcmhlYWRzdHlsZXMiLCJib3R0b20iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkNvbnRlbnQiLCJib3hTaXppbmciLCJ1c2VydGFpbHN0eWxlcyIsInVzZXJheGlzc3R5bGVzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./src/infinitegridscroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // InfiniteGridScroller.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    ROADMAP:\n\n        layout: uniform, variable\n\n        cross-browser testing; smartphone testing\n\n        release to npm\n\n        create demo site - github pages\n\n    BUGS:\n\n        - scroll toward top sometimes loses position; can\'s scroll all the way; hard to reproduce\n            - may relate to undersized elements\n            - triggerline reconnect apparently didn\'t happen (or failed) in one case (!)\n        - settriggercell apparently fails rarely - new triggerline cell going out of scope?\n        - axis can jump on load variable data\n        - bottom of list adjustments are broken\n        - reposition is flaky with variable\n        - goto fails from blank cradle\n        - reposition to start with variable sometimes ends up blank (content below viewport)\n        - possible reset layout reference values on reposition\n\n        - pivot is broken\n        - FF sets axis to past last item on variable layout\n        - Edge fails to set scrollPos so at bottom so that last item is at end of scrollblock\n\n    TODO:\n\n        - allow updateCradleContent without scrollmovement\n        - add logic for last item in list visible in adjustScrollblockForVariability\n        - make disconnect methods of interrupthandler\n        - check visibiliy hidden for portallist (instead of display none)\n        - allow pixel parameters to be expresse in text alternative eg. em\n            - then convert internally to pixels using getComputedStyles (or let user do that)\n        - try to remove need for viewportVisibleRowcount\n        - calcalate end of list by actual lengths (both set and update)\n        - consider resetting positions on after scroll\n\n        - try performance without cradle resizeobserver\n        - review all code where variable mode changes positioning calculations\n        - use cradleResize to capture async variable cell updates between state cycles\n        - change scroll bounce behaviour if supported on all browsers\n\n        re-test for memory leaks window.performance.memory\n        retest concat replacements\n        integrate cradleParameters object availability into cachehandler\n        test phone rotation for resize during scroll intertia\n        require variable settings: min/max for height/width (?)\n        ----------------\n        (after layout...)\n        \n        - prioritize fetch cells for visible cells\n\n        - create random loading delays in test ui\n        - provide way to attempt reload of a single cell (change instanceID)\n        - test for two root portals\n        - calc minwidth by form factor\n        - review scroller-frame for appropriate dimensions - s/b inset:0;position:absolute\n        - add grid-template-rows: max-content to parent for safari issue grid-auto-flow: column not filling column\n*/\n\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the scrollblock, fullsize for adjusted cell height/width, which in turn contains the cradle\n        - a component that contains CellFrames (which contain displayed items or transitional placeholders.\n    The CellFrames are skeletons which contain the host content components.\n\n    Host content is instantiated in a portal cache (via PortalHandler)\n    and then portal\'d to its host CellFrame. The cach can be configured to hold many more items\n    than cradle, allowing a range of host content to maintain state.\n\n    Scrollblock by size represents the entirety of the list, and is the scroller\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as\n      though it is the full scrollblock, but in fact it is only slightly larger than\n      the viewport.\n    - individual host items are framed by CellFrame, managed by Cradle\n\n    Overall the infinitegridscroller as a package manages the often asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react")); // defensive\n\n\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ "./node_modules/react-error-boundary/dist/react-error-boundary.umd.js"); // www.npmjs.com/package/react-error-boundary\n// based on module template\n\n\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n      resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert"\n  }, react_1["default"].createElement("p", null, "Oops! Something went wrong inside react-infinite-grid-scroller."), react_1["default"].createElement("p", null, "Click to cancel the error and continue."), react_1["default"].createElement("button", {\n    onClick: resetErrorBoundary\n  }, "Cancel error"), react_1["default"].createElement("pre", null, error));\n} // scroller components\n\n\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\n\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\n\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx")); // loaded here to minimize redundant renders in Cradle\n\n\nvar cachehandler_1 = __webpack_require__(/*! ./cradle/cachehandler */ "./src/cradle/cachehandler.tsx"); // -------------------[ global session ID generator ]----------------\n\n\nvar globalScrollerID = 0; // ===================================[ INITIALIZE ]===========================\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      _props$estimatedListS = props.estimatedListSize,\n      estimatedListSize = _props$estimatedListS === void 0 ? 0 : _props$estimatedListS,\n      getItem = props.getItem,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n      _props$gap = props.gap,\n      gap = _props$gap === void 0 ? 0 : _props$gap,\n      _props$padding = props.padding,\n      padding = _props$padding === void 0 ? 0 : _props$padding,\n      _props$layout = props.layout,\n      layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n      _props$varHeightMin = props.varHeightMin,\n      varHeightMin = _props$varHeightMin === void 0 ? 0 : _props$varHeightMin,\n      _props$varWidthMin = props.varWidthMin,\n      varWidthMin = _props$varWidthMin === void 0 ? 0 : _props$varWidthMin,\n      _props$runwaySize = props.runwaySize,\n      runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n      _props$startingIndex = props.startingIndex,\n      startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n      placeholder = props.placeholder,\n      _props$styles = props.styles,\n      styles = _props$styles === void 0 ? {} : _props$styles,\n      _props$useScrollTrack = props.useScrollTracker,\n      useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n      _props$cache = props.cache,\n      cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n      _props$cacheMax = props.cacheMax,\n      cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n      _props$triggerlineOff = props.triggerlineOffset,\n      triggerlineOffset = _props$triggerlineOff === void 0 ? 10 : _props$triggerlineOff,\n      _props$callbacks = props.callbacks,\n      callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n      _props$advanced = props.advanced,\n      advanced = _props$advanced === void 0 ? {} : _props$advanced,\n      scrollerProperties = props.scrollerProperties;\n\n  if (!(cellWidth && cellHeight && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight and getItem are required\');\n    return null;\n  } // ---------------------[ Data setup ]----------------------\n  // avoid null/undefined\n\n\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  advanced = advanced !== null && advanced !== void 0 ? advanced : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  estimatedListSize = estimatedListSize !== null && estimatedListSize !== void 0 ? estimatedListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  varHeightMin = varHeightMin !== null && varHeightMin !== void 0 ? varHeightMin : 0;\n  varWidthMin = varWidthMin !== null && varWidthMin !== void 0 ? varWidthMin : 0; // prop constraints - non-negative values\n\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n\n  estimatedListSize = Math.max(0, estimatedListSize);\n  startingIndex = Math.max(0, startingIndex); // enums\n\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  } // package\n\n\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    varHeightMin: varHeightMin,\n    varWidthMin: varWidthMin,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs); // state\n\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      scrollerState = _ref3[0],\n      setScrollerState = _ref3[1]; // setup, setlistsize, ready\n  // system\n\n\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var _advanced = advanced,\n      showAxis = _advanced.showAxis,\n      VIEWPORT_RESIZE_TIMEOUT = _advanced.VIEWPORT_RESIZE_TIMEOUT,\n      SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _advanced.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n      IDLECALLBACK_TIMEOUT = _advanced.IDLECALLBACK_TIMEOUT,\n      TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _advanced.TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n      MIN_MAX_DELTA_RATIO = _advanced.MIN_MAX_DELTA_RATIO,\n      MAX_CACHE_OVER_RUN = _advanced.MAX_CACHE_OVER_RUN;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== null && SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== void 0 ? SCROLL_TIMEOUT_FOR_ONAFTERSCROLL : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 4000;\n  TIMEOUT_FOR_VARIABLE_MEASUREMENTS = TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== null && TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== void 0 ? TIMEOUT_FOR_VARIABLE_MEASUREMENTS : 100;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  MIN_MAX_DELTA_RATIO = MIN_MAX_DELTA_RATIO !== null && MIN_MAX_DELTA_RATIO !== void 0 ? MIN_MAX_DELTA_RATIO : 0.5;\n\n  if (MIN_MAX_DELTA_RATIO < 0 || MIN_MAX_DELTA_RATIO > 1) {\n    MIN_MAX_DELTA_RATIO = 0.5;\n  }\n\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true; // for mount version\n\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current; // for children\n\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(estimatedListSize);\n  var listsize = listsizeRef.current; // test React Object.is for attributes; avoid re-renders with no change\n\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  } // -------------------------[ Initialization ]-------------------------------\n\n\n  (0, react_1.useEffect)(function () {\n    scrollerSessionIDRef.current = globalScrollerID++;\n    cacheHandlerRef.current = new cachehandler_1.CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef);\n  }, []); // called when getItem returns null, or direct call from user (see servicehandler)\n\n  var setListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize; // inform the user\n\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistsize\');\n  }, []); // ---------------------[ State handling ]------------------------\n\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n      case \'setlistsize\':\n        setScrollerState(\'ready\');\n    }\n  }, [scrollerState]); // --------------------[ Render ]---------------------\n  // component calls are deferred by scrollerState to give cacheHandler a chance to initialize\n\n  return react_1["default"].createElement(react_1["default"].StrictMode, null, react_1["default"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {// response tbd; there may not need to be one\n    },\n    onError: function onError(error, info) {\n      console.log(\'react-infinite-grid-scroller captured error\', error);\n    }\n  }, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    scrollerProperties: scrollerProperties,\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    cacheHandler: cacheHandlerRef.current,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    MIN_MAX_DELTA_RATIO: MIN_MAX_DELTA_RATIO,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    TIMEOUT_FOR_VARIABLE_MEASUREMENTS: TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n    scrollerID: scrollerID\n  }))), scrollerState != \'setup\' && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(cachehandler_1.PortalList, {\n    cacheProps: cacheHandlerRef.current.cacheProps\n  }))));\n};\n\nexports["default"] = InfiniteGridScroller; // ----------------------------[ Support ]------------------------------\n\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\n\nfunction compareProps(obj1, obj2) {\n  var keys = Object.keys(obj1);\n  var same;\n\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5maW5pdGVncmlkc2Nyb2xsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLHNFLENBRUE7OztBQUNBLHFKLENBQXFEO0FBRXJEOzs7QUFDQSxTQUFTQSxhQUFULE9BQWtEO0VBQUEsSUFBMUJDLEtBQTBCLFFBQTFCQSxLQUEwQjtFQUFBLElBQW5CQyxrQkFBbUIsUUFBbkJBLGtCQUFtQjtFQUNoRCxPQUNFQztJQUFLQyxJQUFJLEVBQUM7RUFBVixHQUNFRCw4R0FERixFQUVFQSxzRkFGRixFQUdFQTtJQUFRRSxPQUFPLEVBQUdIO0VBQWxCLEdBQW9DLGNBQXBDLENBSEYsRUFJRUMsOENBQU1GLEtBQU4sQ0FKRixDQURGO0FBUUQsQyxDQUVEOzs7QUFDQTs7QUFDQTs7QUFDQSx3RixDQUVBOzs7QUFDQSx1RyxDQUVBOzs7QUFFQSxJQUFJSyxnQkFBZ0IsR0FBRyxDQUF2QixDLENBRUE7O0FBRUEsSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDQyxLQUFELEVBQVU7RUFFbkM7RUFFQSxJQUdJQyxVQUhKLEdBMENJRCxLQTFDSixDQUdJQyxVQUhKO0VBQUEsSUFLSUMsU0FMSixHQTBDSUYsS0ExQ0osQ0FLSUUsU0FMSjtFQUFBLDRCQTBDSUYsS0ExQ0osQ0FPSUcsaUJBUEo7RUFBQSxJQU9JQSxpQkFQSixzQ0FPd0IsQ0FQeEI7RUFBQSxJQVFJQyxPQVJKLEdBMENJSixLQTFDSixDQVFJSSxPQVJKO0VBQUEseUJBMENJSixLQTFDSixDQWFJSyxXQWJKO0VBQUEsSUFhSUEsV0FiSixtQ0Fha0IsVUFibEI7RUFBQSxpQkEwQ0lMLEtBMUNK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eEIsQ0FBTCxFQUFxQztNQUNqQyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELE9BQU8sSUFBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmZpbml0ZUdyaWRTY3JvbGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgUk9BRE1BUDpcblxuICAgICAgICBsYXlvdXQ6IHVuaWZvcm0sIHZhcmlhYmxlXG5cbiAgICAgICAgY3Jvc3MtYnJvd3NlciB0ZXN0aW5nOyBzbWFydHBob25lIHRlc3RpbmdcblxuICAgICAgICByZWxlYXNlIHRvIG5wbVxuXG4gICAgICAgIGNyZWF0ZSBkZW1vIHNpdGUgLSBnaXRodWIgcGFnZXNcblxuICAgIEJVR1M6IFxuXG4gICAgICAgIC0gc2Nyb2xsIHRvd2FyZCB0b3Agc29tZXRpbWVzIGxvc2VzIHBvc2l0aW9uOyBjYW4ncyBzY3JvbGwgYWxsIHRoZSB3YXk7IGhhcmQgdG8gcmVwcm9kdWNlXG4gICAgICAgICAgICAtIG1heSByZWxhdGUgdG8gdW5kZXJzaXplZCBlbGVtZW50c1xuICAgICAgICAgICAgLSB0cmlnZ2VybGluZSByZWNvbm5lY3QgYXBwYXJlbnRseSBkaWRuJ3QgaGFwcGVuIChvciBmYWlsZWQpIGluIG9uZSBjYXNlICghKVxuICAgICAgICAtIHNldHRyaWdnZXJjZWxsIGFwcGFyZW50bHkgZmFpbHMgcmFyZWx5IC0gbmV3IHRyaWdnZXJsaW5lIGNlbGwgZ29pbmcgb3V0IG9mIHNjb3BlP1xuICAgICAgICAtIGF4aXMgY2FuIGp1bXAgb24gbG9hZCB2YXJpYWJsZSBkYXRhXG4gICAgICAgIC0gYm90dG9tIG9mIGxpc3QgYWRqdXN0bWVudHMgYXJlIGJyb2tlblxuICAgICAgICAtIHJlcG9zaXRpb24gaXMgZmxha3kgd2l0aCB2YXJpYWJsZVxuICAgICAgICAtIGdvdG8gZmFpbHMgZnJvbSBibGFuayBjcmFkbGVcbiAgICAgICAgLSByZXBvc2l0aW9uIHRvIHN0YXJ0IHdpdGggdmFyaWFibGUgc29tZXRpbWVzIGVuZHMgdXAgYmxhbmsgKGNvbnRlbnQgYmVsb3cgdmlld3BvcnQpXG4gICAgICAgIC0gcG9zc2libGUgcmVzZXQgbGF5b3V0IHJlZmVyZW5jZSB2YWx1ZXMgb24gcmVwb3NpdGlvblxuXG4gICAgICAgIC0gcGl2b3QgaXMgYnJva2VuXG4gICAgICAgIC0gRkYgc2V0cyBheGlzIHRvIHBhc3QgbGFzdCBpdGVtIG9uIHZhcmlhYmxlIGxheW91dFxuICAgICAgICAtIEVkZ2UgZmFpbHMgdG8gc2V0IHNjcm9sbFBvcyBzbyBhdCBib3R0b20gc28gdGhhdCBsYXN0IGl0ZW0gaXMgYXQgZW5kIG9mIHNjcm9sbGJsb2NrXG5cbiAgICBUT0RPOlxuXG4gICAgICAgIC0gYWxsb3cgdXBkYXRlQ3JhZGxlQ29udGVudCB3aXRob3V0IHNjcm9sbG1vdmVtZW50XG4gICAgICAgIC0gYWRkIGxvZ2ljIGZvciBsYXN0IGl0ZW0gaW4gbGlzdCB2aXNpYmxlIGluIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHlcbiAgICAgICAgLSBtYWtlIGRpc2Nvbm5lY3QgbWV0aG9kcyBvZiBpbnRlcnJ1cHRoYW5kbGVyXG4gICAgICAgIC0gY2hlY2sgdmlzaWJpbGl5IGhpZGRlbiBmb3IgcG9ydGFsbGlzdCAoaW5zdGVhZCBvZiBkaXNwbGF5IG5vbmUpXG4gICAgICAgIC0gYWxsb3cgcGl4ZWwgcGFyYW1ldGVycyB0byBiZSBleHByZXNzZSBpbiB0ZXh0IGFsdGVybmF0aXZlIGVnLiBlbVxuICAgICAgICAgICAgLSB0aGVuIGNvbnZlcnQgaW50ZXJuYWxseSB0byBwaXhlbHMgdXNpbmcgZ2V0Q29tcHV0ZWRTdHlsZXMgKG9yIGxldCB1c2VyIGRvIHRoYXQpXG4gICAgICAgIC0gdHJ5IHRvIHJlbW92ZSBuZWVkIGZvciB2aWV3cG9ydFZpc2libGVSb3djb3VudFxuICAgICAgICAtIGNhbGNhbGF0ZSBlbmQgb2YgbGlzdCBieSBhY3R1YWwgbGVuZ3RocyAoYm90aCBzZXQgYW5kIHVwZGF0ZSlcbiAgICAgICAgLSBjb25zaWRlciByZXNldHRpbmcgcG9zaXRpb25zIG9uIGFmdGVyIHNjcm9sbFxuXG4gICAgICAgIC0gdHJ5IHBlcmZvcm1hbmNlIHdpdGhvdXQgY3JhZGxlIHJlc2l6ZW9ic2VydmVyXG4gICAgICAgIC0gcmV2aWV3IGFsbCBjb2RlIHdoZXJlIHZhcmlhYmxlIG1vZGUgY2hhbmdlcyBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbnNcbiAgICAgICAgLSB1c2UgY3JhZGxlUmVzaXplIHRvIGNhcHR1cmUgYXN5bmMgdmFyaWFibGUgY2VsbCB1cGRhdGVzIGJldHdlZW4gc3RhdGUgY3ljbGVzXG4gICAgICAgIC0gY2hhbmdlIHNjcm9sbCBib3VuY2UgYmVoYXZpb3VyIGlmIHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnNcblxuICAgICAgICByZS10ZXN0IGZvciBtZW1vcnkgbGVha3Mgd2luZG93LnBlcmZvcm1hbmNlLm1lbW9yeVxuICAgICAgICByZXRlc3QgY29uY2F0IHJlcGxhY2VtZW50c1xuICAgICAgICBpbnRlZ3JhdGUgY3JhZGxlUGFyYW1ldGVycyBvYmplY3QgYXZhaWxhYmlsaXR5IGludG8gY2FjaGVoYW5kbGVyXG4gICAgICAgIHRlc3QgcGhvbmUgcm90YXRpb24gZm9yIHJlc2l6ZSBkdXJpbmcgc2Nyb2xsIGludGVydGlhXG4gICAgICAgIHJlcXVpcmUgdmFyaWFibGUgc2V0dGluZ3M6IG1pbi9tYXggZm9yIGhlaWdodC93aWR0aCAoPylcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAoYWZ0ZXIgbGF5b3V0Li4uKVxuICAgICAgICBcbiAgICAgICAgLSBwcmlvcml0aXplIGZldGNoIGNlbGxzIGZvciB2aXNpYmxlIGNlbGxzXG5cbiAgICAgICAgLSBjcmVhdGUgcmFuZG9tIGxvYWRpbmcgZGVsYXlzIGluIHRlc3QgdWlcbiAgICAgICAgLSBwcm92aWRlIHdheSB0byBhdHRlbXB0IHJlbG9hZCBvZiBhIHNpbmdsZSBjZWxsIChjaGFuZ2UgaW5zdGFuY2VJRClcbiAgICAgICAgLSB0ZXN0IGZvciB0d28gcm9vdCBwb3J0YWxzXG4gICAgICAgIC0gY2FsYyBtaW53aWR0aCBieSBmb3JtIGZhY3RvclxuICAgICAgICAtIHJldmlldyBzY3JvbGxlci1mcmFtZSBmb3IgYXBwcm9wcmlhdGUgZGltZW5zaW9ucyAtIHMvYiBpbnNldDowO3Bvc2l0aW9uOmFic29sdXRlXG4gICAgICAgIC0gYWRkIGdyaWQtdGVtcGxhdGUtcm93czogbWF4LWNvbnRlbnQgdG8gcGFyZW50IGZvciBzYWZhcmkgaXNzdWUgZ3JpZC1hdXRvLWZsb3c6IGNvbHVtbiBub3QgZmlsbGluZyBjb2x1bW5cbiovXG5cbi8qXG4gICAgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciA9IFJJR1NcblxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIHNjcm9sbGJsb2NrLCBmdWxsc2l6ZSBmb3IgYWRqdXN0ZWQgY2VsbCBoZWlnaHQvd2lkdGgsIHdoaWNoIGluIHR1cm4gY29udGFpbnMgdGhlIGNyYWRsZSBcbiAgICAgICAgLSBhIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIENlbGxGcmFtZXMgKHdoaWNoIGNvbnRhaW4gZGlzcGxheWVkIGl0ZW1zIG9yIHRyYW5zaXRpb25hbCBwbGFjZWhvbGRlcnMuIFxuICAgIFRoZSBDZWxsRnJhbWVzIGFyZSBza2VsZXRvbnMgd2hpY2ggY29udGFpbiB0aGUgaG9zdCBjb250ZW50IGNvbXBvbmVudHMuXG5cbiAgICBIb3N0IGNvbnRlbnQgaXMgaW5zdGFudGlhdGVkIGluIGEgcG9ydGFsIGNhY2hlICh2aWEgUG9ydGFsSGFuZGxlcikgXG4gICAgYW5kIHRoZW4gcG9ydGFsJ2QgdG8gaXRzIGhvc3QgQ2VsbEZyYW1lLiBUaGUgY2FjaCBjYW4gYmUgY29uZmlndXJlZCB0byBob2xkIG1hbnkgbW9yZSBpdGVtc1xuICAgIHRoYW4gY3JhZGxlLCBhbGxvd2luZyBhIHJhbmdlIG9mIGhvc3QgY29udGVudCB0byBtYWludGFpbiBzdGF0ZS5cblxuICAgIFNjcm9sbGJsb2NrIGJ5IHNpemUgcmVwcmVzZW50cyB0aGUgZW50aXJldHkgb2YgdGhlIGxpc3QsIGFuZCBpcyB0aGUgc2Nyb2xsZXJcblxuICAgIENyYWRsZSBjb250YWlucyB0aGUgbGlzdCBpdGVtcywgYW5kIGlzICd2aXJ0dWFsaXplZCcgLS0gaXQgYXBwZWFycyBhc1xuICAgICAgdGhvdWdoIGl0IGlzIHRoZSBmdWxsIHNjcm9sbGJsb2NrLCBidXQgaW4gZmFjdCBpdCBpcyBvbmx5IHNsaWdodGx5IGxhcmdlciB0aGFuXG4gICAgICB0aGUgdmlld3BvcnQuXG4gICAgLSBpbmRpdmlkdWFsIGhvc3QgaXRlbXMgYXJlIGZyYW1lZCBieSBDZWxsRnJhbWUsIG1hbmFnZWQgYnkgQ3JhZGxlXG5cbiAgICBPdmVyYWxsIHRoZSBpbmZpbml0ZWdyaWRzY3JvbGxlciBhcyBhIHBhY2thZ2UgbWFuYWdlcyB0aGUgb2Z0ZW4gYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBvZiB0aGUgXG4gICAgY29tcG9uZW50cyBvZiB0aGUgbWVjaGFuaXNtLiBNb3N0IG9mIHRoZSB3b3JrIG9jY3VycyBpbiB0aGUgQ3JhZGxlIGNvbXBvbmVudC5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbi8vIGRlZmVuc2l2ZVxuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeSB9IGZyb20gJ3JlYWN0LWVycm9yLWJvdW5kYXJ5JyAvLyB3d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtZXJyb3ItYm91bmRhcnlcblxuLy8gYmFzZWQgb24gbW9kdWxlIHRlbXBsYXRlXG5mdW5jdGlvbiBFcnJvckZhbGxiYWNrKHtlcnJvciwgcmVzZXRFcnJvckJvdW5kYXJ5fSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgcm9sZT1cImFsZXJ0XCI+XG4gICAgICA8cD5Pb3BzISBTb21ldGhpbmcgd2VudCB3cm9uZyBpbnNpZGUgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci48L3A+XG4gICAgICA8cD5DbGljayB0byBjYW5jZWwgdGhlIGVycm9yIGFuZCBjb250aW51ZS48L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eyByZXNldEVycm9yQm91bmRhcnkgfT5DYW5jZWwgZXJyb3I8L2J1dHRvbj5cbiAgICAgIDxwcmU+e2Vycm9yfTwvcHJlPlxuICAgIDwvZGl2PlxuICApXG59XG5cbi8vIHNjcm9sbGVyIGNvbXBvbmVudHNcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL1ZpZXdwb3J0J1xuaW1wb3J0IFNjcm9sbGJsb2NrIGZyb20gJy4vU2Nyb2xsYmxvY2snXG5pbXBvcnQgQ3JhZGxlIGZyb20gJy4vQ3JhZGxlJ1xuXG4vLyBsb2FkZWQgaGVyZSB0byBtaW5pbWl6ZSByZWR1bmRhbnQgcmVuZGVycyBpbiBDcmFkbGVcbmltcG9ydCB7IENhY2hlSGFuZGxlciwgUG9ydGFsTGlzdCB9IGZyb20gJy4vY3JhZGxlL2NhY2hlaGFuZGxlcidcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgZ2xvYmFsIHNlc3Npb24gSUQgZ2VuZXJhdG9yIF0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBnbG9iYWxTY3JvbGxlcklEID0gMFxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaRSBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IEluZmluaXRlR3JpZFNjcm9sbGVyID0gKHByb3BzKSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1bIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IHsgXG5cbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgY2VsbEhlaWdodCwgLy8gcmVxdWlyZWQuIHRoZSBvdXRlciBwaXhlbCBoZWlnaHQgLSBsaXRlcmFsIGZvciB2ZXJ0aWNhbDsgYXBwcm94aW1hdGUgZm9yIGhvcml6b250YWxcbiAgICAgICAgICAgIC8vIGJhc2UgZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICBjZWxsV2lkdGgsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgd2lkdGggLSBsaXRlcmFsIGZvciBob3Jpem9udGFsOyBhcHByb3hpbWF0ZSBmb3IgdmVydGljYWxcbiAgICAgICAgICAgIC8vIGJhc2UgZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICBlc3RpbWF0ZWRMaXN0U2l6ZSA9IDAsIC8vIHRoZSBlc3RpbWF0ZWQgbnVtYmVyIG9mIHRoZSBpdGVtcyBpbiB0aGUgdmlydHVhbCBsaXN0LiBjYW4gYmUgbW9kaWZpZWRcbiAgICAgICAgZ2V0SXRlbSwgLy8gcmVxdWlyZWQuIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGhvc3QgLSBwYXJhbWV0ZXJzIGFyZSBpbmRleCBudW1iZXIsIHNldCBieSBzeXN0ZW0sXG4gICAgICAgICAgICAvLyBhbmQgc2Vzc2lvbiBpdGVtSUQgZm9yIHRyYWNraW5nIGFuZCBtYXRjaGluZzsgXG4gICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudCwgb3IgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICAvLyAqKiBncmlkIHNwZWNzOlxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwID0gMCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG4gICAgICAgIHBhZGRpbmcgPSAwLCAvLyB0aGUgYm9yZGVyIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBsYXlvdXQgPSAndW5pZm9ybScsIC8vIHVuaWZvcm0sIHZhcmlhYmxlXG4gICAgICAgIHZhckhlaWdodE1pbiA9IDAsIC8vIGZvciBsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBvcmllbnRhdGlvbiA9PSAndmVydGljYWwnXG4gICAgICAgIHZhcldpZHRoTWluID0gMCwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJ1xuXG4gICAgICAgIC8vICoqIHNjcm9sbGVyIHNwZWNzOlxuICAgICAgICBydW53YXlTaXplID0gMywgLy8gdGhlIG51bWJlciBvZiBpdGVtcyBvdXRzaWRlIHRoZSB2aWV3IG9mIGVhY2ggc2lkZSBvZiB0aGUgdmlld3BvcnQgXG4gICAgICAgICAgICAvLyAtLSBnaXZlcyB0aW1lIHRvIGFzc2VtYmxlIGNlbGxGcmFtZXMgYmVmb3JlIGRpc3BsYXlcbiAgICAgICAgc3RhcnRpbmdJbmRleCA9IDAsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuICAgICAgICBwbGFjZWhvbGRlciwgLy8gb3B0aW9uYWwuIGEgc3BhcnNlIGNvbXBvbmVudCB0byBzdGFuZCBpbiBmb3IgY29udGVudCB1bnRpbCB0aGUgY29udGVudCBhcnJpdmVzOyBcbiAgICAgICAgICAgIC8vIHJlcGxhY2VzIGRlZmF1bHQgcGxhY2Vob2xkZXIgaWYgcHJlc2VudFxuICAgICAgICBzdHlsZXMgPSB7fSwgLy8gb3B0aW9uYWwuIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KTsgaGFzIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB2aWV3cG9ydCwgc2Nyb2xsYmxvY2ssIGNyYWRsZSwgc2Nyb2xsdHJhY2tlciwgcGxhY2Vob2xkZXJmcmFtZSwgb3JcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyY29udGVudC4gRG8gbm90IG1ha2Ugc3RydWN0dXJhbCBjaGFuZ2VzIVxuXG4gICAgICAgIC8vICoqIHN5c3RlbSBzcGVjczpcbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlciA9IHRydWUsIC8vIHRoZSBpbnRlcm5hbCBjb21wb25lbnQgdG8gZ2l2ZSBmZWVkYmFjayBmb3IgcmVwb3NpdGlvbmluZ1xuICAgICAgICBjYWNoZSA9ICdjcmFkbGUnLCAvLyBcInByZWxvYWRcIiwgXCJrZWVwbG9hZFwiIG9yIFwiY3JhZGxlXCJcbiAgICAgICAgY2FjaGVNYXggPSBudWxsLCAvLyBhbHdheXMgbWluaW11bSBjcmFkbGU7IG51bGwgbWVhbnMgbGltaXRlZCBieSBsaXN0c2l6ZVxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCA9IDEwLCAvLyBkaXN0YW5jZSBmcm9tIGNlbGwgaGVhZCBvciB0YWlsIGZvciBjb250ZW50IHNoaWZ0cyBhYm92ZS9iZWxvdyBheGlzXG4gICAgICAgIGNhbGxiYWNrcyA9IHt9LCAvLyBvcHRpb25hbC4gY2xvc3VyZXMgdG8gZ2V0IGRpcmVjdCBpbmZvcm1hdGlvbiBzdHJlYW1zIG9mIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzXG4gICAgICAgICAgICAvLyBjYW4gY29udGFpbiBnZXRGdW5jdGlvbnMsIHdoaWNoIHByb3ZpZGVzIGFjY2VzcyB0byBpbnRlcm5hbCBzY3JvbGxlciBmdW5jdGlvbnMgKG1vc3RseSBjYWNoZSBtYW5hZ2VtZW50KVxuICAgICAgICBhZHZhbmNlZCA9IHt9LCAvLyBvcHRpb25hbC4gdGVjaG5pY2FsIHNldHRpbmdzIGxpa2UgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVRcblxuICAgICAgICAvLyAqKiBpbmZvcm1hdGlvbiBmb3IgaG9zdCBjZWxsIGNvbnRlbnRcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLCAvLyByZXF1aXJlZCBmb3IgZW1iZWRkZWQgc2Nyb2xsZXI7IHNoYXJlcyBzY3JvbGxlciBzZXR0aW5ncyB3aXRoIGNvbnRlbnRcblxuICAgIH0gPSBwcm9wc1xuXG4gICAgaWYgKCEoY2VsbFdpZHRoICYmIGNlbGxIZWlnaHQgJiYgZ2V0SXRlbSApKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSSUdTOiBjZWxsV2lkdGgsIGNlbGxIZWlnaHQgYW5kIGdldEl0ZW0gYXJlIHJlcXVpcmVkJylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIERhdGEgc2V0dXAgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGF2b2lkIG51bGwvdW5kZWZpbmVkXG4gICAgc3R5bGVzID0gc3R5bGVzID8/IHt9XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzID8/IHt9XG4gICAgYWR2YW5jZWQgPSBhZHZhbmNlZCA/PyB7fVxuICAgIHN0YXJ0aW5nSW5kZXggPSBzdGFydGluZ0luZGV4ID8/IDBcbiAgICBlc3RpbWF0ZWRMaXN0U2l6ZSA9IGVzdGltYXRlZExpc3RTaXplID8/IDBcbiAgICBydW53YXlTaXplID0gcnVud2F5U2l6ZSA/PyAzXG4gICAgdXNlU2Nyb2xsVHJhY2tlciA9IHVzZVNjcm9sbFRyYWNrZXIgPz8gdHJ1ZVxuICAgIHZhckhlaWdodE1pbiA9IHZhckhlaWdodE1pbiA/PyAwXG4gICAgdmFyV2lkdGhNaW4gPSB2YXJXaWR0aE1pbiA/PyAwXG5cbiAgICAvLyBwcm9wIGNvbnN0cmFpbnRzIC0gbm9uLW5lZ2F0aXZlIHZhbHVlc1xuICAgIHJ1bndheVNpemUgPSBNYXRoLm1heCgxLHJ1bndheVNpemUpIC8vIHJ1bndheXNpemUgbXVzdCBiZSBhdCBsZWFzdCAxXG4gICAgZXN0aW1hdGVkTGlzdFNpemUgPSBNYXRoLm1heCgwLGVzdGltYXRlZExpc3RTaXplKVxuICAgIHN0YXJ0aW5nSW5kZXggPSBNYXRoLm1heCgwLHN0YXJ0aW5nSW5kZXgpXG5cbiAgICAvLyBlbnVtc1xuICAgIGlmICghWydob3Jpem9udGFsJywndmVydGljYWwnXS5pbmNsdWRlcyhvcmllbnRhdGlvbikpIHsgXG4gICAgICAgIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJ1xuICAgIH1cbiAgICBpZiAoIVsncHJlbG9hZCcsJ2tlZXBsb2FkJywnY3JhZGxlJ10uaW5jbHVkZXMoY2FjaGUpKSB7XG4gICAgICAgIGNhY2hlID0gJ2NyYWRsZSdcbiAgICB9XG4gICAgaWYgKCFbJ3VuaWZvcm0nLCAndmFyaWFibGUnXS5pbmNsdWRlcyhsYXlvdXQpKSB7XG4gICAgICAgIGxheW91dCA9ICd1bmlmb3JtJ1xuICAgIH1cblxuICAgIC8vIHBhY2thZ2VcbiAgICBjb25zdCBncmlkU3BlY3MgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgdmFySGVpZ2h0TWluLFxuICAgICAgICB2YXJXaWR0aE1pbixcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICAvLyBzdGF0ZVxuICAgIGNvbnN0IFtzY3JvbGxlclN0YXRlLCBzZXRTY3JvbGxlclN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCBzZXRsaXN0c2l6ZSwgcmVhZHlcblxuICAgIC8vIHN5c3RlbVxuICAgIGNvbnN0IHN0eWxlc1JlZiA9IHVzZVJlZihzdHlsZXMpXG4gICAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKGNhbGxiYWNrcylcblxuICAgIGxldCB7XG5cbiAgICAgICAgc2hvd0F4aXMsIC8vIGF4aXMgbWFkZSB2aXNpYmxlIGZvciBkZWJ1Z1xuICAgICAgICAvLyB0aW1lb3V0c1xuICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCxcbiAgICAgICAgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwsXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULFxuICAgICAgICBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMsXG4gICAgICAgIC8vIHJhdGlvczpcbiAgICAgICAgLy8gTUlOX01BWF9ERUxUQV9SQVRJTyA9IFxuICAgICAgICAvLyAgICB2YXJbbGVuZ3RoXU1pbiArICgoY2VsbFtMZW5ndGhdIC0gdmFyW0xlbmd0aF1NaW4pICogTUlOX01BWF9ERUxUQV9SQVRJTykgdXNlZCBcbiAgICAgICAgLy8gICAgIHRvIGNhbGN1bGF0ZSB2aXJ0dWFsIHBvc2l0aW9uIGluIHNjcm9sbGJsb2NrICh3aGVyZSBbTGVuZ3RoXSA9IFdpZHRoL0hlaWdodClcbiAgICAgICAgTUlOX01BWF9ERUxUQV9SQVRJTywgXG4gICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTiwgLy8gbWF4IHN0cmVhbWluZyBvdmVyLXJ1biBhcyByYXRpbyB0byBjYWNoZU1heFxuXG4gICAgfSA9IGFkdmFuY2VkXG5cbiAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCA9IFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID8/IDI1MFxuICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMID0gU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwgPz8gMTAwXG4gICAgSURMRUNBTExCQUNLX1RJTUVPVVQgPSBJRExFQ0FMTEJBQ0tfVElNRU9VVCA/PyA0MDAwXG4gICAgVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTID0gVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTID8/IDEwMFxuICAgIFxuICAgIE1BWF9DQUNIRV9PVkVSX1JVTiA9IE1BWF9DQUNIRV9PVkVSX1JVTiA/PyAxLjVcbiAgICBNSU5fTUFYX0RFTFRBX1JBVElPID0gTUlOX01BWF9ERUxUQV9SQVRJTyA/PyAwLjVcbiAgICBpZiAoIChNSU5fTUFYX0RFTFRBX1JBVElPIDwgMCkgfHwgKE1JTl9NQVhfREVMVEFfUkFUSU8gPiAxKSApIHtcbiAgICAgICAgTUlOX01BWF9ERUxUQV9SQVRJTyA9IDAuNVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2hvd0F4aXMgIT0gJ2Jvb2xlYW4nKSBzaG93QXhpcyA9IGZhbHNlXG5cbiAgICBpZiAodHlwZW9mIHVzZVNjcm9sbFRyYWNrZXIgIT0gJ2Jvb2xlYW4nKSB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuXG4gICAgLy8gZm9yIG1vdW50IHZlcnNpb25cbiAgICBjb25zdCBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbGVySUQgPSBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50XG5cbiAgICAvLyBmb3IgY2hpbGRyZW5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGxpc3RzaXplUmVmID0gdXNlUmVmKGVzdGltYXRlZExpc3RTaXplKVxuXG4gICAgY29uc3QgbGlzdHNpemUgPSBsaXN0c2l6ZVJlZi5jdXJyZW50XG5cbiAgICAvLyB0ZXN0IFJlYWN0IE9iamVjdC5pcyBmb3IgYXR0cmlidXRlczsgYXZvaWQgcmUtcmVuZGVycyB3aXRoIG5vIGNoYW5nZVxuICAgIGlmICghY29tcGFyZVByb3BzKGdyaWRTcGVjcywgZ3JpZFNwZWNzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGdyaWRTcGVjc1JlZi5jdXJyZW50ID0gZ3JpZFNwZWNzXG4gICAgfVxuXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoc3R5bGVzLCBzdHlsZXNSZWYuY3VycmVudCkpIHtcbiAgICAgICAgc3R5bGVzUmVmLmN1cnJlbnQgPSBzdHlsZXNcbiAgICB9XG4gICAgaWYgKCFjb21wYXJlUHJvcHMoY2FsbGJhY2tzLCBjYWxsYmFja3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQgPSBjYWxsYmFja3NcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbml0aWFsaXphdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0ICgoKSA9PiB7XG5cbiAgICAgICAgc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudCA9IGdsb2JhbFNjcm9sbGVySUQrK1xuICAgICAgICBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCA9IG5ldyBDYWNoZUhhbmRsZXIoc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudCwgc2V0TGlzdHNpemUsIGxpc3RzaXplUmVmKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGNhbGxlZCB3aGVuIGdldEl0ZW0gcmV0dXJucyBudWxsLCBvciBkaXJlY3QgY2FsbCBmcm9tIHVzZXIgKHNlZSBzZXJ2aWNlaGFuZGxlcilcbiAgICBjb25zdCBzZXRMaXN0c2l6ZSA9IHVzZUNhbGxiYWNrKChsaXN0c2l6ZSkgPT57XG5cbiAgICAgICAgaWYgKGxpc3RzaXplID09IGxpc3RzaXplUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGxpc3RzaXplUmVmLmN1cnJlbnQgPSBsaXN0c2l6ZVxuXG4gICAgICAgIC8vIGluZm9ybSB0aGUgdXNlclxuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5uZXdMaXN0c2l6ZSAmJiBjYWxsYmFja3NSZWYuY3VycmVudC5uZXdMaXN0c2l6ZShsaXN0c2l6ZSlcblxuICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdzZXRsaXN0c2l6ZScpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTdGF0ZSBoYW5kbGluZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoc2Nyb2xsZXJTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOlxuICAgICAgICAgICAgY2FzZSAnc2V0bGlzdHNpemUnOlxuICAgICAgICAgICAgICAgIHNldFNjcm9sbGVyU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgfVxuXG4gICAgfSxbc2Nyb2xsZXJTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgUmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbXBvbmVudCBjYWxscyBhcmUgZGVmZXJyZWQgYnkgc2Nyb2xsZXJTdGF0ZSB0byBnaXZlIGNhY2hlSGFuZGxlciBhIGNoYW5jZSB0byBpbml0aWFsaXplXG4gICAgcmV0dXJuIDxSZWFjdC5TdHJpY3RNb2RlPlxuICAgICAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgICBGYWxsYmFja0NvbXBvbmVudD0geyBFcnJvckZhbGxiYWNrIH1cbiAgICAgICAgb25SZXNldD0geyAoKSA9PiB7XG4gICAgICAgICAgLy8gcmVzcG9uc2UgdGJkOyB0aGVyZSBtYXkgbm90IG5lZWQgdG8gYmUgb25lXG4gICAgICAgIH19XG4gICAgICAgIG9uRXJyb3IgPSB7KGVycm9yOiBFcnJvciwgaW5mbzoge2NvbXBvbmVudFN0YWNrOiBzdHJpbmd9KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciBjYXB0dXJlZCBlcnJvcicsIGVycm9yKVxuICAgICAgICB9fVxuICAgID5cblxuICAgICAgICB7KHNjcm9sbGVyU3RhdGUgIT0gJ3NldHVwJykgJiYgPFZpZXdwb3J0XG5cbiAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMgPSB7c2Nyb2xsZXJQcm9wZXJ0aWVzfVxuICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCA9IHsgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgfVxuXG4gICAgICAgID5cbiAgICAgICAgXG4gICAgICAgICAgICA8U2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPENyYWRsZSBcblxuICAgICAgICAgICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0geyBjYWNoZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlTWF4ID0geyBjYWNoZU1heCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDYWxsYmFja3MgPSB7IGNhbGxiYWNrc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleCA9IHsgc3RhcnRpbmdJbmRleCB9XG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICBydW53YXlTaXplID0geyBydW53YXlTaXplIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQgPSB7IHRyaWdnZXJsaW5lT2Zmc2V0IH1cblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIgPSB7Y2FjaGVIYW5kbGVyUmVmLmN1cnJlbnR9XG4gICAgICAgICAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB7dXNlU2Nyb2xsVHJhY2tlcn1cbiAgICAgICAgICAgICAgICAgICAgc2hvd0F4aXMgPSB7IHNob3dBeGlzIH1cbiAgICAgICAgICAgICAgICAgICAgTUlOX01BWF9ERUxUQV9SQVRJTyA9IHsgTUlOX01BWF9ERUxUQV9SQVRJTyB9XG4gICAgICAgICAgICAgICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMID0geyBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCB9XG4gICAgICAgICAgICAgICAgICAgIElETEVDQUxMQkFDS19USU1FT1VUID0geyBJRExFQ0FMTEJBQ0tfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTiA9IHsgTUFYX0NBQ0hFX09WRVJfUlVOIH1cbiAgICAgICAgICAgICAgICAgICAgVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTID0geyBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cblxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1Njcm9sbGJsb2NrPlxuICAgICAgICA8L1ZpZXdwb3J0Pn1cbiAgICAgICAgeyhzY3JvbGxlclN0YXRlICE9ICdzZXR1cCcpICYmIDxkaXYgZGF0YS10eXBlID0gJ2NhY2hlcm9vdCcgc3R5bGUgPSB7IGNhY2hlcm9vdHN0eWxlIH0+XG4gICAgICAgICAgICA8UG9ydGFsTGlzdCBjYWNoZVByb3BzID0geyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudC5jYWNoZVByb3BzIH0vPlxuICAgICAgICA8L2Rpdj59XG4gICAgPC9FcnJvckJvdW5kYXJ5PlxuICAgIDwvUmVhY3QuU3RyaWN0TW9kZT5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3VwcG9ydCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNhY2hlcm9vdHN0eWxlID0ge2Rpc3BsYXk6J25vbmUnfS8vIGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMgLy8gc3RhdGljLCBvdXQgb2YgdmlldyBcblxuLy8gdXRpbGl0eVxuZnVuY3Rpb24gY29tcGFyZVByb3BzIChvYmoxLG9iajIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqMSlcbiAgICBsZXQgc2FtZVxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG9iajFba2V5XSxvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIkVycm9yRmFsbGJhY2siLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInJlYWN0XzEiLCJyb2xlIiwib25DbGljayIsImdsb2JhbFNjcm9sbGVySUQiLCJJbmZpbml0ZUdyaWRTY3JvbGxlciIsInByb3BzIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImVzdGltYXRlZExpc3RTaXplIiwiZ2V0SXRlbSIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImxheW91dCIsInZhckhlaWdodE1pbiIsInZhcldpZHRoTWluIiwicnVud2F5U2l6ZSIsInN0YXJ0aW5nSW5kZXgiLCJwbGFjZWhvbGRlciIsInN0eWxlcyIsInVzZVNjcm9sbFRyYWNrZXIiLCJjYWNoZSIsImNhY2hlTWF4IiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJjYWxsYmFja3MiLCJhZHZhbmNlZCIsInNjcm9sbGVyUHJvcGVydGllcyIsImNvbnNvbGUiLCJsb2ciLCJNYXRoIiwibWF4IiwiaW5jbHVkZXMiLCJncmlkU3BlY3MiLCJncmlkU3BlY3NSZWYiLCJzY3JvbGxlclN0YXRlIiwic2V0U2Nyb2xsZXJTdGF0ZSIsInN0eWxlc1JlZiIsImNhbGxiYWNrc1JlZiIsInNob3dBeGlzIiwiVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQiLCJTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCIsIklETEVDQUxMQkFDS19USU1FT1VUIiwiVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTIiwiTUlOX01BWF9ERUxUQV9SQVRJTyIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsInNjcm9sbGVyU2Vzc2lvbklEUmVmIiwic2Nyb2xsZXJJRCIsImN1cnJlbnQiLCJjYWNoZUhhbmRsZXJSZWYiLCJsaXN0c2l6ZVJlZiIsImxpc3RzaXplIiwiY29tcGFyZVByb3BzIiwiY2FjaGVoYW5kbGVyXzEiLCJzZXRMaXN0c2l6ZSIsIm5ld0xpc3RzaXplIiwiU3RyaWN0TW9kZSIsInJlYWN0X2Vycm9yX2JvdW5kYXJ5XzEiLCJGYWxsYmFja0NvbXBvbmVudCIsIm9uUmVzZXQiLCJvbkVycm9yIiwiaW5mbyIsIlZpZXdwb3J0XzEiLCJTY3JvbGxibG9ja18xIiwiQ3JhZGxlXzEiLCJ1c2VyQ2FsbGJhY2tzIiwiY2FjaGVIYW5kbGVyIiwic3R5bGUiLCJjYWNoZXJvb3RzdHlsZSIsImNhY2hlUHJvcHMiLCJleHBvcnRzIiwiZGlzcGxheSIsIm9iajEiLCJvYmoyIiwia2V5cyIsIk9iamVjdCIsInNhbWUiLCJrZXkiLCJpcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n')},"./node_modules/react-error-boundary/dist/react-error-boundary.umd.js":function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"react\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  var changedArray = function changedArray(a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error;\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React__namespace.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React__namespace.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React__namespace.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function Wrapped(props) {\n      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__namespace.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React__namespace.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError != null) throw givenError;\n    if (error != null) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/sort-type-union-intersection-members: \"off\",\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-error-boundary.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pHLEVBQUUsQ0FDaUk7QUFDbkksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVycm9yLWJvdW5kYXJ5L2Rpc3QvcmVhY3QtZXJyb3ItYm91bmRhcnkudW1kLmpzP2U4OTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdEVycm9yQm91bmRhcnkgPSB7fSwgZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuXG4gIHZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbiAgfShSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoQ29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICB2YXIgV3JhcHBlZCA9IGZ1bmN0aW9uIFdyYXBwZWQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIGVycm9yQm91bmRhcnlQcm9wcywgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTsgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG5cblxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIiArIG5hbWUgKyBcIilcIjtcbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihnaXZlbkVycm9yKSB7XG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobnVsbCksXG4gICAgICAgIGVycm9yID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRFcnJvciA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGlmIChnaXZlbkVycm9yICE9IG51bGwpIHRocm93IGdpdmVuRXJyb3I7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBzZXRFcnJvcjtcbiAgfVxuICAvKlxuICBlc2xpbnRcbiAgICBAdHlwZXNjcmlwdC1lc2xpbnQvc29ydC10eXBlLXVuaW9uLWludGVyc2VjdGlvbi1tZW1iZXJzOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nOiBcIm9mZlwiXG4gICovXG5cbiAgZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbiAgZXhwb3J0cy51c2VFcnJvckhhbmRsZXIgPSB1c2VFcnJvckhhbmRsZXI7XG4gIGV4cG9ydHMud2l0aEVycm9yQm91bmRhcnkgPSB3aXRoRXJyb3JCb3VuZGFyeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\n")},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InPortal": () => (/* binding */ InPortal),\n/* harmony export */   "OutPortal": () => (/* binding */ OutPortal),\n/* harmony export */   "createHtmlPortalNode": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   "createSvgPortalNode": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(e){var I=__webpack_module_cache__[e];if(void 0!==I)return I.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}__webpack_require__.n=e=>{var I=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(e,I)=>{for(var l in I)__webpack_require__.o(I,l)&&!__webpack_require__.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:I[l]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,I)=>Object.prototype.hasOwnProperty.call(e,I),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/infinitegridscroller.tsx");return __webpack_exports__})()));