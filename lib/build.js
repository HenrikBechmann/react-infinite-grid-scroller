/*! For license information please see build.js.LICENSE.txt */
!function(e,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],I):"object"==typeof exports?exports["react-infinite-grid-scroller"]=I(require("react"),require("react-dom")):e["react-infinite-grid-scroller"]=I(e.react,e["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DOMRectReadOnly": () => (/* binding */ DOMRectReadOnly)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvRE9NUmVjdFJlYWRPbmx5LmpzP2ZkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObservation": () => (/* binding */ ResizeObservation)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === \'inline\';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJGQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzPzQ0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserver\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RkFBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsdUZBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHlGQUFrQztBQUMxQztBQUNBO0FBQ0EsUUFBUSwwRkFBbUM7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlci5qcz9kMDIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n")},"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverBoxOptions": () => (/* binding */ ResizeObserverBoxOptions)\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";\n    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";\n    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLmpzP2U1NTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverController": () => (/* binding */ ResizeObserverController)\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdFQUFvQjtBQUNwRCwrQ0FBK0MsaUVBQWlCO0FBQ2hFLFlBQVksNkRBQVc7QUFDdkIsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQXNCLENBQUMsMkVBQXVCO0FBQzdFO0FBQ0EsWUFBWSw2REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9EQUFvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmpzP2YzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9IGZyb20gJy4vdXRpbHMvc2NoZWR1bGVyJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmF0aW9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZhdGlvbic7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlckRldGFpbCB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJEZXRhaWwnO1xuaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRPYnNlcnZhdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9ic2VydmF0aW9uVGFyZ2V0c1tpXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBuZXcgUmVzaXplT2JzZXJ2ZXJEZXRhaWwocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXJNYXAuc2V0KHJlc2l6ZU9ic2VydmVyLCBkZXRhaWwpO1xuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgIGZpcnN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnB1c2goZGV0YWlsKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMucHVzaChuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvcHRpb25zICYmIG9wdGlvbnMuYm94KSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgxKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIHZhciBpbmRleCA9IGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIGxhc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAxO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGFzdE9ic2VydmF0aW9uICYmIHJlc2l6ZU9ic2VydmVycy5zcGxpY2UocmVzaXplT2JzZXJ2ZXJzLmluZGV4T2YoZGV0YWlsKSwgMSk7XG4gICAgICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAob3QpIHsgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTsgfSk7XG4gICAgICAgIGRldGFpbC5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCBkZXRhaWwuYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverDetail": () => (/* binding */ ResizeObserverDetail)\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanM/NzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverEntry": () => (/* binding */ ResizeObserverEntry)\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanM/NDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverSize": () => (/* binding */ ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcz9jNjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "broadcastActiveObservations": () => (/* binding */ broadcastActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLDhCQUE4Qiw2RUFBcUI7QUFDbkQ7QUFDQSxrQ0FBa0MsbUVBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzP2NhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckVudHJ5JztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJveFNpemUgfSBmcm9tICcuL2NhbGN1bGF0ZUJveFNpemUnO1xudmFyIGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hhbGxvd2VzdERlcHRoID0gSW5maW5pdHk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHJlc2l6ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NPYnNlcnZlcihybykge1xuICAgICAgICBpZiAocm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob3QudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZXB0aCA9IGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIG90Lmxhc3RSZXBvcnRlZFNpemUgPSBjYWxjdWxhdGVCb3hTaXplKG90LnRhcmdldCwgb3Qub2JzZXJ2ZWRCb3gpO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgc2hhbGxvd2VzdERlcHRoKSB7XG4gICAgICAgICAgICAgICAgc2hhbGxvd2VzdERlcHRoID0gdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgcm8uY2FsbGJhY2suY2FsbChyby5vYnNlcnZlciwgZW50cmllcywgcm8ub2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dlc3REZXB0aDtcbn07XG5leHBvcnQgeyBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateBoxSize": () => (/* binding */ calculateBoxSize),\n/* harmony export */   "calculateBoxSizes": () => (/* binding */ calculateBoxSizes)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ "./node_modules/@juggle/resize-observer/lib/utils/global.js");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || \'0\'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === \'border-box\';\n    var switchSizes = verticalRegexp.test(cs.writingMode || \'\');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || \'\');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || \'\');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFnQixJQUFJLHFFQUEwQjtBQUM5RSx3Q0FBd0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxlQUFlLG1FQUFrQjtBQUNqQztBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEMsQ0FBQztBQUNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0dBQWlEO0FBQzlEO0FBQ0EsYUFBYSwwRkFBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcz8xMDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlclNpemUnO1xuaW1wb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH0gZnJvbSAnLi4vRE9NUmVjdFJlYWRPbmx5JztcbmltcG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiB9IGZyb20gJy4uL3V0aWxzL2VsZW1lbnQnO1xuaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi4vdXRpbHMvZnJlZXplJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbCc7XG52YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNjcm9sbFJlZ2V4cCA9IC9hdXRvfHNjcm9sbC87XG52YXIgdmVydGljYWxSZWdleHAgPSAvXnRifHZlcnRpY2FsLztcbnZhciBJRSA9ICgvbXNpZXx0cmlkZW50L2kpLnRlc3QoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgcGFyc2VEaW1lbnNpb24gPSBmdW5jdGlvbiAocGl4ZWwpIHsgcmV0dXJuIHBhcnNlRmxvYXQocGl4ZWwgfHwgJzAnKTsgfTtcbnZhciBzaXplID0gZnVuY3Rpb24gKGlubGluZVNpemUsIGJsb2NrU2l6ZSwgc3dpdGNoU2l6ZXMpIHtcbiAgICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7IGlubGluZVNpemUgPSAwOyB9XG4gICAgaWYgKGJsb2NrU2l6ZSA9PT0gdm9pZCAwKSB7IGJsb2NrU2l6ZSA9IDA7IH1cbiAgICBpZiAoc3dpdGNoU2l6ZXMgPT09IHZvaWQgMCkgeyBzd2l0Y2hTaXplcyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG59O1xudmFyIHplcm9Cb3hlcyA9IGZyZWV6ZSh7XG4gICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGJvcmRlckJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KDAsIDAsIDAsIDApXG59KTtcbnZhciBjYWxjdWxhdGVCb3hTaXplcyA9IGZ1bmN0aW9uICh0YXJnZXQsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIGlmIChmb3JjZVJlY2FsY3VsYXRpb24gPT09IHZvaWQgMCkgeyBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChjYWNoZS5oYXModGFyZ2V0KSAmJiAhZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGlzSGlkZGVuKHRhcmdldCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgemVyb0JveGVzKTtcbiAgICAgICAgcmV0dXJuIHplcm9Cb3hlcztcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcbiAgICB2YXIgcmVtb3ZlUGFkZGluZyA9ICFJRSAmJiBjcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgICB2YXIgc3dpdGNoU2l6ZXMgPSB2ZXJ0aWNhbFJlZ2V4cC50ZXN0KGNzLndyaXRpbmdNb2RlIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsVmVydGljYWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dZIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gIXN2ZyAmJiBzY3JvbGxSZWdleHAudGVzdChjcy5vdmVyZmxvd1ggfHwgJycpO1xuICAgIHZhciBwYWRkaW5nVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdUb3ApO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ1JpZ2h0KTtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nQm90dG9tKTtcbiAgICB2YXIgcGFkZGluZ0xlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0xlZnQpO1xuICAgIHZhciBib3JkZXJUb3AgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbEJvcmRlckFyZWEgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsQm9yZGVyQXJlYSA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxIb3Jpem9udGFsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldEhlaWdodCAtIHZlcnRpY2FsQm9yZGVyQXJlYSAtIHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzID0gIWNhblNjcm9sbFZlcnRpY2FsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpZHRoUmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlckFyZWEgOiAwO1xuICAgIHZhciBoZWlnaHRSZWR1Y3Rpb24gPSByZW1vdmVQYWRkaW5nID8gdmVydGljYWxQYWRkaW5nICsgdmVydGljYWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gc3ZnID8gc3ZnLndpZHRoIDogcGFyc2VEaW1lbnNpb24oY3Mud2lkdGgpIC0gd2lkdGhSZWR1Y3Rpb24gLSB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgY29udGVudEhlaWdodCA9IHN2ZyA/IHN2Zy5oZWlnaHQgOiBwYXJzZURpbWVuc2lvbihjcy5oZWlnaHQpIC0gaGVpZ2h0UmVkdWN0aW9uIC0gaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgYm9yZGVyQm94V2lkdGggPSBjb250ZW50V2lkdGggKyBob3Jpem9udGFsUGFkZGluZyArIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzICsgaG9yaXpvbnRhbEJvcmRlckFyZWE7XG4gICAgdmFyIGJvcmRlckJveEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmcgKyBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzICsgdmVydGljYWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3hlcyA9IGZyZWV6ZSh7XG4gICAgICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoTWF0aC5yb3VuZChjb250ZW50V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSwgTWF0aC5yb3VuZChjb250ZW50SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpbyksIHN3aXRjaFNpemVzKSxcbiAgICAgICAgYm9yZGVyQm94U2l6ZTogc2l6ZShib3JkZXJCb3hXaWR0aCwgYm9yZGVyQm94SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGNvbnRlbnRCb3hTaXplOiBzaXplKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seShwYWRkaW5nTGVmdCwgcGFkZGluZ1RvcCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0KVxuICAgIH0pO1xuICAgIGNhY2hlLnNldCh0YXJnZXQsIGJveGVzKTtcbiAgICByZXR1cm4gYm94ZXM7XG59O1xudmFyIGNhbGN1bGF0ZUJveFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYnNlcnZlZEJveCwgZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgdmFyIF9hID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pLCBib3JkZXJCb3hTaXplID0gX2EuYm9yZGVyQm94U2l6ZSwgY29udGVudEJveFNpemUgPSBfYS5jb250ZW50Qm94U2l6ZSwgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IF9hLmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgc3dpdGNoIChvYnNlcnZlZEJveCkge1xuICAgICAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5ERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1g6XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQk9SREVSX0JPWDpcbiAgICAgICAgICAgIHJldHVybiBib3JkZXJCb3hTaXplO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3hTaXplO1xuICAgIH1cbn07XG5leHBvcnQgeyBjYWxjdWxhdGVCb3hTaXplLCBjYWxjdWxhdGVCb3hTaXplcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateDepthForNode": () => (/* binding */ calculateDepthForNode)\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzP2M5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deliverResizeLoopError\": () => (/* binding */ deliverResizeLoopError)\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2RlbGl2ZXJSZXNpemVMb29wRXJyb3IuanM/YzJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n")},"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "gatherActiveObservationsAtDepth": () => (/* binding */ gatherActiveObservationsAtDepth)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQzJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9nYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoLmpzPzQ1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbnZhciBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMuc3BsaWNlKDAsIHJvLnNraXBwZWRUYXJnZXRzLmxlbmd0aCk7XG4gICAgICAgIHJvLm9ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NUYXJnZXQob3QpIHtcbiAgICAgICAgICAgIGlmIChvdC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5wdXNoKG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasActiveObservations": () => (/* binding */ hasActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyx3RUFBb0IsaUJBQWlCLHFDQUFxQztBQUNyRjtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzP2RkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbnZhciBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasSkippedObservations": () => (/* binding */ hasSkippedObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsd0VBQW9CLGlCQUFpQixzQ0FBc0M7QUFDdEY7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc1NraXBwZWRPYnNlcnZhdGlvbnMuanM/YzEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc1NraXBwZWRPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoID4gMDsgfSk7XG59O1xuZXhwb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserver": () => (/* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver),\n/* harmony export */   "ResizeObserverEntry": () => (/* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry),\n/* harmony export */   "ResizeObserverSize": () => (/* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9leHBvcnRzL3Jlc2l6ZS1vYnNlcnZlci5qcz8xZDFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/element.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isElement\": () => (/* binding */ isElement),\n/* harmony export */   \"isHidden\": () => (/* binding */ isHidden),\n/* harmony export */   \"isReplacedElement\": () => (/* binding */ isReplacedElement),\n/* harmony export */   \"isSVG\": () => (/* binding */ isSVG)\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9lbGVtZW50LmpzPzNjZDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/freeze.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "freeze": () => (/* binding */ freeze)\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvZnJlZXplLmpzP2ZjZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/global.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"global\": () => (/* binding */ global)\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9nbG9iYWwuanM/Y2I3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/process.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "process": () => (/* binding */ process)\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzP2Q0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueMicroTask": () => (/* binding */ queueMicroTask)\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode(\'\');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVNaWNyb1Rhc2suanM/YTk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueResizeObserver": () => (/* binding */ queueResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVSZXNpemVPYnNlcnZlci5qcz9hMzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "resizeObservers": () => (/* binding */ resizeObservers)\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9yZXNpemVPYnNlcnZlcnMuanM/YThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduler\": () => (/* binding */ scheduler),\n/* harmony export */   \"updateCount\": () => (/* binding */ updateCount)\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDREQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDREQUF1QiwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sK0RBQTBCLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n")},"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n        - anything else is treated as an error\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its parent that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical position in the list) and session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n\n    One CellFrame at a time is desgnated as the host of the two triggerLines (which trigger an update\n    of the Cradle), with the isTriggerCell flag.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n    cellHeight = _ref.cellHeight,\n    cellWidth = _ref.cellWidth,\n    cellMinHeight = _ref.cellMinHeight,\n    cellMinWidth = _ref.cellMinWidth,\n    layout = _ref.layout,\n    getItem = _ref.getItem,\n    listsize = _ref.listsize,\n    placeholder = _ref.placeholder,\n    itemID = _ref.itemID,\n    index = _ref.index,\n    instanceID = _ref.instanceID,\n    scrollerID = _ref.scrollerID,\n    isTriggercell = _ref.isTriggercell,\n    placeholderFrameStyles = _ref.placeholderFrameStyles,\n    placeholderLinerStyles = _ref.placeholderLinerStyles,\n    usePlaceholder = _ref.usePlaceholder;\n  var coreConfigRef = (0, react_1.useRef)(null);\n  coreConfigRef.current = {\n    layout: layout,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight\n  };\n  // ----------------------[ setup ]----------------------\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n    scrollerPropertiesRef = cradleContext.scrollerPropertiesRef,\n    nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n    itemExceptionCallback = cradleContext.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef;\n  // style change generates state refresh\n  // const [styles,saveStyles] = useState({})\n  var stylesRef = (0, react_1.useRef)({});\n  // processing state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameState = _ref3[0],\n    setFrameState = _ref3[1];\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState;\n  // console.log(\'RUNNING frameState\',\'-\'+index+\'-\' ,typeof index ,\'_\'+instanceID+\'_\', frameState)\n  // DOM ref\n  var frameRef = (0, react_1.useRef)(null);\n  // to track unmount interrupt\n  var isMountedRef = (0, react_1.useRef)(true);\n  // cache data\n  var portalMetadataRef = (0, react_1.useRef)(null);\n  // the placeholder to use\n  var placeholderRef = (0, react_1.useRef)(null);\n  // the session itemID to use; could be updated by parent\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID;\n  var latestItemIDRef = (0, react_1.useRef)(null);\n  var cellFrameDataRef = (0, react_1.useRef)(null);\n  cellFrameDataRef.current = {\n    itemID: itemID,\n    index: index\n  };\n  // fetch error\n  var errorRef = (0, react_1.useRef)(false);\n  // placeholder message\n  var messageRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // for unmount\n  (0, react_1.useEffect)(function () {\n    return function () {\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.removeRequestedPortal(index);\n    };\n  }, []);\n  // refresh content if itemID changes\n  (0, react_1.useEffect)(function () {\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]);\n  // ----------------- [ placeholder definition ] -------------------------\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, messageRef.current, errorRef.current, usePlaceholder]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userLinerStyles: placeholderLinerStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current, usePlaceholder]);\n  // ---------------- [ requestidlecallback config ] ------------------------\n  var requestidlecallback = window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback = window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null);\n  // --------------------[ processing ]-----------------\n  // set styles\n  (0, react_1.useEffect)(function () {\n    // console.log(\'getting styles\')\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, stylesRef.current);\n    if (isMountedRef.current) {\n      // saveStyles(newStyles)\n      stylesRef.current = newStyles;\n    }\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  var isReparentingRef = (0, react_1.useRef)(false);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        {\n          setFrameState(\'working\');\n          break;\n        }\n      case \'working\':\n        {\n          setFrameState(\'preparing\');\n        }\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID);\n          var _coreConfigRef$curren = coreConfigRef.current,\n            _layout = _coreConfigRef$curren.layout,\n            _orientation = _coreConfigRef$curren.orientation,\n            _cellWidth = _coreConfigRef$curren.cellWidth,\n            _cellHeight = _coreConfigRef$curren.cellHeight;\n          if (cached) {\n            messageRef.current = \'(retrieving from cache)\';\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheHandler.getPortal(_itemID);\n              // get OutPortal node\n              portalNodeRef.current = portalMetadataRef.current.portalNode;\n              setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n              // notify fetched component that reparenting is underway\n              portalMetadataRef.current.isReparentingRef.current = true;\n              setFrameState(\'retrieved\');\n            }\n          } else {\n            messageRef.current = \'(loading...)\';\n            setFrameState(\'fetching\');\n            // reserve space in the cache\n            cacheHandler.registerRequestedPortal(index);\n            // enqueue the fetch\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, isValidElement, content, scrollerProperties;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return getItem(index, _itemID);\n                      case 3:\n                        usercontent = _context.sent;\n                        if (usercontent === null) returnvalue = usercontent;\n                        if (usercontent === undefined) {\n                          error = new Error(\'host returned "undefined"\');\n                        }\n                        _context.next = 12;\n                        break;\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context["catch"](0);\n                        returnvalue = usercontent = undefined;\n                        error = _context.t0;\n                      case 12:\n                        // process the return value\n                        if (usercontent !== null && usercontent !== undefined) {\n                          isValidElement = react_1["default"].isValidElement(usercontent);\n                          if (!isValidElement) {\n                            returnvalue = usercontent;\n                            usercontent = undefined;\n                            error = new Error(\'invalid React element\');\n                          }\n                        }\n                        if (isMountedRef.current) {\n                          // prepare the content\n                          if (usercontent !== null && usercontent !== undefined) {\n                            // if usercontent is otherwise disallowed, let error handling deal with it.\n                            scrollerProperties = {\n                              isReparentingRef: null,\n                              cellFrameDataRef: cellFrameDataRef,\n                              scrollerPropertiesRef: scrollerPropertiesRef\n                            };\n                            if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                              content = react_1["default"].cloneElement(usercontent, {\n                                scrollerProperties: scrollerProperties\n                              });\n                            } else {\n                              content = usercontent;\n                            }\n                            portalMetadataRef.current = cacheHandler.createPortal(content, index, _itemID);\n                            portalNodeRef.current = portalMetadataRef.current.portalNode;\n                            setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n                            // make available to user content\n                            scrollerProperties.isReparentingRef = portalMetadataRef.current.isReparentingRef;\n                            isMountedRef.current && setFrameState(\'inserting\');\n                          } else {\n                            // null or undefined; handle non-component value\n                            if (usercontent === null) {\n                              // truncate listsize at this index\n                              itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(\'end of list\'));\n                              nullItemSetMaxListsize(index);\n                            } else {\n                              // usercontent === undefined, meaning an error has occurred\n                              // change placeholder message to error message\n                              errorRef.current = error;\n                              // notify the host\n                              itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                              isMountedRef.current && setFrameState(\'error\');\n                            }\n                          }\n                        }\n                      case 14:\n                      case "end":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n          break;\n        }\n      case \'retrieved\':\n      case \'inserting\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n    }\n  }, [frameState]);\n  // with \'inserting\' the content is still in cache\n  // the content re-renders with \'ready\' when the height/width have returned to normal after-cache\n  // React re-renders on diff between the two (virtual vs real DOM)\n  // this gives the content component a chance to respond to uncaching\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: stylesRef.current\n  }, frameState != \'setup\' && (frameState != \'ready\' ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    node: portalNodeRef.current\n  })), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\nexports["default"] = CellFrame;\n// utilities\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\',\n    overflow: \'visible\'\n  });\n  if (orientation === \'vertical\') {\n    styleset.width = null;\n    if (layout == \'uniform\') {\n      styleset.height = cellHeight + \'px\';\n      styleset.minHeight = null;\n      styleset.maxHeight = null;\n    } else {\n      // \'variable\'\n      styleset.height = null;\n      styleset.minHeight = cellMinHeight + \'px\';\n      styleset.maxHeight = cellHeight + \'px\';\n    }\n  } else {\n    // \'horizontal\'\n    styleset.height = null;\n    if (layout == \'uniform\') {\n      styleset.width = cellWidth + \'px\';\n      styleset.minWidth = null;\n      styleset.maxWidth = null;\n    } else {\n      // \'variable\'\n      styleset.width = null;\n      styleset.minWidth = cellMinWidth + \'px\';\n      styleset.maxWidth = cellWidth + \'px\';\n    }\n  }\n  return styleset;\n};\n// see also some base styles set in cachehandler\nvar setContainerStyles = function setContainerStyles(container, layout, orientation, cellWidth, cellHeight) {\n  container.style.overflow = \'hidden\';\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n    container.style.maxWidth = null;\n    container.style.maxHeight = null;\n    container.style.height = null;\n    container.style.width = null;\n  } else {\n    // variable\n    container.style.inset = null;\n    container.style.position = null;\n    if (orientation == \'vertical\') {\n      container.style.width = \'100%\';\n      container.style.height = null;\n      container.style.maxWidth = null;\n      container.style.maxHeight = cellHeight + \'px\';\n    } else {\n      container.style.width = null;\n      container.style.height = \'100%\';\n      container.style.maxWidth = cellWidth + \'px\';\n      container.style.maxHeight = null;\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLLENBQUNXLFNBQVMsR0FBRyxJQUFJOzs7QUFLNUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvQ2VsbEZyYW1lLnRzeD9mMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbGxGcmFtZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2YgQ2VsbEZyYW1lIGlzIHRvIGZldGNoIHVzZXIgY29udGVudCBmcm9tIHRoZSBjYWNoZSwgb3IgZnJvbSB0aGUgaG9zdCAodXNpbmcgZ2V0SXRlbSkuXG4gICAgV2hpbGUgYW4gaXRlbSBpcyBiZWluZyBmZXRjaGVkLCBDZWxsRnJhbWUgcHJlc2VudHMgYSBwbGFjZWhvbGRlciAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGFuIFxuICAgIGltcG9ydGVkIGN1c3RvbSB2ZXJzaW9uKS4gSWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gZmV0Y2hpbmcgY29udGVudCB0aGVuIHRoZSBwbGFjZWhvbGRlciBpcyB1c2VkXG4gICAgdG8gcHJlc2VudCB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuIElmIGEgbmV3IGl0ZW1JRCBpcyBzZXQgYnkgdGhlIHBhcmVudCAodG8gc3luY2hyb25pemUgd2l0aCBhbiBhbHRlcmVkXG4gICAgY2FjaGUpLCB0aGVuIENlbGxGcmFtZSByZXBsYWNlcyB0aGUgb2xkIGl0ZW0gd2l0aCB0aGUgbmV3IGl0ZW0uXG5cbiAgICBnZXRJdGVtICh3aGljaCBpcyBhIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBob3N0KSBjYW4gcmV0dXJuIG9uZSBvZiBzZXZlcmFsIHZhbHVlczpcbiAgICAgICAgLSBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgICAtIGEgcHJvbWlzZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICAtIG51bGxcbiAgICAgICAgLSB1bmRlZmluZWRcbiAgICAgICAgLSBhbnl0aGluZyBlbHNlIGlzIHRyZWF0ZWQgYXMgYW4gZXJyb3JcbiAgICBpZiBhIHByb21pc2UgaXMgcmV0dXJuZWQsIHRoZW4gdGhlIHByb21pc2UgcmV0dXJucyBhIFJlYWN0IGNvbXBvbmVudCwgbnVsbCBvciB1bmRlZmluZWQuXG5cbiAgICBJZiBhIHZhbGlkIHJlYWN0IGNvbXBvbmVudCBpcyByZXR1cm5lZCwgdGhlbiBpdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlIGNhY2hlLCBhbmQgcmVuZGVyZWQgaW4gdGhlXG4gICAgQ2VsbEZyYW1lLiBJZiBudWxsIGlzIHJldHVybmVkLCB0aGVuIENlbGxGcmFtZSBzZW5kcyBhIG1lc3NhZ2UgdG8gaXRzIHBhcmVudCB0aGF0IHRoZSBob3N0IGhhcyBcbiAgICBpbmRpY2F0ZWQgdGhlIHRoZSBpdGVtIGJlaW5nIGZldGNoZWQgaW5zdGVhZCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhlIGxpc3QsIGFuZCB0aGUgbGlzdHNpemUgc2hvdWxkXG4gICAgYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkuIEFueSBvdGhlciB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGlzIHRyZWF0ZWQgYXMgYW4gZXJyb3IsIGFuZCBwcmVzZW50ZWRcbiAgICBhcyBzdWNoIHRvIHRoZSB1c2VyIHRocm91Z2ggdGhlIHBsYWNlaG9sZGVyIGNvbXBvbmVudC5cblxuICAgIGdldEl0ZW0gc2VuZHMgdGhlIGluZGV4IChsb2dpY2FsIHBvc2l0aW9uIGluIHRoZSBsaXN0KSBhbmQgc2Vzc2lvbiBpdGVtSUQgdG8gdGhlIGhvc3QsIHNvIHRoYXRcbiAgICB0aGUgaG9zdCBjYW4gc3luYyBpdHMgb3duIHRyYWNraW5nIHdpdGggdGhlIHNjcm9sbGVyLlxuXG4gICAgT25lIENlbGxGcmFtZSBhdCBhIHRpbWUgaXMgZGVzZ25hdGVkIGFzIHRoZSBob3N0IG9mIHRoZSB0d28gdHJpZ2dlckxpbmVzICh3aGljaCB0cmlnZ2VyIGFuIHVwZGF0ZSBcbiAgICBvZiB0aGUgQ3JhZGxlKSwgd2l0aCB0aGUgaXNUcmlnZ2VyQ2VsbCBmbGFnLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7XG4gICAgdXNlUmVmLCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZUNhbGxiYWNrLCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDb250ZXh0IFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHtyZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2t9IGZyb20gJ3JlcXVlc3RpZGxlY2FsbGJhY2snIC8vIHBvbHlmaWxsIGlmIG5lZWRlZFxuXG5pbXBvcnQgeyBPdXRQb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCcgLy8gZmV0Y2ggZnJvbSBjYWNoZVxuXG5pbXBvcnQgUGxhY2Vob2xkZXIgZnJvbSAnLi9jZWxsZnJhbWUvUGxhY2Vob2xkZXInIC8vIGRlZmF1bHRcblxuaW1wb3J0IHsgQ3JhZGxlQ29udGV4dCB9IGZyb20gJy4vQ3JhZGxlJ1xuXG5jb25zdCBDZWxsRnJhbWUgPSAoe1xuICAgIG9yaWVudGF0aW9uLCBcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgY2VsbE1pbldpZHRoLFxuICAgIGxheW91dCxcbiAgICBnZXRJdGVtLCAvLyBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0XG4gICAgbGlzdHNpemUsIC8vIGZvciBmZWVkYmFjayBpbiBwbGFjZWhvbGRlclxuICAgIHBsYWNlaG9sZGVyLCAvLyBvcHRpb25hbGx5IHByb3ZpZGVkIGJ5IGhvc3RcbiAgICBpdGVtSUQsIC8vIHNlc3Npb24gaXRlbUlEXG4gICAgaW5kZXgsIC8vIGxvZ2ljYWwgcG9zaXRpb24gaW4gaW5maW5pdGUgbGlzdFxuICAgIGluc3RhbmNlSUQsIC8vIENlbGxGcmFtZSBzZXNzaW9uIElEXG4gICAgc2Nyb2xsZXJJRCwgLy8gc2Nyb2xsZXIgSUQgKGZvciBkZWJ1Z2dpbmcpXG4gICAgaXNUcmlnZ2VyY2VsbCxcbiAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXMsXG4gICAgdXNlUGxhY2Vob2xkZXIsXG59KSA9PiB7XG5cbiAgICBjb25zdCBjb3JlQ29uZmlnUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29yZUNvbmZpZ1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbEhlaWdodFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZXh0ID0gdXNlQ29udGV4dChDcmFkbGVDb250ZXh0KVxuXG4gICAgY29uc3QgeyBcbiAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLCAvLyBmb3IgdGhlIHVzZXIgY29udGVudCwgaWYgcmVxdWVzdGVkXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIC8vIGZvciBpbnRlcm5hbCBub3RpZmljYXRpb24gb2YgZW5kLW9mLWxpc3RcbiAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLCAvLyBvciBub3RpZmljYXRpb24gdG8gaG9zdCBvZiBlcnJvclxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCwgLy8gdG8gb3B0aW1pemUgcmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZixcbiAgICB9ID0gY3JhZGxlQ29udGV4dFxuICAgIFxuICAgIC8vIHN0eWxlIGNoYW5nZSBnZW5lcmF0ZXMgc3RhdGUgcmVmcmVzaFxuICAgIC8vIGNvbnN0IFtzdHlsZXMsc2F2ZVN0eWxlc10gPSB1c2VTdGF0ZSh7fSlcbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoe30pXG5cbiAgICAvLyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgY29uc3QgW2ZyYW1lU3RhdGUsIHNldEZyYW1lU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBmcmFtZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpXG4gICAgZnJhbWVTdGF0ZVJlZi5jdXJyZW50ID0gZnJhbWVTdGF0ZVxuXG4gICAgLy8gY29uc29sZS5sb2coJ1JVTk5JTkcgZnJhbWVTdGF0ZScsJy0nK2luZGV4KyctJyAsdHlwZW9mIGluZGV4ICwnXycraW5zdGFuY2VJRCsnXycsIGZyYW1lU3RhdGUpXG5cbiAgICAvLyBET00gcmVmXG4gICAgY29uc3QgZnJhbWVSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0byB0cmFjayB1bm1vdW50IGludGVycnVwdFxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuICAgIC8vIGNhY2hlIGRhdGFcbiAgICBjb25zdCBwb3J0YWxNZXRhZGF0YVJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHRoZSBwbGFjZWhvbGRlciB0byB1c2VcbiAgICBjb25zdCBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHRoZSBzZXNzaW9uIGl0ZW1JRCB0byB1c2U7IGNvdWxkIGJlIHVwZGF0ZWQgYnkgcGFyZW50XG4gICAgY29uc3QgaXRlbUlEUmVmID0gdXNlUmVmKG51bGwpXG4gICAgaXRlbUlEUmVmLmN1cnJlbnQgPSBpdGVtSURcbiAgICBjb25zdCBsYXRlc3RJdGVtSURSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBjZWxsRnJhbWVEYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY2VsbEZyYW1lRGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICBpdGVtSUQsXG4gICAgICAgIGluZGV4XG4gICAgfVxuICAgIC8vIGZldGNoIGVycm9yXG4gICAgY29uc3QgZXJyb3JSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgLy8gcGxhY2Vob2xkZXIgbWVzc2FnZVxuICAgIGNvbnN0IG1lc3NhZ2VSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gZm9yIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBjYW5jZWxpZGxlY2FsbGJhY2socmVxdWVzdElkbGVDYWxsYmFja0lkUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW1vdmVSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIHJlZnJlc2ggY29udGVudCBpZiBpdGVtSUQgY2hhbmdlc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkgc2V0RnJhbWVTdGF0ZSgnZ2V0dXNlcmNvbnRlbnQnKVxuXG4gICAgfSxbaXRlbUlEXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tIFsgcGxhY2Vob2xkZXIgZGVmaW5pdGlvbiBdIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGN1c3RvbXBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgaWYgKCF1c2VQbGFjZWhvbGRlcikgcmV0dXJuIG51bGwgICAgICAgIFxuXG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcj9cbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQocGxhY2Vob2xkZXIsIFxuICAgICAgICAgICAgICAgIHtpbmRleCwgbGlzdHNpemUsIG1lc3NhZ2U6bWVzc2FnZVJlZi5jdXJyZW50LCBlcnJvcjplcnJvclJlZi5jdXJyZW50fSk6XG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBcbiAgICB9LFtcbiAgICAgICAgaW5kZXgsIFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbGlzdHNpemUsIFxuICAgICAgICBtZXNzYWdlUmVmLmN1cnJlbnQsIFxuICAgICAgICBlcnJvclJlZi5jdXJyZW50LCBcbiAgICAgICAgdXNlUGxhY2Vob2xkZXJcbiAgICBdKVxuXG4gICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHVzZU1lbW8oKCk9PntcblxuICAgICAgICBpZiAoIXVzZVBsYWNlaG9sZGVyKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gXG4gICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcj9cbiAgICAgICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcjpcbiAgICAgICAgICAgICAgICA8UGxhY2Vob2xkZXIgXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfSBcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHsgbWVzc2FnZVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7IGVycm9yUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyTGluZXJTdHlsZXMgPSB7IHBsYWNlaG9sZGVyTGluZXJTdHlsZXMgfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyXG5cbiAgICB9LCBbXG4gICAgICAgIGluZGV4LCBcbiAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXIsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCwgXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQsXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuICAgIF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFsgcmVxdWVzdGlkbGVjYWxsYmFjayBjb25maWcgXSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHJlcXVlc3RpZGxlY2FsbGJhY2sgPSBcbiAgICAgICAgd2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ10/XG4gICAgICAgICAgICB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXTpcbiAgICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2tcblxuICAgIGNvbnN0IGNhbmNlbGlkbGVjYWxsYmFjayA9IFxuICAgICAgICB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddP1xuICAgICAgICAgICAgd2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXTpcbiAgICAgICAgICAgIGNhbmNlbElkbGVDYWxsYmFja1xuXG4gICAgY29uc3QgcmVxdWVzdElkbGVDYWxsYmFja0lkUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHNldCBzdHlsZXNcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZ2V0dGluZyBzdHlsZXMnKVxuICAgICAgICBsZXQgbmV3U3R5bGVzID0gZ2V0RnJhbWVTdHlsZXMoXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsIGxheW91dCwgc3R5bGVzUmVmLmN1cnJlbnQpXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIHNhdmVTdHlsZXMobmV3U3R5bGVzKVxuICAgICAgICAgICAgc3R5bGVzUmVmLmN1cnJlbnQgPSBuZXdTdHlsZXNcbiAgICAgICAgfVxuXG4gICAgfSxbb3JpZW50YXRpb24sY2VsbEhlaWdodCxjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0XSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBpc1JlcGFyZW50aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKGZyYW1lU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzoge1xuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3dvcmtpbmcnKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dvcmtpbmcnOiB7XG4gICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncHJlcGFyaW5nJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZ2V0dXNlcmNvbnRlbnQnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpdGVtSURSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlSGFuZGxlci5oYXNQb3J0YWwoaXRlbUlEKVxuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gPSBjb3JlQ29uZmlnUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gJyhyZXRyaWV2aW5nIGZyb20gY2FjaGUpJ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBjYWNoZUhhbmRsZXIuZ2V0UG9ydGFsKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBPdXRQb3J0YWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250YWluZXJTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50LmVsZW1lbnQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBmZXRjaGVkIGNvbXBvbmVudCB0aGF0IHJlcGFyZW50aW5nIGlzIHVuZGVyd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LmlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmV0cmlldmVkJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9ICcobG9hZGluZy4uLiknXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnZmV0Y2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2VydmUgc3BhY2UgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZWdpc3RlclJlcXVlc3RlZFBvcnRhbChpbmRleClcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSB0aGUgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFja0lkUmVmLmN1cnJlbnQgPSByZXF1ZXN0aWRsZWNhbGxiYWNrKGFzeW5jICgpPT57XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWx1ZSwgdXNlcmNvbnRlbnQsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gYXdhaXQgZ2V0SXRlbShpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSBudWxsKSByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdob3N0IHJldHVybmVkIFwidW5kZWZpbmVkXCInKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gUmVhY3QuaXNWYWxpZEVsZW1lbnQodXNlcmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2ludmFsaWQgUmVhY3QgZWxlbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlcmNvbnRlbnQgaXMgb3RoZXJ3aXNlIGRpc2FsbG93ZWQsIGxldCBlcnJvciBoYW5kbGluZyBkZWFsIHdpdGggaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlcGFyZW50aW5nUmVmOm51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRnJhbWVEYXRhUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudC5wcm9wcz8uaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KHVzZXJjb250ZW50LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jcmVhdGVQb3J0YWwoY29udGVudCwgaW5kZXgsIGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRhaW5lclN0eWxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudC5lbGVtZW50LCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHRvIHVzZXIgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZiA9IHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZDsgaGFuZGxlIG5vbi1jb21wb25lbnQgdmFsdWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdjZWxsRnJhbWUnLCBuZXcgRXJyb3IoJ2VuZCBvZiBsaXN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQsIG1lYW5pbmcgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBwbGFjZWhvbGRlciBtZXNzYWdlIHRvIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBob3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRGcmFtZVN0YXRlKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0se3RpbWVvdXQ6SURMRUNBTExCQUNLX1RJTUVPVVR9KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmV0cmlldmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2luc2VydGluZyc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2ZyYW1lU3RhdGVdKVxuXG4gICAgLy8gd2l0aCAnaW5zZXJ0aW5nJyB0aGUgY29udGVudCBpcyBzdGlsbCBpbiBjYWNoZVxuICAgIC8vIHRoZSBjb250ZW50IHJlLXJlbmRlcnMgd2l0aCAncmVhZHknIHdoZW4gdGhlIGhlaWdodC93aWR0aCBoYXZlIHJldHVybmVkIHRvIG5vcm1hbCBhZnRlci1jYWNoZVxuICAgIC8vIFJlYWN0IHJlLXJlbmRlcnMgb24gZGlmZiBiZXR3ZWVuIHRoZSB0d28gKHZpcnR1YWwgdnMgcmVhbCBET00pXG4gICAgLy8gdGhpcyBnaXZlcyB0aGUgY29udGVudCBjb21wb25lbnQgYSBjaGFuY2UgdG8gcmVzcG9uZCB0byB1bmNhY2hpbmdcbiAgICByZXR1cm4gPGRpdiBcblxuICAgICAgICByZWYgPSB7IGZyYW1lUmVmIH0gXG4gICAgICAgIGRhdGEtdHlwZSA9ICdjZWxsZnJhbWUnIFxuICAgICAgICBkYXRhLXNjcm9sbGVyaWQgPSB7IHNjcm9sbGVySUQgfSBcbiAgICAgICAgZGF0YS1pbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgZGF0YS1pbnN0YW5jZWlkID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIHN0eWxlID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG5cbiAgICA+XG5cbiAgICAgICAgeyBcbiAgICAgICAgICAgKGZyYW1lU3RhdGUgIT0gJ3NldHVwJykgJiYgKChmcmFtZVN0YXRlICE9ICdyZWFkeScpP1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgPE91dFBvcnRhbCBub2RlID0geyBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgfS8+KVxuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzVHJpZ2dlcmNlbGw/XG4gICAgICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYuY3VycmVudDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgPC9kaXY+XG5cbn0gLy8gQ2VsbEZyYW1lXG5cbmV4cG9ydCBkZWZhdWx0IENlbGxGcmFtZVxuXG4vLyB1dGlsaXRpZXNcbmNvbnN0IGdldEZyYW1lU3R5bGVzID0gXG4gICAgKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0LCBzdHlsZXMpID0+IHtcblxuICAgIGxldCBzdHlsZXNldCA9IHsuLi5zdHlsZXMscG9zaXRpb246J3JlbGF0aXZlJywgb3ZlcmZsb3c6J3Zpc2libGUnfVxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhIZWlnaHQgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBjZWxsTWluSGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWF4SGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCdcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IG51bGxcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gbnVsbFxuXG4gICAgICAgIH0gZWxzZSB7IC8vICd2YXJpYWJsZSdcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IGNlbGxNaW5XaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXNldFxuXG59XG5cbi8vIHNlZSBhbHNvIHNvbWUgYmFzZSBzdHlsZXMgc2V0IGluIGNhY2hlaGFuZGxlclxuY29uc3Qgc2V0Q29udGFpbmVyU3R5bGVzID0gKGNvbnRhaW5lciwgbGF5b3V0LCBvcmllbnRhdGlvbiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KSA9PiB7XG5cbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuXG4gICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSAnMHB4JyBcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICBjb250YWluZXIuc3R5bGUubWF4V2lkdGggPSBudWxsXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhIZWlnaHQgPSBudWxsXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBudWxsXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IG51bGxcblxuICAgIH0gZWxzZSB7IC8vIHZhcmlhYmxlXG5cbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmluc2V0ID0gbnVsbCBcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gbnVsbFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG51bGxcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhXaWR0aCA9IG51bGxcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhIZWlnaHQgPSBjZWxsSGVpZ2h0ICsgJ3B4J1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IG51bGxcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhXaWR0aCA9IGNlbGxXaWR0aCArICdweCdcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhIZWlnaHQgPSBudWxsXG5cbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG4iXSwibmFtZXMiOlsiQ2VsbEZyYW1lIiwib3JpZW50YXRpb24iLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImxheW91dCIsImdldEl0ZW0iLCJsaXN0c2l6ZSIsInBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiaW5kZXgiLCJpbnN0YW5jZUlEIiwic2Nyb2xsZXJJRCIsImlzVHJpZ2dlcmNlbGwiLCJwbGFjZWhvbGRlckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJMaW5lclN0eWxlcyIsInVzZVBsYWNlaG9sZGVyIiwiY29yZUNvbmZpZ1JlZiIsImN1cnJlbnQiLCJjcmFkbGVDb250ZXh0IiwiQ3JhZGxlXzEiLCJjYWNoZUhhbmRsZXIiLCJzY3JvbGxlclByb3BlcnRpZXNSZWYiLCJudWxsSXRlbVNldE1heExpc3RzaXplIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZiIsInN0eWxlc1JlZiIsImZyYW1lU3RhdGUiLCJzZXRGcmFtZVN0YXRlIiwiZnJhbWVTdGF0ZVJlZiIsImZyYW1lUmVmIiwiaXNNb3VudGVkUmVmIiwicG9ydGFsTWV0YWRhdGFSZWYiLCJwbGFjZWhvbGRlclJlZiIsIml0ZW1JRFJlZiIsImxhdGVzdEl0ZW1JRFJlZiIsImNlbGxGcmFtZURhdGFSZWYiLCJlcnJvclJlZiIsIm1lc3NhZ2VSZWYiLCJjYW5jZWxpZGxlY2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJjdXN0b21wbGFjZWhvbGRlciIsInJlYWN0XzEiLCJjcmVhdGVFbGVtZW50IiwibWVzc2FnZSIsImVycm9yIiwiUGxhY2Vob2xkZXJfMSIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJMaW5lclN0eWxlcyIsInJlcXVlc3RpZGxlY2FsbGJhY2siLCJ3aW5kb3ciLCJyZXF1ZXN0aWRsZWNhbGxiYWNrXzEiLCJuZXdTdHlsZXMiLCJnZXRGcmFtZVN0eWxlcyIsInBvcnRhbE5vZGVSZWYiLCJpc1JlcGFyZW50aW5nUmVmIiwiY2FjaGVkIiwiaGFzUG9ydGFsIiwiZ2V0UG9ydGFsIiwicG9ydGFsTm9kZSIsInNldENvbnRhaW5lclN0eWxlcyIsImVsZW1lbnQiLCJyZWdpc3RlclJlcXVlc3RlZFBvcnRhbCIsIl9fYXdhaXRlciIsInVzZXJjb250ZW50IiwicmV0dXJudmFsdWUiLCJ1bmRlZmluZWQiLCJFcnJvciIsImlzVmFsaWRFbGVtZW50Iiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwicHJvcHMiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnRlbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVQb3J0YWwiLCJ0aW1lb3V0IiwicmVmIiwic3R5bGUiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsImV4cG9ydHMiLCJzdHlsZXMiLCJzdHlsZXNldCIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJ3aWR0aCIsImhlaWdodCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJjb250YWluZXIiLCJpbnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// Cradle.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers (class instances), and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the ~30 state changes of the system.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be vertical or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'headwards' (up or left) in the Cradle, and\n    below which the cradle content expands 'tailwards' (doen or right). The Cradle content is held in\n    two CSS grids (children of the axis): one above or left (the 'head' grid), and one below or right,\n    of the position of the axis (the 'tail' grid).\n\n    The axis is always kept near the leading (headward) edge of the visible cell rows of the Viewport\n    (there are some edge-case exceptions).\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is usually\n            the first item in the head section of the Cradle, unless the cradle shows the very top of the\n            list, in which case the cradleReferenceIndex is the same as the AxisReferenceIndex)\n        - axisViewportPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll (Viewport scrollTop or scrollLeft) of the\n            ScrollBlock\n    \n    Overscroll handling (repositioning):\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle (including its two content grids) has entirely passed\n        out of the viewport, then the Cradle component is replaced by a ScrollTracker (or by null if\n        the host takes responsibility for feedback). The ScrollTracker displays to the user the relative\n        location in the virtual list at the edge of the viewport during repositioning. When the scrolling\n        stops Cradle recreates the cradle content, according to the final position of the repositioning\n        process.\n\n    Cradle is activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\");\n// popup position tracker for repositioning\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\"));\n// support code; process handlers\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\"));\n// cacheHandler is imported as a property; instantiated at the root\n// for children\nexports.CradleContext = react_1[\"default\"].createContext(null);\n// component\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n    runwaySize = _ref.runwaySize,\n    listsize = _ref.listsize,\n    startingIndex = _ref.startingIndex,\n    getItem = _ref.getItem,\n    placeholder = _ref.placeholder,\n    userCallbacks = _ref.userCallbacks,\n    styles = _ref.styles,\n    triggerlineOffset = _ref.triggerlineOffset,\n    cache = _ref.cache,\n    cacheMax = _ref.cacheMax,\n    scrollerID = _ref.scrollerID,\n    cacheHandler = _ref.cacheHandler,\n    usePlaceholder = _ref.usePlaceholder,\n    useScrollTracker = _ref.useScrollTracker,\n    showAxis = _ref.showAxis,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _ref.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n    TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _ref.TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n    scrollerProperties = _ref.scrollerProperties;\n  var _a, _b;\n  if (listsize == 0) return null; // nothing to do\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    cellMinHeight = gridSpecs.cellMinHeight,\n    cellMinWidth = gridSpecs.cellMinWidth,\n    layout = gridSpecs.layout;\n  // get viewport context\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n  // flags\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var parentingTransitionRequiredRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false);\n  //  viewport dimensions and cached state\n  var getViewportDimensions = function getViewportDimensions() {\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    return {\n      width: viewportElement.offsetWidth,\n      height: viewportElement.offsetHeight\n    };\n  };\n  var viewportDimensions = ViewportContextProperties.viewportDimensions; // for scrollTracker\n  var _getViewportDimension = getViewportDimensions(),\n    viewportheight = _getViewportDimension.height,\n    viewportwidth = _getViewportDimension.width; // viewportDimensions\n  // zero width and height means the component must be in portal (cache) state\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n  // console.log('immediate width/height', viewportwidth,viewportheight)\n  // cradle state\n  var _ref2 = (0, react_1.useState)('setup'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    cradleState = _ref3[0],\n    setCradleState = _ref3[1];\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n  cradleStateRef.current = cradleState;\n  // console.log('==> cradleState','-'+scrollerID+'-',\n  //     '~'+scrollerProperties?.cellFrameDataRef.current.index+'~', cradleState)\n  // cradle scaffold element refs\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null);\n  // layout bundle\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  });\n  // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n  var crosscount = (0, react_1.useMemo)(function () {\n    if (isCachedRef.current) return 0;\n    var viewportcrosslength = orientation == 'vertical' ? viewportwidth : viewportheight;\n    // console.log('viewportcrosslength', viewportcrosslength)\n    // if (viewportcrosslength == 0) {\n    //     return 0\n    // }\n    // cross length of viewport (gap to match crossLength)\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = orientation == 'vertical' ? cellWidth + gap : cellHeight + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]);\n  // console.log('crosscount', crosscount)\n  // various row counts\n  var _ref4 = (0, react_1.useMemo)(function () {\n      var viewportLength = orientation == 'vertical' ? viewportheight : viewportwidth;\n      var baseRowLength;\n      if (layout == 'uniform') {\n        if (orientation == 'vertical') {\n          baseRowLength = cellHeight;\n        } else {\n          baseRowLength = cellWidth;\n        }\n      } else {\n        // layout == 'variable'\n        if (orientation == 'vertical') {\n          baseRowLength = cellMinHeight;\n        } else {\n          baseRowLength = cellMinWidth;\n        }\n      }\n      baseRowLength += gap;\n      var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n      var viewportVisibleRowcount = Math.floor(viewportLength / baseRowLength);\n      var listRowcount = Math.ceil(listsize / crosscount);\n      var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n      var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n      var runwayRowcount;\n      if (calculatedCradleRowcount >= cradleRowcount) {\n        runwayRowcount = runwaySize;\n      } else {\n        var diff = cradleRowcount - calculatedCradleRowcount;\n        runwayRowcount -= Math.floor(diff / 2);\n        runwayRowcount = Math.max(0, runwayRowcount);\n      }\n      var itemcount = cradleRowcount * crosscount;\n      if (itemcount > listsize) {\n        itemcount = listsize;\n        cradleRowcount = Math.ceil(itemcount / crosscount);\n      }\n      return [cradleRowcount, viewportRowcount, viewportVisibleRowcount, listRowcount, runwayRowcount];\n    }, [orientation, gap,\n    // padding,\n    cellWidth, cellHeight, cellMinWidth, cellMinHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount, layout]),\n    _ref5 = _slicedToArray(_ref4, 5),\n    cradleRowcount = _ref5[0],\n    viewportRowcount = _ref5[1],\n    viewportVisibleRowcount = _ref5[2],\n    // maximum number of rows completely visible at once\n    listRowcount = _ref5[3],\n    runwayRowcount = _ref5[4];\n  // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    repositioningIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningIndexCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionCallback\n  });\n  // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    usePlaceholder: usePlaceholder,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    // control values\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN\n  };\n  var scrollerPropertiesRef = (0, react_1.useRef)(null);\n  // passed to cellFrame content (user content) if requested\n  scrollerPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex\n  };\n  // configuration properties to share with handlers\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    viewportVisibleRowcount: viewportVisibleRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  };\n  // placeholder in cradleParameters to make available individual handlers\n  var handlersRef = (0, react_1.useRef)(null);\n  // cradle parameters MASTER BUNDLE\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters;\n  // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  }\n  // make handlers directly available to cradle code below\n  var _handlersRef$current = handlersRef.current,\n    interruptHandler = _handlersRef$current.interruptHandler,\n    scrollHandler = _handlersRef$current.scrollHandler,\n    stateHandler = _handlersRef$current.stateHandler,\n    contentHandler = _handlersRef$current.contentHandler,\n    layoutHandler = _handlersRef$current.layoutHandler,\n    serviceHandler = _handlersRef$current.serviceHandler,\n    stylesHandler = _handlersRef$current.stylesHandler;\n  // console.log('viewportwidth, viewportheight',viewportwidth, viewportheight )\n  // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n  /*\n      Intercept change in caching status:\n      when a component is is cached in a portal (in the React virtual DOM), including the transition of\n      being moved from one cellFrame to another when crossing the Cradle axis,\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n  \n      Not that InfiniteGridScroller components can themselves be cached as content.\n  \n      The restore scrollPos action must be the first priority to hide these scrollPos adjustments\n      from the user.\n  */\n  // // zero width and height means the component must be in portal (cache) state\n  // const isInPortal = ((viewportwidth == 0) && (viewportheight == 0)) \n  // const isCacheChange = (isInPortal != isCachedRef.current)\n  // if (isCacheChange) {\n  //     wasCachedRef.current = isCachedRef.current\n  //     isCachedRef.current = isInPortal\n  // }\n  var isCachingUnderway = isCachedRef.current || wasCachedRef.current;\n  if (isCacheChange || ((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) || ViewportContextProperties.isResizing && isCachingUnderway) {\n    if ((_b = ViewportContextProperties.isReparentingRef) === null || _b === void 0 ? void 0 : _b.current) {\n      ViewportContextProperties.isReparentingRef.current = false; // no longer needed\n      parentingTransitionRequiredRef.current = true;\n    }\n    if (ViewportContextProperties.isResizing) {\n      // caching op is underway, so cancel\n      ViewportContextProperties.isResizing = false;\n    }\n    if (isCacheChange) {\n      // into or out of caching\n      if (isCachedRef.current && !wasCachedRef.current) {\n        // change into cache\n        interruptHandler.pauseInterrupts();\n      }\n    }\n  }\n  // generate state for restoring scrollPos\n  (0, react_1.useEffect)(function () {\n    // if is cached, then the next effect (for entering or leaving cache) has another turn\n    if (parentingTransitionRequiredRef.current && !isCachedRef.current) {\n      parentingTransitionRequiredRef.current = false;\n      setCradleState('parentingtransition');\n    }\n  }, [parentingTransitionRequiredRef.current]);\n  // change state for entering or leaving cache\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('incache');\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n      if (parentingTransitionRequiredRef.current) {\n        parentingTransitionRequiredRef.current = false;\n        setCradleState('parentingtransition');\n      } else {\n        if (hasBeenRenderedRef.current) {\n          setCradleState('rerenderfromcache');\n        } else {\n          setCradleState('firstrenderfromcache');\n        }\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]);\n  // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  //send call-in functions to host\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.functionsCallback) return;\n    var scrollToIndex = serviceHandler.scrollToIndex,\n      reload = serviceHandler.reload,\n      setListsize = serviceHandler.setListsize,\n      clearCache = serviceHandler.clearCache,\n      getCacheIndexMap = serviceHandler.getCacheIndexMap,\n      getCacheItemMap = serviceHandler.getCacheItemMap,\n      getCradleIndexMap = serviceHandler.getCradleIndexMap,\n      remapIndexes = serviceHandler.remapIndexes,\n      moveIndex = serviceHandler.moveIndex,\n      insertIndex = serviceHandler.insertIndex,\n      removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToIndex: scrollToIndex,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.functionsCallback(functions);\n  }, []);\n  // initialize window scroll listener\n  (0, react_1.useEffect)(function () {\n    var viewportdata = ViewportContextPropertiesRef.current;\n    viewportdata.elementRef.current.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportdata.elementRef.current && viewportdata.elementRef.current.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []);\n  // observer support\n  /*\n      There are two interection observers: one for the cradle wings, and another for triggerlines;\n          both against the viewport.\n  */\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n      triggerlinesIntersect = interruptHandler.triggerlinesIntersect;\n    // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements();\n    // triggerobserver tiggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n    var triggerobserver = triggerlinesIntersect.createObserver();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n    };\n  }, []);\n  // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize;\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n        deleteListCallback = _serviceHandler$callb.deleteListCallback,\n        changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n      cacheHandler.changeListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []);\n  // caching change\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n    if (cradleStateRef.current == 'setup') return;\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var _dListCallback;\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]);\n  // trigger viewportresizing response based on viewport state\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    // movement to and from cache is independent of ui viewportresizing\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    }\n    // complete viewportresizing mode\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]);\n  // reconfigure for changed size parameters\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [listsize, cellHeight, cellWidth, gap, padding, triggerlineOffset, layout]);\n  // a new getItem function implies the need to reload\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reload');\n  }, [getItem]);\n  // pivot triggered on change of orientation\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      return;\n    }\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n      cellWidth = _cradleInheritedPrope.cellWidth,\n      cellHeight = _cradleInheritedPrope.cellHeight,\n      gap = _cradleInheritedPrope.gap;\n    // get previous ratio\n    var previousCellPixelLength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n    var previousratio = previousAxisOffset / previousCellPixelLength;\n    var pivotCellPixelLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n    var pivotAxisOffset = previousratio * pivotCellPixelLength;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]);\n  // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n  var _ref6 = (0, react_1.useMemo)(function () {\n      return stylesHandler.getCradleStyles({\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        cellMinHeight: cellMinHeight,\n        cellMinWidth: cellMinWidth,\n        gap: gap,\n        padding: padding,\n        viewportheight: viewportheight,\n        viewportwidth: viewportwidth,\n        crosscount: crosscount,\n        userstyles: styles,\n        triggerlineOffset: triggerlineOffset,\n        layout: layout\n      });\n    }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset, layout]),\n    _ref7 = _slicedToArray(_ref6, 6),\n    cradleHeadStyle = _ref7[0],\n    cradleTailStyle = _ref7[1],\n    cradleAxisStyle = _ref7[2],\n    cradleDividerStyle = _ref7[3],\n    triggercellTriggerlineHeadStyle = _ref7[4],\n    triggercellTriggerlineTailStyle = _ref7[5];\n  // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (about 30 states), using named states\n  // useLayoutEffect for suppressing flashes\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('incache');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.cacheProps.modified = true;\n              cacheHandler.renderPortalList();\n            }\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('incache');\n            }\n          };\n          cacheHandler.preload(finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n      case 'incache':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n          break;\n        }\n      // moving out of cache into visible DOM tree (cellFrame)\n      // resets scrollPos (scrollLeft/scrollTop) to last UI value\n      case 'parentingtransition':\n        {\n          var cradlePositionData = layoutHandler.cradlePositionData;\n          // console.log('Cradle: parentingtransition: cradlePositionData',cradlePositionData)\n          // reset scroll position to previous value\n          var blockScrollPos = cradlePositionData.blockScrollPos;\n          if (blockScrollPos !== null) {\n            var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n            viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n          }\n          setCradleState('finishparenting');\n          break;\n        }\n      case 'finishparenting':\n        {\n          interruptHandler.restoreInterrupts();\n          if (hasBeenRenderedRef.current) {\n            setCradleState('ready');\n          } else {\n            setCradleState('firstrenderfromcache');\n          }\n          break;\n        }\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true;\n          // avoid recursive cradle intersection interrupts\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n          if (scrollHandler.isScrolling) {\n            setCradleState('repositioningRender'); // toggles with repositioningContinuation\n          } else {\n            setCradleState('finishreposition');\n          }\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n      /*\n          the following 11 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts', with a detour for variable layout\n          to reconfigure the scrollblock\n      */\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reload':\n        {\n          if (isCachedRef.current) {\n            setCradleState('incache');\n            break;\n          }\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = [];\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          }\n          // set data\n          contentHandler.setCradleContent(cradleState);\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          }\n          // synchronize cache if necessary\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalList();\n            }\n          }\n          // prepare the cycle for preparerender\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents;\n          // console.log('cradleContent TAIL length', \n          //     '-'+scrollerID+'-',\n          //     '~'+scrollerProperties?.cellFrameDataRef.current.index+'~',\n          //     cradleContent.tailDisplayComponents.length)\n          // update virtual DOM\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n          break;\n        }\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n      case 'preparesetforvariability':\n        {\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability('setcradle');\n            setCradleState('finishsetforvariability');\n          }, TIMEOUT_FOR_VARIABLE_MEASUREMENTS);\n          break;\n        }\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements();\n          // this can be pre-empted by reparenting, which itself restores interrupts\n          setCradleState('restoreinterrupts'); // to restore interrupts\n          break;\n        }\n      case 'restoreinterrupts':\n        {\n          // normalize or resume cycling\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          // update virtual DOM\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n          cacheHandler.renderPortalList();\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n          if (_layout2 == 'uniform') {\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            interruptHandler.triggerlinesIntersect.connectElements();\n            interruptHandler.signals.pauseTriggerlinesObserver = false;\n            setCradleState('ready');\n          } else {\n            setCradleState('refreshDOMupdateforvariability');\n          }\n          break;\n        }\n      case 'refreshDOMupdateforvariability':\n        {\n          // extra cycle needed to allow time to synchronize DOM with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n      case 'adjustupdateforvariability':\n        {\n          contentHandler.adjustScrollblockForVariability('updatecradle');\n          setCradleState('finishupdateforvariability');\n          break;\n        }\n      // called from onAfterScroll. \n      // This can be called twice in succession with short onAfterScroll timeout\n      case 'adjustupdateforvariabilityafterscroll':\n        {\n          contentHandler.adjustScrollblockForVariability('afterscroll');\n          setCradleState('finishupdateforvariability');\n          break;\n        }\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseTriggerlinesObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      // support for various host service requests; syncs cradle content with cache changes\n      case 'applycellframechanges':\n        {\n          // user intervention\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          var portalHoldList = cacheHandler.portalHoldList;\n          var portalMap = cacheHandler.cacheProps.portalMap;\n          if (portalHoldList && portalHoldList.length) {\n            var _iterator = _createForOfIteratorHelper(portalHoldList),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var itemID = _step.value;\n                portalMap[\"delete\"](itemID);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n          setCradleState('ready');\n          break;\n        }\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]);\n  // standard rendering states (3 states)\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]);\n  // ==========================[ RENDER ]===========================\n  var scrollAxisReferenceIndex = layoutHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!useScrollTracker) return null;\n    if (!['repositioningContinuation', 'repositioningRender'].includes(cradleState)) {\n      return null;\n    }\n    var repositioningIndexCallback = serviceHandler.callbacks.repositioningIndexCallback;\n    repositioningIndexCallback && repositioningIndexCallback(scrollAxisReferenceIndex);\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles, useScrollTracker]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'headtrigger',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'tailtrigger',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionCallback: serviceHandler.callbacks.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  });\n  // display the cradle components, the ScrollTracker, or null\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ?\n  // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\nexports[\"default\"] = Cradle;\n// utility\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  cacheHandler.cradleParameters = cradleParameters;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDWnVGLGdCQUFnQixFQUFDeUcsYUFBYSxDQUFDRSw2QkFBZ0IsQ0FBQztJQUNoRDFHLGFBQWEsRUFBQ3dHLGFBQWEsQ0FBQ0csMEJBQWEsQ0FBQztJQUMxQzFHLFlBQVksRUFBQ3VHLGFBQWEsQ0FBQ0kseUJBQVksQ0FBQztJQUN4QzFHLGNBQWMsRUFBQ3NHLGFBQWEsQ0FBQ0ssMkJBQWMsQ0FBQztJQUM1QzFHLGFBQWEsRUFBQ3FHLGFBQWEsQ0FBQ00sMEJBQWEsQ0FBQztJQUMxQzFHLGNBQWMsRUFBQ29HLGFBQWEsQ0FBQ08sMkJBQWMsQ0FBQztJQUM1QzFHLGFBQWEsRUFBQ21HLGFBQWEsQ0FBQ1EsMEJBQWE7R0FFNUM7QUFFTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DcmFkbGUudHN4PzcxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3JhZGxlLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgQ3JhZGxlIGRvZXMgdGhlIGJ1bGsgb2YgdGhlIHdvcmsgZm9yIHRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyLiBJdCBkb2VzIHNvIHdpdGggdGhlIGhlbHAgb2ZcbiAgICBlaWdodCBwcm9jZXNzIGhhbmRsZXJzIChjbGFzcyBpbnN0YW5jZXMpLCBhbmQgb25lIG1haW4gc3ViLWNvbXBvbmVudCAtIHRoZSBDZWxsRnJhbWUuXG5cbiAgICBDcmFkbGUncyBtYWluIHJlc3BvbnNpYmlsaXR5IGlzIHRvIG1hbmFnZSB0aGUgfjMwIHN0YXRlIGNoYW5nZXMgb2YgdGhlIHN5c3RlbS5cblxuICAgIFRoZSBpbGx1c2lvbiBvZiBpbmZpbml0ZSBjb250ZW50IGlzIG1haW50YWluZWQgYnkgc3luY2hyb25pemluZyBjaGFuZ2VzIGluIGNyYWRsZSBjb250ZW50IHdpdGggdGhlXG4gICAgQ3JhZGxlIGxvY2F0aW9uIGluc2lkZSB0aGUgU2Nyb2xsYmxvY2ssIHN1Y2ggdGhhdCBhcyB0aGUgU2Nyb2xsYmxvY2sgaXMgbW92ZWQsIHRoZSBjcmFkbGUgbW92ZXMgXG4gICAgb3Bwb3NpdGVseSB0byBzdGF5IHZpc2libGUgd2l0aGluIHRoZSB2aWV3cG9ydC5cblxuICAgIFRoZSBTY3JvbGxibG9jayBpcyBzaXplZCB0byBhcHByb3hpbWF0ZSB0aGUgbGlzdCBiZWluZyB2aWV3ZWQsIHNvIGFzIHRvIGhhdmUgYSBzY3JvbGwgdGh1bWIgc2l6ZSBcbiAgICBhbmQgcG9zaXRpb24gd2hpY2ggcmVhbGlzdGljYWxseSByZWZsZWN0cyB0aGUgc2l6ZSBvZiB0aGUgbGlzdCBiZWluZyBzaG93bi5cblxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgY3JhZGxlIGlzIGNvbnRyb2xsZWQgYnkgYW4gJ2F4aXMnIHdoaWNoIGlzIGEgMHB4IGhlaWdodC93aWR0aCBkaXZcbiAgICAoYWxvbmcgdGhlIG1lZGlhbCAtIFNjcm9sbEJsb2NrIGNhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsKS4gVGhlIHB1cnBvc2Ugb2YgdGhlIGF4aXMgaXMgdG8gXG4gICAgYWN0IGFzIGEgJ2ZvbGQnLCBhYm92ZSB3aGljaCBjcmFkbGUgY29udGVudCBleHBhbmRzICdoZWFkd2FyZHMnICh1cCBvciBsZWZ0KSBpbiB0aGUgQ3JhZGxlLCBhbmQgXG4gICAgYmVsb3cgd2hpY2ggdGhlIGNyYWRsZSBjb250ZW50IGV4cGFuZHMgJ3RhaWx3YXJkcycgKGRvZW4gb3IgcmlnaHQpLiBUaGUgQ3JhZGxlIGNvbnRlbnQgaXMgaGVsZCBpbiBcbiAgICB0d28gQ1NTIGdyaWRzIChjaGlsZHJlbiBvZiB0aGUgYXhpcyk6IG9uZSBhYm92ZSBvciBsZWZ0ICh0aGUgJ2hlYWQnIGdyaWQpLCBhbmQgb25lIGJlbG93IG9yIHJpZ2h0LCBcbiAgICBvZiB0aGUgcG9zaXRpb24gb2YgdGhlIGF4aXMgKHRoZSAndGFpbCcgZ3JpZCkuXG5cbiAgICBUaGUgYXhpcyBpcyBhbHdheXMga2VwdCBuZWFyIHRoZSBsZWFkaW5nIChoZWFkd2FyZCkgZWRnZSBvZiB0aGUgdmlzaWJsZSBjZWxsIHJvd3Mgb2YgdGhlIFZpZXdwb3J0XG4gICAgKHRoZXJlIGFyZSBzb21lIGVkZ2UtY2FzZSBleGNlcHRpb25zKS5cblxuICAgIFRlY2huaWNhbGx5LCB0aGVyZSBhcmUgc2V2ZXJhbCBrZXkgcmVmZXJlbmNlIHBvaW50cyB0cmFja2VkIGJ5IHRoZSBDcmFkbGUuIFRoZXNlIGFyZTpcbiAgICAgICAgLSBheGlzUmVmZXJlbmNlSW5kZXggaXMgdGhlIHZpcnR1YWwgaW5kZXggb2YgdGhlIGl0ZW0gY29udHJvbGxpbmcgdGhlIGxvY2F0aW9uIG9mIHRoZSBheGlzLlxuICAgICAgICAgICAgVGhlIGF4aXNSZWZlcmVuY2VJbmRleCBpcyBhbHNvIHVzZWQgdG8gYWxsb2NhdGUgaXRlbXMgYWJvdmUgKGxvd2VyIGluZGV4IHZhbHVlKSBhbmQgYmVsb3cgXG4gICAgICAgICAgICAoc2FtZSBvciBoaWdoZXIgaW5kZXggdmFsdWUpIHRoZSBheGlzIGZvbGQuIFRoZSBheGlzUmVmZXJuY2VJbmRleCBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgXG4gICAgICAgICAgICB0YWlsIHNlY3Rpb24gb2YgdGhlIENyYWRsZS5cbiAgICAgICAgLSAoY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgaW5mZXJyZWQgZnJvbSB0aGUgYXhpc1JlZmVyZW5jZUluZGV4LCBhbmQgaXMgdGhlIHZpcnR1YWwgaW5kZXggb2YgXG4gICAgICAgICAgICB0aGUgaXRlbSBkZWZpbmluZyB0aGUgbGVhZGluZyBib3VuZCBvZiB0aGUgY3JhZGxlIGNvbnRlbnQuIFRoZSBjcmFkbGVSZWZlcmVuY2VJbmRleCBpcyB1c3VhbGx5IFxuICAgICAgICAgICAgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGhlYWQgc2VjdGlvbiBvZiB0aGUgQ3JhZGxlLCB1bmxlc3MgdGhlIGNyYWRsZSBzaG93cyB0aGUgdmVyeSB0b3Agb2YgdGhlXG4gICAgICAgICAgICBsaXN0LCBpbiB3aGljaCBjYXNlIHRoZSBjcmFkbGVSZWZlcmVuY2VJbmRleCBpcyB0aGUgc2FtZSBhcyB0aGUgQXhpc1JlZmVyZW5jZUluZGV4KVxuICAgICAgICAtIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IChwaXhlbHMgdGhhdCBwbGFjZSB0aGUgYXhpcyBpbiByZWxhdGlvbiB0byB0aGUgdmlld3BvcnQncyBsZWFkaW5nIGVkZ2UpXG4gICAgICAgIC0gdGhlIGJsb2NrU2Nyb2xsUG9zLCB3aGljaCBpcyB0aGUgYW1vdW50IG9mIHNjcm9sbCAoVmlld3BvcnQgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpIG9mIHRoZSBcbiAgICAgICAgICAgIFNjcm9sbEJsb2NrXG4gICAgXG4gICAgT3ZlcnNjcm9sbCBoYW5kbGluZyAocmVwb3NpdGlvbmluZyk6XG4gICAgICAgIE93aW5nIHRvIHRoZSBwb3RlbnRpYWwgcmFwaWRpdHkgb2Ygc2Nyb2xsaW5nLCB3aGljaCBpbiB0aGUgY2FzZSBvZiBsYXJnZSBsaXN0cyBhbmQgaGVhdnkgY29udGVudCBcbiAgICAgICAgY2FuIGJlIHRvbyBmYXN0IGZvciB0aGUgc3lzdGVtIHRvIGtlZXAgdXAsIHRoZXJlIGlzIGFuIG92ZXJzY3JvbGwgcHJvdG9jb2wgY2FsbGVkICdyZXBvc2l0aW9uaW5nJy5cblxuICAgICAgICBJZiB0aGUgb3ZlcnNjcm9sbCBpcyBzdWNoIHRoYXQgdGhlIGNyYWRsZSAoaW5jbHVkaW5nIGl0cyB0d28gY29udGVudCBncmlkcykgaGFzIGVudGlyZWx5IHBhc3NlZCBcbiAgICAgICAgb3V0IG9mIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGUgQ3JhZGxlIGNvbXBvbmVudCBpcyByZXBsYWNlZCBieSBhIFNjcm9sbFRyYWNrZXIgKG9yIGJ5IG51bGwgaWYgXG4gICAgICAgIHRoZSBob3N0IHRha2VzIHJlc3BvbnNpYmlsaXR5IGZvciBmZWVkYmFjaykuIFRoZSBTY3JvbGxUcmFja2VyIGRpc3BsYXlzIHRvIHRoZSB1c2VyIHRoZSByZWxhdGl2ZSBcbiAgICAgICAgbG9jYXRpb24gaW4gdGhlIHZpcnR1YWwgbGlzdCBhdCB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnQgZHVyaW5nIHJlcG9zaXRpb25pbmcuIFdoZW4gdGhlIHNjcm9sbGluZ1xuICAgICAgICBzdG9wcyBDcmFkbGUgcmVjcmVhdGVzIHRoZSBjcmFkbGUgY29udGVudCwgYWNjb3JkaW5nIHRvIHRoZSBmaW5hbCBwb3NpdGlvbiBvZiB0aGUgcmVwb3NpdGlvbmluZyBcbiAgICAgICAgcHJvY2Vzcy5cblxuICAgIENyYWRsZSBpcyBhY3RpdmF0ZWQgYnkgaW50ZXJydXB0czpcbiAgICAtIHNjcm9sbGluZ1xuICAgIC0gcmVzaXppbmcgb2YgdGhlIHZpZXdwb3J0XG4gICAgLSBvYnNlcnZlciBjYWxsYmFja3M6XG4gICAgICAgIC0gY3JhZGxlL3ZpZXdwb3J0IGludGVyc2VjdGlvbiBmb3IgcmVwb3NpdGlvbmluZyB3aGVuIHRoZSBjcmFkbGUgcmFjZXMgb3V0IG9mIHNjb3BlXG4gICAgICAgIC0gdHdvICd0cmlnZ2VybGluZScvdmlld3BvcnQgaW50ZXJzZWN0aW9ucyB3aGljaCB0cmlnZ2VyIHJvbGxpbmcgb2YgY29udGVudFxuICAgICAgICAgICAgLSByb2xsaW5nIGNvbnRlbnQgdHJpZ2dlcnMgcmUtYWxsb2NhdGlvbiBvZiBjb250ZW50IGJldHdlZW4gY3JhZGxlIGhlYWQgYW5kIHRhaWwgZ3JpZHNcbiAgICAtIHBpdm90IC0gY2hhbmdlIG9mIG9yaWVudGF0aW9uXG4gICAgLSBob3N0IGNoYW5nZXMgb2YgY29uZmlndXJhdGlvbiBzcGVjcyB0aHJvdWdoIHByb3BlcnR5IGNoYW5nZXMgb3IgZGlyZWN0IHNlcnZpY2UgY2FsbHNcbiovXG5cbmltcG9ydCBSZWFjdCwgeyBcbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlUmVmLCBcbiAgICB1c2VDb250ZXh0LCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlTWVtbyxcbiAgICB1c2VDYWxsYmFjaywgXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL1ZpZXdwb3J0J1xuXG4vLyBwb3B1cCBwb3NpdGlvbiB0cmFja2VyIGZvciByZXBvc2l0aW9uaW5nXG5pbXBvcnQgU2Nyb2xsVHJhY2tlciBmcm9tICcuL2NyYWRsZS9TY3JvbGxUcmFja2VyJ1xuXG4vLyBzdXBwb3J0IGNvZGU7IHByb2Nlc3MgaGFuZGxlcnNcbmltcG9ydCBTY3JvbGxIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3Njcm9sbGhhbmRsZXInXG5pbXBvcnQgU3RhdGVIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3N0YXRlaGFuZGxlcidcbmltcG9ydCBDb250ZW50SGFuZGxlciBmcm9tICcuL2NyYWRsZS9jb250ZW50aGFuZGxlcidcbmltcG9ydCBMYXlvdXRIYW5kbGVyIGZyb20gJy4vY3JhZGxlL2xheW91dGhhbmRsZXInXG5pbXBvcnQgSW50ZXJydXB0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyJ1xuaW1wb3J0IFNlcnZpY2VIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3NlcnZpY2VoYW5kbGVyJ1xuaW1wb3J0IFN0eWxlc0hhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc3R5bGVzaGFuZGxlcidcbi8vIGNhY2hlSGFuZGxlciBpcyBpbXBvcnRlZCBhcyBhIHByb3BlcnR5OyBpbnN0YW50aWF0ZWQgYXQgdGhlIHJvb3RcblxuLy8gZm9yIGNoaWxkcmVuXG5leHBvcnQgY29uc3QgQ3JhZGxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuLy8gY29tcG9uZW50XG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ3JpZFNwZWNzLFxuXG4gICAgICAgIHJ1bndheVNpemUsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIFxuICAgICAgICB1c2VyQ2FsbGJhY2tzLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgLy8gZm9yIGhhbmRsZXIgbGlzdFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIC8vIHN5c3RlbVxuICAgICAgICB1c2VQbGFjZWhvbGRlcixcbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlcixcbiAgICAgICAgc2hvd0F4aXMsXG4gICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLFxuICAgICAgICBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMsXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIGlmIChsaXN0c2l6ZSA9PSAwKSByZXR1cm4gbnVsbCAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1bIERBVEEgU0VUVVAgXT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdW5wYWNrIGdyaWRTcGVjc1xuICAgIGNvbnN0IHtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgLy8gZ2V0IHZpZXdwb3J0IGNvbnRleHRcbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG5cbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyAvLyBmb3IgY2xvc3VyZXNcblxuICAgIC8vIGZsYWdzXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG4gICAgY29uc3QgaXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3Qgd2FzQ2FjaGVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCBoYXNCZWVuUmVuZGVyZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgICAvLyAgdmlld3BvcnQgZGltZW5zaW9ucyBhbmQgY2FjaGVkIHN0YXRlXG4gICAgY29uc3QgZ2V0Vmlld3BvcnREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6dmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OnZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgdmlld3BvcnREaW1lbnNpb25zIH0gPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIC8vIGZvciBzY3JvbGxUcmFja2VyXG4gICAgY29uc3QgeyBoZWlnaHQ6dmlld3BvcnRoZWlnaHQsd2lkdGg6dmlld3BvcnR3aWR0aCB9ID0gZ2V0Vmlld3BvcnREaW1lbnNpb25zKCkgLy8gdmlld3BvcnREaW1lbnNpb25zXG5cbiAgICAvLyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgbWVhbnMgdGhlIGNvbXBvbmVudCBtdXN0IGJlIGluIHBvcnRhbCAoY2FjaGUpIHN0YXRlXG4gICAgY29uc3QgaXNJblBvcnRhbCA9ICgodmlld3BvcnR3aWR0aCA9PSAwKSAmJiAodmlld3BvcnRoZWlnaHQgPT0gMCkpIFxuXG4gICAgY29uc3QgaXNDYWNoZUNoYW5nZSA9IChpc0luUG9ydGFsICE9IGlzQ2FjaGVkUmVmLmN1cnJlbnQpXG5cbiAgICBpZiAoaXNDYWNoZUNoYW5nZSkge1xuICAgICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGlzQ2FjaGVkUmVmLmN1cnJlbnRcbiAgICAgICAgaXNDYWNoZWRSZWYuY3VycmVudCA9IGlzSW5Qb3J0YWxcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnaW1tZWRpYXRlIHdpZHRoL2hlaWdodCcsIHZpZXdwb3J0d2lkdGgsdmlld3BvcnRoZWlnaHQpXG5cbiAgICAvLyBjcmFkbGUgc3RhdGVcbiAgICBjb25zdCBbY3JhZGxlU3RhdGUsIHNldENyYWRsZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgY3JhZGxlU3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzXG4gICAgY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9IGNyYWRsZVN0YXRlXG5cbiAgICAvLyBjb25zb2xlLmxvZygnPT0+IGNyYWRsZVN0YXRlJywnLScrc2Nyb2xsZXJJRCsnLScsXG4gICAgLy8gICAgICd+JytzY3JvbGxlclByb3BlcnRpZXM/LmNlbGxGcmFtZURhdGFSZWYuY3VycmVudC5pbmRleCsnficsIGNyYWRsZVN0YXRlKVxuXG4gICAgLy8gY3JhZGxlIHNjYWZmb2xkIGVsZW1lbnQgcmVmc1xuICAgIGNvbnN0IGhlYWRDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdGFpbENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBheGlzQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gbGF5b3V0IGJ1bmRsZVxuICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkUmVmOmhlYWRDcmFkbGVFbGVtZW50UmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWY6dGFpbENyYWRsZUVsZW1lbnRSZWYsIFxuICAgICAgICAgICAgYXhpc1JlZjpheGlzQ3JhZGxlRWxlbWVudFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmOnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmOnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZixcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb25maWd1cmF0aW9uIGNhbGN1bGF0aW9uc1xuXG4gICAgLy8gY3Jvc3Njb3VudCAoYWxzbyBjYWxjdWxhdGVkIGJ5IFNjcm9sbGJsb2NrIGZvciBkZXJpdmluZyBTY3JvbGxibG9jayBsZW5ndGgpXG4gICAgY29uc3QgY3Jvc3Njb3VudCA9IHVzZU1lbW8oKCkgPT4geyAvLyB0aGUgbnVtYmVyIG9mIGNlbGxzIGNyb3NzaW5nIG9yaWVudGF0aW9uXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVybiAwXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRjcm9zc2xlbmd0aCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0d2lkdGg6XG4gICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHRcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndmlld3BvcnRjcm9zc2xlbmd0aCcsIHZpZXdwb3J0Y3Jvc3NsZW5ndGgpXG4gICAgICAgIC8vIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoID09IDApIHtcblxuICAgICAgICAvLyAgICAgcmV0dXJuIDBcblxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gY3Jvc3MgbGVuZ3RoIG9mIHZpZXdwb3J0IChnYXAgdG8gbWF0Y2ggY3Jvc3NMZW5ndGgpXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjID0gdmlld3BvcnRjcm9zc2xlbmd0aCAtIChwYWRkaW5nICogMikgKyBnYXAgXG5cbiAgICAgICAgY29uc3QgY2VsbGNyb3NzbGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgKGNlbGxXaWR0aCArIGdhcCk6XG4gICAgICAgICAgICAgICAgKGNlbGxIZWlnaHQgKyBnYXApO1xuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aGZvcmNhbGMgPSBcbiAgICAgICAgICAgIE1hdGgubWluKGNlbGxjcm9zc2xlbmd0aCx2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYykgLy8gcmVzdWx0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMVxuXG4gICAgICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjL2NlbGxjcm9zc2xlbmd0aGZvcmNhbGMpXG5cbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICAvLyBjb25zb2xlLmxvZygnY3Jvc3Njb3VudCcsIGNyb3NzY291bnQpXG5cbiAgICAvLyB2YXJpb3VzIHJvdyBjb3VudHNcbiAgICBjb25zdCBbXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LCBcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LCAvLyBtYXhpbXVtIG51bWJlciBvZiByb3dzIGNvbXBsZXRlbHkgdmlzaWJsZSBhdCBvbmNlXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRMZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoXG5cbiAgICAgICAgbGV0IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsSGVpZ2h0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbFdpZHRoXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBsYXlvdXQgPT0gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxNaW5IZWlnaHRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsTWluV2lkdGhcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBiYXNlUm93TGVuZ3RoICs9IGdhcFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Um93Y291bnQgPSBNYXRoLmNlaWwodmlld3BvcnRMZW5ndGgvYmFzZVJvd0xlbmd0aClcblxuICAgICAgICBjb25zdCB2aWV3cG9ydFZpc2libGVSb3djb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRMZW5ndGgvYmFzZVJvd0xlbmd0aClcblxuICAgICAgICBjb25zdCBsaXN0Um93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPSB2aWV3cG9ydFJvd2NvdW50ICsgKHJ1bndheVNpemUgKiAyKVxuXG4gICAgICAgIGxldCBjcmFkbGVSb3djb3VudCA9IE1hdGgubWluKGxpc3RSb3djb3VudCwgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50KVxuXG4gICAgICAgIGxldCBydW53YXlSb3djb3VudFxuICAgICAgICBpZiAoY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50ID49IGNyYWRsZVJvd2NvdW50KSB7XG5cbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gcnVud2F5U2l6ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAoY3JhZGxlUm93Y291bnQgLSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCAtPSBNYXRoLmZsb29yKGRpZmYvMilcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gTWF0aC5tYXgoMCxydW53YXlSb3djb3VudClcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW1jb3VudCA9IGNyYWRsZVJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgICAgICBpZiAoaXRlbWNvdW50ID4gbGlzdHNpemUpIHtcblxuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG5cbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxheW91dCxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsbGJhY2tzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBob3N0IGNhbGxiYWNrcywgdXBhY2tlZCBieSBzZXJ2aWNlSGFuZGxlclxuICAgIGNvbnN0IGV4dGVybmFsQ2FsbGJhY2tzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5yZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmRlbGV0ZUxpc3RDYWxsYmFjayxcbiAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uY2hhbmdlTGlzdHNpemVDYWxsYmFjayxcbiAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5pdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVsgYnVuZGxlIHByb3BlcnRpZXMgZm9yIGhhbmRsZXJzIF0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBidW5kbGUgYWxsIGNyYWRsZSBwcm9wcyB0byBwYXNzIHRvIGhhbmRsZXJzIC0gdWx0aW1hdGVseSBjcmFkbGVQYXJhbWV0ZXJzUmVmXG4gICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXMgYW5kIHN1cHBvcnQgY2FsbGJhY2tzXG4gICAgLy8gdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIC8vIGdyaWRTcGVjc1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIC8vIC4uLnJlc3RcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIHVzZXJDYWxsYmFja3MsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAvLyBjb250cm9sIHZhbHVlc1xuICAgICAgICBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCxcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLFxuXG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gcGFzc2VkIHRvIGNlbGxGcmFtZSBjb250ZW50ICh1c2VyIGNvbnRlbnQpIGlmIHJlcXVlc3RlZFxuICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsIFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gc2hhcmUgd2l0aCBoYW5kbGVyc1xuICAgIGNvbnN0IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuXG4gICAgICAgIC8vIHVwZGF0ZWQgdmFsdWVzXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG5cbiAgICAgICAgLy8gZm9yIHN0YXRlSGFuZGxlclxuICAgICAgICBjcmFkbGVTdGF0ZVJlZixcbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUsXG4gICAgfVxuXG4gICAgLy8gcGxhY2Vob2xkZXIgaW4gY3JhZGxlUGFyYW1ldGVycyB0byBtYWtlIGF2YWlsYWJsZSBpbmRpdmlkdWFsIGhhbmRsZXJzXG4gICAgY29uc3QgaGFuZGxlcnNSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGNyYWRsZSBwYXJhbWV0ZXJzIE1BU1RFUiBCVU5ETEVcbiAgICBjb25zdCBjcmFkbGVQYXJhbWV0ZXJzID0ge1xuICAgICAgICBoYW5kbGVyc1JlZixcbiAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZixcbiAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiwgXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZixcbiAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgZXh0ZXJuYWxDYWxsYmFja3NSZWYsXG4gICAgfVxuXG4gICAgY29uc3QgY3JhZGxlUGFyYW1ldGVyc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNyYWRsZVBhcmFtZXRlcnNSZWYuY3VycmVudCA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIC8vIG9uZ29pbmcgc291cmNlIG9mIGhhbmRsZXJzIC0gbm90ZSBhbGwgSGFuZGxlcnMgYXJlIGdpdmVuIGFsbCBwYXJhbWV0ZXJzIChjcmFkbGVQYXJhbWV0ZXJzKVxuICAgIGlmICghaGFuZGxlcnNSZWYuY3VycmVudCkge1xuXG4gICAgICAgIGhhbmRsZXJzUmVmLmN1cnJlbnQgPSBnZXRDcmFkbGVIYW5kbGVycyhjcmFkbGVQYXJhbWV0ZXJzKVxuXG4gICAgfVxuXG4gICAgLy8gbWFrZSBoYW5kbGVycyBkaXJlY3RseSBhdmFpbGFibGUgdG8gY3JhZGxlIGNvZGUgYmVsb3dcbiAgICBjb25zdCB7IC8vIGNhY2hlSGFuZGxlciBhbHJlYWR5IGF2YWlsYWJsZVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICBzY3JvbGxIYW5kbGVyLFxuICAgICAgICBzdGF0ZUhhbmRsZXIsXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgc3R5bGVzSGFuZGxlcixcbiAgICB9ID0gaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgLy8gY29uc29sZS5sb2coJ3ZpZXdwb3J0d2lkdGgsIHZpZXdwb3J0aGVpZ2h0Jyx2aWV3cG9ydHdpZHRoLCB2aWV3cG9ydGhlaWdodCApXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVsgSU5URVJDRVBUIENBQ0hJTkcgU1RBVEUgQ0hBTkdFIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qICAgIFxuICAgIEludGVyY2VwdCBjaGFuZ2UgaW4gY2FjaGluZyBzdGF0dXM6XG4gICAgd2hlbiBhIGNvbXBvbmVudCBpcyBpcyBjYWNoZWQgaW4gYSBwb3J0YWwgKGluIHRoZSBSZWFjdCB2aXJ0dWFsIERPTSksIGluY2x1ZGluZyB0aGUgdHJhbnNpdGlvbiBvZiBcbiAgICBiZWluZyBtb3ZlZCBmcm9tIG9uZSBjZWxsRnJhbWUgdG8gYW5vdGhlciB3aGVuIGNyb3NzaW5nIHRoZSBDcmFkbGUgYXhpcywgXG4gICAgdGhlIHNjcm9sbFBvcyAoc2Nyb2xsTGVmdCBvciBzY3JvbGxUb3ApIGlzIHJlc2V0IHRvIDAgKHplcm8pLiBXaGVuIHRoZSBzY3JvbGxlciBpcyBcbiAgICBtb3ZlZCB0byBhIGNlbGxGcmFtZSwgdGhpcyBjb2RlIHRyaWdnZXJzIHJlc3RvcmF0aW9uIHRoZSBzY3JvbGxQb3MgKHNlZSBjYXNlICdwYXJlbnRpbmd0cmFuc2l0aW9uJ1xuICAgIGluIHRoZSBzdGF0ZSBtYW5hZ2VtZW50IHNlY3Rpb24gYmVsb3cpLlxuXG4gICAgTm90IHRoYXQgSW5maW5pdGVHcmlkU2Nyb2xsZXIgY29tcG9uZW50cyBjYW4gdGhlbXNlbHZlcyBiZSBjYWNoZWQgYXMgY29udGVudC5cblxuICAgIFRoZSByZXN0b3JlIHNjcm9sbFBvcyBhY3Rpb24gbXVzdCBiZSB0aGUgZmlyc3QgcHJpb3JpdHkgdG8gaGlkZSB0aGVzZSBzY3JvbGxQb3MgYWRqdXN0bWVudHNcbiAgICBmcm9tIHRoZSB1c2VyLlxuKi9cbiAgICAvLyAvLyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgbWVhbnMgdGhlIGNvbXBvbmVudCBtdXN0IGJlIGluIHBvcnRhbCAoY2FjaGUpIHN0YXRlXG4gICAgLy8gY29uc3QgaXNJblBvcnRhbCA9ICgodmlld3BvcnR3aWR0aCA9PSAwKSAmJiAodmlld3BvcnRoZWlnaHQgPT0gMCkpIFxuXG4gICAgLy8gY29uc3QgaXNDYWNoZUNoYW5nZSA9IChpc0luUG9ydGFsICE9IGlzQ2FjaGVkUmVmLmN1cnJlbnQpXG5cbiAgICAvLyBpZiAoaXNDYWNoZUNoYW5nZSkge1xuICAgIC8vICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGlzQ2FjaGVkUmVmLmN1cnJlbnRcbiAgICAvLyAgICAgaXNDYWNoZWRSZWYuY3VycmVudCA9IGlzSW5Qb3J0YWxcbiAgICAvLyB9XG5cbiAgICBjb25zdCBpc0NhY2hpbmdVbmRlcndheSA9IChpc0NhY2hlZFJlZi5jdXJyZW50IHx8IHdhc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UgfHwgXG4gICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZj8uY3VycmVudCB8fFxuICAgICAgICAoVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nICYmIGlzQ2FjaGluZ1VuZGVyd2F5KSkgeyBcblxuICAgICAgICBpZiAoVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZi5jdXJyZW50ID0gZmFsc2UgLy8gbm8gbG9uZ2VyIG5lZWRlZFxuXG4gICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHsgLy8gY2FjaGluZyBvcCBpcyB1bmRlcndheSwgc28gY2FuY2VsXG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZyA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhY2hlQ2hhbmdlKSB7IC8vIGludG8gb3Igb3V0IG9mIGNhY2hpbmdcblxuICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgc3RhdGUgZm9yIHJlc3RvcmluZyBzY3JvbGxQb3NcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyBpZiBpcyBjYWNoZWQsIHRoZW4gdGhlIG5leHQgZWZmZWN0IChmb3IgZW50ZXJpbmcgb3IgbGVhdmluZyBjYWNoZSkgaGFzIGFub3RoZXIgdHVyblxuICAgICAgICBpZiAocGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgPSBmYWxzZSAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuICAgICAgICB9XG5cbiAgICB9LFtwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyBjaGFuZ2Ugc3RhdGUgZm9yIGVudGVyaW5nIG9yIGxlYXZpbmcgY2FjaGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm4gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50ICYmICF3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBpbnRvIGNhY2hlXG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdpbmNhY2hlJylcblxuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhY2hlZFJlZi5jdXJyZW50ICYmIHdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIG91dCBvZiBjYWNoZVxuXG4gICAgICAgICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgPSBmYWxzZSAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwYXJlbnRpbmd0cmFuc2l0aW9uJylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbaXNDYWNoZWRSZWYuY3VycmVudCwgd2FzQ2FjaGVkUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaQVRJT04gZWZmZWN0cyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgYXJlIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcblxuICAgIC8vIGNsZWFyIG1vdW50ZWQgZmxhZyBvbiB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIC8vIHVubW91bnRcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvL3NlbmQgY2FsbC1pbiBmdW5jdGlvbnMgdG8gaG9zdFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICghdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0luZGV4LCBcbiAgICAgICAgICAgIHJlbG9hZCwgXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuXG4gICAgICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgICAgICBtb3ZlSW5kZXgsXG4gICAgICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgICAgIHJlbW92ZUluZGV4LFxuXG4gICAgICAgIH0gPSBzZXJ2aWNlSGFuZGxlclxuXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHtcblxuICAgICAgICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgICAgIHJlbG9hZCxcbiAgICAgICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICAgICAgY2xlYXJDYWNoZSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCxcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgICAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICByZW1vdmVJbmRleCxcblxuICAgICAgICB9XG5cbiAgICAgICAgdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjayhmdW5jdGlvbnMpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc2Nyb2xsIGxpc3RlbmVyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBjb25zdCB2aWV3cG9ydGRhdGEgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgdmlld3BvcnRkYXRhLmVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIub25TY3JvbGwpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgdmlld3BvcnRkYXRhLmVsZW1lbnRSZWYuY3VycmVudCAmJiB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5vblNjcm9sbClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gb2JzZXJ2ZXIgc3VwcG9ydFxuICAgIC8qXG4gICAgICAgIFRoZXJlIGFyZSB0d28gaW50ZXJlY3Rpb24gb2JzZXJ2ZXJzOiBvbmUgZm9yIHRoZSBjcmFkbGUgd2luZ3MsIGFuZCBhbm90aGVyIGZvciB0cmlnZ2VybGluZXM7IFxuICAgICAgICAgICAgYm90aCBhZ2FpbnN0IHRoZSB2aWV3cG9ydC5cbiAgICAqLyAgICBcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjcmFkbGVJbnRlcnNlY3QsXG4gICAgICAgICAgICB0cmlnZ2VybGluZXNJbnRlcnNlY3QsXG4gICAgICAgIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIG9ic2VydmVyIGZvciBjcmFkbGUgYm9keVxuICAgICAgICAvLyB0aGlzIHNldHMgdXAgYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgb2YgdGhlIGNyYWRsZSBhZ2FpbnN0IHRoZSB2aWV3cG9ydC4gV2hlbiB0aGVcbiAgICAgICAgLy8gY3JhZGxlIGdvZXMgb3V0IG9mIHRoZSBvYnNlcnZlciBzY29wZSwgdGhlICdyZXBvc2l0aW9uaW5nUmVuZGVyJyBjcmFkbGUgc3RhdGUgaXMgdHJpZ2dlcmVkLlxuICAgICAgICBjb25zdCBjcmFkbGVpbnRlcnNlY3RvYnNlcnZlciA9IGNyYWRsZUludGVyc2VjdC5jcmVhdGVPYnNlcnZlcigpXG4gICAgICAgIGNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIC8vIHRyaWdnZXJvYnNlcnZlciB0aWdnZXJzIGNyYWRsZSBjb250ZW50IHVwZGF0ZXMgXG4gICAgICAgIC8vICAgICB3aGVuIHRyaWdnZXJsaW5lcyBwYXNzIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAvLyBkZWZlciBjb25uZWN0RWxlbWVudHMgdW50aWwgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzIGhhdmUgYmVlbiBhc3NpZ25lZFxuICAgICAgICBjb25zdCB0cmlnZ2Vyb2JzZXJ2ZXIgPSB0cmlnZ2VybGluZXNJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdHJpZ2dlcm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhbmdlIGxpc3RzaXplLCBjYWNoaW5nLCByZXNpemUgKFVJIHJlc2l6ZSBvZiB0aGUgdmlld3BvcnQpLCByZWNvbmZpZ3VyZSwgb3IgcGl2b3RcblxuICAgIC8vIGNhbGxiYWNrOiB0aGUgbmV3IGxpc3Qgc2l6ZSB3aWxsIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VycmVudCBsaXN0c2l6ZVxuICAgIC8vIGludm9rZWQgaWYgZ2V0SXRlbSByZXR1cm5zIG51bGxcbiAgICBjb25zdCBudWxsSXRlbVNldE1heExpc3RzaXplID0gdXNlQ2FsbGJhY2soKG1heExpc3RzaXplKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RzaXplID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQubGlzdHNpemVcblxuICAgICAgICBpZiAobWF4TGlzdHNpemUgPCBsaXN0c2l6ZSkge1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdnZXRJdGVtIHJldHVybmVkIG51bGwnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNoYW5nZUxpc3RzaXplKG1heExpc3RzaXplLCBcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2spXG5cbiAgICAgICAgfVxuICAgIH0sW10pXG5cbiAgICAvLyBjYWNoaW5nIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBpZiAoY2FjaGUgPT0gJ3ByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgc3dpdGNoIChjYWNoZSkge1xuXG4gICAgICAgICAgICBjYXNlICdrZWVwbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNYXggPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZU1heFxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChjYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2ssIHNjcm9sbGVySUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWNhY2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3JhZGxlJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlY2FjaGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW2NhY2hlLCBjYWNoZU1heF0pXG5cbiAgICAvLyB0cmlnZ2VyIHZpZXdwb3J0cmVzaXppbmcgcmVzcG9uc2UgYmFzZWQgb24gdmlld3BvcnQgc3RhdGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICAvLyBtb3ZlbWVudCB0byBhbmQgZnJvbSBjYWNoZSBpcyBpbmRlcGVuZGVudCBvZiB1aSB2aWV3cG9ydHJlc2l6aW5nXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50IHx8IHdhc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nKSAmJiBcbiAgICAgICAgICAgICAgICAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCAhPSAndmlld3BvcnRyZXNpemluZycpKSB7XG5cbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcbiBcbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCd2aWV3cG9ydHJlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcGxldGUgdmlld3BvcnRyZXNpemluZyBtb2RlXG4gICAgICAgIGlmICghVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcgJiYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3ZpZXdwb3J0cmVzaXppbmcnKSkge1xuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodmlld3BvcnRyZXNpemUnKVxuXG4gICAgICAgIH1cblxuICAgIH0sW1ZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nXSlcblxuICAgIC8vIHJlY29uZmlndXJlIGZvciBjaGFuZ2VkIHNpemUgcGFyYW1ldGVyc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlY29uZmlndXJlJylcblxuICAgIH0sW1xuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG4gICAgXSlcblxuICAgIC8vIGEgbmV3IGdldEl0ZW0gZnVuY3Rpb24gaW1wbGllcyB0aGUgbmVlZCB0byByZWxvYWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVsb2FkJylcblxuICAgIH0sW2dldEl0ZW1dKVxuXG4gICAgLy8gcGl2b3QgdHJpZ2dlcmVkIG9uIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKT9cInNjcm9sbFRvcFwiOlwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBnZXQgcHJldmlvdXMgcmF0aW9cbiAgICAgICAgY29uc3QgcHJldmlvdXNDZWxsUGl4ZWxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoOlxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc09mZnNldCA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNyYXRpbyA9IHByZXZpb3VzQXhpc09mZnNldC9wcmV2aW91c0NlbGxQaXhlbExlbmd0aFxuXG4gICAgICAgIGNvbnN0IHBpdm90Q2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBwaXZvdEF4aXNPZmZzZXQgPSBwcmV2aW91c3JhdGlvICogcGl2b3RDZWxsUGl4ZWxMZW5ndGhcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gTWF0aC5yb3VuZChwaXZvdEF4aXNPZmZzZXQpXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZUF4aXNTdHlsZSxcbiAgICAgICAgY3JhZGxlRGl2aWRlclN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlLFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLmdldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgdXNlcnN0eWxlczpzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgICAgIGxheW91dCxcblxuICAgICAgICB9KVxuXG4gICAgfSxbXG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUQVRFIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZSAoYWJvdXQgMzAgc3RhdGVzKSwgdXNpbmcgbmFtZWQgc3RhdGVzXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGZvciBzdXBwcmVzc2luZyBmbGFzaGVzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29ycyB0byBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhbGwgd29ya2Zsb3cgcmVsYXRlZCwgYnV0XG4gICAgICAgICAgICAvLyByZXNpemUgY291bGQgYmUgYXN5bmNocm9ub3VzIHdoZW4gcm90YXRpbmcgcGhvbmUgZHVyaW5nIHNjcm9sbCBpbnRlcnRpYVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBhc3NpZ25tZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZSAhPSAncHJlbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdpbmNhY2hlJylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcicpIC8vIGxvYWQgZ3JpZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAndmlld3BvcnRyZXNpemluZyc6IHtcblxuICAgICAgICAgICAgICAgIC8vIG5vLW9wLCB3YWl0IGZvciByZXNpemluZyB0byBlbmRcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdzdGFydHByZWxvYWQnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENhbGxiYWNrID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KGNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hwcmVsb2FkJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnaW5jYWNoZScpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnByZWxvYWQoZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRClcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2luY2FjaGUnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXdhc0NhY2hlZFJlZi5jdXJyZW50ICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KXtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB3YWl0IGZvciByZXBhcmVudGluZ1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92aW5nIG91dCBvZiBjYWNoZSBpbnRvIHZpc2libGUgRE9NIHRyZWUgKGNlbGxGcmFtZSlcbiAgICAgICAgICAgIC8vIHJlc2V0cyBzY3JvbGxQb3MgKHNjcm9sbExlZnQvc2Nyb2xsVG9wKSB0byBsYXN0IFVJIHZhbHVlXG4gICAgICAgICAgICBjYXNlICdwYXJlbnRpbmd0cmFuc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NyYWRsZTogcGFyZW50aW5ndHJhbnNpdGlvbjogY3JhZGxlUG9zaXRpb25EYXRhJyxjcmFkbGVQb3NpdGlvbkRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHNjcm9sbCBwb3NpdGlvbiB0byBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9IGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvc1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tTY3JvbGxQb3MgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHBhcmVudGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHBhcmVudGluZyc6e1xuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5yZXN0b3JlSW50ZXJydXB0cygpXG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRyZXBvc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgY3JhZGxlIGludGVyc2VjdGlvbiBpbnRlcnJ1cHRzXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2UgLy8gYmVjYXVzZSBub3cgdW5kZXJ3YXlcblxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxIYW5kbGVyLmlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKSAvLyB0b2dnbGVzIHdpdGggcmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvblxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNocmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldENyYWRsZUNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRoZSBmb2xsb3dpbmcgMTEgY3JhZGxlIHN0YXRlcyBhbGwgcmVzb2x2ZSB3aXRoXG4gICAgICAgICAgICAgICAgYSBjaGFpbiBzdGFydGluZyB3aXRoIHNldENyYWRsZUNvbnRlbnQsIFxuICAgICAgICAgICAgICAgIGNvbnRpbnVpbmcgd2l0aCAncHJlcGFyZXJlbmRlcicsIGFuZCBlbmRpbmcgd2l0aFxuICAgICAgICAgICAgICAgICdyZXN0b3JlaW50ZXJydXB0cycsIHdpdGggYSBkZXRvdXIgZm9yIHZhcmlhYmxlIGxheW91dCBcbiAgICAgICAgICAgICAgICB0byByZWNvbmZpZ3VyZSB0aGUgc2Nyb2xsYmxvY2tcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcmZyb21jYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdyZXJlbmRlcmZyb21jYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdzY3JvbGx0byc6XG4gICAgICAgICAgICBjYXNlICdjaGFuZ2VjYWNoaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHByZWxvYWQnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocmVwb3NpdGlvbic6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2h2aWV3cG9ydHJlc2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdwaXZvdCc6XG4gICAgICAgICAgICBjYXNlICdyZWNvbmZpZ3VyZSc6XG4gICAgICAgICAgICBjYXNlICdyZWxvYWQnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnaW5jYWNoZScpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVsb2FkJykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGRhdGFcbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5zZXRDcmFkbGVDb250ZW50KCBjcmFkbGVTdGF0ZSApXG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgIT0gJ2ZpbmlzaHByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9uaXplIGNhY2hlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PSAnY3JhZGxlJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGN5Y2xlIGZvciBwcmVwYXJlcmVuZGVyXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NyYWRsZUNvbnRlbnQgVEFJTCBsZW5ndGgnLCBcbiAgICAgICAgICAgICAgICAvLyAgICAgJy0nK3Njcm9sbGVySUQrJy0nLFxuICAgICAgICAgICAgICAgIC8vICAgICAnficrc2Nyb2xsZXJQcm9wZXJ0aWVzPy5jZWxsRnJhbWVEYXRhUmVmLmN1cnJlbnQuaW5kZXgrJ34nLFxuICAgICAgICAgICAgICAgIC8vICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlydHVhbCBET01cbiAgICAgICAgICAgICAgICBjb25zdCB7IGxheW91dCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlZnJlc2hET01zZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwcmVwYXJlc2V0Zm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy8gZ2l2ZSB0aW1lIGZvciBET00gdG8gcHJvZHVjZSBsYXlvdXRcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCdzZXRjcmFkbGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hzZXRmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICB9LFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVyZW5kZXInOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RFbGVtZW50cyBkZWxheWVkIGZvciBhIGN5Y2xlIHRvIHJlbmRlciB0cmlnZ2VyY2VsbCB0cmlnZ2VybGluZXNcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSBwcmUtZW1wdGVkIGJ5IHJlcGFyZW50aW5nLCB3aGljaCBpdHNlbGYgcmVzdG9yZXMgaW50ZXJydXB0c1xuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXN0b3JlaW50ZXJydXB0cycpIC8vIHRvIHJlc3RvcmUgaW50ZXJydXB0c1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVzdG9yZWludGVycnVwdHMnOiB7IC8vIG5vcm1hbGl6ZSBvciByZXN1bWUgY3ljbGluZ1xuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5yZXN0b3JlSW50ZXJydXB0cygpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZm9sbG93dXAgZnJvbSB1cGRhdGVDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHNjcm9sbCBlZmZlY3RzXG5cbiAgICAgICAgICAgIC8vIHJlbmRlcnVwZGF0ZWRjb250ZW50IGlzIGNhbGxlZCBmcm9tIHVwZGF0ZUNyYWRsZUNvbnRlbnQuIFxuICAgICAgICAgICAgLy8gaXQgaXMgcmVxdWlyZWQgdG8gaW50ZWdyYXRlIGNoYW5nZWQgRE9NIGNvbmZpZ3VyYXRpb25zIGJlZm9yZSAncmVhZHknIGlzIGRpc3BsYXllZFxuICAgICAgICAgICAgY2FzZSAncmVuZGVydXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlydHVhbCBET01cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuXG4gICAgICAgICAgICAgICAgLy8gc3luY2hyb25pemUgY2FjaGVcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtYWN0aXZhdGUgdHJpZ2dlcnM7IHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlZnJlc2hET011cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGN5Y2xlIG5lZWRlZCB0byBhbGxvdyB0aW1lIHRvIHN5bmNocm9uaXplIERPTSB3aXRoIGdyaWQgY2hhbmdlc1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCd1cGRhdGVjcmFkbGUnKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsbGVkIGZyb20gb25BZnRlclNjcm9sbC4gXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBjYWxsZWQgdHdpY2UgaW4gc3VjY2Vzc2lvbiB3aXRoIHNob3J0IG9uQWZ0ZXJTY3JvbGwgdGltZW91dFxuICAgICAgICAgICAgY2FzZSAnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHlhZnRlcnNjcm9sbCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkoJ2FmdGVyc2Nyb2xsJylcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgLy8gcmUtYWN0aXZhdGUgdHJpZ2dlcnM7IHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tWyB1c2VyIHJlcXVlc3RzIF0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHZhcmlvdXMgaG9zdCBzZXJ2aWNlIHJlcXVlc3RzOyBzeW5jcyBjcmFkbGUgY29udGVudCB3aXRoIGNhY2hlIGNoYW5nZXNcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcyc6IHsgLy8gdXNlciBpbnRlcnZlbnRpb25cblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsSG9sZExpc3QgfSA9IGNhY2hlSGFuZGxlclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsTWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRhbEhvbGRMaXN0ICYmIHBvcnRhbEhvbGRMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbUlEIG9mIHBvcnRhbEhvbGRMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjbGVhcmNhY2hlJzoge1xuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuY2xlYXJDcmFkbGUoKVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZVN0YXRlXSlcblxuICAgIC8vIHN0YW5kYXJkIHJlbmRlcmluZyBzdGF0ZXMgKDMgc3RhdGVzKVxuICAgIHVzZUVmZmVjdCgoKT0+IHsgXG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uaW5nUmVuZGVyIGFuZCByZXBvc2l0aW9uaW5nQ29udGludWF0aW9uIGFyZSB0b2dnbGVkIHRvIGdlbmVyYXRlIGNvbnRpbnVvdXMgXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uaW5nIHJlbmRlcnNcbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdSZW5kZXInOiAvLyBuby1vcFxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nOiAvLyBzZXQgZnJvbSBvblNjcm9sbFxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nUmVuZGVyJylcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6IC8vIG5vLW9wXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZVN0YXRlXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBSRU5ERVIgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgY29uc3Qgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4ID0gbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgY29uc3Qgc2Nyb2xsVHJhY2tlckFyZ3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCF1c2VTY3JvbGxUcmFja2VyKSByZXR1cm4gbnVsbFxuICAgICAgICBpZiAoIVsncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicsJ3JlcG9zaXRpb25pbmdSZW5kZXInXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG4gICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrKHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleClcbiAgICAgICAgY29uc3QgdHJhY2tlcmFyZ3MgPSB7XG4gICAgICAgICAgICB0b3A6dmlld3BvcnREaW1lbnNpb25zLnRvcCArIDMsXG4gICAgICAgICAgICBsZWZ0OnZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgMyxcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFja2VyYXJnc1xuICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGNyYWRsZVN0YXRlLCBcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9ucywgXG4gICAgICAgICAgICBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyLFxuICAgICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYuY3VycmVudCA9IHVzZU1lbW8oKCk9PntcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleSA9ICdoZWFkJ1xuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdoZWFkdHJpZ2dlcidcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlfVxuICAgICAgICAgICAgICAgIHJlZiA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWZ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5ID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWx0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZVxuICAgIF0pXG5cbiAgICBjb25zdCBjb250ZXh0dmFsdWVSZWYgPSB1c2VSZWYoe1xuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBjYWNoZUhhbmRsZXIsIFxuICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplLFxuICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2s6c2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLml0ZW1FeGNlcHRpb25DYWxsYmFjayxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLFxuICAgIH0pXG5cblxuICAgIC8vIGRpc3BsYXkgdGhlIGNyYWRsZSBjb21wb25lbnRzLCB0aGUgU2Nyb2xsVHJhY2tlciwgb3IgbnVsbFxuICAgIHJldHVybiA8Q3JhZGxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZSA9IHsgY29udGV4dHZhbHVlUmVmLmN1cnJlbnQgfT5cblxuICAgICAgICB7KFsncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicsJ3JlcG9zaXRpb25pbmdSZW5kZXInXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkpP1xuICAgICAgICAgICAgdXNlU2Nyb2xsVHJhY2tlcj88U2Nyb2xsVHJhY2tlciBcbiAgICAgICAgICAgICAgICB0b3AgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnRvcCB9IFxuICAgICAgICAgICAgICAgIGxlZnQgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLmxlZnQgfSBcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCB9IFxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBzY3JvbGxUcmFja2VyQXJncy5saXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzY3JvbGxUcmFja2VyQXJncy5zdHlsZXMgfVxuICAgICAgICAgICAgLz46bnVsbDpcbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2NyYWRsZS1heGlzJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVBeGlzU3R5bGUgfSBcbiAgICAgICAgICAgICAgICByZWYgPSB7IGF4aXNDcmFkbGVFbGVtZW50UmVmIH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IHNob3dBeGlzPyAvLyBmb3IgZGVidWdcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdjcmFkbGUtZGl2aWRlcicgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsgY3JhZGxlRGl2aWRlclN0eWxlIH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj46XG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2hlYWQnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHsgaGVhZENyYWRsZUVsZW1lbnRSZWYgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsgY3JhZGxlSGVhZFN0eWxlIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHsoY3JhZGxlU3RhdGUgIT0gJ3NldHVwJyk/XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd0YWlsJ1xuICAgICAgICAgICAgICAgICAgICByZWYgPSB7IHRhaWxDcmFkbGVFbGVtZW50UmVmIH0gXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVUYWlsU3R5bGUgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuXG4gICAgPC9DcmFkbGVDb250ZXh0LlByb3ZpZGVyPlxuXG59IC8vIENyYWRsZVxuXG5leHBvcnQgZGVmYXVsdCBDcmFkbGVcblxuLy8gdXRpbGl0eVxuXG5jb25zdCBnZXRDcmFkbGVIYW5kbGVycyA9IChjcmFkbGVQYXJhbWV0ZXJzKSA9PiB7XG5cbiAgICBjb25zdCBjcmVhdGVIYW5kbGVyID0gaGFuZGxlciA9PiBuZXcgaGFuZGxlcihjcmFkbGVQYXJhbWV0ZXJzKVxuXG4gICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICBjYWNoZUhhbmRsZXIuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoSW50ZXJydXB0SGFuZGxlciksXG4gICAgICAgIHNjcm9sbEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTY3JvbGxIYW5kbGVyKSxcbiAgICAgICAgc3RhdGVIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoU3RhdGVIYW5kbGVyKSxcbiAgICAgICAgY29udGVudEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihDb250ZW50SGFuZGxlciksXG4gICAgICAgIGxheW91dEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihMYXlvdXRIYW5kbGVyKSxcbiAgICAgICAgc2VydmljZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTZXJ2aWNlSGFuZGxlciksXG4gICAgICAgIHN0eWxlc0hhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdHlsZXNIYW5kbGVyKSxcblxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJyZWFjdF8xIiwiY3JlYXRlQ29udGV4dCIsIkNyYWRsZSIsImdyaWRTcGVjcyIsInJ1bndheVNpemUiLCJsaXN0c2l6ZSIsInN0YXJ0aW5nSW5kZXgiLCJnZXRJdGVtIiwicGxhY2Vob2xkZXIiLCJ1c2VyQ2FsbGJhY2tzIiwic3R5bGVzIiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJjYWNoZSIsImNhY2hlTWF4Iiwic2Nyb2xsZXJJRCIsImNhY2hlSGFuZGxlciIsInVzZVBsYWNlaG9sZGVyIiwidXNlU2Nyb2xsVHJhY2tlciIsInNob3dBeGlzIiwiU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwiLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsIlRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyIsInNjcm9sbGVyUHJvcGVydGllcyIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwibGF5b3V0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsImlzTW91bnRlZFJlZiIsImlzQ2FjaGVkUmVmIiwid2FzQ2FjaGVkUmVmIiwicGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmIiwiaGFzQmVlblJlbmRlcmVkUmVmIiwiZ2V0Vmlld3BvcnREaW1lbnNpb25zIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ2aWV3cG9ydGhlaWdodCIsInZpZXdwb3J0d2lkdGgiLCJpc0luUG9ydGFsIiwiaXNDYWNoZUNoYW5nZSIsImNyYWRsZVN0YXRlIiwic2V0Q3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImhlYWRDcmFkbGVFbGVtZW50UmVmIiwidGFpbENyYWRsZUVsZW1lbnRSZWYiLCJheGlzQ3JhZGxlRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiIsImNyYWRsZUVsZW1lbnRzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJheGlzUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZiIsImNyb3NzY291bnQiLCJ2aWV3cG9ydGNyb3NzbGVuZ3RoIiwidmlld3BvcnRjcm9zc2xlbmd0aGZvcmNhbGMiLCJjZWxsY3Jvc3NsZW5ndGgiLCJjZWxsY3Jvc3NsZW5ndGhmb3JjYWxjIiwiTWF0aCIsIm1pbiIsImZsb29yIiwidmlld3BvcnRMZW5ndGgiLCJiYXNlUm93TGVuZ3RoIiwidmlld3BvcnRSb3djb3VudCIsImNlaWwiLCJ2aWV3cG9ydFZpc2libGVSb3djb3VudCIsImxpc3RSb3djb3VudCIsImNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJkaWZmIiwibWF4IiwiaXRlbWNvdW50IiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsInJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3JhZGxlUGFyYW1ldGVycyIsImNyYWRsZVBhcmFtZXRlcnNSZWYiLCJnZXRDcmFkbGVIYW5kbGVycyIsImludGVycnVwdEhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwic3RhdGVIYW5kbGVyIiwiY29udGVudEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJzdHlsZXNIYW5kbGVyIiwiaXNDYWNoaW5nVW5kZXJ3YXkiLCJpc1JlcGFyZW50aW5nUmVmIiwiaXNSZXNpemluZyIsInBhdXNlSW50ZXJydXB0cyIsImZ1bmN0aW9uc0NhbGxiYWNrIiwic2Nyb2xsVG9JbmRleCIsInJlbG9hZCIsInNldExpc3RzaXplIiwiY2xlYXJDYWNoZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsInJlbWFwSW5kZXhlcyIsIm1vdmVJbmRleCIsImluc2VydEluZGV4IiwicmVtb3ZlSW5kZXgiLCJmdW5jdGlvbnMiLCJ2aWV3cG9ydGRhdGEiLCJhZGRFdmVudExpc3RlbmVyIiwib25TY3JvbGwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JhZGxlSW50ZXJzZWN0IiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0IiwiY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIiLCJjcmVhdGVPYnNlcnZlciIsImNvbm5lY3RFbGVtZW50cyIsInRyaWdnZXJvYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJudWxsSXRlbVNldE1heExpc3RzaXplIiwibWF4TGlzdHNpemUiLCJjYWxsYmFja3MiLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImNoYW5nZUxpc3RzaXplIiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsInBhcmVDYWNoZVRvTWF4IiwiY2FjaGVQcm9wcyIsIm1vZGlmaWVkIiwicmVuZGVyUG9ydGFsTGlzdCIsIm1hdGNoQ2FjaGVUb0NyYWRsZSIsImNyYWRsZVBvc2l0aW9uRGF0YSIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJibG9ja1Njcm9sbFBvcyIsInByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoIiwicHJldmlvdXNBeGlzT2Zmc2V0IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJwcmV2aW91c3JhdGlvIiwicGl2b3RDZWxsUGl4ZWxMZW5ndGgiLCJwaXZvdEF4aXNPZmZzZXQiLCJyb3VuZCIsImdldENyYWRsZVN0eWxlcyIsInVzZXJzdHlsZXMiLCJjcmFkbGVIZWFkU3R5bGUiLCJjcmFkbGVUYWlsU3R5bGUiLCJjcmFkbGVBeGlzU3R5bGUiLCJjcmFkbGVEaXZpZGVyU3R5bGUiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZSIsImZpbmFsQ2FsbGJhY2siLCJwcmVsb2FkIiwicmVzdG9yZUludGVycnVwdHMiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyZXBvc2l0aW9uaW5nUmVxdWlyZWQiLCJpc1Njcm9sbGluZyIsImNyYWRsZUNvbnRlbnQiLCJjb250ZW50IiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJzZXRDcmFkbGVDb250ZW50IiwiaGVhZERpc3BsYXlDb21wb25lbnRzIiwidGFpbERpc3BsYXlDb21wb25lbnRzIiwic2V0VGltZW91dCIsImFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInBvcnRhbEhvbGRMaXN0IiwicG9ydGFsTWFwIiwibGVuZ3RoIiwiaXRlbUlEIiwiY2xlYXJDcmFkbGUiLCJzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJzY3JvbGxUcmFja2VyQXJncyIsImluY2x1ZGVzIiwidHJhY2tlcmFyZ3MiLCJ0b3AiLCJsZWZ0IiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYiLCJrZXkiLCJzdHlsZSIsInJlZiIsImNvbnRleHR2YWx1ZVJlZiIsIlByb3ZpZGVyIiwidmFsdWUiLCJTY3JvbGxUcmFja2VyXzEiLCJvZmZzZXQiLCJjcmVhdGVIYW5kbGVyIiwiaGFuZGxlciIsImludGVycnVwdGhhbmRsZXJfMSIsInNjcm9sbGhhbmRsZXJfMSIsInN0YXRlaGFuZGxlcl8xIiwiY29udGVudGhhbmRsZXJfMSIsImxheW91dGhhbmRsZXJfMSIsInNlcnZpY2VoYW5kbGVyXzEiLCJzdHlsZXNoYW5kbGVyXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Scrollblock.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element (scrolled by Viewport) of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n    listsize = _ref.listsize,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    layout = gridSpecs.layout;\n  // -------------------------[ context and state ]-------------------------\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  // -----------------------------------[ data heap ]-------------------------\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null);\n  // just for init\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n    _ref3 = _slicedToArray(_ref2, 2),\n    divlinerstyle = _ref3[0],\n    saveDivlinerstyle = _ref3[1]; // to trigger render\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n    width = _ViewportContextPrope.width,\n    height = _ViewportContextPrope.height;\n  // reconfigure\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\nexports["default"] = Scrollblock;\n// any of the parameters can affect the length\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n    viewportheight = _ref4.viewportheight,\n    viewportwidth = _ref4.viewportwidth,\n    listsize = _ref4.listsize,\n    cellHeight = _ref4.cellHeight,\n    cellWidth = _ref4.cellWidth,\n    gap = _ref4.gap,\n    padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  }\n  // adjustments to viewportcrosslength\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  // -------------------[ calculate scrollblock length ]-----------------\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap :\n  // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n  return baselength;\n};\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n  var height;\n  var width;\n  if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n  } else {\n    // orientation == \'horizontal\'\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n  }\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF1QixDQUFJdEIsV0FBVyxFQUFFc0MsU0FBUyxFQUFFQyx3QkFBd0IsRUFBSTtFQUVqRixJQUFJQyxXQUFXLHFCQUFPRixTQUFTLENBQUN6QixPQUFPLENBQUMsRUFBQztFQUN6QyxJQUFJSyxNQUFNO0VBQ1YsSUFBSUQsS0FBSztFQUNULElBQUlqQixXQUFXLElBQUksVUFBVSxFQUFFO0lBQzNCa0IsTUFBTSxHQUFHcUIsd0JBQXdCLENBQUMxQixPQUFPLEdBQUcsSUFBSTtJQUNoREksS0FBSyxHQUFHLE1BQU07R0FDakIsTUFBTTtJQUFFO0lBQ0xDLE1BQU0sR0FBRyxNQUFNO0lBQ2ZELEtBQUssR0FBR3NCLHdCQUF3QixDQUFDMUIsT0FBTyxHQUFHLElBQUk7O0VBRW5EMkIsV0FBVyxDQUFDdEIsTUFBTSxHQUFHQSxNQUFNO0VBQzNCc0IsV0FBVyxDQUFDdkIsS0FBSyxHQUFHQSxLQUFLO0VBRXpCLE9BQU91QixXQUFXO0FBQ3RCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1Njcm9sbGJsb2NrLnRzeD8zYjY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNjcm9sbGJsb2NrLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcblxuICAgIFRoZSBzY3JvbGxibG9jayBwcm92aWRlcyB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IChzY3JvbGxlZCBieSBWaWV3cG9ydCkgb2YgdGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIuXG4gICAgSXQgaXMgc2l6ZWQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBjZWxsIHNpemUgYW5kIHJvdyBjb3VudHMsIGFkanVzdGVkIGZvciB2YXJpYWJsZSBjcmFkbGUgY29udGVudC5cbiAgICBJdHMgb25seSBzdGF0ZSBjaGFuZ2UgaXMgY2hhbmdlIG9mIHN0eWxlcy5cblxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlQ29udGV4dCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtb30gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vVmlld3BvcnQnXG5cbmNvbnN0IFNjcm9sbGJsb2NrID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICBsaXN0c2l6ZSxcbiAgICBncmlkU3BlY3MsIFxuICAgIHN0eWxlcyxcbiAgICBzY3JvbGxlcklELFxufSkgPT4ge1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBcbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjb250ZXh0IGFuZCBzdGF0ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHVzZUNvbnRleHQoVmlld3BvcnRDb250ZXh0KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGRhdGEgaGVhcCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBqdXN0IGZvciBpbml0XG4gICAgY29uc3QgbGluZXJTdHlsZSA9IHVzZU1lbW8oKCkgPT57XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0eWxlcy5zY3JvbGxibG9jayxcbiAgICAgICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZScsXG4gICAgICAgIH1cblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgZGl2bGluZXJzdHlsZVJlZiA9IHVzZVJlZihsaW5lclN0eWxlKVxuXG4gICAgY29uc3QgW2RpdmxpbmVyc3R5bGUsc2F2ZURpdmxpbmVyc3R5bGVdID0gdXNlU3RhdGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KSAvLyB0byB0cmlnZ2VyIHJlbmRlclxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLnZpZXdwb3J0RGltZW5zaW9uc1xuICAgIFxuICAgIC8vIHJlY29uZmlndXJlXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcblxuICAgICAgICB1cGRhdGVCYXNlQmxvY2tMZW5ndGgoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQ6aGVpZ2h0LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0d2lkdGg6d2lkdGgsXG4gICAgICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50ID0gXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyhcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLFxuICAgICAgICAgICAgICAgIGJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZlxuICAgICAgICAgICAgKVxuICAgICAgICBzYXZlRGl2bGluZXJzdHlsZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgY29uc3QgdXBkYXRlQmFzZUJsb2NrTGVuZ3RoID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChsYXlvdXRzcGVjcykgPT4ge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBiYXNlc2Nyb2xsYmxvY2tsZW5ndGggPSBjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoKGxheW91dHNwZWNzKVxuXG4gICAgICAgICAgICBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYuY3VycmVudCA9IGJhc2VzY3JvbGxibG9ja2xlbmd0aFxuXG4gICAgICAgIH0sW11cbiAgICApXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAnc2Nyb2xsYmxvY2snIHN0eWxlPXtkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnR9PntjaGlsZHJlbn08L2Rpdj5cblxufSAvLyBTY3JvbGxibG9ja1xuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxibG9ja1xuXG4vLyBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgY2FuIGFmZmVjdCB0aGUgbGVuZ3RoXG5jb25zdCBjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoID0gKHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgY3Jvc3Njb3VudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9jcm9zc2NvdW50IGlzIGFsc28gY2FsY3VsYXRlZCBieSBDcmFkbGVcblxuICAgIGxldCBjcm9zc2xlbmd0aFxuICAgIGxldCBjZWxsTGVuZ3RoXG4gICAgbGV0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydHdpZHRoIFxuXG4gICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgY3Jvc3NsZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgdmlld3BvcnRjcm9zc2xlbmd0aCA9IHZpZXdwb3J0aGVpZ2h0XG5cbiAgICB9XG5cbiAgICAvLyBhZGp1c3RtZW50cyB0byB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCAtPSAocGFkZGluZyAqIDIpXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCArPSBnYXAgLy8gdG8gbWF0Y2ggY3Jvc3NMZW5ndGhcblxuICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoIDwgY3Jvc3NsZW5ndGgpIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBjcm9zc2xlbmd0aCAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZVxuXG4gICAgY29uc3QgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRjcm9zc2xlbmd0aC9jcm9zc2xlbmd0aClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBzY3JvbGxibG9jayBsZW5ndGggXS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBsaXN0cm93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdHJvd2NvdW50ICogY2VsbExlbmd0aCkgLSBcbiAgICAgICAgKChsaXN0cm93Y291bnQgPiAwKT9cbiAgICAgICAgICAgIGdhcDogLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICAwKSBcbiAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgIHJldHVybiBiYXNlbGVuZ3RoXG5cbn1cblxuY29uc3QgdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMgPSAob3JpZW50YXRpb24sIHN0eWxlc1JlZiwgYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmKSA9PiB7XG5cbiAgICBsZXQgbG9jYWxzdHlsZXMgPSB7Li4uc3R5bGVzUmVmLmN1cnJlbnR9IC8vIG5ldyBvYmplY3RcbiAgICBsZXQgaGVpZ2h0IFxuICAgIGxldCB3aWR0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIGhlaWdodCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgIH0gZWxzZSB7IC8vIG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJ1xuICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgd2lkdGggPSBiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG59XG4iXSwibmFtZXMiOlsiU2Nyb2xsYmxvY2siLCJjaGlsZHJlbiIsImxpc3RzaXplIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRfMSIsImJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZiIsImxpbmVyU3R5bGUiLCJzY3JvbGxibG9jayIsInBvc2l0aW9uIiwiZGl2bGluZXJzdHlsZVJlZiIsImN1cnJlbnQiLCJkaXZsaW5lcnN0eWxlIiwic2F2ZURpdmxpbmVyc3R5bGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInVwZGF0ZUJhc2VCbG9ja0xlbmd0aCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzIiwibGF5b3V0c3BlY3MiLCJiYXNlc2Nyb2xsYmxvY2tsZW5ndGgiLCJjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoIiwicmVhY3RfMSIsInN0eWxlIiwiZXhwb3J0cyIsImNyb3NzbGVuZ3RoIiwiY2VsbExlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGgiLCJjcm9zc2NvdW50IiwiTWF0aCIsImZsb29yIiwibGlzdHJvd2NvdW50IiwiY2VpbCIsImJhc2VsZW5ndGgiLCJzdHlsZXNSZWYiLCJiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYiLCJsb2NhbHN0eWxlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Viewport.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible screen portal of the list being shown.\n    If it is resized, it notifies the Cradle to reconfigure.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nexports.ViewportContext = react_1["default"].createContext(null); // for children\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js");\nvar ResizeObserver = window[\'ResizeObserver\'] || resize_observer_1.ResizeObserver;\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID,\n    scrollerProperties = _ref.scrollerProperties,\n    VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    layout = gridSpecs.layout;\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    viewportState = _ref3[0],\n    setViewportState = _ref3[1]; // setup, resizing, resized, ready\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var viewportElementRef = (0, react_1.useRef)(null);\n  // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  // initialize\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isReparentingRef: scrollerProperties === null || scrollerProperties === void 0 ? void 0 : scrollerProperties.isReparentingRef,\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  });\n  // mark as unmounted\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // --------------------[ viewport resizer interrupt ]-----------------------\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null);\n  // set up resizeObserver\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current);\n    // unmount\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  // used by resizeObserver; generates interrupt\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target;\n    // no need to trigger interrupt on first resize notification\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    }\n    // generate interrupt response, if initiating resize\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true;\n      // new object creation triggers a realtime interrupt message to cradle through context\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    }\n    // finalize resizing after timeout\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []);\n  // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n  var divlinerstyleRef = (0, react_1.useRef)(null);\n  // initialize with inherited styles\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'auto\',\n      overflowAnchor: \'none\'\n    });\n  }, [styles.viewport]);\n  // update ViewportContextPropertiesRef; add viewport dimensions\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n      top = _viewportElementRef$c.top,\n      right = _viewportElementRef$c.right,\n      bottom = _viewportElementRef$c.bottom,\n      left = _viewportElementRef$c.left;\n    var width = right - left;\n    var height = bottom - top;\n    // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    };\n    // trigger context change with new object\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]);\n  // --------------------[ state processing ]---------------------------\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]);\n  // ----------------------[ render ]--------------------------------\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SDtFQUFPLEdBQzNFckI7SUFBQSxhQUNnQixVQUFVO0lBQUEsbUJBQ0ZTLFVBQVU7SUFDOUJpRCxLQUFLLEVBQUtqQixnQkFBZ0IsQ0FBQ3BCLE9BQU87SUFDbENzQyxHQUFHLEVBQUtwQztFQUFrQixHQUV2QkwsYUFBYSxJQUFJLE9BQU8sSUFBS1osUUFBUSxDQUN0QyxDQUNpQjtBQUUvQixDQUFDLEVBQUM7QUFFRlAsa0JBQUFBLEdBQWVNLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1ZpZXdwb3J0LnRzeD9jODI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXdwb3J0LnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB2aWV3cG9ydCBpcyB0byBwcm92aWRlIGRhdGEgdG8gaXRzIGNoaWxkcmVuIChzY3JvbGxibG9jayBhbmQgY3JhZGxlKSxcbiAgICBhbmQgYWN0IGFzIHRoZSB2aXNpYmxlIHNjcmVlbiBwb3J0YWwgb2YgdGhlIGxpc3QgYmVpbmcgc2hvd24uXG4gICAgSWYgaXQgaXMgcmVzaXplZCwgaXQgbm90aWZpZXMgdGhlIENyYWRsZSB0byByZWNvbmZpZ3VyZS5cbiovXG5cbmltcG9ydCBSZWFjdCwge1xuXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZVJlZiwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZU1lbW8sIFxuICAgIHVzZUNhbGxiYWNrLCBcbiAgICB1c2VDb250ZXh0XG5cbn0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBWaWV3cG9ydENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpIC8vIGZvciBjaGlsZHJlblxuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciBhcyBSZXNpemVPYnNlcnZlclBvbGx5ZmlsbCB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJ1xuXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHdpbmRvd1snUmVzaXplT2JzZXJ2ZXInXSB8fCBSZXNpemVPYnNlcnZlclBvbGx5ZmlsbFxuXG5jb25zdCBWaWV3cG9ydCA9ICh7XG5cbiAgICBjaGlsZHJlbiwgXG4gICAgZ3JpZFNwZWNzLFxuICAgIHN0eWxlcyxcbiAgICBzY3JvbGxlcklELFxuICAgIHNjcm9sbGVyUHJvcGVydGllcyxcbiAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCxcbiAgICBcbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGxheW91dCxcblxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIGNvbnN0IFt2aWV3cG9ydFN0YXRlLHNldFZpZXdwb3J0U3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJykgLy8gc2V0dXAsIHJlc2l6aW5nLCByZXNpemVkLCByZWFkeVxuXG4gICAgY29uc3Qgdmlld3BvcnRTdGF0ZVJlZiA9IHVzZVJlZihudWxsKSAvLyBmb3IgdXNlQ2FsbGJhY2sgLT4gcmVzaXplQ2FsbGJhY2sgc2NvcGVcbiAgICB2aWV3cG9ydFN0YXRlUmVmLmN1cnJlbnQgPSB2aWV3cG9ydFN0YXRlXG5cbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcblxuICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiBpcyBwYXNzZWQgYXMgYSByZXNpemluZyBpbnRlcnJ1cHQgKHRocm91Z2ggY29udGV4dCkgdG8gY2hpbGRyZW5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjpzY3JvbGxlclByb3BlcnRpZXM/LmlzUmVwYXJlbnRpbmdSZWYsIFxuICAgICAgICAgICAgaXNSZXNpemluZzpmYWxzZSwgXG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6bnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6bnVsbFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gbWFyayBhcyB1bm1vdW50ZWRcbiAgICB1c2VFZmZlY3QoKCkgPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHZpZXdwb3J0IHJlc2l6ZXIgaW50ZXJydXB0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVzaXplVGltZXJpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGlzUmVzaXppbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7ICAgIFxuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVudHJpZXNbMF0udGFyZ2V0XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byB0cmlnZ2VyIGludGVycnVwdCBvbiBmaXJzdCByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQgPSAndHJ1ZSdcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJydXB0IHJlc3BvbnNlLCBpZiBpbml0aWF0aW5nIHJlc2l6ZVxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG5cbiAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgY3JlYXRpb24gdHJpZ2dlcnMgYSByZWFsdGltZSBpbnRlcnJ1cHQgbWVzc2FnZSB0byBjcmFkbGUgdGhyb3VnaCBjb250ZXh0XG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxpemUgcmVzaXppbmcgYWZ0ZXIgdGltZW91dFxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNvbmZpZyB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzdHlsZXNcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplIHdpdGggaW5oZXJpdGVkIHN0eWxlc1xuICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIC4uLnN0eWxlcy52aWV3cG9ydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICBpbnNldDowLFxuICAgICAgICAgICAgb3ZlcmZsb3c6J2F1dG8nLFxuICAgICAgICAgICAgb3ZlcmZsb3dBbmNob3I6J25vbmUnLCAvLyBjcnVjaWFsIVxuICAgICAgICAgICAgLy8gb3ZlcnNjcm9sbEJlaGF2aW9yOidub25lJ1xuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH0sW3N0eWxlcy52aWV3cG9ydF0pXG5cbiAgICAvLyB1cGRhdGUgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZjsgYWRkIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZSA9PSAnc2V0dXAnKSByZXR1cm4gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSB2aWV3cG9ydEVsZW1lbnRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBjb25zdCB3aWR0aCA9IChyaWdodCAtIGxlZnQpXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IChib3R0b20gLSB0b3ApXG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIGRpbWVuc2lvbiB1cGRhdGUgcHJvY2VkdXJlIGZvciByZXNpemUuIFxuICAgICAgICAvLyBTZWUgYWxzbyBpbnRlcnJ1cHRoYW5kbGVyLnRzeCBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrIGZvciBjcmFkbGUgaW50ZXJzZWN0aW9uIHVwZGF0ZVxuICAgICAgICBjb25zdCBsb2NhbFZpZXdwb3J0RGF0YSA9IHtcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczp7dG9wLHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgICAgICAgZWxlbWVudFJlZjp2aWV3cG9ydEVsZW1lbnRSZWYsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOmlzUmVzaXppbmdSZWYuY3VycmVudCxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBjaGFuZ2Ugd2l0aCBuZXcgb2JqZWN0XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YW9iamVjdCA9IHsuLi5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsIC4uLmxvY2FsVmlld3BvcnREYXRhfVxuXG4gICAgICAgIHJldHVybiAgdmlld3BvcnRkYXRhb2JqZWN0XG5cbiAgICB9LFtvcmllbnRhdGlvbiwgaXNSZXNpemluZ1JlZi5jdXJyZW50LCB2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzdGF0ZSBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgc3dpdGNoICh2aWV3cG9ydFN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiB7XG4gICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0U3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmV0dXJuIDxWaWV3cG9ydENvbnRleHQuUHJvdmlkZXIgdmFsdWUgPSB7IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCB9PlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgZGF0YS10eXBlID0gJ3ZpZXdwb3J0J1xuICAgICAgICAgICAgZGF0YS1zY3JvbGxlcmlkID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgIHN0eWxlID0geyBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgcmVmID0geyB2aWV3cG9ydEVsZW1lbnRSZWYgfVxuICAgICAgICA+XG4gICAgICAgICAgICB7ICh2aWV3cG9ydFN0YXRlICE9ICdzZXR1cCcpICYmIGNoaWxkcmVuIH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9WaWV3cG9ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgXG59IC8vIFZpZXdwb3J0XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWN0XzEiLCJjcmVhdGVDb250ZXh0IiwiUmVzaXplT2JzZXJ2ZXIiLCJ3aW5kb3ciLCJyZXNpemVfb2JzZXJ2ZXJfMSIsIlZpZXdwb3J0IiwiY2hpbGRyZW4iLCJncmlkU3BlY3MiLCJzdHlsZXMiLCJzY3JvbGxlcklEIiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwiVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQiLCJvcmllbnRhdGlvbiIsImdhcCIsInBhZGRpbmciLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwibGF5b3V0Iiwidmlld3BvcnRTdGF0ZSIsInNldFZpZXdwb3J0U3RhdGUiLCJ2aWV3cG9ydFN0YXRlUmVmIiwiY3VycmVudCIsImlzTW91bnRlZFJlZiIsInZpZXdwb3J0RWxlbWVudFJlZiIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJpc1JlcGFyZW50aW5nUmVmIiwiaXNSZXNpemluZyIsInZpZXdwb3J0RGltZW5zaW9ucyIsImVsZW1lbnRSZWYiLCJyZXNpemVUaW1lcmlkUmVmIiwiaXNSZXNpemluZ1JlZiIsInJlc2l6ZU9ic2VydmVyUmVmIiwicmVzaXplQ2FsbGJhY2siLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsImVudHJpZXMiLCJ0YXJnZXQiLCJkYXRhc2V0IiwiaW5pdGlhbGl6ZWQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZGl2bGluZXJzdHlsZVJlZiIsInZpZXdwb3J0IiwicG9zaXRpb24iLCJpbnNldCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dBbmNob3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsImxvY2FsVmlld3BvcnREYXRhIiwidmlld3BvcnRkYXRhb2JqZWN0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInN0eWxlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Placeholder.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n    listsize = _ref.listsize,\n    message = _ref.message,\n    error = _ref.error,\n    userFrameStyles = _ref.userFrameStyles,\n    userLinerStyles = _ref.userLinerStyles;\n  var frameStylesRef = (0, react_1.useRef)(Object.assign(Object.assign({\n    border: \'2px solid black\',\n    backgroundColor: \'cyan\'\n  }, userFrameStyles), {\n    position: \'relative\',\n    boxSizing: \'border-box\',\n    height: \'100%\',\n    width: \'100%\'\n  }));\n  var linerStylesRef = (0, react_1.useRef)(Object.assign({\n    position: \'absolute\',\n    top: 0,\n    left: 0,\n    padding: \'3px\',\n    opacity: .5,\n    borderRadius: \'8px\',\n    backgroundColor: \'white\',\n    margin: \'3px\',\n    fontSize: \'smaller\'\n  }, userLinerStyles));\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    "data-type": \'placeholderframe\',\n    style: frameStylesRef.current\n  }, !error ? react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStylesRef.current\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStylesRef.current\n  }, "item is not available (", error.message, ")"));\n};\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7OztBQVFBO0FBRUEsSUFBTUEsV0FBVyxHQUFHLFNBQWRBLFdBQVcsT0FBMkU7RUFBQSxJQUF0RUMsS0FBSyxRQUFMQSxLQUFLO0lBQUVDLFFBQVEsUUFBUkEsUUFBUTtJQUFFQyxPQUFPLFFBQVBBLE9BQU87SUFBRUMsS0FBSyxRQUFMQSxLQUFLO0lBQUVDLGVBQWUsUUFBZkEsZUFBZTtJQUFFQyxlQUFlLFFBQWZBLGVBQWU7RUFFbkYsSUFBTUMsY0FBYyxHQUFHLGtCQUFNO0lBQ3pCQyxNQUFNLEVBQUMsaUJBQWlCO0lBQ3hCQyxlQUFlLEVBQUM7RUFBTSxHQUNuQkosZUFBZTtJQUNsQkssUUFBUSxFQUFDLFVBQVU7SUFDbkJDLFNBQVMsRUFBQyxZQUFZO0lBQ3RCQyxNQUFNLEVBQUMsTUFBTTtJQUNiQyxLQUFLLEVBQUM7RUFBTSxHQUNkO0VBQ0YsSUFBTUMsY0FBYyxHQUFHLGtCQUFNO0lBQ3pCSixRQUFRLEVBQUMsVUFBVTtJQUNuQkssR0FBRyxFQUFDLENBQUM7SUFDTEMsSUFBSSxFQUFDLENBQUM7SUFDTkMsT0FBTyxFQUFDLEtBQUs7SUFDYkMsT0FBTyxFQUFDLEVBQUU7SUFDVkMsWUFBWSxFQUFDLEtBQUs7SUFDbEJWLGVBQWUsRUFBQyxPQUFPO0lBQ3ZCVyxNQUFNLEVBQUMsS0FBSztJQUNaQyxRQUFRLEVBQUM7RUFBUyxHQUNmZixlQUFlLEVBQ3BCO0VBRUZILE9BQU8sR0FBR0EsT0FBTyxhQUFQQSxPQUFPLGNBQVBBLE9BQU8sR0FBSSxjQUFjO0VBRW5DLE9BQU9tQjtJQUFBLGFBQWlCLGtCQUFrQjtJQUFDQyxLQUFLLEVBQUloQixjQUFjLENBQUNpQjtFQUFPLEdBQ3BFLENBQUNwQixLQUFLLEdBQ0prQjtJQUFBLGFBQWlCLGtCQUFrQjtJQUFDQyxLQUFLLEVBQUtULGNBQWMsQ0FBQ1U7RUFBTyxHQUFJdkIsS0FBSyxHQUFHLENBQUMsT0FBR0MsUUFBUSxPQUFHQyxPQUFPLENBQU8sR0FDN0dtQjtJQUFBLGFBQWlCLGtCQUFrQjtJQUFDQyxLQUFLLEVBQUtULGNBQWMsQ0FBQ1U7RUFBTyw4QkFBMkJwQixLQUFLLENBQUNELE9BQU8sTUFBUSxDQUd0SDtBQUNWLENBQUM7QUFFRHNCLGtCQUFBQSxHQUFlekIsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB0aGUgZGVmYXVsdCBQbGFjZUhvbGRlciBpcyB0byBob2xkIHRoZSBjb250ZW50IGRpc3BsYXkgdW50aWwgdGhlIGhvc3QgY29udGVudFxuICAgIGlzIHJlY2VpdmVkLiBUaGUgcGxhY2Vob2xkZXIgcHJlc2VudHMgYSB3YWl0aW5nIG1lc3NhZ2UsIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGxvYWRcbiAgICBvZiB0aGUgaG9zdCBjb250ZW50IGZhaWxlZC5cblxuICAgIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNhbiBiZSByZXBsYWNlZCBieSBhIHBsYWNlaG9sZGVyIHByb3ZpZGVkIGJ5IHRoZSBob3N0LlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFBsYWNlaG9sZGVyID0gKHtpbmRleCwgbGlzdHNpemUsIG1lc3NhZ2UsIGVycm9yLCB1c2VyRnJhbWVTdHlsZXMsIHVzZXJMaW5lclN0eWxlc30pID0+IHtcblxuICAgIGNvbnN0IGZyYW1lU3R5bGVzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgYm9yZGVyOicycHggc29saWQgYmxhY2snLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J2N5YW4nLFxuICAgICAgICAuLi51c2VyRnJhbWVTdHlsZXMsXG4gICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZScsXG4gICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgIHdpZHRoOicxMDAlJyxcbiAgICB9KVxuICAgIGNvbnN0IGxpbmVyU3R5bGVzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgdG9wOjAsXG4gICAgICAgIGxlZnQ6MCxcbiAgICAgICAgcGFkZGluZzonM3B4JyxcbiAgICAgICAgb3BhY2l0eTouNSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOic4cHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J3doaXRlJywgXG4gICAgICAgIG1hcmdpbjonM3B4JyxcbiAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICAuLi51c2VyTGluZXJTdHlsZXMsXG4gICAgfSlcblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlID8/ICcobG9hZGluZy4uLiknXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAncGxhY2Vob2xkZXJmcmFtZScgc3R5bGUgPSB7ZnJhbWVTdHlsZXNSZWYuY3VycmVudH0+XG4gICAgICAgIHsgIWVycm9yP1xuICAgICAgICAgICAgPGRpdiBkYXRhLXR5cGUgPSAncGxhY2Vob2xkZXJsaW5lcicgc3R5bGUgPSB7IGxpbmVyU3R5bGVzUmVmLmN1cnJlbnQgfT57aW5kZXggKyAxfS97bGlzdHNpemV9IHttZXNzYWdlfTwvZGl2PjpcbiAgICAgICAgICAgIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVybGluZXInIHN0eWxlID0geyBsaW5lclN0eWxlc1JlZi5jdXJyZW50IH0+aXRlbSBpcyBub3QgYXZhaWxhYmxlICh7ZXJyb3IubWVzc2FnZX0pPC9kaXY+XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgPC9kaXY+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYWNlaG9sZGVyIl0sIm5hbWVzIjpbIlBsYWNlaG9sZGVyIiwiaW5kZXgiLCJsaXN0c2l6ZSIsIm1lc3NhZ2UiLCJlcnJvciIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJMaW5lclN0eWxlcyIsImZyYW1lU3R5bGVzUmVmIiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwicG9zaXRpb24iLCJib3hTaXppbmciLCJoZWlnaHQiLCJ3aWR0aCIsImxpbmVyU3R5bGVzUmVmIiwidG9wIiwibGVmdCIsInBhZGRpbmciLCJvcGFjaXR5IiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luIiwiZm9udFNpemUiLCJyZWFjdF8xIiwic3R5bGUiLCJjdXJyZW50IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// scrolltracker.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n    left = _ref.left,\n    offset = _ref.offset,\n    listsize = _ref.listsize,\n    styles = _ref.styles;\n  var trackdata = "".concat(offset + 1, "/").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFPQTtBQUVBLElBQU1BLGFBQWEsR0FBRyxTQUFoQkEsYUFBYSxPQUErQztFQUFBLElBQXpDQyxHQUFHLFFBQUhBLEdBQUc7SUFBRUMsSUFBSSxRQUFKQSxJQUFJO0lBQUVDLE1BQU0sUUFBTkEsTUFBTTtJQUFFQyxRQUFRLFFBQVJBLFFBQVE7SUFBRUMsTUFBTSxRQUFOQSxNQUFNO0VBRXhELElBQUlDLFNBQVMsYUFBTUgsTUFBTSxHQUFHLENBQUMsY0FBSUMsUUFBUSxDQUFFO0VBRTNDLElBQUlHLFFBQVEsR0FBRyxrQkFBTTtJQUNqQk4sR0FBRyxFQUFFQSxHQUFHLEdBQUcsSUFBSTtJQUNmQyxJQUFJLEVBQUVBLElBQUksR0FBRyxJQUFJO0lBQ2pCTSxRQUFRLEVBQUMsT0FBTztJQUNoQkMsTUFBTSxFQUFDLENBQUM7SUFDUkMsZUFBZSxFQUFDLE9BQU87SUFDdkJDLE1BQU0sRUFBRSxnQkFBZ0I7SUFDeEJDLFlBQVksRUFBQyxNQUFNO0lBQ25CQyxRQUFRLEVBQUMsU0FBUztJQUNsQkMsT0FBTyxFQUFDO0VBQUssR0FDVlQsTUFBTSxDQUFDVSxhQUFhLEVBQ3pCO0VBRUYsT0FBT0M7SUFBQSxhQUFpQixlQUFlO0lBQUNDLEtBQUssRUFBSVYsUUFBUSxDQUFDVztFQUFPLEdBQUlaLFNBQVMsQ0FBTztBQUN6RixDQUFDO0FBRURhLGtCQUFBQSxHQUFlbkIsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4PzBiM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2Nyb2xsdHJhY2tlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2YgU2Nyb2xsVHJhY2tlciBpcyB0byBwcm92aWRlIGZlZWRiYWNrIHRvIHRoZSB1c2VyIG9mIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGVcbiAgICB2aXJ0dWFsIGxpc3QgZHVyaW5nIHJlcG9zaXRpb25nLlxuXG4gICAgU2Nyb2xsVHJhY2tlciBjYW4gYmUgc3VwcHJlc3NlZCBieSB0aGUgaG9zdCAoaW4gZmF2b3VyIG9mIHRoZSBob3N0J3Mgb3duIGxvY2F0aW9uIGZlZWRiYWNrKVxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmfSBmcm9tICdyZWFjdCdcblxuY29uc3QgU2Nyb2xsVHJhY2tlciA9ICh7IHRvcCwgbGVmdCwgb2Zmc2V0LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGxldCB0cmFja2RhdGEgPSBgJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfWBcblxuICAgIGxldCBzdHlsZVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgbGVmdDogbGVmdCArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOidmaXhlZCcsXG4gICAgICAgIHpJbmRleDozLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J3doaXRlJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGdyYXknLFxuICAgICAgICBib3JkZXJSYWRpdXM6JzEwcHgnLFxuICAgICAgICBmb250U2l6ZTonc21hbGxlcicsXG4gICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgIC4uLnN0eWxlcy5zY3JvbGx0cmFja2VyXG4gICAgfSlcblxuICAgIHJldHVybiA8ZGl2IGRhdGEtbmFtZSA9ICdzY3JvbGx0cmFja2VyJyBzdHlsZSA9IHtzdHlsZVJlZi5jdXJyZW50fSA+e3RyYWNrZGF0YX08L2Rpdj5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsVHJhY2tlciJdLCJuYW1lcyI6WyJTY3JvbGxUcmFja2VyIiwidG9wIiwibGVmdCIsIm9mZnNldCIsImxpc3RzaXplIiwic3R5bGVzIiwidHJhY2tkYXRhIiwic3R5bGVSZWYiLCJwb3NpdGlvbiIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsImZvbnRTaXplIiwicGFkZGluZyIsInNjcm9sbHRyYWNrZXIiLCJyZWFjdF8xIiwic3R5bGUiLCJjdXJyZW50IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/cachehandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// cachehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PortalList = exports.CacheHandler = void 0;\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user functionsCallback callback for details. Note that overly large caches of complex components\n    can impair performance. This can be optimized with the cacheMax property.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden portal cache\n    for each InfiniteGridScroller root, from whence the components are pulled into the relevant CellFrames\n    for display. The user components are stored in React portals, with each portal instantiated in\n    a container div (\'portalwrapper\'). These container divs are included in a standard React component\n    list in the real DOM. The contained portals themselves are not part of the real DOM, but are part of\n    React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle without losing state, and the ability to maintain state for\n    complex components which move beyond the scope of the content of the Cradle. But there is an\n    important side effect.\n\n    Instantiated components which are removed from the real DOM (into the portal of the virtual DOM)\n    have their scroll positions, width, and height set to zero. Therefore if components rely on these\n    values for configuration, they must have a way of storing values in state (notably the\n    Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing isReparentingRef and scrollerPropertiesRef\n        - isReparentingRef.current provides an up-to-date boolean indicating whether the component is\n            currently being \'reparented\' into the real DOM. Set the value back to false once you\'ve\n            detected it. After reparenting (after the width and height are back to normal) is when\n            you should restore scrollPos (scrollTop or scrollLeft) to what it was.\n        - if your component does not scroll, there should be no issues.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\nvar globalItemID = 0;\n// global scroller data, organized by session scrollerID\n// the cache itself is maintained in the root infinitegridscroller component\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, setListsize, listsizeRef) {\n    var _this = this;\n    _classCallCheck(this, CacheHandler);\n    this.cacheProps = {\n      setListState: null,\n      modified: false,\n      metadataMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      portalMap: new Map(),\n      indexToItemIDMap: new Map(),\n      portalList: null,\n      scrollerID: null\n    };\n    //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n    this.changeListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      _this.setListsize(newlistsize);\n      // match cache to newlistsize\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n    this.clearCache = function () {\n      // keep the setListState callback\n      _this.cacheProps.portalMap.clear();\n      _this.cacheProps.metadataMap.clear();\n      _this.cacheProps.indexToItemIDMap.clear();\n      _this.cacheProps.requestedSet.clear();\n      _this.cacheProps.portalList = null;\n      _this.cacheProps.modified = true;\n      _this.renderPortalList(); // trigger display update\n    };\n    // set state of the PortalList component of the scroller to trigger render\n    this.renderPortalList = function () {\n      if (_this.cacheProps.modified) {\n        _this.cacheProps.portalList = Array.from(_this.cacheProps.portalMap.values());\n        _this.cacheProps.modified = false;\n      }\n      _this.cacheProps.setListState(); // trigger display update\n    };\n    // ----------------------[ cache size limit enforceent ]------------------\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      var modelLength = cradleIndexList.length;\n      // determine need for paring\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexList = _this.cacheProps.indexToItemIDMap,\n        requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexList.size + requestedSet.size <= max) return false;\n      // sort the map keys\n      var mapkeyslist = Array.from(portalIndexList.keys()),\n        requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      });\n      // get number to pare\n      var mapLength = mapkeys.length,\n        parecount = mapLength - max;\n      // distribute paring proportionally at front and back\n      var headindex = cradleIndexList[0],\n        tailindex = cradleIndexList[modelLength - 1],\n        headpos = mapkeys.indexOf(headindex),\n        tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos,\n        tailroom = mapLength - (tailpos + 1),\n        pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount),\n        tailparecount = parecount - headparecount;\n      // collect indexes to pare\n      var headlist = mapkeys.slice(0, headparecount),\n        taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n      _this.deletePortal(delList, deleteListCallback);\n      return true;\n    };\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var _this$cacheProps = _this.cacheProps,\n        portalMap = _this$cacheProps.portalMap,\n        requestedSet = _this$cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n      if (portalMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n    this.cacheProps.scrollerID = scrollerID;\n    this.setListsize = setListsize; // passed from infinitegridscroller setListsize(listsize)\n    this.listsizeRef = listsizeRef;\n  }\n  // --------------------------------[ preload ]--------------------------------\n  _createClass(CacheHandler, [{\n    key: "preload",\n    value: function preload(finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n      var cradleParameters = this.cradleParameters;\n      var scrollerPropertiesRef = cradleParameters.scrollerPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n        stateHandler = _cradleParameters$han.stateHandler,\n        serviceHandler = _cradleParameters$han.serviceHandler,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n        cacheMax = cradleInheritedProperties.cacheMax,\n        listsize = cradleInternalProperties.listsize;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      };\n      // serviceHandler.callbacks.preloadIndexCallback\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n          preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n          itemExceptionCallback = _serviceHandler$callb.itemExceptionCallback;\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n          if (!indexToItemIDMap.has(index)) {\n            var promise = this.preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n          if (breakloop.current) break;\n        }\n      }\n      Promise.allSettled(promises).then(function () {\n        _this2.cacheProps.modified = true;\n        _this2.renderPortalList();\n        finalCallback();\n      });\n    }\n    // =========================[ SNAPSHOTS ]=========================\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map(),\n        indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var _iterator = _createForOfIteratorHelper(cradleIndexList),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n      var _iterator2 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            key = _step2$value[0],\n            value = _step2$value[1];\n          var index = value.index,\n            component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return cachelist;\n    }\n    // ==========================[ SERVICE SUPPORT ]=========================\n    // move is coerced by servicehandler to be within current list bounds\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(toindex, fromindex, fromhighindex) {\n      var _this$cacheProps2 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n        metadataMap = _this$cacheProps2.metadataMap;\n      // ----------- define parameters ---------------\n      var rangeabsoluteincrement = fromhighindex - fromindex + 1,\n        movedirectionalincrement = toindex - fromindex,\n        tohighindex = toindex + (rangeabsoluteincrement - 1);\n      var shiftdirection = movedirectionalincrement > 0 ?\n      // move up in list\n      -1 :\n      // shift down, make room for shiftingindex above\n      1; // shift up, make room for shiftingindex below\n      var orderedindexlist = Array.from(indexToItemIDMap.keys());\n      orderedindexlist.sort(function (a, b) {\n        return a - b;\n      });\n      var toindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= toindex;\n        }),\n        tohighindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= tohighindex;\n        }),\n        fromindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromindex;\n        }),\n        fromhighindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromhighindex;\n        });\n      // ---------------- capture index data to move ----------------\n      var processtomoveList;\n      if (fromindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        processtomoveList = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        processtomoveList = orderedindexlist.slice(fromindexptr);\n      } else {\n        // scope is entirely in view\n        processtomoveList = orderedindexlist.slice(fromindexptr, fromhighindexptr + 1);\n      }\n      var processtomoveMap = new Map();\n      var capturemoveindex = function capturemoveindex(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n      processtomoveList.forEach(capturemoveindex);\n      // ------------- get list of indexes to shift out of the way ---------------\n      var processtoshiftList;\n      if (shiftdirection == 1) {\n        // block is moving down, shift is up; toindex < fromindex\n        if (toindexptr == -1 && fromindexptr == -1) {\n          processtoshiftList = [];\n        } else if (fromindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(toindexptr);\n        } else {\n          processtoshiftList = orderedindexlist.slice(toindexptr, fromindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          processtoshiftList = [];\n        } else if (tohighindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n      if (shiftdirection == 1) processtoshiftList.reverse();\n      // -------------- move indexes out of the way --------------\n      var processedshiftList = [];\n      var processshiftindex = function processshiftindex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = shiftdirection == -1 ? index - rangeabsoluteincrement : index + rangeabsoluteincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedshiftList.push(newIndex);\n      };\n      processtoshiftList.forEach(processshiftindex);\n      // ------------ replace shifted index space with moved indexes ----------\n      var processedmoveList = [];\n      var processmoveindex = function processmoveindex(itemID, index) {\n        var newIndex = index + movedirectionalincrement; // swap\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n      processtomoveMap.forEach(processmoveindex);\n      // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n      var processedIndexes = [].concat(processedshiftList, processedmoveList);\n      return processedIndexes;\n    }\n    // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      var _this$cacheProps3 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps3.indexToItemIDMap,\n        metadataMap = _this$cacheProps3.metadataMap,\n        portalMap = _this$cacheProps3.portalMap;\n      // ---------- define range parameters ---------------\n      // high range is the highest index number of the insert/remove operation\n      var highrangeindex = highrange !== null && highrange !== void 0 ? highrange : 0;\n      highrangeindex = highrangeindex > index ? highrangeindex : index;\n      var emptyreturn = [[], [], 0];\n      if (increment == -1) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) return emptyreturn;\n      } else {\n        // addition can at most start at the next index above the current list\n        if (index > listsize) return emptyreturn;\n      }\n      // rangecount is the absolute number in the insert/remove range - contiguous\n      var rangecount = highrangeindex - index + 1;\n      // range increment adds sign to rangecount to indicate add/remove\n      var rangeincrement = rangecount * increment;\n      // highPtr, lowPtr, shrinktoPtr within orderedIndexList.\n      var orderedIndexList = Array.from(indexToItemIDMap.keys());\n      orderedIndexList.sort(function (a, b) {\n        return a - b;\n      });\n      // ---------- define boundaries within ordered cache index list ------------\n      // Ptr = index into array, as opposed to index of virtual list\n      // shrinkptr is the location of the bottom of the shrink range for removals\n      var shrinktoIndex = null;\n      var shrinktoPtr = -1;\n      if (increment == -1) {\n        shrinktoIndex = orderedIndexList.at(-1) + rangeincrement;\n        shrinktoIndex = Math.max(highrangeindex + rangeincrement, shrinktoIndex);\n        shrinktoIndex = Math.min(listsize - 1, shrinktoIndex);\n        shrinktoPtr = orderedIndexList.findIndex(function (value) {\n          return value >= shrinktoIndex;\n        });\n      }\n      // lowPtr and highPtr must be within low and high range\n      var lowPtr = orderedIndexList.findIndex(function (value) {\n        return value >= index && value <= highrangeindex;\n      });\n      var reverseIndexList = Array.from(orderedIndexList);\n      reverseIndexList.reverse();\n      var highPtr = reverseIndexList.findIndex(function (value) {\n        return value <= highrangeindex;\n      });\n      if (highPtr != -1) {\n        highPtr = orderedIndexList.length - 1 - highPtr;\n        if (highPtr < lowPtr) highPtr = -1;\n      }\n      // ----------- list indexes to process, replace, and remove, and items to remove --------\n      var indexesToProcessList,\n        // for either insert or remove\n        indexesToReplaceList = [],\n        // for insert the range being inserted\n        indexesToRemoveList = [],\n        // for remove - end of list; the list is shrinking\n        indexesOfItemsToRemoveList = [],\n        // for remove - within the range of indexes being removed\n        itemsToRemoveList = []; // for remove, derived from the previous\n      // get indexesToProcessList\n      if (lowPtr == -1 && highPtr == -1) {\n        // core scope is out of view\n        indexesToProcessList = [];\n      } else {\n        // core scope is partially or fully in view; lowPtr is available\n        if (increment == 1) {\n          indexesToProcessList = orderedIndexList.slice(lowPtr);\n        } else if (highPtr == -1) {\n          // increment == -1; lowPtr is available\n          indexesToProcessList = [];\n        } else {\n          // increment == -1; lowPtr and highPtr are available\n          indexesToProcessList = orderedIndexList.slice(highPtr + 1);\n        }\n      }\n      var portalHoldList = []; // hold portals for deletion until after after cradle synch\n      if (increment == 1) {\n        // get indexesToReplaceList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesToReplaceList = [];\n        } else if (highPtr == -1) {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n      } else {\n        // get indexesToRemoveList\n        if (shrinktoPtr == -1) {\n          // core scope is out of view\n          indexesToRemoveList = [];\n        } else {\n          indexesToRemoveList = orderedIndexList.slice(shrinktoPtr + 1);\n        }\n        // get indexesOfItemsToRemoveList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesOfItemsToRemoveList = [];\n        } else if (highPtr == -1) {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n        // get itemsToRemoveList\n        var _iterator3 = _createForOfIteratorHelper(indexesOfItemsToRemoveList),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _index = _step3.value;\n            itemsToRemoveList.push(indexToItemIDMap.get(_index));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      // ----------- conduct cache operations ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n      if (increment == 1) indexesToProcessList.reverse();\n      var indexesModifiedList = [];\n      // modify index-to-itemid map, and metadata map\n      var processIndex = function processIndex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        indexesModifiedList.push(newIndex);\n      };\n      indexesToProcessList.forEach(processIndex);\n      // delete remaining indexes and items now duplicates\n      if (increment == 1) {\n        var _iterator4 = _createForOfIteratorHelper(indexesToReplaceList),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index2 = _step4.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(indexesToRemoveList),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index3 = _step5.value;\n            indexToItemIDMap["delete"](_index3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var _iterator6 = _createForOfIteratorHelper(itemsToRemoveList),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var itemID = _step6.value;\n            metadataMap["delete"](itemID);\n            portalHoldList.push(itemID);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n      // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n      return [indexesModifiedList, indexesToReplaceList, rangeincrement, portalHoldList];\n    }\n    // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n  }, {\n    key: "registerRequestedPortal",\n    value: function registerRequestedPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: "removeRequestedPortal",\n    value: function removeRequestedPortal(index) {\n      this.cacheProps.requestedSet["delete"](index);\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return globalItemID++;\n    }\n    // get new or existing itemID for contentfunctions.createCellFrame\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    }\n    // create new portal\n  }, {\n    key: "createPortal",\n    value: function createPortal(component, index, itemID) {\n      var isPreload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.removeRequestedPortal(index);\n      var _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current,\n        layout = _this$cradleParameter.layout,\n        cellHeight = _this$cradleParameter.cellHeight,\n        cellWidth = _this$cradleParameter.cellWidth,\n        orientation = _this$cradleParameter.orientation;\n      var portalNode = createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth);\n      // div wrapper to avoid memory leak\n      this.cacheProps.portalMap.set(itemID, react_1["default"].createElement("div", {\n        "data-type": \'portalwrapper\',\n        key: itemID,\n        "data-itemid": itemID,\n        "data-index": index\n      }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n        key: itemID,\n        node: portalNode\n      }, " ", component, " ")));\n      this.cacheProps.modified = true;\n      var portalMetadata = {\n        portalNode: portalNode,\n        isReparentingRef: {\n          current: false\n        },\n        index: index,\n        itemID: itemID,\n        component: component\n      };\n      this.cacheProps.metadataMap.set(itemID, portalMetadata);\n      this.cacheProps.indexToItemIDMap.set(index, itemID);\n      if (!isPreload) this.renderPortalList();\n      return portalMetadata;\n    }\n    // used for preloading new item\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties, portalData;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                itemID = this.getNewItemID();\n                _context.prev = 1;\n                _context.next = 4;\n                return getItem(index, itemID);\n              case 4:\n                usercontent = _context.sent;\n                if (usercontent === null) returnvalue = usercontent;\n                _context.next = 12;\n                break;\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context["catch"](1);\n                returnvalue = usercontent = undefined;\n                error = _context.t0;\n              case 12:\n                if (usercontent !== null && usercontent !== undefined) {\n                  if (!react_1["default"].isValidElement(usercontent)) {\n                    returnvalue = usercontent;\n                    usercontent = undefined;\n                    error = new Error(\'invalid React element\');\n                  }\n                }\n                if (usercontent !== null && usercontent !== undefined) {\n                  scrollerProperties = {\n                    isReparentingRef: null,\n                    scrollerPropertiesRef: scrollerPropertiesRef\n                  };\n                  if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                    content = react_1["default"].cloneElement(usercontent, {\n                      scrollerProperties: scrollerProperties\n                    });\n                  } else {\n                    content = usercontent;\n                  }\n                  portalData = this.createPortal(content, index, itemID, true); // true = isPreload\n                  // make available to user content\n                  scrollerProperties.isReparentingRef = portalData.isReparentingRef;\n                } else {\n                  if (usercontent === undefined) {\n                    itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', error);\n                  } else {\n                    // usercontent === null; last item in list\n                    itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                    maxListsizeInterrupt(index);\n                  }\n                }\n              case 14:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 8]]);\n      }));\n    }\n    // delete a portal list item\n    // accepts an array of indexes\n  }, {\n    key: "deletePortal",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps4 = this.cacheProps,\n        metadataMap = _this$cacheProps4.metadataMap,\n        portalMap = _this$cacheProps4.portalMap,\n        indexToItemIDMap = _this$cacheProps4.indexToItemIDMap;\n      var deleteList = [];\n      var _iterator7 = _createForOfIteratorHelper(indexArray),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n          var itemID = indexToItemIDMap.get(i);\n          deleteList.push({\n            index: i,\n            itemID: itemID\n          });\n          metadataMap["delete"](itemID);\n          portalMap["delete"](itemID);\n          indexToItemIDMap["delete"](i);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      this.cacheProps.modified = true;\n      deleteListCallback && deleteListCallback(deleteList);\n    }\n    // query existence of a portal list item\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortal",\n    value: function getPortal(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n  return CacheHandler;\n}();\nexports.CacheHandler = CacheHandler;\n// ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n// see also some styles set in CellFrame\nvar createPortalNode = function createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n};\n// ========================[ Utility component ]==============================\n// portal list component for rapid relisting of updates, using external callback for set state\nvar PortalList = function PortalList(_ref) {\n  var cacheProps = _ref.cacheProps;\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalListCounter = _ref3[0],\n    setPortalListCounter = _ref3[1];\n  var counterRef = (0, react_1.useRef)(null);\n  counterRef.current = portalListCounter;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    cacheProps.setListState = function () {\n      portalArrayRef.current = cacheProps.portalList;\n      isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n    };\n\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return portalArrayRef.current;\n};\nexports.PortalList = PortalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NhY2hlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUE7QUFBQSwrQ0FEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7QUFFQTtBQUVBLElBQUlBLFlBQVksR0FBRyxDQUFDO0FBRXBCO0FBQ0E7QUFBQSxJQUNhQyxZQUFZO0VBRXJCLHNCQUFZQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsV0FBVztJQUFBO0lBQUE7SUFNaEQsZUFBVSxHQUFHO01BQ1RDLFlBQVksRUFBQyxJQUFJO01BQ2pCQyxRQUFRLEVBQUMsS0FBSztNQUVkQyxXQUFXLEVBQUMsSUFBSUMsR0FBRyxFQUFFO01BQ3JCO01BQ0FDLFlBQVksRUFBQyxJQUFJQyxHQUFHLEVBQUU7TUFDdEJDLFNBQVMsRUFBQyxJQUFJSCxHQUFHLEVBQUU7TUFDbkJJLGdCQUFnQixFQUFDLElBQUlKLEdBQUcsRUFBRTtNQUUxQkssVUFBVSxFQUFDLElBQUk7TUFFZlgsVUFBVSxFQUFDO0tBQ2Q7SUFZRDtJQUVBO0lBRUEsbUJBQWMsR0FBRyxVQUFDWSxXQUFXLEVBQUVDLGtCQUFrQixFQUFFQyxzQkFBc0IsRUFBSTtNQUV6RSxLQUFJLENBQUNiLFdBQVcsQ0FBQ1csV0FBVyxDQUFDO01BRTdCO01BQ0EsSUFBTUcsY0FBYyxHQUFHLEtBQUksQ0FBQ0MsVUFBVSxDQUFDTixnQkFBZ0I7TUFDdkQsSUFBTU8sV0FBVyxHQUFHQyxLQUFLLENBQUNDLElBQUksQ0FBQ0osY0FBYyxDQUFDSyxJQUFJLEVBQUUsQ0FBQztNQUNyREgsV0FBVyxDQUFDSSxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBS0QsQ0FBQyxHQUFHQyxDQUFDO01BQUEsRUFBQztNQUVoQyxJQUFNQyxZQUFZLEdBQUdQLFdBQVcsQ0FBQ1EsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BRXZDLElBQUlELFlBQVksR0FBSVosV0FBVyxHQUFFLENBQUUsRUFBRTtRQUFFO1FBRW5DLElBQU1jLFFBQVEsR0FBR1QsV0FBVyxDQUFDVSxNQUFNLENBQUMsVUFBQ0MsS0FBSyxFQUFHO1VBQ3pDLE9BQU9BLEtBQUssR0FBSWhCLFdBQVcsR0FBRSxDQUFFO1FBQ25DLENBQUMsQ0FBQztRQUVGLEtBQUksQ0FBQ2lCLFlBQVksQ0FBQ0gsUUFBUSxFQUFFYixrQkFBa0IsQ0FBQzs7TUFJbkRDLHNCQUFzQixJQUFJQSxzQkFBc0IsQ0FBQ0YsV0FBVyxDQUFDO0lBRWpFLENBQUM7SUFFRCxlQUFVLEdBQUcsWUFBSztNQUVkO01BQ0EsS0FBSSxDQUFDSSxVQUFVLENBQUNQLFNBQVMsQ0FBQ3FCLEtBQUssRUFBRTtNQUNqQyxLQUFJLENBQUNkLFVBQVUsQ0FBQ1gsV0FBVyxDQUFDeUIsS0FBSyxFQUFFO01BQ25DLEtBQUksQ0FBQ2QsVUFBVSxDQUFDTixnQkFBZ0IsQ0FBQ29CLEtBQUssRUFBRTtNQUN4QyxLQUFJLENBQUNkLFVBQVUsQ0FBQ1QsWUFBWSxDQUFDdUIsS0FBSyxFQUFFO01BQ3BDLEtBQUksQ0FBQ2QsVUFBVSxDQUFDTCxVQUFVLEdBQUcsSUFBSTtNQUNqQyxLQUFJLENBQUNLLFVBQVUsQ0FBQ1osUUFBUSxHQUFHLElBQUk7TUFFL0IsS0FBSSxDQUFDMkIsZ0JBQWdCLEVBQUUsRUFBQztJQUU1QixDQUFDO0lBRUQ7SUFDQSxxQkFBZ0IsR0FBRyxZQUFLO01BRXBCLElBQUksS0FBSSxDQUFDZixVQUFVLENBQUNaLFFBQVEsRUFBRTtRQUMxQixLQUFJLENBQUNZLFVBQVUsQ0FBQ0wsVUFBVSxHQUFHTyxLQUFLLENBQUNDLElBQUksQ0FBQyxLQUFJLENBQUNILFVBQVUsQ0FBQ1AsU0FBUyxDQUFDdUIsTUFBTSxFQUFFLENBQUM7UUFDM0UsS0FBSSxDQUFDaEIsVUFBVSxDQUFDWixRQUFRLEdBQUcsS0FBSzs7TUFHcEMsS0FBSSxDQUFDWSxVQUFVLENBQUNiLFlBQVksRUFBRSxFQUFDO0lBRW5DLENBQUM7SUFFRDtJQUVBLHVCQUFrQixHQUFHLFVBQUM4QixlQUFlLEVBQUVwQixrQkFBa0IsRUFBSTtNQUV6RCxJQUFNcUIsT0FBTyxHQUFHaEIsS0FBSyxDQUFDQyxJQUFJLENBQUMsS0FBSSxDQUFDSCxVQUFVLENBQUNOLGdCQUFnQixDQUFDVSxJQUFJLEVBQUUsQ0FBQztNQUVuRSxJQUFNZSxPQUFPLEdBQUdELE9BQU8sQ0FBQ1AsTUFBTSxDQUFDLGFBQUc7UUFBQSxPQUFJLENBQUNNLGVBQWUsQ0FBQ0csUUFBUSxDQUFDQyxHQUFHLENBQUM7TUFBQSxFQUFDO01BRXJFLElBQUlGLE9BQU8sQ0FBQ0csTUFBTSxFQUFFO1FBRWhCLEtBQUksQ0FBQ1QsWUFBWSxDQUFDTSxPQUFPLEVBQUV0QixrQkFBa0IsQ0FBQztRQUM5QyxPQUFPLElBQUk7T0FFZCxNQUFNO1FBRUgsT0FBTyxLQUFLOztJQUlwQixDQUFDO0lBRUQsbUJBQWMsR0FBRyxVQUFDMEIsUUFBUSxFQUFFTixlQUFlLEVBQUVwQixrQkFBa0IsRUFBNEI7TUFBQSxJQUExQmIsVUFBVSx1RUFBR3dDLFNBQVM7TUFFbkYsSUFBTUMsV0FBVyxHQUFHUixlQUFlLENBQUNLLE1BQU07TUFFMUM7TUFDQSxJQUFLLENBQUNDLFFBQVEsSUFBTSxDQUFDRSxXQUFZLEVBQUUsT0FBTyxLQUFLO01BRS9DLElBQU1DLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQUNELFdBQVcsRUFBRUYsUUFBUSxDQUFDO01BRTNDLElBQU1LLGVBQWUsR0FBRyxLQUFJLENBQUM1QixVQUFVLENBQUNOLGdCQUFnQjtRQUNwREgsWUFBWSxHQUFHLEtBQUksQ0FBQ1MsVUFBVSxDQUFDVCxZQUFZO01BRS9DLElBQUtxQyxlQUFlLENBQUNDLElBQUksR0FBR3RDLFlBQVksQ0FBQ3NDLElBQUksSUFBS0gsR0FBRyxFQUFFLE9BQU8sS0FBSztNQUVuRTtNQUNBLElBQU1JLFdBQVcsR0FBRzVCLEtBQUssQ0FBQ0MsSUFBSSxDQUFDeUIsZUFBZSxDQUFDeEIsSUFBSSxFQUFFLENBQUM7UUFDbEQyQixhQUFhLEdBQUc3QixLQUFLLENBQUNDLElBQUksQ0FBQ1osWUFBWSxDQUFDYSxJQUFJLEVBQUUsQ0FBQztNQUVuRCxJQUFNYyxPQUFPLGFBQU9ZLFdBQVcsRUFBSUMsYUFBYSxDQUFDO01BRWpEYixPQUFPLENBQUNiLElBQUksQ0FBQyxVQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBQSxPQUFLRCxDQUFDLEdBQUdDLENBQUM7TUFBQSxFQUFDO01BRTVCO01BQ0EsSUFBTXlCLFNBQVMsR0FBR2QsT0FBTyxDQUFDSSxNQUFNO1FBQzVCVyxTQUFTLEdBQUdELFNBQVMsR0FBR04sR0FBRztNQUUvQjtNQUNBLElBQU1RLFNBQVMsR0FBR2pCLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDaENrQixTQUFTLEdBQUdsQixlQUFlLENBQUNRLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDNUNXLE9BQU8sR0FBR2xCLE9BQU8sQ0FBQ21CLE9BQU8sQ0FBQ0gsU0FBUyxDQUFDO1FBQ3BDSSxPQUFPLEdBQUdwQixPQUFPLENBQUNtQixPQUFPLENBQUNGLFNBQVMsQ0FBQztNQUV4QyxJQUFNSSxRQUFRLEdBQUdILE9BQU87UUFDcEJJLFFBQVEsR0FBR1IsU0FBUyxJQUFJTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDRyxRQUFRLEdBQUdGLFFBQVEsR0FBR0MsUUFBUTtNQUVsQyxJQUFNRSxhQUFhLEdBQUdmLElBQUksQ0FBQ2dCLEtBQUssQ0FBRUosUUFBUSxHQUFDRSxRQUFRLEdBQUVSLFNBQVMsQ0FBQztRQUMzRFcsYUFBYSxHQUFHWCxTQUFTLEdBQUdTLGFBQWE7TUFFN0M7TUFDQSxJQUFNRyxRQUFRLEdBQUczQixPQUFPLENBQUM0QixLQUFLLENBQUMsQ0FBQyxFQUFDSixhQUFhLENBQUM7UUFDM0NLLFFBQVEsR0FBRzdCLE9BQU8sQ0FBQzRCLEtBQUssQ0FBQ2QsU0FBUyxHQUFHWSxhQUFhLENBQUM7TUFFdkQsSUFBTUksT0FBTyxnQ0FBT0gsUUFBUSxzQkFBSUUsUUFBUSxFQUFDO01BRXpDLEtBQUksQ0FBQ2xDLFlBQVksQ0FBQ21DLE9BQU8sRUFBRW5ELGtCQUFrQixDQUFDO01BRTlDLE9BQU8sSUFBSTtJQUVmLENBQUM7SUFFRCwrQkFBMEIsR0FBRyxVQUFDMEIsUUFBUSxFQUFFMEIsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFJO01BRTVFLElBQUksQ0FBQzNCLFFBQVEsRUFBRSxPQUFPLEtBQUs7TUFFM0IsdUJBR0ksS0FBSSxDQUFDdkIsVUFBVTtRQUZmUCxTQUFTLG9CQUFUQSxTQUFTO1FBQ1RGLFlBQVksb0JBQVpBLFlBQVk7TUFHaEIsSUFBTW1DLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQUN1QixnQkFBZ0IsRUFBRTFCLFFBQVEsQ0FBQztNQUVoRCxJQUFLOUIsU0FBUyxDQUFDb0MsSUFBSSxHQUFHdEMsWUFBWSxDQUFDc0MsSUFBSSxJQUFPSCxHQUFHLEdBQUl3QixrQkFBbUIsRUFBRTtRQUV0RSxPQUFPLEtBQUs7T0FFZixNQUFNO1FBRUgsT0FBTyxJQUFJOztJQUluQixDQUFDO0lBbExHLElBQUksQ0FBQ2xELFVBQVUsQ0FBQ2hCLFVBQVUsR0FBR0EsVUFBVTtJQUN2QyxJQUFJLENBQUNDLFdBQVcsR0FBR0EsV0FBVyxFQUFDO0lBQy9CLElBQUksQ0FBQ0MsV0FBVyxHQUFHQSxXQUFXO0VBQ2xDO0VBaUxBO0VBQUE7SUFBQTtJQUFBLE9BRUEsaUJBQVFpRSxhQUFhLEVBQUVDLHNCQUFzQixFQUFFcEUsVUFBVTtNQUFBO01BRXJELElBQVFxRSxnQkFBZ0IsR0FBSyxJQUFJLENBQXpCQSxnQkFBZ0I7TUFFeEIsSUFBUUMscUJBQXFCLEdBQUtELGdCQUFnQixDQUExQ0MscUJBQXFCO01BRTdCLDRCQUF5Q0QsZ0JBQWdCLENBQUNFLFdBQVcsQ0FBQ0MsT0FBTztRQUFyRUMsWUFBWSx5QkFBWkEsWUFBWTtRQUFFQyxjQUFjLHlCQUFkQSxjQUFjO1FBQ2hDQyx5QkFBeUIsR0FBR04sZ0JBQWdCLENBQUNPLDRCQUE0QixDQUFDSixPQUFPO1FBQ2pGSyx3QkFBd0IsR0FBR1IsZ0JBQWdCLENBQUNTLDJCQUEyQixDQUFDTixPQUFPO01BRW5GLElBQVFPLE9BQU8sR0FBZUoseUJBQXlCLENBQS9DSSxPQUFPO1FBQUV4QyxRQUFRLEdBQUtvQyx5QkFBeUIsQ0FBdENwQyxRQUFRO1FBQ25CeUMsUUFBUSxHQUFLSCx3QkFBd0IsQ0FBckNHLFFBQVE7TUFFZCxJQUFNQyxRQUFRLEdBQUcsRUFBRTtNQUVuQixJQUFJQyxTQUFTLEdBQUczQyxRQUFRLGFBQVJBLFFBQVEsY0FBUkEsUUFBUSxHQUFJLENBQUM7TUFFN0IyQyxTQUFTLEdBQUd2QyxJQUFJLENBQUN3QyxHQUFHLENBQUNELFNBQVMsRUFBRUYsUUFBUSxDQUFDO01BRXpDLElBQU1JLFdBQVcsR0FDYkYsU0FBUyxHQUNMQSxTQUFTLEdBQ1RGLFFBQVE7TUFFaEIsSUFBTUssU0FBUyxHQUFHO1FBQ2RiLE9BQU8sRUFBQztPQUNYO01BRUQsSUFBTWMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUFvQixDQUFJMUQsS0FBSyxFQUFJO1FBQ25DeUQsU0FBUyxDQUFDYixPQUFPLEdBQUcsSUFBSTtRQUN4Qkosc0JBQXNCLENBQUN4QyxLQUFLLENBQUM7TUFDakMsQ0FBQztNQUVEO01BQ0EsSUFBSTZDLFlBQVksQ0FBQ2MsWUFBWSxDQUFDZixPQUFPLEVBQUU7UUFFbkMsSUFBTTlELGdCQUFnQixHQUFHLElBQUksQ0FBQ00sVUFBVSxDQUFDTixnQkFBZ0I7UUFFekQsNEJBQXdEZ0UsY0FBYyxDQUFDYyxTQUFTO1VBQXhFQyxvQkFBb0IseUJBQXBCQSxvQkFBb0I7VUFBRUMscUJBQXFCLHlCQUFyQkEscUJBQXFCO1FBRW5ELEtBQUssSUFBSTlELEtBQUssR0FBRyxDQUFDLEVBQUVBLEtBQUssR0FBR3dELFdBQVcsRUFBRXhELEtBQUssRUFBRSxFQUFFO1VBRTlDNkQsb0JBQW9CLElBQUlBLG9CQUFvQixDQUFDN0QsS0FBSyxDQUFDO1VBQ25ELElBQUksQ0FBQ2xCLGdCQUFnQixDQUFDaUYsR0FBRyxDQUFDL0QsS0FBSyxDQUFDLEVBQUU7WUFFOUIsSUFBTWdFLE9BQU8sR0FBRyxJQUFJLENBQUNDLFdBQVcsQ0FDNUJqRSxLQUFLLEVBQ0xtRCxPQUFPLEVBQ1BULHFCQUFxQixFQUNyQm9CLHFCQUFxQixFQUNyQkosb0JBQW9CLEVBQ3BCdEYsVUFBVSxDQUNiO1lBQ0RpRixRQUFRLENBQUNhLElBQUksQ0FBQ0YsT0FBTyxDQUFDOztVQUkxQixJQUFJUCxTQUFTLENBQUNiLE9BQU8sRUFBRTs7O01BSS9CdUIsT0FBTyxDQUFDQyxVQUFVLENBQUNmLFFBQVEsQ0FBQyxDQUFDZ0IsSUFBSSxDQUM3QixZQUFJO1FBQ0EsTUFBSSxDQUFDakYsVUFBVSxDQUFDWixRQUFRLEdBQUcsSUFBSTtRQUMvQixNQUFJLENBQUMyQixnQkFBZ0IsRUFBRTtRQUN2Qm9DLGFBQWEsRUFBRTtNQUNuQixDQUFDLENBQ0o7SUFFTDtJQUVBO0VBQUE7SUFBQTtJQUFBLE9BRUEsNEJBQWdCO01BRVosT0FBTyxJQUFJN0QsR0FBRyxDQUFDLElBQUksQ0FBQ1UsVUFBVSxDQUFDTixnQkFBZ0IsQ0FBQztJQUVwRDtFQUFDO0lBQUE7SUFBQSxPQUVELDJCQUFrQnVCLGVBQWU7TUFFdkIsYUFBUyxHQUFHLElBQUkzQixHQUFHLEVBQUU7UUFDckJJLGdCQUFnQixHQUFLLElBQUksQ0FBQ00sVUFBVSxDQUFwQ04sZ0JBQWdCO01BREssMkNBR1B1QixlQUFlO1FBQUE7TUFBQTtRQUFuQyxvREFBcUM7VUFBQSxJQUExQkwsS0FBSztVQUVac0UsU0FBUyxDQUFDQyxHQUFHLENBQUN2RSxLQUFLLEVBQUVsQixnQkFBZ0IsQ0FBQzBGLEdBQUcsQ0FBQ3hFLEtBQUssQ0FBQyxDQUFDOztNQUVwRDtRQUFBO01BQUE7UUFBQTtNQUFBO01BRUQsT0FBT3NFLFNBQVM7SUFFcEI7RUFBQztJQUFBO0lBQUEsT0FFRCwyQkFBZTtNQUVYLElBQU1HLFNBQVMsR0FBRyxJQUFJL0YsR0FBRyxFQUFFO01BQUEsNENBRUEsSUFBSSxDQUFDVSxVQUFVLENBQUNYLFdBQVc7UUFBQTtNQUFBO1FBQXRELHVEQUF3RDtVQUFBO1lBQTVDZ0MsR0FBRztZQUFFaUUsS0FBSztVQUNsQixJQUNJMUUsS0FBSyxHQUVMMEUsS0FBSyxDQUZMMUUsS0FBSztZQUNMMkUsU0FBUyxHQUNURCxLQUFLLENBRExDLFNBQVM7VUFHYkYsU0FBUyxDQUFDRixHQUFHLENBQUM5RCxHQUFHLEVBQUM7WUFDZFQsS0FBSyxFQUFMQSxLQUFLO1lBQ0wyRSxTQUFTLEVBQVRBO1dBQ0gsQ0FBQzs7TUFFTDtRQUFBO01BQUE7UUFBQTtNQUFBO01BRUQsT0FBT0YsU0FBUztJQUVwQjtJQUVBO0lBRUE7RUFBQTtJQUFBO0lBQUEsT0FDQSxtQkFBVUcsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLGFBQWE7TUFFdkMsd0JBQXVDLElBQUksQ0FBQzFGLFVBQVU7UUFBL0NOLGdCQUFnQixxQkFBaEJBLGdCQUFnQjtRQUFDTCxXQUFXLHFCQUFYQSxXQUFXO01BRW5DO01BRUEsSUFBTXNHLHNCQUFzQixHQUFHRCxhQUFhLEdBQUdELFNBQVMsR0FBRyxDQUFDO1FBQ3hERyx3QkFBd0IsR0FBR0osT0FBTyxHQUFHQyxTQUFTO1FBQzlDSSxXQUFXLEdBQUdMLE9BQU8sSUFBSUcsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO01BRXhELElBQU1HLGNBQWMsR0FDZkYsd0JBQXdCLEdBQUcsQ0FBQztNQUFHO01BQzVCLENBQUMsQ0FBQztNQUFFO01BQ0osQ0FBQyxFQUFHO01BRVosSUFBTUcsZ0JBQWdCLEdBQUc3RixLQUFLLENBQUNDLElBQUksQ0FBQ1QsZ0JBQWdCLENBQUNVLElBQUksRUFBRSxDQUFDO01BQzVEMkYsZ0JBQWdCLENBQUMxRixJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBR0QsQ0FBQyxHQUFDQyxDQUFDO01BQUEsRUFBQztNQUVqQyxJQUFNeUYsVUFBVSxHQUFHRCxnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDLGVBQUs7VUFBQSxPQUFJWCxLQUFLLElBQUlFLE9BQU87UUFBQSxFQUFDO1FBQ3BFVSxjQUFjLEdBQUdILGdCQUFnQixDQUFDRSxTQUFTLENBQUMsZUFBSztVQUFBLE9BQUlYLEtBQUssSUFBSU8sV0FBVztRQUFBLEVBQUM7UUFDMUVNLFlBQVksR0FBR0osZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQyxlQUFLO1VBQUEsT0FBSVgsS0FBSyxJQUFJRyxTQUFTO1FBQUEsRUFBQztRQUN0RVcsZ0JBQWdCLEdBQUdMLGdCQUFnQixDQUFDRSxTQUFTLENBQUMsZUFBSztVQUFBLE9BQUlYLEtBQUssSUFBSUksYUFBYTtRQUFBLEVBQUM7TUFFbEY7TUFFQSxJQUFJVyxpQkFBaUI7TUFDckIsSUFBS0YsWUFBWSxJQUFJLENBQUMsQ0FBQyxJQUFNQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUUsRUFBRTtRQUFFO1FBRXBEQyxpQkFBaUIsR0FBRyxFQUFFO09BRXpCLE1BQU0sSUFBSUQsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUVqQ0MsaUJBQWlCLEdBQUdOLGdCQUFnQixDQUFDakQsS0FBSyxDQUFDcUQsWUFBWSxDQUFDO09BRTNELE1BQU07UUFBRTtRQUVMRSxpQkFBaUIsR0FBR04sZ0JBQWdCLENBQUNqRCxLQUFLLENBQUNxRCxZQUFZLEVBQUVDLGdCQUFnQixHQUFHLENBQUMsQ0FBQzs7TUFJbEYsSUFBTUUsZ0JBQWdCLEdBQUcsSUFBSWhILEdBQUcsRUFBRTtNQUNsQyxJQUFNaUgsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFnQixDQUFJM0YsS0FBSyxFQUFJO1FBRS9CMEYsZ0JBQWdCLENBQUNuQixHQUFHLENBQUN2RSxLQUFLLEVBQUVsQixnQkFBZ0IsQ0FBQzBGLEdBQUcsQ0FBQ3hFLEtBQUssQ0FBQyxDQUFDO01BRTVELENBQUM7TUFFRHlGLGlCQUFpQixDQUFDRyxPQUFPLENBQUNELGdCQUFnQixDQUFDO01BRTNDO01BRUEsSUFBSUUsa0JBQWtCO01BQ3RCLElBQUlYLGNBQWMsSUFBSSxDQUFDLEVBQUU7UUFBRTtRQUV2QixJQUFLRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQU1HLFlBQVksSUFBSSxDQUFDLENBQUUsRUFBRTtVQUU1Q00sa0JBQWtCLEdBQUcsRUFBRTtTQUUxQixNQUFNLElBQUlOLFlBQVksSUFBSSxDQUFDLENBQUMsRUFBRTtVQUUzQk0sa0JBQWtCLEdBQUdWLGdCQUFnQixDQUFDakQsS0FBSyxDQUFDa0QsVUFBVSxDQUFDO1NBRTFELE1BQU07VUFFSFMsa0JBQWtCLEdBQUdWLGdCQUFnQixDQUFDakQsS0FBSyxDQUFDa0QsVUFBVSxFQUFFRyxZQUFZLENBQUM7O09BSTVFLE1BQU07UUFBRTtRQUVMLElBQUlELGNBQWMsSUFBSSxDQUFDLENBQUMsSUFBSUUsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLEVBQUU7VUFFaERLLGtCQUFrQixHQUFHLEVBQUU7U0FFMUIsTUFBTSxJQUFJUCxjQUFjLElBQUksQ0FBQyxDQUFDLEVBQUU7VUFFN0JPLGtCQUFrQixHQUFHVixnQkFBZ0IsQ0FBQ2pELEtBQUssQ0FBQ3NELGdCQUFnQixHQUFHLENBQUMsQ0FBQztTQUVwRSxNQUFNO1VBRUhLLGtCQUFrQixHQUFHVixnQkFBZ0IsQ0FBQ2pELEtBQUssQ0FBQ3NELGdCQUFnQixHQUFHLENBQUMsRUFBRUYsY0FBYyxHQUFHLENBQUMsQ0FBQzs7O01BSzdGLElBQUlKLGNBQWMsSUFBSSxDQUFDLEVBQUVXLGtCQUFrQixDQUFDQyxPQUFPLEVBQUU7TUFFckQ7TUFFQSxJQUFNQyxrQkFBa0IsR0FBRyxFQUFFO01BQzdCLElBQU1DLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBaUIsQ0FBSWhHLEtBQUssRUFBSTtRQUVoQyxJQUFNaUcsTUFBTSxHQUFHbkgsZ0JBQWdCLENBQUMwRixHQUFHLENBQUN4RSxLQUFLLENBQUM7UUFFMUMsSUFBTWtHLFFBQVEsR0FDVGhCLGNBQWMsSUFBSSxDQUFDLENBQUMsR0FDakJsRixLQUFLLEdBQUcrRSxzQkFBc0IsR0FDOUIvRSxLQUFLLEdBQUcrRSxzQkFBc0I7UUFFdENqRyxnQkFBZ0IsQ0FBQ3lGLEdBQUcsQ0FBQzJCLFFBQVEsRUFBQ0QsTUFBTSxDQUFDO1FBQ3JDeEgsV0FBVyxDQUFDK0YsR0FBRyxDQUFDeUIsTUFBTSxDQUFDLENBQUNqRyxLQUFLLEdBQUdrRyxRQUFRO1FBQ3hDSCxrQkFBa0IsQ0FBQzdCLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQztNQUVyQyxDQUFDO01BRURMLGtCQUFrQixDQUFDRCxPQUFPLENBQUNJLGlCQUFpQixDQUFDO01BRTdDO01BRUEsSUFBTUcsaUJBQWlCLEdBQUcsRUFBRTtNQUM1QixJQUFNQyxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQWdCLENBQUlILE1BQU0sRUFBRWpHLEtBQUssRUFBSTtRQUN2QyxJQUFNa0csUUFBUSxHQUFHbEcsS0FBSyxHQUFHZ0Ysd0JBQXdCLEVBQUM7UUFFbERsRyxnQkFBZ0IsQ0FBQ3lGLEdBQUcsQ0FBQzJCLFFBQVEsRUFBRUQsTUFBTSxDQUFDO1FBQ3RDeEgsV0FBVyxDQUFDK0YsR0FBRyxDQUFDeUIsTUFBTSxDQUFDLENBQUNqRyxLQUFLLEdBQUdrRyxRQUFRO1FBQ3hDQyxpQkFBaUIsQ0FBQ2pDLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQztNQUVwQyxDQUFDO01BRURSLGdCQUFnQixDQUFDRSxPQUFPLENBQUNRLGdCQUFnQixDQUFDO01BRTFDO01BQ0E7TUFFQSxJQUFNQyxnQkFBZ0IsYUFBT04sa0JBQWtCLEVBQUlJLGlCQUFpQixDQUFDO01BRXJFLE9BQU9FLGdCQUFnQjtJQUUzQjtJQUVBO0VBQUE7SUFBQTtJQUFBLE9BQ0EsMkJBQWtCckcsS0FBSyxFQUFFc0csU0FBUyxFQUFFQyxTQUFTLEVBQUVuRCxRQUFRO01BRW5ELHdCQUFxRCxJQUFJLENBQUNoRSxVQUFVO1FBQTVETixnQkFBZ0IscUJBQWhCQSxnQkFBZ0I7UUFBRUwsV0FBVyxxQkFBWEEsV0FBVztRQUFFSSxTQUFTLHFCQUFUQSxTQUFTO01BRWhEO01BRUE7TUFDQSxJQUFJMkgsY0FBYyxHQUFHRixTQUFTLGFBQVRBLFNBQVMsY0FBVEEsU0FBUyxHQUFJLENBQUM7TUFFbkNFLGNBQWMsR0FDVEEsY0FBYyxHQUFHeEcsS0FBSyxHQUNuQndHLGNBQWMsR0FDZHhHLEtBQUs7TUFFYixJQUFNeUcsV0FBVyxHQUFHLENBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUM7TUFDN0IsSUFBSUYsU0FBUyxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBRWpCO1FBQ0EsSUFBSUMsY0FBYyxHQUFJcEQsUUFBUSxHQUFHLENBQUUsRUFBRSxPQUFPcUQsV0FBVztPQUUxRCxNQUFNO1FBRUg7UUFDQSxJQUFJekcsS0FBSyxHQUFHb0QsUUFBUSxFQUFFLE9BQU9xRCxXQUFXOztNQUk1QztNQUNBLElBQU1DLFVBQVUsR0FBR0YsY0FBYyxHQUFHeEcsS0FBSyxHQUFHLENBQUM7TUFFN0M7TUFDQSxJQUFNMkcsY0FBYyxHQUFHRCxVQUFVLEdBQUdILFNBQVM7TUFFN0M7TUFDQSxJQUFNSyxnQkFBZ0IsR0FBR3RILEtBQUssQ0FBQ0MsSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ1UsSUFBSSxFQUFFLENBQUM7TUFDNURvSCxnQkFBZ0IsQ0FBQ25ILElBQUksQ0FBQyxVQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBQSxPQUFHRCxDQUFDLEdBQUNDLENBQUM7TUFBQSxFQUFDO01BRWpDO01BQ0E7TUFFQTtNQUNBLElBQUlrSCxhQUFhLEdBQUcsSUFBSTtNQUN4QixJQUFJQyxXQUFXLEdBQUcsQ0FBRSxDQUFDO01BRXJCLElBQUlQLFNBQVMsSUFBSSxDQUFFLENBQUMsRUFBRTtRQUVsQk0sYUFBYSxHQUFHRCxnQkFBZ0IsQ0FBQy9HLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFJOEcsY0FBZTtRQUUxREUsYUFBYSxHQUFHOUYsSUFBSSxDQUFDRCxHQUFHLENBQUMwRixjQUFjLEdBQUlHLGNBQWUsRUFBRUUsYUFBYSxDQUFDO1FBRTFFQSxhQUFhLEdBQUc5RixJQUFJLENBQUN3QyxHQUFHLENBQUNILFFBQVEsR0FBRyxDQUFDLEVBQUN5RCxhQUFhLENBQUM7UUFFcERDLFdBQVcsR0FBR0YsZ0JBQWdCLENBQUN2QixTQUFTLENBQUMsZUFBSztVQUFBLE9BQUlYLEtBQUssSUFBSW1DLGFBQWE7UUFBQSxFQUFDOztNQUk3RTtNQUNBLElBQU1FLE1BQU0sR0FBR0gsZ0JBQWdCLENBQUN2QixTQUFTLENBQUMsZUFBSyxFQUFHO1FBRTlDLE9BQVFYLEtBQUssSUFBSTFFLEtBQUssSUFBTTBFLEtBQUssSUFBSThCLGNBQWU7TUFFeEQsQ0FBQyxDQUFDO01BRUYsSUFBTVEsZ0JBQWdCLEdBQUcxSCxLQUFLLENBQUNDLElBQUksQ0FBQ3FILGdCQUFnQixDQUFDO01BQ3JESSxnQkFBZ0IsQ0FBQ2xCLE9BQU8sRUFBRTtNQUMxQixJQUFJbUIsT0FBTyxHQUFHRCxnQkFBZ0IsQ0FBQzNCLFNBQVMsQ0FBQyxlQUFLLEVBQUU7UUFFNUMsT0FBT1gsS0FBSyxJQUFJOEIsY0FBYztNQUVsQyxDQUFDLENBQUM7TUFDRixJQUFJUyxPQUFPLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFDZkEsT0FBTyxHQUFJTCxnQkFBZ0IsQ0FBQ2xHLE1BQU0sR0FBRyxDQUFDLEdBQUl1RyxPQUFPO1FBQ2pELElBQUlBLE9BQU8sR0FBR0YsTUFBTSxFQUFFRSxPQUFPLEdBQUcsQ0FBQyxDQUFDOztNQUd0QztNQUVBLElBQUlDLG9CQUFvQjtRQUFFO1FBQ3RCQyxvQkFBb0IsR0FBRyxFQUFFO1FBQUU7UUFDM0JDLG1CQUFtQixHQUFHLEVBQUU7UUFBRTtRQUMxQkMsMEJBQTBCLEdBQUUsRUFBRTtRQUFFO1FBQ2hDQyxpQkFBaUIsR0FBRyxFQUFFLEVBQUM7TUFFM0I7TUFDQSxJQUFLUCxNQUFNLElBQUksQ0FBQyxDQUFDLElBQU1FLE9BQU8sSUFBSSxDQUFDLENBQUUsRUFBRTtRQUFFO1FBRXJDQyxvQkFBb0IsR0FBRyxFQUFFO09BRTVCLE1BQU07UUFBRTtRQUVMLElBQUlYLFNBQVMsSUFBSSxDQUFDLEVBQUU7VUFFaEJXLG9CQUFvQixHQUFHTixnQkFBZ0IsQ0FBQzFFLEtBQUssQ0FBQzZFLE1BQU0sQ0FBQztTQUV4RCxNQUFNLElBQUlFLE9BQU8sSUFBSSxDQUFDLENBQUMsRUFBRTtVQUFFO1VBRXhCQyxvQkFBb0IsR0FBRyxFQUFFO1NBRTVCLE1BQU07VUFBRTtVQUVMQSxvQkFBb0IsR0FBR04sZ0JBQWdCLENBQUMxRSxLQUFLLENBQUMrRSxPQUFPLEdBQUcsQ0FBQyxDQUFDOzs7TUFNbEUsSUFBTU0sY0FBYyxHQUFHLEVBQUUsRUFBQztNQUUxQixJQUFJaEIsU0FBUyxJQUFJLENBQUMsRUFBRTtRQUVoQjtRQUNBLElBQUtRLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBTUUsT0FBTyxJQUFJLENBQUMsQ0FBRSxFQUFFO1VBQUU7VUFFckNFLG9CQUFvQixHQUFHLEVBQUU7U0FFNUIsTUFBTSxJQUFJRixPQUFPLElBQUksQ0FBQyxDQUFDLEVBQUU7VUFFdEJFLG9CQUFvQixHQUFHUCxnQkFBZ0IsQ0FBQzFFLEtBQUssQ0FBQzZFLE1BQU0sQ0FBQztTQUV4RCxNQUFNO1VBRUhJLG9CQUFvQixHQUFHUCxnQkFBZ0IsQ0FBQzFFLEtBQUssQ0FBQzZFLE1BQU0sRUFBRUUsT0FBTyxHQUFHLENBQUMsQ0FBQzs7T0FHekUsTUFBTTtRQUVIO1FBQ0EsSUFBSUgsV0FBVyxJQUFJLENBQUMsQ0FBQyxFQUFFO1VBQUU7VUFFckJNLG1CQUFtQixHQUFHLEVBQUU7U0FFM0IsTUFBTTtVQUVIQSxtQkFBbUIsR0FBR1IsZ0JBQWdCLENBQUMxRSxLQUFLLENBQUM0RSxXQUFXLEdBQUcsQ0FBQyxDQUFDOztRQUdqRTtRQUNBLElBQUtDLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBTUUsT0FBTyxJQUFJLENBQUMsQ0FBRSxFQUFFO1VBQUU7VUFFckNJLDBCQUEwQixHQUFHLEVBQUU7U0FFbEMsTUFBTSxJQUFJSixPQUFPLElBQUksQ0FBQyxDQUFDLEVBQUU7VUFFdEJJLDBCQUEwQixHQUFHVCxnQkFBZ0IsQ0FBQzFFLEtBQUssQ0FBQzZFLE1BQU0sQ0FBQztTQUU5RCxNQUFNO1VBRUhNLDBCQUEwQixHQUFHVCxnQkFBZ0IsQ0FBQzFFLEtBQUssQ0FBQzZFLE1BQU0sRUFBRUUsT0FBTyxHQUFHLENBQUMsQ0FBQzs7UUFJNUU7UUFBQSw0Q0FDb0JJLDBCQUEwQjtVQUFBO1FBQUE7VUFBOUMsdURBQWdEO1lBQUEsSUFBckNySCxNQUFLO1lBRVpzSCxpQkFBaUIsQ0FBQ3BELElBQUksQ0FBQ3BGLGdCQUFnQixDQUFDMEYsR0FBRyxDQUFDeEUsTUFBSyxDQUFDLENBQUM7O1FBRXREO1VBQUE7UUFBQTtVQUFBO1FBQUE7O01BSUw7TUFFQTtNQUNBLElBQUl1RyxTQUFTLElBQUksQ0FBQyxFQUFFVyxvQkFBb0IsQ0FBQ3BCLE9BQU8sRUFBRTtNQUVsRCxJQUFNMEIsbUJBQW1CLEdBQUcsRUFBRTtNQUU5QjtNQUNBLElBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFZLENBQUd6SCxLQUFLLEVBQUc7UUFFekIsSUFBTWlHLE1BQU0sR0FBR25ILGdCQUFnQixDQUFDMEYsR0FBRyxDQUFDeEUsS0FBSyxDQUFDO1FBQzFDLElBQU1rRyxRQUFRLEdBQUdsRyxLQUFLLEdBQUcyRyxjQUFjO1FBRXZDN0gsZ0JBQWdCLENBQUN5RixHQUFHLENBQUMyQixRQUFRLEVBQUVELE1BQU0sQ0FBQztRQUN0Q3hILFdBQVcsQ0FBQytGLEdBQUcsQ0FBQ3lCLE1BQU0sQ0FBQyxDQUFDakcsS0FBSyxHQUFHa0csUUFBUTtRQUN4Q3NCLG1CQUFtQixDQUFDdEQsSUFBSSxDQUFDZ0MsUUFBUSxDQUFDO01BRXRDLENBQUM7TUFFRGdCLG9CQUFvQixDQUFDdEIsT0FBTyxDQUFDNkIsWUFBWSxDQUFDO01BRTFDO01BRUEsSUFBSWxCLFNBQVMsSUFBSSxDQUFDLEVBQUU7UUFBQSw0Q0FFSVksb0JBQW9CO1VBQUE7UUFBQTtVQUF4Qyx1REFBMEM7WUFBQSxJQUEvQm5ILE9BQUs7WUFFWmxCLGdCQUFnQixVQUFPLENBQUNrQixPQUFLLENBQUM7O1FBRWpDO1VBQUE7UUFBQTtVQUFBO1FBQUE7T0FFSixNQUFNO1FBQUEsNENBRWlCb0gsbUJBQW1CO1VBQUE7UUFBQTtVQUF2Qyx1REFBeUM7WUFBQSxJQUE5QnBILE9BQUs7WUFFWmxCLGdCQUFnQixVQUFPLENBQUNrQixPQUFLLENBQUM7O1FBRWpDO1VBQUE7UUFBQTtVQUFBO1FBQUE7UUFBQSw0Q0FFb0JzSCxpQkFBaUI7VUFBQTtRQUFBO1VBQXRDLHVEQUF3QztZQUFBLElBQTdCckIsTUFBTTtZQUVieEgsV0FBVyxVQUFPLENBQUN3SCxNQUFNLENBQUM7WUFDMUJzQixjQUFjLENBQUNyRCxJQUFJLENBQUMrQixNQUFNLENBQUM7O1FBRTlCO1VBQUE7UUFBQTtVQUFBO1FBQUE7O01BSUw7TUFFQTtNQUNBLE9BQU8sQ0FBQ3VCLG1CQUFtQixFQUFFTCxvQkFBb0IsRUFBRVIsY0FBYyxFQUFFWSxjQUFjLENBQUM7SUFFdEY7SUFFQTtJQUVBO0lBQ0E7RUFBQTtJQUFBO0lBQUEsT0FDQSxpQ0FBd0J2SCxLQUFLO01BRXpCLElBQUksQ0FBQ1osVUFBVSxDQUFDVCxZQUFZLENBQUMrSSxHQUFHLENBQUMxSCxLQUFLLENBQUM7SUFFM0M7RUFBQztJQUFBO0lBQUEsT0FFRCwrQkFBc0JBLEtBQUs7TUFFdkIsSUFBSSxDQUFDWixVQUFVLENBQUNULFlBQVksVUFBTyxDQUFDcUIsS0FBSyxDQUFDO0lBRTlDO0VBQUM7SUFBQTtJQUFBLE9BRUQsd0JBQVk7TUFFUixPQUFPOUIsWUFBWSxFQUFFO0lBRXpCO0lBRUE7RUFBQTtJQUFBO0lBQUEsT0FDQSxnQ0FBdUI4QixLQUFLO01BRXhCLElBQVFsQixnQkFBZ0IsR0FBSyxJQUFJLENBQUNNLFVBQVUsQ0FBcENOLGdCQUFnQjtNQUV4QixJQUFNbUgsTUFBTSxHQUNQbkgsZ0JBQWdCLENBQUNpRixHQUFHLENBQUMvRCxLQUFLLENBQUMsR0FDeEJsQixnQkFBZ0IsQ0FBQzBGLEdBQUcsQ0FBQ3hFLEtBQUssQ0FBQyxHQUMxQixJQUFJLENBQUMySCxZQUFZLEVBQUc7TUFFN0IsT0FBTzFCLE1BQU07SUFFakI7SUFFQztFQUFBO0lBQUE7SUFBQSxPQUNELHNCQUFhdEIsU0FBUyxFQUFFM0UsS0FBSyxFQUFFaUcsTUFBTSxFQUFtQjtNQUFBLElBQWpCMkIsU0FBUyx1RUFBRyxLQUFLO01BRXBELElBQUksQ0FBQ0MscUJBQXFCLENBQUM3SCxLQUFLLENBQUM7TUFFakMsNEJBQ0ksSUFBSSxDQUFDeUMsZ0JBQWdCLENBQUNPLDRCQUE0QixDQUFDSixPQUFPO1FBRHREa0YsTUFBTSx5QkFBTkEsTUFBTTtRQUFFQyxVQUFVLHlCQUFWQSxVQUFVO1FBQUVDLFNBQVMseUJBQVRBLFNBQVM7UUFBRUMsV0FBVyx5QkFBWEEsV0FBVztNQUdsRCxJQUFNQyxVQUFVLEdBQUdDLGdCQUFnQixDQUMzQm5JLEtBQUssRUFBRWlHLE1BQU0sRUFBRTZCLE1BQU0sRUFBRUcsV0FBVyxFQUFFRixVQUFVLEVBQUVDLFNBQVMsQ0FBQztNQUVsRTtNQUNBLElBQUksQ0FBQzVJLFVBQVUsQ0FBQ1AsU0FBUyxDQUFDMEYsR0FBRyxDQUFDMEIsTUFBTSxFQUM1Qm1DO1FBQUEsYUFBaUIsZUFBZTtRQUFDM0gsR0FBRyxFQUFJd0YsTUFBTTtRQUFBLGVBQWlCQSxNQUFNO1FBQUEsY0FBZ0JqRztNQUFLLEdBQ3RGb0ksaUNBQUNDLCtCQUFRO1FBQUM1SCxHQUFHLEVBQUl3RixNQUFNO1FBQUVxQyxJQUFJLEVBQUlKO01BQVUsUUFBTXZELFNBQVMsTUFBYyxDQUN0RSxDQUFDO01BRWYsSUFBSSxDQUFDdkYsVUFBVSxDQUFDWixRQUFRLEdBQUcsSUFBSTtNQUUvQixJQUFNK0osY0FBYyxHQUFHO1FBQ25CTCxVQUFVLEVBQVZBLFVBQVU7UUFDVk0sZ0JBQWdCLEVBQUM7VUFDYjVGLE9BQU8sRUFBQztTQUNYO1FBQ0Q1QyxLQUFLLEVBQUxBLEtBQUs7UUFDTGlHLE1BQU0sRUFBTkEsTUFBTTtRQUNOdEIsU0FBUyxFQUFUQTtPQUNIO01BRUQsSUFBSSxDQUFDdkYsVUFBVSxDQUFDWCxXQUFXLENBQUM4RixHQUFHLENBQUMwQixNQUFNLEVBQUVzQyxjQUFjLENBQUM7TUFDdkQsSUFBSSxDQUFDbkosVUFBVSxDQUFDTixnQkFBZ0IsQ0FBQ3lGLEdBQUcsQ0FBQ3ZFLEtBQUssRUFBRWlHLE1BQU0sQ0FBQztNQUVuRCxJQUFJLENBQUMyQixTQUFTLEVBQUUsSUFBSSxDQUFDekgsZ0JBQWdCLEVBQUU7TUFFdkMsT0FBT29JLGNBQWM7SUFFekI7SUFFQTtFQUFBO0lBQUE7SUFBQSxPQUNjLHFCQUNWdkksS0FBSyxFQUNMbUQsT0FBTyxFQUNQVCxxQkFBcUIsRUFDckJvQixxQkFBcUIsRUFDckJKLG9CQUFvQixFQUNwQnRGLFVBQVU7Ozs7Ozs7Z0JBR0o2SCxNQUFNLEdBQUcsSUFBSSxDQUFDMEIsWUFBWSxFQUFFO2dCQUFBO2dCQUFBO2dCQU1oQixPQUFNeEUsT0FBTyxDQUFDbkQsS0FBSyxFQUFFaUcsTUFBTSxDQUFDO2NBQUE7Z0JBQTFDd0MsV0FBVztnQkFDWCxJQUFJQSxXQUFXLEtBQUssSUFBSSxFQUFFQyxXQUFXLEdBQUdELFdBQVc7Z0JBQUE7Z0JBQUE7Y0FBQTtnQkFBQTtnQkFBQTtnQkFJbkRDLFdBQVcsR0FBR0QsV0FBVyxHQUFHN0gsU0FBUztnQkFDckMrSCxLQUFLLGNBQUk7Y0FBQTtnQkFJYixJQUFLRixXQUFXLEtBQUssSUFBSSxJQUFNQSxXQUFXLEtBQUs3SCxTQUFVLEVBQUU7a0JBRXZELElBQUksQ0FBQ3dILGtCQUFLLENBQUNRLGNBQWMsQ0FBQ0gsV0FBVyxDQUFDLEVBQUU7b0JBQ3BDQyxXQUFXLEdBQUdELFdBQVc7b0JBQ3pCQSxXQUFXLEdBQUc3SCxTQUFTO29CQUN2QitILEtBQUssR0FBRyxJQUFJRSxLQUFLLENBQUMsdUJBQXVCLENBQUM7OztnQkFLbEQsSUFBS0osV0FBVyxLQUFLLElBQUksSUFBTUEsV0FBVyxLQUFLN0gsU0FBVSxFQUFFO2tCQUdqRGtJLGtCQUFrQixHQUFHO29CQUN2Qk4sZ0JBQWdCLEVBQUMsSUFBSTtvQkFDckI5RixxQkFBcUIsRUFBckJBO21CQUNIO2tCQUNELElBQUkrRixXQUFXLENBQUNNLEtBQUssQ0FBQ0MsY0FBYyxDQUFDLG9CQUFvQixDQUFDLEVBQUU7b0JBQ3hEQyxPQUFPLEdBQUdiLGtCQUFLLENBQUNjLFlBQVksQ0FBQ1QsV0FBVyxFQUFFO3NCQUFDSyxrQkFBa0IsRUFBbEJBO29CQUFrQixDQUFDLENBQUM7bUJBQ2xFLE1BQU07b0JBQ0hHLE9BQU8sR0FBR1IsV0FBVzs7a0JBR25CVSxVQUFVLEdBQ1osSUFBSSxDQUFDQyxZQUFZLENBQUNILE9BQU8sRUFBRWpKLEtBQUssRUFBRWlHLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBQztrQkFDcEQ7a0JBQ0E2QyxrQkFBa0IsQ0FBQ04sZ0JBQWdCLEdBQUdXLFVBQVUsQ0FBQ1gsZ0JBQWdCO2lCQUVwRSxNQUFNO2tCQUVILElBQUlDLFdBQVcsS0FBSzdILFNBQVMsRUFBRTtvQkFFM0JrRCxxQkFBcUIsSUFDakJBLHFCQUFxQixDQUFDOUQsS0FBSyxFQUFFaUcsTUFBTSxFQUFFeUMsV0FBVyxFQUFFLFNBQVMsRUFBRUMsS0FBSyxDQUFDO21CQUUxRSxNQUFNO29CQUFFO29CQUVMN0UscUJBQXFCLElBQ2pCQSxxQkFBcUIsQ0FBQzlELEtBQUssRUFBRWlHLE1BQU0sRUFBRXlDLFdBQVcsRUFBRSxTQUFTLEVBQUUsSUFBSUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUUxRm5GLG9CQUFvQixDQUFDMUQsS0FBSyxDQUFDOzs7Y0FJbEM7Y0FBQTtnQkFBQTtZQUFBO1VBQUE7UUFBQTtNQUFBLENBRUo7O0lBRUQ7SUFDQTtFQUFBO0lBQUE7SUFBQSxPQUNBLHNCQUFhQSxLQUFLLEVBQUVmLGtCQUFrQjtNQUVsQyxJQUFNb0ssVUFBVSxHQUNYLENBQUMvSixLQUFLLENBQUNnSyxPQUFPLENBQUN0SixLQUFLLENBQUMsR0FDbEIsQ0FBQ0EsS0FBSyxDQUFDLEdBQ1BBLEtBQUs7TUFFYix3QkFJSSxJQUFJLENBQUNaLFVBQVU7UUFIZlgsV0FBVyxxQkFBWEEsV0FBVztRQUNYSSxTQUFTLHFCQUFUQSxTQUFTO1FBQ1RDLGdCQUFnQixxQkFBaEJBLGdCQUFnQjtNQUdwQixJQUFNeUssVUFBVSxHQUFHLEVBQUU7TUFBQSw0Q0FDUEYsVUFBVTtRQUFBO01BQUE7UUFBeEIsdURBQTBCO1VBQUEsSUFBakJHLENBQUM7VUFFTixJQUFNdkQsTUFBTSxHQUFHbkgsZ0JBQWdCLENBQUMwRixHQUFHLENBQUNnRixDQUFDLENBQUM7VUFFdENELFVBQVUsQ0FBQ3JGLElBQUksQ0FBQztZQUFDbEUsS0FBSyxFQUFDd0osQ0FBQztZQUFDdkQsTUFBTSxFQUFOQTtVQUFNLENBQUMsQ0FBQztVQUNqQ3hILFdBQVcsVUFBTyxDQUFDd0gsTUFBTSxDQUFDO1VBQzFCcEgsU0FBUyxVQUFPLENBQUNvSCxNQUFNLENBQUM7VUFDeEJuSCxnQkFBZ0IsVUFBTyxDQUFDMEssQ0FBQyxDQUFDOztNQUU3QjtRQUFBO01BQUE7UUFBQTtNQUFBO01BRUQsSUFBSSxDQUFDcEssVUFBVSxDQUFDWixRQUFRLEdBQUcsSUFBSTtNQUUvQlMsa0JBQWtCLElBQUlBLGtCQUFrQixDQUFDc0ssVUFBVSxDQUFDO0lBRXhEO0lBRUE7RUFBQTtJQUFBO0lBQUEsT0FDQSxtQkFBVXRELE1BQU07TUFFWixPQUFPLElBQUksQ0FBQzdHLFVBQVUsQ0FBQ1gsV0FBVyxDQUFDc0YsR0FBRyxDQUFDa0MsTUFBTSxDQUFDO0lBRWxEO0VBQUM7SUFBQTtJQUFBLE9BRUQsbUJBQVVBLE1BQU07TUFFWixJQUFJLElBQUksQ0FBQ3dELFNBQVMsQ0FBQ3hELE1BQU0sQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDN0csVUFBVSxDQUFDWCxXQUFXLENBQUMrRixHQUFHLENBQUN5QixNQUFNLENBQUM7O0lBR3REO0VBQUM7RUFBQTtBQUFBO0FBMzBCTHlELG9CQUFBQTtBQSswQkE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxJQUFNdkIsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFnQixDQUFJbkksS0FBSyxFQUFFaUcsTUFBTSxFQUFFNkIsTUFBTSxFQUFFRyxXQUFXLEVBQUVGLFVBQVUsRUFBRUMsU0FBUyxFQUFJO0VBRW5GLElBQUlFLFVBQVUsR0FBRywrQ0FBb0IsR0FBRTtFQUV2QyxJQUFJeUIsU0FBUyxHQUFHekIsVUFBVSxDQUFDMEIsT0FBTztFQUNsQ0QsU0FBUyxDQUFDRSxLQUFLLENBQUNDLFFBQVEsR0FBRyxRQUFRO0VBRW5DSCxTQUFTLENBQUNJLE9BQU8sQ0FBQ0MsSUFBSSxHQUFHLGlCQUFpQjtFQUMxQ0wsU0FBUyxDQUFDSSxPQUFPLENBQUMvSixLQUFLLEdBQUdBLEtBQUs7RUFDL0IySixTQUFTLENBQUNJLE9BQU8sQ0FBQ0UsV0FBVyxHQUFHaEUsTUFBTTtFQUV0QyxPQUFPaUMsVUFBVTtBQUVyQixDQUFDO0FBRUQ7QUFFQTtBQUNPLElBQU1nQyxVQUFVLEdBQUcsU0FBYkEsVUFBVSxPQUFzQjtFQUFBLElBQWhCOUssVUFBVSxRQUFWQSxVQUFVO0VBRW5DLFlBQWtELG9CQUFRLEVBQUMsQ0FBQyxDQUFDO0lBQUE7SUFBdEQrSyxpQkFBaUI7SUFBRUMsb0JBQW9CO0VBRTlDLElBQU1DLFVBQVUsR0FBRyxrQkFBTSxFQUFDLElBQUksQ0FBQztFQUMvQkEsVUFBVSxDQUFDekgsT0FBTyxHQUFHdUgsaUJBQWlCO0VBRXRDLElBQU14RyxZQUFZLEdBQUcsa0JBQU0sRUFBQyxJQUFJLENBQUM7RUFFakMsSUFBTTJHLGNBQWMsR0FBRyxrQkFBTSxFQUFDLElBQUksQ0FBQztFQUVuQyxxQkFBUyxFQUFDLFlBQUk7SUFFVjNHLFlBQVksQ0FBQ2YsT0FBTyxHQUFHLElBQUk7SUFFM0J4RCxVQUFVLENBQUNiLFlBQVksR0FBRyxZQUFJO01BRTFCK0wsY0FBYyxDQUFDMUgsT0FBTyxHQUFHeEQsVUFBVSxDQUFDTCxVQUFVO01BRTlDNEUsWUFBWSxDQUFDZixPQUFPLElBQUl3SCxvQkFBb0IsQ0FBQyxFQUFFQyxVQUFVLENBQUN6SCxPQUFPLENBQUMsRUFBQztJQUV2RSxDQUFDOztJQUVELE9BQU8sWUFBSztNQUVSZSxZQUFZLENBQUNmLE9BQU8sR0FBRyxLQUFLO0lBRWhDLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUwsT0FBTzBILGNBQWMsQ0FBQzFILE9BQU87QUFFakMsQ0FBQztBQWpDWThHLGtCQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvY2FjaGVoYW5kbGVyLnRzeD85ZTlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNhY2hlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgbWFuYWdlcyB0aGUgSW5maW5pdGVHcmlkU2Nyb2xsZXIgbGltaXRlZCAoc3BhcnNlKSBjYWNoZS4gSXQgYWxzbyBwcm92aWRlcyBzdXBwb3J0IGZvciBcbiAgICBzZXJ2aWNlcyB3aGljaCBhbGxvdyB0aGUgaG9zdCB0byBhY3RpdmVseSBtYW5hZ2UgbWFueSBhc3BlY3RzIG9mIHRoZSBjYWNoZS4gU2VlIGRvY3VtZW50YXRpb25cbiAgICBhYm91dCB0aGUgdXNlciBmdW5jdGlvbnNDYWxsYmFjayBjYWxsYmFjayBmb3IgZGV0YWlscy4gTm90ZSB0aGF0IG92ZXJseSBsYXJnZSBjYWNoZXMgb2YgY29tcGxleCBjb21wb25lbnRzXG4gICAgY2FuIGltcGFpciBwZXJmb3JtYW5jZS4gVGhpcyBjYW4gYmUgb3B0aW1pemVkIHdpdGggdGhlIGNhY2hlTWF4IHByb3BlcnR5LlxuXG4gICAgVGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIgc3RvcmVzIHVzZXIgY2VsbCBjb250ZW50IChjb21wb25lbnRzKSBpbiBhIGNlbnRyYWwgaGlkZGVuIHBvcnRhbCBjYWNoZSBcbiAgICBmb3IgZWFjaCBJbmZpbml0ZUdyaWRTY3JvbGxlciByb290LCBmcm9tIHdoZW5jZSB0aGUgY29tcG9uZW50cyBhcmUgcHVsbGVkIGludG8gdGhlIHJlbGV2YW50IENlbGxGcmFtZXMgXG4gICAgZm9yIGRpc3BsYXkuIFRoZSB1c2VyIGNvbXBvbmVudHMgYXJlIHN0b3JlZCBpbiBSZWFjdCBwb3J0YWxzLCB3aXRoIGVhY2ggcG9ydGFsIGluc3RhbnRpYXRlZCBpblxuICAgIGEgY29udGFpbmVyIGRpdiAoJ3BvcnRhbHdyYXBwZXInKS4gVGhlc2UgY29udGFpbmVyIGRpdnMgYXJlIGluY2x1ZGVkIGluIGEgc3RhbmRhcmQgUmVhY3QgY29tcG9uZW50IFxuICAgIGxpc3QgaW4gdGhlIHJlYWwgRE9NLiBUaGUgY29udGFpbmVkIHBvcnRhbHMgdGhlbXNlbHZlcyBhcmUgbm90IHBhcnQgb2YgdGhlIHJlYWwgRE9NLCBidXQgYXJlIHBhcnQgb2YgXG4gICAgUmVhY3QncyB2aXJ0dWFsIERPTS5cblxuICAgIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcG9ydGFscy5odG1sIGZvciBnZW5lcmFsIGluZm9ybWF0aW9uIGFib3V0IFJlYWN0IHBvcnRhbHMuXG4gICAgU2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LXJldmVyc2UtcG9ydGFsIGZvciB0aGUgdXRpbGl0eSB0aGF0IEluZmluaXRlR3JpZFNjcm9sbGVyXG4gICAgdXNlcyB0byBtYW5hZ2UgcG9ydGFscy5cblxuICAgIFRoaXMgY2FjaGluZyBoYXMgbWFueSBhZHZhbnRhZ2VzLCBub3RhYmx5IHRoZSBhYmlsaXR5IHRvIG1vdmUgY2VsbHMgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGVcbiAgICBoZWFkIGFuZCB0YWlsIGdyaWRzIG9mIHRoZSBDcmFkbGUgd2l0aG91dCBsb3Npbmcgc3RhdGUsIGFuZCB0aGUgYWJpbGl0eSB0byBtYWludGFpbiBzdGF0ZSBmb3IgXG4gICAgY29tcGxleCBjb21wb25lbnRzIHdoaWNoIG1vdmUgYmV5b25kIHRoZSBzY29wZSBvZiB0aGUgY29udGVudCBvZiB0aGUgQ3JhZGxlLiBCdXQgdGhlcmUgaXMgYW5cbiAgICBpbXBvcnRhbnQgc2lkZSBlZmZlY3QuXG5cbiAgICBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZWFsIERPTSAoaW50byB0aGUgcG9ydGFsIG9mIHRoZSB2aXJ0dWFsIERPTSlcbiAgICBoYXZlIHRoZWlyIHNjcm9sbCBwb3NpdGlvbnMsIHdpZHRoLCBhbmQgaGVpZ2h0IHNldCB0byB6ZXJvLiBUaGVyZWZvcmUgaWYgY29tcG9uZW50cyByZWx5IG9uIHRoZXNlIFxuICAgIHZhbHVlcyBmb3IgY29uZmlndXJhdGlvbiwgdGhleSBtdXN0IGhhdmUgYSB3YXkgb2Ygc3RvcmluZyB2YWx1ZXMgaW4gc3RhdGUgKG5vdGFibHkgdGhlIFxuICAgIFNjcm9sbCBQb3MgLSBzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCksIHJlY29nbml6aW5nIHdoZW4gdGhlIGNvbXBvbmVudCBjb21lcyBvdXQgb2YgdGhlIHBvcnRhbCBjYWNoZSBcbiAgICBpbnRvIHRoZSByZWFsIERPTSAod2lkdGggYW5kIGhlaWdodCBhcmUgdHlwaWNhbGx5IG5vIGxvbmdlciBib3RoIDApLCBhbmQgcmVzcG9uZGluZyB0byBjaGFuZ2UgaW4gXG4gICAgY2FjaGUgc3RhdGUgYXBwcm9wcmlhdGVseS5cblxuICAgIFRpcHM6XG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgaW4gY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgPSAwXG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgb3V0IG9mIGNhY2hlIHdoZW4gYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbFxuICAgICAgICAtIGlmIHlvdSBjcmVhdGUgYW4gZW1wdHkgJ3Njcm9sbGVyUHJvcGVydGllcycgcHJvcGVydHkgZm9yIHlvdXIgY29tcG9uZW50LCBDZWxsRnJhbWUgd2lsbFxuICAgICAgICAgICAgc2V0IGl0IHRvIGFuIG9iamVjdCBjb250YWluaW5nIGlzUmVwYXJlbnRpbmdSZWYgYW5kIHNjcm9sbGVyUHJvcGVydGllc1JlZlxuICAgICAgICAtIGlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCBwcm92aWRlcyBhbiB1cC10by1kYXRlIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgXG4gICAgICAgICAgICBjdXJyZW50bHkgYmVpbmcgJ3JlcGFyZW50ZWQnIGludG8gdGhlIHJlYWwgRE9NLiBTZXQgdGhlIHZhbHVlIGJhY2sgdG8gZmFsc2Ugb25jZSB5b3UndmUgXG4gICAgICAgICAgICBkZXRlY3RlZCBpdC4gQWZ0ZXIgcmVwYXJlbnRpbmcgKGFmdGVyIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbCkgaXMgd2hlblxuICAgICAgICAgICAgeW91IHNob3VsZCByZXN0b3JlIHNjcm9sbFBvcyAoc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpIHRvIHdoYXQgaXQgd2FzLlxuICAgICAgICAtIGlmIHlvdXIgY29tcG9uZW50IGRvZXMgbm90IHNjcm9sbCwgdGhlcmUgc2hvdWxkIGJlIG5vIGlzc3Vlcy5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IGNyZWF0ZUh0bWxQb3J0YWxOb2RlLCBJblBvcnRhbCB9IGZyb20gJ3JlYWN0LXJldmVyc2UtcG9ydGFsJ1xuXG5sZXQgZ2xvYmFsSXRlbUlEID0gMFxuXG4vLyBnbG9iYWwgc2Nyb2xsZXIgZGF0YSwgb3JnYW5pemVkIGJ5IHNlc3Npb24gc2Nyb2xsZXJJRFxuLy8gdGhlIGNhY2hlIGl0c2VsZiBpcyBtYWludGFpbmVkIGluIHRoZSByb290IGluZmluaXRlZ3JpZHNjcm9sbGVyIGNvbXBvbmVudFxuZXhwb3J0IGNsYXNzIENhY2hlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxlcklELCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYpIHtcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnNjcm9sbGVySUQgPSBzY3JvbGxlcklEXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUgPSBzZXRMaXN0c2l6ZSAvLyBwYXNzZWQgZnJvbSBpbmZpbml0ZWdyaWRzY3JvbGxlciBzZXRMaXN0c2l6ZShsaXN0c2l6ZSlcbiAgICAgICAgdGhpcy5saXN0c2l6ZVJlZiA9IGxpc3RzaXplUmVmXG4gICAgfVxuXG4gICAgY2FjaGVQcm9wcyA9IHtcbiAgICAgICAgc2V0TGlzdFN0YXRlOm51bGwsXG4gICAgICAgIG1vZGlmaWVkOmZhbHNlLFxuXG4gICAgICAgIG1ldGFkYXRhTWFwOm5ldyBNYXAoKSwgLy8gaXRlbSA9PiB7aW5kZXgsIGNvbXBvbmVudH1cbiAgICAgICAgLy8gc29tZSBwb3J0YWxzIG1heSBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ5IHJlcXVlc3RpZGxlY2FsbGJhY2ssIG5vdCB5ZXQgY3JlYXRlZFxuICAgICAgICByZXF1ZXN0ZWRTZXQ6bmV3IFNldCgpLCAvLyByZXF1ZXN0ZWRTZXQgb2YgaW5kZXhlc1xuICAgICAgICBwb3J0YWxNYXA6bmV3IE1hcCgpLCAvLyBpbmRleCA9PiBJblBvcnRhbFxuICAgICAgICBpbmRleFRvSXRlbUlETWFwOm5ldyBNYXAoKSxcblxuICAgICAgICBwb3J0YWxMaXN0Om51bGwsXG5cbiAgICAgICAgc2Nyb2xsZXJJRDpudWxsXG4gICAgfVxuXG4gICAgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcG9ydGFsSG9sZExpc3RcblxuICAgIGxpc3RzaXplUmVmXG5cbiAgICAvLyBzZXRMaXN0c2l6ZShsaXN0c2l6ZSkgY2F1c2VzIGFuIEluZmluaXRlR3JpZFNjcm9sbGVyIHVzZVN0YXRlIHVwZGF0ZVxuICAgIC8vIG9mIHRoZSBsaXN0c2l6ZSB0aHJvdWdob3V0XG4gICAgc2V0TGlzdHNpemUgXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVQT1NJVE9SWSBBTkQgTElTVCBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBiYXNpYyBvcGVyYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhbmdlTGlzdHNpemUgPSAobmV3bGlzdHNpemUsIGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjaykgPT4ge1xuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgLy8gbWF0Y2ggY2FjaGUgdG8gbmV3bGlzdHNpemVcbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhNYXAgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcFxuICAgICAgICBjb25zdCBtYXBrZXlzTGlzdCA9IEFycmF5LmZyb20ocG9ydGFsSW5kZXhNYXAua2V5cygpKVxuICAgICAgICBtYXBrZXlzTGlzdC5zb3J0KChhLGIpID0+IGEgLSBiKVxuXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RpbmRleCA9IG1hcGtleXNMaXN0LmF0KC0xKVxuXG4gICAgICAgIGlmIChoaWdoZXN0aW5kZXggPiAobmV3bGlzdHNpemUgLTEpKSB7IC8vIHBhcmUgdGhlIGNhY2hlXG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVsaXN0ID0gbWFwa2V5c0xpc3QuZmlsdGVyKChpbmRleCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAobmV3bGlzdHNpemUgLTEpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChwYXJlbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrICYmIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sobmV3bGlzdHNpemUpXG5cbiAgICB9XG5cbiAgICBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIGtlZXAgdGhlIHNldExpc3RTdGF0ZSBjYWxsYmFja1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLmNsZWFyKCkgXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gbnVsbFxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KCkgLy8gdHJpZ2dlciBkaXNwbGF5IHVwZGF0ZVxuXG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlIG9mIHRoZSBQb3J0YWxMaXN0IGNvbXBvbmVudCBvZiB0aGUgc2Nyb2xsZXIgdG8gdHJpZ2dlciByZW5kZXJcbiAgICByZW5kZXJQb3J0YWxMaXN0ID0gKCkgPT4ge1xuXG4gICAgICAgIGlmICh0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5zZXRMaXN0U3RhdGUoKSAvLyB0cmlnZ2VyIGRpc3BsYXkgdXBkYXRlXG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWNoZSBzaXplIGxpbWl0IGVuZm9yY2VlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbWF0Y2hDYWNoZVRvQ3JhZGxlID0gKGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IEFycmF5LmZyb20odGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuXG4gICAgICAgIGNvbnN0IGRlbGtleXMgPSBtYXBrZXlzLmZpbHRlcihrZXkgPT4gIWNyYWRsZUluZGV4TGlzdC5pbmNsdWRlcyhrZXkpKVxuXG4gICAgICAgIGlmIChkZWxrZXlzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChkZWxrZXlzLCBkZWxldGVMaXN0Q2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHBhcmVDYWNoZVRvTWF4ID0gKGNhY2hlTWF4LCBjcmFkbGVJbmRleExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCA9IHVuZGVmaW5lZCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsTGVuZ3RoID0gY3JhZGxlSW5kZXhMaXN0Lmxlbmd0aFxuXG4gICAgICAgIC8vIGRldGVybWluZSBuZWVkIGZvciBwYXJpbmdcbiAgICAgICAgaWYgKCghY2FjaGVNYXgpIHx8ICghbW9kZWxMZW5ndGgpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChtb2RlbExlbmd0aCwgY2FjaGVNYXgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhMaXN0ID0gdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAsXG4gICAgICAgICAgICByZXF1ZXN0ZWRTZXQgPSB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgaWYgKChwb3J0YWxJbmRleExpc3Quc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSBtYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIG1hcCBrZXlzXG4gICAgICAgIGNvbnN0IG1hcGtleXNsaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleExpc3Qua2V5cygpKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZGtleXMgPSBBcnJheS5mcm9tKHJlcXVlc3RlZFNldC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IFsuLi5tYXBrZXlzbGlzdCwuLi5yZXF1ZXN0ZWRrZXlzXVxuXG4gICAgICAgIG1hcGtleXMuc29ydCgoYSxiKSA9PiBhIC0gYilcblxuICAgICAgICAvLyBnZXQgbnVtYmVyIHRvIHBhcmVcbiAgICAgICAgY29uc3QgbWFwTGVuZ3RoID0gbWFwa2V5cy5sZW5ndGgsXG4gICAgICAgICAgICBwYXJlY291bnQgPSBtYXBMZW5ndGggLSBtYXhcblxuICAgICAgICAvLyBkaXN0cmlidXRlIHBhcmluZyBwcm9wb3J0aW9uYWxseSBhdCBmcm9udCBhbmQgYmFja1xuICAgICAgICBjb25zdCBoZWFkaW5kZXggPSBjcmFkbGVJbmRleExpc3RbMF0sXG4gICAgICAgICAgICB0YWlsaW5kZXggPSBjcmFkbGVJbmRleExpc3RbbW9kZWxMZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGhlYWRwb3MgPSBtYXBrZXlzLmluZGV4T2YoaGVhZGluZGV4KSxcbiAgICAgICAgICAgIHRhaWxwb3MgPSBtYXBrZXlzLmluZGV4T2YodGFpbGluZGV4KVxuXG4gICAgICAgIGNvbnN0IGhlYWRyb29tID0gaGVhZHBvcyxcbiAgICAgICAgICAgIHRhaWxyb29tID0gbWFwTGVuZ3RoIC0gKHRhaWxwb3MgKyAxKSxcbiAgICAgICAgICAgIHBhcmVyb29tID0gaGVhZHJvb20gKyB0YWlscm9vbVxuXG4gICAgICAgIGNvbnN0IGhlYWRwYXJlY291bnQgPSBNYXRoLmZsb29yKChoZWFkcm9vbS9wYXJlcm9vbSkqcGFyZWNvdW50KSxcbiAgICAgICAgICAgIHRhaWxwYXJlY291bnQgPSBwYXJlY291bnQgLSBoZWFkcGFyZWNvdW50XG5cbiAgICAgICAgLy8gY29sbGVjdCBpbmRleGVzIHRvIHBhcmVcbiAgICAgICAgY29uc3QgaGVhZGxpc3QgPSBtYXBrZXlzLnNsaWNlKDAsaGVhZHBhcmVjb3VudCksXG4gICAgICAgICAgICB0YWlsbGlzdCA9IG1hcGtleXMuc2xpY2UobWFwTGVuZ3RoIC0gdGFpbHBhcmVjb3VudClcblxuICAgICAgICBjb25zdCBkZWxMaXN0ID0gWy4uLmhlYWRsaXN0LC4uLnRhaWxsaXN0XVxuXG4gICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoY2FjaGVNYXgsIGNyYWRsZUxpc3RMZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTikgPT4ge1xuXG4gICAgICAgIGlmICghY2FjaGVNYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHBvcnRhbE1hcCxcbiAgICAgICAgICAgIHJlcXVlc3RlZFNldCBcbiAgICAgICAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGNyYWRsZUxpc3RMZW5ndGgsIGNhY2hlTWF4KVxuXG4gICAgICAgIGlmICgocG9ydGFsTWFwLnNpemUgKyByZXF1ZXN0ZWRTZXQuc2l6ZSkgPD0gKChtYXgpICogTUFYX0NBQ0hFX09WRVJfUlVOKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcmVsb2FkIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHJlbG9hZChmaW5hbENhbGxiYWNrLCBudWxsSXRlbVNldE1heExpc3RzaXplLCBzY3JvbGxlcklEKSB7XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQYXJhbWV0ZXJzIH0gPSB0aGlzXG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlclByb3BlcnRpZXNSZWYgfSA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCB7IHN0YXRlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGdldEl0ZW0sIGNhY2hlTWF4IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgeyBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuXG4gICAgICAgIGxldCBjYWNoZVNpemUgPSBjYWNoZU1heCA/PyAwXG5cbiAgICAgICAgY2FjaGVTaXplID0gTWF0aC5taW4oY2FjaGVTaXplLCBsaXN0c2l6ZSlcblxuICAgICAgICBjb25zdCBwcmVsb2Fkc2l6ZSA9IFxuICAgICAgICAgICAgY2FjaGVTaXplP1xuICAgICAgICAgICAgICAgIGNhY2hlU2l6ZTpcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZVxuXG4gICAgICAgIGNvbnN0IGJyZWFrbG9vcCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6ZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heExpc3RzaXplSW50ZXJydXB0ID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICBicmVha2xvb3AuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucHJlbG9hZEluZGV4Q2FsbGJhY2tcbiAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbmRleFRvSXRlbUlETWFwID0gdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXBcblxuICAgICAgICAgICAgY29uc3QgeyBwcmVsb2FkSW5kZXhDYWxsYmFjaywgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByZWxvYWRzaXplOyBpbmRleCsrKSB7XG5cbiAgICAgICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjayAmJiBwcmVsb2FkSW5kZXhDYWxsYmFjayhpbmRleClcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnByZWxvYWRJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySURcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYnJlYWtsb29wLmN1cnJlbnQpIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpLnRoZW4oXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICAgICAgICAgIGZpbmFsQ2FsbGJhY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09WyBTTkFQU0hPVFMgXT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGdldENhY2hlSW5kZXhNYXAoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXApXG5cbiAgICB9XG5cbiAgICBnZXRDcmFkbGVJbmRleE1hcChjcmFkbGVJbmRleExpc3QpIHtcblxuICAgICAgICBjb25zdCBjcmFkbGVNYXAgPSBuZXcgTWFwKCksXG4gICAgICAgICAgICB7IGluZGV4VG9JdGVtSURNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgICAgIGNyYWRsZU1hcC5zZXQoaW5kZXgsIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyYWRsZU1hcFxuXG4gICAgfVxuXG4gICAgZ2V0Q2FjaGVJdGVtTWFwKCkge1xuXG4gICAgICAgIGNvbnN0IGNhY2hlbGlzdCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIH0gPSB2YWx1ZVxuXG4gICAgICAgICAgICBjYWNoZWxpc3Quc2V0KGtleSx7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlbGlzdFxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gbW92ZSBpcyBjb2VyY2VkIGJ5IHNlcnZpY2VoYW5kbGVyIHRvIGJlIHdpdGhpbiBjdXJyZW50IGxpc3QgYm91bmRzXG4gICAgbW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgZnJvbWhpZ2hpbmRleCApIHtcblxuICAgICAgICBjb25zdCB7aW5kZXhUb0l0ZW1JRE1hcCxtZXRhZGF0YU1hcH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBkZWZpbmUgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCByYW5nZWFic29sdXRlaW5jcmVtZW50ID0gZnJvbWhpZ2hpbmRleCAtIGZyb21pbmRleCArIDEsXG4gICAgICAgICAgICBtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgPSB0b2luZGV4IC0gZnJvbWluZGV4LFxuICAgICAgICAgICAgdG9oaWdoaW5kZXggPSB0b2luZGV4ICsgKHJhbmdlYWJzb2x1dGVpbmNyZW1lbnQgLSAxKVxuXG4gICAgICAgIGNvbnN0IHNoaWZ0ZGlyZWN0aW9uID0gXG4gICAgICAgICAgICAobW92ZWRpcmVjdGlvbmFsaW5jcmVtZW50ID4gMCk/IC8vIG1vdmUgdXAgaW4gbGlzdFxuICAgICAgICAgICAgICAgIC0xOiAvLyBzaGlmdCBkb3duLCBtYWtlIHJvb20gZm9yIHNoaWZ0aW5naW5kZXggYWJvdmVcbiAgICAgICAgICAgICAgICAxICAgLy8gc2hpZnQgdXAsIG1ha2Ugcm9vbSBmb3Igc2hpZnRpbmdpbmRleCBiZWxvd1xuXG4gICAgICAgIGNvbnN0IG9yZGVyZWRpbmRleGxpc3QgPSBBcnJheS5mcm9tKGluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICBvcmRlcmVkaW5kZXhsaXN0LnNvcnQoKGEsYik9PmEtYilcblxuICAgICAgICBjb25zdCB0b2luZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gdG9pbmRleCksXG4gICAgICAgICAgICB0b2hpZ2hpbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHRvaGlnaGluZGV4KSxcbiAgICAgICAgICAgIGZyb21pbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IGZyb21pbmRleCksXG4gICAgICAgICAgICBmcm9taGlnaGluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gZnJvbWhpZ2hpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIGNhcHR1cmUgaW5kZXggZGF0YSB0byBtb3ZlIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgcHJvY2Vzc3RvbW92ZUxpc3RcbiAgICAgICAgaWYgKChmcm9taW5kZXhwdHIgPT0gLTEpICYmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSkgeyAvLyBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgfSBlbHNlIGlmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSB7IC8vIHNjb3BlIGlzIHBhcnRpYWxseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taW5kZXhwdHIpXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc2NvcGUgaXMgZW50aXJlbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWluZGV4cHRyLCBmcm9taGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc3RvbW92ZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBjYXB0dXJlbW92ZWluZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3N0b21vdmVMaXN0LmZvckVhY2goY2FwdHVyZW1vdmVpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGdldCBsaXN0IG9mIGluZGV4ZXMgdG8gc2hpZnQgb3V0IG9mIHRoZSB3YXkgLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICBsZXQgcHJvY2Vzc3Rvc2hpZnRMaXN0XG4gICAgICAgIGlmIChzaGlmdGRpcmVjdGlvbiA9PSAxKSB7IC8vIGJsb2NrIGlzIG1vdmluZyBkb3duLCBzaGlmdCBpcyB1cDsgdG9pbmRleCA8IGZyb21pbmRleFxuXG4gICAgICAgICAgICBpZiAoKHRvaW5kZXhwdHIgPT0gLTEpICYmIChmcm9taW5kZXhwdHIgPT0gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21pbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2luZGV4cHRyKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2luZGV4cHRyLCBmcm9taW5kZXhwdHIpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBzaGlmdGRpcmVjdGlvbiA9PSAtMTsgYmxvY2sgaXMgbW92aW5nIHVwLCBzaGlmdCBpcyBkb3duOyBmcm9taW5kZXggPCB0b2luZGV4XG5cbiAgICAgICAgICAgIGlmICh0b2hpZ2hpbmRleHB0ciA9PSAtMSAmJiBmcm9taGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvaGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taGlnaGluZGV4cHRyICsgMSwgdG9oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hpZnRkaXJlY3Rpb24gPT0gMSkgcHJvY2Vzc3Rvc2hpZnRMaXN0LnJldmVyc2UoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIG1vdmUgaW5kZXhlcyBvdXQgb2YgdGhlIHdheSAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZHNoaWZ0TGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IHByb2Nlc3NzaGlmdGluZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IFxuICAgICAgICAgICAgICAgIChzaGlmdGRpcmVjdGlvbiA9PSAtMSk/XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC0gcmFuZ2VhYnNvbHV0ZWluY3JlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKyByYW5nZWFic29sdXRlaW5jcmVtZW50XG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIHByb2Nlc3NlZHNoaWZ0TGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QuZm9yRWFjaChwcm9jZXNzc2hpZnRpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gcmVwbGFjZSBzaGlmdGVkIGluZGV4IHNwYWNlIHdpdGggbW92ZWQgaW5kZXhlcyAtLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkbW92ZUxpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzbW92ZWluZGV4ID0gKGl0ZW1JRCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyBtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgLy8gc3dhcFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkbW92ZUxpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5mb3JFYWNoKHByb2Nlc3Ntb3ZlaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS1yZXR1cm4gbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlcyB0byBjYWxsZXIgLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIHN5bmNocm5pemF0aW9uIHdpdGggY3JhZGxlIGNlbGxGcmFtZXNcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleGVzID0gWy4uLnByb2Nlc3NlZHNoaWZ0TGlzdCwuLi5wcm9jZXNzZWRtb3ZlTGlzdF1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhlc1xuXG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0IG9yIHJlbW92ZSBpbmRleGVzOiBtdWNoIG9mIHRoaXMgZGVhbHMgd2l0aCB0aGUgZmFjdCB0aGF0IHRoZSBjYWNoZSBpcyBzcGFyc2UuXG4gICAgaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIGhpZ2hyYW5nZSwgaW5jcmVtZW50LCBsaXN0c2l6ZSkgeyAvLyBpbmNyZW1lbnQgaXMgKzEgb3IgLTFcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAsIG1ldGFkYXRhTWFwLCBwb3J0YWxNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gZGVmaW5lIHJhbmdlIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaGlnaCByYW5nZSBpcyB0aGUgaGlnaGVzdCBpbmRleCBudW1iZXIgb2YgdGhlIGluc2VydC9yZW1vdmUgb3BlcmF0aW9uXG4gICAgICAgIGxldCBoaWdocmFuZ2VpbmRleCA9IGhpZ2hyYW5nZSA/PyAwXG5cbiAgICAgICAgaGlnaHJhbmdlaW5kZXggPSBcbiAgICAgICAgICAgIChoaWdocmFuZ2VpbmRleCA+IGluZGV4KT9cbiAgICAgICAgICAgICAgICBoaWdocmFuZ2VpbmRleDpcbiAgICAgICAgICAgICAgICBpbmRleFxuXG4gICAgICAgIGNvbnN0IGVtcHR5cmV0dXJuID0gW1tdLFtdLDBdXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gLTEpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZhbCBtdXN0IGJlIGVudGlyZWx5IHdpdGhpbiBzY29wZSBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgaWYgKGhpZ2hyYW5nZWluZGV4ID4gKGxpc3RzaXplIC0gMSkpIHJldHVybiBlbXB0eXJldHVyblxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIGNhbiBhdCBtb3N0IHN0YXJ0IGF0IHRoZSBuZXh0IGluZGV4IGFib3ZlIHRoZSBjdXJyZW50IGxpc3RcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGxpc3RzaXplKSByZXR1cm4gZW1wdHlyZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFuZ2Vjb3VudCBpcyB0aGUgYWJzb2x1dGUgbnVtYmVyIGluIHRoZSBpbnNlcnQvcmVtb3ZlIHJhbmdlIC0gY29udGlndW91c1xuICAgICAgICBjb25zdCByYW5nZWNvdW50ID0gaGlnaHJhbmdlaW5kZXggLSBpbmRleCArIDFcblxuICAgICAgICAvLyByYW5nZSBpbmNyZW1lbnQgYWRkcyBzaWduIHRvIHJhbmdlY291bnQgdG8gaW5kaWNhdGUgYWRkL3JlbW92ZVxuICAgICAgICBjb25zdCByYW5nZWluY3JlbWVudCA9IHJhbmdlY291bnQgKiBpbmNyZW1lbnRcblxuICAgICAgICAvLyBoaWdoUHRyLCBsb3dQdHIsIHNocmlua3RvUHRyIHdpdGhpbiBvcmRlcmVkSW5kZXhMaXN0LlxuICAgICAgICBjb25zdCBvcmRlcmVkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShpbmRleFRvSXRlbUlETWFwLmtleXMoKSlcbiAgICAgICAgb3JkZXJlZEluZGV4TGlzdC5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBkZWZpbmUgYm91bmRhcmllcyB3aXRoaW4gb3JkZXJlZCBjYWNoZSBpbmRleCBsaXN0IC0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBQdHIgPSBpbmRleCBpbnRvIGFycmF5LCBhcyBvcHBvc2VkIHRvIGluZGV4IG9mIHZpcnR1YWwgbGlzdFxuXG4gICAgICAgIC8vIHNocmlua3B0ciBpcyB0aGUgbG9jYXRpb24gb2YgdGhlIGJvdHRvbSBvZiB0aGUgc2hyaW5rIHJhbmdlIGZvciByZW1vdmFsc1xuICAgICAgICBsZXQgc2hyaW5rdG9JbmRleCA9IG51bGxcbiAgICAgICAgbGV0IHNocmlua3RvUHRyID0gLSAxXG4gICAgICAgIFxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IC0gMSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gb3JkZXJlZEluZGV4TGlzdC5hdCgtMSkgKyAocmFuZ2VpbmNyZW1lbnQpXG5cbiAgICAgICAgICAgIHNocmlua3RvSW5kZXggPSBNYXRoLm1heChoaWdocmFuZ2VpbmRleCArIChyYW5nZWluY3JlbWVudCksIHNocmlua3RvSW5kZXgpXG5cbiAgICAgICAgICAgIHNocmlua3RvSW5kZXggPSBNYXRoLm1pbihsaXN0c2l6ZSAtIDEsc2hyaW5rdG9JbmRleCkgXG5cbiAgICAgICAgICAgIHNocmlua3RvUHRyID0gb3JkZXJlZEluZGV4TGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gc2hyaW5rdG9JbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG93UHRyIGFuZCBoaWdoUHRyIG11c3QgYmUgd2l0aGluIGxvdyBhbmQgaGlnaCByYW5nZVxuICAgICAgICBjb25zdCBsb3dQdHIgPSBvcmRlcmVkSW5kZXhMaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPj0gaW5kZXgpICYmICh2YWx1ZSA8PSBoaWdocmFuZ2VpbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHJldmVyc2VJbmRleExpc3QgPSBBcnJheS5mcm9tKG9yZGVyZWRJbmRleExpc3QpXG4gICAgICAgIHJldmVyc2VJbmRleExpc3QucmV2ZXJzZSgpXG4gICAgICAgIGxldCBoaWdoUHRyID0gcmV2ZXJzZUluZGV4TGlzdC5maW5kSW5kZXgodmFsdWU9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8PSBoaWdocmFuZ2VpbmRleFxuXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChoaWdoUHRyICE9IC0xKSB7XG4gICAgICAgICAgICBoaWdoUHRyID0gKG9yZGVyZWRJbmRleExpc3QubGVuZ3RoIC0gMSkgLSBoaWdoUHRyXG4gICAgICAgICAgICBpZiAoaGlnaFB0ciA8IGxvd1B0cikgaGlnaFB0ciA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBsaXN0IGluZGV4ZXMgdG8gcHJvY2VzcywgcmVwbGFjZSwgYW5kIHJlbW92ZSwgYW5kIGl0ZW1zIHRvIHJlbW92ZSAtLS0tLS0tLVxuXG4gICAgICAgIGxldCBpbmRleGVzVG9Qcm9jZXNzTGlzdCwgLy8gZm9yIGVpdGhlciBpbnNlcnQgb3IgcmVtb3ZlXG4gICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IFtdLCAvLyBmb3IgaW5zZXJ0IHRoZSByYW5nZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlTGlzdCA9IFtdLCAvLyBmb3IgcmVtb3ZlIC0gZW5kIG9mIGxpc3Q7IHRoZSBsaXN0IGlzIHNocmlua2luZ1xuICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3Q9IFtdLCAvLyBmb3IgcmVtb3ZlIC0gd2l0aGluIHRoZSByYW5nZSBvZiBpbmRleGVzIGJlaW5nIHJlbW92ZWRcbiAgICAgICAgICAgIGl0ZW1zVG9SZW1vdmVMaXN0ID0gW10gLy8gZm9yIHJlbW92ZSwgZGVyaXZlZCBmcm9tIHRoZSBwcmV2aW91c1xuXG4gICAgICAgIC8vIGdldCBpbmRleGVzVG9Qcm9jZXNzTGlzdFxuICAgICAgICBpZiAoKGxvd1B0ciA9PSAtMSkgJiYgKGhpZ2hQdHIgPT0gLTEpKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBbXVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGNvcmUgc2NvcGUgaXMgcGFydGlhbGx5IG9yIGZ1bGx5IGluIHZpZXc7IGxvd1B0ciBpcyBhdmFpbGFibGVcblxuICAgICAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyKVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hQdHIgPT0gLTEpIHsgLy8gaW5jcmVtZW50ID09IC0xOyBsb3dQdHIgaXMgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGluY3JlbWVudCA9PSAtMTsgbG93UHRyIGFuZCBoaWdoUHRyIGFyZSBhdmFpbGFibGVcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShoaWdoUHRyICsgMSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3J0YWxIb2xkTGlzdCA9IFtdIC8vIGhvbGQgcG9ydGFscyBmb3IgZGVsZXRpb24gdW50aWwgYWZ0ZXIgYWZ0ZXIgY3JhZGxlIHN5bmNoXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzVG9SZXBsYWNlTGlzdFxuICAgICAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIsIGhpZ2hQdHIgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBpZiAoc2hyaW5rdG9QdHIgPT0gLTEpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShzaHJpbmt0b1B0ciArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIsIGhpZ2hQdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBpdGVtc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgaXRlbXNUb1JlbW92ZUxpc3QucHVzaChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gY29uZHVjdCBjYWNoZSBvcGVyYXRpb25zIC0tLS0tLS0tLS1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgaGlnaGVyIGZyb20gdG9wIG9mIGxpc3QgdG8gcHJlc2VydmUgbG93ZXIgdmFsdWVzIGZvciBzdWJzZXF1ZW50IGluY3JlbWVudFxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIGluZGV4ZXNUb1Byb2Nlc3NMaXN0LnJldmVyc2UoKSBcblxuICAgICAgICBjb25zdCBpbmRleGVzTW9kaWZpZWRMaXN0ID0gW11cblxuICAgICAgICAvLyBtb2RpZnkgaW5kZXgtdG8taXRlbWlkIG1hcCwgYW5kIG1ldGFkYXRhIG1hcFxuICAgICAgICBjb25zdCBwcm9jZXNzSW5kZXggPSBpbmRleCA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBpbmRleCArIHJhbmdlaW5jcmVtZW50XG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKS5pbmRleCA9IG5ld0luZGV4XG4gICAgICAgICAgICBpbmRleGVzTW9kaWZpZWRMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0LmZvckVhY2gocHJvY2Vzc0luZGV4KVxuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1haW5pbmcgaW5kZXhlcyBhbmQgaXRlbXMgbm93IGR1cGxpY2F0ZXNcblxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzVG9SZXBsYWNlTGlzdCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzVG9SZW1vdmVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW1JRCBvZiBpdGVtc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgICAgICAgICBwb3J0YWxIb2xkTGlzdC5wdXNoKGl0ZW1JRClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0gcmV0dXJucyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXR1cm4gdmFsdWVzIGZvciBjYWxsZXIgdG8gc2VuZCB0byBjb250ZW50aGFuZGxlciBmb3IgY3JhZGxlIHN5bmNocm9uaXphdGlvblxuICAgICAgICByZXR1cm4gW2luZGV4ZXNNb2RpZmllZExpc3QsIGluZGV4ZXNUb1JlcGxhY2VMaXN0LCByYW5nZWluY3JlbWVudCwgcG9ydGFsSG9sZExpc3RdXG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5ESVZJRFVBTCBQT1JUQUwgTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdXNlZCBmb3Igc2l6ZSBjYWxjdWxhdGlvbiBpbiBwYXJlQ2FjaGVUb01heFxuICAgIC8vIHJlZ2lzdGVycyBpbmRleGVzIHdoZW4gcmVxdWVzdGVkIGJ1dCBiZWZvcmUgcmV0cmlldmVkIGFuZCBlbnRlcmVkIGludG8gY2FjaGVcbiAgICByZWdpc3RlclJlcXVlc3RlZFBvcnRhbChpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuYWRkKGluZGV4KVxuXG4gICAgfVxuXG4gICAgcmVtb3ZlUmVxdWVzdGVkUG9ydGFsKGluZGV4KSB7XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldC5kZWxldGUoaW5kZXgpXG5cbiAgICB9XG5cbiAgICBnZXROZXdJdGVtSUQoKSB7XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbEl0ZW1JRCsrXG5cbiAgICB9XG5cbiAgICAvLyBnZXQgbmV3IG9yIGV4aXN0aW5nIGl0ZW1JRCBmb3IgY29udGVudGZ1bmN0aW9ucy5jcmVhdGVDZWxsRnJhbWVcbiAgICBnZXROZXdPckV4aXN0aW5nSXRlbUlEKGluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCBpdGVtSUQgPSBcbiAgICAgICAgICAgIChpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpP1xuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KTpcbiAgICAgICAgICAgICAgICAodGhpcy5nZXROZXdJdGVtSUQoKSlcblxuICAgICAgICByZXR1cm4gaXRlbUlEXG5cbiAgICB9XG5cbiAgICAgLy8gY3JlYXRlIG5ldyBwb3J0YWxcbiAgICBjcmVhdGVQb3J0YWwoY29tcG9uZW50LCBpbmRleCwgaXRlbUlELCBpc1ByZWxvYWQgPSBmYWxzZSkge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlUmVxdWVzdGVkUG9ydGFsKGluZGV4KVxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0LCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIG9yaWVudGF0aW9uIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBwb3J0YWxOb2RlID0gY3JlYXRlUG9ydGFsTm9kZShcbiAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgpXG5cbiAgICAgICAgLy8gZGl2IHdyYXBwZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBvcnRhbE1hcC5zZXQoaXRlbUlELFxuICAgICAgICAgICAgICAgIDxkaXYgZGF0YS10eXBlID0gJ3BvcnRhbHdyYXBwZXInIGtleSA9IHtpdGVtSUR9IGRhdGEtaXRlbWlkID0ge2l0ZW1JRH0gZGF0YS1pbmRleCA9IHtpbmRleH0+XG4gICAgICAgICAgICAgICAgICAgIDxJblBvcnRhbCBrZXkgPSB7aXRlbUlEfSBub2RlID0ge3BvcnRhbE5vZGV9ID4geyBjb21wb25lbnQgfSA8L0luUG9ydGFsPlxuICAgICAgICAgICAgICAgIDwvZGl2PilcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgY29uc3QgcG9ydGFsTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBwb3J0YWxOb2RlLFxuICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjp7XG4gICAgICAgICAgICAgICAgY3VycmVudDpmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGl0ZW1JRCxcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5zZXQoaXRlbUlELCBwb3J0YWxNZXRhZGF0YSlcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgaWYgKCFpc1ByZWxvYWQpIHRoaXMucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgcmV0dXJuIHBvcnRhbE1ldGFkYXRhXG5cbiAgICB9XG5cbiAgICAvLyB1c2VkIGZvciBwcmVsb2FkaW5nIG5ldyBpdGVtXG4gICAgcHJpdmF0ZSBhc3luYyBwcmVsb2FkSXRlbShcbiAgICAgICAgaW5kZXgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdCxcbiAgICAgICAgc2Nyb2xsZXJJRFxuICAgICkge1xuXG4gICAgICAgIGNvbnN0IGl0ZW1JRCA9IHRoaXMuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICBsZXQgcmV0dXJudmFsdWUsIHVzZXJjb250ZW50LCBlcnJvclxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIHVzZXJjb250ZW50ID0gYXdhaXQgZ2V0SXRlbShpbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSBudWxsKSByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBSZWFjdCBlbGVtZW50JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgIGxldCBjb250ZW50IFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIGlzUmVwYXJlbnRpbmdSZWY6bnVsbCxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQucHJvcHMuaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudCh1c2VyY29udGVudCwge3Njcm9sbGVyUHJvcGVydGllc30pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB1c2VyY29udGVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwb3J0YWxEYXRhID0gXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3J0YWwoY29udGVudCwgaW5kZXgsIGl0ZW1JRCwgdHJ1ZSkgLy8gdHJ1ZSA9IGlzUHJlbG9hZFxuICAgICAgICAgICAgLy8gbWFrZSBhdmFpbGFibGUgdG8gdXNlciBjb250ZW50XG4gICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZiA9IHBvcnRhbERhdGEuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBlcnJvcilcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IG51bGw7IGxhc3QgaXRlbSBpbiBsaXN0XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBuZXcgRXJyb3IoJ2VuZCBvZiBsaXN0JykpXG5cbiAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdChpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBhIHBvcnRhbCBsaXN0IGl0ZW1cbiAgICAvLyBhY2NlcHRzIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICBkZWxldGVQb3J0YWwoaW5kZXgsIGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuXG4gICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBcbiAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShpbmRleCkpP1xuICAgICAgICAgICAgICAgIFtpbmRleF06XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsXG4gICAgICAgICAgICBwb3J0YWxNYXAsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIFxuICAgICAgICB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgZGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgb2YgaW5kZXhBcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpKVxuXG4gICAgICAgICAgICBkZWxldGVMaXN0LnB1c2goe2luZGV4OmksaXRlbUlEfSlcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBwb3J0YWxNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGkpXG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuXG4gICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjayAmJiBkZWxldGVMaXN0Q2FsbGJhY2soZGVsZXRlTGlzdClcblxuICAgIH1cblxuICAgIC8vIHF1ZXJ5IGV4aXN0ZW5jZSBvZiBhIHBvcnRhbCBsaXN0IGl0ZW1cbiAgICBoYXNQb3J0YWwoaXRlbUlEKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5oYXMoaXRlbUlEKVxuXG4gICAgfVxuXG4gICAgZ2V0UG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1BvcnRhbChpdGVtSUQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBmdW5jdGlvbiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBnZXQgYSByZWFjdC1yZXZlcnNlLXBvcnRhbCBJblBvcnRhbCBjb21wb25lbnQsIHdpdGggaXRzIG1ldGFkYXRhXG4vLyB3aXRoIHVzZXIgY29udGVudCBhbmQgY29udGFpbmVyXG4vLyBzZWUgYWxzbyBzb21lIHN0eWxlcyBzZXQgaW4gQ2VsbEZyYW1lXG5cbmNvbnN0IGNyZWF0ZVBvcnRhbE5vZGUgPSAoaW5kZXgsIGl0ZW1JRCwgbGF5b3V0LCBvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoKSA9PiB7XG5cbiAgICBsZXQgcG9ydGFsTm9kZSA9IGNyZWF0ZUh0bWxQb3J0YWxOb2RlKClcblxuICAgIGxldCBjb250YWluZXIgPSBwb3J0YWxOb2RlLmVsZW1lbnRcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuXG4gICAgY29udGFpbmVyLmRhdGFzZXQudHlwZSA9ICdjb250ZW50ZW52ZWxvcGUnXG4gICAgY29udGFpbmVyLmRhdGFzZXQuaW5kZXggPSBpbmRleFxuICAgIGNvbnRhaW5lci5kYXRhc2V0LmNhY2hlaXRlbWlkID0gaXRlbUlEXG5cbiAgICByZXR1cm4gcG9ydGFsTm9kZVxuXG59ICAgICBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBVdGlsaXR5IGNvbXBvbmVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHBvcnRhbCBsaXN0IGNvbXBvbmVudCBmb3IgcmFwaWQgcmVsaXN0aW5nIG9mIHVwZGF0ZXMsIHVzaW5nIGV4dGVybmFsIGNhbGxiYWNrIGZvciBzZXQgc3RhdGVcbmV4cG9ydCBjb25zdCBQb3J0YWxMaXN0ID0gKHsgY2FjaGVQcm9wcyB9KSA9PiB7XG5cbiAgICBjb25zdCBbcG9ydGFsTGlzdENvdW50ZXIsIHNldFBvcnRhbExpc3RDb3VudGVyXSA9IHVzZVN0YXRlKDApXG5cbiAgICBjb25zdCBjb3VudGVyUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY291bnRlclJlZi5jdXJyZW50ID0gcG9ydGFsTGlzdENvdW50ZXJcblxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgY29uc3QgcG9ydGFsQXJyYXlSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIGNhY2hlUHJvcHMuc2V0TGlzdFN0YXRlID0gKCk9PntcblxuICAgICAgICAgICAgcG9ydGFsQXJyYXlSZWYuY3VycmVudCA9IGNhY2hlUHJvcHMucG9ydGFsTGlzdFxuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRQb3J0YWxMaXN0Q291bnRlcigrK2NvdW50ZXJSZWYuY3VycmVudCkgLy8gZm9yY2UgcmVuZGVyXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKSBcblxuICAgIHJldHVybiBwb3J0YWxBcnJheVJlZi5jdXJyZW50XG5cbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxJdGVtSUQiLCJDYWNoZUhhbmRsZXIiLCJzY3JvbGxlcklEIiwic2V0TGlzdHNpemUiLCJsaXN0c2l6ZVJlZiIsInNldExpc3RTdGF0ZSIsIm1vZGlmaWVkIiwibWV0YWRhdGFNYXAiLCJNYXAiLCJyZXF1ZXN0ZWRTZXQiLCJTZXQiLCJwb3J0YWxNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwicG9ydGFsTGlzdCIsIm5ld2xpc3RzaXplIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsInBvcnRhbEluZGV4TWFwIiwiY2FjaGVQcm9wcyIsIm1hcGtleXNMaXN0IiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJhIiwiYiIsImhpZ2hlc3RpbmRleCIsImF0IiwicGFyZWxpc3QiLCJmaWx0ZXIiLCJpbmRleCIsImRlbGV0ZVBvcnRhbCIsImNsZWFyIiwicmVuZGVyUG9ydGFsTGlzdCIsInZhbHVlcyIsImNyYWRsZUluZGV4TGlzdCIsIm1hcGtleXMiLCJkZWxrZXlzIiwiaW5jbHVkZXMiLCJrZXkiLCJsZW5ndGgiLCJjYWNoZU1heCIsInVuZGVmaW5lZCIsIm1vZGVsTGVuZ3RoIiwibWF4IiwiTWF0aCIsInBvcnRhbEluZGV4TGlzdCIsInNpemUiLCJtYXBrZXlzbGlzdCIsInJlcXVlc3RlZGtleXMiLCJtYXBMZW5ndGgiLCJwYXJlY291bnQiLCJoZWFkaW5kZXgiLCJ0YWlsaW5kZXgiLCJoZWFkcG9zIiwiaW5kZXhPZiIsInRhaWxwb3MiLCJoZWFkcm9vbSIsInRhaWxyb29tIiwicGFyZXJvb20iLCJoZWFkcGFyZWNvdW50IiwiZmxvb3IiLCJ0YWlscGFyZWNvdW50IiwiaGVhZGxpc3QiLCJzbGljZSIsInRhaWxsaXN0IiwiZGVsTGlzdCIsImNyYWRsZUxpc3RMZW5ndGgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJmaW5hbENhbGxiYWNrIiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsImNyYWRsZVBhcmFtZXRlcnMiLCJzY3JvbGxlclByb3BlcnRpZXNSZWYiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJzdGF0ZUhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiZ2V0SXRlbSIsImxpc3RzaXplIiwicHJvbWlzZXMiLCJjYWNoZVNpemUiLCJtaW4iLCJwcmVsb2Fkc2l6ZSIsImJyZWFrbG9vcCIsIm1heExpc3RzaXplSW50ZXJydXB0IiwiaXNNb3VudGVkUmVmIiwiY2FsbGJhY2tzIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJoYXMiLCJwcm9taXNlIiwicHJlbG9hZEl0ZW0iLCJwdXNoIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJ0aGVuIiwiY3JhZGxlTWFwIiwic2V0IiwiZ2V0IiwiY2FjaGVsaXN0IiwidmFsdWUiLCJjb21wb25lbnQiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiZnJvbWhpZ2hpbmRleCIsInJhbmdlYWJzb2x1dGVpbmNyZW1lbnQiLCJtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQiLCJ0b2hpZ2hpbmRleCIsInNoaWZ0ZGlyZWN0aW9uIiwib3JkZXJlZGluZGV4bGlzdCIsInRvaW5kZXhwdHIiLCJmaW5kSW5kZXgiLCJ0b2hpZ2hpbmRleHB0ciIsImZyb21pbmRleHB0ciIsImZyb21oaWdoaW5kZXhwdHIiLCJwcm9jZXNzdG9tb3ZlTGlzdCIsInByb2Nlc3N0b21vdmVNYXAiLCJjYXB0dXJlbW92ZWluZGV4IiwiZm9yRWFjaCIsInByb2Nlc3N0b3NoaWZ0TGlzdCIsInJldmVyc2UiLCJwcm9jZXNzZWRzaGlmdExpc3QiLCJwcm9jZXNzc2hpZnRpbmRleCIsIml0ZW1JRCIsIm5ld0luZGV4IiwicHJvY2Vzc2VkbW92ZUxpc3QiLCJwcm9jZXNzbW92ZWluZGV4IiwicHJvY2Vzc2VkSW5kZXhlcyIsImhpZ2hyYW5nZSIsImluY3JlbWVudCIsImhpZ2hyYW5nZWluZGV4IiwiZW1wdHlyZXR1cm4iLCJyYW5nZWNvdW50IiwicmFuZ2VpbmNyZW1lbnQiLCJvcmRlcmVkSW5kZXhMaXN0Iiwic2hyaW5rdG9JbmRleCIsInNocmlua3RvUHRyIiwibG93UHRyIiwicmV2ZXJzZUluZGV4TGlzdCIsImhpZ2hQdHIiLCJpbmRleGVzVG9Qcm9jZXNzTGlzdCIsImluZGV4ZXNUb1JlcGxhY2VMaXN0IiwiaW5kZXhlc1RvUmVtb3ZlTGlzdCIsImluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0IiwiaXRlbXNUb1JlbW92ZUxpc3QiLCJwb3J0YWxIb2xkTGlzdCIsImluZGV4ZXNNb2RpZmllZExpc3QiLCJwcm9jZXNzSW5kZXgiLCJhZGQiLCJnZXROZXdJdGVtSUQiLCJpc1ByZWxvYWQiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJsYXlvdXQiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwib3JpZW50YXRpb24iLCJwb3J0YWxOb2RlIiwiY3JlYXRlUG9ydGFsTm9kZSIsInJlYWN0XzEiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsInBvcnRhbE1ldGFkYXRhIiwiaXNSZXBhcmVudGluZ1JlZiIsInVzZXJjb250ZW50IiwicmV0dXJudmFsdWUiLCJlcnJvciIsImlzVmFsaWRFbGVtZW50IiwiRXJyb3IiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsImhhc093blByb3BlcnR5IiwiY29udGVudCIsImNsb25lRWxlbWVudCIsInBvcnRhbERhdGEiLCJjcmVhdGVQb3J0YWwiLCJpbmRleEFycmF5IiwiaXNBcnJheSIsImRlbGV0ZUxpc3QiLCJpIiwiaGFzUG9ydGFsIiwiZXhwb3J0cyIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzdHlsZSIsIm92ZXJmbG93IiwiZGF0YXNldCIsInR5cGUiLCJjYWNoZWl0ZW1pZCIsIlBvcnRhbExpc3QiLCJwb3J0YWxMaXN0Q291bnRlciIsInNldFBvcnRhbExpc3RDb3VudGVyIiwiY291bnRlclJlZiIsInBvcnRhbEFycmF5UmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/cachehandler.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// contentfunctions.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calcContentShift = exports.getShiftInstruction = exports.getContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    getContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    getShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\"));\n// ======================[ for setCradleContent ]===========================\nvar getContentListRequirements = function getContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n    baseRowLength = _ref.baseRowLength,\n    targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n    cradleInheritedProperties = _ref.cradleInheritedProperties,\n    cradleInternalProperties = _ref.cradleInternalProperties;\n  // console.log('getContentListRequirements: targetAxisReferenceIndex, baseRowLength',\n  //     targetAxisReferenceIndex, baseRowLength)\n  var padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount,\n    listRowcount = cradleInternalProperties.listRowcount,\n    listsize = cradleInternalProperties.listsize,\n    viewportVisibleRowcount = cradleInternalProperties.viewportVisibleRowcount;\n  // align axis reference to first row item\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount;\n  // derive target row\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  var maxAxisRowOffset = Math.max(0, listRowcount - viewportVisibleRowcount);\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  }\n  // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount);\n  // trailing edge\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount;\n  // ---------------------[ calc cradle content count ]---------------------\n  var newCradleContentCount = cradleRowcount * crosscount;\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  }\n  // --------------------[ calc css positioning ]-----------------------\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * baseRowLength + padding - targetAxisViewportPixelOffset;\n  // ----------------------[ return required values ]---------------------\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\nexports.getContentListRequirements = getContentListRequirements;\n// ======================[ for updateCradleContent ]===========================\n/*\n    the two triggerlines must straddle the head of the viewport (top or left) so that\n    cradle motion can be detected. Motion is most often caused by scrolling, but\n    can also occur with change of size of cradle content rows.\n\n    getShiftInstruction determines whether the axis should be moved toward the head or tail\n        to restore the straddling position of the two trigger lines. Lots of relative motion.\n\n    'axisheadward' (scrolling down or right) means moving the axis up or left, adjacent items down\n         or right to the tail, dropping trailing tail items, and adding leading head items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'axistailward' (scrolling up or left) means moving the axis down or right, adjacent items up\n         or left to the head, dropping trailing head items, and adding leading tail items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'none' means no shift is required\n*/\nvar getShiftInstruction = function getShiftInstruction(_ref2) {\n  var orientation = _ref2.orientation,\n    triggerlineEntries = _ref2.triggerlineEntries,\n    triggerlineSpan = _ref2.triggerlineSpan,\n    scrollerID = _ref2.scrollerID,\n    isFirstRowTriggerConfig = _ref2.isFirstRowTriggerConfig;\n  var triggerData = {\n    headOffset: null,\n    tailOffset: null,\n    span: triggerlineSpan,\n    isFirstRowTriggerConfig: isFirstRowTriggerConfig\n  };\n  var entry = triggerlineEntries.at(-1); // most recent; either triggerline will do\n  var referencename = entry.target.dataset.type;\n  var span = triggerlineSpan;\n  var rootpos = orientation == 'vertical' ? entry.rootBounds.y : entry.rootBounds.x;\n  var entrypos = orientation == 'vertical' ? entry.boundingClientRect.y : entry.boundingClientRect.x;\n  var viewportTriggerOffset = entrypos - rootpos;\n  if (referencename == 'headtrigger') {\n    triggerData.headOffset = viewportTriggerOffset;\n    triggerData.tailOffset = viewportTriggerOffset + span;\n  } else {\n    // tailtrigger\n    triggerData.tailOffset = viewportTriggerOffset;\n    triggerData.headOffset = viewportTriggerOffset - span;\n  }\n  var shiftinstruction;\n  if (isFirstRowTriggerConfig) {\n    if (triggerData.headOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  } else {\n    if (triggerData.tailOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else if (triggerData.headOffset >= 0) {\n      shiftinstruction = 'axisheadward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  }\n  return [shiftinstruction, triggerData];\n};\nexports.getShiftInstruction = getShiftInstruction;\n/*\n    The basic goal here is to determine the number and direction of rows to shift between\n    the head and tail grids (which determines the new location of the axis), and also to\n    calculate the rolling addition and deletion of cradle content to accommodate the changes.\n\n    The number of rows to shift is determined by the pixel shift required to restore the\n    triggerlines to their straddle configuration around the head (top or left) of the viewport.\n\n    Adjustments are made to accommodate special requirements at the start and end of the virtual list.\n\n    DOM measurements are used where available (to accommodate variable dimension rows), and standard\n    units (cellHeight, cellWidth) used for estimates where necessary.\n*/\n// rowshift is at least 1 by the time this function is reached\n// ie. a shiftinstruction of 'axisheadward' or 'axistailward'\nvar calcContentShift = function calcContentShift(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n    triggerData = _ref3.triggerData,\n    scrollPos = _ref3.scrollPos,\n    scrollblockElement = _ref3.scrollblockElement,\n    cradleInheritedProperties = _ref3.cradleInheritedProperties,\n    cradleInternalProperties = _ref3.cradleInternalProperties,\n    cradleContent = _ref3.cradleContent,\n    cradleElements = _ref3.cradleElements;\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n  var gap = cradleInheritedProperties.gap,\n    orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    layout = cradleInheritedProperties.layout;\n  var axisElement = cradleElements.axisRef.current,\n    headGridElement = cradleElements.headRef.current,\n    tailGridElement = cradleElements.tailRef.current;\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n    tailcontentlist = cradleContent.tailModelComponents;\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    listsize = cradleInternalProperties.listsize,\n    listRowcount = cradleInternalProperties.listRowcount,\n    viewportRowcount = cradleInternalProperties.viewportRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var referenceGridElement =\n  // moving axis (and triggers) toward the reference grid element\n  shiftinstruction == 'axistailward' ?\n  // scrolling up or left\n  tailGridElement : headGridElement;\n  var gridRowLengths = getGridRowLengths(referenceGridElement, orientation, crosscount, gap);\n  if (shiftinstruction == 'axisheadward') {\n    // scrolling down or right; move triggerlines up or left\n    gridRowLengths.reverse(); // head row lengths listed from axis toward head\n  }\n\n  var gridRowSpans = getGridRowSpans(gridRowLengths);\n  var triggerViewportReferencePos = shiftinstruction == 'axistailward' ?\n  // block scrolling up or left\n  triggerData.tailOffset :\n  // needs to move down or right toward tail\n  triggerData.headOffset; // needs to move up or left toward head\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0,\n    previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0,\n    previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n  // ----------------------------[ 2. calculate base row shift ]--------------------------\n  var spanRowPtr;\n  if (shiftinstruction == 'axistailward') {\n    // scroll up\n    // tail trigger needs to move down or right until position relative to viewport top or left is positive\n    spanRowPtr = gridRowSpans.findIndex(function (movementspan) {\n      return triggerViewportReferencePos + movementspan >= 0;\n    });\n  } else {\n    // 'axisheadward', scrolldown\n    // head trigger needs to move up or left until position relative to viewport top or left is negative\n    spanRowPtr = gridRowSpans.findIndex(function (movementspan) {\n      return triggerViewportReferencePos - movementspan <= 0;\n    });\n  }\n  var listEndrowOffset = listRowcount - 1;\n  var spanAxisPixelShift; // in relation to viewport head boundary\n  if (spanRowPtr == -1) {\n    // overshoot of instantiated rows; continue with virtual rows\n    var notionalRowPtr;\n    if (gridRowSpans.length == 0) {\n      // must be list boundary\n      // notionalRowPtr = 0\n      notionalRowPtr = -1; // \"not found\"\n      spanAxisPixelShift = 0;\n    } else {\n      var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      notionalRowPtr = gridRowSpans.length - 1; // base: failed measured row ptr\n      var totalPixelShift = gridRowSpans[notionalRowPtr]; // set base of working overshoot\n      if (shiftinstruction == 'axistailward') {\n        // scrolling up \n        do {\n          totalPixelShift += baseRowLength;\n          notionalRowPtr++;\n        } while (triggerViewportReferencePos + totalPixelShift < 0);\n        spanAxisPixelShift = totalPixelShift;\n      } else {\n        // axisheadward; scrolling down\n        do {\n          totalPixelShift += baseRowLength;\n          notionalRowPtr++;\n          if (previousAxisRowOffset - notionalRowPtr == 0) {\n            // stop cycling at head limit\n            // accommodate isFirstRowTriggerConfig exception in placing trigger lines\n            // in first row after axis, rather than first row before axis\n            notionalRowPtr -= 1;\n            totalPixelShift -= baseRowLength;\n            break;\n          }\n        } while (triggerViewportReferencePos - totalPixelShift > 0);\n        spanAxisPixelShift = -totalPixelShift;\n      }\n    }\n    spanRowPtr = notionalRowPtr;\n  } else {\n    // final values found in instantiated rows\n    spanAxisPixelShift = shiftinstruction == 'axistailward' ? gridRowSpans[spanRowPtr] :\n    // move axis toward tail from viewport boundary (positive)\n    -gridRowSpans[spanRowPtr]; // move axis toward head from viewport boundary (negative)\n  }\n\n  var spanRowShift =\n  // pick up row shift with or without overshoot\n  shiftinstruction == 'axistailward' ? spanRowPtr + 1 : -(spanRowPtr + 1);\n  // the following two values, and no other calcs, are carried forward in the function.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n  var axisReferenceRowShift = spanRowShift;\n  var axisPixelShift = spanAxisPixelShift;\n  // -----------[ 3. calculate current viewport axis offset ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n  var scrollblockAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockOffset =\n  // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n  // currentViewportAxisOffset will be negative (above viewport edge) for scroll block headward \n  //     and positive for scroll block tailward\n  // the pixel distance between the viewport frame and the axis, toward the head\n  var currentViewportAxisOffset = scrollblockAxisOffset + scrollblockOffset - scrollPos;\n  // -------------[ 4. calculate new axis pixel position ]------------------\n  var newAxisViewportPixelOffset = currentViewportAxisOffset + axisPixelShift;\n  // Note: sections 5, 6 and 7 deal entirely with row calculations; no pixels\n  // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n  var cradleReferenceRowshift = axisReferenceRowShift;\n  // base values\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowShift;\n  // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n  if (shiftinstruction == 'axistailward') {\n    // scrolling toward head\n    // a. if scrolling the block headward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling the block headward (revealing tail of list), as the cradle last row offset \n    // approaches max listrow, new cradle offset and cradle row shift have to be adjusted to prevent \n    // shortening of cradle content.\n    // --- start of list adjustment\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1); // extra row for visibility\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    }\n    // --- end of list adjustment: case of being in bounds of trailing runway (end of list)\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n    if (tailrowdiff > 0) {\n      newCradleReferenceRowOffset -= tailrowdiff;\n      cradleReferenceRowshift -= tailrowdiff;\n      targetCradleEndrowOffset -= tailrowdiff;\n    }\n  } else {\n    // shiftinstruction == 'axisheadward'; scrolling toward tail \n    // c. if scrolling the block tailward (toward revealing head of list), as the cradlerowoffset \n    // hits 0, cradle changes have to be adjusted to prevent shortening of cradle content\n    // d. if scrolling headward near the end of the list, cradle changes have to be adjusted to \n    // accomodate the trailing runway\n    // --- start of list adjustment\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    }\n    // --- end of list adjustment; case of in bounds of trailing runway\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n    var _targetCradleEndrowOffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n    var _tailrowdiff = Math.max(0, _targetCradleEndrowOffset - computedNextCradleEndrowOffset);\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset += _tailrowdiff;\n    }\n  }\n  // ----------------------[ 7. map rows to item references ]----------------------\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowShift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  }\n  // create head and tail change counts\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount;\n  // ---------------------[ 8. return required values ]-------------------\n  return {\n    newCradleReferenceIndex: newCradleReferenceIndex,\n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisViewportPixelOffset: newAxisViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\nexports.calcContentShift = calcContentShift;\n// supports calcContentShift above\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n  return rowLengths;\n};\n// supports calcContentShift above\nvar getGridRowSpans = function getGridRowSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n};\n// =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n    cradleInternalProperties = _ref4.cradleInternalProperties,\n    cacheHandler = _ref4.cacheHandler,\n    cradleContentCount = _ref4.cradleContentCount,\n    cradleReferenceIndex = _ref4.cradleReferenceIndex,\n    listStartChangeCount = _ref4.listStartChangeCount,\n    listEndChangeCount = _ref4.listEndChangeCount,\n    contentlist = _ref4.workingContentList,\n    instanceIdCounterRef = _ref4.instanceIdCounterRef,\n    styles = _ref4.styles;\n  var localContentlist = _toConsumableArray(contentlist);\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n    tailContentlist = [];\n  var deletedtailitems = [],\n    deletedheaditems = [];\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    for (var newindex = cradleReferenceIndex - listStartChangeCount; newindex < cradleReferenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    for (var _newindex = lastindexoffset + 1; _newindex < lastindexoffset + 1 + listEndChangeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\nexports.getCellFrameComponentList = getCellFrameComponentList;\n// Leading (head) all or partially hidden; tail, visible plus trailing hidden\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n    axisReferenceIndex = _ref5.axisReferenceIndex,\n    layoutHandler = _ref5.layoutHandler;\n  var _a;\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index,\n    highindex = offsetindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n  if (triggercellIndex !== undefined && offsetindex !== undefined) {\n    //&& \n    if (triggercellIndex >= offsetindex && triggercellIndex <= highindex) {\n      var _triggercellPtr = triggercellIndex - offsetindex;\n      var _triggercellComponent = contentlist[_triggercellPtr];\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n  var triggercellPtr = targetTriggercellIndex - offsetindex;\n  var triggercellComponent = contentlist[triggercellPtr];\n  if (triggercellComponent) {\n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    // defensive; shouldn't happen\n    console.log('FAILURE TO REGISTER TRIGGERCELL: \\n', 'triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent?.props.isTriggecell\\n', triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell, contentlist, axisReferenceIndex);\n  }\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\nexports.allocateContentList = allocateContentList;\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\nexports.deletePortals = deletePortals;\n// =====================[ internal, acquire item ]======================\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n    cradleInheritedProperties = _ref6.cradleInheritedProperties,\n    cradleInternalProperties = _ref6.cradleInternalProperties,\n    instanceIdCounterRef = _ref6.instanceIdCounterRef,\n    cacheHandler = _ref6.cacheHandler,\n    placeholderFrameStyles = _ref6.placeholderFrameStyles,\n    placeholderLinerStyles = _ref6.placeholderLinerStyles;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    cellMinHeight = cradleInheritedProperties.cellMinHeight,\n    cellMinWidth = cradleInheritedProperties.cellMinWidth,\n    getItem = cradleInheritedProperties.getItem,\n    placeholder = cradleInheritedProperties.placeholder,\n    scrollerID = cradleInheritedProperties.scrollerID,\n    layout = cradleInheritedProperties.layout,\n    usePlaceholder = cradleInheritedProperties.usePlaceholder;\n  var listsize = cradleInternalProperties.listsize;\n  // get new or existing itemID\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  // console.log('creating CellFrame','-'+index+'-','_'+instanceID+'_')\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderLinerStyles: placeholderLinerStyles,\n    usePlaceholder: usePlaceholder\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBTW9MLE1BQU0sR0FBR3hELFlBQVksQ0FBQ3lELHNCQUFzQixDQUFDOUcsS0FBSyxDQUFDO0VBRXpEO0VBRUEsT0FBT3VGLGlDQUFDd0Isc0JBQVM7SUFDYkMsR0FBRyxFQUFLVCxVQUFVO0lBQ2xCNUosV0FBVyxFQUFLQSxXQUFXO0lBQzNCNkIsVUFBVSxFQUFLQSxVQUFVO0lBQ3pCQyxTQUFTLEVBQUtBLFNBQVM7SUFDdkIrSCxhQUFhLEVBQUtBLGFBQWE7SUFDL0JDLFlBQVksRUFBS0EsWUFBWTtJQUM3Qi9ILE1BQU0sRUFBS0EsTUFBTTtJQUNqQnNCLEtBQUssRUFBS0EsS0FBSztJQUNmMEcsT0FBTyxFQUFLQSxPQUFPO0lBQ25CakwsUUFBUSxFQUFLQSxRQUFRO0lBQ3JCa0wsV0FBVyxFQUFLQSxXQUFXO0lBQzNCRSxNQUFNLEVBQUtBLE1BQU07SUFDakJOLFVBQVUsRUFBS0EsVUFBVTtJQUN6QnpKLFVBQVUsRUFBS0EsVUFBVTtJQUN6QjJJLGFBQWEsRUFBSyxLQUFLO0lBQ3ZCckIsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqREUsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqRHNDLGNBQWMsRUFBS0E7RUFBYyxFQUNuQztBQUVOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBjb250ZW50aGFuZGxlciBtb2R1bGUuIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgcGVyZm9ybVxuICAgIHRoZSBkZXRhaWxlZCBjYWxjdWxhdGlvbnMgYW5kIHByb2Nlc3NlcyByZXF1aXJlZCBieSB0aGUgY29udGVudGhhbmRsZXIuXG5cbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyBpcyBjYWxsZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyJ3Mgc2V0Q3JhZGxlQ29udGVudCBmdW5jdGlvbi5cblxuICAgIGdldFNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcbiAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50czogdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCBiYXNlUm93TGVuZ3RoJyxcbiAgICAvLyAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCBiYXNlUm93TGVuZ3RoKVxuXG4gICAgY29uc3QgeyBcbiAgICAgICAgcGFkZGluZyxcbiAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgdmlld3BvcnRWaXNpYmxlUm93Y291bnQsXG5cbiAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG4gICAgXG4gICAgLy8gYWxpZ24gYXhpcyByZWZlcmVuY2UgdG8gZmlyc3Qgcm93IGl0ZW1cbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbih0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtPSAodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudClcblxuICAgIC8vIGRlcml2ZSB0YXJnZXQgcm93XG4gICAgbGV0IHRhcmdldEF4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBtYXhBeGlzUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCxsaXN0Um93Y291bnQgLSB2aWV3cG9ydFZpc2libGVSb3djb3VudClcbiAgICBpZiAodGFyZ2V0QXhpc1Jvd09mZnNldCA+IG1heEF4aXNSb3dPZmZzZXQpIHtcbiAgICAgICAgdGFyZ2V0QXhpc1Jvd09mZnNldCA9IG1heEF4aXNSb3dPZmZzZXRcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gdGFyZ2V0QXhpc1Jvd09mZnNldCAqIGNyb3NzY291bnRcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjcmFkbGVSZWZlcmVuY2VSb3cgJiBJbmRleCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBsZWFkaW5nIGVkZ2VcbiAgICBsZXQgdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCx0YXJnZXRBeGlzUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQpXG5cbiAgICAvLyB0cmFpbGluZyBlZGdlXG4gICAgbGV0IHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA9IHRhcmdldENyYWRsZVJvd09mZnNldCArIChjcmFkbGVSb3djb3VudCAtIDEpXG5cbiAgICBjb25zdCBsaXN0RW5kUm93T2Zmc2V0ID0gKGxpc3RSb3djb3VudCAtIDEpXG5cbiAgICBpZiAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID4gKGxpc3RFbmRSb3dPZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0IC0gbGlzdEVuZFJvd09mZnNldClcbiAgICAgICAgdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0IC09IGRpZmZcbiAgICAgICAgdGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0IC09IGRpZmZcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCA9IHRhcmdldENyYWRsZVJvd09mZnNldCAqIGNyb3NzY291bnRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjcmFkbGUgY29udGVudCBjb3VudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgbmV3Q3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgaWYgKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA9PSBsaXN0RW5kUm93T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGVuZFJvd1JlbWFpbmRlckNvdW50ID0gbGlzdHNpemUgJSBjcm9zc2NvdW50XG4gICAgICAgIGlmIChlbmRSb3dSZW1haW5kZXJDb3VudCkge1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IChjcm9zc2NvdW50IC0gZW5kUm93UmVtYWluZGVyQ291bnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjc3MgcG9zaXRpb25pbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgKHRhcmdldEF4aXNSb3dPZmZzZXQgKiBiYXNlUm93TGVuZ3RoKSArIHBhZGRpbmcgLSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmV0dXJuIHJlcXVpcmVkIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LCBcbiAgICB9IFxuXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT1bIGZvciB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLypcbiAgICB0aGUgdHdvIHRyaWdnZXJsaW5lcyBtdXN0IHN0cmFkZGxlIHRoZSBoZWFkIG9mIHRoZSB2aWV3cG9ydCAodG9wIG9yIGxlZnQpIHNvIHRoYXRcbiAgICBjcmFkbGUgbW90aW9uIGNhbiBiZSBkZXRlY3RlZC4gTW90aW9uIGlzIG1vc3Qgb2Z0ZW4gY2F1c2VkIGJ5IHNjcm9sbGluZywgYnV0XG4gICAgY2FuIGFsc28gb2NjdXIgd2l0aCBjaGFuZ2Ugb2Ygc2l6ZSBvZiBjcmFkbGUgY29udGVudCByb3dzLlxuXG4gICAgZ2V0U2hpZnRJbnN0cnVjdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGF4aXMgc2hvdWxkIGJlIG1vdmVkIHRvd2FyZCB0aGUgaGVhZCBvciB0YWlsXG4gICAgICAgIHRvIHJlc3RvcmUgdGhlIHN0cmFkZGxpbmcgcG9zaXRpb24gb2YgdGhlIHR3byB0cmlnZ2VyIGxpbmVzLiBMb3RzIG9mIHJlbGF0aXZlIG1vdGlvbi5cblxuICAgICdheGlzaGVhZHdhcmQnIChzY3JvbGxpbmcgZG93biBvciByaWdodCkgbWVhbnMgbW92aW5nIHRoZSBheGlzIHVwIG9yIGxlZnQsIGFkamFjZW50IGl0ZW1zIGRvd25cbiAgICAgICAgIG9yIHJpZ2h0IHRvIHRoZSB0YWlsLCBkcm9wcGluZyB0cmFpbGluZyB0YWlsIGl0ZW1zLCBhbmQgYWRkaW5nIGxlYWRpbmcgaGVhZCBpdGVtcyBhcyBuZWNlc3NhcnlcbiAgICAgICAgIHRvIG1haW50YWluIG51bWJlciBvZiBjcmFkbGUgcm93cyBvZiBjb250ZW50IGNvbnN0YW50LlxuXG4gICAgJ2F4aXN0YWlsd2FyZCcgKHNjcm9sbGluZyB1cCBvciBsZWZ0KSBtZWFucyBtb3ZpbmcgdGhlIGF4aXMgZG93biBvciByaWdodCwgYWRqYWNlbnQgaXRlbXMgdXBcbiAgICAgICAgIG9yIGxlZnQgdG8gdGhlIGhlYWQsIGRyb3BwaW5nIHRyYWlsaW5nIGhlYWQgaXRlbXMsIGFuZCBhZGRpbmcgbGVhZGluZyB0YWlsIGl0ZW1zIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgdG8gbWFpbnRhaW4gbnVtYmVyIG9mIGNyYWRsZSByb3dzIG9mIGNvbnRlbnQgY29uc3RhbnQuXG5cbiAgICAnbm9uZScgbWVhbnMgbm8gc2hpZnQgaXMgcmVxdWlyZWRcbiovXG5cbmV4cG9ydCBjb25zdCBnZXRTaGlmdEluc3RydWN0aW9uID0gKHtcblxuICAgIG9yaWVudGF0aW9uLFxuICAgIHRyaWdnZXJsaW5lRW50cmllcyxcbiAgICB0cmlnZ2VybGluZVNwYW4sXG4gICAgc2Nyb2xsZXJJRCwgLy8gZm9yIGRlYnVnXG4gICAgXG4gICAgLy8gaXNGaXJzdFJvd1RyaWdnZXJDb25maWcgaXMgdHJ1ZSBpZiB0aGUgdHJpZ2dlcmxpbmVzIGFyZSB3aXRoIHRoZSBmaXJzdCB0YWlsIHJvdyBpbnN0ZWFkIG9mIHRoZVxuICAgIC8vIGxhc3QgaGVhZHJvdy4gVGhhdCBoYXBwZW5zICh3b3JrYXJvdW5kKSB3aGVuIHRoZXJlIGFyZSBubyBoZWFkIHJvd3NcbiAgICBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZywgXG5cbn0pID0+IHtcblxuICAgIGNvbnN0IHRyaWdnZXJEYXRhID0ge1xuICAgICAgICBoZWFkT2Zmc2V0Om51bGwsXG4gICAgICAgIHRhaWxPZmZzZXQ6bnVsbCxcbiAgICAgICAgc3Bhbjp0cmlnZ2VybGluZVNwYW4sXG4gICAgICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnXG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSB0cmlnZ2VybGluZUVudHJpZXMuYXQoLTEpIC8vIG1vc3QgcmVjZW50OyBlaXRoZXIgdHJpZ2dlcmxpbmUgd2lsbCBkb1xuICAgIGNvbnN0IHJlZmVyZW5jZW5hbWUgPSBlbnRyeS50YXJnZXQuZGF0YXNldC50eXBlXG4gICAgY29uc3Qgc3BhbiA9IHRyaWdnZXJsaW5lU3BhblxuXG4gICAgY29uc3Qgcm9vdHBvcyA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBlbnRyeS5yb290Qm91bmRzLnk6XG4gICAgICAgICAgICBlbnRyeS5yb290Qm91bmRzLnhcblxuICAgIGNvbnN0IGVudHJ5cG9zID0gXG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC55OlxuICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnhcblxuICAgIGNvbnN0IHZpZXdwb3J0VHJpZ2dlck9mZnNldCA9IGVudHJ5cG9zIC0gcm9vdHBvc1xuXG4gICAgaWYgKHJlZmVyZW5jZW5hbWUgPT0gJ2hlYWR0cmlnZ2VyJykge1xuXG4gICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXRcbiAgICAgICAgdHJpZ2dlckRhdGEudGFpbE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldCArIHNwYW5cblxuICAgIH0gZWxzZSB7IC8vIHRhaWx0cmlnZ2VyXG5cbiAgICAgICAgdHJpZ2dlckRhdGEudGFpbE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldFxuICAgICAgICB0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID0gdmlld3BvcnRUcmlnZ2VyT2Zmc2V0IC0gc3BhblxuXG4gICAgfVxuXG4gICAgbGV0IHNoaWZ0aW5zdHJ1Y3Rpb25cbiAgICBcbiAgICBpZiAoaXNGaXJzdFJvd1RyaWdnZXJDb25maWcpIHtcblxuICAgICAgICBpZiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA8PSAwKSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnYXhpc3RhaWx3YXJkJ1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnbm9uZSdcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICh0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0IDw9IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdheGlzdGFpbHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdheGlzaGVhZHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBbc2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlckRhdGFdXG5cbn1cblxuLypcbiAgICBUaGUgYmFzaWMgZ29hbCBoZXJlIGlzIHRvIGRldGVybWluZSB0aGUgbnVtYmVyIGFuZCBkaXJlY3Rpb24gb2Ygcm93cyB0byBzaGlmdCBiZXR3ZWVuXG4gICAgdGhlIGhlYWQgYW5kIHRhaWwgZ3JpZHMgKHdoaWNoIGRldGVybWluZXMgdGhlIG5ldyBsb2NhdGlvbiBvZiB0aGUgYXhpcyksIGFuZCBhbHNvIHRvXG4gICAgY2FsY3VsYXRlIHRoZSByb2xsaW5nIGFkZGl0aW9uIGFuZCBkZWxldGlvbiBvZiBjcmFkbGUgY29udGVudCB0byBhY2NvbW1vZGF0ZSB0aGUgY2hhbmdlcy5cblxuICAgIFRoZSBudW1iZXIgb2Ygcm93cyB0byBzaGlmdCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwaXhlbCBzaGlmdCByZXF1aXJlZCB0byByZXN0b3JlIHRoZSBcbiAgICB0cmlnZ2VybGluZXMgdG8gdGhlaXIgc3RyYWRkbGUgY29uZmlndXJhdGlvbiBhcm91bmQgdGhlIGhlYWQgKHRvcCBvciBsZWZ0KSBvZiB0aGUgdmlld3BvcnQuXG5cbiAgICBBZGp1c3RtZW50cyBhcmUgbWFkZSB0byBhY2NvbW1vZGF0ZSBzcGVjaWFsIHJlcXVpcmVtZW50cyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgdmlydHVhbCBsaXN0LlxuXG4gICAgRE9NIG1lYXN1cmVtZW50cyBhcmUgdXNlZCB3aGVyZSBhdmFpbGFibGUgKHRvIGFjY29tbW9kYXRlIHZhcmlhYmxlIGRpbWVuc2lvbiByb3dzKSwgYW5kIHN0YW5kYXJkXG4gICAgdW5pdHMgKGNlbGxIZWlnaHQsIGNlbGxXaWR0aCkgdXNlZCBmb3IgZXN0aW1hdGVzIHdoZXJlIG5lY2Vzc2FyeS5cbiovXG5cbi8vIHJvd3NoaWZ0IGlzIGF0IGxlYXN0IDEgYnkgdGhlIHRpbWUgdGhpcyBmdW5jdGlvbiBpcyByZWFjaGVkXG4vLyBpZS4gYSBzaGlmdGluc3RydWN0aW9uIG9mICdheGlzaGVhZHdhcmQnIG9yICdheGlzdGFpbHdhcmQnXG5leHBvcnQgY29uc3QgY2FsY0NvbnRlbnRTaGlmdCA9ICh7XG5cbiAgICBzaGlmdGluc3RydWN0aW9uLFxuICAgIHRyaWdnZXJEYXRhLFxuICAgIHNjcm9sbFBvcyxcbiAgICBzY3JvbGxibG9ja0VsZW1lbnQsXG5cbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICBjcmFkbGVDb250ZW50LFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7IFxuXG4gICAgICAgIGdhcCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50LFxuICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudFxuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czpjcmFkbGVjb250ZW50bGlzdCwgXG4gICAgICAgIHRhaWxNb2RlbENvbXBvbmVudHM6dGFpbGNvbnRlbnRsaXN0LFxuXG4gICAgfSA9IGNyYWRsZUNvbnRlbnRcblxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgY29uc3QgcmVmZXJlbmNlR3JpZEVsZW1lbnQgPSAvLyBtb3ZpbmcgYXhpcyAoYW5kIHRyaWdnZXJzKSB0b3dhcmQgdGhlIHJlZmVyZW5jZSBncmlkIGVsZW1lbnRcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpPyAvLyBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICAgICAgdGFpbEdyaWRFbGVtZW50OlxuICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50XG5cbiAgICBjb25zdCBncmlkUm93TGVuZ3RocyA9IGdldEdyaWRSb3dMZW5ndGhzKHJlZmVyZW5jZUdyaWRFbGVtZW50LCBvcmllbnRhdGlvbiwgY3Jvc3Njb3VudCwgZ2FwKVxuXG4gICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXNoZWFkd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIGRvd24gb3IgcmlnaHQ7IG1vdmUgdHJpZ2dlcmxpbmVzIHVwIG9yIGxlZnRcblxuICAgICAgICBncmlkUm93TGVuZ3Rocy5yZXZlcnNlKCkgLy8gaGVhZCByb3cgbGVuZ3RocyBsaXN0ZWQgZnJvbSBheGlzIHRvd2FyZCBoZWFkXG5cbiAgICB9XG5cbiAgICBjb25zdCBncmlkUm93U3BhbnMgPSBnZXRHcmlkUm93U3BhbnMoZ3JpZFJvd0xlbmd0aHMpXG5cbiAgICBjb25zdCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgPSBcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpPyAvLyBibG9jayBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0OiAvLyBuZWVkcyB0byBtb3ZlIGRvd24gb3IgcmlnaHQgdG93YXJkIHRhaWxcbiAgICAgICAgdHJpZ2dlckRhdGEuaGVhZE9mZnNldCAvLyBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdG93YXJkIGhlYWRcblxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAoY3JhZGxlY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0NyYWRsZVJvd09mZnNldCA9IE1hdGguY2VpbChwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCA9ICh0YWlsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGNhbGN1bGF0ZSBiYXNlIHJvdyBzaGlmdCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBzcGFuUm93UHRyXG4gICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsIHVwXG5cbiAgICAgICAgLy8gdGFpbCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBwb3NpdGl2ZVxuICAgICAgICBzcGFuUm93UHRyID0gZ3JpZFJvd1NwYW5zLmZpbmRJbmRleCgobW92ZW1lbnRzcGFuKSA9PiBcbiAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgKyBtb3ZlbWVudHNwYW4pID49IDAgKVxuICAgIFxuICAgIH0gZWxzZSB7IC8vICdheGlzaGVhZHdhcmQnLCBzY3JvbGxkb3duXG5cbiAgICAgICAgLy8gaGVhZCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgdXAgb3IgbGVmdCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBuZWdhdGl2ZVxuICAgICAgICBzcGFuUm93UHRyID0gZ3JpZFJvd1NwYW5zLmZpbmRJbmRleCgobW92ZW1lbnRzcGFuKSA9PiBcbiAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgLSBtb3ZlbWVudHNwYW4pIDw9IDAgKVxuXG4gICAgfVxuXG4gICAgY29uc3QgbGlzdEVuZHJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuXG4gICAgbGV0IHNwYW5BeGlzUGl4ZWxTaGlmdCAvLyBpbiByZWxhdGlvbiB0byB2aWV3cG9ydCBoZWFkIGJvdW5kYXJ5XG4gICAgaWYgKHNwYW5Sb3dQdHIgPT0gLTEgKSB7IC8vIG92ZXJzaG9vdCBvZiBpbnN0YW50aWF0ZWQgcm93czsgY29udGludWUgd2l0aCB2aXJ0dWFsIHJvd3NcblxuICAgICAgICBsZXQgbm90aW9uYWxSb3dQdHJcbiAgICAgICAgaWYgKGdyaWRSb3dTcGFucy5sZW5ndGggPT0gMCkgeyAvLyBtdXN0IGJlIGxpc3QgYm91bmRhcnlcblxuICAgICAgICAgICAgLy8gbm90aW9uYWxSb3dQdHIgPSAwXG4gICAgICAgICAgICBub3Rpb25hbFJvd1B0ciA9IC0xIC8vIFwibm90IGZvdW5kXCJcbiAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IDBcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFzZVJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoKSBcbiAgICAgICAgICAgICAgICArIGdhcFxuXG4gICAgICAgICAgICBub3Rpb25hbFJvd1B0ciA9IGdyaWRSb3dTcGFucy5sZW5ndGggLSAxIC8vIGJhc2U6IGZhaWxlZCBtZWFzdXJlZCByb3cgcHRyXG4gICAgICAgICAgICBsZXQgdG90YWxQaXhlbFNoaWZ0ID0gZ3JpZFJvd1NwYW5zW25vdGlvbmFsUm93UHRyXSAvLyBzZXQgYmFzZSBvZiB3b3JraW5nIG92ZXJzaG9vdFxuXG4gICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGxpbmcgdXAgXG5cbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uYWxSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyArIHRvdGFsUGl4ZWxTaGlmdCkgPCAwKSBcblxuICAgICAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IHRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBheGlzaGVhZHdhcmQ7IHNjcm9sbGluZyBkb3duXG5cbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uYWxSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJldmlvdXNBeGlzUm93T2Zmc2V0IC0gbm90aW9uYWxSb3dQdHIpID09IDApIHsgLy8gc3RvcCBjeWNsaW5nIGF0IGhlYWQgbGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY29tbW9kYXRlIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIGV4Y2VwdGlvbiBpbiBwbGFjaW5nIHRyaWdnZXIgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGZpcnN0IHJvdyBhZnRlciBheGlzLCByYXRoZXIgdGhhbiBmaXJzdCByb3cgYmVmb3JlIGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlvbmFsUm93UHRyIC09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCAtPSBiYXNlUm93TGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIC0gdG90YWxQaXhlbFNoaWZ0KSA+IDApXG5cbiAgICAgICAgICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSAtdG90YWxQaXhlbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgc3BhblJvd1B0ciA9IG5vdGlvbmFsUm93UHRyXG5cbiAgICB9IGVsc2UgeyAvLyBmaW5hbCB2YWx1ZXMgZm91bmQgaW4gaW5zdGFudGlhdGVkIHJvd3NcblxuICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSBcbiAgICAgICAgICAgIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzdGFpbHdhcmQnKT9cbiAgICAgICAgICAgICAgICBncmlkUm93U3BhbnNbc3BhblJvd1B0cl06IC8vIG1vdmUgYXhpcyB0b3dhcmQgdGFpbCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5IChwb3NpdGl2ZSlcbiAgICAgICAgICAgICAgICAtZ3JpZFJvd1NwYW5zW3NwYW5Sb3dQdHJdIC8vIG1vdmUgYXhpcyB0b3dhcmQgaGVhZCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5IChuZWdhdGl2ZSlcblxuICAgIH1cblxuICAgIGNvbnN0IHNwYW5Sb3dTaGlmdCA9IC8vIHBpY2sgdXAgcm93IHNoaWZ0IHdpdGggb3Igd2l0aG91dCBvdmVyc2hvb3RcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgc3BhblJvd1B0ciArIDE6XG4gICAgICAgICAgICAtKHNwYW5Sb3dQdHIgKyAxKVxuXG4gICAgLy8gdGhlIGZvbGxvd2luZyB0d28gdmFsdWVzLCBhbmQgbm8gb3RoZXIgY2FsY3MsIGFyZSBjYXJyaWVkIGZvcndhcmQgaW4gdGhlIGZ1bmN0aW9uLlxuICAgIC8vIGZvciBheGlzUmVmZXJlbmNlUm93c2hpZnQ6XG4gICAgLy8gbmVnYXRpdmUgZm9yIG1vdmluZyByb3dzIG91dCBvZiBoZWFkIGludG8gdGFpbDtcbiAgICAvLyBwb3NpdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIHRhaWwgaW50byBoZWFkXG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0ID0gc3BhblJvd1NoaWZ0XG4gICAgY29uc3QgYXhpc1BpeGVsU2hpZnQgPSBzcGFuQXhpc1BpeGVsU2hpZnQgXG5cbiAgICAvLyAtLS0tLS0tLS0tLVsgMy4gY2FsY3VsYXRlIGN1cnJlbnQgdmlld3BvcnQgYXhpcyBvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnYXBzIGJleW9uZCByZW5kZXJlZCByb3dzIGNhbiBiZSBjYXVzZWQgYnkgcmFwaWQgc2Nyb2xsaW5nXG5cbiAgICBjb25zdCBzY3JvbGxibG9ja0F4aXNPZmZzZXQgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tPZmZzZXQgPSAvLyB0byBjYXB0dXJlIGN1cnJlbnQgdG9wL2xlZnQgYWRqdXN0bWVudCB0byB2aWV3cG9ydCBmb3IgdmFyaWFibGUgbGF5b3V0XG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgLy8gY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCB3aWxsIGJlIG5lZ2F0aXZlIChhYm92ZSB2aWV3cG9ydCBlZGdlKSBmb3Igc2Nyb2xsIGJsb2NrIGhlYWR3YXJkIFxuICAgIC8vICAgICBhbmQgcG9zaXRpdmUgZm9yIHNjcm9sbCBibG9jayB0YWlsd2FyZFxuICAgIC8vIHRoZSBwaXhlbCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB2aWV3cG9ydCBmcmFtZSBhbmQgdGhlIGF4aXMsIHRvd2FyZCB0aGUgaGVhZFxuICAgIGNvbnN0IGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgPSBcbiAgICAgICAgc2Nyb2xsYmxvY2tBeGlzT2Zmc2V0ICsgc2Nyb2xsYmxvY2tPZmZzZXQgLSBzY3JvbGxQb3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS1bIDQuIGNhbGN1bGF0ZSBuZXcgYXhpcyBwaXhlbCBwb3NpdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgKyBheGlzUGl4ZWxTaGlmdFxuXG4gICAgLy8gTm90ZTogc2VjdGlvbnMgNSwgNiBhbmQgNyBkZWFsIGVudGlyZWx5IHdpdGggcm93IGNhbGN1bGF0aW9uczsgbm8gcGl4ZWxzXG5cbiAgICAvLyAtLS0tLS0tLS0tLS1bIDUuIGNhbGMgbmV3IGNyYWRsZSBhbmQgYXhpcyByZWZlcmVuY2Ugcm93IG9mZnNldHMgXS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJhc2UgdmFsdWUgZm9yIGNyYWRsZSByZWZlcmVuY2Ugc2hpZnQ7IG1heSBjaGFuZ2UgaWYgYmV5b25kIGxpc3QgYm91bmRzXG4gICAgbGV0IGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ID0gYXhpc1JlZmVyZW5jZVJvd1NoaWZ0XG5cbiAgICAvLyBiYXNlIHZhbHVlc1xuICAgIGxldCBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBwcmV2aW91c0NyYWRsZVJvd09mZnNldCArIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0XG4gICAgbGV0IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgPSBwcmV2aW91c0F4aXNSb3dPZmZzZXQgKyBheGlzUmVmZXJlbmNlUm93U2hpZnRcblxuICAgIC8vIC0tLS0tLS0tWyA2LiBhZGp1c3QgY3JhZGxlIGNvbnRlbnRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGxpc3QgXS0tLS0tLS1cbiAgICAvLyAuLi50byBtYWludGFpbiBjb25zdGFudCBudW1iZXIgb2YgY3JhZGxlIHJvd3NcblxuICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzdGFpbHdhcmQnKSB7IC8vIHNjcm9sbGluZyB0b3dhcmQgaGVhZFxuXG4gICAgICAgIC8vIGEuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgaGVhZHdhcmQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIG5ldyBjcmFkbGUgcm93IG9mZnNldCBhbmRcbiAgICAgICAgLy8gY3JhZGxlIHJvdyBzaGlmdCBjb3VudCBoYXMgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxlYWRpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gYi4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayBoZWFkd2FyZCAocmV2ZWFsaW5nIHRhaWwgb2YgbGlzdCksIGFzIHRoZSBjcmFkbGUgbGFzdCByb3cgb2Zmc2V0IFxuICAgICAgICAvLyBhcHByb2FjaGVzIG1heCBsaXN0cm93LCBuZXcgY3JhZGxlIG9mZnNldCBhbmQgY3JhZGxlIHJvdyBzaGlmdCBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgXG4gICAgICAgIC8vIHNob3J0ZW5pbmcgb2YgY3JhZGxlIGNvbnRlbnQuXG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQgLSAxKSkgLy8gZXh0cmEgcm93IGZvciB2aXNpYmlsaXR5XG5cbiAgICAgICAgY29uc3QgaGVhZHJvd0RpZmYgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgaWYgKGhlYWRyb3dEaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gaGVhZHJvd0RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IGhlYWRyb3dEaWZmXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OiBjYXNlIG9mIGJlaW5nIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXkgKGVuZCBvZiBsaXN0KVxuICAgICAgICBsZXQgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGxpc3RFbmRyb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBzaGlmdGluc3RydWN0aW9uID09ICdheGlzaGVhZHdhcmQnOyBzY3JvbGxpbmcgdG93YXJkIHRhaWwgXG5cbiAgICAgICAgLy8gYy4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayB0YWlsd2FyZCAodG93YXJkIHJldmVhbGluZyBoZWFkIG9mIGxpc3QpLCBhcyB0aGUgY3JhZGxlcm93b2Zmc2V0IFxuICAgICAgICAvLyBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmUgdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICAgICAgLy8gZC4gaWYgc2Nyb2xsaW5nIGhlYWR3YXJkIG5lYXIgdGhlIGVuZCBvZiB0aGUgbGlzdCwgY3JhZGxlIGNoYW5nZXMgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBcbiAgICAgICAgLy8gYWNjb21vZGF0ZSB0aGUgdHJhaWxpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IDBcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tIGVuZCBvZiBsaXN0IGFkanVzdG1lbnQ7IGNhc2Ugb2YgaW4gYm91bmRzIG9mIHRyYWlsaW5nIHJ1bndheVxuICAgICAgICBjb25zdCBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIChwcmV2aW91c0NyYWRsZVJvd09mZnNldCArIChjcmFkbGVSb3djb3VudCAtMSkgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdClcblxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBNYXRoLm1pbihsaXN0RW5kcm93T2Zmc2V0LCBcbiAgICAgICAgICAgIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpKSlcblxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsIHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldClcblxuICAgICAgICBpZiAodGFpbHJvd2RpZmYgPiAwKSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICs9IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKz0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA3LiBtYXAgcm93cyB0byBpdGVtIHJlZmVyZW5jZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCAqIGNyb3NzY291bnQpXG4gICAgY29uc3QgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0ID0gKGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICogY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IG5ld0F4aXNSZWZlcmVuY2VJbmRleCA9IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCA9IGF4aXNSZWZlcmVuY2VSb3dTaGlmdCAqIGNyb3NzY291bnRcblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnQgLy8gYmFzZSBjb3VudFxuICAgIGNvbnN0IGluY2x1ZGVzTGFzdFJvdyA9ICgobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgY3JhZGxlUm93Y291bnQpID49IGxpc3RSb3djb3VudClcbiAgICBpZiAoaW5jbHVkZXNMYXN0Um93KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxzcGFjZXMgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgY29uc3QgaXRlbXNTaG9ydGZhbGwgPSBcbiAgICAgICAgICAgIChwYXJ0aWFsc3BhY2VzID09IDApP1xuICAgICAgICAgICAgICAgIDA6XG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCAtIHBhcnRpYWxzcGFjZXNcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IGl0ZW1zU2hvcnRmYWxsXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGhlYWQgYW5kIHRhaWwgY2hhbmdlIGNvdW50c1xuICAgIGNvbnN0IGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlY29udGVudGxpc3QubGVuZ3RoIC0gbmV3Q3JhZGxlQ29udGVudENvdW50XG5cbiAgICBjb25zdCBsaXN0U3RhcnRDaGFuZ2VDb3VudCA9IC0oY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0KVxuICAgIGNvbnN0IGxpc3RFbmRDaGFuZ2VDb3VudCA9IC1saXN0U3RhcnRDaGFuZ2VDb3VudCAtIGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDguIHJldHVybiByZXF1aXJlZCB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQsIFxuICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBheGlzUmVmZXJlbmNlSXRlbVNoaWZ0LCBcblxuICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnRcbiAgICB9XG5cbn1cblxuLy8gc3VwcG9ydHMgY2FsY0NvbnRlbnRTaGlmdCBhYm92ZVxuY29uc3QgZ2V0R3JpZFJvd0xlbmd0aHMgPSAoZ3JpZCwgb3JpZW50YXRpb24sIGNyb3NzY291bnQsIGdhcCkgPT4ge1xuXG4gICAgY29uc3Qgcm93TGVuZ3RocyA9IFtdXG4gICAgY29uc3QgZWxlbWVudExpc3QgPSBncmlkLmNoaWxkTm9kZXNcblxuICAgIGxldCBlbGVtZW50UHRyID0gMFxuICAgIGxldCBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJvd2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoKSBcbiAgICAgICAgICAgICsgZ2FwXG4gICAgICAgIHJvd0xlbmd0aHMucHVzaChyb3dsZW5ndGgpXG4gICAgICAgIGVsZW1lbnRQdHIgKz0gY3Jvc3Njb3VudFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cbiAgICB9XG5cbiAgICByZXR1cm4gcm93TGVuZ3Roc1xufVxuXG4vLyBzdXBwb3J0cyBjYWxjQ29udGVudFNoaWZ0IGFib3ZlXG5jb25zdCBnZXRHcmlkUm93U3BhbnMgPSAocm93TGVuZ3RocykgPT4ge1xuXG4gICAgY29uc3Qgcm93U3BhbnMgPSBbXVxuICAgIGxldCBzcGFuID0gMFxuICAgIHJvd0xlbmd0aHMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgc3BhbiArPSB2YWx1ZVxuICAgICAgICByb3dTcGFucy5wdXNoKHNwYW4pXG4gICAgfSlcblxuICAgIHJldHVybiByb3dTcGFuc1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIHNoYXJlZCBieSBib3RoIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHVwZGF0ZSBjb250ZW50XG4vLyBhZGRzIGl0ZW1zaGVsbHMgYXQgZW5kIG9mIGNvbnRlbnRsaXN0IGFjY29yZGluZyB0byBoZWFkaW5kZXhjb3VudCBhbmQgdGFpbGluZGVzY291bnQsXG4vLyBvciBpZiBpbmRleGNvdW50IHZhbHVlcyBhcmUgPDAgcmVtb3ZlcyB0aGVtLlxuZXhwb3J0IGNvbnN0IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3QgPSAoeyBcblxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LCBcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LCBcbiAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0OmNvbnRlbnRsaXN0LFxuICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgc3R5bGVzLFxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgY29uc3QgbGFzdGluZGV4b2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggKyBsb2NhbENvbnRlbnRsaXN0Lmxlbmd0aCAtIDFcblxuICAgIGNvbnN0IGhlYWRDb250ZW50bGlzdCA9IFtdLCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgbGV0IGRlbGV0ZWR0YWlsaXRlbXMgPSBbXSwgZGVsZXRlZGhlYWRpdGVtcyA9IFtdXG5cbiAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggLSBsaXN0U3RhcnRDaGFuZ2VDb3VudDsgbmV3aW5kZXggPCAoY3JhZGxlUmVmZXJlbmNlSW5kZXgpOyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVybGluZXIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkaGVhZGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UoIDAsIC1saXN0U3RhcnRDaGFuZ2VDb3VudCApXG5cbiAgICB9XG5cbiAgICBpZiAobGlzdEVuZENoYW5nZUNvdW50ID49IDApIHsgLy8gYWNxdWlyZSBuZXcgaXRlbXNcblxuICAgICAgICBmb3IgKGxldCBuZXdpbmRleCA9IGxhc3RpbmRleG9mZnNldCArIDE7IG5ld2luZGV4IDwgKGxhc3RpbmRleG9mZnNldCArIDEgKyBsaXN0RW5kQ2hhbmdlQ291bnQpOyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIHRhaWxDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVybGluZXIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkdGFpbGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UobGlzdEVuZENoYW5nZUNvdW50LC1saXN0RW5kQ2hhbmdlQ291bnQpXG5cbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkSXRlbXMgPSBbLi4uZGVsZXRlZGhlYWRpdGVtcywuLi5kZWxldGVkdGFpbGl0ZW1zXVxuXG4gICAgY29uc3QgY29tcG9uZW50TGlzdCA9IFsuLi5oZWFkQ29udGVudGxpc3QsLi4ubG9jYWxDb250ZW50bGlzdCwuLi50YWlsQ29udGVudGxpc3RdXG5cbiAgICByZXR1cm4gW2NvbXBvbmVudExpc3QsZGVsZXRlZEl0ZW1zXVxuXG59XG5cbi8vIExlYWRpbmcgKGhlYWQpIGFsbCBvciBwYXJ0aWFsbHkgaGlkZGVuOyB0YWlsLCB2aXNpYmxlIHBsdXMgdHJhaWxpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZmlyc3QgdGFpbCBpdGVtXG4gICAgICAgIGxheW91dEhhbmRsZXIsXG5cbiAgICB9XG4pID0+IHtcblxuICAgIGNvbnN0IHsgdHJpZ2dlcmNlbGxJbmRleCB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgY29uc3Qgb2Zmc2V0aW5kZXggPSBjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXgsXG4gICAgICAgIGhpZ2hpbmRleCA9IG9mZnNldGluZGV4ICsgY29udGVudGxpc3QubGVuZ3RoXG5cbiAgICBjb25zdCBoZWFkaXRlbWNvdW50ID0gKGF4aXNSZWZlcmVuY2VJbmRleCAtIG9mZnNldGluZGV4KVxuXG4gICAgY29uc3QgdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCA9IFxuICAgICAgICAoaGVhZGl0ZW1jb3VudCA9PSAwKT9cbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDpcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCAtIDFcblxuICAgIGxheW91dEhhbmRsZXIudHJpZ2dlcmNlbGxJc0luVGFpbCA9IFxuICAgICAgICAoaGVhZGl0ZW1jb3VudCA9PSAwKT9cbiAgICAgICAgICAgIHRydWU6XG4gICAgICAgICAgICBmYWxzZVxuXG4gICAgaWYgKCh0cmlnZ2VyY2VsbEluZGV4ICE9PSB1bmRlZmluZWQpICYmIChvZmZzZXRpbmRleCAhPT0gdW5kZWZpbmVkKSkgeyAvLyYmIFxuICAgICAgICBpZiAoKHRyaWdnZXJjZWxsSW5kZXggPj0gb2Zmc2V0aW5kZXgpICYmICh0cmlnZ2VyY2VsbEluZGV4IDw9IGhpZ2hpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsUHRyID0gdHJpZ2dlcmNlbGxJbmRleCAtIG9mZnNldGluZGV4XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbENvbXBvbmVudCA9IGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJjZWxsQ29tcG9uZW50KSB7IC8vIG90aGVyd2lzZSBoYXMgYmVlbiBhc3luY2hyb25vdXNseSBjbGVhcmVkXG4gICAgICAgICAgICAgICAgY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXJjZWxsQ29tcG9uZW50LCB7aXNUcmlnZ2VyY2VsbDpmYWxzZX0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cmlnZ2VyY2VsbFB0ciA9IHRhcmdldFRyaWdnZXJjZWxsSW5kZXggLSBvZmZzZXRpbmRleFxuICAgIGNvbnN0IHRyaWdnZXJjZWxsQ29tcG9uZW50ID0gY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdXG4gICAgaWYgKHRyaWdnZXJjZWxsQ29tcG9uZW50KSB7XG5cbiAgICAgICAgY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXJjZWxsQ29tcG9uZW50LCB7aXNUcmlnZ2VyY2VsbDp0cnVlfSlcbiAgICAgICAgbGF5b3V0SGFuZGxlci50cmlnZ2VyY2VsbEluZGV4ID0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleFxuXG4gICAgfSBlbHNlIHsgLy8gZGVmZW5zaXZlOyBzaG91bGRuJ3QgaGFwcGVuXG5cbiAgICAgICAgY29uc29sZS5sb2coJ0ZBSUxVUkUgVE8gUkVHSVNURVIgVFJJR0dFUkNFTEw6IFxcbicsXG4gICAgICAgICAgICAndHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsSW5kZXgsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXgsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGxcXG4nLCBcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsQ29tcG9uZW50LCB0cmlnZ2VyY2VsbEluZGV4LCB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4LCB0cmlnZ2VyY2VsbENvbXBvbmVudD8ucHJvcHMuaXNUcmlnZ2VjZWxsLCBcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdCwgYXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGxpc3QgPSBjb250ZW50bGlzdC5zbGljZSgwLGhlYWRpdGVtY291bnQpXG4gICAgY29uc3QgdGFpbGxpc3QgPSBjb250ZW50bGlzdC5zbGljZShoZWFkaXRlbWNvdW50KVxuXG4gICAgcmV0dXJuIFsgaGVhZGxpc3QsIHRhaWxsaXN0IF1cblxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUG9ydGFscyA9IChjYWNoZUhhbmRsZXIsIGRlbGV0ZUxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaykgPT4ge1xuXG4gICAgY29uc3QgZGxpc3QgPSBkZWxldGVMaXN0Lm1hcCgoaXRlbSk9PntcblxuICAgICAgICByZXR1cm4gaXRlbS5wcm9wcy5pbmRleFxuICAgICAgICBcbiAgICB9KVxuXG4gICAgY2FjaGVIYW5kbGVyLmRlbGV0ZVBvcnRhbChkbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIGludGVybmFsLCBhY3F1aXJlIGl0ZW0gXT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY3JlYXRlQ2VsbEZyYW1lID0gKHtcbiAgICBpbmRleCwgXG4gICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgY2FjaGVIYW5kbGVyLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyxcbn0pID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZUlEID0gaW5zdGFuY2VJZENvdW50ZXJSZWYuY3VycmVudCsrXG5cbiAgICBjb25zdCB7IFxuICAgICAgICBcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnZXRJdGVtLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgbGF5b3V0LCBcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIsXG5cbiAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAvLyBnZXQgbmV3IG9yIGV4aXN0aW5nIGl0ZW1JRFxuICAgIGNvbnN0IGl0ZW1JRCA9IGNhY2hlSGFuZGxlci5nZXROZXdPckV4aXN0aW5nSXRlbUlEKGluZGV4KVxuXG4gICAgLy8gY29uc29sZS5sb2coJ2NyZWF0aW5nIENlbGxGcmFtZScsJy0nK2luZGV4KyctJywnXycraW5zdGFuY2VJRCsnXycpXG5cbiAgICByZXR1cm4gPENlbGxGcmFtZSBcbiAgICAgICAga2V5ID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgIGNlbGxNaW5IZWlnaHQgPSB7IGNlbGxNaW5IZWlnaHQgfVxuICAgICAgICBjZWxsTWluV2lkdGggPSB7IGNlbGxNaW5XaWR0aCB9XG4gICAgICAgIGxheW91dCA9IHsgbGF5b3V0IH1cbiAgICAgICAgaW5kZXggPSB7IGluZGV4IH1cbiAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgIGl0ZW1JRCA9IHsgaXRlbUlEIH1cbiAgICAgICAgaW5zdGFuY2VJRCA9IHsgaW5zdGFuY2VJRCB9XG4gICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICBpc1RyaWdnZXJjZWxsID0geyBmYWxzZSB9XG4gICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgfVxuICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckxpbmVyU3R5bGVzIH1cbiAgICAgICAgdXNlUGxhY2Vob2xkZXIgPSB7IHVzZVBsYWNlaG9sZGVyIH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwicGFkZGluZyIsImNyb3NzY291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwibGlzdFJvd2NvdW50IiwibGlzdHNpemUiLCJ2aWV3cG9ydFZpc2libGVSb3djb3VudCIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRBeGlzUm93T2Zmc2V0IiwiY2VpbCIsIm1heEF4aXNSb3dPZmZzZXQiLCJtYXgiLCJ0YXJnZXRDcmFkbGVSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQiLCJsaXN0RW5kUm93T2Zmc2V0IiwiZGlmZiIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwibmV3Q3JhZGxlQ29udGVudENvdW50IiwiZW5kUm93UmVtYWluZGVyQ291bnQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJleHBvcnRzIiwiZ2V0U2hpZnRJbnN0cnVjdGlvbiIsIm9yaWVudGF0aW9uIiwidHJpZ2dlcmxpbmVFbnRyaWVzIiwidHJpZ2dlcmxpbmVTcGFuIiwic2Nyb2xsZXJJRCIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidHJpZ2dlckRhdGEiLCJoZWFkT2Zmc2V0IiwidGFpbE9mZnNldCIsInNwYW4iLCJlbnRyeSIsImF0IiwicmVmZXJlbmNlbmFtZSIsInRhcmdldCIsImRhdGFzZXQiLCJ0eXBlIiwicm9vdHBvcyIsInJvb3RCb3VuZHMiLCJ5IiwieCIsImVudHJ5cG9zIiwiYm91bmRpbmdDbGllbnRSZWN0Iiwidmlld3BvcnRUcmlnZ2VyT2Zmc2V0Iiwic2hpZnRpbnN0cnVjdGlvbiIsImNhbGNDb250ZW50U2hpZnQiLCJzY3JvbGxQb3MiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJjcmFkbGVDb250ZW50IiwiY3JhZGxlRWxlbWVudHMiLCJnYXAiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwibGF5b3V0IiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiY3VycmVudCIsImhlYWRHcmlkRWxlbWVudCIsImhlYWRSZWYiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwiY3JhZGxlY29udGVudGxpc3QiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJ0YWlsY29udGVudGxpc3QiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwidmlld3BvcnRSb3djb3VudCIsInJlZmVyZW5jZUdyaWRFbGVtZW50IiwiZ3JpZFJvd0xlbmd0aHMiLCJnZXRHcmlkUm93TGVuZ3RocyIsInJldmVyc2UiLCJncmlkUm93U3BhbnMiLCJnZXRHcmlkUm93U3BhbnMiLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwicHJvcHMiLCJpbmRleCIsInByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0IiwicHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgiLCJwcmV2aW91c0F4aXNSb3dPZmZzZXQiLCJzcGFuUm93UHRyIiwiZmluZEluZGV4IiwibW92ZW1lbnRzcGFuIiwibGlzdEVuZHJvd09mZnNldCIsInNwYW5BeGlzUGl4ZWxTaGlmdCIsIm5vdGlvbmFsUm93UHRyIiwibGVuZ3RoIiwidG90YWxQaXhlbFNoaWZ0Iiwic3BhblJvd1NoaWZ0IiwiYXhpc1JlZmVyZW5jZVJvd1NoaWZ0IiwiYXhpc1BpeGVsU2hpZnQiLCJzY3JvbGxibG9ja0F4aXNPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IiwibmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCIsIm5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCIsIm5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQiLCJoZWFkcm93RGlmZiIsInRhcmdldENyYWRsZUVuZHJvd09mZnNldCIsInRhaWxyb3dkaWZmIiwiY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0IiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzUmVmZXJlbmNlSXRlbVNoaWZ0IiwiaW5jbHVkZXNMYXN0Um93IiwicGFydGlhbHNwYWNlcyIsIml0ZW1zU2hvcnRmYWxsIiwiY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsImdyaWQiLCJyb3dMZW5ndGhzIiwiZWxlbWVudExpc3QiLCJjaGlsZE5vZGVzIiwiZWxlbWVudFB0ciIsImVsZW1lbnQiLCJyb3dsZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInB1c2giLCJyb3dTcGFucyIsImZvckVhY2giLCJ2YWx1ZSIsImdldENlbGxGcmFtZUNvbXBvbmVudExpc3QiLCJjYWNoZUhhbmRsZXIiLCJjcmFkbGVDb250ZW50Q291bnQiLCJjcmFkbGVSZWZlcmVuY2VJbmRleCIsImNvbnRlbnRsaXN0Iiwid29ya2luZ0NvbnRlbnRMaXN0IiwiaW5zdGFuY2VJZENvdW50ZXJSZWYiLCJzdHlsZXMiLCJsb2NhbENvbnRlbnRsaXN0IiwibGFzdGluZGV4b2Zmc2V0IiwiaGVhZENvbnRlbnRsaXN0IiwidGFpbENvbnRlbnRsaXN0IiwiZGVsZXRlZHRhaWxpdGVtcyIsImRlbGV0ZWRoZWFkaXRlbXMiLCJuZXdpbmRleCIsImNyZWF0ZUNlbGxGcmFtZSIsInBsYWNlaG9sZGVyRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlcmZyYW1lIiwicGxhY2Vob2xkZXJMaW5lclN0eWxlcyIsInBsYWNlaG9sZGVybGluZXIiLCJzcGxpY2UiLCJkZWxldGVkSXRlbXMiLCJjb21wb25lbnRMaXN0IiwiYWxsb2NhdGVDb250ZW50TGlzdCIsImF4aXNSZWZlcmVuY2VJbmRleCIsImxheW91dEhhbmRsZXIiLCJ0cmlnZ2VyY2VsbEluZGV4Iiwib2Zmc2V0aW5kZXgiLCJoaWdoaW5kZXgiLCJoZWFkaXRlbWNvdW50IiwidGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCIsInRyaWdnZXJjZWxsSXNJblRhaWwiLCJ1bmRlZmluZWQiLCJ0cmlnZ2VyY2VsbFB0ciIsInRyaWdnZXJjZWxsQ29tcG9uZW50IiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImlzVHJpZ2dlcmNlbGwiLCJjb25zb2xlIiwibG9nIiwiaXNUcmlnZ2VjZWxsIiwiaGVhZGxpc3QiLCJzbGljZSIsInRhaWxsaXN0IiwiZGVsZXRlUG9ydGFscyIsImRlbGV0ZUxpc3QiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJkbGlzdCIsIm1hcCIsIml0ZW0iLCJkZWxldGVQb3J0YWwiLCJpbnN0YW5jZUlEIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImdldEl0ZW0iLCJwbGFjZWhvbGRlciIsInVzZVBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRCIsIkNlbGxGcmFtZV8xIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// contenthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module supports the setup and rollover and positioning of content in the Cradle.\n\n    There are three key functions in this module: setCradleContent, updateCradleContent, and\n    adjustScrollblockForVariability.\n\n    There are also a few functions which support synchronization of Cradle content with cache\n    content (see internal and external services below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    tailward, content is removed from the Cradle head and added to the Cradle tail. When scrolling\n    headward, the reverse occurs.\n\n    adjustScrollblockForVariability reconfigures the scrollblock to accommodate variable sized grid rows.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ \"./src/cradle/contentfunctions.tsx\");\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, ContentHandler);\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    };\n    // Two main public methods - setCradleContent and updateCradleContent\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n        cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n        layoutHandler = cradleHandlers.layoutHandler,\n        serviceHandler = cradleHandlers.serviceHandler,\n        interruptHandler = cradleHandlers.interruptHandler,\n        scrollHandler = cradleHandlers.scrollHandler;\n      // the triggerlines and cradle grids will be moved, so disconnect them from their observers.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.cradleIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true;\n      interruptHandler.signals.pauseCradleIntersectionObserver = true;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      // console.log('setCradleContent 1: requestedAxisReferenceIndex',requestedAxisReferenceIndex)\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        cache = cradleInheritedProperties.cache,\n        scrollerID = cradleInheritedProperties.scrollerID,\n        styles = cradleInheritedProperties.styles,\n        layout = cradleInheritedProperties.layout;\n      var crosscount = cradleInternalProperties.crosscount,\n        listsize = cradleInternalProperties.listsize,\n        listRowcount = cradleInternalProperties.listRowcount;\n      // if (crosscount == 0) return // TODO check validity\n      var workingRequestAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingRequestAxisReferenceIndex -= workingRequestAxisReferenceIndex % crosscount;\n      // console.log('setCradleContent 2: workingRequestAxisReferenceIndex, requestedAxisReferenceIndex, listsize, crosscount, cradlePositionData',\n      //     workingRequestAxisReferenceIndex, requestedAxisReferenceIndex, listsize, crosscount, cradlePositionData)\n      // reposition at row boundary\n      if (['firstrender', 'firstrenderfromcache', 'finishreposition', 'reconfigure', 'scrollto'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingRequestAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content;\n      // ----------------------[ 2. get content requirements ]----------------------\n      var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      // note that targetAxisReferenceIndex replaces requestedAxisReferenceIndex here\n      var _ref = (0, contentfunctions_1.getContentListRequirements)({\n          // pixel\n          baseRowLength: baseRowLength,\n          targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n          // index\n          targetAxisReferenceIndex: workingRequestAxisReferenceIndex,\n          // resources\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties\n        }),\n        targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n        targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n        cradleContentCount = _ref.newCradleContentCount,\n        scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset;\n      // reset scrollblock Offset and length\n      var scrollblockElement = viewportElement.firstChild;\n      var baselength = listRowcount * baseRowLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (cradleState == 'pivot') {\n        if (orientation == 'vertical') {\n          scrollblockElement.style.left = null;\n        } else {\n          scrollblockElement.style.top = null;\n        }\n      }\n      if (orientation == 'vertical') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + 'px';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + 'px';\n      }\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // semantics\n      // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          cradleReferenceIndex: targetCradleReferenceIndex,\n          listStartChangeCount: 0,\n          listEndChangeCount: cradleContentCount,\n          workingContentList: workingContentList,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles\n        }),\n        _ref3 = _slicedToArray(_ref2, 2),\n        newcontentlist = _ref3[0],\n        deleteditems = _ref3[1];\n      // console.log('setCradleContent 3: cradleState, cradleContentCount, newcontentlist, deleteditems, targetAxisReferenceIndex',\n      //     cradleState, cradleContentCount, newcontentlist, deleteditems, targetAxisReferenceIndex)\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: newcontentlist,\n          axisReferenceIndex: targetAxisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref5 = _slicedToArray(_ref4, 2),\n        headcontentlist = _ref5[0],\n        tailcontentlist = _ref5[1];\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, 'setCradleContent', cstate);\n      }\n      //  ----------------------[ 4. set CSS ]-----------------------\n      // console.log('setCradleContent 4: scrollblockViewportPixelOffset',scrollblockViewportPixelOffset)\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset; // - scrollblockOffset\n      // avoid bogus call to updateCradleContent\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset); // - scrollblockOffset) \n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current,\n        headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n      if (orientation == 'vertical') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontentlist.length ? gap + 'px' : 0;\n      } else {\n        // orientation = 'horizontal'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = left + 'px';\n        headElement.style.paddingRight = headcontentlist.length ? gap + 'px' : 0;\n      }\n    };\n    // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element's scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler.\n    // typically called for scroll action, but can also be called if the triggerLineCell changes\n    // size with variant layout.\n    this.updateCradleContent = function (triggerlineEntries) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'notifications';\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a, _b;\n      // handler support\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter.cacheHandler,\n        scrollHandler = _this$cradleParameter.scrollHandler,\n        layoutHandler = _this$cradleParameter.layoutHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        interruptHandler = _this$cradleParameter.interruptHandler,\n        serviceHandler = _this$cradleParameter.serviceHandler;\n      // scroll data\n      var scrollData = scrollHandler.scrollData;\n      var scrollPos = scrollData.currentupdate;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n        cache = cradleInheritedProperties.cache,\n        styles = cradleInheritedProperties.styles;\n      var crosscount = cradleInternalProperties.crosscount,\n        listsize = cradleInternalProperties.listsize;\n      var contentLength = orientation == 'vertical' ? viewportElement.scrollHeight : viewportElement.scrollWidth;\n      var viewportLength = orientation == 'vertical' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n      // first abandon option/3; nothing to do\n      // for browser top or bottom bounce\n      if (scrollPos < 0 || scrollPos + viewportLength > contentLength) {\n        return;\n      }\n      // cradle scaffold and user cells\n      var cradleElements = layoutHandler.elements;\n      var cradleContent = _this.content,\n        modelcontentlist = cradleContent.cradleModelComponents || [],\n        oldAxisReferenceIndex = ((_a = cradleContent.tailModelComponents[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      var oldCradleReferenceIndex = ((_b = modelcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n      // --------------------[ 2. get shift instruction ]-----------------------\n      var _ref6 = (0, contentfunctions_1.getShiftInstruction)({\n          scrollerID: cradleInheritedProperties.scrollerID,\n          orientation: orientation,\n          triggerlineEntries: triggerlineEntries,\n          triggerlineSpan: layoutHandler.triggerlineSpan,\n          isFirstRowTriggerConfig: layoutHandler.triggercellIsInTail\n        }),\n        _ref7 = _slicedToArray(_ref6, 2),\n        shiftinstruction = _ref7[0],\n        triggerData = _ref7[1];\n      // second abandon option/3; nothing to do\n      if (shiftinstruction == 'none') {\n        return;\n      }\n      // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      var _ref8 = (0, contentfunctions_1.calcContentShift)({\n          shiftinstruction: shiftinstruction,\n          triggerData: triggerData,\n          scrollPos: scrollPos,\n          scrollblockElement: viewportElement.firstChild,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContent: cradleContent,\n          cradleElements: cradleElements\n        }),\n        newCradleReferenceIndex = _ref8.newCradleReferenceIndex,\n        cradleItemShift = _ref8.cradleReferenceItemShift,\n        axisReferenceIndex = _ref8.newAxisReferenceIndex,\n        axisItemShift = _ref8.axisReferenceItemShift,\n        cradleContentCount = _ref8.newCradleContentCount,\n        listStartChangeCount = _ref8.listStartChangeCount,\n        listEndChangeCount = _ref8.listEndChangeCount,\n        axisViewportPixelOffset = _ref8.newAxisViewportPixelOffset;\n      // third abandon option/3; nothing to do\n      if (axisItemShift == 0 && cradleItemShift == 0) {\n        // can happen first row\n        return;\n      }\n      // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true;\n      // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect modified content\n      var updatedContentList,\n        deletedContentItems = [];\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref9 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles\n        });\n        var _ref10 = _slicedToArray(_ref9, 2);\n        updatedContentList = _ref10[0];\n        deletedContentItems = _ref10[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n      if (deletedContentItems.length && cache == 'cradle') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cradle', deleteList);\n          };\n        }\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      }\n      // ----------------------------------[ 5. allocate cradle content ]--------------------------\n      var _ref11 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: updatedContentList,\n          axisReferenceIndex: axisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref12 = _slicedToArray(_ref11, 2),\n        headcontent = _ref12[0],\n        tailcontent = _ref12[1];\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, 'updateCradleContent', cstate);\n      }\n      // -------------------------------[ 6. set css changes ]-------------------------\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      if (cradleInheritedProperties.orientation == 'vertical') {\n        var topPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = topPos + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      } else {\n        // 'horizontal'\n        var leftPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = leftPos + 'px';\n        headElement.style.paddingRight = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      }\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      stateHandler.setCradleState('renderupdatedcontent');\n    };\n    // ===================[ RECONFIGURE THE SCROLLBLOCK FOR VARIABLE CONTENT ]=======================\n    // Called for variale layout only. All DOM elements should have been rendered at this point\n    // sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n    // this to get closer to natural proportions to minimize janky scroll thumb\n    this.adjustScrollblockForVariability = function (source) {\n      // ----------------------[ setup base values and references ]------------------------\n      // resources...\n      var cradleParameters = _this.cradleParameters,\n        cradleHandlers = cradleParameters.handlersRef.current,\n        ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var layoutHandler = cradleHandlers.layoutHandler,\n        scrollHandler = cradleHandlers.scrollHandler,\n        cradleElements = layoutHandler.elements,\n        cradlePositionData = layoutHandler.cradlePositionData;\n      // element references...\n      var viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild,\n        headGridElement = cradleElements.headRef.current,\n        tailGridElement = cradleElements.tailRef.current,\n        axisElement = cradleElements.axisRef.current;\n      // current configurations...\n      var axisReferenceIndex = cradlePositionData.targetAxisReferenceIndex,\n        axisViewportOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var blockScrollPos = cradlePositionData.blockScrollPos;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth;\n      var crosscount = cradleInternalProperties.crosscount,\n        listRowcount = cradleInternalProperties.listRowcount;\n      // ------------------------[ precursor calculations ]------------------------\n      // rowcounts and row offsets for positioning\n      // listRowcount taken from internal properties above\n      var headRowCount = Math.ceil(headGridElement.childNodes.length / crosscount),\n        tailRowCount = Math.ceil(tailGridElement.childNodes.length / crosscount);\n      // reference rows - cradle first/last; axis; list end\n      var axisReferenceRow = Math.ceil(axisReferenceIndex / crosscount),\n        cradleReferenceRow = axisReferenceRow - headRowCount,\n        cradleLastReferenceRow = axisReferenceRow + (tailRowCount - 1),\n        listLastReferenceRow = listRowcount - 1;\n      var preCradleRowCount = cradleReferenceRow,\n        postCradleRowCount = listLastReferenceRow - cradleLastReferenceRow;\n      // base pixel values\n      var baseCellLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      var baseHeadLength = headRowCount * baseCellLength + padding;\n      // measured pixel cradle grid values\n      var measuredTailLength;\n      if (orientation == 'vertical') {\n        measuredTailLength = tailGridElement.offsetHeight;\n      } else {\n        measuredTailLength = tailGridElement.offsetWidth;\n      }\n      var preCradlePixelLength = preCradleRowCount * baseCellLength,\n        postCradlePixelLength = postCradleRowCount * baseCellLength;\n      var computedPostAxisPixelLength = postCradlePixelLength + measuredTailLength;\n      // base figures used for preAxis #s for compatibility with repositioning, which uses base figures\n      var computedScrollblockLength = preCradlePixelLength + baseHeadLength + computedPostAxisPixelLength;\n      var basePreAxisPixelLength = (preCradleRowCount + headRowCount) * baseCellLength + padding;\n      // ------------------------[ change calculations ]----------------------\n      var variableAdjustment = blockScrollPos + axisViewportOffset - basePreAxisPixelLength;\n      // change blockScrollPos\n      var reposition = false;\n      if (source == 'afterscroll') {\n        blockScrollPos -= variableAdjustment;\n        reposition = true;\n      }\n      var newAxisScrollblockOffset = blockScrollPos + axisViewportOffset - variableAdjustment;\n      var resetscroll = false;\n      if (axisReferenceRow == 0) {\n        if (variableAdjustment > 0 || newAxisScrollblockOffset > padding) {\n          variableAdjustment = 0;\n          newAxisScrollblockOffset = padding;\n          resetscroll = true;\n        }\n      }\n      var newScrollblockLength = computedScrollblockLength + variableAdjustment;\n      // -----------------------[ application ]-------------------------\n      // change scrollblockElement top and height, or left and width,\n      //    and axisElement top or left\n      if (orientation == 'vertical') {\n        // the scrollblock top is moved to compensate for the cumulative variability\n        scrollblockElement.style.top = !variableAdjustment ? null : variableAdjustment + 'px';\n        // the axis is moved in the opposite direction to maintain viewport position\n        axisElement.style.top = newAxisScrollblockOffset + 'px';\n        // the height is adjusted by both deltas, as it controls the scroll length\n        scrollblockElement.style.height = newScrollblockLength + 'px';\n      } else {\n        // 'horizontal'\n        scrollblockElement.style.left = !variableAdjustment ? null : variableAdjustment + 'px';\n        // scrollblockElement.style.left = variableAdjustment + 'px'\n        axisElement.style.left = newAxisScrollblockOffset + 'px';\n        scrollblockElement.style.width = newScrollblockLength + 'px';\n      }\n      if (resetscroll) {\n        // top of list\n        viewportElement.scrollTo(0, 0);\n        viewportElement[cradlePositionData.blockScrollProperty] = 0;\n        scrollHandler.resetScrollData(0);\n      }\n      // must be done after length is updated\n      if (reposition) {\n        // reset blockScrollPos afterscroll\n        cradlePositionData.blockScrollPos = blockScrollPos;\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n        scrollHandler.resetScrollData(blockScrollPos);\n      }\n    };\n    // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cacheMax = _this$cradleParameter2.cacheMax,\n        MAX_CACHE_OVER_RUN = _this$cradleParameter2.MAX_CACHE_OVER_RUN;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      var modelComponentList = _this.content.cradleModelComponents;\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n        scrollerID = cradleInheritedProperties.scrollerID;\n      if (cache == 'keepload') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n          serviceHandler = cradleHandlers.serviceHandler;\n        var modelIndexList = _this.getModelIndexList();\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cacheMax', deleteList);\n          };\n        }\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.cacheProps.modified = true;\n          cacheHandler.renderPortalList();\n        }\n      }\n    };\n    // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n    this.cradleParameters = cradleParameters;\n  }\n  // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n  _createClass(ContentHandler, [{\n    key: \"getModelIndexList\",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    }\n    // called from service handler's remapIndexes, as last step\n  }, {\n    key: \"reconcileCellFrames\",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n      function processComponent(component, i, array) {\n        var _component$props = component.props,\n          index = _component$props.index,\n          itemID = _component$props.itemID;\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n          if (newItemID != itemID) {\n            // defensive; shouldn't happen\n            array[i] = react_1[\"default\"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n      cradleModelComponents.forEach(processComponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports moveIndex and insertRemoveIndex\n  }, {\n    key: \"changeCradleItemIDs\",\n    value: function changeCradleItemIDs(changeList) {\n      if (changeList.length == 0) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var _cacheHandler$cachePr = cacheHandler.cacheProps,\n        indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap,\n        metadataMap = _cacheHandler$cachePr.metadataMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = changeList.indexOf(index);\n        if (ptr != -1) {\n          var itemID = indexToItemIDMap.get(index);\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: itemID\n          });\n        }\n      }\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports insertRemoveIndex\n  }, {\n    key: \"createNewItemIDs\",\n    value: function createNewItemIDs(newList) {\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = newList.indexOf(index);\n        if (ptr != -1) {\n          var newItemID = cacheHandler.getNewItemID();\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: newItemID\n          });\n        }\n      }\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n  }]);\n  return ContentHandler;\n}();\nexports[\"default\"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFtQixDQUFDMEYsTUFBTSxDQUFDO01BQ3pHLElBQUksQ0FBQ3hDLE9BQU8sQ0FBQ2pELG1CQUFtQixHQUFHRixxQkFBcUIsQ0FBQzJMLEtBQUssQ0FBQyxJQUFJLENBQUN4SSxPQUFPLENBQUNsRCxtQkFBbUIsQ0FBQzBGLE1BQU0sQ0FBQztJQUUzRztFQUFDO0VBQUE7QUFBQTtBQTEyQkx1RyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50aGFuZGxlci50c3g/YTg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb250ZW50aGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgc3VwcG9ydHMgdGhlIHNldHVwIGFuZCByb2xsb3ZlciBhbmQgcG9zaXRpb25pbmcgb2YgY29udGVudCBpbiB0aGUgQ3JhZGxlLiBcblxuICAgIFRoZXJlIGFyZSB0aHJlZSBrZXkgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlOiBzZXRDcmFkbGVDb250ZW50LCB1cGRhdGVDcmFkbGVDb250ZW50LCBhbmRcbiAgICBhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5LlxuXG4gICAgVGhlcmUgYXJlIGFsc28gYSBmZXcgZnVuY3Rpb25zIHdoaWNoIHN1cHBvcnQgc3luY2hyb25pemF0aW9uIG9mIENyYWRsZSBjb250ZW50IHdpdGggY2FjaGUgXG4gICAgY29udGVudCAoc2VlIGludGVybmFsIGFuZCBleHRlcm5hbCBzZXJ2aWNlcyBiZWxvdykuXG5cbiAgICBzZXRDcmFkbGVDb250ZW50IGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIENyYWRsZSAoaW4gdGhlIHN0YXRlIG1hbmFnZXIpLCBhbmQgaW5zdGFudGlhdGVzIG5ldyBDcmFkbGVcbiAgICBjb250ZW50IGluIHJlc3BvbnNlIHRvIHRoZSBzY3JvbGxlciBzZXR1cCwgb3IgY2hhbmdlcyB0byBpdHMgY29uZmlndXJhdGlvbi4gc2V0Q3JhZGxlQ29udGVudFxuICAgIGNyZWF0ZXMgYSBsaXN0IG9mIENyYWRsZSBjb250ZW50IENlbGxGcmFtZXMsIGFuZCBhbGxvY2F0ZXMgdGhvc2UgdG8gdGhlIHR3byBDcmFkbGUgZ3JpZHMuIFRoaXMgXG4gICAgcHJvY2VzcyBvY2N1cnMgaW4gcmVzcG9uc2UgdG8gbWFueSBzdGF0ZSBjaGFuZ2VzLCBzdWNoIGFzIGZpbmlzaHJlcG9zaXRpb24sIHBpdm90LCBhIGhvc3Qgc2Nyb2xsdG9cbiAgICByZXF1ZXN0LCBhbmQgbW9yZS5cblxuICAgIHVwZGF0ZUNyYWRsZUNvbnRlbnQgcm9sbHMgb3ZlciB0aGUgQ3JhZGxlIGNvbnRlbnQgaW4gcmVzcG9uc2UgdG8gdXNlciBzY3JvbGxpbmcuIFdoZW4gc2Nyb2xsaW5nIFxuICAgIHRhaWx3YXJkLCBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgQ3JhZGxlIGhlYWQgYW5kIGFkZGVkIHRvIHRoZSBDcmFkbGUgdGFpbC4gV2hlbiBzY3JvbGxpbmcgXG4gICAgaGVhZHdhcmQsIHRoZSByZXZlcnNlIG9jY3Vycy5cblxuICAgIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkgcmVjb25maWd1cmVzIHRoZSBzY3JvbGxibG9jayB0byBhY2NvbW1vZGF0ZSB2YXJpYWJsZSBzaXplZCBncmlkIHJvd3MuXG5cbiAgICBUaGUgQ3JhZGxlICh0aHJvdWdoIHRoZSBjb250ZW50ZnVuY3Rpb25zIG1vZHVsZSkgZGVsZWdhdGVzIGZldGNoaW5nIGNvbnRlbnQgaXRlbXMgdG8gdGhlIENlbGxGcmFtZS5cblxuICAgIFRoaXMgbW9kdWxlIGlzIHN1cHBvcnRlZCBwcmltYXJpbHkgYnkgdGhlIGNvbnRlbnRmdW5jdGlvbnMgbW9kdWxlLlxuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFxuICAgIGdldENvbnRlbnRMaXN0UmVxdWlyZW1lbnRzLFxuICAgIGdldFNoaWZ0SW5zdHJ1Y3Rpb24sXG4gICAgY2FsY0NvbnRlbnRTaGlmdCxcbiAgICBhbGxvY2F0ZUNvbnRlbnRMaXN0LFxuICAgIGRlbGV0ZVBvcnRhbHMsXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgXG4gICAgLy8gZ2V0R3JpZFJvd0xlbmd0aHMsXG4gICAgLy8gZ2V0R3JpZFJvd1NwYW5zLFxuXG59IGZyb20gJy4vY29udGVudGZ1bmN0aW9ucydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGVudEhhbmRsZXIge1xuXG4gICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgfVxuXG4gICBwdWJsaWMgY29udGVudCA9IHtcblxuICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgaGVhZE1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIHRhaWxNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIHR3byBvbmx5IHVzZWQgaW4gY3JhZGxlIGZvciByZW5kZXJcbiAgICAgIGhlYWREaXNwbGF5Q29tcG9uZW50czogW10sXG4gICAgICB0YWlsRGlzcGxheUNvbXBvbmVudHM6IFtdLFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwcml2YXRlIGluc3RhbmNlSWRDb3VudGVyUmVmID0ge1xuXG4gICAgICAgY3VycmVudDowXG5cbiAgICB9XG4gICAgLy8gVHdvIG1haW4gcHVibGljIG1ldGhvZHMgLSBzZXRDcmFkbGVDb250ZW50IGFuZCB1cGRhdGVDcmFkbGVDb250ZW50XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgU0VUIENPTlRFTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gcmVzZXQgdGhlIGNyYWRsZSB3aXRoIG5ldyBjb250ZW50LCBpbmNsdWRpbmcgYWxsb2NhdGlvbiBiZXR3ZWVuIGhlYWQgYW5kIHRhaWwgcGFydHMgb2YgdGhlIGNyYWRsZVxuICAgIC8vIC0gY2FsbGVkIG9ubHkgZnJvbSB0aGUgQ3JhZGxlIHN0YXRlIGhhbmRsZXJcblxuICAgIHB1YmxpYyBzZXRDcmFkbGVDb250ZW50ID0gKCBjcmFkbGVTdGF0ZSApID0+IHsgLy8gY3JhZGxlU3RhdGUgaW5mbHVlbmNlcyBzb21lIGJlaGF2aW91clxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQYXJhbWV0ZXJzIH0gPSB0aGlzXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUhhbmRsZXJzID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlcixcblxuICAgICAgICB9ID0gY3JhZGxlSGFuZGxlcnNcblxuICAgICAgICAvLyB0aGUgdHJpZ2dlcmxpbmVzIGFuZCBjcmFkbGUgZ3JpZHMgd2lsbCBiZSBtb3ZlZCwgc28gZGlzY29ubmVjdCB0aGVtIGZyb20gdGhlaXIgb2JzZXJ2ZXJzLlxuICAgICAgICAvLyB0aGV5IGFyZSByZWNvbm5lY3RlZCB3aXRoICdyZW5kZXJ1cGRhdGVkY29udGVudCcgc3RhdGUgaW4gY3JhZGxlLnRzeFxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gdHJ1ZVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWVcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCA9IGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldENyYWRsZUNvbnRlbnQgMTogcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4JyxyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgpXG4gICAgICAgIGxldCB7IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IH0gPSBjcmFkbGVQb3NpdGlvbkRhdGFcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHtjcm9zc2NvdW50LCBsaXN0c2l6ZSwgbGlzdFJvd2NvdW50fSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIC8vIGlmIChjcm9zc2NvdW50ID09IDApIHJldHVybiAvLyBUT0RPIGNoZWNrIHZhbGlkaXR5XG5cbiAgICAgICAgbGV0IHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4ocmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4LGxpc3RzaXplIC0gMSlcbiAgICAgICAgd29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggLT0gKHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Q3JhZGxlQ29udGVudCAyOiB3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCwgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4LCBsaXN0c2l6ZSwgY3Jvc3Njb3VudCwgY3JhZGxlUG9zaXRpb25EYXRhJyxcbiAgICAgICAgLy8gICAgIHdvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4LCByZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgsIGxpc3RzaXplLCBjcm9zc2NvdW50LCBjcmFkbGVQb3NpdGlvbkRhdGEpXG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBhdCByb3cgYm91bmRhcnlcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcicsIFxuICAgICAgICAgICAgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJyxcbiAgICAgICAgICAgICdmaW5pc2hyZXBvc2l0aW9uJywgXG4gICAgICAgICAgICAncmVjb25maWd1cmUnLCBcbiAgICAgICAgICAgICdzY3JvbGx0bycsIFxuICAgICAgICBdLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgICh3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKT9cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzpcbiAgICAgICAgICAgICAgICAgICAgZ2FwIC8vIGRlZmF1bHRcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NvbnRlbnRMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGdldCBjb250ZW50IHJlcXVpcmVtZW50cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGJhc2VSb3dMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggcmVwbGFjZXMgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGhlcmVcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgICAgICAvLyBjb3VudHNcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudDpjcmFkbGVDb250ZW50Q291bnQsIFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgc2Nyb2xsUG9zIGJ5IHBpeGVsc1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0OnNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICB9ID0gZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMoe1xuXG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxcbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6d29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyByZXNldCBzY3JvbGxibG9jayBPZmZzZXQgYW5kIGxlbmd0aFxuICAgICAgICBjb25zdCBzY3JvbGxibG9ja0VsZW1lbnQgPSB2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZFxuXG4gICAgICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdFJvd2NvdW50ICogYmFzZVJvd0xlbmd0aCkgLSBnYXAgLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncGl2b3QnKSB7XG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmhlaWdodCA9IGJhc2VsZW5ndGggKyAncHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGJhc2VsZW5ndGggKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IC8vIHNlbWFudGljc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIGdldCBhbmQgY29uZmlnIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIC8vIHJldHVybnMgY29udGVudCBjb25zdHJhaW5lZCBieSBjcmFkbGVSb3djb3VudFxuICAgICAgICBjb25zdCBbbmV3Y29udGVudGxpc3QsZGVsZXRlZGl0ZW1zXSA9IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3Qoe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsICAgICAgICAgICAgXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6dGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudDowLFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICBzdHlsZXMsXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Q3JhZGxlQ29udGVudCAzOiBjcmFkbGVTdGF0ZSwgY3JhZGxlQ29udGVudENvdW50LCBuZXdjb250ZW50bGlzdCwgZGVsZXRlZGl0ZW1zLCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgnLFxuICAgICAgICAvLyAgICAgY3JhZGxlU3RhdGUsIGNyYWRsZUNvbnRlbnRDb3VudCwgbmV3Y29udGVudGxpc3QsIGRlbGV0ZWRpdGVtcywgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgICAgIGNvbnN0IFtoZWFkY29udGVudGxpc3QsIHRhaWxjb250ZW50bGlzdF0gPSBhbGxvY2F0ZUNvbnRlbnRMaXN0KHtcblxuICAgICAgICAgICAgY29udGVudGxpc3Q6bmV3Y29udGVudGxpc3QsXG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXg6dGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICBcbiAgICAgICAgfSlcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IG5ld2NvbnRlbnRsaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGhlYWRjb250ZW50bGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSB0YWlsY29udGVudGxpc3RcblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNzdGF0ZSA9IGNyYWRsZVN0YXRlXG5cbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKFxuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwnc2V0Q3JhZGxlQ29udGVudCcsIGNzdGF0ZSlcbiAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNC4gc2V0IENTUyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Q3JhZGxlQ29udGVudCA0OiBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQnLHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldClcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0IC8vIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgLy8gYXZvaWQgYm9ndXMgY2FsbCB0byB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCkgLy8gLSBzY3JvbGxibG9ja09mZnNldCkgXG5cbiAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9XG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgXG5cbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBsYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG5cbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0ID0gXG4gICAgICAgICAgICBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKyBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0IFxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSB0b3AgKyAncHgnXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gJ2F1dG8nXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmdCb3R0b20gPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudGxpc3QubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBnYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50bGlzdC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT1bIFVQREFURSBDT05URU5UIHRocm91Z2ggc2Nyb2xsIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVwZGF0ZUNyYWRsZUNvbnRlbnQgZG9lcyBub3QgdG91Y2ggdGhlIHZpZXdwb3J0IGVsZW1lbnQncyBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBzY3JvbGxibG9ja1xuICAgIC8vIGluc3RlYWQgaXQgcmVjb25maWd1cmVzIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3JhZGxlLiBJdCBpcyBjYWxsZWQgc29sZWx5IGZyb21cbiAgICAvLyBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayBvZiBpbnRlcnJ1cHRIYW5kbGVyLlxuICAgIC8vIHR5cGljYWxseSBjYWxsZWQgZm9yIHNjcm9sbCBhY3Rpb24sIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgaWYgdGhlIHRyaWdnZXJMaW5lQ2VsbCBjaGFuZ2VzXG4gICAgLy8gc2l6ZSB3aXRoIHZhcmlhbnQgbGF5b3V0LlxuXG4gICAgcHVibGljIHVwZGF0ZUNyYWRsZUNvbnRlbnQgPSAoXG5cbiAgICAgICAgdHJpZ2dlcmxpbmVFbnRyaWVzLCBcbiAgICAgICAgc291cmNlID0gJ25vdGlmaWNhdGlvbnMnXG5cbiAgICApID0+IHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaGFuZGxlciBzdXBwb3J0XG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsIFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlciwgXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIsIFxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICAgICAgXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHNjcm9sbCBkYXRhXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gc2Nyb2xsSGFuZGxlclxuXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvcyA9IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZVxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIC8vIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LFxuICAgICAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgICAgIGxpc3RzaXplLFxuXG4gICAgICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsV2lkdGhcblxuICAgICAgICBjb25zdCB2aWV3cG9ydExlbmd0aCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG5cbiAgICAgICAgLy8gZmlyc3QgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICAvLyBmb3IgYnJvd3NlciB0b3Agb3IgYm90dG9tIGJvdW5jZVxuICAgICAgICBpZiAoIChzY3JvbGxQb3MgPCAwKSB8fCAoKHNjcm9sbFBvcyArIHZpZXdwb3J0TGVuZ3RoKSA+IGNvbnRlbnRMZW5ndGgpKSB7IFxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JhZGxlIHNjYWZmb2xkIGFuZCB1c2VyIGNlbGxzXG4gICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gbGF5b3V0SGFuZGxlci5lbGVtZW50c1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBtb2RlbGNvbnRlbnRsaXN0ID0gY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgfHwgW10sXG4gICAgICAgICAgICBvbGRBeGlzUmVmZXJlbmNlSW5kZXggPSAoY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzWzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuXG4gICAgICAgIGNvbnN0IG9sZENyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG1vZGVsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGdldCBzaGlmdCBpbnN0cnVjdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBbc2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlckRhdGFdID0gZ2V0U2hpZnRJbnN0cnVjdGlvbih7XG4gICAgICAgICAgICBzY3JvbGxlcklEOiBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLnNjcm9sbGVySUQsXG4gICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lRW50cmllcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lU3BhbjogbGF5b3V0SGFuZGxlci50cmlnZ2VybGluZVNwYW4sXG5cbiAgICAgICAgICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnOmxheW91dEhhbmRsZXIudHJpZ2dlcmNlbGxJc0luVGFpbCxcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHNlY29uZCBhYmFuZG9uIG9wdGlvbi8zOyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdub25lJykgeyBcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAzLiBDYWxjdWxhdGUgc2hpZnRzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY3JhZGxlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQ6Y3JhZGxlSXRlbVNoaWZ0LCBcbiAgICAgICAgICAgIG5ld0F4aXNSZWZlcmVuY2VJbmRleDpheGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdDpheGlzSXRlbVNoaWZ0LCBcblxuICAgICAgICAgICAgLy8gY291bnRzXG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQ6Y3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4gICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG5cbiAgICAgICAgICAgIC8vIHBpeGVsc1xuICAgICAgICAgICAgbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6YXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIFxuXG4gICAgICAgIH0gPSBjYWxjQ29udGVudFNoaWZ0KHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbixcbiAgICAgICAgICAgIHRyaWdnZXJEYXRhLFxuICAgICAgICAgICAgc2Nyb2xsUG9zLFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50OnZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkLFxuXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudCxcbiAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdGhpcmQgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoKGF4aXNJdGVtU2hpZnQgPT0gMCAmJiBjcmFkbGVJdGVtU2hpZnQgPT0gMCkpIHsgLy8gY2FuIGhhcHBlbiBmaXJzdCByb3dcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgd2lsbCBiZSBtb3ZlZCwgc28gZGlzY29ubmVjdCB0aGVtIGZyb20gdGhlaXIgb2JzZXJ2ZXIuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiByZWNvbmZpZ3VyZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb2xsZWN0IG1vZGlmaWVkIGNvbnRlbnRcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50TGlzdCwgZGVsZXRlZENvbnRlbnRJdGVtcyA9IFtdXG5cbiAgICAgICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50IHx8IGxpc3RFbmRDaGFuZ2VDb3VudCkgeyAvLyBpZiBlaXRoZXIgaXMgbm9uLTAgdGhlbiBtb2RpZnkgY29udGVudFxuXG4gICAgICAgICAgICBbdXBkYXRlZENvbnRlbnRMaXN0LGRlbGV0ZWRDb250ZW50SXRlbXNdID0gZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCh7XG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgICAgICB3b3JraW5nQ29udGVudExpc3Q6bW9kZWxjb250ZW50bGlzdCxcbiAgICAgICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6b2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWY6dGhpcy5pbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50TGlzdCA9IG1vZGVsY29udGVudGxpc3RcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGV0ZWRDb250ZW50SXRlbXMubGVuZ3RoICYmIChjYWNoZSA9PSAnY3JhZGxlJykpIHtcblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlUG9ydGFscyhjYWNoZUhhbmRsZXIsIGRlbGV0ZWRDb250ZW50SXRlbXMsIGRMaXN0Q2FsbGJhY2spXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDUuIGFsbG9jYXRlIGNyYWRsZSBjb250ZW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IFtoZWFkY29udGVudCwgdGFpbGNvbnRlbnRdID0gYWxsb2NhdGVDb250ZW50TGlzdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdDp1cGRhdGVkQ29udGVudExpc3QsXG4gICAgICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IHVwZGF0ZWRDb250ZW50TGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudFxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSB0YWlsY29udGVudFxuXG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGxldCBjc3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjayhcblxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwndXBkYXRlQ3JhZGxlQ29udGVudCcsIGNzdGF0ZSlcbiAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA2LiBzZXQgY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wUG9zID0gc2Nyb2xsUG9zICsgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gdG9wUG9zICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnQubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9IGVsc2UgeyAvLyAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgY29uc3QgbGVmdFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRQb3MgKyAncHgnXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5nYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IGF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVuZGVydXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVsgUkVDT05GSUdVUkUgVEhFIFNDUk9MTEJMT0NLIEZPUiBWQVJJQUJMRSBDT05URU5UIF09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gQ2FsbGVkIGZvciB2YXJpYWxlIGxheW91dCBvbmx5LiBBbGwgRE9NIGVsZW1lbnRzIHNob3VsZCBoYXZlIGJlZW4gcmVuZGVyZWQgYXQgdGhpcyBwb2ludFxuICAgIC8vIHNldHMgQ1NTOiBzY3JvbGxibG9ja0VsZW1lbnQgdG9wIGFuZCBoZWlnaHQgKG9yIGxlZnQgYW5kIHdpZHRoKSwgYW5kIGF4aXNFbGVtZW50IHRvcCAob3IgbGVmdClcbiAgICAvLyB0aGlzIHRvIGdldCBjbG9zZXIgdG8gbmF0dXJhbCBwcm9wb3J0aW9ucyB0byBtaW5pbWl6ZSBqYW5reSBzY3JvbGwgdGh1bWJcbiAgICBwdWJsaWMgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSA9IChzb3VyY2UpID0+IHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBiYXNlIHZhbHVlcyBhbmQgcmVmZXJlbmNlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmVzb3VyY2VzLi4uXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpcyxcbiAgICAgICAgICAgIGNyYWRsZUhhbmRsZXJzID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciwgc2Nyb2xsSGFuZGxlciB9ID0gY3JhZGxlSGFuZGxlcnMsXG4gICAgICAgICAgICB7IFxuXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGNyYWRsZUVsZW1lbnRzLCBcbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEgXG5cbiAgICAgICAgICAgIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgLy8gZWxlbWVudCByZWZlcmVuY2VzLi4uXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGN1cnJlbnQgY29uZmlndXJhdGlvbnMuLi5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OiBheGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDogYXhpc1ZpZXdwb3J0T2Zmc2V0LFxuXG4gICAgICAgIH0gPSBjcmFkbGVQb3NpdGlvbkRhdGFcblxuICAgICAgICBsZXQgeyBcbiAgICAgICAgXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyBcblxuICAgICAgICB9ID0gY3JhZGxlUG9zaXRpb25EYXRhXG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICBsaXN0Um93Y291bnQgXG5cbiAgICAgICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29yIGNhbGN1bGF0aW9ucyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcm93Y291bnRzIGFuZCByb3cgb2Zmc2V0cyBmb3IgcG9zaXRpb25pbmdcbiAgICAgICAgLy8gbGlzdFJvd2NvdW50IHRha2VuIGZyb20gaW50ZXJuYWwgcHJvcGVydGllcyBhYm92ZVxuICAgICAgICBjb25zdCBoZWFkUm93Q291bnQgPSBNYXRoLmNlaWwoaGVhZEdyaWRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoL2Nyb3NzY291bnQpLFxuICAgICAgICAgICAgdGFpbFJvd0NvdW50ID0gTWF0aC5jZWlsKHRhaWxHcmlkRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aC9jcm9zc2NvdW50KVxuXG4gICAgICAgIC8vIHJlZmVyZW5jZSByb3dzIC0gY3JhZGxlIGZpcnN0L2xhc3Q7IGF4aXM7IGxpc3QgZW5kXG4gICAgICAgIGNvbnN0IGF4aXNSZWZlcmVuY2VSb3cgPSBNYXRoLmNlaWwoYXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpLFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlUm93ID0gYXhpc1JlZmVyZW5jZVJvdyAtIGhlYWRSb3dDb3VudCxcbiAgICAgICAgICAgIGNyYWRsZUxhc3RSZWZlcmVuY2VSb3cgPSBheGlzUmVmZXJlbmNlUm93ICsgKHRhaWxSb3dDb3VudCAtIDEpLFxuICAgICAgICAgICAgbGlzdExhc3RSZWZlcmVuY2VSb3cgPSBsaXN0Um93Y291bnQgLSAxXG5cbiAgICAgICAgY29uc3QgcHJlQ3JhZGxlUm93Q291bnQgPSBjcmFkbGVSZWZlcmVuY2VSb3csXG4gICAgICAgICAgICBwb3N0Q3JhZGxlUm93Q291bnQgPSBsaXN0TGFzdFJlZmVyZW5jZVJvdyAtIGNyYWRsZUxhc3RSZWZlcmVuY2VSb3dcblxuICAgICAgICAvLyBiYXNlIHBpeGVsIHZhbHVlc1xuICAgICAgICBjb25zdCBiYXNlQ2VsbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aFxuICAgICAgICAgICAgKSArIGdhcFxuXG4gICAgICAgIGNvbnN0IGJhc2VIZWFkTGVuZ3RoID0gKGhlYWRSb3dDb3VudCAqIGJhc2VDZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuICAgICAgICAvLyBtZWFzdXJlZCBwaXhlbCBjcmFkbGUgZ3JpZCB2YWx1ZXNcbiAgICAgICAgbGV0IG1lYXN1cmVkVGFpbExlbmd0aFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBtZWFzdXJlZFRhaWxMZW5ndGggPSB0YWlsR3JpZEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbWVhc3VyZWRUYWlsTGVuZ3RoID0gdGFpbEdyaWRFbGVtZW50Lm9mZnNldFdpZHRoXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZUNyYWRsZVBpeGVsTGVuZ3RoID0gKHByZUNyYWRsZVJvd0NvdW50ICogYmFzZUNlbGxMZW5ndGgpLFxuICAgICAgICAgICAgcG9zdENyYWRsZVBpeGVsTGVuZ3RoID0gcG9zdENyYWRsZVJvd0NvdW50ICogYmFzZUNlbGxMZW5ndGhcblxuICAgICAgICBjb25zdCBjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGggPSBwb3N0Q3JhZGxlUGl4ZWxMZW5ndGggKyBtZWFzdXJlZFRhaWxMZW5ndGhcblxuICAgICAgICAvLyBiYXNlIGZpZ3VyZXMgdXNlZCBmb3IgcHJlQXhpcyAjcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHJlcG9zaXRpb25pbmcsIHdoaWNoIHVzZXMgYmFzZSBmaWd1cmVzXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU2Nyb2xsYmxvY2tMZW5ndGggPSBwcmVDcmFkbGVQaXhlbExlbmd0aCArIGJhc2VIZWFkTGVuZ3RoICsgY29tcHV0ZWRQb3N0QXhpc1BpeGVsTGVuZ3RoXG5cbiAgICAgICAgY29uc3QgYmFzZVByZUF4aXNQaXhlbExlbmd0aCA9ICgocHJlQ3JhZGxlUm93Q291bnQgKyBoZWFkUm93Q291bnQpICogYmFzZUNlbGxMZW5ndGgpICsgcGFkZGluZ1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2hhbmdlIGNhbGN1bGF0aW9ucyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCB2YXJpYWJsZUFkanVzdG1lbnQgPSBibG9ja1Njcm9sbFBvcyArIGF4aXNWaWV3cG9ydE9mZnNldCAtIGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGhcblxuICAgICAgICAvLyBjaGFuZ2UgYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgbGV0IHJlcG9zaXRpb24gPSBmYWxzZVxuICAgICAgICBpZiAoc291cmNlID09ICdhZnRlcnNjcm9sbCcpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgLT0gdmFyaWFibGVBZGp1c3RtZW50XG5cbiAgICAgICAgICAgIHJlcG9zaXRpb24gPSB0cnVlXG4gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ID0gYmxvY2tTY3JvbGxQb3MgKyBheGlzVmlld3BvcnRPZmZzZXQgLSB2YXJpYWJsZUFkanVzdG1lbnRcblxuICAgICAgICBsZXQgcmVzZXRzY3JvbGwgPSBmYWxzZVxuICAgICAgICBpZiAoYXhpc1JlZmVyZW5jZVJvdyA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGVBZGp1c3RtZW50ID4gMCB8fCBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgPiBwYWRkaW5nICkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlQWRqdXN0bWVudCA9IDBcbiAgICAgICAgICAgICAgICBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgPSBwYWRkaW5nXG4gICAgICAgICAgICAgICAgcmVzZXRzY3JvbGwgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdTY3JvbGxibG9ja0xlbmd0aCA9IGNvbXB1dGVkU2Nyb2xsYmxvY2tMZW5ndGggKyB2YXJpYWJsZUFkanVzdG1lbnRcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgYXBwbGljYXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjaGFuZ2Ugc2Nyb2xsYmxvY2tFbGVtZW50IHRvcCBhbmQgaGVpZ2h0LCBvciBsZWZ0IGFuZCB3aWR0aCxcbiAgICAgICAgLy8gICAgYW5kIGF4aXNFbGVtZW50IHRvcCBvciBsZWZ0XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGxibG9jayB0b3AgaXMgbW92ZWQgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIGN1bXVsYXRpdmUgdmFyaWFiaWxpdHlcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBcbiAgICAgICAgICAgICAgICAhdmFyaWFibGVBZGp1c3RtZW50P1xuICAgICAgICAgICAgICAgICAgICBudWxsOlxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZUFkanVzdG1lbnQgKyAncHgnXG4gICAgICAgICAgICAvLyB0aGUgYXhpcyBpcyBtb3ZlZCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIG1haW50YWluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IGlzIGFkanVzdGVkIGJ5IGJvdGggZGVsdGFzLCBhcyBpdCBjb250cm9scyB0aGUgc2Nyb2xsIGxlbmd0aFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmhlaWdodCA9IG5ld1Njcm9sbGJsb2NrTGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IFxuICAgICAgICAgICAgICAgICF2YXJpYWJsZUFkanVzdG1lbnQ/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlQWRqdXN0bWVudCArICdweCdcbiAgICAgICAgICAgIC8vIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gdmFyaWFibGVBZGp1c3RtZW50ICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IG5ld0F4aXNTY3JvbGxibG9ja09mZnNldCArICdweCdcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld1Njcm9sbGJsb2NrTGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzZXRzY3JvbGwpIHsgLy8gdG9wIG9mIGxpc3RcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvKDAsMClcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSAwXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YSgwKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdXN0IGJlIGRvbmUgYWZ0ZXIgbGVuZ3RoIGlzIHVwZGF0ZWRcbiAgICAgICAgaWYgKHJlcG9zaXRpb24pIHsgLy8gcmVzZXQgYmxvY2tTY3JvbGxQb3MgYWZ0ZXJzY3JvbGxcblxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBibG9ja1Njcm9sbFBvc1xuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlci5yZXNldFNjcm9sbERhdGEoYmxvY2tTY3JvbGxQb3MpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBbIElOVEVSTkFMIENPTlRFTlQgTUFOQUdFTUVOVCBTRVJWSUNFUyBdPT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoKSA9PiB7IFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVNYXgsIE1BWF9DQUNIRV9PVkVSX1JVTiB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsQ29tcG9uZW50TGlzdCA9IHRoaXMuY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHNcbiBcbiAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5ndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyhjYWNoZU1heCwgbW9kZWxDb21wb25lbnRMaXN0Lmxlbmd0aCwgTUFYX0NBQ0hFX09WRVJfUlVOICkpIHtcblxuICAgICAgICAgICAgdGhpcy5wYXJlQ2FjaGVUb01heCgpXG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgcGFyZUNhY2hlVG9NYXggPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlLCBzY3JvbGxlcklEIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG4gICAgICAgIFxuICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVIYW5kbGVycyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IGNyYWRsZUhhbmRsZXJzXG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gdGhpcy5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIEVYVEVSTkFMIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN1cHBvcnRzIGNsZWFyQ2FjaGVcbiAgICBwdWJsaWMgY2xlYXJDcmFkbGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2VIYW5kbGVyIGdldENyYWRsZUluZGV4TWFwXG4gICAgLy8gYWxzbyBzdXBwb3J0cyBwYXJlQ2FjaGVUb01heCwgbWF0Y2hDYWNoZVRvQ3JhZGxlXG4gICAgcHVibGljIGdldE1vZGVsSW5kZXhMaXN0KCkge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBpZiAoIWNyYWRsZU1vZGVsQ29tcG9uZW50cykge1xuXG4gICAgICAgICAgICByZXR1cm4gW10gXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5tYXAoKGl0ZW0pPT5pdGVtLnByb3BzLmluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2UgaGFuZGxlcidzIHJlbWFwSW5kZXhlcywgYXMgbGFzdCBzdGVwXG4gICAgcHVibGljIHJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleGVzTGlzdCkge1xuXG4gICAgICAgIGlmICghbW9kaWZpZWRJbmRleGVzTGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzXG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoY29tcG9uZW50LCBpLCBhcnJheSApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIGl0ZW1JRCB9ID0gY29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRleGVzTGlzdC5pbmNsdWRlcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IFxuICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCk/XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtSUQgIT0gaXRlbUlEKSB7IC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGhhcHBlblxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc0NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgbW92ZUluZGV4IGFuZCBpbnNlcnRSZW1vdmVJbmRleFxuICAgIHB1YmxpYyBjaGFuZ2VDcmFkbGVJdGVtSURzKGNoYW5nZUxpc3QpIHtcblxuICAgICAgICBpZiAoY2hhbmdlTGlzdC5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCwgbWV0YWRhdGFNYXAgfSA9IGNhY2hlSGFuZGxlci5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnQoY29tcG9uZW50LCBpLCBhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuXG4gICAgICAgICAgICBjb25zdCBwdHIgPSBjaGFuZ2VMaXN0LmluZGV4T2YoaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChwdHIgIT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc2NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgaW5zZXJ0UmVtb3ZlSW5kZXhcbiAgICBwdWJsaWMgY3JlYXRlTmV3SXRlbUlEcyhuZXdMaXN0KSB7XG5cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnQoY29tcG9uZW50LCBpLCBhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuICAgICAgICAgICAgY29uc3QgcHRyID0gbmV3TGlzdC5pbmRleE9mKGluZGV4KVxuXG4gICAgICAgICAgICBpZiAocHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtSUQgPSBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUQ6bmV3SXRlbUlEfSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbn0iXSwibmFtZXMiOlsiQ29udGVudEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJjdXJyZW50IiwiY3JhZGxlU3RhdGUiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSGFuZGxlcnMiLCJoYW5kbGVyc1JlZiIsImNhY2hlSGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImludGVycnVwdEhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0Iiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiY3JhZGxlSW50ZXJzZWN0Iiwic2lnbmFscyIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsInJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImNhY2hlIiwic2Nyb2xsZXJJRCIsInN0eWxlcyIsImxheW91dCIsImNyb3NzY291bnQiLCJsaXN0c2l6ZSIsImxpc3RSb3djb3VudCIsIndvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4IiwiTWF0aCIsIm1pbiIsImluY2x1ZGVzIiwid29ya2luZ0NvbnRlbnRMaXN0IiwiY3JhZGxlQ29udGVudCIsImNvbnRlbnQiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVDb250ZW50Q291bnQiLCJuZXdDcmFkbGVDb250ZW50Q291bnQiLCJzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiYmFzZWxlbmd0aCIsInN0eWxlIiwibGVmdCIsInRvcCIsImhlaWdodCIsIndpZHRoIiwiYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VJbmRleCIsImxpc3RTdGFydENoYW5nZUNvdW50IiwibGlzdEVuZENoYW5nZUNvdW50IiwiaW5zdGFuY2VJZENvdW50ZXJSZWYiLCJuZXdjb250ZW50bGlzdCIsImRlbGV0ZWRpdGVtcyIsImNvbnRlbnRsaXN0IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwiaGVhZGNvbnRlbnRsaXN0IiwidGFpbGNvbnRlbnRsaXN0IiwiY2FsbGJhY2tzIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsImNzdGF0ZSIsImJsb2NrU2Nyb2xsUG9zIiwicmVzZXRTY3JvbGxEYXRhIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJoZWFkRWxlbWVudCIsImhlYWRSZWYiLCJheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCIsInBhZGRpbmdCb3R0b20iLCJsZW5ndGgiLCJwYWRkaW5nUmlnaHQiLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJzb3VyY2UiLCJzdGF0ZUhhbmRsZXIiLCJzY3JvbGxEYXRhIiwic2Nyb2xsUG9zIiwiY3VycmVudHVwZGF0ZSIsImNvbnRlbnRMZW5ndGgiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsInZpZXdwb3J0TGVuZ3RoIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJtb2RlbGNvbnRlbnRsaXN0Iiwib2xkQXhpc1JlZmVyZW5jZUluZGV4IiwicHJvcHMiLCJpbmRleCIsIm9sZENyYWRsZVJlZmVyZW5jZUluZGV4IiwidHJpZ2dlcmxpbmVTcGFuIiwiaXNGaXJzdFJvd1RyaWdnZXJDb25maWciLCJ0cmlnZ2VyY2VsbElzSW5UYWlsIiwic2hpZnRpbnN0cnVjdGlvbiIsInRyaWdnZXJEYXRhIiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVJdGVtU2hpZnQiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzSXRlbVNoaWZ0IiwiYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCIsIm5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwidXBkYXRlZENvbnRlbnRMaXN0IiwiZGVsZXRlZENvbnRlbnRJdGVtcyIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwiaGVhZGNvbnRlbnQiLCJ0YWlsY29udGVudCIsImNyYWRsZVN0YXRlUmVmIiwidG9wUG9zIiwibGVmdFBvcyIsInNldENyYWRsZVN0YXRlIiwiaGVhZEdyaWRFbGVtZW50IiwidGFpbEdyaWRFbGVtZW50IiwidGFpbFJlZiIsImF4aXNWaWV3cG9ydE9mZnNldCIsImhlYWRSb3dDb3VudCIsImNlaWwiLCJjaGlsZE5vZGVzIiwidGFpbFJvd0NvdW50IiwiYXhpc1JlZmVyZW5jZVJvdyIsImNyYWRsZVJlZmVyZW5jZVJvdyIsImNyYWRsZUxhc3RSZWZlcmVuY2VSb3ciLCJsaXN0TGFzdFJlZmVyZW5jZVJvdyIsInByZUNyYWRsZVJvd0NvdW50IiwicG9zdENyYWRsZVJvd0NvdW50IiwiYmFzZUNlbGxMZW5ndGgiLCJiYXNlSGVhZExlbmd0aCIsIm1lYXN1cmVkVGFpbExlbmd0aCIsInByZUNyYWRsZVBpeGVsTGVuZ3RoIiwicG9zdENyYWRsZVBpeGVsTGVuZ3RoIiwiY29tcHV0ZWRQb3N0QXhpc1BpeGVsTGVuZ3RoIiwiY29tcHV0ZWRTY3JvbGxibG9ja0xlbmd0aCIsImJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgiLCJ2YXJpYWJsZUFkanVzdG1lbnQiLCJyZXBvc2l0aW9uIiwibmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0IiwicmVzZXRzY3JvbGwiLCJuZXdTY3JvbGxibG9ja0xlbmd0aCIsInNjcm9sbFRvIiwiY2FjaGVNYXgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJtb2RlbENvbXBvbmVudExpc3QiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInBhcmVDYWNoZVRvTWF4IiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXAiLCJpdGVtIiwibW9kaWZpZWRJbmRleGVzTGlzdCIsImluZGV4VG9JdGVtSURNYXAiLCJwcm9jZXNzQ29tcG9uZW50IiwiY29tcG9uZW50IiwiaSIsImFycmF5IiwiaXRlbUlEIiwibmV3SXRlbUlEIiwiaGFzIiwiZ2V0IiwiZ2V0TmV3SXRlbUlEIiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImZvckVhY2giLCJzbGljZSIsImNoYW5nZUxpc3QiLCJtZXRhZGF0YU1hcCIsInByb2Nlc3Njb21wb25lbnQiLCJwdHIiLCJpbmRleE9mIiwibmV3TGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n")},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// interrupthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleIntersectionObserverCallback // responds to move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback // responds to crossing of tailward and headward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing is handled by viewport\n    scrolling interrupts handled by scrollHandler\n*/\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, InterruptHandler);\n  this.isTailCradleInView = false;\n  this.isHeadCradleInView = false;\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n    var testrootbounds = entries[0].rootBounds;\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      contentHandler = _this$cradleParameter.contentHandler,\n      stateHandler = _this$cradleParameter.stateHandler,\n      scrollHandler = _this$cradleParameter.scrollHandler,\n      layoutHandler = _this$cradleParameter.layoutHandler;\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n      scrollData.previousupdate = scrollData.currentupdate;\n      scrollData.currentupdate = scrollData.current;\n      contentHandler.updateCradleContent(entries, 'triggerlinesObserver');\n    }\n  };\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var _a;\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler,\n      scrollHandler = _this$cradleParameter2.scrollHandler,\n      layoutHandler = _this$cradleParameter2.layoutHandler;\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (entry.target.dataset.type == 'head') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (_this.signals.repositioningRequired)\n      // start reposition if no other interrupts are underway\n      {\n        var cradleState = stateHandler.cradleStateRef.current;\n        if (!((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) && !(cradleState == 'repositioningRender') && !(cradleState == 'repositioningContinuation') && !(cradleState == 'finishreposition') && !(cradleState == 'renderupdatedcontent') && !(cradleState == 'finishupdatedcontent') &&\n        // !(cradleState == 'adjustupdateforvariability') &&\n        // !(cradleState == 'adjustupdateforvariabilityafterscroll') &&\n        !ViewportContextProperties.isResizing && !(cradleState == 'finishviewportresize')) {\n          var viewportElement = ViewportContextProperties.elementRef.current;\n          var _this$cradleParameter3 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n            scrollerID = _this$cradleParameter3.scrollerID,\n            orientation = _this$cradleParameter3.orientation,\n            padding = _this$cradleParameter3.padding,\n            gap = _this$cradleParameter3.gap,\n            cellHeight = _this$cradleParameter3.cellHeight,\n            cellWidth = _this$cradleParameter3.cellWidth,\n            layout = _this$cradleParameter3.layout;\n          if (!viewportElement) {\n            console.log('SYSTEM: viewport element not set in cradleIntersectionObserverCallback', scrollerID, ViewportContextProperties);\n            return;\n          }\n          var _this$cradleParameter4 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n            listRowcount = _this$cradleParameter4.listRowcount,\n            crosscount = _this$cradleParameter4.crosscount;\n          // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n          // and getViewportDimensions in Cradle for width/height\n          var rect = viewportElement.getBoundingClientRect();\n          var top = rect.top,\n            right = rect.right,\n            bottom = rect.bottom,\n            left = rect.left;\n          var width = right - left,\n            height = bottom - top;\n          // update for scrolltracker\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          if (layout == 'variable') {\n            // restore base config to scrollblock\n            layoutHandler.restoreBaseScrollblockConfig();\n          }\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState('startreposition');\n        }\n      }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDbEYsZ0JBQWdCLEdBQUdBLGdCQUFnQjtBQUUzQyxDQUFDO0FBTkxtRixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBDcmFkbGUgc3RydWN0dXJlIGxpc3RlbmVyczpcbiAgICAtIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgLy8gcmVzcG9uZHMgdG8gbW92ZSBvZiBib3RoIGNyYWRsZSBncmlkcyBvdXRzaWRlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMgaW5pdGlhdGVzIHRoZSByZXBvc2l0aW9uaW5nIHByb3RvY29sXG4gICAgLSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayAvLyByZXNwb25kcyB0byBjcm9zc2luZyBvZiB0YWlsd2FyZCBhbmQgaGVhZHdhcmQgdHJpZ2dlcmxpbmVzXG4gICAgICAgIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydCwgYW5kIHRyaWdnZXJzIHJvbGxvdmVyIGFuZCByZS1hbGxvY2F0aW9uIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICB2aWV3cG9ydFJlc2l6aW5nIGlzIGhhbmRsZWQgYnkgdmlld3BvcnRcbiAgICBzY3JvbGxpbmcgaW50ZXJydXB0cyBoYW5kbGVkIGJ5IHNjcm9sbEhhbmRsZXJcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVycnVwdEhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwcml2YXRlIGlzVGFpbENyYWRsZUluVmlldyA9IGZhbHNlXG4gICAgcHJpdmF0ZSBpc0hlYWRDcmFkbGVJblZpZXcgPSBmYWxzZVxuXG4gICAgcHJpdmF0ZSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyKSB7IFxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdHJvb3Rib3VuZHMgPSBlbnRyaWVzWzBdLnJvb3RCb3VuZHNcbiAgICAgICAgaWYgKCh0ZXN0cm9vdGJvdW5kcy53aWR0aCA9PSAwKSAmJiAodGVzdHJvb3Rib3VuZHMuaGVpZ2h0ID09IDApKSB7IC8vIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbERhdGEgfSA9IHNjcm9sbEhhbmRsZXJcblxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZVxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50XG5cbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnVwZGF0ZUNyYWRsZUNvbnRlbnQoZW50cmllcywndHJpZ2dlcmxpbmVzT2JzZXJ2ZXInKVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNpZ25hbHMgPSB0aGlzLnNpZ25hbHNcbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLCBcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsIFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlciBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWRDcmFkbGVJblZpZXcgPSBcbiAgICAgICAgICAgICAgICAgICAgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUYWlsQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyAgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGVudHJ5LnJvb3RCb3VuZHMud2lkdGggPT0gMCkgJiYgKGVudHJ5LnJvb3RCb3VuZHMuaGVpZ2h0ID09IDApKSAvLyByZXBhcmVudGluZ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSAoIXRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ICYmICF0aGlzLmlzVGFpbENyYWRsZUluVmlldylcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkKSAvLyBzdGFydCByZXBvc2l0aW9uIGlmIG5vIG90aGVyIGludGVycnVwdHMgYXJlIHVuZGVyd2F5XG4gICAgICAgIHtcblxuICAgICAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZj8uY3VycmVudCAmJlxuXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpICYmIFxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSAmJlxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ2ZpbmlzaHJlcG9zaXRpb24nKSAmJiBcblxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ3JlbmRlcnVwZGF0ZWRjb250ZW50JykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAnZmluaXNodXBkYXRlZGNvbnRlbnQnKSAmJlxuXG4gICAgICAgICAgICAgICAgLy8gIShjcmFkbGVTdGF0ZSA9PSAnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHknKSAmJlxuICAgICAgICAgICAgICAgIC8vICEoY3JhZGxlU3RhdGUgPT0gJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5YWZ0ZXJzY3JvbGwnKSAmJlxuXG4gICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZyAmJlxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJylcblxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCwgXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgXG5cbiAgICAgICAgICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTWVNURU06IHZpZXdwb3J0IGVsZW1lbnQgbm90IHNldCBpbiBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySUQsVmlld3BvcnRDb250ZXh0UHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGlzdFJvd2NvdW50LCBjcm9zc2NvdW50IH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZGltZW5zaW9ucyB3aXRoIGNyYWRsZSBpbnRlcnNlY3Rpb24uIFNlZSBhbHNvIGRpbWVuc2lvbiB1cGRhdGUgaW4gdmlld3BvcnQudHN4IGZvciByZXNpemVcbiAgICAgICAgICAgICAgICAvLyBhbmQgZ2V0Vmlld3BvcnREaW1lbnNpb25zIGluIENyYWRsZSBmb3Igd2lkdGgvaGVpZ2h0XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHZpZXdwb3J0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gcmVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0LCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZm9yIHNjcm9sbHRyYWNrZXJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLnZpZXdwb3J0RGltZW5zaW9ucyA9IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9IFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sodHJ1ZSlcblxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgeyAvLyByZXN0b3JlIGJhc2UgY29uZmlnIHRvIHNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5yZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnKClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgIHB1YmxpYyBjcmFkbGVJbnRlcnNlY3QgPSB7ICAgIFxuICAgICAgICBvYnNlcnZlcjpudWxsLCAgICBcbiAgICAgICAgY2FsbGJhY2s6dGhpcy5jcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBjb25uZWN0RWxlbWVudHM6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudGFpbFJlZi5jdXJyZW50KVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKSAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICB9XG4gICAgfVxuXG4gICBwdWJsaWMgdHJpZ2dlcmxpbmVzSW50ZXJzZWN0ID0ge1xuICAgICAgICBvYnNlcnZlcjpudWxsLFxuICAgICAgICBjYWxsYmFjazp0aGlzLmF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBjb25uZWN0RWxlbWVudHM6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2lnbmFscyA9IHtcbiAgICAgICAgcmVwb3NpdGlvbmluZ1JlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlcjogZmFsc2UsIFxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyOmZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvciBcbiAgICAgICAgY3JhZGxlOlxuICAgICAgICAtIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgIC0gdHJpZ2dlciBjcmFkbGVyZXNpemluZ1xuICAgICAgICAtIHRyaWdnZXIgcmVjb25maWd1cmF0aW9uXG4gICAgICAgIC0gdHJpZ2dlciBwaXZvdFxuICAgICAgICBzZXJ2aWNlaGFuZGxlcjpcbiAgICAgICAgLSBjYWxsIHJlbG9hZFxuICAgICovXG4gICAgcHVibGljIHBhdXNlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuICAgIH1cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvclxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gcmVzdG9yZWludGVycnVwdHNcbiAgICAqL1xuICAgIHB1YmxpYyByZXN0b3JlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gZmFsc2VcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJJbnRlcnJ1cHRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImVudHJpZXMiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInRlc3Ryb290Ym91bmRzIiwicm9vdEJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiY29udGVudEhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsImlzTW91bnRlZFJlZiIsInNjcm9sbERhdGEiLCJwcmV2aW91c3VwZGF0ZSIsImN1cnJlbnR1cGRhdGUiLCJ1cGRhdGVDcmFkbGVDb250ZW50Iiwic2VydmljZUhhbmRsZXIiLCJwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyIiwiaSIsImxlbmd0aCIsImVudHJ5IiwidGFyZ2V0IiwiZGF0YXNldCIsInR5cGUiLCJpc0hlYWRDcmFkbGVJblZpZXciLCJpc0ludGVyc2VjdGluZyIsImlzVGFpbENyYWRsZUluVmlldyIsInJlcG9zaXRpb25pbmdSZXF1aXJlZCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImlzUmVwYXJlbnRpbmdSZWYiLCJpc1Jlc2l6aW5nIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJzY3JvbGxlcklEIiwib3JpZW50YXRpb24iLCJwYWRkaW5nIiwiZ2FwIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsImNvbnNvbGUiLCJsb2ciLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJsaXN0Um93Y291bnQiLCJjcm9zc2NvdW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInZpZXdwb3J0RGltZW5zaW9ucyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnIiwic2V0Q3JhZGxlU3RhdGUiLCJvYnNlcnZlciIsImNhbGxiYWNrIiwiY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayIsImNvbm5lY3RFbGVtZW50cyIsImNyYWRsZUludGVyc2VjdCIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJvYnNlcnZlIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJjcmVhdGVPYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdCIsInRocmVzaG9sZCIsImF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrIiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0IiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZiIsInBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n")},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// layouthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the head and tail triggerlines\n    The key control values are the blockScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferenceIndex (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, LayoutHandler);\n    this.triggercellIsInTail = false;\n    // cradlePositionData controls the relative positions of the scaffold elements\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToIndex call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // into the viewport\n    };\n    // called by interruptHandler\n    this.restoreBaseScrollblockConfig = function () {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var scrollblockElement = viewportElement.firstChild;\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        orientation = _this$cradleParameter.orientation,\n        padding = _this$cradleParameter.padding,\n        gap = _this$cradleParameter.gap,\n        cellHeight = _this$cradleParameter.cellHeight,\n        cellWidth = _this$cradleParameter.cellWidth;\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n        listRowcount = _this$cradleParameter2.listRowcount,\n        crosscount = _this$cradleParameter2.crosscount;\n      var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        scrollHandler = _this$cradleParameter3.scrollHandler,\n        layoutHandler = _this$cradleParameter3.layoutHandler;\n      var cellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var baselength = listRowcount * cellLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var axisReference = cradlePositionData.targetAxisReferenceIndex;\n      var rowOffset = Math.ceil(axisReference / crosscount);\n      var calculatedBlockScrollPos = rowOffset * cellLength + padding;\n      viewportElement[cradlePositionData.blockScrollProperty] = calculatedBlockScrollPos;\n      cradlePositionData.blockScrollPos = calculatedBlockScrollPos;\n      scrollHandler.resetScrollData(calculatedBlockScrollPos);\n      scrollHandler.calcImpliedRepositioningData();\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n      axisRef = _cradleParameters$cra.axisRef,\n      headRef = _cradleParameters$cra.headRef,\n      tailRef = _cradleParameters$cra.tailRef,\n      triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    // progression of references: implied->target\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    // console.log(\'layouthandler init: cradlePositionData\',this.cradlePositionData)\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      var span = orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop :\n      // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n      return span;\n    }\n  }]);\n  return LayoutHandler;\n}();\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTO01BQzdEO01BQ0EsSUFBSSxDQUFDTCxRQUFRLENBQUNELDZCQUE2QixDQUFDckMsT0FBTyxDQUFDNEMsVUFBVSxHQUM5RCxJQUFJLENBQUNOLFFBQVEsQ0FBQ0YsNkJBQTZCLENBQUNwQyxPQUFPLENBQUM0QyxVQUFVO01BRWxFLE9BQU9GLElBQUk7SUFDZjtFQUFDO0VBQUE7QUFBQTtBQXhETEcsa0JBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvbGF5b3V0aGFuZGxlci50c3g/MDdiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsYXlvdXRoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBob2xkcyByZWZlcmVuY2VzIHRvIFxuICAgIC0gdGhlIHN0cnVjdHVyYWwgZWxlbWVudHMgb2YgdGhlIGNyYWRsZVxuICAgIC0gdGhlIGtleSBjb250cm9sIHZhbHVlcyBvZiB0aGUgY3JhZGxlXG5cbiAgICBUaGUgc3RydWN0dXJhbCBlbGVtZW50cyBhcmUgdGhlIGF4aXMsIGhlYWQgKGdyaWQpLCB0YWlsIChncmlkKSwgXG4gICAgICAgIGFuZCB0aGUgaGVhZCBhbmQgdGFpbCB0cmlnZ2VybGluZXNcbiAgICBUaGUga2V5IGNvbnRyb2wgdmFsdWVzIGFyZSB0aGUgYmxvY2tTY3JvbGxQb3MgKHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0KSwgdGhlIGJsb2NrIHNjcm9sbFxuICAgICAgICBwcm9wZXJ0eSAoXCJzY3JvbGxUb3BcIiBvciBcInNjcm9sbExlZnRcIiksIHRoZSB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggKGZpcnN0IGluZGV4IG9mIHRoZVxuICAgICAgICB0YWlsIGJsb2NrKSwgYW5kIHRoZSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCAocGl4ZWxzIG9mZnNldCBmcm9tIHRoZSBlZGdlIG9mIHRoZSBcbiAgICAgICAgdmlld3BvcnQpXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXlvdXRIYW5kbGVyIHsgXG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGF4aXNSZWYsIFxuICAgICAgICAgICAgaGVhZFJlZiwgXG4gICAgICAgICAgICB0YWlsUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZixcbiAgICAgICAgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHtcbiAgICAgICAgICAgIGF4aXNSZWYsXG4gICAgICAgICAgICBoZWFkUmVmLFxuICAgICAgICAgICAgdGFpbFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHByb2dyZXNzaW9uIG9mIHJlZmVyZW5jZXM6IGltcGxpZWQtPnRhcmdldFxuICAgICAgICB0aGlzLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBcbiAgICAgICAgICAgIChNYXRoLm1pbihzdGFydGluZ0luZGV4LChsaXN0c2l6ZSAtIDEpKSB8fCAwKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbGF5b3V0aGFuZGxlciBpbml0OiBjcmFkbGVQb3NpdGlvbkRhdGEnLHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhKVxuICAgICAgICB0aGlzLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IDBcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHVibGljIGdldCB0cmlnZ2VybGluZVNwYW4oKSB7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHNwYW4gPSAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0VG9wIC0gXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLmN1cnJlbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZi5jdXJyZW50Lm9mZnNldExlZnQgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgcmV0dXJuIHNwYW5cbiAgICB9XG5cbiAgICBwdWJsaWMgdHJpZ2dlcmNlbGxJbmRleFxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbElzSW5UYWlsID0gZmFsc2VcblxuICAgIC8vIGNyYWRsZVBvc2l0aW9uRGF0YSBjb250cm9scyB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIHRoZSBzY2FmZm9sZCBlbGVtZW50c1xuICAgIHB1YmxpYyBjcmFkbGVQb3NpdGlvbkRhdGEgPSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFwiYmxvY2tcIiA9IGNyYWRsZWJsb2NrLCB3aGljaCBpcyB0aGUgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGVkXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHNldCBieSBzY3JvbGxIYW5kbGVyIGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsaW5nLFxuICAgICAgICAgICAgYW5kIGJ5IHNldENyYWRsZUNvbnRlbnQgaW4gY29udGVudEhhbmRsZXIsIHdoaWNoIHJlcG9zaXRpb25zIHRoZSBjcmFkbGUuXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIGNyYWRsZSBpbml0aWFsaXphdGlvbiBpbiByZXNwb25zZSB0byByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICBibG9ja1Njcm9sbFBvczpudWxsLCAvLyB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnRcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdmFsdWVzIGNhbiBiZSBcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiIChvZiB0aGUgdmlld3BvcnQgZWxlbWVudCkgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBvcmllbnRhdGlvbiByZWNvbmZpZ3VyYXRpb24gZWZmZWN0IGluIGNyYWRsZSBtb2R1bGUuXG5cbiAgICAgICAgICAgIGl0IGlzIHVzZWQgd2hlcmUgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBhYm92ZS5cbiAgICAgICAgKi9cbiAgICAgICAgYmxvY2tTY3JvbGxQcm9wZXJ0eTpudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgc2V0IGJ5XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSBsYXlvdXRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gaG9zdCBzY3JvbGxUb0luZGV4IGNhbGxcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIHNjcm9sbFRyYWNrZXJBcmdzIGluIGNyYWRsZSBtb2R1bGVcbiAgICAgICAgICAgICAgICAtIHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCBpbiBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICovXG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleDpudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCBpcyBzZXQgYnlcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIGxheW91dEhhbmRsZXIgKGluaXRpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsSGFuZGxlciAoZHVyaW5nIGFuZCBhZnRlciBzY3JvbGwpXG4gICAgICAgICAgICAgICAgLSBwaXZvdCBlZmZlY3QgKGNoYW5nZSBvZiBvcmllbnRhdGlvbikgaW4gY3JhZGxlIG1vZHVsZVxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCBpcyB1c2VkIGJ5XG4gICAgICAgICAgICAgICAgLSBwcmV2aW91c0F4aXNPZmZzZXQgaW4gcGl2b3QgZWZmZWN0XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG5cbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6bnVsbCwgLy8gaW50byB0aGUgdmlld3BvcnRcblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBieSBpbnRlcnJ1cHRIYW5kbGVyXG4gICAgcHVibGljIHJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAvLyBzY3JvbGxlcklELCBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIC8vIGxheW91dCBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAvLyBzdGF0ZUhhbmRsZXIsIFxuICAgICAgICAgICAgLy8gc2VydmljZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyIFxuXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdFJvd2NvdW50ICogY2VsbExlbmd0aCkgLSBnYXAgLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYmFzZWxlbmd0aCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGJhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIGNvbnN0IGF4aXNSZWZlcmVuY2UgPSBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNvbnN0IHJvd09mZnNldCA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlL2Nyb3NzY291bnQpXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcyA9IFxuICAgICAgICAgICAgKHJvd09mZnNldCAqIGNlbGxMZW5ndGgpICsgcGFkZGluZ1xuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3NcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gY2FsY3VsYXRlZEJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcylcbiAgICAgICAgXG4gICAgICAgIHNjcm9sbEhhbmRsZXIuY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZWxlbWVudHNcblxufVxuXG4iXSwibmFtZXMiOlsiTGF5b3V0SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsIm9yaWVudGF0aW9uIiwicGFkZGluZyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJsaXN0Um93Y291bnQiLCJjcm9zc2NvdW50IiwiaGFuZGxlcnNSZWYiLCJzY3JvbGxIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsImNlbGxMZW5ndGgiLCJiYXNlbGVuZ3RoIiwic3R5bGUiLCJ0b3AiLCJoZWlnaHQiLCJsZWZ0Iiwid2lkdGgiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJheGlzUmVmZXJlbmNlIiwicm93T2Zmc2V0IiwiTWF0aCIsImNlaWwiLCJjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MiLCJyZXNldFNjcm9sbERhdGEiLCJjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhIiwiY3JhZGxlRWxlbWVudHNSZWYiLCJheGlzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmIiwiZWxlbWVudHMiLCJzdGFydGluZ0luZGV4IiwibGlzdHNpemUiLCJtaW4iLCJzcGFuIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// scrollhandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferenceIndex, and\n        targetAxisViewportPixelOffset\n*/\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ScrollHandler);\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      scrollerID = _this$cradleParameter.scrollerID,\n      SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _this$cradleParameter.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var scrollPositionCurrent = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    // keep up to date in case of reparenting interrupt\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler;\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        _this.calcImpliedRepositioningData();\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n    return false;\n  };\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter3.stateHandler,\n      contentHandler = _this$cradleParameter3.contentHandler,\n      serviceHandler = _this$cradleParameter3.serviceHandler;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n      cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n          break;\n        }\n    }\n    var cache = cradleInheritedProperties.cache,\n      layout = cradleInheritedProperties.layout;\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n    if (!['repositioningRender', 'repositioningContinuation'].includes(cradleState) && layout == 'variable') {\n      // TODO check reasoning for this\n      if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n        stateHandler.setCradleState('adjustupdateforvariabilityafterscroll');\n      }\n    }\n  };\n  // after scroll, but not after repositioning\n  this.updateReferenceData = function () {\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter4.stateHandler,\n      layoutHandler = _this$cradleParameter4.layoutHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current,\n      viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var axisVisiblePixelOffset;\n    if (cradleProps.orientation == 'vertical') {\n      axisVisiblePixelOffset = axisElement.offsetTop + scrollblockElement.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisVisiblePixelOffset = axisElement.offsetLeft + scrollblockElement.offsetLeft - viewportElement.scrollLeft;\n    }\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisVisiblePixelOffset;\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  };\n  // called from finishreposition state change call above\n  // called from updateReferenceData\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n      }\n    }\n  };\n  this.calcImpliedRepositioningData = function () {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n      cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var crosscount = cradleConfig.crosscount,\n      listsize = cradleConfig.listsize,\n      orientation = cradleProps.orientation;\n    var scrollPos, cellLength, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    var axisPixelOffset = cellLength - (scrollPos + scrollblockOffset) % cellLength;\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    // console.log('calcImpliedRepositioningData: axisReferenceIndex',axisReferenceIndex)\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n    var repositioningIndexCallback = _this.cradleParameters.handlersRef.current.serviceHandler.callbacks.repositioningIndexCallback;\n    repositioningIndexCallback && repositioningIndexCallback(axisReferenceIndex);\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDMkIsYUFBYSxDQUE5RUMsa0JBQWtCO0lBRTFCO0lBRUFBLGtCQUFrQixDQUFDbUQsd0JBQXdCLEdBQUdILGtCQUFrQjtJQUNoRWhELGtCQUFrQixDQUFDZ0MsNkJBQTZCLEdBQUdXLGVBQWU7SUFFbEUsSUFBUVMsMEJBQTBCLEdBQzlCLEtBQUksQ0FBQ2xGLGdCQUFnQixDQUFDeUIsV0FBVyxDQUFDdkIsT0FBTyxDQUFDa0MsY0FBYyxDQUFDUyxTQUFTLENBRDlEcUMsMEJBQTBCO0lBRWxDQSwwQkFBMEIsSUFBSUEsMEJBQTBCLENBQUNKLGtCQUFrQixDQUFDO0VBRWhGLENBQUM7RUE3UkcsSUFBSSxDQUFDOUUsZ0JBQWdCLEdBQUdBLGdCQUFnQjtBQUU1QyxDQUFDO0FBTkxtRixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSByZXNwb25zZSB0byBzY3JvbGxpbmcuIEl0IGFsc28gdHJpZ2dlcnMgYW4gb25BZnRlclNjcm9sbCBldmVudCAoYWZ0ZXIgYSB0aW1lb3V0KVxuICAgIEl0J3MgbWFpbiBqb2IgaXMgdG8gbWFpbnRhaW4gcmVjb3JkcyBvZiBzY3JvbGxQb3MsIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyByZXNldFNjcm9sbERhdGEgPSAoc2Nyb2xsUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSB0aGlzXG4gICAgICAgIHNjcm9sbERhdGEuc3RhcnQgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50ID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXMgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IFxuICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlcklELCBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb25DdXJyZW50ID0gXG4gICAgICAgICAgICAodGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Njcm9sbHRpbWVyaWQpXG5cbiAgICAgICAgaWYgKCh2aWV3cG9ydEVsZW1lbnQuY2xpZW50V2lkdGggPT0gMCAgJiYgdmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkgey8vIGluIGNhY2hlXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsUG9zaXRpb25DdXJyZW50IDwgMCkgeyAvLyBmb3IgU2FmYXJpXG5cbiAgICAgICAgICAgIHJldHVybiBcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge3NpZ25hbHN9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cykge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuc3RhcnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICAvLyBrZWVwIHVwIHRvIGRhdGUgaW4gY2FzZSBvZiByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzID0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnRcbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICBjb25zdCB7c3RhdGVIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICBpZiAoKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgfHwgKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJykpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSgpXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJylcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zY3JvbGx0aW1lcmlkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMub25BZnRlclNjcm9sbCgpXG5cbiAgICAgICAgfSxTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTClcblxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBvbkFmdGVyU2Nyb2xsID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHtzdGF0ZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlcn0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdSZW5kZXInOiBcbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nOlxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Njcm9sbFBvcygpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayhmYWxzZSlcbiAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHJlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNjcm9sbERhdGEuc3RhcnQgIT0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgIT0gdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNhY2hlLCBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuICAgICAgICAgICAgY29udGVudEhhbmRsZXIucGFyZUNhY2hlVG9NYXgoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFbJ3JlcG9zaXRpb25pbmdSZW5kZXInLCdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJ10uaW5jbHVkZXMoY3JhZGxlU3RhdGUpICYmXG4gICAgICAgICAgICAobGF5b3V0ID09ICd2YXJpYWJsZScpKSB7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgcmVhc29uaW5nIGZvciB0aGlzXG4gICAgICAgICAgICBpZiAoKHRoaXMuc2Nyb2xsRGF0YS5zdGFydCAhPSB0aGlzLnNjcm9sbERhdGEuY3VycmVudCkgfHwgXG4gICAgICAgICAgICAgICAgKHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50ICE9IHRoaXMuc2Nyb2xsRGF0YS5wcmV2aW91cykpIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHlhZnRlcnNjcm9sbCcpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgc2Nyb2xsLCBidXQgbm90IGFmdGVyIHJlcG9zaXRpb25pbmdcbiAgICBwcml2YXRlIHVwZGF0ZVJlZmVyZW5jZURhdGEgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIGxheW91dEhhbmRsZXIgfSBcbiAgICAgICAgICAgID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgYXhpc1Zpc2libGVQaXhlbE9mZnNldFxuICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBheGlzVmlzaWJsZVBpeGVsT2Zmc2V0ID0gXG4gICAgICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wICsgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldFRvcCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYXhpc1Zpc2libGVQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldExlZnQgKyBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1Zpc2libGVQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmICghVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmxvY2tTY3JvbGxQb3MoKVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIGZpbmlzaHJlcG9zaXRpb24gc3RhdGUgY2hhbmdlIGNhbGwgYWJvdmVcbiAgICAvLyBjYWxsZWQgZnJvbSB1cGRhdGVSZWZlcmVuY2VEYXRhXG4gICAgcHJpdmF0ZSB1cGRhdGVCbG9ja1Njcm9sbFBvcyA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qge2xheW91dEhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghKCh2aWV3cG9ydEVsZW1lbnQuY2xpZW50V2lkdGggPT0gMCkgICYmICh2aWV3cG9ydEVsZW1lbnQuY2xpZW50SGVpZ2h0ID09IDApKSkgey8vIGluIGNhY2hlXG5cbiAgICAgICAgICAgIGlmIChjcmFkbGVQcm9wcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlQ29uZmlnID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQgPSB2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZFxuXG4gICAgICAgIGNvbnN0IHsgY3Jvc3Njb3VudCwgbGlzdHNpemUgfSA9IGNyYWRsZUNvbmZpZyxcbiAgICAgICAgICAgIHsgb3JpZW50YXRpb24gfSA9IGNyYWRsZVByb3BzXG5cbiAgICAgICAgbGV0IHNjcm9sbFBvcywgY2VsbExlbmd0aCwgc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgY2VsbExlbmd0aCA9IGNyYWRsZVByb3BzLmNlbGxIZWlnaHQgKyBjcmFkbGVQcm9wcy5nYXBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrT2Zmc2V0ID0gc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldFRvcFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlUHJvcHMuY2VsbFdpZHRoICsgY3JhZGxlUHJvcHMuZ2FwXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBheGlzUGl4ZWxPZmZzZXQgPSBjZWxsTGVuZ3RoIC0gKChzY3JvbGxQb3MgKyBzY3JvbGxibG9ja09mZnNldCkgJSBjZWxsTGVuZ3RoKVxuICAgICAgICBpZiAoYXhpc1BpeGVsT2Zmc2V0ID09IChjZWxsTGVuZ3RoICsgY3JhZGxlUHJvcHMucGFkZGluZykpIHtcbiAgICAgICAgICAgIGF4aXNQaXhlbE9mZnNldCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF4aXNSb3dJbmRleCA9IE1hdGguY2VpbCgoc2Nyb2xsUG9zIC0gY3JhZGxlUHJvcHMucGFkZGluZykvY2VsbExlbmd0aClcblxuICAgICAgICBsZXQgYXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1Jvd0luZGV4ICogY3Jvc3Njb3VudFxuICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbihheGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBheGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCAtPSBkaWZmXG5cbiAgICAgICAgaWYgKGF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKSBheGlzUGl4ZWxPZmZzZXQgPSAwIC8vIGRlZmVuc2l2ZVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5sYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGE6IGF4aXNSZWZlcmVuY2VJbmRleCcsYXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1BpeGVsT2Zmc2V0XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LnNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayAmJiByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayhheGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJTY3JvbGxIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsInN0YXJ0IiwiY3VycmVudCIsInByZXZpb3VzIiwicHJldmlvdXN1cGRhdGUiLCJjdXJyZW50dXBkYXRlIiwic2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxEYXRhIiwiZSIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJzY3JvbGxlcklEIiwiU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxQb3NpdGlvbkN1cnJlbnQiLCJvcmllbnRhdGlvbiIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJjbGVhclRpbWVvdXQiLCJfc2Nyb2xsdGltZXJpZCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2lnbmFscyIsImhhbmRsZXJzUmVmIiwiaW50ZXJydXB0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsImlzU2Nyb2xsaW5nIiwibGF5b3V0SGFuZGxlciIsImNyYWRsZVBvc2l0aW9uRGF0YSIsImJsb2NrU2Nyb2xsUG9zIiwic3RhdGVIYW5kbGVyIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImNvbnRlbnRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJpc1Jlc2l6aW5nIiwiY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSIsInNldENyYWRsZVN0YXRlIiwic2V0VGltZW91dCIsIm9uQWZ0ZXJTY3JvbGwiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwidXBkYXRlQmxvY2tTY3JvbGxQb3MiLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiY2FsbGJhY2tzIiwiaXNNb3VudGVkUmVmIiwidXBkYXRlUmVmZXJlbmNlRGF0YSIsImNhY2hlIiwibGF5b3V0IiwicGFyZUNhY2hlVG9NYXgiLCJpbmNsdWRlcyIsImNyYWRsZVByb3BzIiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsInNjcm9sbGJsb2NrRWxlbWVudCIsImZpcnN0Q2hpbGQiLCJheGlzVmlzaWJsZVBpeGVsT2Zmc2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiY3JhZGxlQ29uZmlnIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3Jvc3Njb3VudCIsImxpc3RzaXplIiwic2Nyb2xsUG9zIiwiY2VsbExlbmd0aCIsInNjcm9sbGJsb2NrT2Zmc2V0IiwiY2VsbEhlaWdodCIsImdhcCIsImNlbGxXaWR0aCIsImF4aXNQaXhlbE9mZnNldCIsInBhZGRpbmciLCJheGlzUm93SW5kZXgiLCJNYXRoIiwiY2VpbCIsImF4aXNSZWZlcmVuY2VJbmRleCIsIm1pbiIsImRpZmYiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJyZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// servicehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streas, see the constructor.\n\n    The function calls avaiable to the host are:\n\n        scrollToIndex,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n\n        insertIndex,\n        removeIndex,\n        moveIndex,\n        remapIndexes,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions in cacheHandler and contentHandler. stateHandler is\n    often invoked to change state upon servicing requests.\n*/\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ServiceHandler);\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState(\'reload\');\n  };\n  this.scrollToIndex = function (index) {\n    index = Math.max(0, index);\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      layoutHandler = _this$cradleParameter.layoutHandler,\n      stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState(\'scrollto\');\n  };\n  this.setListsize = function (newlistsize) {\n    newlistsize = Math.max(0, newlistsize);\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter2.cacheHandler,\n      stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n      deleteListCallback = _this$callbacks.deleteListCallback,\n      changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback(\'change list size intervention\', deleteList);\n      };\n    }\n    cacheHandler.changeListsize(newlistsize, dListCallback, changeListsizeCallback);\n    if (cache == \'preload\' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState(\'startpreload\');\n    }\n  };\n  // ======================[ GET SNAPSHOTS ]========================\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter3.cacheHandler,\n      contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  };\n  // =================[ CACHE MANAGEMENT REQUESTS ]==================\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState(\'clearcache\');\n  };\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter4.cacheHandler,\n      contentHandler = _this$cradleParameter4.contentHandler,\n      stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n      metadataMap = _cacheHandler$cachePr.metadataMap,\n      portalMap = _cacheHandler$cachePr.portalMap,\n      indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map();\n    // =====================[ PREPARE ]======================\n    // ------------ filter out inoperable indexes and itemIDs ------------\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == \'string\') {\n          errorEntriesMap.set(index, \'itemID is a string\');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, \'itemID is not an integer\');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, \'index not in cache\');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " has not changed"));\n        } else if (!metadataMap.has(itemID)) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " not in cache"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    });\n    // -------------- filter out duplicate itemIDs ------------\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, "target itemID ".concat(itemID, " has duplicates (").concat(count, ")"));\n        changeIndexToItemIDMap["delete"](index);\n      });\n    }\n    // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n    var originalMap = new Map(); // index => itemID; before change\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    });\n    // ... and from the list of indexes to be deleted\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    });\n    // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID\'s will be orphaned, but could be remapped.\n    // orphans are resolved below\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap["delete"](index);\n      });\n    }\n    // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n    var processedIndexList = [];\n    // make changes\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n      processedIndexList.push(index);\n    });\n    // -------------- look for and delete item and index orphans --------------------\n    // if the original item\'s index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item\'s index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n    var deletedIndexToItemIDMap = new Map();\n    var portalHoldList = []; // hold deleted portals for deletion until after cradle synch\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        metadataMap["delete"](originalItemID);\n        portalHoldList.push(originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap["delete"](originalItemIDIndex);\n          }\n        }\n      }\n    });\n    // refresh the modified cache\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList();\n    // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys());\n    // for return information...\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    cacheHandler.portalHoldList = portalHoldList;\n    stateHandler.setCradleState(\'applycellframechanges\');\n    // ---------- returns for user information --------------------\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  };\n  // move must be entirely within list bounds\n  // returns list of processed indexes\n  this.moveIndex = function (toindex, fromindex) {\n    var highrange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------- define parameters ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    // remove nulls\n    toindex = toindex !== null && toindex !== void 0 ? toindex : 0;\n    fromindex = fromindex !== null && fromindex !== void 0 ? fromindex : 0;\n    highrange = highrange !== null && highrange !== void 0 ? highrange : fromindex;\n    toindex = Math.max(0, toindex);\n    fromindex = Math.max(0, fromindex);\n    highrange = Math.max(0, highrange);\n    // keep within current list size\n    var listbound = listsize - 1;\n    toindex = toindex > listbound ? listbound : toindex;\n    fromindex = fromindex > listbound ? listbound : fromindex;\n    highrange = highrange > listbound ? listbound : highrange;\n    // highrange must be >= fromindex\n    highrange = highrange >= fromindex ? highrange : fromindex;\n    var rangeincrement = highrange - fromindex + 1;\n    var moveincrement = toindex - fromindex;\n    // ---------- constrain parameters --------------\n    if (fromindex == toindex) return []; // nothing to do\n    // move must be in list bounds\n    if (moveincrement > 0) {\n      // move up\n      var targettop = toindex + (rangeincrement - 1);\n      if (targettop > listbound) return []; // out of bounds\n    }\n    // ----------- perform cache and cradle operations -----------\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter5.cacheHandler,\n      contentHandler = _this$cradleParameter5.contentHandler,\n      stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList = cacheHandler.moveIndex(toindex, fromindex, highrange);\n    if (processedIndexList.length) {\n      cacheHandler.cacheProps.modified = true;\n      cacheHandler.renderPortalList();\n      contentHandler.changeCradleItemIDs(processedIndexList);\n      stateHandler.setCradleState(\'applycellframechanges\');\n    }\n    return processedIndexList;\n  };\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  };\n  // shared logic. Returns lists of items changed, and items replaced (new items for insert)\n  // this operation changes the listsize\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    index = index !== null && index !== void 0 ? index : 0;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter6.cacheHandler,\n      contentHandler = _this$cradleParameter6.contentHandler,\n      stateHandler = _this$cradleParameter6.stateHandler;\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n      _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 4),\n      changeList = _cacheHandler$insertR2[0],\n      replaceList = _cacheHandler$insertR2[1],\n      rangeincrement = _cacheHandler$insertR2[2],\n      portalHoldList = _cacheHandler$insertR2[3];\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList();\n    cacheHandler.portalHoldList = portalHoldList;\n    contentHandler.changeCradleItemIDs(changeList);\n    if (increment == +1) contentHandler.createNewItemIDs(replaceList);\n    var content = contentHandler.content;\n    stateHandler.setCradleState(\'applycellframechanges\');\n    var changecount = rangeincrement; // semantics\n    var newlistsize = listsize + changecount;\n    _this.setListsize(newlistsize);\n    return [changeList, replaceList];\n  };\n  this.cradleParameters = cradleParameters;\n  // doing this explicitly here for documentation\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n    referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n    preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n    deleteListCallback = _cradleParameters$ext.deleteListCallback,\n    changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n    itemExceptionCallback = _cradleParameters$ext.itemExceptionCallback,\n    repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback,\n    repositioningIndexCallback = _cradleParameters$ext.repositioningIndexCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionCallback: itemExceptionCallback,\n    repositioningFlagCallback: repositioningFlagCallback,\n    repositioningIndexCallback: repositioningIndexCallback\n  };\n  this.callbacks = callbacks;\n});\nexports["default"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFFakUsSUFBUUUsT0FBTyxHQUFLcEUsY0FBYyxDQUExQm9FLE9BQU87SUFFZmpHLFlBQVksQ0FBQ0ssY0FBYyxDQUFDLHVCQUF1QixDQUFDO0lBRXBELElBQU02RixXQUFXLEdBQUdaLGNBQWMsRUFBQztJQUNuQyxJQUFNeEUsV0FBVyxHQUFHTyxRQUFRLEdBQUc2RSxXQUFXO0lBRTFDLEtBQUksQ0FBQ0MsV0FBVyxDQUFDckYsV0FBVyxDQUFDO0lBRTdCLE9BQU8sQ0FBQ2dGLFVBQVUsRUFBRUMsV0FBVyxDQUFDO0VBRXBDLENBQUM7RUFqZ0JFLElBQUksQ0FBQ2hHLGdCQUFnQixHQUFHQSxnQkFBZ0I7RUFFeEM7RUFDQSw0QkFTSUEsZ0JBQWdCLENBQUNxRyxvQkFBb0IsQ0FBQ2xHLE9BQU87SUFSN0NtRyxzQkFBc0IseUJBQXRCQSxzQkFBc0I7SUFDdEJDLG9CQUFvQix5QkFBcEJBLG9CQUFvQjtJQUNwQnJGLGtCQUFrQix5QkFBbEJBLGtCQUFrQjtJQUNsQkMsc0JBQXNCLHlCQUF0QkEsc0JBQXNCO0lBQ3RCcUYscUJBQXFCLHlCQUFyQkEscUJBQXFCO0lBQ3JCQyx5QkFBeUIseUJBQXpCQSx5QkFBeUI7SUFDekJDLDBCQUEwQix5QkFBMUJBLDBCQUEwQjtFQUk5QixJQUFNekYsU0FBUyxHQUFHO0lBQ2RxRixzQkFBc0IsRUFBdEJBLHNCQUFzQjtJQUN0QkMsb0JBQW9CLEVBQXBCQSxvQkFBb0I7SUFDcEJyRixrQkFBa0IsRUFBbEJBLGtCQUFrQjtJQUNsQkMsc0JBQXNCLEVBQXRCQSxzQkFBc0I7SUFDdEJxRixxQkFBcUIsRUFBckJBLHFCQUFxQjtJQUNyQkMseUJBQXlCLEVBQXpCQSx5QkFBeUI7SUFDekJDLDBCQUEwQixFQUExQkE7R0FDSDtFQUVELElBQUksQ0FBQ3pGLFNBQVMsR0FBR0EsU0FBUztBQUU3QixDQUFDO0FBOUJMMEYsa0JBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvc2VydmljZWhhbmRsZXIudHN4PzljYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VydmljZWhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGZpZWxkcyBzZXJ2aWNlIHJlcXVlc3RzIGZyb20gdGhlIGhvc3QuIFRoZXJlIGFyZSB0d28gZm9ybXNcbiAgICAtIHN0cmVhbWluZyBmcm9tIHRoZSBzY3JvbGxlciB0byB0aGUgaG9zdFxuICAgIC0gZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgdXNlciB0byB0aGUgc2Nyb2xsZXJcblxuICAgIEZvciB0aGUgbGlzdCBvZiBkYXRhIHN0cmVhcywgc2VlIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAgIFRoZSBmdW5jdGlvbiBjYWxscyBhdmFpYWJsZSB0byB0aGUgaG9zdCBhcmU6XG5cbiAgICAgICAgc2Nyb2xsVG9JbmRleCwgXG4gICAgICAgIHJlbG9hZCwgXG4gICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICBjbGVhckNhY2hlLCBcblxuICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgZ2V0Q2FjaGVJdGVtTWFwLFxuICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcblxuICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgcmVtb3ZlSW5kZXgsXG4gICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgIFxuICAgIFRoZSBmdW5jdGlvbnMgbGlzdGVkIGFyZSBkZWZpbmVkIGluIHRoaXMgbW9kdWxlLlxuXG4gICAgVGhlcmUgYXJlIGltcG9ydGFudCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBpbiBjYWNoZUhhbmRsZXIgYW5kIGNvbnRlbnRIYW5kbGVyLiBzdGF0ZUhhbmRsZXIgaXNcbiAgICBvZnRlbiBpbnZva2VkIHRvIGNoYW5nZSBzdGF0ZSB1cG9uIHNlcnZpY2luZyByZXF1ZXN0cy5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcnZpY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIC8vIGRvaW5nIHRoaXMgZXhwbGljaXRseSBoZXJlIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICAgY29uc3Qge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgsIGxvY2F0aW9uLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIC8vIChpbmRleClcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLCAvLyAocmVhc29uLCBkZWxldGVMaXN0KVxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLCAvLyAobmV3bGlzdHNpemUpXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjaywgLy8gKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCBsb2NhdGlvbiwgZXJyb3IpXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssIC8vIChmbGFnKSAvLyBib29sZWFuXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBcbiAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5leHRlcm5hbENhbGxiYWNrc1JlZi5jdXJyZW50XG5cbiAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayxcbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayxcbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2tcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBzZWUgYWJvdmUgZm9yIGxpc3RcbiAgICBwdWJsaWMgY2FsbGJhY2tzXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1bIEdFTkVSQUwgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyByZWxvYWQgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBpbnRlcnJ1cHRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlbG9hZCcpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2Nyb2xsVG9JbmRleCA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCxpbmRleClcblxuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmludGVycnVwdEhhbmRsZXJcbiAgICAgICAgY29uc3QgeyBsYXlvdXRIYW5kbGVyLCBzdGF0ZUhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBpbmRleFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc2Nyb2xsdG8nKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldExpc3RzaXplID0gKG5ld2xpc3RzaXplKSA9PiB7XG5cbiAgICAgICAgbmV3bGlzdHNpemUgPSBNYXRoLm1heCgwLG5ld2xpc3RzaXplKVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgfSA9IHRoaXMuY2FsbGJhY2tzXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZTpjdXJyZW50bGlzdHNpemUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2NoYW5nZSBsaXN0IHNpemUgaW50ZXJ2ZW50aW9uJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlSGFuZGxlci5jaGFuZ2VMaXN0c2l6ZShuZXdsaXN0c2l6ZSwgXG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFja1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKChjYWNoZSA9PSAncHJlbG9hZCcpICYmIChuZXdsaXN0c2l6ZSA+IGN1cnJlbnRsaXN0c2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRwcmVsb2FkJylcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgR0VUIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSW5kZXhNYXAoKVxuXG4gICAgfVxuXG4gICAgcHVibGljIGdldENhY2hlSXRlbU1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSXRlbU1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlSW5kZXhNYXAgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENyYWRsZUluZGV4TWFwKG1vZGVsSW5kZXhMaXN0KVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09WyBDQUNIRSBNQU5BR0VNRU5UIFJFUVVFU1RTIF09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2xlYXJjYWNoZScpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtYXBJbmRleGVzID0gKGNoYW5nZU1hcCkgPT4geyAvLyBpbmRleCA9PiBpdGVtSURcblxuICAgICAgICBpZiAoY2hhbmdlTWFwLnNpemUgPT0gMCkgcmV0dXJuIFtdIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLCAvLyBpdGVtSUQgdG8gY29tcG9uZW50IGRhdGEsIGluY2x1ZGluZyBpbmRleFxuICAgICAgICAgICAgcG9ydGFsTWFwLCAvLyB0d2lubmVkIHdpdGggbWV0YWRhdGFNYXAgZm9yIHBvcnRhbFxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcCAvLyBpbmRleCB0byBpdGVtSURcblxuICAgICAgICB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc1RvRGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGNoYW5nZUluZGV4VG9JdGVtSURNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgZXJyb3JFbnRyaWVzTWFwID0gbmV3IE1hcCgpXG5cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09WyBQUkVQQVJFIF09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgaW5vcGVyYWJsZSBpbmRleGVzIGFuZCBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNoYW5nZU1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PntcblxuICAgICAgICAgICAgaWYgKChpdGVtSUQgPT09IG51bGwpIHx8IChpdGVtSUQgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QucHVzaChpbmRleClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGl0ZW1JRCkgPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgYSBzdHJpbmcnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwnaXRlbUlEIGlzIG5vdCBhbiBpbnRlZ2VyJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsICdpbmRleCBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkgPT0gaXRlbUlEKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBub3QgY2hhbmdlZGApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFtZXRhZGF0YU1hcC5oYXMoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBub3QgaW4gY2FjaGVgKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBmaWx0ZXIgb3V0IGR1cGxpY2F0ZSBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IG1hcHNpemUgPSBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNpemVcblxuICAgICAgICBjb25zdCBpdGVtSURTZXQgPSBuZXcgU2V0KGNoYW5nZUluZGV4VG9JdGVtSURNYXAudmFsdWVzKCkpXG5cbiAgICAgICAgY29uc3QgaXRlbXNldHNpemUgPSBpdGVtSURTZXQuc2l6ZVxuXG4gICAgICAgIGlmIChtYXBzaXplICE9IGl0ZW1zZXRzaXplKSB7IC8vIHRoZXJlIG11c3QgYmUgZHVwbGljYXRlIGl0ZW1JRHNcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEQ291bnRNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1JRENvdW50TWFwLmhhcyhpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuc2V0KGl0ZW1JRCwgMSlcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gaXRlbUlEQ291bnRNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuc2V0KGl0ZW1JRCwgKytjb3VudCApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVJdGVtc01hcCA9IG5ldyBNYXAoKVxuICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuZm9yRWFjaCgoY291bnQsaXRlbUlEKT0+e1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUl0ZW1zTWFwLnNldChpdGVtSUQsIGNvdW50KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QgPSBbXVxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlSXRlbXNNYXAuaGFzKGl0ZW1JRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdC5wdXNoKGluZGV4KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdC5mb3JFYWNoKChpbmRleCk9PntcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZHVwbGljYXRlSXRlbXNNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBoYXMgZHVwbGljYXRlcyAoJHtjb3VudH0pYClcbiAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGNhcHR1cmUgbWFwIGJlZm9yZSBjaGFuZ2VzIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gLi4uIHRoaXMgbWFwIGlzIHVzZWQgbGF0ZXIgdG8gaWRlbnRpZnkgb3JwaGFuZWQgaXRlbSBhbmQgaW5kZXggY2FjaGUgcmVjb3JkcyBmb3IgZGVsZXRpb25cblxuICAgICAgICAvLyBmcm9tIHRoZSBsaXN0IG9mIGNoYW5nZXNcbiAgICAgICAgLy8gYm90aCBzaWRlcyBvZiBjaGFuZ2UgbWFwLi4uXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgYmVmb3JlIGNoYW5nZVxuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpPT57XG5cbiAgICAgICAgICAgIG9yaWdpbmFsTWFwLnNldChpbmRleCxpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpIC8vIGluZGV4IHRvIGJlIG1hcHBlZFxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4LGl0ZW1JRCkgLy8gdGFyZ2V0IGl0ZW1JRFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gLi4uIGFuZCBmcm9tIHRoZSBsaXN0IG9mIGluZGV4ZXMgdG8gYmUgZGVsZXRlZFxuICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIG9yaWdpbmFsTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgQ0FDSEUgT1BFUkFUSU9OUyBdPT09PT09PT09PT09PT09PVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLSBkZWxldGUgbGlzdGVkIGluZGV4ZXMgLS0tLS0tLS0tXG4gICAgICAgIC8vIGZvciBpbmRleGVzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAvLyBhc3NvY2lhdGVkIGl0ZW1JRCdzIHdpbGwgYmUgb3JwaGFuZWQsIGJ1dCBjb3VsZCBiZSByZW1hcHBlZC5cbiAgICAgICAgLy8gb3JwaGFucyBhcmUgcmVzb2x2ZWQgYmVsb3dcblxuICAgICAgICBpZiAoaW5kZXhlc1RvRGVsZXRlTGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaW5kZXhlc1RvRGVsZXRlTGlzdC5mb3JFYWNoKChpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGFwcGx5IGZpbHRlcmVkIGNoYW5nZXMgdG8gY2FjaGUgaW5kZXggbWFwIGFuZCBpdGVtSUQgbWFwIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBldmVyeSByZW1haW5pbmcgaW5kZXggbGlzdGVkIHdpbGwgY2hhbmdlIGl0cyBtYXBwaW5nXG5cbiAgICAgICAgLy8gY29uc3QgcHJvY2Vzc2VkTWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgY2hhbmdlIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gW11cblxuICAgICAgICAvLyBtYWtlIGNoYW5nZXNcbiAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5zZXQoaW5kZXgsaXRlbUlEKSAvLyBtb2RpaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDFcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1kYXRhID0gbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgaXRlbWRhdGEuaW5kZXggPSBpbmRleCAvLyBtb2RpZmljYXRpb24gYXBwbGllZCwgcGFydCAyXG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZE1hcC5zZXQoaW5kZXgsaXRlbUlEKVxuICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBsb29rIGZvciBhbmQgZGVsZXRlIGl0ZW0gYW5kIGluZGV4IG9ycGhhbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbmFsIGl0ZW0ncyBpbmRleCBoYXMgbm90IGNoYW5nZWQsIHRoZW4gaXQgaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCBcbiAgICAgICAgLy8gICAgIGl0IGlzIG9ycGhhbmVkLCBhbmQgdGhlIGl0ZW0gaXMgZGVsZXRlZFxuICAgICAgICAvLyBpZiB0aGUgaXRlbSdzIGluZGV4IGhhcyBjaGFuZ2VkLCBidXQgdGhlIG9yaWdpbmFsIGl0ZW0gaW5kZXggbWFwIHN0aWxsIHBvaW50cyB0byB0aGUgaXRlbSxcbiAgICAgICAgLy8gICAgIHRoZW4gdGhlIGluZGV4IGlzIG9ycGhhbmVkIChkdXBsaWNhdGUpLCBhbmQgZGVsZXRlZFxuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgb3JwaGFuZWQgaW5kZXhcbiAgICAgICAgY29uc3QgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBjb25zdCBwb3J0YWxIb2xkTGlzdCA9IFtdIC8vIGhvbGQgZGVsZXRlZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBjcmFkbGUgc3luY2hcblxuICAgICAgICBvcmlnaW5hbE1hcC5mb3JFYWNoKChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JREluZGV4ID0gbWV0YWRhdGFNYXAuZ2V0KG9yaWdpbmFsSXRlbUlEKS5pbmRleFxuXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJdGVtSURJbmRleCA9PSBmaW5hbEl0ZW1JREluZGV4KSB7IC8vIG5vdCByZW1hcHBlZCwgdGhlcmVmb3JlIG9ycGhhbmVkXG5cbiAgICAgICAgICAgICAgICBkZWxldGVkSXRlbUlEVG9JbmRleE1hcC5zZXQob3JpZ2luYWxJdGVtSUQsIG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcC5kZWxldGUob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsSG9sZExpc3QucHVzaChvcmlnaW5hbEl0ZW1JRClcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVtYXBwZWQsIGNoZWNrIGZvciBvcnBoYW5lZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKG9yaWdpbmFsSXRlbUlESW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxJdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEl0ZW1JRCA9PSBvcmlnaW5hbEl0ZW1JRCkgeyAvLyB0aGUgaW5kZXggaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAuc2V0KG9yaWdpbmFsSXRlbUlESW5kZXgsIG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgbW9kaWZpZWQgY2FjaGVcbiAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGFwcGx5IGNoYW5nZXMgdG8gZXh0YW50IGNlbGxGcmFtZXMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHVzZWQgdG8gcmVjb25jaWxlIGNyYWRsZSBjZWxsRnJhbWVzLCBhbmQgYWxzbyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGNvbnN0IHByb2Nlc3NlZEluZGV4TGlzdCA9IEFycmF5LmZyb20ocHJvY2Vzc2VkTWFwLmtleXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAudmFsdWVzKCkpXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICAvLyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uLi4uXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QgPSBBcnJheS5mcm9tKGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLmtleXMoKSkgXG5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kZXhMaXN0ID0gW1xuICAgICAgICAgICAgLi4ucHJvY2Vzc2VkSW5kZXhMaXN0LFxuICAgICAgICAgICAgLi4uaW5kZXhlc1RvRGVsZXRlTGlzdCwgXG4gICAgICAgICAgICAuLi5kZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdFxuICAgICAgICBdXG5cbiAgICAgICAgbW9kaWZpZWRJbmRleExpc3QgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kaWZpZWRJbmRleExpc3QudmFsdWVzKCkpKSAvLyByZW1vdmUgZHVwbGljYXRlc1xuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLnJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleExpc3QpXG4gICAgICAgIGNhY2hlSGFuZGxlci5wb3J0YWxIb2xkTGlzdCA9IHBvcnRhbEhvbGRMaXN0XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gcmV0dXJucyBmb3IgdXNlciBpbmZvcm1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBbXG5cbiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIHByb2Nlc3NlZEluZGV4TGlzdCwgXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QsIFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0LFxuICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLCBcbiAgICAgICAgICAgIGNoYW5nZU1hcFxuXG4gICAgICAgIF1cblxuICAgIH1cblxuICAgIC8vIG1vdmUgbXVzdCBiZSBlbnRpcmVseSB3aXRoaW4gbGlzdCBib3VuZHNcbiAgICAvLyByZXR1cm5zIGxpc3Qgb2YgcHJvY2Vzc2VkIGluZGV4ZXNcbiAgICBwdWJsaWMgbW92ZUluZGV4ID0gKHRvaW5kZXgsIGZyb21pbmRleCwgaGlnaHJhbmdlID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gZGVmaW5lIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gcmVtb3ZlIG51bGxzXG4gICAgICAgIHRvaW5kZXggPSB0b2luZGV4ID8/IDBcbiAgICAgICAgZnJvbWluZGV4ID0gZnJvbWluZGV4ID8/IDBcbiAgICAgICAgaGlnaHJhbmdlID0gaGlnaHJhbmdlID8/IGZyb21pbmRleFxuXG4gICAgICAgIHRvaW5kZXggPSBNYXRoLm1heCgwLHRvaW5kZXgpXG4gICAgICAgIGZyb21pbmRleCA9IE1hdGgubWF4KDAsZnJvbWluZGV4KVxuICAgICAgICBoaWdocmFuZ2UgPSBNYXRoLm1heCgwLGhpZ2hyYW5nZSlcblxuICAgICAgICAvLyBrZWVwIHdpdGhpbiBjdXJyZW50IGxpc3Qgc2l6ZVxuICAgICAgICBjb25zdCBsaXN0Ym91bmQgPSBsaXN0c2l6ZSAtIDFcblxuICAgICAgICB0b2luZGV4ID0gXG4gICAgICAgICAgICAodG9pbmRleCA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIHRvaW5kZXhcblxuICAgICAgICBmcm9taW5kZXggPSBcbiAgICAgICAgICAgIChmcm9taW5kZXggPiBsaXN0Ym91bmQpP1xuICAgICAgICAgICAgICAgIGxpc3Rib3VuZDpcbiAgICAgICAgICAgICAgICBmcm9taW5kZXhcblxuICAgICAgICBoaWdocmFuZ2UgPSBcbiAgICAgICAgICAgIChoaWdocmFuZ2UgPiBsaXN0Ym91bmQpP1xuICAgICAgICAgICAgICAgIGxpc3Rib3VuZDpcbiAgICAgICAgICAgICAgICBoaWdocmFuZ2VcblxuICAgICAgICAvLyBoaWdocmFuZ2UgbXVzdCBiZSA+PSBmcm9taW5kZXhcbiAgICAgICAgaGlnaHJhbmdlID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlID49IGZyb21pbmRleCk/XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlOlxuICAgICAgICAgICAgICAgIGZyb21pbmRleFxuXG4gICAgICAgIGNvbnN0IHJhbmdlaW5jcmVtZW50ID0gaGlnaHJhbmdlIC0gZnJvbWluZGV4ICsgMVxuICAgICAgICBjb25zdCBtb3ZlaW5jcmVtZW50ID0gdG9pbmRleCAtIGZyb21pbmRleFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gY29uc3RyYWluIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpZiAoZnJvbWluZGV4ID09IHRvaW5kZXgpIHJldHVybiBbXSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgLy8gbW92ZSBtdXN0IGJlIGluIGxpc3QgYm91bmRzXG4gICAgICAgIGlmIChtb3ZlaW5jcmVtZW50ID4gMCkgeyAvLyBtb3ZlIHVwXG4gICAgICAgICAgICBjb25zdCB0YXJnZXR0b3AgPSB0b2luZGV4ICsgKHJhbmdlaW5jcmVtZW50IC0gMSlcbiAgICAgICAgICAgIGlmICh0YXJnZXR0b3AgPiBsaXN0Ym91bmQpIHJldHVybiBbXSAvLyBvdXQgb2YgYm91bmRzXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBwZXJmb3JtIGNhY2hlIGFuZCBjcmFkbGUgb3BlcmF0aW9ucyAtLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc3RhdGVIYW5kbGVyIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIubW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgaGlnaHJhbmdlKVxuXG4gICAgICAgIGlmIChwcm9jZXNzZWRJbmRleExpc3QubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5jaGFuZ2VDcmFkbGVJdGVtSURzKHByb2Nlc3NlZEluZGV4TGlzdClcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhMaXN0XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgaW5zZXJ0SW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgKzEpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgLTEpXG5cbiAgICB9XG5cbiAgICAvLyBzaGFyZWQgbG9naWMuIFJldHVybnMgbGlzdHMgb2YgaXRlbXMgY2hhbmdlZCwgYW5kIGl0ZW1zIHJlcGxhY2VkIChuZXcgaXRlbXMgZm9yIGluc2VydClcbiAgICAvLyB0aGlzIG9wZXJhdGlvbiBjaGFuZ2VzIHRoZSBsaXN0c2l6ZVxuICAgIHByaXZhdGUgaW5zZXJ0UmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCBpbmNyZW1lbnQpID0+IHtcblxuICAgICAgICBpbmRleCA9IGluZGV4ID8/IDBcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSByYW5nZWhpZ2hpbmRleCA/PyBpbmRleFxuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCxpbmRleClcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSBNYXRoLm1heChyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBbY2hhbmdlTGlzdCwgcmVwbGFjZUxpc3QsIHJhbmdlaW5jcmVtZW50LCBwb3J0YWxIb2xkTGlzdF0gPSBcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5pbnNlcnRSZW1vdmVJbmRleChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIGluY3JlbWVudCwgbGlzdHNpemUpXG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgY2FjaGVIYW5kbGVyLnBvcnRhbEhvbGRMaXN0ID0gcG9ydGFsSG9sZExpc3RcblxuICAgICAgICBjb250ZW50SGFuZGxlci5jaGFuZ2VDcmFkbGVJdGVtSURzKGNoYW5nZUxpc3QpXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSArMSkgY29udGVudEhhbmRsZXIuY3JlYXRlTmV3SXRlbUlEcyhyZXBsYWNlTGlzdClcblxuICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGNvbnRlbnRIYW5kbGVyXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWNvdW50ID0gcmFuZ2VpbmNyZW1lbnQgLy8gc2VtYW50aWNzXG4gICAgICAgIGNvbnN0IG5ld2xpc3RzaXplID0gbGlzdHNpemUgKyBjaGFuZ2Vjb3VudCBcblxuICAgICAgICB0aGlzLnNldExpc3RzaXplKG5ld2xpc3RzaXplKVxuXG4gICAgICAgIHJldHVybiBbY2hhbmdlTGlzdCwgcmVwbGFjZUxpc3RdXG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJTZXJ2aWNlSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJzdGF0ZUhhbmRsZXIiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJpbnRlcnJ1cHRIYW5kbGVyIiwicGF1c2VJbnRlcnJ1cHRzIiwic2V0Q3JhZGxlU3RhdGUiLCJpbmRleCIsIk1hdGgiLCJtYXgiLCJzaWduYWxzIiwibGF5b3V0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsImNyYWRsZVBvc2l0aW9uRGF0YSIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsIm5ld2xpc3RzaXplIiwiY2FjaGVIYW5kbGVyIiwiY2FsbGJhY2tzIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsImN1cnJlbnRsaXN0c2l6ZSIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImxpc3RzaXplIiwiY2FjaGUiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJjaGFuZ2VMaXN0c2l6ZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJjb250ZW50SGFuZGxlciIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJnZXRDcmFkbGVJbmRleE1hcCIsImNoYW5nZU1hcCIsInNpemUiLCJjYWNoZVByb3BzIiwibWV0YWRhdGFNYXAiLCJwb3J0YWxNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwiaW5kZXhlc1RvRGVsZXRlTGlzdCIsImNoYW5nZUluZGV4VG9JdGVtSURNYXAiLCJNYXAiLCJlcnJvckVudHJpZXNNYXAiLCJmb3JFYWNoIiwiaXRlbUlEIiwidW5kZWZpbmVkIiwicHVzaCIsInNldCIsIk51bWJlciIsImlzSW50ZWdlciIsImhhcyIsImdldCIsIm1hcHNpemUiLCJpdGVtSURTZXQiLCJTZXQiLCJ2YWx1ZXMiLCJpdGVtc2V0c2l6ZSIsIml0ZW1JRENvdW50TWFwIiwiY291bnQiLCJkdXBsaWNhdGVJdGVtc01hcCIsImR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QiLCJvcmlnaW5hbE1hcCIsImxlbmd0aCIsInByb2Nlc3NlZEluZGV4TGlzdCIsIml0ZW1kYXRhIiwiZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAiLCJkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCIsInBvcnRhbEhvbGRMaXN0Iiwib3JpZ2luYWxJdGVtSUQiLCJvcmlnaW5hbEl0ZW1JREluZGV4IiwiZmluYWxJdGVtSURJbmRleCIsImZpbmFsSXRlbUlEIiwibW9kaWZpZWQiLCJyZW5kZXJQb3J0YWxMaXN0IiwiZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCIsIkFycmF5IiwiZnJvbSIsImRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCIsImtleXMiLCJkZWxldGVkT3JwaGFuZWRJdGVtSURMaXN0IiwibW9kaWZpZWRJbmRleExpc3QiLCJyZWNvbmNpbGVDZWxsRnJhbWVzIiwidG9pbmRleCIsImZyb21pbmRleCIsImhpZ2hyYW5nZSIsImxpc3Rib3VuZCIsInJhbmdlaW5jcmVtZW50IiwibW92ZWluY3JlbWVudCIsInRhcmdldHRvcCIsIm1vdmVJbmRleCIsImNoYW5nZUNyYWRsZUl0ZW1JRHMiLCJyYW5nZWhpZ2hpbmRleCIsImluc2VydFJlbW92ZUluZGV4IiwiaW5jcmVtZW50IiwiY2hhbmdlTGlzdCIsInJlcGxhY2VMaXN0IiwiY3JlYXRlTmV3SXRlbUlEcyIsImNvbnRlbnQiLCJjaGFuZ2Vjb3VudCIsInNldExpc3RzaXplIiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n')},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// statehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to the cradle state (cradleState) and the state setting\n   function (setCradleState) for other handlers.\n   It also provides access to the isMountedRef reference.\n*/\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOzs7O0FBRUE7Ozs7O0FBQUEsSUFNcUJBLFlBQVksNkJBRTdCLHNCQUFZQyxnQkFBZ0I7RUFBQTtFQUV6QixJQUFJLENBQUNBLGdCQUFnQixHQUFHQSxnQkFBZ0I7RUFFeEMsSUFBTUMsa0JBQWtCLEdBQUdELGdCQUFnQixDQUFDRSwyQkFBMkIsQ0FBQ0MsT0FBTztFQUUvRSxJQUFJLENBQUNDLGNBQWMsR0FBR0gsa0JBQWtCLENBQUNHLGNBQWM7RUFDdkQsSUFBSSxDQUFDQyxjQUFjLEdBQUdKLGtCQUFrQixDQUFDSSxjQUFjO0VBQ3ZELElBQUksQ0FBQ0MsWUFBWSxHQUFHTCxrQkFBa0IsQ0FBQ0ssWUFBWTtBQUV0RCxDQUFDO0FBWkxDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3g/NjM5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZWhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBjcmFkbGUgc3RhdGUgKGNyYWRsZVN0YXRlKSBhbmQgdGhlIHN0YXRlIHNldHRpbmcgXG4gICBmdW5jdGlvbiAoc2V0Q3JhZGxlU3RhdGUpIGZvciBvdGhlciBoYW5kbGVycy5cbiAgIEl0IGFsc28gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBpc01vdW50ZWRSZWYgcmVmZXJlbmNlLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIGNvbnN0IGludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgIHRoaXMuc2V0Q3JhZGxlU3RhdGUgPSBpbnRlcm5hbFByb3BlcnRpZXMuc2V0Q3JhZGxlU3RhdGVcbiAgICAgICB0aGlzLmNyYWRsZVN0YXRlUmVmID0gaW50ZXJuYWxQcm9wZXJ0aWVzLmNyYWRsZVN0YXRlUmVmXG4gICAgICAgdGhpcy5pc01vdW50ZWRSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuaXNNb3VudGVkUmVmXG4gICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgY3JhZGxlU3RhdGVSZWZcbiAgICBwdWJsaWMgc2V0Q3JhZGxlU3RhdGVcbiAgICBwdWJsaWMgaXNNb3VudGVkUmVmXG5cbn1cbiJdLCJuYW1lcyI6WyJTdGF0ZUhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiaW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInNldENyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc01vdW50ZWRSZWYiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// styleshandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        triggercelltriggerlineheadstyles,\n        triggercelltriggerlinetailstyles,\n        cradledividerstyles\n*/\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, StylesHandler);\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      cellMinHeight = _ref.cellMinHeight,\n      cellMinWidth = _ref.cellMinWidth,\n      gap = _ref.gap,\n      padding = _ref.padding,\n      crosscount = _ref.crosscount,\n      viewportheight = _ref.viewportheight,\n      viewportwidth = _ref.viewportwidth,\n      userstyles = _ref.userstyles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      layout = _ref.layout;\n    var headstyles = _this.getBaseHeadStyles(gap, padding, orientation, userstyles.cradle);\n    var tailstyles = _this.getBaseTailStyles(gap, padding, orientation, userstyles.cradle);\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation);\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gap = tailstyles.gap = gap + 'px';\n    if (orientation == 'vertical') {\n      // padding varies\n      headstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px 0 \").concat(padding, \"px\");\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      // the following are identical for head and tail\n      headstyles.width = tailstyles.width = '100%';\n      headstyles.height = tailstyles.height = 'auto';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = null;\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellWidth, \"px, 1fr))\");\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'row';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = layout == 'uniform' ? null : 'max-content';\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = null;\n    } else {\n      // orientation == 'horizontal'\n      headstyles.padding = \"\".concat(padding, \"px 0 \").concat(padding, \"px \").concat(padding, \"px\");\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      headstyles.width = tailstyles.width = 'auto';\n      headstyles.height = tailstyles.height = '100%';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\");\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = null;\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'column';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = null;\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = layout == 'uniform' ? null : 'max-content';\n    }\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = null;\n      right = null;\n      top = null;\n    } else {\n      bottom = null;\n      left = null;\n      right = 0;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = null;\n      left = null;\n      right = null;\n      top = 0;\n    } else {\n      bottom = null;\n      left = 0;\n      right = null;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n  this.getAxisStyles = function (gap, padding, orientation) {\n    var top, left, width, height; // for axis\n    if (orientation == 'vertical') {\n      top = padding + 'px'; // default\n      left = 'auto';\n      width = '100%';\n      height = 0;\n    } else {\n      top = 'auto';\n      left = padding + 'px'; // default\n      width = 0;\n      height = '100%';\n    }\n    return {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, left;\n    if (orientation == 'vertical') {\n      height = 0;\n      width = '100%';\n      left = 'auto';\n      top = triggerlineOffset + 'px';\n    } else {\n      height = '100%';\n      width = 0;\n      left = triggerlineOffset + 'px';\n      top = 'auto';\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      left: left\n    };\n  };\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, bottom, right;\n    if (orientation == 'vertical') {\n      height = 0;\n      width = '100%';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      right = 'auto';\n    } else {\n      height = '100%';\n      width = 0;\n      bottom = 'auto';\n      right = -(triggerlineOffset + gap) + 'px';\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      bottom: bottom,\n      right: right\n    };\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cm9sbGVyLy4vc3JjL2NyYWRsZS9zdHlsZXNoYW5kbGVyLnRzeD80NWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlc2hhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBDcmFkbGUgY29tcG9uZW50IHdpdGggb25lIGtleSBmdW5jdGlvbjogZ2V0Q3JhZGxlU3R5bGVzLlxuICAgIEl0IHJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyBmb3JcbiAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgdGFpbHN0eWxlcyxcbiAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZWhlYWRzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzLFxuICAgICAgICBjcmFkbGVkaXZpZGVyc3R5bGVzXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZXNIYW5kbGVyIHsgXG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlU3R5bGVzID0gKHtcblxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHVzZXJzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgaGVhZHN0eWxlcyA9IHRoaXMuZ2V0QmFzZUhlYWRTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IHRhaWxzdHlsZXMgPSB0aGlzLmdldEJhc2VUYWlsU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24sIHVzZXJzdHlsZXMuY3JhZGxlKVxuICAgICAgICBjb25zdCBheGlzc3R5bGVzID0gdGhpcy5nZXRBeGlzU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24pXG5cbiAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZWhlYWRzdHlsZXMgPVxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyhcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApXG4gICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzID0gXG4gICAgICAgICAgICB0aGlzLmdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcClcblxuICAgICAgICBjb25zdCBjcmFkbGVkaXZpZGVyc3R5bGVzID0gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgekluZGV4OjEsIFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OicwIDAgNXB4IDNweCByZWQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaGVhZHN0eWxlcy5nYXAgPSB0YWlsc3R5bGVzLmdhcCA9IGdhcCArICdweCdcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAvLyBwYWRkaW5nIHZhcmllc1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMCAke3BhZGRpbmd9cHhgXG4gICAgICAgICAgICB0YWlsc3R5bGVzLnBhZGRpbmcgPSBgMCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgaWRlbnRpY2FsIGZvciBoZWFkIGFuZCB0YWlsXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gdGFpbHN0eWxlcy53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSB0YWlsc3R5bGVzLmhlaWdodCA9ICdhdXRvJ1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSBudWxsXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbFdpZHRofXB4LCAxZnIpKWBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdyb3cnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9Sb3dzID0gXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRBdXRvUm93cyA9XG4gICAgICAgICAgICAgICAgKGxheW91dCA9PSAndW5pZm9ybScpP1xuICAgICAgICAgICAgICAgICAgICBudWxsOlxuICAgICAgICAgICAgICAgICAgICAnbWF4LWNvbnRlbnQnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9Db2x1bW5zID0gdGFpbHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggMCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSB0YWlsc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9IHRhaWxzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdjb2x1bW4nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvUm93cyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9Sb3dzID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICAobGF5b3V0ID09ICd1bmlmb3JtJyk/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICdtYXgtY29udGVudCdcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhlYWRzdHlsZXMsXG4gICAgICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzLFxuICAgICAgICBdXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIHRoZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgc2V0dGluZyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiBleHBhbnNpb24gb2YgdGhlIGdyaWQgYmxvY2tcbiAgICBwcml2YXRlIGdldEJhc2VIZWFkU3R5bGVzID0gXG4gICAgICAgIChnYXAscGFkZGluZyxvcmllbnRhdGlvbix1c2VyaGVhZHN0eWxlcykgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gMFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnVzZXJoZWFkc3R5bGVzLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBzZXR0aW5nIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIGV4cGFuc2lvbiBvZiB0aGUgZ3JpZCBibG9ja1xuICAgIHByaXZhdGUgZ2V0QmFzZVRhaWxTdHlsZXMgPSBcbiAgICAgICAgKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJ0YWlsc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gMFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udXNlcnRhaWxzdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRBeGlzU3R5bGVzID0gXG4gICAgICAgIChnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uKSA9PiB7XG5cbiAgICAgICAgbGV0IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCAvLyBmb3IgYXhpc1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHRvcCA9IHBhZGRpbmcgKyAncHgnIC8vIGRlZmF1bHRcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWlnaHQgPSAwXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBsZWZ0ID0gcGFkZGluZyArICdweCcgLy8gZGVmYXVsdFxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gMFxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHRvcCA9IHRyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBsZWZ0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcblxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCBib3R0b20sIHJpZ2h0XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBib3R0b20gPSAtKHRyaWdnZXJsaW5lT2Zmc2V0ICsgZ2FwKSArICdweCdcbiAgICAgICAgICAgIHJpZ2h0ID0gJ2F1dG8nXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICB3aWR0aCA9IDBcbiAgICAgICAgICAgIGJvdHRvbSA9ICdhdXRvJ1xuICAgICAgICAgICAgcmlnaHQgPSAtKHRyaWdnZXJsaW5lT2Zmc2V0ICsgZ2FwKSArICdweCdcblxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlN0eWxlc0hhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwib3JpZW50YXRpb24iLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImdhcCIsInBhZGRpbmciLCJjcm9zc2NvdW50Iiwidmlld3BvcnRoZWlnaHQiLCJ2aWV3cG9ydHdpZHRoIiwidXNlcnN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwibGF5b3V0IiwiaGVhZHN0eWxlcyIsImdldEJhc2VIZWFkU3R5bGVzIiwiY3JhZGxlIiwidGFpbHN0eWxlcyIsImdldEJhc2VUYWlsU3R5bGVzIiwiYXhpc3N0eWxlcyIsImdldEF4aXNTdHlsZXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzIiwidHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMiLCJnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiZ3JpZFRlbXBsYXRlUm93cyIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkQXV0b0Zsb3ciLCJncmlkQXV0b1Jvd3MiLCJncmlkQXV0b0NvbHVtbnMiLCJ1c2VyaGVhZHN0eWxlcyIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImRpc3BsYXkiLCJncmlkR2FwIiwiYm94U2l6aW5nIiwidXNlcnRhaWxzdHlsZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./src/infinitegridscroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// InfiniteGridScroller.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the Scrollblock, which is full size for listsize of given cell height/width.\n    Scrollblock in turn contains the Cradle - a component that contains CellFrames, which contain\n    displayed user content (items) or transitional placeholders.\n\n    Host content is instantiated in a cache of React portals (via cacheHandler). content is then\n    portal\'d to host CellFrames. The cache can be configured to hold many more items\n    than the Cradle (limited by device memory, and some eventual performance degradation), allowing\n    cached host content to maintain state.\n\n    Scrollblock by size represents the entirety of the list, and is the object that is scrolled.\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as\n    though it scrolls over a filled scrollblock, but in fact it is only slightly larger than\n    the viewport. Content is rotated in and out of the cradle (through the cache)\n    \n    Individual host items are framed by CellFrame, managed by Cradle\n\n    Overall the InfiniteGridScroller as a package manages the asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n\n    The Rigs liner is set with \'display:absolute\' and \'inset:0\', so the user containing block should\n    be styles accordingly.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n// defensive\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ "./node_modules/react-error-boundary/dist/react-error-boundary.umd.js"); // www.npmjs.com/package/react-error-boundary\n// based on module template\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n    resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert"\n  }, react_1["default"].createElement("p", null, "Oops! Something went wrong inside react-infinite-grid-scroller."), react_1["default"].createElement("p", null, "Click to cancel the error and continue."), react_1["default"].createElement("button", {\n    onClick: resetErrorBoundary\n  }, "Cancel error"), react_1["default"].createElement("pre", null, error));\n}\n// scroller components\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx"));\n// loaded here to minimize redundant renders in Cradle\nvar cachehandler_1 = __webpack_require__(/*! ./cradle/cachehandler */ "./src/cradle/cachehandler.tsx");\n// -------------------[ global session ID generator ]----------------\nvar globalScrollerID = 0;\n// ===================================[ INITIALIZE ]===========================\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n    cellWidth = props.cellWidth,\n    _props$estimatedListS = props.estimatedListSize,\n    estimatedListSize = _props$estimatedListS === void 0 ? 0 : _props$estimatedListS,\n    getItem = props.getItem,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n    _props$gap = props.gap,\n    gap = _props$gap === void 0 ? 0 : _props$gap,\n    _props$padding = props.padding,\n    padding = _props$padding === void 0 ? 0 : _props$padding,\n    _props$layout = props.layout,\n    layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n    _props$cellMinHeight = props.cellMinHeight,\n    cellMinHeight = _props$cellMinHeight === void 0 ? 25 : _props$cellMinHeight,\n    _props$cellMinWidth = props.cellMinWidth,\n    cellMinWidth = _props$cellMinWidth === void 0 ? 25 : _props$cellMinWidth,\n    _props$runwaySize = props.runwaySize,\n    runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n    _props$startingIndex = props.startingIndex,\n    startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n    _props$cache = props.cache,\n    cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n    _props$cacheMax = props.cacheMax,\n    cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n    placeholder = props.placeholder,\n    _props$usePlaceholder = props.usePlaceholder,\n    usePlaceholder = _props$usePlaceholder === void 0 ? true : _props$usePlaceholder,\n    _props$useScrollTrack = props.useScrollTracker,\n    useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n    _props$styles = props.styles,\n    styles = _props$styles === void 0 ? {} : _props$styles,\n    _props$callbacks = props.callbacks,\n    callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n    _props$technical = props.technical,\n    technical = _props$technical === void 0 ? {} : _props$technical,\n    scrollerProperties = props.scrollerProperties;\n  if (!(cellWidth && cellHeight && estimatedListSize && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight, estimatedListSize and getItem are required\');\n    return null;\n  }\n  // ---------------------[ Data setup ]----------------------\n  var originalValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    estimatedListSize: estimatedListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  // avoid null/undefined\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  technical = technical !== null && technical !== void 0 ? technical : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  estimatedListSize = estimatedListSize !== null && estimatedListSize !== void 0 ? estimatedListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  usePlaceholder = usePlaceholder !== null && usePlaceholder !== void 0 ? usePlaceholder : true;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  cellMinHeight = cellMinHeight !== null && cellMinHeight !== void 0 ? cellMinHeight : 0;\n  cellMinWidth = cellMinWidth !== null && cellMinWidth !== void 0 ? cellMinWidth : 0;\n  cacheMax = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n  cellHeight = +cellHeight;\n  cellWidth = +cellWidth;\n  cellMinHeight = +cellMinHeight;\n  cellMinWidth = +cellMinWidth;\n  gap = +gap;\n  padding = +padding;\n  startingIndex = +startingIndex;\n  estimatedListSize = +estimatedListSize;\n  runwaySize = +runwaySize;\n  cacheMax = +cacheMax;\n  var verifiedValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    estimatedListSize: estimatedListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  var problems = 0;\n  for (var prop in verifiedValues) {\n    if (isNaN(verifiedValues[prop])) {\n      problems++;\n    }\n  }\n  if (problems) {\n    console.error(\'Error: invalid number - compare originalValues and verifiedValues\', originalValues, verifiedValues);\n    return react_1["default"].createElement("div", null, "error: see console.");\n  }\n  cellMinHeight = Math.max(cellMinHeight, 25);\n  cellMinWidth = Math.max(cellMinWidth, 25);\n  cellMinHeight = Math.min(cellHeight, cellMinHeight);\n  cellMinWidth = Math.min(cellWidth, cellMinWidth);\n  // prop constraints - non-negative values\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n  estimatedListSize = Math.max(0, estimatedListSize);\n  startingIndex = Math.max(0, startingIndex);\n  // enums\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  }\n  // package\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs);\n  // state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    scrollerState = _ref3[0],\n    setScrollerState = _ref3[1]; // setup, setlistsize, ready\n  // system\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var _technical = technical,\n    showAxis = _technical.showAxis,\n    triggerlineOffset = _technical.triggerlineOffset,\n    VIEWPORT_RESIZE_TIMEOUT = _technical.VIEWPORT_RESIZE_TIMEOUT,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _technical.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    IDLECALLBACK_TIMEOUT = _technical.IDLECALLBACK_TIMEOUT,\n    TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _technical.TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n    MAX_CACHE_OVER_RUN = _technical.MAX_CACHE_OVER_RUN;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== null && SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== void 0 ? SCROLL_TIMEOUT_FOR_ONAFTERSCROLL : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 4000;\n  TIMEOUT_FOR_VARIABLE_MEASUREMENTS = TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== null && TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== void 0 ? TIMEOUT_FOR_VARIABLE_MEASUREMENTS : 100;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  triggerlineOffset = triggerlineOffset !== null && triggerlineOffset !== void 0 ? triggerlineOffset : 10;\n  if (typeof usePlaceholder != \'boolean\') usePlaceholder = true;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true;\n  // for mount version\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current;\n  // for children\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(estimatedListSize);\n  var listsize = listsizeRef.current;\n  // tests for React with Object.is for changed properties; avoid re-renders with no change\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  }\n  // -------------------------[ Initialization ]-------------------------------\n  (0, react_1.useEffect)(function () {\n    if (scrollerSessionIDRef.current === null) {\n      // defend against React.StrictMode double run\n      scrollerSessionIDRef.current = globalScrollerID++;\n      cacheHandlerRef.current = new cachehandler_1.CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef);\n    }\n  }, []);\n  // called when getItem returns null, or direct call from user (see serviceHandler)\n  var setListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize;\n    // inform the user\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistsize\');\n  }, []);\n  // ---------------------[ State handling ]------------------------\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n      case \'setlistsize\':\n        setScrollerState(\'ready\');\n    }\n  }, [scrollerState]);\n  // --------------------[ Render ]---------------------\n  // component calls are deferred by scrollerState to give cacheHandler a chance to initialize\n  return react_1["default"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {\n      // response tbd; there may not need to be one\n    },\n    onError: function onError(error, info) {\n      console.log(\'react-infinite-grid-scroller captured error\', error);\n    }\n  }, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    scrollerProperties: scrollerProperties,\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    scrollerProperties: scrollerProperties,\n    cacheHandler: cacheHandlerRef.current,\n    usePlaceholder: usePlaceholder,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    TIMEOUT_FOR_VARIABLE_MEASUREMENTS: TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n    scrollerID: scrollerID\n  }))), scrollerState != \'setup\' && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(cachehandler_1.PortalList, {\n    cacheProps: cacheHandlerRef.current.cacheProps\n  })));\n};\nexports["default"] = InfiniteGridScroller;\n// ----------------------------[ Support ]------------------------------\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\nfunction compareProps(obj1, obj2) {\n  var keys = Object.keys(obj1);\n  var same;\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q04sSUFBSSxDQUFDSyxHQUFHLENBQUMsRUFBQ0osSUFBSSxDQUFDSSxHQUFHLENBQUMsQ0FBQyxFQUFFO01BQ2pDLE9BQU8sS0FBSzs7O0VBR3BCLE9BQU8sSUFBSTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmZpbml0ZUdyaWRTY3JvbGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciA9IFJJR1NcblxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIFNjcm9sbGJsb2NrLCB3aGljaCBpcyBmdWxsIHNpemUgZm9yIGxpc3RzaXplIG9mIGdpdmVuIGNlbGwgaGVpZ2h0L3dpZHRoLlxuICAgIFNjcm9sbGJsb2NrIGluIHR1cm4gY29udGFpbnMgdGhlIENyYWRsZSAtIGEgY29tcG9uZW50IHRoYXQgY29udGFpbnMgQ2VsbEZyYW1lcywgd2hpY2ggY29udGFpbiBcbiAgICBkaXNwbGF5ZWQgdXNlciBjb250ZW50IChpdGVtcykgb3IgdHJhbnNpdGlvbmFsIHBsYWNlaG9sZGVycy4gXG5cbiAgICBIb3N0IGNvbnRlbnQgaXMgaW5zdGFudGlhdGVkIGluIGEgY2FjaGUgb2YgUmVhY3QgcG9ydGFscyAodmlhIGNhY2hlSGFuZGxlcikuIGNvbnRlbnQgaXMgdGhlbiBcbiAgICBwb3J0YWwnZCB0byBob3N0IENlbGxGcmFtZXMuIFRoZSBjYWNoZSBjYW4gYmUgY29uZmlndXJlZCB0byBob2xkIG1hbnkgbW9yZSBpdGVtc1xuICAgIHRoYW4gdGhlIENyYWRsZSAobGltaXRlZCBieSBkZXZpY2UgbWVtb3J5LCBhbmQgc29tZSBldmVudHVhbCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiksIGFsbG93aW5nIFxuICAgIGNhY2hlZCBob3N0IGNvbnRlbnQgdG8gbWFpbnRhaW4gc3RhdGUuXG5cbiAgICBTY3JvbGxibG9jayBieSBzaXplIHJlcHJlc2VudHMgdGhlIGVudGlyZXR5IG9mIHRoZSBsaXN0LCBhbmQgaXMgdGhlIG9iamVjdCB0aGF0IGlzIHNjcm9sbGVkLlxuXG4gICAgQ3JhZGxlIGNvbnRhaW5zIHRoZSBsaXN0IGl0ZW1zLCBhbmQgaXMgJ3ZpcnR1YWxpemVkJyAtLSBpdCBhcHBlYXJzIGFzXG4gICAgdGhvdWdoIGl0IHNjcm9sbHMgb3ZlciBhIGZpbGxlZCBzY3JvbGxibG9jaywgYnV0IGluIGZhY3QgaXQgaXMgb25seSBzbGlnaHRseSBsYXJnZXIgdGhhblxuICAgIHRoZSB2aWV3cG9ydC4gQ29udGVudCBpcyByb3RhdGVkIGluIGFuZCBvdXQgb2YgdGhlIGNyYWRsZSAodGhyb3VnaCB0aGUgY2FjaGUpXG4gICAgXG4gICAgSW5kaXZpZHVhbCBob3N0IGl0ZW1zIGFyZSBmcmFtZWQgYnkgQ2VsbEZyYW1lLCBtYW5hZ2VkIGJ5IENyYWRsZVxuXG4gICAgT3ZlcmFsbCB0aGUgSW5maW5pdGVHcmlkU2Nyb2xsZXIgYXMgYSBwYWNrYWdlIG1hbmFnZXMgdGhlIGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgb2YgdGhlIFxuICAgIGNvbXBvbmVudHMgb2YgdGhlIG1lY2hhbmlzbS4gTW9zdCBvZiB0aGUgd29yayBvY2N1cnMgaW4gdGhlIENyYWRsZSBjb21wb25lbnQuXG5cbiAgICBUaGUgUmlncyBsaW5lciBpcyBzZXQgd2l0aCAnZGlzcGxheTphYnNvbHV0ZScgYW5kICdpbnNldDowJywgc28gdGhlIHVzZXIgY29udGFpbmluZyBibG9jayBzaG91bGRcbiAgICBiZSBzdHlsZXMgYWNjb3JkaW5nbHkuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBkZWZlbnNpdmVcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICdyZWFjdC1lcnJvci1ib3VuZGFyeScgLy8gd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LWVycm9yLWJvdW5kYXJ5XG5cbi8vIGJhc2VkIG9uIG1vZHVsZSB0ZW1wbGF0ZVxuZnVuY3Rpb24gRXJyb3JGYWxsYmFjayh7ZXJyb3IsIHJlc2V0RXJyb3JCb3VuZGFyeX0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IHJvbGU9XCJhbGVydFwiPlxuICAgICAgPHA+T29wcyEgU29tZXRoaW5nIHdlbnQgd3JvbmcgaW5zaWRlIHJlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIuPC9wPlxuICAgICAgPHA+Q2xpY2sgdG8gY2FuY2VsIHRoZSBlcnJvciBhbmQgY29udGludWUuPC9wPlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsgcmVzZXRFcnJvckJvdW5kYXJ5IH0+Q2FuY2VsIGVycm9yPC9idXR0b24+XG4gICAgICA8cHJlPntlcnJvcn08L3ByZT5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG4vLyBzY3JvbGxlciBjb21wb25lbnRzXG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi9WaWV3cG9ydCdcbmltcG9ydCBTY3JvbGxibG9jayBmcm9tICcuL1Njcm9sbGJsb2NrJ1xuaW1wb3J0IENyYWRsZSBmcm9tICcuL0NyYWRsZSdcblxuLy8gbG9hZGVkIGhlcmUgdG8gbWluaW1pemUgcmVkdW5kYW50IHJlbmRlcnMgaW4gQ3JhZGxlXG5pbXBvcnQgeyBDYWNoZUhhbmRsZXIsIFBvcnRhbExpc3QgfSBmcm9tICcuL2NyYWRsZS9jYWNoZWhhbmRsZXInXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGdsb2JhbCBzZXNzaW9uIElEIGdlbmVyYXRvciBdLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgZ2xvYmFsU2Nyb2xsZXJJRCA9IDBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1bIElOSVRJQUxJWkUgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBJbmZpbml0ZUdyaWRTY3JvbGxlciA9IChwcm9wcykgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tWyBub3JtYWxpemUgcHJvcGVydGllcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCB7IFxuXG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIGNlbGxIZWlnaHQsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgaGVpZ2h0IC0gbGl0ZXJhbCBmb3IgdmVydGljYWw7IGFwcHJveGltYXRlIGZvciBob3Jpem9udGFsXG4gICAgICAgICAgICAvLyBiYXNlIGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgY2VsbFdpZHRoLCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIHdpZHRoIC0gbGl0ZXJhbCBmb3IgaG9yaXpvbnRhbDsgYXBwcm94aW1hdGUgZm9yIHZlcnRpY2FsXG4gICAgICAgICAgICAvLyBiYXNlIGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgZXN0aW1hdGVkTGlzdFNpemUgPSAwLCAvLyB0aGUgZXN0aW1hdGVkIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdmlydHVhbCBsaXN0LiBjYW4gYmUgbW9kaWZpZWRcbiAgICAgICAgZ2V0SXRlbSwgLy8gcmVxdWlyZWQuIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGhvc3QgLSBwYXJhbWV0ZXJzIHNldCBieSBzeXN0ZW0gYXJlIGluZGV4IG51bWJlclxuICAgICAgICAgICAgLy8gYW5kIHNlc3Npb24gaXRlbUlEIGZvciB0cmFja2luZyBhbmQgbWF0Y2hpbmc7IFxuICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGhvc3Qtc2VsZWN0ZWQgY29tcG9uZW50IG9yIHByb21pc2Ugb2YgYSBjb21wb25lbnQsIG9yIG51bGwgb3IgdW5kZWZpbmVkXG5cbiAgICAgICAgLy8gKiogZ3JpZCBzcGVjczpcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAvLyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsXG4gICAgICAgIGdhcCA9IDAsIC8vIHNwYWNlIGJldHdlZW4gZ3JpZCBjZWxscywgbm90IGluY2x1ZGluZyB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuICAgICAgICBwYWRkaW5nID0gMCwgLy8gdGhlIGJvcmRlciBzcGFjZSBiZXR3ZWVuIHRoZSBpdGVtcyBhbmQgdGhlIHZpZXdwb3J0LCBhcHBsaWVkIHRvIHRoZSBjcmFkbGVcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nLCAvLyB1bmlmb3JtLCB2YXJpYWJsZVxuICAgICAgICBjZWxsTWluSGVpZ2h0ID0gMjUsIC8vIGZvciBsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBvcmllbnRhdGlvbiA9PSAndmVydGljYWwnXG4gICAgICAgIGNlbGxNaW5XaWR0aCA9IDI1LCAvLyBmb3IgbGF5b3V0ID09ICd2YXJpYWJsZScgJiYgb3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnXG5cbiAgICAgICAgLy8gKiogc2Nyb2xsZXIgc3BlY3M6XG4gICAgICAgIHJ1bndheVNpemUgPSAzLCAvLyB0aGUgbnVtYmVyIG9mIHJvd3Mgb3V0c2lkZSB0aGUgdmlldyBvZiBlYWNoIHNpZGUgb2YgdGhlIHZpZXdwb3J0IFxuICAgICAgICAgICAgLy8gLS0gZ2l2ZXMgdGltZSB0byBhc3NlbWJsZSBjZWxsRnJhbWVzIGJlZm9yZSBkaXNwbGF5XG4gICAgICAgIHN0YXJ0aW5nSW5kZXggPSAwLCAvLyB0aGUgMC1iYXNlZCBzdGFydGluZyBpbmRleCBvZiB0aGUgbGlzdCwgd2hlbiBmaXJzdCBsb2FkZWRcblxuICAgICAgICAvLyAqKiBzeXN0ZW0gc3BlY3M6XG4gICAgICAgIGNhY2hlID0gJ2NyYWRsZScsIC8vIFwicHJlbG9hZFwiLCBcImtlZXBsb2FkXCIgb3IgXCJjcmFkbGVcIlxuICAgICAgICBjYWNoZU1heCA9IG51bGwsIC8vIGFsd2F5cyBtaW5pbXVtIGNyYWRsZTsgbnVsbCBtZWFucyBsaW1pdGVkIGJ5IGxpc3RzaXplXG4gICAgICAgIHBsYWNlaG9sZGVyLCAvLyBvcHRpb25hbC4gYSBzcGFyc2UgY29tcG9uZW50IHRvIHN0YW5kIGluIGZvciBjb250ZW50IHVudGlsIHRoZSBjb250ZW50IGFycml2ZXM7IFxuICAgICAgICAgICAgLy8gcmVwbGFjZXMgZGVmYXVsdCBwbGFjZWhvbGRlciBpZiBwcmVzZW50XG4gICAgICAgIHVzZVBsYWNlaG9sZGVyID0gdHJ1ZSxcbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlciA9IHRydWUsIC8vIHRoZSBpbnRlcm5hbCBjb21wb25lbnQgdG8gZ2l2ZSBmZWVkYmFjayBmb3IgcmVwb3NpdGlvbmluZ1xuXG4gICAgICAgIC8vICoqKiBvYmplY3RzXG4gICAgICAgIHN0eWxlcyA9IHt9LCAvLyBvcHRpb25hbC4gcGFzc2l2ZSBzdHlsZSBvdmVyLXJpZGVzIChlZy4gY29sb3IsIG9wYWNpdHkpOyBoYXMgXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHZpZXdwb3J0LCBzY3JvbGxibG9jaywgY3JhZGxlLCBzY3JvbGx0cmFja2VyLCBwbGFjZWhvbGRlcmZyYW1lLCBvclxuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXJsaW5lci4gRG8gbm90IG1ha2Ugc3RydWN0dXJhbCBjaGFuZ2VzIVxuICAgICAgICBjYWxsYmFja3MgPSB7fSwgLy8gb3B0aW9uYWwuIGNsb3N1cmVzIHRvIGdldCBkaXJlY3QgaW5mb3JtYXRpb24gc3RyZWFtcyBvZiBzb21lIGNvbXBvbmVudCB1dGlsaXRlc1xuICAgICAgICAgICAgLy8gY2FuIGNvbnRhaW4gZnVuY3Rpb25zQ2FsbGJhY2ssIHdoaWNoIHByb3ZpZGVzIGFjY2VzcyB0byBpbnRlcm5hbCBzY3JvbGxlciBmdW5jdGlvbnMgXG4gICAgICAgICAgICAvLyhtb3N0bHkgY2FjaGUgbWFuYWdlbWVudClcbiAgICAgICAgdGVjaG5pY2FsID0ge30sIC8vIG9wdGlvbmFsLiB0ZWNobmljYWwgc2V0dGluZ3MgbGlrZSBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVFxuXG4gICAgICAgIC8vICoqIGluZm9ybWF0aW9uIGZvciBob3N0IGNlbGwgY29udGVudFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMsIC8vIHJlcXVpcmVkIGZvciBlbWJlZGRlZCBzY3JvbGxlcjsgc2hhcmVzIHNjcm9sbGVyIHNldHRpbmdzIHdpdGggY29udGVudFxuXG4gICAgfSA9IHByb3BzXG5cbiAgICBpZiAoIShjZWxsV2lkdGggJiYgY2VsbEhlaWdodCAmJiBlc3RpbWF0ZWRMaXN0U2l6ZSAmJiBnZXRJdGVtICkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JJR1M6IGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgZXN0aW1hdGVkTGlzdFNpemUgYW5kIGdldEl0ZW0gYXJlIHJlcXVpcmVkJylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIERhdGEgc2V0dXAgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWVzID0ge1xuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdGFydGluZ0luZGV4LFxuICAgICAgICBlc3RpbWF0ZWRMaXN0U2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgfVxuXG4gICAgLy8gYXZvaWQgbnVsbC91bmRlZmluZWRcbiAgICBzdHlsZXMgPSBzdHlsZXMgPz8ge31cbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgPz8ge31cbiAgICB0ZWNobmljYWwgPSB0ZWNobmljYWwgPz8ge31cbiAgICBzdGFydGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleCA/PyAwXG4gICAgZXN0aW1hdGVkTGlzdFNpemUgPSBlc3RpbWF0ZWRMaXN0U2l6ZSA/PyAwXG4gICAgcnVud2F5U2l6ZSA9IHJ1bndheVNpemUgPz8gM1xuICAgIHVzZVBsYWNlaG9sZGVyID0gdXNlUGxhY2Vob2xkZXIgPz8gdHJ1ZVxuICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB1c2VTY3JvbGxUcmFja2VyID8/IHRydWVcbiAgICBjZWxsTWluSGVpZ2h0ID0gY2VsbE1pbkhlaWdodCA/PyAwXG4gICAgY2VsbE1pbldpZHRoID0gY2VsbE1pbldpZHRoID8/IDBcbiAgICBjYWNoZU1heCA9IGNhY2hlTWF4ID8/IDBcblxuICAgIGNlbGxIZWlnaHQgPSArY2VsbEhlaWdodFxuICAgIGNlbGxXaWR0aCA9ICtjZWxsV2lkdGhcbiAgICBjZWxsTWluSGVpZ2h0ID0gK2NlbGxNaW5IZWlnaHRcbiAgICBjZWxsTWluV2lkdGggPSArY2VsbE1pbldpZHRoXG4gICAgZ2FwID0gK2dhcFxuICAgIHBhZGRpbmcgPSArcGFkZGluZ1xuICAgIHN0YXJ0aW5nSW5kZXggPSArc3RhcnRpbmdJbmRleFxuICAgIGVzdGltYXRlZExpc3RTaXplID0gK2VzdGltYXRlZExpc3RTaXplXG4gICAgcnVud2F5U2l6ZSA9ICtydW53YXlTaXplXG4gICAgY2FjaGVNYXggPSArY2FjaGVNYXhcblxuICAgIGNvbnN0IHZlcmlmaWVkVmFsdWVzID0ge1xuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdGFydGluZ0luZGV4LFxuICAgICAgICBlc3RpbWF0ZWRMaXN0U2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY2FjaGVNYXgsICAgICAgICBcbiAgICB9XG5cbiAgICBsZXQgcHJvYmxlbXMgPSAwXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHZlcmlmaWVkVmFsdWVzKSB7XG4gICAgICAgIGlmIChpc05hTih2ZXJpZmllZFZhbHVlc1twcm9wXSkpIHtcbiAgICAgICAgICAgIHByb2JsZW1zKytcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBpZiAocHJvYmxlbXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6IGludmFsaWQgbnVtYmVyIC0gY29tcGFyZSBvcmlnaW5hbFZhbHVlcyBhbmQgdmVyaWZpZWRWYWx1ZXMnLCBcbiAgICAgICAgICAgIG9yaWdpbmFsVmFsdWVzLCB2ZXJpZmllZFZhbHVlcylcbiAgICAgICAgcmV0dXJuIDxkaXY+ZXJyb3I6IHNlZSBjb25zb2xlLjwvZGl2PlxuICAgIH1cblxuICAgIGNlbGxNaW5IZWlnaHQgPSBNYXRoLm1heChjZWxsTWluSGVpZ2h0LCAyNSlcbiAgICBjZWxsTWluV2lkdGggPSBNYXRoLm1heChjZWxsTWluV2lkdGgsIDI1KVxuICAgIGNlbGxNaW5IZWlnaHQgPSBNYXRoLm1pbihjZWxsSGVpZ2h0LCBjZWxsTWluSGVpZ2h0KVxuICAgIGNlbGxNaW5XaWR0aCA9IE1hdGgubWluKGNlbGxXaWR0aCwgY2VsbE1pbldpZHRoKVxuXG4gICAgLy8gcHJvcCBjb25zdHJhaW50cyAtIG5vbi1uZWdhdGl2ZSB2YWx1ZXNcbiAgICBydW53YXlTaXplID0gTWF0aC5tYXgoMSxydW53YXlTaXplKSAvLyBydW53YXlzaXplIG11c3QgYmUgYXQgbGVhc3QgMVxuICAgIGVzdGltYXRlZExpc3RTaXplID0gTWF0aC5tYXgoMCxlc3RpbWF0ZWRMaXN0U2l6ZSlcbiAgICBzdGFydGluZ0luZGV4ID0gTWF0aC5tYXgoMCxzdGFydGluZ0luZGV4KVxuXG4gICAgLy8gZW51bXNcbiAgICBpZiAoIVsnaG9yaXpvbnRhbCcsJ3ZlcnRpY2FsJ10uaW5jbHVkZXMob3JpZW50YXRpb24pKSB7IFxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCdcbiAgICB9XG4gICAgaWYgKCFbJ3ByZWxvYWQnLCdrZWVwbG9hZCcsJ2NyYWRsZSddLmluY2x1ZGVzKGNhY2hlKSkge1xuICAgICAgICBjYWNoZSA9ICdjcmFkbGUnXG4gICAgfVxuICAgIGlmICghWyd1bmlmb3JtJywgJ3ZhcmlhYmxlJ10uaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgICBsYXlvdXQgPSAndW5pZm9ybSdcbiAgICB9XG5cbiAgICAvLyBwYWNrYWdlXG4gICAgY29uc3QgZ3JpZFNwZWNzID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICAvLyBzdGF0ZVxuICAgIGNvbnN0IFtzY3JvbGxlclN0YXRlLCBzZXRTY3JvbGxlclN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCBzZXRsaXN0c2l6ZSwgcmVhZHlcbiAgICAvLyBzeXN0ZW1cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoc3R5bGVzKVxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZihjYWxsYmFja3MpXG5cbiAgICBsZXQge1xuXG4gICAgICAgIHNob3dBeGlzLCAvLyBib29sZWFuOyBheGlzIGNhbiBiZSBtYWRlIHZpc2libGUgZm9yIGRlYnVnXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LCAvLyBkaXN0YW5jZSBmcm9tIGNlbGwgaGVhZCBvciB0YWlsIGZvciBjb250ZW50IHNoaWZ0cyBhYm92ZS9iZWxvdyBheGlzXG4gICAgICAgIC8vIHRpbWVvdXRzXG4gICAgICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VULFxuICAgICAgICBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgICAgIFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyxcbiAgICAgICAgLy8gcmF0aW9zOlxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sIC8vIG1heCBzdHJlYW1pbmcgb3Zlci1ydW4gYXMgcmF0aW8gdG8gY2FjaGVNYXhcblxuICAgIH0gPSB0ZWNobmljYWxcblxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0gVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPz8gMjUwXG4gICAgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwgPSBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCA/PyAxMDBcbiAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCA9IElETEVDQUxMQkFDS19USU1FT1VUID8/IDQwMDBcbiAgICBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMgPSBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMgPz8gMTAwXG4gICAgXG4gICAgTUFYX0NBQ0hFX09WRVJfUlVOID0gTUFYX0NBQ0hFX09WRVJfUlVOID8/IDEuNVxuXG4gICAgaWYgKHR5cGVvZiBzaG93QXhpcyAhPSAnYm9vbGVhbicpIHNob3dBeGlzID0gZmFsc2VcblxuICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgPz8gMTBcblxuICAgIGlmICh0eXBlb2YgdXNlUGxhY2Vob2xkZXIgIT0gJ2Jvb2xlYW4nKSB1c2VQbGFjZWhvbGRlciA9IHRydWVcbiAgICBpZiAodHlwZW9mIHVzZVNjcm9sbFRyYWNrZXIgIT0gJ2Jvb2xlYW4nKSB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuXG4gICAgLy8gZm9yIG1vdW50IHZlcnNpb25cbiAgICBjb25zdCBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbGVySUQgPSBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50XG5cbiAgICAvLyBmb3IgY2hpbGRyZW5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGxpc3RzaXplUmVmID0gdXNlUmVmKGVzdGltYXRlZExpc3RTaXplKVxuXG4gICAgY29uc3QgbGlzdHNpemUgPSBsaXN0c2l6ZVJlZi5jdXJyZW50XG5cbiAgICAvLyB0ZXN0cyBmb3IgUmVhY3Qgd2l0aCBPYmplY3QuaXMgZm9yIGNoYW5nZWQgcHJvcGVydGllczsgYXZvaWQgcmUtcmVuZGVycyB3aXRoIG5vIGNoYW5nZVxuICAgIGlmICghY29tcGFyZVByb3BzKGdyaWRTcGVjcywgZ3JpZFNwZWNzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGdyaWRTcGVjc1JlZi5jdXJyZW50ID0gZ3JpZFNwZWNzXG4gICAgfVxuXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoc3R5bGVzLCBzdHlsZXNSZWYuY3VycmVudCkpIHtcbiAgICAgICAgc3R5bGVzUmVmLmN1cnJlbnQgPSBzdHlsZXNcbiAgICB9XG4gICAgaWYgKCFjb21wYXJlUHJvcHMoY2FsbGJhY2tzLCBjYWxsYmFja3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQgPSBjYWxsYmFja3NcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbml0aWFsaXphdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0ICgoKSA9PiB7XG5cbiAgICAgICAgaWYgKHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQgPT09IG51bGwpIHsgLy8gZGVmZW5kIGFnYWluc3QgUmVhY3QuU3RyaWN0TW9kZSBkb3VibGUgcnVuXG4gICAgICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50ID0gZ2xvYmFsU2Nyb2xsZXJJRCsrXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCA9IG5ldyBDYWNoZUhhbmRsZXIoc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudCwgc2V0TGlzdHNpemUsIGxpc3RzaXplUmVmKVxuICAgICAgICB9XG5cbiAgICB9LFtdKTtcblxuICAgIC8vIGNhbGxlZCB3aGVuIGdldEl0ZW0gcmV0dXJucyBudWxsLCBvciBkaXJlY3QgY2FsbCBmcm9tIHVzZXIgKHNlZSBzZXJ2aWNlSGFuZGxlcilcbiAgICBjb25zdCBzZXRMaXN0c2l6ZSA9IHVzZUNhbGxiYWNrKChsaXN0c2l6ZSkgPT57XG5cbiAgICAgICAgaWYgKGxpc3RzaXplID09IGxpc3RzaXplUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGxpc3RzaXplUmVmLmN1cnJlbnQgPSBsaXN0c2l6ZVxuXG4gICAgICAgIC8vIGluZm9ybSB0aGUgdXNlclxuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5uZXdMaXN0c2l6ZSAmJiBjYWxsYmFja3NSZWYuY3VycmVudC5uZXdMaXN0c2l6ZShsaXN0c2l6ZSlcblxuICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdzZXRsaXN0c2l6ZScpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTdGF0ZSBoYW5kbGluZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoc2Nyb2xsZXJTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOlxuICAgICAgICAgICAgY2FzZSAnc2V0bGlzdHNpemUnOlxuICAgICAgICAgICAgICAgIHNldFNjcm9sbGVyU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgfVxuXG4gICAgfSxbc2Nyb2xsZXJTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgUmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbXBvbmVudCBjYWxscyBhcmUgZGVmZXJyZWQgYnkgc2Nyb2xsZXJTdGF0ZSB0byBnaXZlIGNhY2hlSGFuZGxlciBhIGNoYW5jZSB0byBpbml0aWFsaXplXG4gICAgcmV0dXJuIDxFcnJvckJvdW5kYXJ5XG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50PSB7IEVycm9yRmFsbGJhY2sgfVxuICAgICAgICBvblJlc2V0PSB7ICgpID0+IHtcbiAgICAgICAgICAvLyByZXNwb25zZSB0YmQ7IHRoZXJlIG1heSBub3QgbmVlZCB0byBiZSBvbmVcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvciA9IHsoZXJyb3I6IEVycm9yLCBpbmZvOiB7Y29tcG9uZW50U3RhY2s6IHN0cmluZ30pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyIGNhcHR1cmVkIGVycm9yJywgZXJyb3IpXG4gICAgICAgIH19XG4gICAgPlxuXG4gICAgICAgIHsoc2Nyb2xsZXJTdGF0ZSAhPSAnc2V0dXAnKSAmJiA8Vmlld3BvcnRcblxuICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyA9IHtzY3JvbGxlclByb3BlcnRpZXN9XG4gICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0geyBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCB9XG5cbiAgICAgICAgPlxuICAgICAgICBcbiAgICAgICAgICAgIDxTY3JvbGxibG9ja1xuXG4gICAgICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8Q3JhZGxlIFxuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB7IGNhY2hlIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVNYXggPSB7IGNhY2hlTWF4IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNhbGxiYWNrcyA9IHsgY2FsbGJhY2tzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4ID0geyBzdGFydGluZ0luZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bndheVNpemUgPSB7IHJ1bndheVNpemUgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCA9IHsgdHJpZ2dlcmxpbmVPZmZzZXQgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMgPSB7IHNjcm9sbGVyUHJvcGVydGllcyB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyID0geyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVBsYWNlaG9sZGVyID0geyB1c2VQbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB7IHVzZVNjcm9sbFRyYWNrZXIgfVxuICAgICAgICAgICAgICAgICAgICBzaG93QXhpcyA9IHsgc2hvd0F4aXMgfVxuICAgICAgICAgICAgICAgICAgICBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCA9IHsgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwgfVxuICAgICAgICAgICAgICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCA9IHsgSURMRUNBTExCQUNLX1RJTUVPVVQgfVxuICAgICAgICAgICAgICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4gPSB7IE1BWF9DQUNIRV9PVkVSX1JVTiB9XG4gICAgICAgICAgICAgICAgICAgIFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyA9IHsgVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG5cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9TY3JvbGxibG9jaz5cbiAgICAgICAgPC9WaWV3cG9ydD59XG4gICAgICAgIHsoc2Nyb2xsZXJTdGF0ZSAhPSAnc2V0dXAnKSAmJiA8ZGl2IGRhdGEtdHlwZSA9ICdjYWNoZXJvb3QnIHN0eWxlID0geyBjYWNoZXJvb3RzdHlsZSB9PlxuICAgICAgICAgICAgPFBvcnRhbExpc3QgY2FjaGVQcm9wcyA9IHsgY2FjaGVIYW5kbGVyUmVmLmN1cnJlbnQuY2FjaGVQcm9wcyB9Lz5cbiAgICAgICAgPC9kaXY+fVxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3VwcG9ydCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNhY2hlcm9vdHN0eWxlID0ge2Rpc3BsYXk6J25vbmUnfS8vIGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMgLy8gc3RhdGljLCBvdXQgb2YgdmlldyBcblxuLy8gdXRpbGl0eVxuZnVuY3Rpb24gY29tcGFyZVByb3BzIChvYmoxLG9iajIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqMSlcbiAgICBsZXQgc2FtZVxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG9iajFba2V5XSxvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIkVycm9yRmFsbGJhY2siLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInJlYWN0XzEiLCJyb2xlIiwib25DbGljayIsImdsb2JhbFNjcm9sbGVySUQiLCJJbmZpbml0ZUdyaWRTY3JvbGxlciIsInByb3BzIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImVzdGltYXRlZExpc3RTaXplIiwiZ2V0SXRlbSIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImxheW91dCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJydW53YXlTaXplIiwic3RhcnRpbmdJbmRleCIsImNhY2hlIiwiY2FjaGVNYXgiLCJwbGFjZWhvbGRlciIsInVzZVBsYWNlaG9sZGVyIiwidXNlU2Nyb2xsVHJhY2tlciIsInN0eWxlcyIsImNhbGxiYWNrcyIsInRlY2huaWNhbCIsInNjcm9sbGVyUHJvcGVydGllcyIsImNvbnNvbGUiLCJsb2ciLCJvcmlnaW5hbFZhbHVlcyIsInZlcmlmaWVkVmFsdWVzIiwicHJvYmxlbXMiLCJwcm9wIiwiaXNOYU4iLCJNYXRoIiwibWF4IiwibWluIiwiaW5jbHVkZXMiLCJncmlkU3BlY3MiLCJncmlkU3BlY3NSZWYiLCJzY3JvbGxlclN0YXRlIiwic2V0U2Nyb2xsZXJTdGF0ZSIsInN0eWxlc1JlZiIsImNhbGxiYWNrc1JlZiIsInNob3dBeGlzIiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCIsIlNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJzY3JvbGxlclNlc3Npb25JRFJlZiIsInNjcm9sbGVySUQiLCJjdXJyZW50IiwiY2FjaGVIYW5kbGVyUmVmIiwibGlzdHNpemVSZWYiLCJsaXN0c2l6ZSIsImNvbXBhcmVQcm9wcyIsImNhY2hlaGFuZGxlcl8xIiwic2V0TGlzdHNpemUiLCJuZXdMaXN0c2l6ZSIsInJlYWN0X2Vycm9yX2JvdW5kYXJ5XzEiLCJGYWxsYmFja0NvbXBvbmVudCIsIm9uUmVzZXQiLCJvbkVycm9yIiwiaW5mbyIsIlZpZXdwb3J0XzEiLCJTY3JvbGxibG9ja18xIiwiQ3JhZGxlXzEiLCJ1c2VyQ2FsbGJhY2tzIiwiY2FjaGVIYW5kbGVyIiwic3R5bGUiLCJjYWNoZXJvb3RzdHlsZSIsImNhY2hlUHJvcHMiLCJleHBvcnRzIiwiZGlzcGxheSIsIm9iajEiLCJvYmoyIiwia2V5cyIsIk9iamVjdCIsInNhbWUiLCJrZXkiLCJpcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n')},"./node_modules/react-error-boundary/dist/react-error-boundary.umd.js":function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"react\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  var changedArray = function changedArray(a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error;\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React__namespace.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React__namespace.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React__namespace.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function Wrapped(props) {\n      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__namespace.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React__namespace.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError != null) throw givenError;\n    if (error != null) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/sort-type-union-intersection-members: \"off\",\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-error-boundary.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pHLEVBQUUsQ0FDaUk7QUFDbkksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVycm9yLWJvdW5kYXJ5L2Rpc3QvcmVhY3QtZXJyb3ItYm91bmRhcnkudW1kLmpzP2U4OTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdEVycm9yQm91bmRhcnkgPSB7fSwgZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuXG4gIHZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbiAgfShSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoQ29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICB2YXIgV3JhcHBlZCA9IGZ1bmN0aW9uIFdyYXBwZWQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIGVycm9yQm91bmRhcnlQcm9wcywgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTsgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG5cblxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIiArIG5hbWUgKyBcIilcIjtcbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihnaXZlbkVycm9yKSB7XG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobnVsbCksXG4gICAgICAgIGVycm9yID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRFcnJvciA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGlmIChnaXZlbkVycm9yICE9IG51bGwpIHRocm93IGdpdmVuRXJyb3I7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBzZXRFcnJvcjtcbiAgfVxuICAvKlxuICBlc2xpbnRcbiAgICBAdHlwZXNjcmlwdC1lc2xpbnQvc29ydC10eXBlLXVuaW9uLWludGVyc2VjdGlvbi1tZW1iZXJzOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nOiBcIm9mZlwiXG4gICovXG5cbiAgZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbiAgZXhwb3J0cy51c2VFcnJvckhhbmRsZXIgPSB1c2VFcnJvckhhbmRsZXI7XG4gIGV4cG9ydHMud2l0aEVycm9yQm91bmRhcnkgPSB3aXRoRXJyb3JCb3VuZGFyeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\n")},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InPortal": () => (/* binding */ InPortal),\n/* harmony export */   "OutPortal": () => (/* binding */ OutPortal),\n/* harmony export */   "createHtmlPortalNode": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   "createSvgPortalNode": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(e){var I=__webpack_module_cache__[e];if(void 0!==I)return I.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}__webpack_require__.n=e=>{var I=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(e,I)=>{for(var l in I)__webpack_require__.o(I,l)&&!__webpack_require__.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:I[l]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,I)=>Object.prototype.hasOwnProperty.call(e,I),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/infinitegridscroller.tsx");return __webpack_exports__})()));