!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("React")):"function"==typeof define&&define.amd?define(["React"],I):"object"==typeof exports?exports.Scroller=I(require("React")):g.Scroller=I(g.React)}(window,(function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function n(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,n),e.l=!0,e.exports}return n.m=g,n.c=I,n.d=function(g,I,t){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)n.d(t,e,function(I){return g[I]}.bind(null,e));return t},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=5)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci9leHRlcm5hbCBcIlJlYWN0XCI/YzQ4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval(" // viewport.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible portal of the list being shown\n*/\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nexports.ViewportContext = react_1[\"default\"].createContext(null);\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(2));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(3));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"]; // control constant\n\nvar RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE = 250;\n\nvar Viewport = function Viewport(_a) {\n  // -----------------------[ initialize ]------------------\n  var children = _a.children,\n      orientation = _a.orientation,\n      cellWidth = _a.cellWidth,\n      cellHeight = _a.cellHeight,\n      gap = _a.gap,\n      padding = _a.padding,\n      functions = _a.functions,\n      styles = _a.styles; // processing state\n\n  var _b = react_1.useState('prepare'),\n      portstate = _b[0],\n      setPortState = _b[1];\n\n  var portstateRef = react_1.useRef(null);\n  portstateRef.current = portstate;\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // data heap\n\n  var timeoutidRef = react_1.useRef(null);\n  var viewportdivRef = react_1.useRef(undefined);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    overflow: 'auto',\n    backgroundColor: 'red'\n  }, styles === null || styles === void 0 ? void 0 : styles.viewport));\n  var resizeTimeridRef = react_1.useRef(null);\n  var isResizingRef = react_1.useRef(false);\n  var viewportDataRef = react_1.useRef(null);\n  var resizeObserverRef = react_1.useRef(null); // initialize\n\n  react_1.useEffect(function () {\n    resizeObserverRef.current = new LocalResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportdivRef.current);\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var resizeCallback = react_1.useCallback(function (entries) {\n    if (portstateRef.current == 'prepare') return;\n\n    if (!isResizingRef.current) {\n      isResizingRef.current = true; // below is a realtime message to cradle.onScroll\n      // to stop updating the referenceIndexData, and to the item observer to stop\n      // triggering responses (anticipating reset of cradle content based on resize)\n\n      viewportDataRef.current.isResizing = true;\n      if (isMounted()) setPortState('resizing');\n    }\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMounted()) setPortState('resize');\n    }, RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE);\n  }, []); // ----------------------------------[ calculate ]--------------------------------\n  // calculated values\n\n  divlinerstyleRef.current = react_1.useMemo(function () {\n    var mincrosslength = calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding);\n\n    var styles = __assign({}, divlinerstyleRef.current);\n\n    if (orientation == 'vertical') {\n      styles.minWidth = mincrosslength + 'px';\n      styles.minHeight = 'auto';\n    } else {\n      styles.minWidth = 'auto';\n      styles.minHeight = mincrosslength + 'px';\n    }\n\n    return styles;\n  }, [orientation, cellWidth, cellHeight, padding]); // TODO: gap?\n\n  var viewportClientRect;\n\n  if (viewportdivRef.current) {\n    viewportClientRect = viewportdivRef.current.getBoundingClientRect();\n  } else {\n    viewportClientRect = {};\n  }\n\n  var top = viewportClientRect.top,\n      right = viewportClientRect.right,\n      bottom = viewportClientRect.bottom,\n      left = viewportClientRect.left; // set context data for children\n\n  viewportDataRef.current = react_1.useMemo(function () {\n    var width, height, localViewportData;\n\n    if (!(top === undefined)) {\n      //proxy\n      width = right - left;\n      height = bottom - top;\n      localViewportData = {\n        viewportDimensions: {\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n          width: width,\n          height: height\n        },\n        elementref: viewportdivRef,\n        isResizing: isResizingRef.current\n      };\n    }\n\n    return localViewportData;\n  }, [orientation, top, right, bottom, left, isResizingRef.current]); // --------------------[ state processing ]---------------------------\n\n  react_1.useEffect(function () {\n    switch (portstate) {\n      case 'prepare':\n      case 'resize':\n        {\n          setPortState('render');\n          break;\n        }\n    }\n  }, [portstate]); // ----------------------[ render ]--------------------------------\n\n  return react_1[\"default\"].createElement(exports.ViewportContext.Provider, {\n    value: viewportDataRef.current\n  }, react_1[\"default\"].createElement(\"div\", {\n    style: divlinerstyleRef.current,\n    ref: viewportdivRef\n  }, portstate != 'prepare' ? children : null));\n}; // Viewport\n// establish minimum width/height for the viewport -- approximately one item\n\n\nvar calcMinViewportCrossLength = function calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding) {\n  var crosslength, cellLength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellWidth;\n  } else {\n    cellLength = cellHeight;\n  }\n\n  crosslength = cellLength + padding * 2;\n  return crosslength;\n};\n\nexports[\"default\"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy92aWV3cG9ydC50c3g/MGRlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7O0FBRWEsMEJBQWtCLG1CQUFNLGFBQU4sQ0FBb0IsSUFBcEIsQ0FBbEI7O0FBRWI7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQsQyxDQUVBOztBQUNBLElBQU0saUNBQWlDLEdBQUcsR0FBMUM7O0FBRUEsSUFBTSxRQUFRLEdBQUcsU0FBWCxRQUFXLENBQUMsRUFBRCxFQVNoQjtBQUVHO01BVkEsc0I7TUFDQSw0QjtNQUNBLHdCO01BQ0EsMEI7TUFDQSxZO01BQ0Esb0I7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FJRzs7QUFDTTtBQUFBLE1BQUMsaUJBQUQ7QUFBQSxNQUFXLG9CQUFYOztBQUNOLE1BQU0sWUFBWSxHQUFHLGVBQU8sSUFBUCxDQUFyQjtBQUNBLGNBQVksQ0FBQyxPQUFiLEdBQXVCLFNBQXZCO0FBQ0EsTUFBTSxTQUFTLEdBQUcsb0NBQWxCLENBUkgsQ0FTRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxlQUFPLElBQVAsQ0FBckI7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLFNBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDZCxZQUFRLEVBQUMsVUFESztBQUVkLE9BQUcsRUFBQyxDQUZVO0FBR2QsU0FBSyxFQUFDLENBSFE7QUFJZCxVQUFNLEVBQUMsQ0FKTztBQUtkLFFBQUksRUFBQyxDQUxTO0FBTWQsWUFBUSxFQUFDLE1BTks7QUFPZCxtQkFBZSxFQUFDO0FBUEYsR0FBZCxFQVFxQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsUUFSN0IsQ0FEcUIsQ0FBekI7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V0FBUDtBQUNILENBVEQ7O0FBV0EscUJBQWUsUUFBZiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdmlld3BvcnQudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB2aWV3cG9ydCBpcyB0byBwcm92aWRlIGRhdGEgdG8gaXRzIGNoaWxkcmVuIChzY3JvbGxibG9jayBhbmQgY3JhZGxlKSwgXG4gICAgYW5kIGFjdCBhcyB0aGUgdmlzaWJsZSBwb3J0YWwgb2YgdGhlIGxpc3QgYmVpbmcgc2hvd25cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlQ2FsbGJhY2t9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKVxuXG5pbXBvcnQgdXNlSXNNb3VudGVkIGZyb20gJ3JlYWN0LWlzLW1vdW50ZWQtaG9vaydcblxuaW1wb3J0IFJlc2l6ZU9ic2VydmVyUG9seWZpbGwgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJ1xuXG5jb25zdCBMb2NhbFJlc2l6ZU9ic2VydmVyID0gd2luZG93WydSZXNpemVPYnNlcnZlciddIHx8IFJlc2l6ZU9ic2VydmVyUG9seWZpbGxcblxuLy8gY29udHJvbCBjb25zdGFudFxuY29uc3QgUkVTSVpFX1RJTUVPVVRfRk9SX09OQUZURVJTUkVTSVpFID0gMjUwXG5cbmNvbnN0IFZpZXdwb3J0ID0gKHtcbiAgICBjaGlsZHJlbiwgXG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgZ2FwLCBcbiAgICBwYWRkaW5nLCBcbiAgICBmdW5jdGlvbnMsIFxuICAgIHN0eWxlcyxcbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHByb2Nlc3Npbmcgc3RhdGVcbiAgICBjb25zdCBbcG9ydHN0YXRlLHNldFBvcnRTdGF0ZV0gPSB1c2VTdGF0ZSgncHJlcGFyZScpXG4gICAgY29uc3QgcG9ydHN0YXRlUmVmID0gdXNlUmVmKG51bGwpXG4gICAgcG9ydHN0YXRlUmVmLmN1cnJlbnQgPSBwb3J0c3RhdGVcbiAgICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKVxuICAgIC8vIGRhdGEgaGVhcFxuICAgIGNvbnN0IHRpbWVvdXRpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHZpZXdwb3J0ZGl2UmVmID0gdXNlUmVmKHVuZGVmaW5lZClcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKFxuICAgICAgICBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgdG9wOjAsXG4gICAgICAgIHJpZ2h0OjAsXG4gICAgICAgIGJvdHRvbTowLFxuICAgICAgICBsZWZ0OjAsXG4gICAgICAgIG92ZXJmbG93OidhdXRvJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOidyZWQnLFxuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyxzdHlsZXM/LnZpZXdwb3J0KSlcbiAgICBjb25zdCByZXNpemVUaW1lcmlkUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgaXNSZXNpemluZ1JlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCB2aWV3cG9ydERhdGFSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBMb2NhbFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRkaXZSZWYuY3VycmVudClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCByZXNpemVDYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKT0+e1xuICAgICAgICBpZiAocG9ydHN0YXRlUmVmLmN1cnJlbnQgPT0gJ3ByZXBhcmUnKSByZXR1cm5cblxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gdHJ1ZSBcbiAgICAgICAgICAgICAgICAvLyBiZWxvdyBpcyBhIHJlYWx0aW1lIG1lc3NhZ2UgdG8gY3JhZGxlLm9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgLy8gdG8gc3RvcCB1cGRhdGluZyB0aGUgcmVmZXJlbmNlSW5kZXhEYXRhLCBhbmQgdG8gdGhlIGl0ZW0gb2JzZXJ2ZXIgdG8gc3RvcFxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJpbmcgcmVzcG9uc2VzIChhbnRpY2lwYXRpbmcgcmVzZXQgb2YgY3JhZGxlIGNvbnRlbnQgYmFzZWQgb24gcmVzaXplKVxuICAgICAgICAgICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IHRydWVcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQoKSkgc2V0UG9ydFN0YXRlKCdyZXNpemluZycpXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQoKSkgc2V0UG9ydFN0YXRlKCdyZXNpemUnKVxuXG4gICAgICAgIH0sUkVTSVpFX1RJTUVPVVRfRk9SX09OQUZURVJTUkVTSVpFKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBtaW5jcm9zc2xlbmd0aCA9IGNhbGNNaW5WaWV3cG9ydENyb3NzTGVuZ3RoKG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHBhZGRpbmcpXG4gICAgICAgIGxldCBzdHlsZXMgPSB7Li4uZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzdHlsZXMubWluV2lkdGggPSBtaW5jcm9zc2xlbmd0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlcy5taW5IZWlnaHQgPSAnYXV0bydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5taW5XaWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9IG1pbmNyb3NzbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlc1xuXG4gICAgfSxbb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcGFkZGluZ10pIC8vIFRPRE86IGdhcD9cblxuICAgIGxldCB2aWV3cG9ydENsaWVudFJlY3RcbiAgICBpZiAodmlld3BvcnRkaXZSZWYuY3VycmVudCkge1xuICAgICAgICB2aWV3cG9ydENsaWVudFJlY3QgPSB2aWV3cG9ydGRpdlJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmlld3BvcnRDbGllbnRSZWN0ID0ge31cbiAgICB9XG4gICAgbGV0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gdmlld3BvcnRDbGllbnRSZWN0XG5cbiAgICAvLyBzZXQgY29udGV4dCBkYXRhIGZvciBjaGlsZHJlblxuICAgIHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCBsb2NhbFZpZXdwb3J0RGF0YVxuICAgICAgICBpZiAoISh0b3AgPT09IHVuZGVmaW5lZCkpIHsgLy9wcm94eVxuICAgICAgICAgICAgd2lkdGggPSAocmlnaHQgLSBsZWZ0KVxuICAgICAgICAgICAgaGVpZ2h0ID0gKGJvdHRvbSAtIHRvcClcbiAgICAgICAgICAgIGxvY2FsVmlld3BvcnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczp7dG9wLHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgICAgICAgICAgIGVsZW1lbnRyZWY6dmlld3BvcnRkaXZSZWYsXG4gICAgICAgICAgICAgICAgaXNSZXNpemluZzppc1Jlc2l6aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmlld3BvcnREYXRhXG5cbiAgICB9LFtvcmllbnRhdGlvbiwgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBpc1Jlc2l6aW5nUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIHByb2Nlc3NpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBzd2l0Y2ggKHBvcnRzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAncHJlcGFyZSc6XG4gICAgICAgICAgICBjYXNlICdyZXNpemUnOiB7XG4gICAgICAgICAgICAgICAgc2V0UG9ydFN0YXRlKCdyZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFtwb3J0c3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJldHVybiA8Vmlld3BvcnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyB2aWV3cG9ydERhdGFSZWYuY3VycmVudCB9PlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgc3R5bGUgPSB7ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fVxuICAgICAgICAgICAgcmVmID0ge3ZpZXdwb3J0ZGl2UmVmfVxuICAgICAgICA+XG4gICAgICAgICAgICB7IChwb3J0c3RhdGUgIT0gJ3ByZXBhcmUnKT9jaGlsZHJlbjpudWxsIH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9WaWV3cG9ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgXG59IC8vIFZpZXdwb3J0XG5cbi8vIGVzdGFibGlzaCBtaW5pbXVtIHdpZHRoL2hlaWdodCBmb3IgdGhlIHZpZXdwb3J0IC0tIGFwcHJveGltYXRlbHkgb25lIGl0ZW1cbmNvbnN0IGNhbGNNaW5WaWV3cG9ydENyb3NzTGVuZ3RoID0gKG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHBhZGRpbmcpID0+IHtcbiAgICBsZXQgY3Jvc3NsZW5ndGgsIGNlbGxMZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHRcbiAgICB9XG4gICAgY3Jvc3NsZW5ndGggPSBjZWxsTGVuZ3RoICsgKHBhZGRpbmcgKiAyKVxuICAgIHJldHVybiBjcm9zc2xlbmd0aFxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar use_is_mounted_1 = __importDefault(__webpack_require__(6));\nexports.default = use_is_mounted_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL2luZGV4LmpzPzVjOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHVDQUF1QyxtQkFBTyxDQUFDLENBQWtCO0FBQ2pFO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHVzZV9pc19tb3VudGVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXNlLWlzLW1vdW50ZWRcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXNlX2lzX21vdW50ZWRfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz82ZGQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0MsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWMsb0VBQUssRUFBQyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval(' // infinitegridscroller.tsx\n// copyright (c) 2019 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar react_1 = __importDefault(__webpack_require__(0));\n\nvar viewport_1 = __importDefault(__webpack_require__(1));\n\nvar scrollblock_1 = __importDefault(__webpack_require__(7));\n\nvar cradle_1 = __importDefault(__webpack_require__(8));\n/*\n    BACKLOG:\n    - cache: none/preload/keepload\n*/\n// ===================================[ INITIALIZE ]===========================\n\n/*\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the scrollblock, which in turn contains the cradle\n        - a component that contains displayed (or nearly displayed) items.\n    The items are skeletons which contain the host content components.\n\n    Scrollblock virtually represents the entirety of the list, and of course scrolls\n    Cradle contains the list items, and is \'virtualiized\' -- it appears as\n      though it is the full scrollblock, but in fact it is only slightly larger than\n      the viewport.\n    - individual items are framed by ItemShell, managed by Cradle\n\n    Overall the infinitegridscroller manages the often asynchronous interactions of the\n    components of the mechanism\n*/\n\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  var orientation = props.orientation,\n      // vertical or horizontal\n  gap = props.gap,\n      // space between grid cells, not including the leading and trailing edges\n  padding = props.padding,\n      // the space between the items and the viewport, applied to the cradle\n  cellHeight = props.cellHeight,\n      // the outer pixel height - literal for vertical; approximate for horizontal\n  cellWidth = props.cellWidth,\n      // the outer pixel width - literal for horizontal; approximate for vertical\n  runway = props.runway,\n      // the number of items outside the view of each side of the viewport \n  // -- gives time to assemble before display\n  listsize = props.listsize,\n      // the exact number of the size of the virtual list\n  offset = props.offset,\n      // the 0-based starting index of the list, when first loaded\n  getItem = props.getItem,\n      // function provided by host - parameter is index number, set by system; return value is \n  // host-selected component or promise of a component\n  functions = props.functions,\n      // properties with direct access to some component utilites, optional\n  placeholder = props.placeholder,\n      // a sparse component to stand in for content until the content arrives; \n  // optional, replaces default\n  styles = props.styles,\n      // passive style over-rides (eg. color, opacity) for viewport, scrollblock, cradle, or scrolltracker\n  // to come...\n  // cache = "preload", "keepload", "none"\n  // dense, // boolean (only with preload)\n  layout = props.layout; // defaults\n\n  (_a = functions) !== null && _a !== void 0 ? _a : functions = {};\n  (_b = gap) !== null && _b !== void 0 ? _b : gap = 0;\n  (_c = padding) !== null && _c !== void 0 ? _c : padding = 0;\n  (_d = runway) !== null && _d !== void 0 ? _d : runway = 3;\n  (_e = offset) !== null && _e !== void 0 ? _e : offset = 0;\n  (_f = listsize) !== null && _f !== void 0 ? _f : listsize = 0;\n  (_g = layout) !== null && _g !== void 0 ? _g : layout = \'uniform\'; // constraints\n\n  offset = Math.max(0, offset); // non-negative\n\n  offset = Math.min(listsize, offset); // not larger than list\n\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'horizontal\';\n  } // convert to pixels\n\n\n  var runwaylength = orientation == \'vertical\' ? runway * (cellHeight + gap) : runway * (cellWidth + gap);\n  runwaylength && (runwaylength += padding * 2);\n  return react_1["default"].createElement(viewport_1["default"], {\n    orientation: orientation,\n    cellWidth: cellHeight,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    functions: functions,\n    styles: styles\n  }, react_1["default"].createElement(scrollblock_1["default"], {\n    listsize: listsize,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    orientation: orientation,\n    functions: functions,\n    styles: styles\n  }, react_1["default"].createElement(cradle_1["default"], {\n    gap: gap,\n    padding: padding,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    listsize: listsize,\n    offset: offset,\n    orientation: orientation,\n    runwaylength: runwaylength,\n    getItem: getItem,\n    functions: functions,\n    placeholder: placeholder,\n    styles: styles,\n    runwaycount: runway\n  })));\n};\n\nexports["default"] = InfiniteGridScroller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUVBOzs7O0FBS0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTSxvQkFBb0IsR0FBRyxTQUF2QixvQkFBdUIsQ0FBQyxLQUFELEVBQU07OztBQUUzQjtBQUFBLE1BQWE7QUFDYixpQkFEQTtBQUFBLE1BQ0s7QUFDTCx5QkFGQTtBQUFBLE1BRVM7QUFDVCwrQkFIQTtBQUFBLE1BR1k7QUFDWiw2QkFKQTtBQUFBLE1BSVc7QUFDWCx1QkFMQTtBQUFBLE1BS1E7QUFDSjtBQUNKLDJCQVBBO0FBQUEsTUFPVTtBQUNWLHVCQVJBO0FBQUEsTUFRUTtBQUNSLHlCQVRBO0FBQUEsTUFTUztBQUNMO0FBQ0osNkJBWEE7QUFBQSxNQVdXO0FBQ1gsaUNBWkE7QUFBQSxNQVlhO0FBQ1Q7QUFDSix1QkFkQTtBQUFBLE1BY1E7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFsQkEsQ0FGMkIsQ0F1Qi9COztBQUNBLHVCQUFXLElBQVgsSUFBVyxhQUFYLEdBQVcsRUFBWCxHQUFlLFNBQVMsR0FBRyxFQUEzQjtBQUNBLGlCQUFLLElBQUwsSUFBSyxhQUFMLEdBQUssRUFBTCxHQUFTLEdBQUcsR0FBRyxDQUFmO0FBQ0EscUJBQVMsSUFBVCxJQUFTLGFBQVQsR0FBUyxFQUFULEdBQWEsT0FBTyxHQUFHLENBQXZCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLENBQXJCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLENBQXJCO0FBQ0Esc0JBQVUsSUFBVixJQUFVLGFBQVYsR0FBVSxFQUFWLEdBQWMsUUFBUSxHQUFHLENBQXpCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLFNBQXJCLENBOUIrQixDQStCL0I7O0FBQ0EsUUFBTSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFXLE1BQVgsQ0FBVCxDQWhDK0IsQ0FnQ0g7O0FBQzVCLFFBQU0sR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLFFBQVQsRUFBbUIsTUFBbkIsQ0FBVCxDQWpDK0IsQ0FpQ0s7O0FBQ3BDLE1BQUksQ0FBQyxDQUFDLFlBQUQsRUFBYyxVQUFkLEVBQTBCLFFBQTFCLENBQW1DLFdBQW5DLENBQUwsRUFBc0Q7QUFDbEQsZUFBVyxHQUFHLFlBQWQ7QUFDSCxHQXBDOEIsQ0FxQy9COzs7QUFDQSxNQUFJLFlBQVksR0FBSSxXQUFXLElBQUksVUFBaEIsR0FBNkIsTUFBTSxJQUFJLFVBQVUsR0FBRyxHQUFqQixDQUFuQyxHQUEyRCxNQUFNLElBQUksU0FBUyxHQUFHLEdBQWhCLENBQXBGO0FBQ0EsY0FBWSxLQUFLLFlBQVksSUFBSyxPQUFPLEdBQUcsQ0FBaEMsQ0FBWjtBQUVBLFNBQU8saUNBQUMscUJBQUQsRUFBUztBQUVaLGVBQVcsRUFBSyxXQUZKO0FBR1osYUFBUyxFQUFLLFVBSEY7QUFJWixjQUFVLEVBQUssVUFKSDtBQUtaLE9BQUcsRUFBSyxHQUxJO0FBTVosV0FBTyxFQUFLLE9BTkE7QUFPWixhQUFTLEVBQUssU0FQRjtBQVFaLFVBQU0sRUFBSztBQVJDLEdBQVQsRUFXSCxpQ0FBQyx3QkFBRCxFQUFZO0FBRVIsWUFBUSxFQUFLLFFBRkw7QUFHUixhQUFTLEVBQUssU0FITjtBQUlSLGNBQVUsRUFBSyxVQUpQO0FBS1IsT0FBRyxFQUFLLEdBTEE7QUFNUixXQUFPLEVBQUssT0FOSjtBQU9SLGVBQVcsRUFBSyxXQVBSO0FBUVIsYUFBUyxFQUFLLFNBUk47QUFTUixVQUFNLEVBQUs7QUFUSCxHQUFaLEVBYUksaUNBQUMsbUJBQUQsRUFBTztBQUVILE9BQUcsRUFBSyxHQUZMO0FBR0gsV0FBTyxFQUFLLE9BSFQ7QUFJSCxhQUFTLEVBQUssU0FKWDtBQUtILGNBQVUsRUFBSyxVQUxaO0FBTUgsWUFBUSxFQUFLLFFBTlY7QUFPSCxVQUFNLEVBQUssTUFQUjtBQVFILGVBQVcsRUFBSyxXQVJiO0FBU0gsZ0JBQVksRUFBSyxZQVRkO0FBVUgsV0FBTyxFQUFLLE9BVlQ7QUFXSCxhQUFTLEVBQUssU0FYWDtBQVlILGVBQVcsRUFBSyxXQVpiO0FBYUgsVUFBTSxFQUFLLE1BYlI7QUFjSCxlQUFXLEVBQUs7QUFkYixHQUFQLENBYkosQ0FYRyxDQUFQO0FBNkNILENBdEZEOztBQXdGQSxxQkFBZSxvQkFBZiIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW5maW5pdGVncmlkc2Nyb2xsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTkgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3cG9ydCdcbmltcG9ydCBTY3JvbGxibG9jayBmcm9tICcuL3Njcm9sbGJsb2NrJ1xuaW1wb3J0IENyYWRsZSBmcm9tICcuL2NyYWRsZSdcblxuLypcbiAgICBCQUNLTE9HOiBcbiAgICAtIGNhY2hlOiBub25lL3ByZWxvYWQva2VlcGxvYWRcbiovXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09WyBJTklUSUFMSVpFIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLypcbiAgICBUaGUgam9iIG9mIEluZmluaXRlR3JpZFNjcm9sbGVyIGlzIHRvIHBhc3MgcGFyYW1ldGVycyB0byBkZXBlbmRlbnRzLlxuICAgIFZpZXdwb3J0IGNvbnRhaW5zIHRoZSBzY3JvbGxibG9jaywgd2hpY2ggaW4gdHVybiBjb250YWlucyB0aGUgY3JhZGxlIFxuICAgICAgICAtIGEgY29tcG9uZW50IHRoYXQgY29udGFpbnMgZGlzcGxheWVkIChvciBuZWFybHkgZGlzcGxheWVkKSBpdGVtcy4gXG4gICAgVGhlIGl0ZW1zIGFyZSBza2VsZXRvbnMgd2hpY2ggY29udGFpbiB0aGUgaG9zdCBjb250ZW50IGNvbXBvbmVudHMuXG5cbiAgICBTY3JvbGxibG9jayB2aXJ0dWFsbHkgcmVwcmVzZW50cyB0aGUgZW50aXJldHkgb2YgdGhlIGxpc3QsIGFuZCBvZiBjb3Vyc2Ugc2Nyb2xsc1xuICAgIENyYWRsZSBjb250YWlucyB0aGUgbGlzdCBpdGVtcywgYW5kIGlzICd2aXJ0dWFsaWl6ZWQnIC0tIGl0IGFwcGVhcnMgYXNcbiAgICAgIHRob3VnaCBpdCBpcyB0aGUgZnVsbCBzY3JvbGxibG9jaywgYnV0IGluIGZhY3QgaXQgaXMgb25seSBzbGlnaHRseSBsYXJnZXIgdGhhblxuICAgICAgdGhlIHZpZXdwb3J0LlxuICAgIC0gaW5kaXZpZHVhbCBpdGVtcyBhcmUgZnJhbWVkIGJ5IEl0ZW1TaGVsbCwgbWFuYWdlZCBieSBDcmFkbGVcblxuICAgIE92ZXJhbGwgdGhlIGluZmluaXRlZ3JpZHNjcm9sbGVyIG1hbmFnZXMgdGhlIG9mdGVuIGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgb2YgdGhlIFxuICAgIGNvbXBvbmVudHMgb2YgdGhlIG1lY2hhbmlzbVxuKi9cbmNvbnN0IEluZmluaXRlR3JpZFNjcm9sbGVyID0gKHByb3BzKSA9PiB7XG4gICAgbGV0IHsgXG4gICAgICAgIG9yaWVudGF0aW9uLCAvLyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsXG4gICAgICAgIGdhcCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBlZGdlc1xuICAgICAgICBwYWRkaW5nLCAvLyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgaXRlbXMgYW5kIHRoZSB2aWV3cG9ydCwgYXBwbGllZCB0byB0aGUgY3JhZGxlXG4gICAgICAgIGNlbGxIZWlnaHQsIC8vIHRoZSBvdXRlciBwaXhlbCBoZWlnaHQgLSBsaXRlcmFsIGZvciB2ZXJ0aWNhbDsgYXBwcm94aW1hdGUgZm9yIGhvcml6b250YWxcbiAgICAgICAgY2VsbFdpZHRoLCAvLyB0aGUgb3V0ZXIgcGl4ZWwgd2lkdGggLSBsaXRlcmFsIGZvciBob3Jpem9udGFsOyBhcHByb3hpbWF0ZSBmb3IgdmVydGljYWxcbiAgICAgICAgcnVud2F5LCAvLyB0aGUgbnVtYmVyIG9mIGl0ZW1zIG91dHNpZGUgdGhlIHZpZXcgb2YgZWFjaCBzaWRlIG9mIHRoZSB2aWV3cG9ydCBcbiAgICAgICAgICAgIC8vIC0tIGdpdmVzIHRpbWUgdG8gYXNzZW1ibGUgYmVmb3JlIGRpc3BsYXlcbiAgICAgICAgbGlzdHNpemUsIC8vIHRoZSBleGFjdCBudW1iZXIgb2YgdGhlIHNpemUgb2YgdGhlIHZpcnR1YWwgbGlzdFxuICAgICAgICBvZmZzZXQsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuICAgICAgICBnZXRJdGVtLCAvLyBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0IC0gcGFyYW1ldGVyIGlzIGluZGV4IG51bWJlciwgc2V0IGJ5IHN5c3RlbTsgcmV0dXJuIHZhbHVlIGlzIFxuICAgICAgICAgICAgLy8gaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICBmdW5jdGlvbnMsIC8vIHByb3BlcnRpZXMgd2l0aCBkaXJlY3QgYWNjZXNzIHRvIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzLCBvcHRpb25hbFxuICAgICAgICBwbGFjZWhvbGRlciwgLy8gYSBzcGFyc2UgY29tcG9uZW50IHRvIHN0YW5kIGluIGZvciBjb250ZW50IHVudGlsIHRoZSBjb250ZW50IGFycml2ZXM7IFxuICAgICAgICAgICAgLy8gb3B0aW9uYWwsIHJlcGxhY2VzIGRlZmF1bHRcbiAgICAgICAgc3R5bGVzLCAvLyBwYXNzaXZlIHN0eWxlIG92ZXItcmlkZXMgKGVnLiBjb2xvciwgb3BhY2l0eSkgZm9yIHZpZXdwb3J0LCBzY3JvbGxibG9jaywgY3JhZGxlLCBvciBzY3JvbGx0cmFja2VyXG4gICAgICAgIC8vIHRvIGNvbWUuLi5cbiAgICAgICAgLy8gY2FjaGUgPSBcInByZWxvYWRcIiwgXCJrZWVwbG9hZFwiLCBcIm5vbmVcIlxuICAgICAgICAvLyBkZW5zZSwgLy8gYm9vbGVhbiAob25seSB3aXRoIHByZWxvYWQpXG4gICAgICAgIGxheW91dCwgLy8gdW5pZm9ybSwgdmFyaWFibGVcbiAgICB9ID0gcHJvcHNcblxuICAgIC8vIGRlZmF1bHRzXG4gICAgZnVuY3Rpb25zICE/PyAoZnVuY3Rpb25zID0ge30pXG4gICAgZ2FwICE/PyAoZ2FwID0gMClcbiAgICBwYWRkaW5nICE/PyAocGFkZGluZyA9IDApXG4gICAgcnVud2F5ICE/PyAocnVud2F5ID0gMylcbiAgICBvZmZzZXQgIT8/IChvZmZzZXQgPSAwKVxuICAgIGxpc3RzaXplICE/PyAobGlzdHNpemUgPSAwKVxuICAgIGxheW91dCAhPz8gKGxheW91dCA9ICd1bmlmb3JtJylcbiAgICAvLyBjb25zdHJhaW50c1xuICAgIG9mZnNldCA9IE1hdGgubWF4KDAsb2Zmc2V0KSAvLyBub24tbmVnYXRpdmVcbiAgICBvZmZzZXQgPSBNYXRoLm1pbihsaXN0c2l6ZSwgb2Zmc2V0KSAvLyBub3QgbGFyZ2VyIHRoYW4gbGlzdFxuICAgIGlmICghWydob3Jpem9udGFsJywndmVydGljYWwnXS5pbmNsdWRlcyhvcmllbnRhdGlvbikpIHtcbiAgICAgICAgb3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCdcbiAgICB9XG4gICAgLy8gY29udmVydCB0byBwaXhlbHNcbiAgICBsZXQgcnVud2F5bGVuZ3RoID0gKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpPyhydW53YXkgKiAoY2VsbEhlaWdodCArIGdhcCkpOihydW53YXkgKiAoY2VsbFdpZHRoICsgZ2FwKSlcbiAgICBydW53YXlsZW5ndGggJiYgKHJ1bndheWxlbmd0aCArPSAocGFkZGluZyAqIDIpKVxuXG4gICAgcmV0dXJuIDxWaWV3cG9ydCBcblxuICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfSBcbiAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgY2VsbEhlaWdodCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgIGdhcCA9IHsgZ2FwIH1cbiAgICAgICAgcGFkZGluZyA9IHsgcGFkZGluZyB9XG4gICAgICAgIGZ1bmN0aW9ucyA9IHsgZnVuY3Rpb25zIH1cbiAgICAgICAgc3R5bGVzID0geyBzdHlsZXMgfVxuICAgID5cbiAgICBcbiAgICAgICAgPFNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgICAgIGdhcCA9IHsgZ2FwfVxuICAgICAgICAgICAgcGFkZGluZyA9IHsgcGFkZGluZyB9XG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfVxuICAgICAgICAgICAgZnVuY3Rpb25zID0geyBmdW5jdGlvbnMgfVxuICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXMgfVxuXG4gICAgICAgID5cblxuICAgICAgICAgICAgPENyYWRsZSBcblxuICAgICAgICAgICAgICAgIGdhcCA9IHsgZ2FwIH1cbiAgICAgICAgICAgICAgICBwYWRkaW5nID0geyBwYWRkaW5nIH1cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB7IG9mZnNldCB9XG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSB7IG9yaWVudGF0aW9uIH1cbiAgICAgICAgICAgICAgICBydW53YXlsZW5ndGggPSB7IHJ1bndheWxlbmd0aCB9IFxuICAgICAgICAgICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyA9IHsgZnVuY3Rpb25zIH1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzIH1cbiAgICAgICAgICAgICAgICBydW53YXljb3VudCA9IHsgcnVud2F5IH1cblxuICAgICAgICAgICAgLz5cblxuICAgICAgICA8L1Njcm9sbGJsb2NrPlxuICAgIDwvVmlld3BvcnQ+XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar react_1 = __webpack_require__(0);\nfunction useIsMounted() {\n    var ref = react_1.useRef(false);\n    react_1.useEffect(function () {\n        ref.current = true;\n        return function () {\n            ref.current = false;\n        };\n    }, []);\n    return function () { return ref.current; };\n}\nexports.default = useIsMounted;\n//# sourceMappingURL=use-is-mounted.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL3VzZS1pcy1tb3VudGVkLmpzPzkzMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgICB2YXIgcmVmID0gcmVhY3RfMS51c2VSZWYoZmFsc2UpO1xuICAgIHJlYWN0XzEudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlSXNNb3VudGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWlzLW1vdW50ZWQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){"use strict";eval(" // scrollblock.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nvar viewport_1 = __webpack_require__(1);\n\nvar Scrollblock = function Scrollblock(_a) {\n  var children = _a.children,\n      listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      functions = _a.functions,\n      styles = _a.styles; // -------------------------[ context and state ]-------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n\n  var _b = react_1.useState('prepare'),\n      blockstate = _b[0],\n      setBlockState = _b[1]; // -----------------------------------[ data heap ]-------------------------\n\n\n  var scrollBlockLengthRef = react_1.useRef(null);\n  var scrollblockRef = react_1.useRef(null);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    backgroundColor: 'white',\n    position: 'relative'\n  }, styles === null || styles === void 0 ? void 0 : styles.cradle));\n\n  var _c = react_1.useState(divlinerstyleRef.current),\n      divlinerstyle = _c[0],\n      saveDivlinerstyle = _c[1]; // to trigger render\n\n\n  var viewportDimensions = viewportData.viewportDimensions,\n      itemobserver = viewportData.itemobserver,\n      isResizing = viewportData.isResizing;\n  var top = viewportDimensions.top,\n      right = viewportDimensions.right,\n      bottom = viewportDimensions.bottom,\n      left = viewportDimensions.left,\n      width = viewportDimensions.width,\n      height = viewportDimensions.height; // state engine\n\n  react_1.useEffect(function () {\n    switch (blockstate) {\n      case 'prepare':\n        {\n          setBlockState('render');\n          break;\n        }\n    }\n  }, [blockstate]);\n  react_1.useLayoutEffect(function () {\n    updateBlockLength();\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, scrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBlockLength = react_1.useCallback(function () {\n    var scrollblocklength = calcScrollblockLength({\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width\n    });\n    scrollBlockLengthRef.current = scrollblocklength;\n  }, [listsize, cellHeight, cellWidth, gap, padding, orientation, height, width]);\n  return blockstate != 'prepare' ? react_1[\"default\"].createElement(\"div\", {\n    ref: scrollblockRef,\n    style: divlinerstyleRef.current\n  }, children) : null;\n}; // Scrollblock\n// all the parameters affect the length\n\n\nvar calcScrollblockLength = function calcScrollblockLength(_a) {\n  var listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth; // dependents of orientation\n\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == 'vertical') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap;\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  var listlength = Math.ceil(listsize / crosscount);\n  var straightlength = listlength * cellLength - (listlength > 0 ? gap : 0) + padding * 2;\n  return straightlength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, scrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current);\n  var height;\n  var width;\n\n  if (orientation == 'horizontal') {\n    height = '100%';\n    width = scrollblocklengthRef.current + 'px';\n  } else if (orientation == 'vertical') {\n    height = scrollblocklengthRef.current + 'px';\n    width = '100%';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};\n\nexports[\"default\"] = Scrollblock;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGxibG9jay50c3g/MmZhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQVVuQjtNQVRHLHNCO01BQ0Esc0I7TUFDQSwwQjtNQUNBLHdCO01BQ0EsWTtNQUNBLG9CO01BQ0EsNEI7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FFRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxtQkFBVywwQkFBWCxDQUFyQjs7QUFDTTtBQUFBLE1BQUMsa0JBQUQ7QUFBQSxNQUFZLHFCQUFaLENBSlQsQ0FNRzs7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxlQUFPLElBQVAsQ0FBN0I7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLElBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQ0E7QUFFSSxtQkFBZSxFQUFDLE9BRnBCO0FBR0ksWUFBUSxFQUFDO0FBSGIsR0FEQSxFQU0wQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsTUFObEMsQ0FEcUIsQ0FBekI7O0FBVU07QUFBQSxNQUFDLHFCQUFEO0FBQUEsTUFBZSx5QkFBZixDQW5CVCxDQW1CZ0Y7OztBQUV2RTtBQUFBLE1BQW9CLHdDQUFwQjtBQUFBLE1BQWtDLG9DQUFsQztBQUNBO0FBQUEsTUFBSyxnQ0FBTDtBQUFBLE1BQVksa0NBQVo7QUFBQSxNQUFvQiw4QkFBcEI7QUFBQSxNQUEwQixnQ0FBMUI7QUFBQSxNQUFpQyxrQ0FBakMsQ0F0QlQsQ0F3Qkc7O0FBQ0Esb0JBQVU7QUFDTixZQUFRLFVBQVI7QUFDSSxXQUFLLFNBQUw7QUFBZ0I7QUFDWix1QkFBYSxDQUFDLFFBQUQsQ0FBYjtBQUNBO0FBQ0g7QUFKTDtBQU1ILEdBUEQsRUFPRSxDQUFDLFVBQUQsQ0FQRjtB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LElBQXZDO0FBQ0gsR0FIRCxNQUdPLElBQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBQ2xDLFVBQU0sR0FBRyxvQkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUF4QztBQUNBLFNBQUssR0FBRyxNQUFSO0FBQ0g7O0FBQ0QsYUFBVyxDQUFDLE1BQVosR0FBcUIsTUFBckI7QUFDQSxhQUFXLENBQUMsS0FBWixHQUFvQixLQUFwQjtBQUVBLFNBQU8sV0FBUDtBQUNILENBaEJEOztBQWtCQSxxQkFBZSxXQUFmIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY3JvbGxibG9jay50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QsIHt1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGV9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL3ZpZXdwb3J0J1xuXG5jb25zdCBTY3JvbGxibG9jayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgbGlzdHNpemUsIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgZ2FwLCBcbiAgICBwYWRkaW5nLCBcbiAgICBvcmllbnRhdGlvbiwgXG4gICAgZnVuY3Rpb25zLCBcbiAgICBzdHlsZXMgXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjb250ZXh0IGFuZCBzdGF0ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IHZpZXdwb3J0RGF0YSA9IHVzZUNvbnRleHQoVmlld3BvcnRDb250ZXh0KVxuICAgIGNvbnN0IFtibG9ja3N0YXRlLHNldEJsb2NrU3RhdGVdID0gdXNlU3RhdGUoJ3ByZXBhcmUnKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGRhdGEgaGVhcCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IHNjcm9sbEJsb2NrTGVuZ3RoUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgICAgIFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsIHN0eWxlcz8uY3JhZGxlKVxuXG4gICAgKVxuICAgIGNvbnN0IFtkaXZsaW5lcnN0eWxlLHNhdmVEaXZsaW5lcnN0eWxlXSA9IHVzZVN0YXRlKGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCkgLy8gdG8gdHJpZ2dlciByZW5kZXJcblxuICAgIGxldCB7IHZpZXdwb3J0RGltZW5zaW9ucywgaXRlbW9ic2VydmVyLCBpc1Jlc2l6aW5nIH0gPSB2aWV3cG9ydERhdGFcbiAgICBsZXQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IHZpZXdwb3J0RGltZW5zaW9uc1xuXG4gICAgLy8gc3RhdGUgZW5naW5lXG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHN3aXRjaCAoYmxvY2tzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAncHJlcGFyZSc6IHtcbiAgICAgICAgICAgICAgICBzZXRCbG9ja1N0YXRlKCdyZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFtibG9ja3N0YXRlXSlcbiAgICBcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHVwZGF0ZUJsb2NrTGVuZ3RoKClcbiAgICAgICAgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50ID0gdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMob3JpZW50YXRpb24sZGl2bGluZXJzdHlsZVJlZixzY3JvbGxCbG9ja0xlbmd0aFJlZilcbiAgICAgICAgc2F2ZURpdmxpbmVyc3R5bGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgXSlcblxuICAgIGNvbnN0IHVwZGF0ZUJsb2NrTGVuZ3RoID0gdXNlQ2FsbGJhY2soXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxibG9ja2xlbmd0aCA9IFxuICAgICAgICAgICAgICAgIGNhbGNTY3JvbGxibG9ja0xlbmd0aChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0OmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0d2lkdGg6d2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHNjcm9sbEJsb2NrTGVuZ3RoUmVmLmN1cnJlbnQgPSBzY3JvbGxibG9ja2xlbmd0aFxuXG4gICAgICAgIH0sW1xuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgXVxuICAgIClcblxuICAgIHJldHVybiAoYmxvY2tzdGF0ZSAhPSAncHJlcGFyZScpXG4gICAgICAgID88ZGl2IHJlZiA9IHtzY3JvbGxibG9ja1JlZn0gc3R5bGU9e2RpdmxpbmVyc3R5bGVSZWYuY3VycmVudH0+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICA6bnVsbFxuXG59IC8vIFNjcm9sbGJsb2NrXG5cbi8vIGFsbCB0aGUgcGFyYW1ldGVycyBhZmZlY3QgdGhlIGxlbmd0aFxuY29uc3QgY2FsY1Njcm9sbGJsb2NrTGVuZ3RoID0gKHtcbiAgICBsaXN0c2l6ZSwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBnYXAsIFxuICAgIHBhZGRpbmcsIFxuICAgIG9yaWVudGF0aW9uLCBcbiAgICB2aWV3cG9ydGhlaWdodCxcbiAgICB2aWV3cG9ydHdpZHRoLFxuICAgIH0pID0+IHtcblxuICAgIC8vIGRlcGVuZGVudHMgb2Ygb3JpZW50YXRpb25cbiAgICBsZXQgY3Jvc3NsZW5ndGhcbiAgICBsZXQgY2VsbExlbmd0aFxuICAgIGxldCB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnR3aWR0aCBcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY3Jvc3NsZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgdmlld3BvcnRjcm9zc2xlbmd0aCA9IHZpZXdwb3J0aGVpZ2h0XG5cbiAgICB9XG4gICAgLy8gYWRqdXN0bWVudHMgdG8gdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggLT0gKHBhZGRpbmcgKiAyKVxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggKz0gZ2FwXG5cbiAgICBpZiAodmlld3BvcnRjcm9zc2xlbmd0aCA8IGNyb3NzbGVuZ3RoKSB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gY3Jvc3NsZW5ndGggLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmVcbiAgICBsZXQgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRjcm9zc2xlbmd0aC9jcm9zc2xlbmd0aClcblxuICAgIGxldCBsaXN0bGVuZ3RoID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG5cbiAgICBsZXQgc3RyYWlnaHRsZW5ndGggPSAobGlzdGxlbmd0aCAqIGNlbGxMZW5ndGgpIC0gKChsaXN0bGVuZ3RoID4gMCk/Z2FwOjApICsgKHBhZGRpbmcgKiAyKVxuXG4gICAgcmV0dXJuIHN0cmFpZ2h0bGVuZ3RoXG5cbn1cblxuY29uc3QgdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMgPSAob3JpZW50YXRpb24sc3R5bGVzUmVmLHNjcm9sbGJsb2NrbGVuZ3RoUmVmKSA9PiB7XG5cbiAgICBsZXQgbG9jYWxzdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LHN0eWxlc1JlZi5jdXJyZW50KSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgbGV0IGhlaWdodCBcbiAgICBsZXQgd2lkdGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IHNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIGhlaWdodCA9IHNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgfVxuICAgIGxvY2Fsc3R5bGVzLmhlaWdodCA9IGhlaWdodFxuICAgIGxvY2Fsc3R5bGVzLndpZHRoID0gd2lkdGhcblxuICAgIHJldHVybiBsb2NhbHN0eWxlc1xufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxibG9ja1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval(" // cradle.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    TODO:\n*/\n\n/*\n    Description\n    -----------\n\n    This module has one main design pattern: the butterfuly pattern (my name)\n\n    the butterfly pattern:\n        This pattern consists of two containers for items (the \"wings\"), joined by a 0-length div (the \"spine\").\n        The wings are fixed to the spine through the bottom/right position style on one side, and top/left\n        on the other. Thus additions or deletions effect the distant ends of the wings from the spine on each end.\n        All three together comprise the \"cradle\" of items. After a change of content, the only compensating\n        adjustment required is the change of position of the spine in relation to the viewport.\n\n*/\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nvar viewport_1 = __webpack_require__(1);\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(2));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(3));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"];\nvar ITEM_OBSERVER_THRESHOLD = .9;\n\nvar cradlefunctions_1 = __webpack_require__(9);\n\nvar scrolltracker_1 = __importDefault(__webpack_require__(13));\n\nvar SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = 200;\n\nvar Cradle = function Cradle(_a) {\n  var gap = _a.gap,\n      padding = _a.padding,\n      runwaylength = _a.runwaylength,\n      runwaycount = _a.runwaycount,\n      listsize = _a.listsize,\n      offset = _a.offset,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      getItem = _a.getItem,\n      placeholder = _a.placeholder,\n      functions = _a.functions,\n      styles = _a.styles; // functions and styles handled separately\n\n  var cradlePropsRef = react_1.useRef(null); // access by closures\n\n  cradlePropsRef.current = react_1.useMemo(function () {\n    return {\n      gap: gap,\n      padding: padding,\n      runwaylength: runwaylength,\n      runwaycount: runwaycount,\n      listsize: listsize,\n      offset: offset,\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      getItem: getItem,\n      placeholder: placeholder\n    };\n  }, [gap, padding, runwaylength, runwaycount, listsize, offset, orientation, cellHeight, cellWidth, getItem, placeholder]); // =============================================================================================\n  // --------------------------------------[ INITIALIZATION ]-------------------------------------\n  // =============================================================================================\n  // -----------------------------------------------------------------------\n  // -----------------------------------[ utilites ]------------------------\n\n  var isMounted = react_is_mounted_hook_1[\"default\"]();\n  var referenceIndexCallbackRef = react_1.useRef(functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback);\n  var itemObserverRef = react_1.useRef(null); // IntersectionObserver\n\n  var cradleIntersectionObserverRef = react_1.useRef(null);\n  var cradleResizeObserverRef = react_1.useRef(null); // -----------------------------------------------------------------------\n  // ---------------------------[ context data ]----------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n  var viewportDataRef = react_1.useRef(null);\n  viewportDataRef.current = viewportData;\n\n  var _b = react_1.useState('setup'),\n      cradlestate = _b[0],\n      saveCradleState = _b[1];\n\n  var cradlestateRef = react_1.useRef(null); // access by closures\n\n  cradlestateRef.current = cradlestate; // console.log('running cradle with state',cradlestate)\n  // -----------------------------------------------------------------------\n  // -------------------------[ control variables ]-----------------\n\n  var pauseItemObserverRef = react_1.useRef(false);\n  var pauseCradleIntersectionObserverRef = react_1.useRef(false);\n  var pauseCradleResizeObserverRef = react_1.useRef(false);\n  var pauseScrollingEffectsRef = react_1.useRef(false); // to control appearance of repositioning mode\n\n  var isTailCradleInViewRef = react_1.useRef(true);\n  var isHeadCradleInViewRef = react_1.useRef(true);\n  var isCradleInViewRef = react_1.useRef(true); // ------------------------------------------------------------------------\n  // -----------------------[ initialization effects ]-----------------------\n  //initialize host functions properties\n\n  react_1.useEffect(function () {\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('scrollToItem')) {\n      functions.scrollToItem = scrollToItem;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getVisibleList')) {\n      functions.getVisibleList = getVisibleList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getContentList')) {\n      functions.getContentList = getContentList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('reload')) {\n      functions.reload = reload;\n    }\n\n    referenceIndexCallbackRef.current = functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback;\n  }, [functions]); // initialize window scroll listener\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n    viewportData.elementref.current.addEventListener('scroll', onScroll);\n    return function () {\n      viewportData.elementref.current && viewportData.elementref.current.removeEventListener('scroll', onScroll);\n    };\n  }, []); // -----------------------------------------------------------------------\n  // -----------------------[ reconfiguration effects ]---------------------\n  // trigger resizing based on viewport state\n\n  react_1.useEffect(function () {\n    if (viewportData.isResizing) {\n      // enter resizing mode\n      callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n      pauseItemObserverRef.current = true;\n      pauseCradleIntersectionObserverRef.current = true;\n      pauseScrollingEffectsRef.current = true;\n      saveCradleState('resizing');\n    } // complete resizing mode\n\n\n    if (!viewportData.isResizing && cradlestateRef.current == 'resizing') {\n      saveCradleState('resize');\n    }\n  }, [viewportData.isResizing]); // reload for changed parameters\n\n  react_1.useEffect(function () {\n    if (cradlestateRef.current == 'setup') return;\n    callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    pauseScrollingEffectsRef.current = true;\n    saveCradleState('reload');\n  }, [listsize, cellHeight, cellWidth, gap, padding]); // trigger pivot on change in orientation\n\n  react_1.useEffect(function () {\n    headModelContentRef.current = [];\n    tailModelContentRef.current = [];\n\n    if (cradlestateRef.current != 'setup') {\n      callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n      pauseItemObserverRef.current = true;\n      pauseCradleIntersectionObserverRef.current = true;\n      pauseScrollingEffectsRef.current = true;\n      saveCradleState('pivot');\n    }\n  }, [orientation]); // =======================================================================\n  // -------------------------[ OPERATION ]---------------------------------\n  // =======================================================================\n  // -----------------------------------------------------------------------\n  // ------------------------[ session data ]-------------------------------\n  // ------------------ current location -- first head visible item -------------\n\n  var _c = react_1.useState({\n    index: Math.min(offset, listsize - 1) || 0,\n    scrolloffset: 0\n  }),\n      immediateReferenceIndexData = _c[0],\n      saveImmediateReferenceIndexData = _c[1];\n\n  var immediateReferenceIndexDataRef = react_1.useRef(null); // access by closures\n\n  immediateReferenceIndexDataRef.current = immediateReferenceIndexData;\n  var masterReferenceIndexDataRef = react_1.useRef(immediateReferenceIndexData); // capture for state resetContent operations\n\n  var callingReferenceIndexDataRef = react_1.useRef(immediateReferenceIndexData); // anticipate reposition\n  // -------------------------------[ cradle data ]-------------------------------------\n  // cradle butterfly html components\n\n  var headCradleElementRef = react_1.useRef(null);\n  var tailCradleElementRef = react_1.useRef(null);\n  var spineCradleElementRef = react_1.useRef(null); // data model\n\n  var modelContentRef = react_1.useRef(null);\n  var headModelContentRef = react_1.useRef(null);\n  var tailModelContentRef = react_1.useRef(null); // view model\n\n  var headViewContentRef = react_1.useRef([]);\n  var tailViewContentRef = react_1.useRef([]);\n  var itemElementsRef = react_1.useRef(new Map()); // items register their element\n  // ------------------------------[ cradle configuration ]---------------------------\n  // viewportDimensions, crosscount, rowcount\n\n  var viewportDimensions = viewportData.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width;\n  var crosscount = react_1.useMemo(function () {\n    var crosscount;\n    var size = orientation == 'horizontal' ? viewportheight : viewportwidth;\n    var crossLength = orientation == 'horizontal' ? cellHeight : cellWidth;\n    var lengthforcalc = size - padding * 2 + gap; // length of viewport\n\n    var tilelengthforcalc = crossLength + gap;\n    tilelengthforcalc = Math.min(tilelengthforcalc, lengthforcalc); // result cannot be less than 1\n\n    crosscount = Math.floor(lengthforcalc / tilelengthforcalc);\n    return crosscount;\n  }, [orientation, cellWidth, cellHeight, gap, padding, viewportheight, viewportwidth]);\n  var crosscountRef = react_1.useRef(crosscount); // for easy reference by observer\n\n  crosscountRef.current = crosscount; // available for observer closure\n\n  var _d = react_1.useMemo(function () {\n    var viewportLength, cellLength;\n\n    if (orientation == 'vertical') {\n      viewportLength = viewportheight;\n      cellLength = cellHeight;\n    } else {\n      viewportLength = viewportwidth;\n      cellLength = cellWidth;\n    }\n\n    cellLength += gap;\n    var viewportrowcount = Math.ceil(viewportLength / cellLength);\n    var cradlerowcount = viewportrowcount + runwaycount * 2;\n    var itemcount = cradlerowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradlerowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradlerowcount, viewportrowcount];\n  }, [orientation, cellWidth, cellHeight, gap, listsize, // padding,\n  viewportheight, viewportwidth, runwaycount, crosscount]),\n      cradlerowcount = _d[0],\n      viewportrowcount = _d[1];\n\n  var cradlerowcountRef = react_1.useRef(null);\n  cradlerowcountRef.current = cradlerowcount;\n  var viewportrowcountRef = react_1.useRef(null);\n  viewportrowcountRef.current = viewportrowcount; // base styles\n\n  var cradleHeadStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = gap + 'px';\n      left = 0;\n      right = 0;\n      top = 'auto';\n    } else {\n      bottom = 0;\n      left = 'auto';\n      right = gap + 'px';\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]);\n  var cradleTailStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 'auto';\n      left = 0;\n      right = 0;\n      top = 0;\n    } else {\n      bottom = 0;\n      left = 0;\n      right = 'right';\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]);\n  var cradleSpineStyle = react_1.useMemo(function () {\n    var paddingx, paddingy, top, left;\n\n    if (orientation == 'vertical') {\n      paddingx = 0;\n      paddingy = padding;\n      top = padding + 'px', left = 'auto';\n    } else {\n      paddingx = padding;\n      paddingy = 0;\n      left = padding + 'px';\n      top = 'auto';\n    }\n\n    return {\n      position: 'relative',\n      top: top,\n      left: left\n    };\n  }, [padding, orientation]); // enhanced styles for grid\n\n  var _e = react_1.useMemo(function () {\n    // merge base style and revisions (by observer)\n    var headCradleStyles = __assign({}, cradleHeadStyle);\n\n    var tailCradleStyles = __assign({}, cradleTailStyle);\n\n    var _a = cradlefunctions_1.setCradleGridStyles({\n      orientation: orientation,\n      headCradleStyles: headCradleStyles,\n      tailCradleStyles: tailCradleStyles,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      crosscount: crosscount,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth\n    }),\n        headstyles = _a[0],\n        tailstyles = _a[1];\n\n    var top, left;\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n    } else {\n      top = 'auto';\n      left = 'padding' + 'px';\n    }\n\n    var spinestyle = {\n      position: 'relative',\n      top: top,\n      left: left\n    };\n    return [headstyles, tailstyles, spinestyle];\n  }, [orientation, cellHeight, cellWidth, gap, padding, viewportheight, viewportwidth, crosscount, cradleHeadStyle, cradleTailStyle, cradleSpineStyle]),\n      headstyle = _e[0],\n      tailstyle = _e[1],\n      spinestyle = _e[2];\n\n  cradleHeadStyle = headstyle;\n  cradleTailStyle = tailstyle;\n  cradleSpineStyle = spinestyle; // =================================================================================\n  // -------------------------[ IntersectionObserver support]-------------------------\n  // =================================================================================\n\n  /*\n      There are two interection observers, one for the cradle, and another for itemShells;\n          both against the viewport.\n      There is also a resize observer for the cradle wings, to respond to size changes of\n          variable cells.\n  */\n  // --------------------------[ cradle observers ]-----------------------------------\n  // set up cradle resizeobserver\n\n  react_1.useEffect(function () {\n    // ResizeObserver\n    cradleResizeObserverRef.current = new LocalResizeObserver(cradleresizeobservercallback);\n    cradleResizeObserverRef.current.observe(headCradleElementRef.current);\n    cradleResizeObserverRef.current.observe(tailCradleElementRef.current);\n    return function () {\n      cradleResizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleresizeobservercallback = react_1.useCallback(function (entries) {\n    if (pauseCradleResizeObserverRef.current) return; // console.log('cradle resize entries',entries)\n  }, []); // this sets up an IntersectionObserver of the cradle against the viewport. When the\n  // cradle goes out of the observer scope, the \"repositioning\" cradle state is triggerd.\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current; // IntersectionObserver\n\n    cradleIntersectionObserverRef.current = new IntersectionObserver(cradleintersectionobservercallback, {\n      root: viewportData.elementref.current,\n      threshold: 0\n    });\n    cradleIntersectionObserverRef.current.observe(headCradleElementRef.current);\n    cradleIntersectionObserverRef.current.observe(tailCradleElementRef.current);\n    return function () {\n      cradleIntersectionObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleintersectionobservercallback = react_1.useCallback(function (entries) {\n    if (pauseCradleIntersectionObserverRef.current) return;\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.name == 'head') {\n        isHeadCradleInViewRef.current = entry.isIntersecting;\n      } else {\n        isTailCradleInViewRef.current = entry.isIntersecting;\n      }\n    } // console.log('isHeadCradleInViewRef.current,isTailCradleInViewRef.current',\n    //     isHeadCradleInViewRef.current,isTailCradleInViewRef.current)\n\n\n    isCradleInViewRef.current = isHeadCradleInViewRef.current || isTailCradleInViewRef.current;\n  }, []); // --------------------------[ item shell observer ]-----------------------------\n\n  /*\n      The cradle content is driven by notifications from the IntersectionObserver.\n      - as the user scrolls the cradle, which has a runwaycount at both the leading\n          and trailing edges, itemShells scroll into or out of the scope of the observer\n          (defined by the width/height of the viewport + the lengths of the runways). The observer\n          notifies the app (through itemobservercallback() below) at the crossings of the itemshells\n          of the defined observer cradle boundaries.\n           The no-longer-intersecting notifications trigger dropping of that number of affected items from\n          the cradle contentlist. The dropping of items from the trailing end of the content list\n          triggers the addition of an equal number of items at the leading edge of the cradle content.\n           Technically, the opposite end position spec is set (top or left depending on orientation),\n          and the matching end position spec is set to 'auto' when items are added. This causes items to be\n          \"squeezed\" into the leading or trailing ends of the ui content (out of view) as appropriate.\n           There are exceptions for setup and edge cases.\n  */\n\n  react_1.useEffect(function () {\n    itemObserverRef.current = new IntersectionObserver(itemobservercallback, {\n      root: viewportDataRef.current.elementref.current,\n      threshold: ITEM_OBSERVER_THRESHOLD\n    });\n    return function () {\n      itemObserverRef.current.disconnect();\n    };\n  }, [orientation]); // the async callback from IntersectionObserver.\n\n  var itemobservercallback = react_1.useCallback(function (entries) {\n    if (pauseItemObserverRef.current) {\n      // console.log('returning with pauseItemObserverRef.current',pauseItemObserverRef.current)\n      return;\n    } // console.log('ENTRIES', entries)\n\n\n    isMounted() && adjustcradleentries(entries);\n  }, []); // TODO: investigate case where both forward and backward scroll\n  // adjust scroll content:\n  // 1.shift, 2.clip, and 3.add clip amount at other end\n\n  var adjustcradleentries = react_1.useCallback(function (entries) {\n    var _a, _b;\n\n    var intersections = __spreadArrays(entries);\n\n    var viewportData = viewportDataRef.current;\n\n    var contentlistcopy = __spreadArrays(modelContentRef.current);\n\n    var cradleProps = cradlePropsRef.current;\n    var listsize = cradleProps.listsize;\n    var viewportElement = viewportData.elementref.current;\n    var headcontentlist = headModelContentRef.current;\n    var tailcontentlist = tailModelContentRef.current;\n    var crosscount = crosscountRef.current;\n    var indexoffset = contentlistcopy[0].props.index;\n    var scrollforward; // filter out inapplicable intersection entries\n    // we're only interested in intersections proximal to the spine\n\n    intersections = cradlefunctions_1.isolateRelevantIntersections({\n      intersections: intersections,\n      headcontent: headcontentlist,\n      tailcontent: tailcontentlist,\n      ITEM_OBSERVER_THRESHOLD: ITEM_OBSERVER_THRESHOLD\n    }); // console.log('FILTERED intersections',intersections)\n\n    if (intersections.length == 0) {\n      return;\n    } // -- isolate forward and backward lists (happens with rapid scrolling changes)\n    //  then set scrollforward\n\n\n    var forwardcount = 0,\n        backwardcount = 0;\n\n    for (var intersectrecordindex = 0; intersectrecordindex < intersections.length; intersectrecordindex++) {\n      // let ratio = Math.round(entry.intersectionRatio * 100)/100\n      // intersecting[index] = {\n      //     intersecting:ratio >= ITEM_OBSERVER_THRESHOLD,\n      var sampleEntry = intersections[intersectrecordindex];\n      var ratio = Math.round(sampleEntry.intersectionRatio * 100) / 100; // if (orientation == 'vertical') {\n\n      var isintersecting = ratio >= ITEM_OBSERVER_THRESHOLD; // if (!sampleEntry.isIntersecting) {\n\n      if (!isintersecting) {\n        forwardcount++;\n      } else {\n        backwardcount++;\n      } // } \n\n    } // calculate referenceindex\n\n\n    scrollforward = forwardcount > backwardcount;\n    var shiftitemcount = forwardcount - backwardcount; // console.log('SHIFT ITEM COUNT forwardcount, backwardcount, shiftitemcount',\n    //     forwardcount, backwardcount, shiftitemcount)\n\n    if (shiftitemcount == 0) {\n      return;\n    }\n\n    var referencerowshift = Math.abs(Math.ceil(shiftitemcount / crosscount));\n    var referenceshift;\n    var referenceindex;\n    referenceshift = referencerowshift * crosscount;\n\n    if (scrollforward) {\n      referenceindex = ((_a = tailcontentlist[referenceshift]) === null || _a === void 0 ? void 0 : _a.props.index) || 0; // first time\n    } else {\n      referenceindex = ((_b = headcontentlist[headcontentlist.length - crosscount]) === null || _b === void 0 ? void 0 : _b.props.index) || 0; // 0 = first time\n\n      referenceindex -= referenceshift - crosscount;\n    }\n\n    var entryindexes = [];\n\n    for (var _i = 0, intersections_1 = intersections; _i < intersections_1.length; _i++) {\n      var entry = intersections_1[_i];\n      entryindexes.push(entry.target.dataset.index);\n    }\n\n    if (referenceindex > listsize - 1) {\n      referenceindex = listsize - 1;\n    }\n\n    if (referenceindex < 0) {\n      referenceindex = 0;\n    } // console.log('referenceindex, entryindexes',referenceindex, ...entryindexes)\n    // generate modified content instructions\n\n\n    shiftitemcount = Math.abs(shiftitemcount);\n    var shiftrowcount = Math.ceil(shiftitemcount / crosscount); // set pendingcontentoffset\n\n    var pendingcontentoffset;\n    var addcontentcount = 0; // next, verify number of rows to delete\n\n    var headindexchangecount, currentheadrowcount, viewportrowcount, tailindexchangecount, tailrowcount;\n    currentheadrowcount = Math.ceil(headModelContentRef.current.length / crosscount);\n    var cliprowcount = 0,\n        clipitemcount = 0;\n\n    if (scrollforward) {\n      // delete from head; add to tail; head is direction of stroll\n      if (currentheadrowcount + shiftrowcount > cradleProps.runwaycount) {\n        var rowdiff = currentheadrowcount + shiftrowcount - cradleProps.runwaycount;\n        cliprowcount = rowdiff;\n        clipitemcount = cliprowcount * crosscount;\n      }\n\n      addcontentcount = clipitemcount;\n      pendingcontentoffset = indexoffset + clipitemcount;\n      var proposedtailindex = pendingcontentoffset + contentlistcopy.length - 1;\n\n      if (proposedtailindex > listsize - 1) {\n        var diffitemcount = proposedtailindex - (listsize - 1); // items outside range\n\n        addcontentcount -= diffitemcount; // adjust the addcontent accordingly\n\n        var diffrows = Math.floor(diffitemcount / crosscount); // number of full rows to leave in place\n\n        var diffrowitems = diffrows * crosscount; // derived number of items to leave in place\n\n        clipitemcount -= diffrowitems; // apply adjustment to netshift\n\n        if (addcontentcount <= 0) {\n          // nothing to do\n          clipitemcount = addcontentcount = 0;\n        }\n      }\n\n      headindexchangecount = -clipitemcount;\n      tailindexchangecount = addcontentcount;\n    } else {\n      if (currentheadrowcount - shiftrowcount < cradleProps.runwaycount) {\n        addcontentcount = shiftrowcount * crosscount;\n        var rowdiff = cradleProps.runwaycount - (currentheadrowcount - shiftrowcount);\n        cliprowcount = rowdiff;\n        var tailrowitemcount = listsize % crosscount;\n\n        if (tailrowcount) {\n          clipitemcount = tailrowitemcount;\n\n          if (cliprowcount > 1) {\n            clipitemcount += (cliprowcount - 1) * crosscount;\n          }\n        } else {\n          clipitemcount = cliprowcount * crosscount;\n        }\n      }\n\n      pendingcontentoffset = indexoffset; // add to tail (opposite end of scroll direction), offset will remain the same\n\n      var proposedindexoffset = pendingcontentoffset - clipitemcount;\n\n      if (proposedindexoffset < 0) {\n        var diffitemcount = -proposedindexoffset;\n        var diffrows = Math.floor(diffitemcount / crosscount); // number of full rows to leave in place\n\n        var diffrowitems = diffrows * crosscount;\n        addcontentcount -= diffitemcount;\n        clipitemcount -= diffrowitems;\n\n        if (addcontentcount <= 0) {\n          clipitemcount = addcontentcount = 0;\n        }\n      }\n\n      headindexchangecount = addcontentcount;\n      tailindexchangecount = -clipitemcount;\n    } // collect modified content\n\n\n    var localContentList; // console.log('SHIFT headindexchangecount,tailindexchangecount',headindexchangecount,tailindexchangecount)\n\n    if (headindexchangecount || tailindexchangecount) {\n      localContentList = cradlefunctions_1.getUIContentList({\n        localContentList: contentlistcopy,\n        headindexcount: headindexchangecount,\n        tailindexcount: tailindexchangecount,\n        indexoffset: indexoffset,\n        orientation: cradleProps.orientation,\n        cellHeight: cradleProps.cellHeight,\n        cellWidth: cradleProps.cellWidth,\n        observer: itemObserverRef.current,\n        crosscount: crosscount,\n        callbacks: callbacksRef.current,\n        getItem: cradleProps.getItem,\n        listsize: listsize,\n        placeholder: cradleProps.placeholder\n      });\n    } else {\n      localContentList = contentlistcopy;\n    } // headModelContentRef.current = localContentList\n\n\n    var _c = cradlefunctions_1.allocateContentList({\n      contentlist: localContentList,\n      runwaycount: cradleProps.runwaycount,\n      crosscount: crosscount,\n      referenceindex: referenceindex\n    }),\n        headcontent = _c[0],\n        tailcontent = _c[1];\n\n    modelContentRef.current = localContentList;\n    headViewContentRef.current = headModelContentRef.current = headcontent;\n    tailViewContentRef.current = tailModelContentRef.current = tailcontent; // place the spine in the scrollblock\n\n    var spineposref = cradlefunctions_1.getSpinePosRef({\n      scrollforward: scrollforward,\n      itemelements: itemElementsRef.current,\n      orientation: cradleProps.orientation,\n      spineElement: spineCradleElementRef.current,\n      referenceindex: referenceindex,\n      crosscount: crosscount,\n      gap: cradleProps.gap,\n      referenceshift: referenceshift\n    });\n\n    if (spineposref !== undefined) {\n      if (cradleProps.orientation == 'vertical') {\n        spineCradleElementRef.current.style.top = spineposref + 'px';\n        spineCradleElementRef.current.style.left = 'auto';\n      } else {\n        spineCradleElementRef.current.style.left = spineposref + 'px';\n        spineCradleElementRef.current.style.top = 'auto';\n      }\n    }\n\n    saveCradleState('updatescroll');\n  }, []); // End of IntersectionObserver support\n  // ========================================================================================\n  // -------------------------------[ Assembly of content]-----------------------------------\n  // ========================================================================================\n  // reset cradle, including allocation between head and tail parts of the cradle\n\n  var setCradleContent = react_1.useCallback(function (cradleState, referenceIndexData) {\n    var visibletargetindexoffset = referenceIndexData.index,\n        visibletargetscrolloffset = referenceIndexData.scrolloffset;\n    if (cradleState == 'reposition') visibletargetscrolloffset = 0;\n    var localContentList = []; // any duplicated items will be re-used by react\n\n    var _a = cradlefunctions_1.getContentListRequirements({\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      orientation: orientation,\n      runwaycount: runwaycount,\n      rowcount: cradlerowcount,\n      gap: gap,\n      visibletargetindexoffset: visibletargetindexoffset,\n      targetScrollOffset: visibletargetscrolloffset,\n      crosscount: crosscount,\n      listsize: listsize\n    }),\n        indexoffset = _a.indexoffset,\n        referenceoffset = _a.referenceoffset,\n        contentCount = _a.contentCount,\n        scrollblockoffset = _a.scrollblockoffset,\n        cradleoffset = _a.cradleoffset;\n\n    immediateReferenceIndexDataRef.current = {\n      index: referenceoffset,\n      scrolloffset: visibletargetscrolloffset\n    };\n\n    if (referenceIndexCallbackRef.current) {\n      var cstate = cradleState;\n      if (cstate == 'setreload') cstate = 'reload';\n      referenceIndexCallbackRef.current(immediateReferenceIndexDataRef.current.index, 'setCradleContent', cstate);\n    }\n\n    saveImmediateReferenceIndexData(immediateReferenceIndexDataRef.current); // consistent with onScroll\n\n    var childlist = cradlefunctions_1.getUIContentList({\n      indexoffset: indexoffset,\n      headindexcount: 0,\n      tailindexcount: contentCount,\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      localContentList: localContentList,\n      observer: itemObserverRef.current,\n      crosscount: crosscount,\n      callbacks: callbacksRef.current,\n      getItem: getItem,\n      listsize: listsize,\n      placeholder: placeholder\n    });\n\n    var _b = cradlefunctions_1.allocateContentList({\n      contentlist: childlist,\n      runwaycount: cradlePropsRef.current.runwaycount,\n      crosscount: crosscount,\n      referenceindex: 0\n    }),\n        headcontentlist = _b[0],\n        tailcontentlist = _b[1];\n\n    modelContentRef.current = childlist;\n    headModelContentRef.current = headcontentlist;\n    tailModelContentRef.current = tailcontentlist;\n\n    if (orientation == 'vertical') {\n      scrollPositionDataRef.current = {\n        property: 'scrollTop',\n        value: scrollblockoffset\n      };\n    } else {\n      // orientation = 'horizontal'\n      scrollPositionDataRef.current = {\n        property: 'scrollLeft',\n        value: scrollblockoffset\n      };\n    }\n  }, [getItem, listsize, placeholder, cellHeight, cellWidth, orientation, viewportheight, viewportwidth, runwaylength, runwaycount, gap, padding, crosscount, cradlerowcount]); // =====================================================================================\n  // ----------------------------------[ state management ]-------------------------------\n  // =====================================================================================\n\n  var scrollTimeridRef = react_1.useRef(null); // callback for scroll\n\n  var onScroll = react_1.useCallback(function () {\n    // console.log('onScroll scrollTop',viewportDataRef.current.elementref.current.scrollTop)\n    clearTimeout(scrollTimeridRef.current);\n\n    if (pauseScrollingEffectsRef.current) {\n      console.log('returning with pauseScrollingEffect', pauseScrollingEffectsRef.current);\n      return;\n    }\n\n    var cradleState = cradlestateRef.current;\n\n    if (!viewportDataRef.current.isResizing) {\n      if (cradleState == 'ready' || cradleState == 'repositioning') {\n        immediateReferenceIndexDataRef.current = cradlefunctions_1.getReferenceIndexData({\n          viewportData: viewportDataRef.current,\n          cradlePropsRef: cradlePropsRef,\n          crosscountRef: crosscountRef\n        });\n        referenceIndexCallbackRef.current && referenceIndexCallbackRef.current(immediateReferenceIndexDataRef.current.index, 'scrolling', cradleState);\n        saveImmediateReferenceIndexData(immediateReferenceIndexDataRef.current);\n      }\n    }\n\n    if (!isCradleInViewRef.current && !pauseItemObserverRef.current && !viewportDataRef.current.isResizing && !(cradleState == 'resize') && !(cradleState == 'repositioning') && !(cradleState == 'reposition')) {\n      var rect = viewportDataRef.current.elementref.current.getBoundingClientRect();\n      var top_1 = rect.top,\n          right = rect.right,\n          bottom = rect.bottom,\n          left = rect.left;\n      var width = right - left,\n          height = bottom - top_1;\n      viewportDataRef.current.viewportDimensions = {\n        top: top_1,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      }; // update for scrolltracker\n\n      console.log('REPOSITIONING');\n      saveCradleState('repositioning');\n    }\n\n    scrollTimeridRef.current = setTimeout(function () {\n      // isScrollingRef.current = false;\n      var cradleState = cradlestateRef.current;\n\n      if (!viewportDataRef.current.isResizing) {\n        // (cradleState != 'repositioning') && \n        //     normalizeCradleAnchors(headCradleElementRef.current, cradlePropsRef.current.orientation)\n        var localrefdata = __assign({}, immediateReferenceIndexDataRef.current);\n\n        saveImmediateReferenceIndexData(localrefdata); // trigger re-run to capture end of scroll session values\n\n        masterReferenceIndexDataRef.current = localrefdata;\n      }\n\n      switch (cradleState) {\n        case 'repositioning':\n          {\n            callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n            pauseItemObserverRef.current = true;\n            saveCradleState('reposition');\n            break;\n          }\n      }\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n  }, []); // data for state processing\n\n  var callingCradleState = react_1.useRef(cradlestateRef.current);\n  var headlayoutDataRef = react_1.useRef(null);\n  var scrollPositionDataRef = react_1.useRef(null); // this is the core state engine\n  // useLayout for suppressing flashes\n\n  react_1.useLayoutEffect(function () {\n    var viewportData = viewportDataRef.current;\n\n    switch (cradlestate) {\n      case 'reload':\n        headModelContentRef.current = [];\n        tailModelContentRef.current = [];\n        saveCradleState('setreload');\n        break;\n\n      case 'scrollposition':\n        {\n          viewportData.elementref.current[scrollPositionDataRef.current.property] = scrollPositionDataRef.current.value;\n          saveCradleState('content');\n          break;\n        }\n\n      case 'updatescroll':\n        {\n          // scroll\n          saveCradleState('ready');\n          break;\n        }\n\n      case 'content':\n        {\n          headViewContentRef.current = headModelContentRef.current; // contentDataRef.current\n\n          tailViewContentRef.current = tailModelContentRef.current;\n          saveCradleState('normalize');\n          break;\n        }\n    }\n  }, [cradlestate]); // standard processing stages\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n\n    switch (cradlestate) {\n      case 'setup':\n      case 'resize':\n      case 'pivot':\n      case 'setreload':\n      case 'reposition':\n        callingCradleState.current = cradlestate;\n        saveCradleState('settle');\n        break;\n\n      case 'settle':\n        {\n          setCradleContent(callingCradleState.current, callingReferenceIndexDataRef.current);\n          saveCradleState('scrollposition');\n          break;\n        }\n\n      case 'normalize':\n        {\n          setTimeout(function () {\n            // redundant scroll position to avoid accidental positioning at tail end of reposition\n            if (viewportData.elementref.current) {\n              // already unmounted if fails\n              viewportData.elementref.current[scrollPositionDataRef.current.property] = scrollPositionDataRef.current.value; // pick up position from setContent\n\n              masterReferenceIndexDataRef.current = __assign({}, immediateReferenceIndexDataRef.current);\n              pauseItemObserverRef.current && (pauseItemObserverRef.current = false);\n              pauseCradleIntersectionObserverRef.current && (pauseCradleIntersectionObserverRef.current = false);\n              pauseScrollingEffectsRef.current && (pauseScrollingEffectsRef.current = false);\n            }\n          }, 100);\n          saveCradleState('ready');\n          break;\n        }\n\n      case 'ready':\n        break;\n    }\n  }, [cradlestate]); // =============================================================================\n  // ------------------------------[ callbacks ]----------------------------------\n  // =============================================================================\n  // on host demand\n\n  var getVisibleList = react_1.useCallback(function () {\n    var itemlist = Array.from(itemElementsRef.current);\n    return cradlefunctions_1.calcVisibleItems(itemlist, viewportDataRef.current.elementref.current, headCradleElementRef.current, cradlePropsRef.current.orientation);\n  }, []);\n  var getContentList = react_1.useCallback(function () {\n    return Array.from(itemElementsRef.current);\n  }, []);\n  var reload = react_1.useCallback(function () {\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    pauseScrollingEffectsRef.current = true;\n    callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n    saveCradleState('reload');\n  }, []);\n  var scrollToItem = react_1.useCallback(function (index) {\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    callingReferenceIndexDataRef.current = {\n      index: index,\n      scrolloffset: 0\n    };\n    saveCradleState('reposition');\n  }, []); // content item registration callback; called from item\n\n  var getItemElementData = react_1.useCallback(function (itemElementData, reportType) {\n    var index = itemElementData[0],\n        shellref = itemElementData[1];\n\n    if (reportType == 'register') {\n      itemElementsRef.current.set(index, shellref);\n    } else if (reportType == 'unregister') {\n      // console.log('UNREGISTERING',index)\n      itemElementsRef.current[\"delete\"](index);\n    }\n  }, []);\n  var callbacksRef = react_1.useRef({\n    getElementData: getItemElementData\n  }); // =============================================================================\n  // ------------------------------[ RENDER... ]----------------------------------\n  // =============================================================================\n  // let cradleHeadStyle = cradleHeadStyleRef.current\n  // let cradleTailStyle = cradleTailStyleRef.current\n  // let cradleSpineStyle = cradleSpineStyleRef.current\n\n  var scrollTrackerArgs = react_1.useMemo(function () {\n    return {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      offset: immediateReferenceIndexDataRef.current.index,\n      listsize: cradlePropsRef.current.listsize,\n      styles: cradlePropsRef.current.styles\n    };\n  }, [viewportDimensions, immediateReferenceIndexDataRef, cradlePropsRef]);\n  return react_1[\"default\"].createElement(react_1[\"default\"].Fragment, null, cradlestateRef.current == 'repositioning' ? react_1[\"default\"].createElement(scrolltracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.offset,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    style: cradleSpineStyle,\n    ref: spineCradleElementRef,\n    \"data-name\": 'spine'\n  }, react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradlestateRef.current != 'setup' ? headViewContentRef.current : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradlestateRef.current != 'setup' ? tailViewContentRef.current : null)));\n}; // Cradle\n\n\nexports[\"default\"] = Cradle;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGUudHN4PzE4M2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQ7QUFFQSxJQUFNLHVCQUF1QixHQUFHLEVBQWhDOztBQUVBOztBQWFBOztBQUVBLElBQU0sZ0NBQWdDLEdBQUcsR0FBekM7O0FBRUEsSUFBTSxNQUFNLEdBQUcsU0FBVCxNQUFTLENBQUMsRUFBRCxFQWNWO01BYkcsWTtNQUNBLG9CO01BQ0EsOEI7TUFDQSw0QjtNQUNBLHNCO01BQ0Esa0I7TUFDQSw0QjtNQUNBLDBCO01BQ0Esd0I7TUFDQSxvQjtNQUNBLDRCO01BQ0Esd0I7TUFDQSxrQixDQUNILENBRUQ7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsZUFBTyxJQUFQLENBQXZCLENBSEMsQ0FHbUM7O0FBQ3BDLGdCQUFjLENBQUMsT0FBZixHQUF5QixnQkFBUTtBQUM3QixXQUFPO0FBQ0gsU0FBRyxLQURBO0FBRUgsYUFBTyxTQUZKO0FBR0gsa0JBQVksY0FIVDtBQUlILGlCQUFXLGFBSlI7QUFLSCxjQUFRLFVBTEw7QUFNSCxZQUFNLFFBTkg7QUFPSCxpQkFBVyxhQVBSO0FBUUgsZ0JBQVUsWUFSUDtBQVNILGVBQVMsV0FUTjtBQVVILGFBQU8sU0FWSjtBQVdILGlCQUFXO0FBWFIsS0FBUDtBQVlGLEdBYnVCLEVBYXRCLENBQ0MsR0FERCxFQUVDLE9BRkQsRUFHQyxZQUhELEVBSUMsV0FKRCxFQUtDLFFBTEQsRUFNQyxNQU5ELEVBT0MsV0FQRCxFQVFDLFVBUkQsRUFTQyxTQVRELEVBVUMsT0FWRCxFQVdDLFdBWEQsQ0Fic0IsQ0FBekIsQ0FKQyxDQStCRDtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBLE1BQU0sU0FBUyxHQUFHLG9DQUFsQjtBQUNBLE1BQU0seUJBQXlCLEdBQUcsZUFBTyxTQUFTLFNBQVQsYUFBUyxXQUFULEdBQVMsTUFBVCxZQUFTLENBQUUsc0JBQWxCLENBQWxDO0FBRUEsTUFBTSxlQUFlLEdBQUcsZUFBTyxJQUFQLENBQXhCLENBekNDLENBeUNvQzs7QUFDckMsTUFBTSw2QkFBNkIsR0FBRyxlQUFPLElBQVAsQ0FBdEM7QUFDQSxNQUFNLHVCQUF1QixHQUFHLGVBQU8sSUFBUCxDQUFoQyxDQTNDQyxDQTZDRDtBQUNBOztBQUVBLE1BQU0sWUFBWSxHQUFHLG1CQUFXLDBCQUFYLENBQXJCO0FBQ0EsTUFBTSxlQUFlLEdBQUcsZUFBTyxJQUFQLENBQXhCO0FBQ0EsaUJBQWUsQ0FBQyxPQUFoQixHQUEwQixZQUExQjs7QUFFTTtBQUFBLE1BQUMsbUJBQUQ7QUFBQSxNQUFjLHVCQUFkOztBQUNOLE1BQU0sY0FBYyxHQUFHLGVBQU8sSUFBUCxDQUF2QixDQXJEQyxDQXFEbUM7O0FBQ3BDLGdCQUFjLENBQUMsT0FBZixHQUF5QixXQUF6QixDQXREQyxDQXdERDtBQUVBO0FBQ0E7O0FBRUEsTUFBTSxvQkFBb0IsR0FBRyxlQUFPLEtBQVAsQ0FBN0I7QUFDQSxNQUFNLGtDQUFrQyxHQUFHLGVBQU8sS0FBUCxDQUEzQztBQUNBLE1BQU0sNEJBQTRCLEdBQUcsZUFBTyxLQUFQLENBQXJDO0FBQ0EsTUFBTSx3QkFBd0IsR0FBRyxlQUFPLEtBQVAsQ0FBakMsQ0FoRUMsQ0FrRUQ7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxlQUFPLElBQVAsQ0FBOUI7QUFDQSxNQUFNLHFCQUFxQixHQUFHLGVBQU8sSUFBUCxDQUE5QjtBQUNBLE1BQU0saUJBQWlCLEdBQUcsZUFBTyxJQUFQLENBQTFCLENBckVDLENBdUVEO0FBQ0E7QUFFQTs7QUFDQSxvQkFBVTtBQUVOLFFBQUksU0FBUyxTQUFULGFBQVMsV0FBVCxHQUFTLE1BQVQsWUFBUyxDQUFFLGNBQVgsQ0FBMEIsY0FBMUIsQ0FBSixFQUErQztBQUMzQyxlQUFTLENBQUMsWUFBVixHQUF5QixZQUF6QjtBQUNIOztBQUVELFFBQUksU0FBUyxTQUFULGFBQVMsV0FBVCxHQUFTLE1BQVQsWUFBUyxDQUFFLGNBQVgsQ0FBMEIsZ0JBQTFCLENBQUosRUFBaUQ7QUFDN0MsZUFBUyxDQUFDLGNBQVYsR0FBMkIsY0FBM0I7QUFDSDs7QUFFRCxRQUFJLFNBQVMsU0FBVCxhQUFTLFdBQVQsR0FBUyxNQUFULFlBQVMsQ0FBRSxjQUFYLENBQTBCLGdCQUExQixDQUFKLEVBQWlEO0FBQzdDLGVBQVMsQ0FBQyxjQUFWLEdBQTJCLGNBQTNCO0FBQ0g7O0FBRUQsUUFBSSxTQUFTLFNBQVQsYUFBUyxXQUFULEdBQVMsTUFBVCxZQUFTLENBQUUsY0FBWCxDQUEwQixRQUExQixDQUFKLEVBQXlDO0FBQ3JDLGVBQVMsQ0FBQyxNQUFWLEdBQW1CLE1BQW5CO0FBQ0g7O0FBRUQsNkJBQXlCLENBQUMsT0FBMUIsR0FBb0MsU0FBUyxTQUFULGFBQVMsV0FBVCxHQUFTLE1BQVQsWUFBUyxDQUFFLHNCQUEvQztBQUVILEdBcEJELEVBb0JFLENBQUMsU0FBRCxDQXBCRixFQTNFQyxDQWlHRDs7QUFDQSxvQkFBVTtBQUNOLFFBQUksWUFBWSxHQUFHLGVBQWUsQ0FBQyxPQUFuQztBQUNBLGdCQUFZLENBQUMsVUFBYixDQUF3QixPQUF4QixDQUFnQyxnQkFBaEMsQ0FBaUQsUUFBakQsRUFBMEQsUUFBMUQ7QUFFQSxXQUFPO0FBRUgsa0JBQVksQ0FBQyxVQUFiLENBQXdCLE9BQXhCLElBQW1DLFlBQVksQ0FBQyxVQUFiLENBQXdCLE9BQXhCLENBQWdDLG1CQUFoQyxDQUFvRCxRQUFwRCxFQUE2RCxRQUE3RCxDQUFuQztBQUVILEtBSkQ7QUFNSCxHQVZELEVBVUUsRUFWRixFQWxHQyxDQThHRDtBQUNBO0FBRUE7O0FBQ0Esb0JBQVU7QUFFTixRQUFJLFlBQVksQ0FBQyxVQUFqQixFQUE2QjtBQUV6QjtBQUNBLGtDQUE0QixDQUFDLE9BQTdCLEdBQW9DLGFBQU8sMkJBQTJCLENBQUMsT0FBbkMsQ0FBcEM7QUFFQSwwQkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUEvQjtBQUNBLHdDQUFrQyxDQUFDLE9BQW5DLEdBQTZDLElBQTdDO0FBQ0EsOEJBQXdCLENBQUMsT0FBekIsR0FBbUMsSUFBbkM7QUFDQSxxQkFBZSxDQUFDLFVBQUQsQ0FBZjtBQUVILEtBWkssQ0FjTjs7O0FBQ0EsUUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFkLElBQTZCLGNBQWMsQ0FBQyxPQUFmLElBQTBCLFVBQTNELEVBQXdFO0FBRXBFLHFCQUFlLENBQUMsUUFBRCxDQUFmO0FBRUg7QUFFSixHQXJCRCxFQXFCRSxDQUFDLFlBQVksQ0FBQyxVQUFkLENBckJGLEVBbEhDLENBeUlEOztBQUNBLG9CQUFVO0FBRU4sUUFBSSxjQUFjLENBQUMsT0FBZixJQUEwQixPQUE5QixFQUF1QztBQUV2QyxnQ0FBNEIsQ0FBQyxPQUE3QixHQUFvQyxhQUFPLDJCQUEyQixDQUFDLE9BQW5DLENBQXBDO0FBRUEsd0JBQW9CLENBQUMsT0FBckIsR0FBK0IsSUFBL0I7QUFDQSxzQ0FBa0MsQ0FBQyxPQUFuQyxHQUE2QyxJQUE3QztBQUNBLDRCQUF3QixDQUFDLE9BQXpCLEdBQW1DLElBQW5DO0FBRUEsbUJBQWUsQ0FBQyxRQUFELENBQWY7QUFFSCxHQVpELEVBWUUsQ0FDRSxRQURGLEVBRUUsVUFGRixFQUdFLFNBSEYsRUFJRSxHQUpGLEVBS0UsT0FMRixDQVpGLEVBMUlDLENBOEpEOztBQUNBLG9CQUFVO0FBRU4sdUJBQW1CLENBQUMsT0FBcEIsR0FBOEIsRUFBOUI7QUFDQSx1QkFBbUIsQ0FBQyxPQUFwQixHQUE4QixFQUE5Qjs7QUFFQSxRQUFJLGNBQWMsQ0FBQyxPQUFmLElBQTBCLE9BQTlCLEVBQXVDO0FBRW5DLGtDQUE0QixDQUFDLE9BQTdCLEdBQW9DLGFBQU8sMkJBQTJCLENBQUMsT0FBbkMsQ0FBcEM7QUFFQSwwQkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUEvQjtBQUNBLHdDQUFrQyxDQUFDLE9BQW5DLEdBQTZDLElBQTdDO0FBQ0EsOEJBQXdCLENBQUMsT0FBekIsR0FBbUMsSUFBbkM7QUFFQSxxQkFBZSxDQUFDLE9BQUQsQ0FBZjtBQUVIO0FBRUosR0FqQkQsRUFpQkUsQ0FDRSxXQURGLENBakJGLEVBL0pDLENBb0xEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFTTs4Q0FBQTs7QUFBQTtBQUFBLE1BQUMsbUNBQUQ7QUFBQSxNQUE4Qix1Q0FBOUI7O0FBSU4sTUFBTSw4QkFBOEIsR0FBRyxlQUFPLElBQVAsQ0FBdkMsQ0FqTUMsQ0FpTW1EOztBQUNwRCxnQ0FBOEIsQ0FBQyxPQUEvQixHQUF5QywyQkFBekM7QUFDQSxNQUFNLDJCQUEyQixHQUFHLGVBQU8sMkJBQVAsQ0FBcEMsQ0FuTUMsQ0FtTXVFOztBQUN4RSxNQUFNLDRCQUE0QixHQUFHLGVBQU8sMkJBQVAsQ0FBckMsQ0FwTUMsQ0FvTXdFO0FBRXpFO0FBRUE7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxlQUFPLElBQVAsQ0FBN0I7QUFDQSxNQUFNLG9CQUFvQixHQUFHLGVBQU8sSUFBUCxDQUE3QjtBQUNBLE1BQU0scUJBQXFCLEdBQUcsZUFBTyxJQUFQLENBQTlCLENBM01DLENBNk1EOztBQUNBLE1BQU0sZUFBZSxHQUFHLGVBQU8sSUFBUCxDQUF4QjtBQUNBLE1BQU0sbUJBQW1CLEdBQUcsZUFBTyxJQUFQLENBQTVCO0FBQ0EsTUFBTSxtQkFBbUIsR0FBRyxlQUFPLElBQVAsQ0FBNUIsQ0FoTkMsQ0FrTkQ7O0FBQ0EsTUFBTSxrQkFBa0IsR0FBRyxlQUFPLEVBQVAsQ0FBM0I7QUFDQSxNQUFNLGtCQUFrQixHQUFHLGVBQU8sRUFBUCxDQUEzQjtBQUVBLE1BQU0sZUFBZSxHQUFHLGVBQU8sSUFBSSxHQUFKLEVBQVAsQ0FBeEIsQ0F0TkMsQ0FzTnlDO0FBRTFDO0FBRUE7O0FBRVE7QUFFRjtBQUFBLE1BQXNCLHdDQUF0QjtBQUVOLE1BQU0sVUFBVSxHQUFHLGdCQUFRO0FBRXZCLFFBQUksVUFBSjtBQUNBLFFBQUksSUFBSSxHQUFJLFdBQVcsSUFBSSxZQUFoQixHQUE4QixjQUE5QixHQUE2QyxhQUF4RDtBQUNBLFFBQUksV0FBVyxHQUFJLFdBQVcsSUFBSSxZQUFoQixHQUE4QixVQUE5QixHQUF5QyxTQUEzRDtBQUVBLFFBQUksYUFBYSxHQUFHLElBQUksR0FBSSxPQUFPLEdBQUcsQ0FBbEIsR0FBdUIsR0FBM0MsQ0FOdUIsQ0FNd0I7O0FBQy9DLFFBQUksaUJBQWlCLEdBQUcsV0FBVyxHQUFHLEdBQXRDO0FBQ0EscUJBQWlCLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxpQkFBVCxFQUEyQixhQUEzQixDQUFwQixDQVJ1QixDQVF1Qzs7QUFDOUQsY0FBVSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsYUFBYSxHQUFFLGlCQUExQixDQUFiO0FBQ0EsV0FBTyxVQUFQO0FBRUgsR0Faa0IsRUFZakIsQ0FDRSxXQURGLEVBRUUsU0FGRixFQUdFLFVBSEYsRUFJRSxHQUpGLEVBS0UsT0FMRixFQU1FLGNBTkYsRUFPRSxhQVBGLENBWmlCLENBQW5CO0FBc0JBLE1BQU0sYUFBYSxHQUFHLGVBQU8sVUFBUCxDQUF0QixDQXRQQyxDQXNQd0M7O0FBQ3pDLGVBQWEsQ0FBQyxPQUFkLEdBQXdCLFVBQXhCLENBdlBDLENBdVBrQzs7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FBQSxFO3lEQUFBO0FBQUEsTUFBQyxzQkFBRDtBQUFBLE1BQWdCLHdCQUFoQjs7QUFtQ04sTUFBTSxpQkFBaUIsR0FBRyxlQUFPLElBQVAsQ0FBMUI7QUFDQSxtQkFBaUIsQ0FBQyxPQUFsQixHQUE0QixjQUE1QjtBQUNBLE1BQU0sbUJBQW1CLEdBQUcsZUFBTyxJQUFQLENBQTVCO0FBQ0EscUJBQW1CLENBQUMsT0FBcEIsR0FBOEIsZ0JBQTlCLENBL1JDLENBaVNEOztBQUNBLE1BQUksZUFBZSxHQUFHLGdCQUFRO0FBRTFCLFFBQUksTUFBSixFQUFZLElBQVosRUFBa0IsR0FBbEIsRUFBdUIsS0FBdkI7O0FBRUEsUUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFDM0IsWUFBTSxHQUFHLEdBQUcsR0FBRyxJQUFmO0FBQ0EsVUFBSSxHQUFHLENBQVA7QUFDQSxXQUFLLEdBQUcsQ0FBUjtBQUNBLFNBQUcsR0FBRyxNQUFOO0FBQ0gsS0FMRCxNQUtPO0FBQ0gsWUFBTSxHQUFHLENBQVQ7QUFDQSxVQUFJLEdBQUcsTUFBUDtBQUNBLFdBQUssR0FBRyxHQUFHLEdBQUcsSUFBZDtBQUNBLFNBQUcsR0FBRyxDQUFOO0FBQ0g7O0FBRUQsaUNBQVc7QUFFUCxjQUFRLEVBQUUsVUFGSDtBQUdQLHFCQUFlLEVBQUUsTUFIVjtBQUlQLGFBQU8sRUFBRSxNQUpGO0FBS1AsYUFBTyxFQUFFLEdBQUcsR0FBRyxJQUxSO0FBTVAsYUFBTyxFQUFFLE9BQU8sR0FBRyxJQU5aO0FBT1Asb0JBQWMsRUFBQyxPQVBSO0FBUVAsa0JBQVksRUFBQyxPQVJOO0FBU1AsZUFBUyxFQUFDLFlBVEg7QUFVUCxZQUFNLFFBVkM7QUFXUCxVQUFJLE1BWEc7QUFZUCxXQUFLLE9BWkU7QUFhUCxTQUFHO0FBYkksS0FBWCxHQWU0QixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsTUFmcEM7QUFpQkgsR0FqQ3FCLEVBaUNwQixDQUNFLEdBREYsRUFFRSxPQUZGLEVBR0UsTUFIRixFQUlFLFdBSkYsQ0FqQ29CLENBQXRCO0FBd0NBLE1BQUksZUFBZSxHQUFHLGdCQUFRO0FBRTFCLFFBQUksTUFBSixFQUFZLElBQVosRUFBa0IsR0FBbEIsRUFBdUIsS0FBdkI7O0FBRUEsUUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFDM0IsWUFBTSxHQUFHLE1BQVQ7QUFDQSxVQUFJLEdBQUcsQ0FBUDtBQUNBLFdBQUssR0FBRyxDQUFSO0FBQ0EsU0FBRyxHQUFHLENBQU47QUFDSCxLQUxELE1BS087QUFDSCxZQUFNLEdBQUcsQ0FBVDtBQUNBLFVBQUksR0FBRyxDQUFQO0FBQ0EsV0FBSyxHQUFHLE9BQVI7QUFDQSxTQUFHLEdBQUcsQ0FBTjtBQUNIOztBQUVELGlDQUFXO0FBRVAsY0FBUSxFQUFFLFVBRkg7QUFHUCxxQkFBZSxFQUFFLE1BSFY7QUFJUCxhQUFPLEVBQUUsTUFKRjtBQUtQLGFBQU8sRUFBRSxHQUFHLEdBQUcsSUFMUjtBQU1QLGFBQU8sRUFBRSxPQUFPLEdBQUcsSUFOWjtBQU9QLG9CQUFjLEVBQUMsT0FQUjtBQVFQLGtCQUFZLEVBQUMsT0FSTjtBQVNQLGVBQVMsRUFBQyxZQVRIO0FBVVAsU0FBRyxLQVZJO0FBV1AsVUFBSSxNQVhHO0FBWVAsV0FBSyxPQVpFO0FBYVAsWUFBTTtBQWJDLEtBQVgsR0FlNEIsTUFBTSxTQUFOLFVBQU0sV0FBTixHQUFNLE1BQU4sU0FBTSxDQUFFLE1BZnBDO0FBaUJILEdBakNxQixFQWlDcEIsQ0FDRSxHQURGLEVBRUUsT0FGRixFQUdFLE1BSEYsRUFJRSxXQUpGLENBakNvQixDQUF0QjtBQXdDQSxNQUFJLGdCQUFnQixHQUFHLGdCQUFRO0FBRTNCLFFBQUksUUFBSixFQUFjLFFBQWQsRUFBd0IsR0FBeEIsRUFBNkIsSUFBN0I7O0FBQ0EsUUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFFM0IsY0FBUSxHQUFHLENBQVg7QUFDQSxjQUFRLEdBQUcsT0FBWDtBQUNBLFNBQUcsR0FBRyxPQUFPLEdBQUcsSUFBaEIsRUFDQSxJQUFJLEdBQUcsTUFEUDtBQUdILEtBUEQsTUFPTztBQUVILGNBQVEsR0FBRyxPQUFYO0FBQ0EsY0FBUSxHQUFHLENBQVg7QUFDQSxVQUFJLEdBQUcsT0FBTyxHQUFHLElBQWpCO0FBQ0EsU0FBRyxHQUFHLE1BQU47QUFFSDs7QUFFRCxXQUFPO0FBRUgsY0FBUSxFQUFFLFVBRlA7QUFHSCxTQUFHLEtBSEE7QUFJSCxVQUFJO0FBSkQsS0FBUDtBQVNILEdBNUJzQixFQTRCckIsQ0FFRSxPQUZGLEVBR0UsV0FIRixDQTVCcUIsQ0FBdkIsQ0FsWEMsQ0FxWkQ7O0FBQ007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FBQSxFLGlKQUFBO0FBQUEsTUFBQyxpQkFBRDtBQUFBLE1BQVksaUJBQVo7QUFBQSxNQUF1QixrQkFBdkI7O0FBdUROLGlCQUFlLEdBQUcsU0FBbEI7QUFDQSxpQkFBZSxHQUFHLFNBQWxCO0FBQ0Esa0JBQWdCLEdBQUcsVUFBbkIsQ0EvY0MsQ0FpZEQ7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFPQTtBQUVBOztBQUNBLG9CQUFVO0FBRU47QUFDQSwyQkFBdUIsQ0FBQyxPQUF4QixHQUFrQyxJQUFJLG1CQUFKLENBQXdCLDRCQUF4QixDQUFsQztBQUVBLDJCQUF1QixDQUFDLE9BQXhCLENBQWdDLE9BQWhDLENBQXdDLG9CQUFvQixDQUFDLE9BQTdEO0FBQ0EsMkJBQXVCLENBQUMsT0FBeEIsQ0FBZ0MsT0FBaEMsQ0FBd0Msb0JBQW9CLENBQUMsT0FBN0Q7QUFFQSxXQUFPO0FBRUgsNkJBQXVCLENBQUMsT0FBeEIsQ0FBZ0MsVUFBaEM7QUFFSCxLQUpEO0FBTUgsR0FkRCxFQWNFLEVBZEY7QUFnQkEsTUFBTSw0QkFBNEIsR0FBRyxvQkFBWSxVQUFDLE9BQUQsRUFBUTtBQUVyRCxRQUFJLDRCQUE0QixDQUFDLE9BQWpDLEVBQTBDLE9BRlcsQ0FJckQ7QUFFSCxHQU5vQyxFQU1uQyxFQU5tQyxDQUFyQyxDQS9lQyxDQXVmRDtBQUNBOztBQUNBLG9CQUFVO0FBRU4sUUFBSSxZQUFZLEdBQUcsZUFBZSxDQUFDLE9BQW5DLENBRk0sQ0FHTjs7QUFDQSxpQ0FBNkIsQ0FBQyxPQUE5QixHQUF3QyxJQUFJLG9CQUFKLENBRXBDLGtDQUZvQyxFQUdwQztBQUFDLFVBQUksRUFBQyxZQUFZLENBQUMsVUFBYixDQUF3QixPQUE5QjtBQUF1QyxlQUFTLEVBQUM7QUFBakQsS0FIb0MsQ0FBeEM7QUFPQSxpQ0FBNkIsQ0FBQyxPQUE5QixDQUFzQyxPQUF0QyxDQUE4QyxvQkFBb0IsQ0FBQyxPQUFuRTtBQUNBLGlDQUE2QixDQUFDLE9BQTlCLENBQXNDLE9BQXRDLENBQThDLG9CQUFvQixDQUFDLE9BQW5FO0FBRUEsV0FBTztBQUVILG1DQUE2QixDQUFDLE9BQTlCLENBQXNDLFVBQXRDO0FBRUgsS0FKRDtBQU1ILEdBcEJELEVBb0JFLEVBcEJGO0FBc0JBLE1BQU0sa0NBQWtDLEdBQUcsb0JBQVksVUFBQyxPQUFELEVBQVE7QUFFM0QsUUFBSSxrQ0FBa0MsQ0FBQyxPQUF2QyxFQUFnRDs7QUFFaEQsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBNUIsRUFBb0MsQ0FBQyxFQUFyQyxFQUEwQztBQUN0QyxVQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBRCxDQUFuQjs7QUFDQSxVQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsT0FBYixDQUFxQixJQUFyQixJQUE2QixNQUFqQyxFQUF5QztBQUNyQyw2QkFBcUIsQ0FBQyxPQUF0QixHQUFnQyxLQUFLLENBQUMsY0FBdEM7QUFDSCxPQUZELE1BRU87QUFDSCw2QkFBcUIsQ0FBQyxPQUF0QixHQUFnQyxLQUFLLENBQUMsY0FBdEM7QUFDSDtBQUNKLEtBWDBELENBWTNEO0FBQ0E7OztBQUNBLHFCQUFpQixDQUFDLE9BQWxCLEdBQTZCLHFCQUFxQixDQUFDLE9BQXRCLElBQWlDLHFCQUFxQixDQUFDLE9BQXBGO0FBRUgsR0FoQjBDLEVBZ0J6QyxFQWhCeUMsQ0FBM0MsQ0EvZ0JDLENBaWlCRDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxvQkFBVTtBQUVOLG1CQUFlLENBQUMsT0FBaEIsR0FBMEIsSUFBSSxvQkFBSixDQUV0QixvQkFGc0IsRUFHdEI7QUFDSSxVQUFJLEVBQUMsZUFBZSxDQUFDLE9BQWhCLENBQXdCLFVBQXhCLENBQW1DLE9BRDVDO0FBRUksZUFBUyxFQUFDO0FBRmQsS0FIc0IsQ0FBMUI7QUFXQSxXQUFPO0FBRUgscUJBQWUsQ0FBQyxPQUFoQixDQUF3QixVQUF4QjtBQUVILEtBSkQ7QUFLSCxHQWxCRCxFQWtCRSxDQUFDLFdBQUQsQ0FsQkYsRUF0akJDLENBMGtCRDs7QUFDQSxNQUFNLG9CQUFvQixHQUFHLG9CQUFZLFVBQUMsT0FBRCxFQUFRO0FBRTdDLFFBQUksb0JBQW9CLENBQUMsT0FBekIsRUFBa0M7QUFDOUI7QUFDQTtBQUNILEtBTDRDLENBTzdDOzs7QUFFQSxhQUFTLE1BQU0sbUJBQW1CLENBQUMsT0FBRCxDQUFsQztBQUdILEdBWjRCLEVBWTNCLEVBWjJCLENBQTdCLENBM2tCQyxDQXlsQkQ7QUFDQTtBQUNBOztBQUNBLE1BQU0sbUJBQW1CLEdBQUcsb0JBQVksVUFBQyxPQUFELEVBQVE7OztBQUU1QyxRQUFJLGFBQWEsa0JBQU8sT0FBUCxDQUFqQjs7QUFFQSxRQUFJLFlBQVksR0FBRyxlQUFlLENBQUMsT0FBbkM7O0FBQ0EsUUFBSSxlQUFlLGtCQUFPLGVBQWUsQ0FBQyxPQUF2QixDQUFuQjs7QUFDQSxRQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBakM7QUFFQSxRQUFJLFFBQVEsR0FBRyxXQUFXLENBQUMsUUFBM0I7QUFFQSxRQUFJLGVBQWUsR0FBRyxZQUFZLENBQUMsVUFBYixDQUF3QixPQUE5QztBQUVBLFFBQUksZUFBZSxHQUFHLG1CQUFtQixDQUFDLE9BQTFDO0FBQ0EsUUFBSSxlQUFlLEdBQUcsbUJBQW1CLENBQUMsT0FBMUM7QUFDQSxRQUFJLFVBQVUsR0FBRyxhQUFhLENBQUMsT0FBL0I7QUFFQSxRQUFJLFdBQVcsR0FBRyxlQUFlLENBQUMsQ0FBRCxDQUFmLENBQW1CLEtBQW5CLENBQXlCLEtBQTNDO0FBRUEsUUFBSSxhQUFKLENBbEI0QyxDQW9CNUM7QUFDQTs7QUFDQSxpQkFBYSxHQUFHLCtDQUE2QjtBQUV6QyxtQkFBYSxFQUFDLGFBRjJCO0FBR3pDLGlCQUFXLEVBQUMsZUFINkI7QUFJekMsaUJBQVcsRUFBQyxlQUo2QjtBQUt6Qyw2QkFBdUI7QUFMa0IsS0FBN0IsQ0FBaEIsQ0F0QjRDLENBK0I1Qzs7QUFDQSxRQUFJLGFBQWEsQ0FBQyxNQUFkLElBQXdCLENBQTVCLEVBQStCO0FBRTNCO0FBRUgsS0FwQzJDLENBc0M1QztBQUNBOzs7QUFDQSxRQUFJLFlBQVksR0FBRyxDQUFuQjtBQUFBLFFBQXNCLGFBQWEsR0FBRyxDQUF0Qzs7QUFDQSxTQUFLLElBQUksb0JBQW9CLEdBQUcsQ0FBaEMsRUFBbUMsb0JBQW9CLEdBQUcsYUFBYSxDQUFDLE1BQXhFLEVBQWdGLG9CQUFvQixFQUFwRyxFQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDSSxVQUFJLFdBQVcsR0FBRyxhQUFhLENBQUMsb0JBQUQsQ0FBL0I7QUFDQSxVQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLFdBQVcsQ0FBQyxpQkFBWixHQUFnQyxHQUEzQyxJQUFnRCxHQUE1RCxDQUxxRyxDQU1yRzs7QUFDQSxVQUFJLGNBQWMsR0FBRyxLQUFLLElBQUksdUJBQTlCLENBUHFHLENBUXJHOztBQUNBLFVBQUksQ0FBQyxjQUFMLEVBQXFCO0FBQ2pCLG9CQUFZO0FBQ2YsT0FGRCxNQUVPO0FBQ0gscUJBQWE7QUFDaEIsT0Fib0csQ0Flckc7O0FBQ0gsS0F6RDJDLENBMkQ1Qzs7O0FBQ0EsaUJBQWEsR0FBSSxZQUFZLEdBQUcsYUFBaEM7QUFDQSxRQUFJLGNBQWMsR0FBRyxZQUFZLEdBQUcsYUFBcEMsQ0E3RDRDLENBOEQ1QztBQUNBOztBQUNBLFFBQUksY0FBYyxJQUFJLENBQXRCLEVBQXlCO0FBRXJCO0FBRUg7O0FBRUQsUUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLElBQUksQ0FBQyxJQUFMLENBQVUsY0FBYyxHQUFDLFVBQXpCLENBQVQsQ0FBeEI7QUFDQSxRQUFJLGNBQUo7QUFFQSxRQUFJLGNBQUo7QUFDQSxrQkFBYyxHQUFHLGlCQUFpQixHQUFHLFVBQXJDOztBQUNBLFFBQUksYUFBSixFQUFtQjtBQUVmLG9CQUFjLEdBQUcsc0JBQWUsQ0FBQyxjQUFELENBQWYsTUFBK0IsSUFBL0IsSUFBK0IsYUFBL0IsR0FBK0IsTUFBL0IsR0FBK0IsR0FBRSxLQUFGLENBQVEsS0FBdkMsS0FBZ0QsQ0FBakUsQ0FGZSxDQUVvRDtBQUV0RSxLQUpELE1BSU87QUFFSCxvQkFBYyxHQUFHLHNCQUFlLENBQUUsZUFBZSxDQUFDLE1BQWhCLEdBQXlCLFVBQTNCLENBQWYsTUFBc0QsSUFBdEQsSUFBc0QsYUFBdEQsR0FBc0QsTUFBdEQsR0FBc0QsR0FBRSxLQUFGLENBQVEsS0FBOUQsS0FBdUUsQ0FBeEYsQ0FGRyxDQUV1Rjs7QUFDMUYsb0JBQWMsSUFBSSxjQUFjLEdBQUcsVUFBbkM7QUFFSDs7QUFFRCxRQUFJLFlBQVksR0FBRyxFQUFuQjs7QUFDQSxTQUFrQiwyQ0FBbEIsRUFBa0IsMkJBQWxCLEVBQWtCLElBQWxCLEVBQWlDO0FBQTVCLFVBQUksS0FBSyxzQkFBVDtBQUNELGtCQUFZLENBQUMsSUFBYixDQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLE9BQWIsQ0FBcUIsS0FBdkM7QUFDSDs7QUFFRCxRQUFJLGNBQWMsR0FBSSxRQUFRLEdBQUUsQ0FBaEMsRUFBb0M7QUFDaEMsb0JBQWMsR0FBRyxRQUFRLEdBQUUsQ0FBM0I7QUFDSDs7QUFDRCxRQUFJLGNBQWMsR0FBRyxDQUFyQixFQUF3QjtBQUNwQixvQkFBYyxHQUFHLENBQWpCO0FBQ0gsS0FoRzJDLENBa0c1QztBQUVBOzs7QUFDQSxrQkFBYyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsY0FBVCxDQUFqQjtBQUNBLFFBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFMLENBQVUsY0FBYyxHQUFDLFVBQXpCLENBQXBCLENBdEc0QyxDQXdHNUM7O0FBQ0EsUUFBSSxvQkFBSjtBQUNBLFFBQUksZUFBZSxHQUFHLENBQXRCLENBMUc0QyxDQTRHNUM7O0FBQ0EsUUFBSSxvQkFBSixFQUEwQixtQkFBMUIsRUFBK0MsZ0JBQS9DLEVBQWlFLG9CQUFqRSxFQUF1RixZQUF2RjtBQUVBLHVCQUFtQixHQUFHLElBQUksQ0FBQyxJQUFMLENBQVUsbUJBQW1CLENBQUMsT0FBcEIsQ0FBNEIsTUFBNUIsR0FBbUMsVUFBN0MsQ0FBdEI7QUFFQSxRQUFJLFlBQVksR0FBRyxDQUFuQjtBQUFBLFFBQXNCLGFBQWEsR0FBRyxDQUF0Qzs7QUFFQSxRQUFJLGFBQUosRUFBbUI7QUFBRTtBQUVqQixVQUFLLG1CQUFtQixHQUFHLGFBQXZCLEdBQXlDLFdBQVcsQ0FBQyxXQUF6RCxFQUF1RTtBQUNuRSxZQUFJLE9BQU8sR0FBSSxtQkFBbUIsR0FBRyxhQUF2QixHQUF5QyxXQUFXLENBQUMsV0FBbkU7QUFDQSxvQkFBWSxHQUFHLE9BQWY7QUFDQSxxQkFBYSxHQUFJLFlBQVksR0FBRyxVQUFoQztBQUNIOztBQUVELHFCQUFlLEdBQUcsYUFBbEI7QUFFQSwwQkFBb0IsR0FBRyxXQUFXLEdBQUcsYUFBckM7QUFFQSxVQUFJLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGVBQWUsQ0FBQyxNQUF2QyxHQUFnRCxDQUF4RTs7QUFFQSxVQUFLLGlCQUFELEdBQXVCLFFBQVEsR0FBRSxDQUFyQyxFQUEwQztBQUV0QyxZQUFJLGFBQWEsR0FBSSxpQkFBaUIsSUFBSSxRQUFRLEdBQUUsQ0FBZCxDQUF0QyxDQUZzQyxDQUVrQjs7QUFDeEQsdUJBQWUsSUFBSSxhQUFuQixDQUhzQyxDQUdMOztBQUVqQyxZQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLGFBQWEsR0FBQyxVQUF6QixDQUFmLENBTHNDLENBS2M7O0FBQ3BELFlBQUksWUFBWSxHQUFJLFFBQVEsR0FBRyxVQUEvQixDQU5zQyxDQU1NOztBQUU1QyxxQkFBYSxJQUFJLFlBQWpCLENBUnNDLENBUVI7O0FBRTlCLFlBQUksZUFBZSxJQUFHLENBQXRCLEVBQXlCO0FBQUU7QUFFdkIsdUJBQWEsR0FBRyxlQUFlLEdBQUcsQ0FBbEM7QUFFSDtBQUNKOztBQUVELDBCQUFvQixHQUFHLENBQUMsYUFBeEI7QUFDQSwwQkFBb0IsR0FBRyxlQUF2QjtBQUVILEtBbENELE1Ba0NPO0FBRUgsVUFBSyxtQkFBbUIsR0FBRyxhQUF2QixHQUF5QyxXQUFXLENBQUMsV0FBekQsRUFBdUU7QUFDbkUsdUJBQWUsR0FBSSxhQUFhLEdBQUcsVUFBbkM7QUFFQSxZQUFJLE9BQU8sR0FBSSxXQUFXLENBQUMsV0FBYixJQUE2QixtQkFBbUIsR0FBRyxhQUFuRCxDQUFkO0FBQ0Esb0JBQVksR0FBRyxPQUFmO0FBQ0EsWUFBSSxnQkFBZ0IsR0FBSSxRQUFRLEdBQUcsVUFBbkM7O0FBQ0EsWUFBSSxZQUFKLEVBQWtCO0FBQ2QsdUJBQWEsR0FBRyxnQkFBaEI7O0FBQ0EsY0FBSSxZQUFZLEdBQUcsQ0FBbkIsRUFBc0I7QUFDbEIseUJBQWEsSUFBSyxDQUFDLFlBQVksR0FBRSxDQUFmLElBQW9CLFVBQXRDO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSCx1QkFBYSxHQUFJLFlBQVksR0FBRyxVQUFoQztBQUNIO0FBQ0o7O0FBRUQsMEJBQW9CLEdBQUcsV0FBdkIsQ0FsQkcsQ0FrQmdDOztBQUVuQyxVQUFJLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLGFBQWpEOztBQUVBLFVBQUksbUJBQW1CLEdBQUcsQ0FBMUIsRUFBNkI7QUFFekIsWUFBSSxhQUFhLEdBQUcsQ0FBQyxtQkFBckI7QUFDQSxZQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLGFBQWEsR0FBQyxVQUF6QixDQUFmLENBSHlCLENBRzJCOztBQUNwRCxZQUFJLFlBQVksR0FBSSxRQUFRLEdBQUcsVUFBL0I7QUFFQSx1QkFBZSxJQUFJLGFBQW5CO0FBQ0EscUJBQWEsSUFBSSxZQUFqQjs7QUFFQSxZQUFJLGVBQWUsSUFBSSxDQUF2QixFQUEwQjtBQUV0Qix1QkFBYSxHQUFHLGVBQWUsR0FBRyxDQUFsQztBQUVIO0FBQ0o7O0FBRUQsMEJBQW9CLEdBQUcsZUFBdkI7QUFDQSwwQkFBb0IsR0FBRyxDQUFDLGFBQXhCO0FBRUgsS0E5TDJDLENBZ001Qzs7O0FBQ0EsUUFBSSxnQkFBSixDQWpNNEMsQ0FrTTVDOztBQUNBLFFBQUksb0JBQW9CLElBQUksb0JBQTVCLEVBQWtEO0FBRTlDLHNCQUFnQixHQUFHLG1DQUFpQjtBQUVoQyx3QkFBZ0IsRUFBQyxlQUZlO0FBR2hDLHNCQUFjLEVBQUMsb0JBSGlCO0FBSWhDLHNCQUFjLEVBQUMsb0JBSmlCO0FBS2hDLG1CQUFXLGFBTHFCO0FBT2hDLG1CQUFXLEVBQUMsV0FBVyxDQUFDLFdBUFE7QUFRaEMsa0JBQVUsRUFBQyxXQUFXLENBQUMsVUFSUztBQVNoQyxpQkFBUyxFQUFDLFdBQVcsQ0FBQyxTQVRVO0FBVWhDLGdCQUFRLEVBQUUsZUFBZSxDQUFDLE9BVk07QUFXaEMsa0JBQVUsWUFYc0I7QUFZaEMsaUJBQVMsRUFBQyxZQUFZLENBQUMsT0FaUztBQWFoQyxlQUFPLEVBQUMsV0FBVyxDQUFDLE9BYlk7QUFjaEMsZ0JBQVEsVUFkd0I7QUFlaEMsbUJBQVcsRUFBQyxXQUFXLENBQUM7QUFmUSxPQUFqQixDQUFuQjtBQWtCSCxLQXBCRCxNQW9CTztBQUVILHNCQUFnQixHQUFHLGVBQW5CO0FBRUgsS0EzTjJDLENBNk41Qzs7O0FBQ0k7bUNBQUE7MENBQUE7NEJBQUE7O0FBQUE7QUFBQSxRQUFDLG1CQUFEO0FBQUEsUUFBYyxtQkFBZDs7QUFTSixtQkFBZSxDQUFDLE9BQWhCLEdBQTBCLGdCQUExQjtBQUNBLHNCQUFrQixDQUFDLE9BQW5CLEdBQTZCLG1CQUFtQixDQUFDLE9BQXBCLEdBQThCLFdBQTNEO0FBQ0Esc0JBQWtCLENBQUMsT0FBbkIsR0FBNkIsbUJBQW1CLENBQUMsT0FBcEIsR0FBOEIsV0FBM0QsQ0F6TzRDLENBMk81Qzs7QUFDQSxRQUFJLFdBQVcsR0FBRyxpQ0FDZDtBQUNJLG1CQUFhLGVBRGpCO0FBRUksa0JBQVksRUFBQyxlQUFlLENBQUMsT0FGakM7QUFHSSxpQkFBVyxFQUFDLFdBQVcsQ0FBQyxXQUg1QjtBQUlJLGtCQUFZLEVBQUMscUJBQXFCLENBQUMsT0FKdkM7QUFLSSxvQkFBYyxnQkFMbEI7QUFNSSxnQkFBVSxZQU5kO0FBT0ksU0FBRyxFQUFDLFdBQVcsQ0FBQyxHQVBwQjtBQVFJLG9CQUFjO0FBUmxCLEtBRGMsQ0FBbEI7O0FBYUEsUUFBSSxXQUFXLEtBQUssU0FBcEIsRUFBK0I7QUFDM0IsVUFBSSxXQUFXLENBQUMsV0FBWixJQUEyQixVQUEvQixFQUEyQztBQUV2Qyw2QkFBcUIsQ0FBQyxPQUF0QixDQUE4QixLQUE5QixDQUFvQyxHQUFwQyxHQUEwQyxXQUFXLEdBQUcsSUFBeEQ7QUFDQSw2QkFBcUIsQ0FBQyxPQUF0QixDQUE4QixLQUE5QixDQUFvQyxJQUFwQyxHQUEyQyxNQUEzQztBQUVILE9BTEQsTUFLTztBQUVILDZCQUFxQixDQUFDLE9BQXRCLENBQThCLEtBQTlCLENBQW9DLElBQXBDLEdBQTJDLFdBQVcsR0FBRyxJQUF6RDtBQUNBLDZCQUFxQixDQUFDLE9BQXRCLENBQThCLEtBQTlCLENBQW9DLEdBQXBDLEdBQTBDLE1BQTFDO0FBRUg7QUFFSjs7QUFFRCxtQkFBZSxDQUFDLGNBQUQsQ0FBZjtBQUVILEdBMVEyQixFQTBRMUIsRUExUTBCLENBQTVCLENBNWxCQyxDQXcyQkQ7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLG9CQUFZLFVBQUMsV0FBRCxFQUFjLGtCQUFkLEVBQWdDO0FBRTNEO0FBQUEsUUFDRiwyREFERTtBQUdOLFFBQUksV0FBVyxJQUFJLFlBQW5CLEVBQWlDLHlCQUF5QixHQUFHLENBQTVCO0FBRWpDLFFBQUksZ0JBQWdCLEdBQUcsRUFBdkIsQ0FQaUUsQ0FPdkM7O0FBRXRCOzRCQUFBOzBCQUFBOzhCQUFBOzhCQUFBOzhCQUFBO2NBQUE7d0RBQUE7bURBQUE7NEJBQUE7O0FBQUE7QUFBQSxRQUFDLDRCQUFEO0FBQUEsUUFBYyxvQ0FBZDtBQUFBLFFBQStCLDhCQUEvQjtBQUFBLFFBQTZDLHdDQUE3QztBQUFBLFFBQWdFLDhCQUFoRTs7QUFjSixrQ0FBOEIsQ0FBQyxPQUEvQixHQUF5QztBQUNyQyxXQUFLLEVBQUMsZUFEK0I7QUFFckMsa0JBQVksRUFBQztBQUZ3QixLQUF6Qzs7QUFLQSxRQUFJLHlCQUF5QixDQUFDLE9BQTlCLEVBQXVDO0FBQ25DLFVBQUksTUFBTSxHQUFHLFdBQWI7QUFDQSxVQUFJLE1BQU0sSUFBSSxXQUFkLEVBQTJCLE1BQU0sR0FBRyxRQUFUO0FBQzNCLCtCQUF5QixDQUFDLE9BQTFCLENBQ0EsOEJBQThCLENBQUMsT0FBL0IsQ0FBdUMsS0FEdkMsRUFDOEMsa0JBRDlDLEVBQ2tFLE1BRGxFO0FBR0g7O0FBRUQsbUNBQStCLENBQUMsOEJBQThCLENBQUMsT0FBaEMsQ0FBL0IsQ0FwQ2lFLENBb0NPOztBQUV4RSxRQUFJLFNBQVMsR0FBRyxtQ0FBaUI7QUFDN0IsaUJBQVcsYUFEa0I7QUFFN0Isb0JBQWMsRUFBQyxDQUZjO0FBRzdCLG9CQUFjLEVBQUMsWUFIYztBQUk3QixpQkFBVyxhQUprQjtBQUs3QixnQkFBVSxZQUxtQjtBQU03QixlQUFTLFdBTm9CO0FBTzdCLHNCQUFnQixrQkFQYTtBQVE3QixjQUFRLEVBQUMsZUFBZSxDQUFDLE9BUkk7QUFTN0IsZ0JBQVUsWUFUbUI7QUFVN0IsZUFBUyxFQUFDLFlBQVksQ0FBQyxPQVZNO0FBVzdCLGFBQU8sU0FYc0I7QUFZN0IsY0FBUSxVQVpxQjtBQWE3QixpQkFBVztBQWJrQixLQUFqQixDQUFoQjs7QUFnQkk7NEJBQUE7cURBQUE7NEJBQUE7O0FBQUE7QUFBQSxRQUFDLHVCQUFEO0FBQUEsUUFBa0IsdUJBQWxCOztBQVNKLG1CQUFlLENBQUMsT0FBaEIsR0FBMEIsU0FBMUI7QUFDQSx1QkFBbUIsQ0FBQyxPQUFwQixHQUE4QixlQUE5QjtBQUNBLHVCQUFtQixDQUFDLE9BQXBCLEdBQThCLGVBQTlCOztBQUVBLFFBQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBRTNCLDJCQUFxQixDQUFDLE9BQXRCLEdBQWdDO0FBQUMsZ0JBQVEsRUFBQyxXQUFWO0FBQXNCLGFBQUssRUFBQztBQUE1QixPQUFoQztBQUVILEtBSkQsTUFJTztBQUFFO0FBRUwsMkJBQXFCLENBQUMsT0FBdEIsR0FBZ0M7QUFBQyxnQkFBUSxFQUFDLFlBQVY7QUFBdUIsYUFBSyxFQUFDO0FBQTdCLE9BQWhDO0FBRUg7QUFFSixHQTdFd0IsRUE2RXZCLENBQ0UsT0FERixFQUVFLFFBRkYsRUFHRSxXQUhGLEVBSUUsVUFKRixFQUtFLFNBTEYsRUFNRSxXQU5GLEVBT0UsY0FQRixFQVFFLGFBUkYsRUFTRSxZQVRGLEVBVUUsV0FWRixFQVdFLEdBWEYsRUFZRSxPQVpGLEVBYUUsVUFiRixFQWNFLGNBZEYsQ0E3RXVCLENBQXpCLENBLzJCQyxDQTg4QkQ7QUFDQTtBQUNBOztBQUVBLE1BQU0sZ0JBQWdCLEdBQUcsZUFBTyxJQUFQLENBQXpCLENBbDlCQyxDQW85QkQ7O0FBQ0EsTUFBTSxRQUFRLEdBQUcsb0JBQVk7QUFFekI7QUFFQSxnQkFBWSxDQUFDLGdCQUFnQixDQUFDLE9BQWxCLENBQVo7O0FBRUEsUUFBSSx3QkFBd0IsQ0FBQyxPQUE3QixFQUFzQztBQUNsQyxhQUFPLENBQUMsR0FBUixDQUFZLHFDQUFaLEVBQWtELHdCQUF3QixDQUFDLE9BQTNFO0FBQ0E7QUFDSDs7QUFFRCxRQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBakM7O0FBRUEsUUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFoQixDQUF3QixVQUE3QixFQUF5QztBQUVyQyxVQUFJLFdBQVcsSUFBSSxPQUFmLElBQTBCLFdBQVcsSUFBSSxlQUE3QyxFQUE4RDtBQUUxRCxzQ0FBOEIsQ0FBQyxPQUEvQixHQUF5Qyx3Q0FBc0I7QUFDM0Qsc0JBQVksRUFBQyxlQUFlLENBQUMsT0FEOEI7QUFFM0Qsd0JBQWMsZ0JBRjZDO0FBRzNELHVCQUFhO0FBSDhDLFNBQXRCLENBQXpDO0FBS0EsaUNBQXlCLENBQUMsT0FBMUIsSUFDSSx5QkFBeUIsQ0FBQyxPQUExQixDQUFrQyw4QkFBOEIsQ0FBQyxPQUEvQixDQUF1QyxLQUF6RSxFQUErRSxXQUEvRSxFQUE0RixXQUE1RixDQURKO0FBR0EsdUNBQStCLENBQUMsOEJBQThCLENBQUMsT0FBaEMsQ0FBL0I7QUFFSDtBQUVKOztBQUVELFFBQ0ksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFuQixJQUNBLENBQUMsb0JBQW9CLENBQUMsT0FEdEIsSUFFQSxDQUFDLGVBQWUsQ0FBQyxPQUFoQixDQUF3QixVQUZ6QixJQUdBLEVBQUUsV0FBVyxJQUFJLFFBQWpCLENBSEEsSUFJQSxFQUFFLFdBQVcsSUFBSSxlQUFqQixDQUpBLElBS0EsRUFBRSxXQUFXLElBQUksWUFBakIsQ0FOSixFQU1vQztBQUVoQyxVQUFJLElBQUksR0FBRyxlQUFlLENBQUMsT0FBaEIsQ0FBd0IsVUFBeEIsQ0FBbUMsT0FBbkMsQ0FBMkMscUJBQTNDLEVBQVg7QUFDSztBQUFBLFVBQUssa0JBQUw7QUFBQSxVQUFZLG9CQUFaO0FBQUEsVUFBb0IsZ0JBQXBCO0FBQ0wsVUFBSSxLQUFLLEdBQUcsS0FBSyxHQUFHLElBQXBCO0FBQUEsVUFBMEIsTUFBTSxHQUFHLE1BQU0sR0FBRyxLQUE1QztBQUNBLHFCQUFlLENBQUMsT0FBaEIsQ0FBd0Isa0JBQXhCLEdBQTZDO0FBQUMsV0FBRyxPQUFKO0FBQU0sYUFBSyxPQUFYO0FBQWEsY0FBTSxRQUFuQjtBQUFxQixZQUFJLE1BQXpCO0FBQTJCLGFBQUssT0FBaEM7QUFBa0MsY0FBTTtBQUF4QyxPQUE3QyxDQUxnQyxDQUt1RDs7QUFFdkYsYUFBTyxDQUFDLEdBQVIsQ0FBWSxlQUFaO0FBQ0EscUJBQWUsQ0FBQyxlQUFELENBQWY7QUFFSDs7QUFFRCxvQkFBZ0IsQ0FBQyxPQUFqQixHQUEyQixVQUFVLENBQUM7QUFFbEM7QUFDQSxVQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBakM7O0FBQ0EsVUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFoQixDQUF3QixVQUE3QixFQUF5QztBQUVyQztBQUNBO0FBQ0EsWUFBSSxZQUFZLGdCQUFPLDhCQUE4QixDQUFDLE9BQXRDLENBQWhCOztBQUNBLHVDQUErQixDQUFDLFlBQUQsQ0FBL0IsQ0FMcUMsQ0FLUzs7QUFDOUMsbUNBQTJCLENBQUMsT0FBNUIsR0FBc0MsWUFBdEM7QUFFSDs7QUFDRCxjQUFRLFdBQVI7QUFFSSxhQUFLLGVBQUw7QUFBc0I7QUFFbEIsd0NBQTRCLENBQUMsT0FBN0IsR0FBb0MsYUFBTywyQkFBMkIsQ0FBQyxPQUFuQyxDQUFwQztBQUVBLGdDQUFvQixDQUFDLE9BQXJCLEdBQStCLElBQS9CO0FBRUEsMkJBQWUsQ0FBQyxZQUFELENBQWY7QUFFQTtBQUVIO0FBWkw7QUFnQkgsS0E3Qm9DLEVBNkJuQyxnQ0E3Qm1DLENBQXJDO0FBK0JILEdBaEZnQixFQWdGZixFQWhGZSxDQUFqQixDQXI5QkMsQ0F1aUNEOztBQUNBLE1BQU0sa0JBQWtCLEdBQUcsZUFBTyxjQUFjLENBQUMsT0FBdEIsQ0FBM0I7QUFDQSxNQUFNLGlCQUFpQixHQUFHLGVBQU8sSUFBUCxDQUExQjtBQUNBLE1BQU0scUJBQXFCLEdBQUcsZUFBTyxJQUFQLENBQTlCLENBMWlDQyxDQTRpQ0Q7QUFDQTs7QUFDQSwwQkFBZ0I7QUFFWixRQUFJLFlBQVksR0FBRyxlQUFlLENBQUMsT0FBbkM7O0FBQ0EsWUFBUSxXQUFSO0FBQ0ksV0FBSyxRQUFMO0FBQ0ksMkJBQW1CLENBQUMsT0FBcEIsR0FBOEIsRUFBOUI7QUFDQSwyQkFBbUIsQ0FBQyxPQUFwQixHQUE4QixFQUE5QjtBQUNBLHVCQUFlLENBQUMsV0FBRCxDQUFmO0FBQ0E7O0FBQ0osV0FBSyxnQkFBTDtBQUF1QjtBQUVuQixzQkFBWSxDQUFDLFVBQWIsQ0FBd0IsT0FBeEIsQ0FBZ0MscUJBQXFCLENBQUMsT0FBdEIsQ0FBOEIsUUFBOUQsSUFDSSxxQkFBcUIsQ0FBQyxPQUF0QixDQUE4QixLQURsQztBQUdBLHlCQUFlLENBQUMsU0FBRCxDQUFmO0FBRUE7QUFDSDs7QUFDRCxXQUFLLGNBQUw7QUFBcUI7QUFBRTtBQUVuQix5QkFBZSxDQUFDLE9BQUQsQ0FBZjtBQUNBO0FBRUg7O0FBQ0QsV0FBSyxTQUFMO0FBQWdCO0FBQ1osNEJBQWtCLENBQUMsT0FBbkIsR0FBNkIsbUJBQW1CLENBQUMsT0FBakQsQ0FEWSxDQUM2Qzs7QUFDekQsNEJBQWtCLENBQUMsT0FBbkIsR0FBNkIsbUJBQW1CLENBQUMsT0FBakQ7QUFDQSx5QkFBZSxDQUFDLFdBQUQsQ0FBZjtBQUNBO0FBQ0g7QUExQkw7QUE2QkgsR0FoQ0QsRUFnQ0UsQ0FBQyxXQUFELENBaENGLEVBOWlDQyxDQWdsQ0Q7O0FBQ0Esb0JBQVU7QUFFTixRQUFJLFlBQVksR0FBRyxlQUFlLENBQUMsT0FBbkM7O0FBQ0EsWUFBUSxXQUFSO0FBQ0ksV0FBSyxPQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxXQUFMO0FBQ0EsV0FBSyxZQUFMO0FBRUksMEJBQWtCLENBQUMsT0FBbkIsR0FBNkIsV0FBN0I7QUFDQSx1QkFBZSxDQUFDLFFBQUQsQ0FBZjtBQUVBOztBQUVKLFdBQUssUUFBTDtBQUFlO0FBRVgsMEJBQWdCLENBQUMsa0JBQWtCLENBQUMsT0FBcEIsRUFBNkIsNEJBQTRCLENBQUMsT0FBMUQsQ0FBaEI7QUFFQSx5QkFBZSxDQUFDLGdCQUFELENBQWY7QUFFQTtBQUNIOztBQUNELFdBQUssV0FBTDtBQUFrQjtBQUNkLG9CQUFVLENBQUM7QUFFUDtBQUNBLGdCQUFJLFlBQVksQ0FBQyxVQUFiLENBQXdCLE9BQTVCLEVBQXFDO0FBQUU7QUFFbkMsMEJBQVksQ0FBQyxVQUFiLENBQXdCLE9BQXhCLENBQWdDLHFCQUFxQixDQUFDLE9BQXRCLENBQThCLFFBQTlELElBQ0kscUJBQXFCLENBQUMsT0FBdEIsQ0FBOEIsS0FEbEMsQ0FGaUMsQ0FLakM7O0FBQ0EseUNBQTJCLENBQUMsT0FBNUIsR0FBbUMsYUFBTyw4QkFBOEIsQ0FBQyxPQUF0QyxDQUFuQztBQUVBLGtDQUFvQixDQUFDLE9BQXJCLEtBQWtDLG9CQUFvQixDQUFDLE9BQXJCLEdBQStCLEtBQWpFO0FBQ0EsZ0RBQWtDLENBQUMsT0FBbkMsS0FBZ0Qsa0NBQWtDLENBQUMsT0FBbkMsR0FBNkMsS0FBN0Y7QUFDQSxzQ0FBd0IsQ0FBQyxPQUF6QixLQUFxQyx3QkFBd0IsQ0FBQyxPQUF6QixHQUFtQyxLQUF4RTtBQUVIO0FBRUosV0FqQlMsRUFpQlIsR0FqQlEsQ0FBVjtBQW1CQSx5QkFBZSxDQUFDLE9BQUQsQ0FBZjtBQUVBO0FBRUg7O0FBRUQsV0FBSyxPQUFMO0FBRUk7QUFoRFI7QUFvREgsR0F2REQsRUF1REUsQ0FBQyxXQUFELENBdkRGLEVBamxDQyxDQTBvQ0Q7QUFDQTtBQUNBO0FBRUE7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsb0JBQVk7QUFFL0IsUUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FBVyxlQUFlLENBQUMsT0FBM0IsQ0FBZjtBQUVBLFdBQU8sbUNBQ0gsUUFERyxFQUVILGVBQWUsQ0FBQyxPQUFoQixDQUF3QixVQUF4QixDQUFtQyxPQUZoQyxFQUdILG9CQUFvQixDQUFDLE9BSGxCLEVBSUgsY0FBYyxDQUFDLE9BQWYsQ0FBdUIsV0FKcEIsQ0FBUDtBQU9ILEdBWHNCLEVBV3JCLEVBWHFCLENBQXZCO0FBYUEsTUFBTSxjQUFjLEdBQUcsb0JBQVk7QUFDL0IsV0FBTyxLQUFLLENBQUMsSUFBTixDQUFXLGVBQWUsQ0FBQyxPQUEzQixDQUFQO0FBQ0gsR0FGc0IsRUFFckIsRUFGcUIsQ0FBdkI7QUFJQSxNQUFNLE1BQU0sR0FBRyxvQkFBWTtBQUV2Qix3QkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUEvQjtBQUNBLHNDQUFrQyxDQUFDLE9BQW5DLEdBQTZDLElBQTdDO0FBQ0EsNEJBQXdCLENBQUMsT0FBekIsR0FBbUMsSUFBbkM7QUFDQSxnQ0FBNEIsQ0FBQyxPQUE3QixHQUFvQyxhQUFPLDJCQUEyQixDQUFDLE9BQW5DLENBQXBDO0FBQ0EsbUJBQWUsQ0FBQyxRQUFELENBQWY7QUFFSCxHQVJjLEVBUWIsRUFSYSxDQUFmO0FBVUEsTUFBTSxZQUFZLEdBQUcsb0JBQVksVUFBQyxLQUFELEVBQU07QUFFbkMsd0JBQW9CLENBQUMsT0FBckIsR0FBK0IsSUFBL0I7QUFDQSxzQ0FBa0MsQ0FBQyxPQUFuQyxHQUE2QyxJQUE3QztBQUVBLGdDQUE0QixDQUFDLE9BQTdCLEdBQXVDO0FBQUMsV0FBSyxPQUFOO0FBQVEsa0JBQVksRUFBQztBQUFyQixLQUF2QztBQUNBLG1CQUFlLENBQUMsWUFBRCxDQUFmO0FBRUgsR0FSb0IsRUFRbkIsRUFSbUIsQ0FBckIsQ0ExcUNDLENBb3JDRDs7QUFDQSxNQUFNLGtCQUFrQixHQUFHLG9CQUFZLFVBQUMsZUFBRCxFQUFrQixVQUFsQixFQUE0QjtBQUV4RDtBQUFBLFFBQU8sNkJBQVA7O0FBRVAsUUFBSSxVQUFVLElBQUksVUFBbEIsRUFBOEI7QUFFMUIscUJBQWUsQ0FBQyxPQUFoQixDQUF3QixHQUF4QixDQUE0QixLQUE1QixFQUFrQyxRQUFsQztBQUVILEtBSkQsTUFJTyxJQUFJLFVBQVUsSUFBSSxZQUFsQixFQUFnQztBQUVuQztBQUVBLHFCQUFlLENBQUMsT0FBaEIsV0FBK0IsS0FBL0I7QUFFSDtBQUVKLEdBaEIwQixFQWdCekIsRUFoQnlCLENBQTNCO0FBa0JBLE1BQU0sWUFBWSxHQUFHLGVBQU87QUFDeEIsa0JBQWMsRUFBQztBQURTLEdBQVAsQ0FBckIsQ0F2c0NDLENBMnNDRDtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxpQkFBaUIsR0FBRyxnQkFBUTtBQUM5QixXQUFPO0FBQ0gsU0FBRyxFQUFDLGtCQUFrQixDQUFDLEdBQW5CLEdBQXlCLENBRDFCO0FBRUgsVUFBSSxFQUFDLGtCQUFrQixDQUFDLElBQW5CLEdBQTBCLENBRjVCO0FBR0gsWUFBTSxFQUFDLDhCQUE4QixDQUFDLE9BQS9CLENBQXVDLEtBSDNDO0FBSUgsY0FBUSxFQUFDLGNBQWMsQ0FBQyxPQUFmLENBQXVCLFFBSjdCO0FBS0gsWUFBTSxFQUFDLGNBQWMsQ0FBQyxPQUFmLENBQXVCO0FBTDNCLEtBQVA7QUFPSCxHQVJ5QixFQVF4QixDQUFDLGtCQUFELEVBQXFCLDhCQUFyQixFQUFxRCxjQUFyRCxDQVJ3QixDQUExQjtBQVVBLFNBQU8sb0VBRUEsY0FBYyxDQUFDLE9BQWYsSUFBMEIsZUFBM0IsR0FDRyxpQ0FBQywwQkFBRCxFQUFjO0FBQ1gsT0FBRyxFQUFJLGlCQUFpQixDQUFDLEdBRGQ7QUFFWCxRQUFJLEVBQUksaUJBQWlCLENBQUMsSUFGZjtBQUdYLFVBQU0sRUFBSSxpQkFBaUIsQ0FBQyxNQUhqQjtBQUlYLFlBQVEsRUFBSSxpQkFBaUIsQ0FBQyxRQUpuQjtBQUtYLFVBQU0sRUFBSSxpQkFBaUIsQ0FBQztBQUxqQixHQUFkLENBREgsR0FRRyxJQVZGLEVBV0g7QUFDSSxTQUFLLEVBQUksZ0JBRGI7QUFFSSxPQUFHLEVBQUkscUJBRlg7QUFFZ0MsaUJBQ2hCO0FBSGhCLEtBS0k7QUFBQSxpQkFFZ0IsTUFGaEI7QUFHSSxPQUFHLEVBQUksb0JBSFg7QUFJSSxTQUFLLEVBQUk7QUFKYixLQVFNLGNBQWMsQ0FBQyxPQUFmLElBQTBCLE9BQTNCLEdBQW9DLGtCQUFrQixDQUFDLE9BQXZELEdBQStELElBUnBFLENBTEosRUFnQkk7QUFBQSxpQkFFZ0IsTUFGaEI7QUFHSSxPQUFHLEVBQUksb0JBSFg7QUFJSSxTQUFLLEVBQUk7QUFKYixLQVFNLGNBQWMsQ0FBQyxPQUFmLElBQTBCLE9BQTNCLEdBQW9DLGtCQUFrQixDQUFDLE9BQXZELEdBQStELElBUnBFLENBaEJKLENBWEcsQ0FBUDtBQTBDSCxDQXJ4Q0QsQyxDQXF4Q0U7OztBQUdGLHFCQUFlLE1BQWYiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNyYWRsZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRPRE86XG4qL1xuXG4vKlxuICAgIERlc2NyaXB0aW9uXG4gICAgLS0tLS0tLS0tLS1cblxuICAgIFRoaXMgbW9kdWxlIGhhcyBvbmUgbWFpbiBkZXNpZ24gcGF0dGVybjogdGhlIGJ1dHRlcmZ1bHkgcGF0dGVybiAobXkgbmFtZSlcblxuICAgIHRoZSBidXR0ZXJmbHkgcGF0dGVybjpcbiAgICAgICAgVGhpcyBwYXR0ZXJuIGNvbnNpc3RzIG9mIHR3byBjb250YWluZXJzIGZvciBpdGVtcyAodGhlIFwid2luZ3NcIiksIGpvaW5lZCBieSBhIDAtbGVuZ3RoIGRpdiAodGhlIFwic3BpbmVcIikuIFxuICAgICAgICBUaGUgd2luZ3MgYXJlIGZpeGVkIHRvIHRoZSBzcGluZSB0aHJvdWdoIHRoZSBib3R0b20vcmlnaHQgcG9zaXRpb24gc3R5bGUgb24gb25lIHNpZGUsIGFuZCB0b3AvbGVmdCBcbiAgICAgICAgb24gdGhlIG90aGVyLiBUaHVzIGFkZGl0aW9ucyBvciBkZWxldGlvbnMgZWZmZWN0IHRoZSBkaXN0YW50IGVuZHMgb2YgdGhlIHdpbmdzIGZyb20gdGhlIHNwaW5lIG9uIGVhY2ggZW5kLiBcbiAgICAgICAgQWxsIHRocmVlIHRvZ2V0aGVyIGNvbXByaXNlIHRoZSBcImNyYWRsZVwiIG9mIGl0ZW1zLiBBZnRlciBhIGNoYW5nZSBvZiBjb250ZW50LCB0aGUgb25seSBjb21wZW5zYXRpbmcgXG4gICAgICAgIGFkanVzdG1lbnQgcmVxdWlyZWQgaXMgdGhlIGNoYW5nZSBvZiBwb3NpdGlvbiBvZiB0aGUgc3BpbmUgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0LlxuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vdmlld3BvcnQnXG5cbmltcG9ydCB1c2VJc01vdW50ZWQgZnJvbSAncmVhY3QtaXMtbW91bnRlZC1ob29rJ1xuXG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbCBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnXG5cbmNvbnN0IExvY2FsUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3dbJ1Jlc2l6ZU9ic2VydmVyJ10gfHwgUmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbFxuXG5jb25zdCBJVEVNX09CU0VSVkVSX1RIUkVTSE9MRCA9IC45XG5cbmltcG9ydCB7IFxuICAgIHNldENyYWRsZUdyaWRTdHlsZXMsIFxuICAgIGdldFVJQ29udGVudExpc3QsIFxuICAgIGNhbGNWaXNpYmxlSXRlbXMsIFxuICAgIGdldFJlZmVyZW5jZUluZGV4RGF0YSxcbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyxcbiAgICBnZXRTcGluZVBvc1JlZixcbiAgICBpc29sYXRlUmVsZXZhbnRJbnRlcnNlY3Rpb25zLFxuICAgIC8vIG5vcm1hbGl6ZUNyYWRsZUFuY2hvcnMsXG4gICAgYWxsb2NhdGVDb250ZW50TGlzdCxcblxufSBmcm9tICcuL2NyYWRsZWZ1bmN0aW9ucydcblxuaW1wb3J0IFNjcm9sbFRyYWNrZXIgZnJvbSAnLi9zY3JvbGx0cmFja2VyJ1xuXG5jb25zdCBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCA9IDIwMFxuXG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIHJ1bndheWxlbmd0aCxcbiAgICAgICAgcnVud2F5Y291bnQsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG9mZnNldCwgXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgc3R5bGVzLFxuICAgIH0pID0+IHtcblxuICAgIC8vIGZ1bmN0aW9ucyBhbmQgc3R5bGVzIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIGNvbnN0IGNyYWRsZVByb3BzUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBydW53YXlsZW5ndGgsXG4gICAgICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgICAgICBvZmZzZXQsIFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgfX0sW1xuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgcnVud2F5bGVuZ3RoLFxuICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgb2Zmc2V0LCBcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICBdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIElOSVRJQUxJWkFUSU9OIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyB1dGlsaXRlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKVxuICAgIGNvbnN0IHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYgPSB1c2VSZWYoZnVuY3Rpb25zPy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKVxuXG4gICAgY29uc3QgaXRlbU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpIC8vIEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgY29uc3QgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBjcmFkbGVSZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgZGF0YSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3Qgdmlld3BvcnREYXRhID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG4gICAgY29uc3Qgdmlld3BvcnREYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQgPSB2aWV3cG9ydERhdGFcblxuICAgIGNvbnN0IFtjcmFkbGVzdGF0ZSwgc2F2ZUNyYWRsZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgY3JhZGxlc3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzXG4gICAgY3JhZGxlc3RhdGVSZWYuY3VycmVudCA9IGNyYWRsZXN0YXRlXG5cbiAgICAvLyBjb25zb2xlLmxvZygncnVubmluZyBjcmFkbGUgd2l0aCBzdGF0ZScsY3JhZGxlc3RhdGUpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRyb2wgdmFyaWFibGVzIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZiA9IHVzZVJlZihmYWxzZSlcblxuICAgIC8vIHRvIGNvbnRyb2wgYXBwZWFyYW5jZSBvZiByZXBvc2l0aW9uaW5nIG1vZGVcbiAgICBjb25zdCBpc1RhaWxDcmFkbGVJblZpZXdSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0hlYWRDcmFkbGVJblZpZXdSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0NyYWRsZUluVmlld1JlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL2luaXRpYWxpemUgaG9zdCBmdW5jdGlvbnMgcHJvcGVydGllc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdzY3JvbGxUb0l0ZW0nKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnNjcm9sbFRvSXRlbSA9IHNjcm9sbFRvSXRlbVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdnZXRWaXNpYmxlTGlzdCcpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMuZ2V0VmlzaWJsZUxpc3QgPSBnZXRWaXNpYmxlTGlzdFxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdnZXRDb250ZW50TGlzdCcpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMuZ2V0Q29udGVudExpc3QgPSBnZXRDb250ZW50TGlzdFxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdyZWxvYWQnKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnJlbG9hZCA9IHJlbG9hZFxuICAgICAgICB9XG5cbiAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50ID0gZnVuY3Rpb25zPy5yZWZlcmVuY2VJbmRleENhbGxiYWNrXG5cbiAgICB9LFtmdW5jdGlvbnNdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc2Nyb2xsIGxpc3RlbmVyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHZpZXdwb3J0RGF0YSA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50XG4gICAgICAgIHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxvblNjcm9sbClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50ICYmIHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxvblNjcm9sbClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVjb25maWd1cmF0aW9uIGVmZmVjdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdHJpZ2dlciByZXNpemluZyBiYXNlZCBvbiB2aWV3cG9ydCBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICh2aWV3cG9ydERhdGEuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICAvLyBlbnRlciByZXNpemluZyBtb2RlXG4gICAgICAgICAgICBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSB7Li4ubWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnR9XG5cbiAgICAgICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBwYXVzZVNjcm9sbGluZ0VmZmVjdHNSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVzaXppbmcnKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wbGV0ZSByZXNpemluZyBtb2RlXG4gICAgICAgIGlmICghdmlld3BvcnREYXRhLmlzUmVzaXppbmcgJiYgKGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgPT0gJ3Jlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXNpemUnKVxuXG4gICAgICAgIH1cblxuICAgIH0sW3ZpZXdwb3J0RGF0YS5pc1Jlc2l6aW5nXSlcblxuICAgIC8vIHJlbG9hZCBmb3IgY2hhbmdlZCBwYXJhbWV0ZXJzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gey4uLm1hc3RlclJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50fVxuXG4gICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgLy8gdHJpZ2dlciBwaXZvdCBvbiBjaGFuZ2UgaW4gb3JpZW50YXRpb25cbiAgICB1c2VFZmZlY3QoKCk9PiB7XG5cbiAgICAgICAgaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gW11cbiAgICAgICAgdGFpbE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gW11cblxuICAgICAgICBpZiAoY3JhZGxlc3RhdGVSZWYuY3VycmVudCAhPSAnc2V0dXAnKSB7XG5cbiAgICAgICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5tYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3Bpdm90JylcblxuICAgICAgICB9XG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgT1BFUkFUSU9OIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNlc3Npb24gZGF0YSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tIGN1cnJlbnQgbG9jYXRpb24gLS0gZmlyc3QgaGVhZCB2aXNpYmxlIGl0ZW0gLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgW2ltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YSwgc2F2ZUltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YV0gPSB1c2VTdGF0ZSh7XG4gICAgICAgIGluZGV4Ok1hdGgubWluKG9mZnNldCwobGlzdHNpemUgLSAxKSkgfHwgMCxcbiAgICAgICAgc2Nyb2xsb2Zmc2V0OjBcbiAgICB9KVxuICAgIGNvbnN0IGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXNcbiAgICBpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVxuICAgIGNvbnN0IG1hc3RlclJlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEpIC8vIGNhcHR1cmUgZm9yIHN0YXRlIHJlc2V0Q29udGVudCBvcGVyYXRpb25zXG4gICAgY29uc3QgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEpIC8vIGFudGljaXBhdGUgcmVwb3NpdGlvblxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIGRhdGEgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNyYWRsZSBidXR0ZXJmbHkgaHRtbCBjb21wb25lbnRzXG4gICAgY29uc3QgaGVhZENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNwaW5lQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gZGF0YSBtb2RlbFxuICAgIGNvbnN0IG1vZGVsQ29udGVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGhlYWRNb2RlbENvbnRlbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsTW9kZWxDb250ZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyB2aWV3IG1vZGVsXG4gICAgY29uc3QgaGVhZFZpZXdDb250ZW50UmVmID0gdXNlUmVmKFtdKVxuICAgIGNvbnN0IHRhaWxWaWV3Q29udGVudFJlZiA9IHVzZVJlZihbXSlcblxuICAgIGNvbnN0IGl0ZW1FbGVtZW50c1JlZiA9IHVzZVJlZihuZXcgTWFwKCkpIC8vIGl0ZW1zIHJlZ2lzdGVyIHRoZWlyIGVsZW1lbnRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIGNvbmZpZ3VyYXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdmlld3BvcnREaW1lbnNpb25zLCBjcm9zc2NvdW50LCByb3djb3VudFxuXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IHZpZXdwb3J0RGF0YVxuXG4gICAgbGV0IHsgaGVpZ2h0OnZpZXdwb3J0aGVpZ2h0LHdpZHRoOnZpZXdwb3J0d2lkdGggfSA9IHZpZXdwb3J0RGltZW5zaW9uc1xuICAgIFxuICAgIGNvbnN0IGNyb3NzY291bnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBsZXQgY3Jvc3Njb3VudFxuICAgICAgICBsZXQgc2l6ZSA9IChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpP3ZpZXdwb3J0aGVpZ2h0OnZpZXdwb3J0d2lkdGhcbiAgICAgICAgbGV0IGNyb3NzTGVuZ3RoID0gKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/Y2VsbEhlaWdodDpjZWxsV2lkdGhcblxuICAgICAgICBsZXQgbGVuZ3RoZm9yY2FsYyA9IHNpemUgLSAocGFkZGluZyAqIDIpICsgZ2FwIC8vIGxlbmd0aCBvZiB2aWV3cG9ydFxuICAgICAgICBsZXQgdGlsZWxlbmd0aGZvcmNhbGMgPSBjcm9zc0xlbmd0aCArIGdhcFxuICAgICAgICB0aWxlbGVuZ3RoZm9yY2FsYyA9IE1hdGgubWluKHRpbGVsZW5ndGhmb3JjYWxjLGxlbmd0aGZvcmNhbGMpIC8vIHJlc3VsdCBjYW5ub3QgYmUgbGVzcyB0aGFuIDFcbiAgICAgICAgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3IobGVuZ3RoZm9yY2FsYy8odGlsZWxlbmd0aGZvcmNhbGMpKVxuICAgICAgICByZXR1cm4gY3Jvc3Njb3VudFxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgXSlcblxuICAgIGNvbnN0IGNyb3NzY291bnRSZWYgPSB1c2VSZWYoY3Jvc3Njb3VudCkgLy8gZm9yIGVhc3kgcmVmZXJlbmNlIGJ5IG9ic2VydmVyXG4gICAgY3Jvc3Njb3VudFJlZi5jdXJyZW50ID0gY3Jvc3Njb3VudCAvLyBhdmFpbGFibGUgZm9yIG9ic2VydmVyIGNsb3N1cmVcblxuICAgIGNvbnN0IFtjcmFkbGVyb3djb3VudCx2aWV3cG9ydHJvd2NvdW50XSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVuZ3RoLCBjZWxsTGVuZ3RoXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB2aWV3cG9ydExlbmd0aCA9IHZpZXdwb3J0aGVpZ2h0XG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSB2aWV3cG9ydHdpZHRoXG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoXG4gICAgICAgIH1cblxuICAgICAgICBjZWxsTGVuZ3RoICs9IGdhcFxuXG4gICAgICAgIGxldCB2aWV3cG9ydHJvd2NvdW50ID0gTWF0aC5jZWlsKHZpZXdwb3J0TGVuZ3RoL2NlbGxMZW5ndGgpXG4gICAgICAgIGxldCBjcmFkbGVyb3djb3VudCA9IHZpZXdwb3J0cm93Y291bnQgKyAocnVud2F5Y291bnQgKiAyKVxuICAgICAgICBsZXQgaXRlbWNvdW50ID0gY3JhZGxlcm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgICAgIGlmIChpdGVtY291bnQgPiBsaXN0c2l6ZSkge1xuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZXJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3JhZGxlcm93Y291bnQsIHZpZXdwb3J0cm93Y291bnRdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIC8vIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgXSlcblxuICAgIGNvbnN0IGNyYWRsZXJvd2NvdW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY3JhZGxlcm93Y291bnRSZWYuY3VycmVudCA9IGNyYWRsZXJvd2NvdW50XG4gICAgY29uc3Qgdmlld3BvcnRyb3djb3VudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIHZpZXdwb3J0cm93Y291bnRSZWYuY3VycmVudCA9IHZpZXdwb3J0cm93Y291bnRcblxuICAgIC8vIGJhc2Ugc3R5bGVzXG4gICAgbGV0IGNyYWRsZUhlYWRTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gZ2FwICsgJ3B4J1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSAwXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICByaWdodCA9IGdhcCArICdweCdcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4ue1xuXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGFsaWduQ29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHRvcCxcblxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsLi4uc3R5bGVzPy5jcmFkbGV9XG5cbiAgICB9LFtcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgIF0pXG5cbiAgICBsZXQgY3JhZGxlVGFpbFN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9ICdyaWdodCdcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4ue1xuXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGFsaWduQ29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcblxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsLi4uc3R5bGVzPy5jcmFkbGV9XG5cbiAgICB9LFtcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgIF0pXG5cbiAgICBsZXQgY3JhZGxlU3BpbmVTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGxldCBwYWRkaW5neCwgcGFkZGluZ3ksIHRvcCwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBwYWRkaW5neCA9IDBcbiAgICAgICAgICAgIHBhZGRpbmd5ID0gcGFkZGluZ1xuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcGFkZGluZ3ggPSBwYWRkaW5nXG4gICAgICAgICAgICBwYWRkaW5neSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nICsgJ3B4J1xuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybTpgdHJhbnNsYXRlKCR7cGFkZGluZ3h9cHgsJHtwYWRkaW5neX1weClgXG5cbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG5cbiAgICB9LFtcblxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBvcmllbnRhdGlvbixcblxuICAgIF0pXG5cbiAgICAvLyBlbmhhbmNlZCBzdHlsZXMgZm9yIGdyaWRcbiAgICBjb25zdCBbaGVhZHN0eWxlLCB0YWlsc3R5bGUsIHNwaW5lc3R5bGVdID0gdXNlTWVtbygoKT0+IHtcblxuICAgICAgICAvLyBtZXJnZSBiYXNlIHN0eWxlIGFuZCByZXZpc2lvbnMgKGJ5IG9ic2VydmVyKVxuICAgICAgICBsZXQgaGVhZENyYWRsZVN0eWxlczpSZWFjdC5DU1NQcm9wZXJ0aWVzID0gey4uLmNyYWRsZUhlYWRTdHlsZX1cbiAgICAgICAgbGV0IHRhaWxDcmFkbGVTdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IHsuLi5jcmFkbGVUYWlsU3R5bGV9XG4gICAgICAgIGxldCBbaGVhZHN0eWxlcywgdGFpbHN0eWxlc10gPSBzZXRDcmFkbGVHcmlkU3R5bGVzKHtcblxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgaGVhZENyYWRsZVN0eWxlcywgXG4gICAgICAgICAgICB0YWlsQ3JhZGxlU3R5bGVzLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgICAgIHZpZXdwb3J0d2lkdGgsIFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IHRvcCwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCdcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgbGVmdCA9ICdwYWRkaW5nJyArICdweCdcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzcGluZXN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtOmB0cmFuc2xhdGUoMHB4LCR7cGFkZGluZ31weClgXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuXG4gICAgICAgIHJldHVybiBbaGVhZHN0eWxlcywgdGFpbHN0eWxlcywgc3BpbmVzdHlsZV1cblxuICAgIH0sW1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGNyb3NzY291bnQsXG5cbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZVNwaW5lU3R5bGVcblxuICAgICAgXSlcblxuICAgIGNyYWRsZUhlYWRTdHlsZSA9IGhlYWRzdHlsZVxuICAgIGNyYWRsZVRhaWxTdHlsZSA9IHRhaWxzdHlsZVxuICAgIGNyYWRsZVNwaW5lU3R5bGUgPSBzcGluZXN0eWxlXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbnRlcnNlY3Rpb25PYnNlcnZlciBzdXBwb3J0XS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qXG4gICAgICAgIFRoZXJlIGFyZSB0d28gaW50ZXJlY3Rpb24gb2JzZXJ2ZXJzLCBvbmUgZm9yIHRoZSBjcmFkbGUsIGFuZCBhbm90aGVyIGZvciBpdGVtU2hlbGxzOyBcbiAgICAgICAgICAgIGJvdGggYWdhaW5zdCB0aGUgdmlld3BvcnQuXG4gICAgICAgIFRoZXJlIGlzIGFsc28gYSByZXNpemUgb2JzZXJ2ZXIgZm9yIHRoZSBjcmFkbGUgd2luZ3MsIHRvIHJlc3BvbmQgdG8gc2l6ZSBjaGFuZ2VzIG9mIFxuICAgICAgICAgICAgdmFyaWFibGUgY2VsbHMuXG4gICAgKi8gICAgXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIG9ic2VydmVycyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHNldCB1cCBjcmFkbGUgcmVzaXplb2JzZXJ2ZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyXG4gICAgICAgIGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgTG9jYWxSZXNpemVPYnNlcnZlcihjcmFkbGVyZXNpemVvYnNlcnZlcmNhbGxiYWNrKVxuXG4gICAgICAgIGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQub2JzZXJ2ZShoZWFkQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50KVxuICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodGFpbENyYWRsZUVsZW1lbnRSZWYuY3VycmVudClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBjcmFkbGVyZXNpemVvYnNlcnZlcmNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpID0+IHtcblxuICAgICAgICBpZiAocGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JhZGxlIHJlc2l6ZSBlbnRyaWVzJyxlbnRyaWVzKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIHRoaXMgc2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvZiB0aGUgY3JhZGxlIGFnYWluc3QgdGhlIHZpZXdwb3J0LiBXaGVuIHRoZVxuICAgIC8vIGNyYWRsZSBnb2VzIG91dCBvZiB0aGUgb2JzZXJ2ZXIgc2NvcGUsIHRoZSBcInJlcG9zaXRpb25pbmdcIiBjcmFkbGUgc3RhdGUgaXMgdHJpZ2dlcmQuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcblxuICAgICAgICAgICAgY3JhZGxlaW50ZXJzZWN0aW9ub2JzZXJ2ZXJjYWxsYmFjayxcbiAgICAgICAgICAgIHtyb290OnZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuXG4gICAgICAgIClcblxuICAgICAgICBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoaGVhZENyYWRsZUVsZW1lbnRSZWYuY3VycmVudClcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudC5vYnNlcnZlKHRhaWxDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudC5kaXNjb25uZWN0KClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgY29uc3QgY3JhZGxlaW50ZXJzZWN0aW9ub2JzZXJ2ZXJjYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0Lm5hbWUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgaXNIZWFkQ3JhZGxlSW5WaWV3UmVmLmN1cnJlbnQgPSBlbnRyeS5pc0ludGVyc2VjdGluZ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1RhaWxDcmFkbGVJblZpZXdSZWYuY3VycmVudCA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lzSGVhZENyYWRsZUluVmlld1JlZi5jdXJyZW50LGlzVGFpbENyYWRsZUluVmlld1JlZi5jdXJyZW50JyxcbiAgICAgICAgLy8gICAgIGlzSGVhZENyYWRsZUluVmlld1JlZi5jdXJyZW50LGlzVGFpbENyYWRsZUluVmlld1JlZi5jdXJyZW50KVxuICAgICAgICBpc0NyYWRsZUluVmlld1JlZi5jdXJyZW50ID0gKGlzSGVhZENyYWRsZUluVmlld1JlZi5jdXJyZW50IHx8IGlzVGFpbENyYWRsZUluVmlld1JlZi5jdXJyZW50KVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBpdGVtIHNoZWxsIG9ic2VydmVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgICAgVGhlIGNyYWRsZSBjb250ZW50IGlzIGRyaXZlbiBieSBub3RpZmljYXRpb25zIGZyb20gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLlxuICAgICAgICAtIGFzIHRoZSB1c2VyIHNjcm9sbHMgdGhlIGNyYWRsZSwgd2hpY2ggaGFzIGEgcnVud2F5Y291bnQgYXQgYm90aCB0aGUgbGVhZGluZ1xuICAgICAgICAgICAgYW5kIHRyYWlsaW5nIGVkZ2VzLCBpdGVtU2hlbGxzIHNjcm9sbCBpbnRvIG9yIG91dCBvZiB0aGUgc2NvcGUgb2YgdGhlIG9ic2VydmVyIFxuICAgICAgICAgICAgKGRlZmluZWQgYnkgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgdmlld3BvcnQgKyB0aGUgbGVuZ3RocyBvZiB0aGUgcnVud2F5cykuIFRoZSBvYnNlcnZlclxuICAgICAgICAgICAgbm90aWZpZXMgdGhlIGFwcCAodGhyb3VnaCBpdGVtb2JzZXJ2ZXJjYWxsYmFjaygpIGJlbG93KSBhdCB0aGUgY3Jvc3NpbmdzIG9mIHRoZSBpdGVtc2hlbGxzIFxuICAgICAgICAgICAgb2YgdGhlIGRlZmluZWQgb2JzZXJ2ZXIgY3JhZGxlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgICAgIFRoZSBuby1sb25nZXItaW50ZXJzZWN0aW5nIG5vdGlmaWNhdGlvbnMgdHJpZ2dlciBkcm9wcGluZyBvZiB0aGF0IG51bWJlciBvZiBhZmZlY3RlZCBpdGVtcyBmcm9tIFxuICAgICAgICAgICAgdGhlIGNyYWRsZSBjb250ZW50bGlzdC4gVGhlIGRyb3BwaW5nIG9mIGl0ZW1zIGZyb20gdGhlIHRyYWlsaW5nIGVuZCBvZiB0aGUgY29udGVudCBsaXN0XG4gICAgICAgICAgICB0cmlnZ2VycyB0aGUgYWRkaXRpb24gb2YgYW4gZXF1YWwgbnVtYmVyIG9mIGl0ZW1zIGF0IHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIGNyYWRsZSBjb250ZW50LlxuXG4gICAgICAgICAgICBUZWNobmljYWxseSwgdGhlIG9wcG9zaXRlIGVuZCBwb3NpdGlvbiBzcGVjIGlzIHNldCAodG9wIG9yIGxlZnQgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uKSwgXG4gICAgICAgICAgICBhbmQgdGhlIG1hdGNoaW5nIGVuZCBwb3NpdGlvbiBzcGVjIGlzIHNldCB0byAnYXV0bycgd2hlbiBpdGVtcyBhcmUgYWRkZWQuIFRoaXMgY2F1c2VzIGl0ZW1zIHRvIGJlIFxuICAgICAgICAgICAgXCJzcXVlZXplZFwiIGludG8gdGhlIGxlYWRpbmcgb3IgdHJhaWxpbmcgZW5kcyBvZiB0aGUgdWkgY29udGVudCAob3V0IG9mIHZpZXcpIGFzIGFwcHJvcHJpYXRlLlxuXG4gICAgICAgICAgICBUaGVyZSBhcmUgZXhjZXB0aW9ucyBmb3Igc2V0dXAgYW5kIGVkZ2UgY2FzZXMuXG4gICAgKi9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgaXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG5cbiAgICAgICAgICAgIGl0ZW1vYnNlcnZlcmNhbGxiYWNrLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvb3Q6dmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LCBcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6SVRFTV9PQlNFUlZFUl9USFJFU0hPTEQsXG4gICAgICAgICAgICAgICAgLy8gcm9vdE1hcmdpbjonNTBweCdcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyB0aGUgYXN5bmMgY2FsbGJhY2sgZnJvbSBJbnRlcnNlY3Rpb25PYnNlcnZlci5cbiAgICBjb25zdCBpdGVtb2JzZXJ2ZXJjYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKT0+e1xuXG4gICAgICAgIGlmIChwYXVzZUl0ZW1PYnNlcnZlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmV0dXJuaW5nIHdpdGggcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCcscGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0VOVFJJRVMnLCBlbnRyaWVzKVxuXG4gICAgICAgIGlzTW91bnRlZCgpICYmIGFkanVzdGNyYWRsZWVudHJpZXMoZW50cmllcylcblxuXG4gICAgfSxbXSlcblxuICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGNhc2Ugd2hlcmUgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZCBzY3JvbGxcbiAgICAvLyBhZGp1c3Qgc2Nyb2xsIGNvbnRlbnQ6XG4gICAgLy8gMS5zaGlmdCwgMi5jbGlwLCBhbmQgMy5hZGQgY2xpcCBhbW91bnQgYXQgb3RoZXIgZW5kXG4gICAgY29uc3QgYWRqdXN0Y3JhZGxlZW50cmllcyA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKT0+e1xuXG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb25zID0gWy4uLmVudHJpZXNdXG5cbiAgICAgICAgbGV0IHZpZXdwb3J0RGF0YSA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50XG4gICAgICAgIGxldCBjb250ZW50bGlzdGNvcHkgPSBbLi4ubW9kZWxDb250ZW50UmVmLmN1cnJlbnRdXG4gICAgICAgIGxldCBjcmFkbGVQcm9wcyA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgbGlzdHNpemUgPSBjcmFkbGVQcm9wcy5saXN0c2l6ZVxuXG4gICAgICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGhlYWRjb250ZW50bGlzdCA9IGhlYWRNb2RlbENvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICBsZXQgdGFpbGNvbnRlbnRsaXN0ID0gdGFpbE1vZGVsQ29udGVudFJlZi5jdXJyZW50XG4gICAgICAgIGxldCBjcm9zc2NvdW50ID0gY3Jvc3Njb3VudFJlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGluZGV4b2Zmc2V0ID0gY29udGVudGxpc3Rjb3B5WzBdLnByb3BzLmluZGV4XG5cbiAgICAgICAgbGV0IHNjcm9sbGZvcndhcmRcblxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGluYXBwbGljYWJsZSBpbnRlcnNlY3Rpb24gZW50cmllc1xuICAgICAgICAvLyB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gaW50ZXJzZWN0aW9ucyBwcm94aW1hbCB0byB0aGUgc3BpbmVcbiAgICAgICAgaW50ZXJzZWN0aW9ucyA9IGlzb2xhdGVSZWxldmFudEludGVyc2VjdGlvbnMoe1xuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zOmludGVyc2VjdGlvbnMsXG4gICAgICAgICAgICBoZWFkY29udGVudDpoZWFkY29udGVudGxpc3QsIFxuICAgICAgICAgICAgdGFpbGNvbnRlbnQ6dGFpbGNvbnRlbnRsaXN0LFxuICAgICAgICAgICAgSVRFTV9PQlNFUlZFUl9USFJFU0hPTEQsXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnRklMVEVSRUQgaW50ZXJzZWN0aW9ucycsaW50ZXJzZWN0aW9ucylcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09IDApIHtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tIGlzb2xhdGUgZm9yd2FyZCBhbmQgYmFja3dhcmQgbGlzdHMgKGhhcHBlbnMgd2l0aCByYXBpZCBzY3JvbGxpbmcgY2hhbmdlcylcbiAgICAgICAgLy8gIHRoZW4gc2V0IHNjcm9sbGZvcndhcmRcbiAgICAgICAgbGV0IGZvcndhcmRjb3VudCA9IDAsIGJhY2t3YXJkY291bnQgPSAwXG4gICAgICAgIGZvciAobGV0IGludGVyc2VjdHJlY29yZGluZGV4ID0gMDsgaW50ZXJzZWN0cmVjb3JkaW5kZXggPCBpbnRlcnNlY3Rpb25zLmxlbmd0aDsgaW50ZXJzZWN0cmVjb3JkaW5kZXgrKyApIHtcbiAgICAgICAgLy8gbGV0IHJhdGlvID0gTWF0aC5yb3VuZChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyAqIDEwMCkvMTAwXG4gICAgICAgIC8vIGludGVyc2VjdGluZ1tpbmRleF0gPSB7XG4gICAgICAgIC8vICAgICBpbnRlcnNlY3Rpbmc6cmF0aW8gPj0gSVRFTV9PQlNFUlZFUl9USFJFU0hPTEQsXG4gICAgICAgICAgICBsZXQgc2FtcGxlRW50cnkgPSBpbnRlcnNlY3Rpb25zW2ludGVyc2VjdHJlY29yZGluZGV4XVxuICAgICAgICAgICAgbGV0IHJhdGlvID0gTWF0aC5yb3VuZChzYW1wbGVFbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyAqIDEwMCkvMTAwXG4gICAgICAgICAgICAvLyBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgbGV0IGlzaW50ZXJzZWN0aW5nID0gcmF0aW8gPj0gSVRFTV9PQlNFUlZFUl9USFJFU0hPTERcbiAgICAgICAgICAgIC8vIGlmICghc2FtcGxlRW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIGlmICghaXNpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBmb3J3YXJkY291bnQrK1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYWNrd2FyZGNvdW50KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gfSBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZlcmVuY2VpbmRleFxuICAgICAgICBzY3JvbGxmb3J3YXJkID0gKGZvcndhcmRjb3VudCA+IGJhY2t3YXJkY291bnQpXG4gICAgICAgIGxldCBzaGlmdGl0ZW1jb3VudCA9IGZvcndhcmRjb3VudCAtIGJhY2t3YXJkY291bnRcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NISUZUIElURU0gQ09VTlQgZm9yd2FyZGNvdW50LCBiYWNrd2FyZGNvdW50LCBzaGlmdGl0ZW1jb3VudCcsXG4gICAgICAgIC8vICAgICBmb3J3YXJkY291bnQsIGJhY2t3YXJkY291bnQsIHNoaWZ0aXRlbWNvdW50KVxuICAgICAgICBpZiAoc2hpZnRpdGVtY291bnQgPT0gMCkge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZmVyZW5jZXJvd3NoaWZ0ID0gTWF0aC5hYnMoTWF0aC5jZWlsKHNoaWZ0aXRlbWNvdW50L2Nyb3NzY291bnQpKVxuICAgICAgICBsZXQgcmVmZXJlbmNlc2hpZnRcblxuICAgICAgICBsZXQgcmVmZXJlbmNlaW5kZXhcbiAgICAgICAgcmVmZXJlbmNlc2hpZnQgPSByZWZlcmVuY2Vyb3dzaGlmdCAqIGNyb3NzY291bnRcbiAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXggPSB0YWlsY29udGVudGxpc3RbcmVmZXJlbmNlc2hpZnRdPy5wcm9wcy5pbmRleCB8fCAwIC8vIGZpcnN0IHRpbWVcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZWZlcmVuY2VpbmRleCA9IGhlYWRjb250ZW50bGlzdFsoaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aCAtIGNyb3NzY291bnQpXT8ucHJvcHMuaW5kZXggfHwgMCAvLyAwID0gZmlyc3QgdGltZVxuICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXggLT0gcmVmZXJlbmNlc2hpZnQgLSBjcm9zc2NvdW50XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbnRyeWluZGV4ZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBpbnRlcnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBlbnRyeWluZGV4ZXMucHVzaChlbnRyeS50YXJnZXQuZGF0YXNldC5pbmRleClcbiAgICAgICAgfSBcblxuICAgICAgICBpZiAocmVmZXJlbmNlaW5kZXggPiAobGlzdHNpemUgLTEpKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VpbmRleCA9IGxpc3RzaXplIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZWluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVmZXJlbmNlaW5kZXgsIGVudHJ5aW5kZXhlcycscmVmZXJlbmNlaW5kZXgsIC4uLmVudHJ5aW5kZXhlcylcblxuICAgICAgICAvLyBnZW5lcmF0ZSBtb2RpZmllZCBjb250ZW50IGluc3RydWN0aW9uc1xuICAgICAgICBzaGlmdGl0ZW1jb3VudCA9IE1hdGguYWJzKHNoaWZ0aXRlbWNvdW50KSBcbiAgICAgICAgbGV0IHNoaWZ0cm93Y291bnQgPSBNYXRoLmNlaWwoc2hpZnRpdGVtY291bnQvY3Jvc3Njb3VudClcblxuICAgICAgICAvLyBzZXQgcGVuZGluZ2NvbnRlbnRvZmZzZXRcbiAgICAgICAgbGV0IHBlbmRpbmdjb250ZW50b2Zmc2V0XG4gICAgICAgIGxldCBhZGRjb250ZW50Y291bnQgPSAwXG5cbiAgICAgICAgLy8gbmV4dCwgdmVyaWZ5IG51bWJlciBvZiByb3dzIHRvIGRlbGV0ZVxuICAgICAgICBsZXQgaGVhZGluZGV4Y2hhbmdlY291bnQsIGN1cnJlbnRoZWFkcm93Y291bnQsIHZpZXdwb3J0cm93Y291bnQsIHRhaWxpbmRleGNoYW5nZWNvdW50LCB0YWlscm93Y291bnRcblxuICAgICAgICBjdXJyZW50aGVhZHJvd2NvdW50ID0gTWF0aC5jZWlsKGhlYWRNb2RlbENvbnRlbnRSZWYuY3VycmVudC5sZW5ndGgvY3Jvc3Njb3VudClcblxuICAgICAgICBsZXQgY2xpcHJvd2NvdW50ID0gMCwgY2xpcGl0ZW1jb3VudCA9IDBcblxuICAgICAgICBpZiAoc2Nyb2xsZm9yd2FyZCkgeyAvLyBkZWxldGUgZnJvbSBoZWFkOyBhZGQgdG8gdGFpbDsgaGVhZCBpcyBkaXJlY3Rpb24gb2Ygc3Ryb2xsXG5cbiAgICAgICAgICAgIGlmICgoY3VycmVudGhlYWRyb3djb3VudCArIHNoaWZ0cm93Y291bnQpID4gKGNyYWRsZVByb3BzLnJ1bndheWNvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCByb3dkaWZmID0gKGN1cnJlbnRoZWFkcm93Y291bnQgKyBzaGlmdHJvd2NvdW50KSAtIChjcmFkbGVQcm9wcy5ydW53YXljb3VudClcbiAgICAgICAgICAgICAgICBjbGlwcm93Y291bnQgPSByb3dkaWZmXG4gICAgICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IChjbGlwcm93Y291bnQgKiBjcm9zc2NvdW50KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRjb250ZW50Y291bnQgPSBjbGlwaXRlbWNvdW50XG5cbiAgICAgICAgICAgIHBlbmRpbmdjb250ZW50b2Zmc2V0ID0gaW5kZXhvZmZzZXQgKyBjbGlwaXRlbWNvdW50XG5cbiAgICAgICAgICAgIGxldCBwcm9wb3NlZHRhaWxpbmRleCA9IHBlbmRpbmdjb250ZW50b2Zmc2V0ICsgY29udGVudGxpc3Rjb3B5Lmxlbmd0aCAtIDFcblxuICAgICAgICAgICAgaWYgKChwcm9wb3NlZHRhaWxpbmRleCkgPiAobGlzdHNpemUgLTEpICkge1xuXG4gICAgICAgICAgICAgICAgbGV0IGRpZmZpdGVtY291bnQgPSAocHJvcG9zZWR0YWlsaW5kZXggLSAobGlzdHNpemUgLTEpKSAvLyBpdGVtcyBvdXRzaWRlIHJhbmdlXG4gICAgICAgICAgICAgICAgYWRkY29udGVudGNvdW50IC09IGRpZmZpdGVtY291bnQgLy8gYWRqdXN0IHRoZSBhZGRjb250ZW50IGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IGRpZmZyb3dzID0gTWF0aC5mbG9vcihkaWZmaXRlbWNvdW50L2Nyb3NzY291bnQpIC8vIG51bWJlciBvZiBmdWxsIHJvd3MgdG8gbGVhdmUgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICBsZXQgZGlmZnJvd2l0ZW1zID0gKGRpZmZyb3dzICogY3Jvc3Njb3VudCkgIC8vIGRlcml2ZWQgbnVtYmVyIG9mIGl0ZW1zIHRvIGxlYXZlIGluIHBsYWNlXG5cbiAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50IC09IGRpZmZyb3dpdGVtcyAvLyBhcHBseSBhZGp1c3RtZW50IHRvIG5ldHNoaWZ0XG5cbiAgICAgICAgICAgICAgICBpZiAoYWRkY29udGVudGNvdW50IDw9MCkgeyAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IGFkZGNvbnRlbnRjb3VudCA9IDBcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVhZGluZGV4Y2hhbmdlY291bnQgPSAtY2xpcGl0ZW1jb3VudFxuICAgICAgICAgICAgdGFpbGluZGV4Y2hhbmdlY291bnQgPSBhZGRjb250ZW50Y291bnRcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRoZWFkcm93Y291bnQgLSBzaGlmdHJvd2NvdW50KSA8IChjcmFkbGVQcm9wcy5ydW53YXljb3VudCkpIHtcbiAgICAgICAgICAgICAgICBhZGRjb250ZW50Y291bnQgPSAoc2hpZnRyb3djb3VudCAqIGNyb3NzY291bnQpXG5cbiAgICAgICAgICAgICAgICBsZXQgcm93ZGlmZiA9IChjcmFkbGVQcm9wcy5ydW53YXljb3VudCkgLSAoY3VycmVudGhlYWRyb3djb3VudCAtIHNoaWZ0cm93Y291bnQpXG4gICAgICAgICAgICAgICAgY2xpcHJvd2NvdW50ID0gcm93ZGlmZlxuICAgICAgICAgICAgICAgIGxldCB0YWlscm93aXRlbWNvdW50ID0gKGxpc3RzaXplICUgY3Jvc3Njb3VudClcbiAgICAgICAgICAgICAgICBpZiAodGFpbHJvd2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgPSB0YWlscm93aXRlbWNvdW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwcm93Y291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50ICs9ICgoY2xpcHJvd2NvdW50IC0xKSAqIGNyb3NzY291bnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50ID0gKGNsaXByb3djb3VudCAqIGNyb3NzY291bnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZW5kaW5nY29udGVudG9mZnNldCA9IGluZGV4b2Zmc2V0IC8vIGFkZCB0byB0YWlsIChvcHBvc2l0ZSBlbmQgb2Ygc2Nyb2xsIGRpcmVjdGlvbiksIG9mZnNldCB3aWxsIHJlbWFpbiB0aGUgc2FtZVxuXG4gICAgICAgICAgICBsZXQgcHJvcG9zZWRpbmRleG9mZnNldCA9IHBlbmRpbmdjb250ZW50b2Zmc2V0IC0gY2xpcGl0ZW1jb3VudFxuXG4gICAgICAgICAgICBpZiAocHJvcG9zZWRpbmRleG9mZnNldCA8IDApIHtcblxuICAgICAgICAgICAgICAgIGxldCBkaWZmaXRlbWNvdW50ID0gLXByb3Bvc2VkaW5kZXhvZmZzZXRcbiAgICAgICAgICAgICAgICBsZXQgZGlmZnJvd3MgPSBNYXRoLmZsb29yKGRpZmZpdGVtY291bnQvY3Jvc3Njb3VudCkgLy8gbnVtYmVyIG9mIGZ1bGwgcm93cyB0byBsZWF2ZSBpbiBwbGFjZVxuICAgICAgICAgICAgICAgIGxldCBkaWZmcm93aXRlbXMgPSAoZGlmZnJvd3MgKiBjcm9zc2NvdW50KVxuXG4gICAgICAgICAgICAgICAgYWRkY29udGVudGNvdW50IC09IGRpZmZpdGVtY291bnRcbiAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50IC09IGRpZmZyb3dpdGVtc1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZGNvbnRlbnRjb3VudCA8PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IGFkZGNvbnRlbnRjb3VudCA9IDBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkaW5kZXhjaGFuZ2Vjb3VudCA9IGFkZGNvbnRlbnRjb3VudFxuICAgICAgICAgICAgdGFpbGluZGV4Y2hhbmdlY291bnQgPSAtY2xpcGl0ZW1jb3VudFxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2xsZWN0IG1vZGlmaWVkIGNvbnRlbnRcbiAgICAgICAgbGV0IGxvY2FsQ29udGVudExpc3QgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTSElGVCBoZWFkaW5kZXhjaGFuZ2Vjb3VudCx0YWlsaW5kZXhjaGFuZ2Vjb3VudCcsaGVhZGluZGV4Y2hhbmdlY291bnQsdGFpbGluZGV4Y2hhbmdlY291bnQpXG4gICAgICAgIGlmIChoZWFkaW5kZXhjaGFuZ2Vjb3VudCB8fCB0YWlsaW5kZXhjaGFuZ2Vjb3VudCkge1xuXG4gICAgICAgICAgICBsb2NhbENvbnRlbnRMaXN0ID0gZ2V0VUlDb250ZW50TGlzdCh7XG5cbiAgICAgICAgICAgICAgICBsb2NhbENvbnRlbnRMaXN0OmNvbnRlbnRsaXN0Y29weSxcbiAgICAgICAgICAgICAgICBoZWFkaW5kZXhjb3VudDpoZWFkaW5kZXhjaGFuZ2Vjb3VudCxcbiAgICAgICAgICAgICAgICB0YWlsaW5kZXhjb3VudDp0YWlsaW5kZXhjaGFuZ2Vjb3VudCxcbiAgICAgICAgICAgICAgICBpbmRleG9mZnNldCwvLyw6IHBlbmRpbmdjb250ZW50b2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb246Y3JhZGxlUHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aDpjcmFkbGVQcm9wcy5jZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOmNhbGxiYWNrc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGdldEl0ZW06Y3JhZGxlUHJvcHMuZ2V0SXRlbSxcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjpjcmFkbGVQcm9wcy5wbGFjZWhvbGRlcixcblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdCA9IGNvbnRlbnRsaXN0Y29weVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWFkTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSBsb2NhbENvbnRlbnRMaXN0XG4gICAgICAgIGxldCBbaGVhZGNvbnRlbnQsIHRhaWxjb250ZW50XSA9IGFsbG9jYXRlQ29udGVudExpc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudGxpc3Q6bG9jYWxDb250ZW50TGlzdCxcbiAgICAgICAgICAgICAgICBydW53YXljb3VudDpjcmFkbGVQcm9wcy5ydW53YXljb3VudCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWluZGV4LFxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgbW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSBsb2NhbENvbnRlbnRMaXN0XG4gICAgICAgIGhlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50ID0gaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gaGVhZGNvbnRlbnRcbiAgICAgICAgdGFpbFZpZXdDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsY29udGVudFxuXG4gICAgICAgIC8vIHBsYWNlIHRoZSBzcGluZSBpbiB0aGUgc2Nyb2xsYmxvY2tcbiAgICAgICAgbGV0IHNwaW5lcG9zcmVmID0gZ2V0U3BpbmVQb3NSZWYoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZm9yd2FyZCxcbiAgICAgICAgICAgICAgICBpdGVtZWxlbWVudHM6aXRlbUVsZW1lbnRzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb246Y3JhZGxlUHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgc3BpbmVFbGVtZW50OnNwaW5lQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWluZGV4LFxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICAgICAgZ2FwOmNyYWRsZVByb3BzLmdhcCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzaGlmdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChzcGluZXBvc3JlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgc3BpbmVDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUudG9wID0gc3BpbmVwb3NyZWYgKyAncHgnXG4gICAgICAgICAgICAgICAgc3BpbmVDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3BpbmVDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IHNwaW5lcG9zcmVmICsgJ3B4J1xuICAgICAgICAgICAgICAgIHNwaW5lQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgndXBkYXRlc2Nyb2xsJylcblxuICAgIH0sW10pXG5cbiAgICAvLyBFbmQgb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgc3VwcG9ydFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIEFzc2VtYmx5IG9mIGNvbnRlbnRdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgLy8gcmVzZXQgY3JhZGxlLCBpbmNsdWRpbmcgYWxsb2NhdGlvbiBiZXR3ZWVuIGhlYWQgYW5kIHRhaWwgcGFydHMgb2YgdGhlIGNyYWRsZVxuICAgIGNvbnN0IHNldENyYWRsZUNvbnRlbnQgPSB1c2VDYWxsYmFjaygoY3JhZGxlU3RhdGUsIHJlZmVyZW5jZUluZGV4RGF0YSkgPT4ge1xuXG4gICAgICAgIGxldCB7IGluZGV4OiB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQsIFxuICAgICAgICAgICAgc2Nyb2xsb2Zmc2V0OiB2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0IH0gPSByZWZlcmVuY2VJbmRleERhdGFcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb24nKSB2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0ID0gMFxuXG4gICAgICAgIGxldCBsb2NhbENvbnRlbnRMaXN0ID0gW10gLy8gYW55IGR1cGxpY2F0ZWQgaXRlbXMgd2lsbCBiZSByZS11c2VkIGJ5IHJlYWN0XG5cbiAgICAgICAgbGV0IHtpbmRleG9mZnNldCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBjcmFkbGVvZmZzZXR9ID0gXG4gICAgICAgICAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyh7XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgICAgICAgICAgcm93Y291bnQ6Y3JhZGxlcm93Y291bnQsXG4gICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgIHZpc2libGV0YXJnZXRpbmRleG9mZnNldCxcbiAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxPZmZzZXQ6dmlzaWJsZXRhcmdldHNjcm9sbG9mZnNldCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICBpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGluZGV4OnJlZmVyZW5jZW9mZnNldCxcbiAgICAgICAgICAgIHNjcm9sbG9mZnNldDp2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0LFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgbGV0IGNzdGF0ZSA9IGNyYWRsZVN0YXRlXG4gICAgICAgICAgICBpZiAoY3N0YXRlID09ICdzZXRyZWxvYWQnKSBjc3RhdGUgPSAncmVsb2FkJ1xuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50KFxuICAgICAgICAgICAgaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQuaW5kZXgsICdzZXRDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuXG4gICAgICAgIH1cblxuICAgICAgICBzYXZlSW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhKGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50KSAvLyBjb25zaXN0ZW50IHdpdGggb25TY3JvbGxcblxuICAgICAgICBsZXQgY2hpbGRsaXN0ID0gZ2V0VUlDb250ZW50TGlzdCh7XG4gICAgICAgICAgICBpbmRleG9mZnNldCwgXG4gICAgICAgICAgICBoZWFkaW5kZXhjb3VudDowLCBcbiAgICAgICAgICAgIHRhaWxpbmRleGNvdW50OmNvbnRlbnRDb3VudCwgXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICBsb2NhbENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgb2JzZXJ2ZXI6aXRlbU9ic2VydmVyUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgY2FsbGJhY2tzOmNhbGxiYWNrc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZ2V0SXRlbSxcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IFtoZWFkY29udGVudGxpc3QsIHRhaWxjb250ZW50bGlzdF0gPSBhbGxvY2F0ZUNvbnRlbnRMaXN0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0OmNoaWxkbGlzdCxcbiAgICAgICAgICAgICAgICBydW53YXljb3VudDpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LnJ1bndheWNvdW50LFxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXg6MCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIG1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gY2hpbGRsaXN0XG4gICAgICAgIGhlYWRNb2RlbENvbnRlbnRSZWYuY3VycmVudCA9IGhlYWRjb250ZW50bGlzdFxuICAgICAgICB0YWlsTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsY29udGVudGxpc3RcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudCA9IHtwcm9wZXJ0eTonc2Nyb2xsVG9wJyx2YWx1ZTpzY3JvbGxibG9ja29mZnNldH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudCA9IHtwcm9wZXJ0eTonc2Nyb2xsTGVmdCcsdmFsdWU6c2Nyb2xsYmxvY2tvZmZzZXR9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHJ1bndheWxlbmd0aCxcbiAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlcm93Y291bnQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIG1hbmFnZW1lbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxUaW1lcmlkUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBjYWxsYmFjayBmb3Igc2Nyb2xsXG4gICAgY29uc3Qgb25TY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29uU2Nyb2xsIHNjcm9sbFRvcCcsdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LnNjcm9sbFRvcClcblxuICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZXJpZFJlZi5jdXJyZW50KVxuXG4gICAgICAgIGlmIChwYXVzZVNjcm9sbGluZ0VmZmVjdHNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JldHVybmluZyB3aXRoIHBhdXNlU2Nyb2xsaW5nRWZmZWN0JyxwYXVzZVNjcm9sbGluZ0VmZmVjdHNSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNyYWRsZVN0YXRlID0gY3JhZGxlc3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlYWR5JyB8fCBjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZycpIHtcblxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gZ2V0UmVmZXJlbmNlSW5kZXhEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnREYXRhOnZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBjcmFkbGVQcm9wc1JlZixcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3Njb3VudFJlZixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudCAmJiBcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50KGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50LmluZGV4LCdzY3JvbGxpbmcnLCBjcmFkbGVTdGF0ZSlcblxuICAgICAgICAgICAgICAgIHNhdmVJbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEoaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzQ3JhZGxlSW5WaWV3UmVmLmN1cnJlbnQgJiYgXG4gICAgICAgICAgICAhcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCAmJiBcbiAgICAgICAgICAgICF2aWV3cG9ydERhdGFSZWYuY3VycmVudC5pc1Jlc2l6aW5nICYmXG4gICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXNpemUnKSAmJlxuICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZycpICYmIFxuICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbicpKSB7XG5cbiAgICAgICAgICAgIGxldCByZWN0ID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBsZXQge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSByZWN0XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICAgICAgICAgICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQudmlld3BvcnREaW1lbnNpb25zID0ge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0gLy8gdXBkYXRlIGZvciBzY3JvbGx0cmFja2VyXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSRVBPU0lUSU9OSU5HJylcbiAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFRpbWVyaWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBpc1Njcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY3JhZGxlU3RhdGUgPSBjcmFkbGVzdGF0ZVJlZi5jdXJyZW50XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgICAgIC8vIChjcmFkbGVTdGF0ZSAhPSAncmVwb3NpdGlvbmluZycpICYmIFxuICAgICAgICAgICAgICAgIC8vICAgICBub3JtYWxpemVDcmFkbGVBbmNob3JzKGhlYWRDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQsIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb24pXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FscmVmZGF0YSA9IHsuLi5pbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICBzYXZlSW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhKGxvY2FscmVmZGF0YSkgLy8gdHJpZ2dlciByZS1ydW4gdG8gY2FwdHVyZSBlbmQgb2Ygc2Nyb2xsIHNlc3Npb24gdmFsdWVzXG4gICAgICAgICAgICAgICAgbWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSBsb2NhbHJlZmRhdGFcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZyc6IHtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSB7Li4ubWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnR9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGRhdGEgZm9yIHN0YXRlIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjYWxsaW5nQ3JhZGxlU3RhdGUgPSB1c2VSZWYoY3JhZGxlc3RhdGVSZWYuY3VycmVudClcbiAgICBjb25zdCBoZWFkbGF5b3V0RGF0YVJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uRGF0YVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBzdGF0ZSBlbmdpbmVcbiAgICAvLyB1c2VMYXlvdXQgZm9yIHN1cHByZXNzaW5nIGZsYXNoZXNcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgc3dpdGNoIChjcmFkbGVzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVsb2FkJzpcbiAgICAgICAgICAgICAgICBoZWFkTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSBbXVxuICAgICAgICAgICAgICAgIHRhaWxNb2RlbENvbnRlbnRSZWYuY3VycmVudCA9IFtdXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXRyZWxvYWQnKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Nyb2xscG9zaXRpb24nOiB7XG5cbiAgICAgICAgICAgICAgICB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50W3Njcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnByb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnZhbHVlXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ2NvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZXNjcm9sbCc6IHsgLy8gc2Nyb2xsXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb250ZW50Jzoge1xuICAgICAgICAgICAgICAgIGhlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50ID0gaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50IC8vIGNvbnRlbnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICB0YWlsVmlld0NvbnRlbnRSZWYuY3VycmVudCA9IHRhaWxNb2RlbENvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgnbm9ybWFsaXplJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVzdGF0ZV0pXG5cbiAgICAvLyBzdGFuZGFyZCBwcm9jZXNzaW5nIHN0YWdlc1xuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgc3dpdGNoIChjcmFkbGVzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiBcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdwaXZvdCc6XG4gICAgICAgICAgICBjYXNlICdzZXRyZWxvYWQnOlxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG5cbiAgICAgICAgICAgICAgICBjYWxsaW5nQ3JhZGxlU3RhdGUuY3VycmVudCA9IGNyYWRsZXN0YXRlXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXR0bGUnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAnc2V0dGxlJzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlQ29udGVudChjYWxsaW5nQ3JhZGxlU3RhdGUuY3VycmVudCwgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50KVxuXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzY3JvbGxwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsaXplJzoge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVkdW5kYW50IHNjcm9sbCBwb3NpdGlvbiB0byBhdm9pZCBhY2NpZGVudGFsIHBvc2l0aW9uaW5nIGF0IHRhaWwgZW5kIG9mIHJlcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQpIHsgLy8gYWxyZWFkeSB1bm1vdW50ZWQgaWYgZmFpbHNcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudFtzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudC5wcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnZhbHVlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpY2sgdXAgcG9zaXRpb24gZnJvbSBzZXRDb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5pbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCAgJiYgKHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCAgJiYgKHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgJiYgKHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZi5jdXJyZW50ID0gZmFsc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwxMDApXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrIFxuXG4gICAgICAgICAgICB9ICAgICAgICAgIFxuXG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZXN0YXRlXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxsYmFja3MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gb24gaG9zdCBkZW1hbmRcbiAgICBjb25zdCBnZXRWaXNpYmxlTGlzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcblxuICAgICAgICBsZXQgaXRlbWxpc3QgPSBBcnJheS5mcm9tKGl0ZW1FbGVtZW50c1JlZi5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiBjYWxjVmlzaWJsZUl0ZW1zKFxuICAgICAgICAgICAgaXRlbWxpc3QsXG4gICAgICAgICAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBoZWFkQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LCBcbiAgICAgICAgICAgIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cbiAgICAgICAgKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IGdldENvbnRlbnRMaXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtRWxlbWVudHNSZWYuY3VycmVudClcbiAgICB9LFtdKVxuXG4gICAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuXG4gICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5tYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHNjcm9sbFRvSXRlbSA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4geyAvLyAsIGFsaWdubWVudCA9ICdzdGFydCcpID0+IHtcblxuICAgICAgICBwYXVzZUl0ZW1PYnNlcnZlclJlZi5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0ge2luZGV4LCBzY3JvbGxvZmZzZXQ6MH1cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXBvc2l0aW9uJylcblxuICAgIH0sW10pXG5cbiAgICAvLyBjb250ZW50IGl0ZW0gcmVnaXN0cmF0aW9uIGNhbGxiYWNrOyBjYWxsZWQgZnJvbSBpdGVtXG4gICAgY29uc3QgZ2V0SXRlbUVsZW1lbnREYXRhID0gdXNlQ2FsbGJhY2soKGl0ZW1FbGVtZW50RGF0YSwgcmVwb3J0VHlwZSkgPT4geyAvLyBjYW5kaWRhdGUgdG8gZXhwb3J0XG5cbiAgICAgICAgY29uc3QgW2luZGV4LCBzaGVsbHJlZl0gPSBpdGVtRWxlbWVudERhdGFcblxuICAgICAgICBpZiAocmVwb3J0VHlwZSA9PSAncmVnaXN0ZXInKSB7XG5cbiAgICAgICAgICAgIGl0ZW1FbGVtZW50c1JlZi5jdXJyZW50LnNldChpbmRleCxzaGVsbHJlZilcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcG9ydFR5cGUgPT0gJ3VucmVnaXN0ZXInKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdVTlJFR0lTVEVSSU5HJyxpbmRleClcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnRzUmVmLmN1cnJlbnQuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgICAgICBnZXRFbGVtZW50RGF0YTpnZXRJdGVtRWxlbWVudERhdGFcbiAgICB9KVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJFTkRFUi4uLiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBsZXQgY3JhZGxlSGVhZFN0eWxlID0gY3JhZGxlSGVhZFN0eWxlUmVmLmN1cnJlbnRcbiAgICAvLyBsZXQgY3JhZGxlVGFpbFN0eWxlID0gY3JhZGxlVGFpbFN0eWxlUmVmLmN1cnJlbnRcbiAgICAvLyBsZXQgY3JhZGxlU3BpbmVTdHlsZSA9IGNyYWRsZVNwaW5lU3R5bGVSZWYuY3VycmVudFxuXG4gICAgY29uc3Qgc2Nyb2xsVHJhY2tlckFyZ3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDp2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgMyxcbiAgICAgICAgICAgIGxlZnQ6dmlld3BvcnREaW1lbnNpb25zLmxlZnQgKyAzLFxuICAgICAgICAgICAgb2Zmc2V0OmltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50LmluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemU6Y3JhZGxlUHJvcHNSZWYuY3VycmVudC5saXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlczpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LnN0eWxlcyxcbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0RGltZW5zaW9ucywgaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLCBjcmFkbGVQcm9wc1JlZl0pXG5cbiAgICByZXR1cm4gPD5cblxuICAgICAgICB7IChjcmFkbGVzdGF0ZVJlZi5jdXJyZW50ID09ICdyZXBvc2l0aW9uaW5nJylcbiAgICAgICAgICAgID88U2Nyb2xsVHJhY2tlciBcbiAgICAgICAgICAgICAgICB0b3AgPSB7c2Nyb2xsVHJhY2tlckFyZ3MudG9wfSBcbiAgICAgICAgICAgICAgICBsZWZ0ID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxlZnR9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHtzY3JvbGxUcmFja2VyQXJncy5vZmZzZXR9IFxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHtzY3JvbGxUcmFja2VyQXJncy5zdHlsZXN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgOm51bGx9XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVTcGluZVN0eWxlfSBcbiAgICAgICAgICAgIHJlZiA9IHtzcGluZUNyYWRsZUVsZW1lbnRSZWZ9XG4gICAgICAgICAgICBkYXRhLW5hbWUgPSAnc3BpbmUnXG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhLW5hbWUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICByZWYgPSB7aGVhZENyYWRsZUVsZW1lbnRSZWZ9IFxuICAgICAgICAgICAgICAgIHN0eWxlID0ge2NyYWRsZUhlYWRTdHlsZX1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgeyhjcmFkbGVzdGF0ZVJlZi5jdXJyZW50ICE9ICdzZXR1cCcpP2hlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50Om51bGx9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRhdGEtbmFtZSA9ICd0YWlsJ1xuICAgICAgICAgICAgICAgIHJlZiA9IHt0YWlsQ3JhZGxlRWxlbWVudFJlZn0gXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlVGFpbFN0eWxlfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7KGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgIT0gJ3NldHVwJyk/dGFpbFZpZXdDb250ZW50UmVmLmN1cnJlbnQ6bnVsbH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICA8Lz5cblxufSAvLyBDcmFkbGVcblxuXG5leHBvcnQgZGVmYXVsdCBDcmFkbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval(" // cradlefunctions.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/******************************************************************************************\n ------------------------------------[ SUPPORTING FUNCTIONS ]------------------------------\n*******************************************************************************************/\n\nvar react_1 = __importDefault(__webpack_require__(0));\n\nvar itemshell_1 = __importDefault(__webpack_require__(10));\n\nexports.calcVisibleItems = function (itemsArray, viewportElement, cradleElement, orientation) {\n  var list = [];\n  var cradleTop = cradleElement.offsetTop,\n      cradleLeft = cradleElement.offsetLeft;\n  var scrollblockTopOffset = -viewportElement.scrollTop,\n      scrollblockLeftOffset = -viewportElement.scrollLeft,\n      viewportHeight = viewportElement.offsetHeight,\n      viewportWidth = viewportElement.offsetWidth,\n      viewportTopOffset = -scrollblockTopOffset,\n      viewportBottomOffset = -scrollblockTopOffset + viewportHeight;\n\n  for (var i = 0; i < itemsArray.length; i++) {\n    var _a = itemsArray[i],\n        index = _a[0],\n        elementRef = _a[1];\n    var element = elementRef.current;\n    var top_1 = element.offsetTop,\n        left = element.offsetLeft,\n        width = element.offsetWidth,\n        height = element.offsetHeight,\n        right = left + width,\n        bottom = top_1 + height;\n    var itemTopOffset = scrollblockTopOffset + cradleTop + top_1,\n        // offset from top of viewport\n    itemBottomOffset = scrollblockTopOffset + cradleTop + bottom,\n        // offset from top of viewport\n    itemLeftOffset = scrollblockLeftOffset + cradleLeft + left,\n        itemRightOffset = scrollblockLeftOffset + cradleLeft + right;\n    var isVisible = false; // default\n\n    var topPortion = void 0,\n        bottomPortion = void 0,\n        leftPortion = void 0,\n        rightPortion = void 0;\n\n    if (itemTopOffset < 0 && itemBottomOffset > 0) {\n      orientation == 'vertical' && (isVisible = true);\n      bottomPortion = itemBottomOffset;\n      topPortion = bottomPortion - height;\n    } else if (itemTopOffset >= 0 && itemBottomOffset < viewportHeight) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = height;\n      bottomPortion = 0;\n    } else if (itemTopOffset > 0 && itemTopOffset - viewportHeight < 0) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = viewportHeight - itemTopOffset;\n      bottomPortion = topPortion - height;\n    } else {\n      if (orientation == 'vertical') continue;\n    }\n\n    if (itemLeftOffset < 0 && itemRightOffset > 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      rightPortion = itemRightOffset;\n      leftPortion = rightPortion - width;\n    } else if (itemLeftOffset >= 0 && itemRightOffset < viewportWidth) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = width;\n      rightPortion = 0;\n    } else if (itemLeftOffset > 0 && itemLeftOffset - viewportWidth < 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = viewportWidth - itemLeftOffset;\n      rightPortion = leftPortion - width;\n    } else {\n      if (orientation == 'horizontal') continue;\n    }\n\n    var verticalRatio = topPortion > 0 ? topPortion / height : bottomPortion / height,\n        horizontalRatio = leftPortion > 0 ? leftPortion / width : rightPortion / height;\n    var itemData = {\n      index: index,\n      isVisible: isVisible,\n      top: top_1,\n      right: right,\n      bottom: bottom,\n      left: left,\n      width: width,\n      height: height,\n      itemTopOffset: itemTopOffset,\n      itemBottomOffset: itemBottomOffset,\n      topPortion: topPortion,\n      bottomPortion: bottomPortion,\n      itemLeftOffset: itemLeftOffset,\n      itemRightOffset: itemRightOffset,\n      leftPortion: leftPortion,\n      rightPortion: rightPortion,\n      verticalRatio: verticalRatio,\n      horizontalRatio: horizontalRatio\n    };\n    list.push(itemData);\n  }\n\n  list.sort(function (a, b) {\n    return a.index - b.index;\n  });\n  return list;\n};\n\nexports.getReferenceIndexData = function (_a) {\n  var viewportData = _a.viewportData,\n      cradlePropsRef = _a.cradlePropsRef,\n      crosscountRef = _a.crosscountRef;\n  var cradleProps = cradlePropsRef.current;\n  var viewportElement = viewportData.elementref.current;\n  var orientation = cradleProps.orientation,\n      listsize = cradleProps.listsize;\n  var scrollPos, cellLength;\n\n  if (orientation == 'vertical') {\n    scrollPos = viewportElement.scrollTop;\n    cellLength = cradleProps.cellHeight + cradleProps.gap;\n  } else {\n    scrollPos = viewportElement.scrollLeft;\n    cellLength = cradleProps.cellWidth + cradleProps.gap;\n  }\n\n  var referencescrolloffset = cellLength - scrollPos % cellLength; // + cellSpecs.padding\n\n  if (referencescrolloffset == cellLength + cradleProps.padding) referencescrolloffset = 0;\n  var referencerowindex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n  var referenceindex = referencerowindex * crosscountRef.current;\n  var referenceIndexData = {\n    index: Math.min(referenceindex, listsize - 1),\n    scrolloffset: referencescrolloffset\n  };\n  if (referenceIndexData.index == 0) referenceIndexData.scrolloffset = 0; // defensive\n\n  return referenceIndexData;\n}; // evaluate content for requirements\n\n\nexports.getContentListRequirements = function (_a) {\n  // -------------[ calc basic inputs: cellLength, contentCount. ]----------\n  var orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      rowcount = _a.rowcount,\n      runwaycount = _a.runwaycount,\n      gap = _a.gap,\n      visibletargetindexoffset = _a.visibletargetindexoffset,\n      targetScrollOffset = _a.targetScrollOffset,\n      crosscount = _a.crosscount,\n      listsize = _a.listsize; // let cradleContentLength, cellLength, viewportlength\n\n  var cellLength, viewportlength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellHeight + gap; // viewportlength = viewportheight\n  } else {\n    cellLength = cellWidth + gap; // viewportlength = viewportwidth\n  } // cradleContentLength = viewportlength + (runwaylength * 2)\n  // let cradlerowcount = Math.ceil(cradleContentLength/cellLength)\n\n\n  var contentCount = rowcount * crosscount; // cradlerowcount * crosscount\n\n  if (contentCount > listsize) contentCount = listsize; // -----------------------[ calc leadingitemcount, referenceoffset ]-----------------------\n  // let cradleleadingrowcount = runwaycount // Math.floor(runwaylength/cellLength)\n\n  var leadingitemcount = runwaycount * crosscount;\n  var targetdiff = visibletargetindexoffset % crosscount;\n  var referenceoffset = visibletargetindexoffset - targetdiff; // part of return message\n\n  leadingitemcount += targetdiff;\n  leadingitemcount = Math.min(leadingitemcount, visibletargetindexoffset); // for list head\n  // -----------------------[ calc indexoffset ]------------------------\n  // leading edge\n\n  var indexoffset = visibletargetindexoffset - leadingitemcount;\n  var diff = indexoffset % crosscount;\n  indexoffset -= diff; // ------------[ adjust indexoffset and contentCount for listsize ]------------\n\n  diff = 0;\n  var shift = 0;\n\n  if (indexoffset + contentCount > listsize) {\n    diff = indexoffset + contentCount - listsize;\n    shift = diff % crosscount;\n  }\n\n  if (diff) {\n    indexoffset -= diff - shift;\n    contentCount -= shift;\n  } // --------------------[ calc css positioning ]-----------------------\n\n\n  var indexrowoffset = Math.floor(indexoffset / crosscount);\n  var cradleoffset = indexrowoffset * cellLength;\n  var targetrowoffset = Math.floor(visibletargetindexoffset / crosscount);\n  var rowscrollblockoffset = targetrowoffset * cellLength;\n  var scrollblockoffset = Math.max(0, rowscrollblockoffset - targetScrollOffset);\n  return {\n    indexoffset: indexoffset,\n    referenceoffset: referenceoffset,\n    contentCount: contentCount,\n    scrollblockoffset: scrollblockoffset,\n    cradleoffset: cradleoffset\n  }; // summarize requirements message\n}; // filter out items that not proximate to the spine\n\n\nexports.isolateRelevantIntersections = function (_a) {\n  var intersections = _a.intersections,\n      headcontent = _a.headcontent,\n      tailcontent = _a.tailcontent,\n      ITEM_OBSERVER_THRESHOLD = _a.ITEM_OBSERVER_THRESHOLD;\n  var headindexes = [],\n      tailindexes = [],\n      headintersectionindexes = [],\n      headintersections = [],\n      tailintersectionindexes = [],\n      tailintersections = [],\n      intersecting = {},\n      filteredintersections = []; // collect lists of indexes\n\n  for (var _i = 0, headcontent_1 = headcontent; _i < headcontent_1.length; _i++) {\n    var item = headcontent_1[_i];\n    headindexes.push(item.props.index);\n  }\n\n  for (var _b = 0, tailcontent_1 = tailcontent; _b < tailcontent_1.length; _b++) {\n    var item = tailcontent_1[_b];\n    tailindexes.push(item.props.index);\n  }\n\n  for (var _c = 0, intersections_1 = intersections; _c < intersections_1.length; _c++) {\n    var entry = intersections_1[_c];\n    var index = parseInt(entry.target.dataset.index);\n\n    if (tailindexes.includes(index)) {\n      tailintersectionindexes.push(index);\n      tailintersections.push(entry);\n    } else if (headindexes.includes(index)) {\n      headintersectionindexes.push(index);\n      headintersections.push(entry);\n    } else {\n      console.log('warning: unknown intersection element', entry);\n      return; // shouldn't happen; give up\n    }\n\n    var ratio = Math.round(entry.intersectionRatio * 100) / 100;\n    intersecting[index] = {\n      intersecting: ratio >= ITEM_OBSERVER_THRESHOLD,\n      isIntersecting: entry.isIntersecting,\n      ratio: ratio\n    };\n  }\n\n  var indexcompare = function indexcompare(a, b) {\n    var retval = a < b ? -1 : 1;\n    return retval;\n  };\n\n  var entrycompare = function entrycompare(a, b) {\n    var retval = parseInt(a.target.dataset.index) < parseInt(b.target.dataset.index) ? -1 : 1;\n    return retval;\n  };\n\n  headintersectionindexes.sort(indexcompare);\n  tailintersectionindexes.sort(indexcompare);\n  headintersections.sort(entrycompare);\n  tailintersections.sort(entrycompare); // console.log('INPUT headintersectionindexes, tailintersectionindexes, intersecting',\n  //     headintersectionindexes, tailintersectionindexes, intersecting)\n  // set reference points in relation to the spine\n\n  var headindex = headindexes[headindexes.length - 1];\n  var tailindex = tailindexes[0];\n  var headptr = headintersectionindexes.indexOf(headindex);\n  var tailptr = tailintersectionindexes.indexOf(tailindex); // console.log('headindex, tailindex, headptr,tailptr',\n  //     headindex, tailindex, headptr,tailptr)\n  // filter out items that register only because they have just been moved\n\n  if (headptr >= 0 && !intersecting[headindex].intersecting) {\n    headptr = -1;\n  }\n\n  if (tailptr >= 0 && intersecting[tailindex].intersecting) {\n    tailptr = -1;\n  } // -----------------------------------------------\n  // collect notifications to main thread (filtered intersections)\n\n\n  if (headptr >= 0) {\n    var refindex = headintersectionindexes[headptr] + 1;\n    var refintersecting = intersecting[refindex - 1].intersecting;\n\n    for (var ptr = headptr; ptr >= 0; ptr--) {\n      var index = headintersectionindexes[ptr]; // test for continuity and consistency\n\n      if (index + 1 == refindex && intersecting[index].intersecting == refintersecting) {\n        filteredintersections.push(headintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[refindex].intersecting;\n    }\n  }\n\n  if (tailptr >= 0) {\n    var refindex = tailintersectionindexes[tailptr] - 1;\n    var refintersecting = intersecting[refindex + 1].intersecting;\n\n    for (var ptr = tailptr; ptr < tailintersectionindexes.length; ptr++) {\n      var index = tailintersectionindexes[ptr]; // test for continuity and consistency\n      // console.log('tail continuity: index -1, refindex, intersecting[index].intersecting,refintersecting',\n      //     index -1, refindex, intersecting[index],refintersecting)\n\n      if (index - 1 == refindex && intersecting[index].intersecting == refintersecting) {\n        filteredintersections.push(tailintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[index].intersecting;\n    }\n  }\n\n  return filteredintersections;\n}; // update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\n\nexports.getUIContentList = function (props) {\n  var indexoffset = props.indexoffset,\n      headindexcount = props.headindexcount,\n      tailindexcount = props.tailindexcount,\n      orientation = props.orientation,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      contentlist = props.localContentList,\n      crosscount = props.crosscount,\n      listsize = props.listsize,\n      callbacks = props.callbacks,\n      getItem = props.getItem,\n      placeholder = props.placeholder,\n      observer = props.observer;\n\n  var localContentlist = __spreadArrays(contentlist);\n\n  var tailindexoffset = indexoffset + contentlist.length;\n  var returnContentlist;\n  var headContentlist = [];\n\n  if (headindexcount >= 0) {\n    for (var index = indexoffset - headindexcount; index < indexoffset; index++) {\n      headContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(0, -headindexcount);\n  }\n\n  var tailContentlist = [];\n\n  if (tailindexcount >= 0) {\n    for (var index = tailindexoffset; index < tailindexoffset + tailindexcount; index++) {\n      tailContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(tailindexcount, -tailindexcount);\n  }\n\n  returnContentlist = headContentlist.concat(localContentlist, tailContentlist);\n  return returnContentlist;\n}; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\n\nexports.allocateContentList = function (_a) {\n  var contentlist = _a.contentlist,\n      // of cradle, in items (React components)\n  runwaycount = _a.runwaycount,\n      // in rows\n  referenceindex = _a.referenceindex,\n      // first tail item\n  crosscount = _a.crosscount;\n  var offsetindex = contentlist[0].props.index;\n  var runwaytailindex = contentlist[runwaycount * crosscount - 1].props.index;\n  var headitemcount; // if (referenceindex <= runwaytailindex) {\n  //     headitemcount = (referenceindex - offsetindex)\n  // } else {\n  //     headitemcount = (runwaycount * crosscount)\n  // }\n\n  headitemcount = referenceindex - offsetindex;\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount); // console.log('headlist, taillist', [...headlist], [...taillist])\n\n  return [headlist, taillist];\n};\n\nexports.getSpinePosRef = function (_a) {\n  // console.log('referenceindex, referenceshift',referenceindex, referenceshift)\n  var scrollforward = _a.scrollforward,\n      itemelements = _a.itemelements,\n      orientation = _a.orientation,\n      spineElement = _a.spineElement,\n      referenceindex = _a.referenceindex,\n      crosscount = _a.crosscount,\n      gap = _a.gap,\n      referenceshift = _a.referenceshift;\n  var spineposbase, spineposref;\n  var localrefindex = referenceindex;\n\n  if (!scrollforward) {\n    // localrefindex += crosscount\n    localrefindex += referenceshift;\n  }\n\n  var referenceobjects = [];\n\n  if (scrollforward) {\n    referenceobjects.push(itemelements.get(localrefindex));\n  } else {\n    for (var index = localrefindex; index > referenceindex; index -= crosscount) {\n      referenceobjects.push(itemelements.get(index));\n    }\n  }\n\n  var referenceposshift;\n\n  if (orientation == 'vertical') {\n    spineposbase = spineElement.offsetTop;\n  } else {\n    spineposbase = spineElement.offsetLeft;\n  }\n\n  if (scrollforward) {\n    var referenceelement = referenceobjects[0].current;\n\n    if (referenceelement) {\n      // console.log('headindex, headelement.offsetTop',headindex,headelement.offsetTop)\n      if (orientation == 'vertical') {\n        referenceposshift = referenceelement.offsetTop;\n      } else {\n        referenceposshift = referenceelement.offsetLeft;\n      }\n    }\n  } else {\n    referenceposshift = 0;\n\n    for (var _i = 0, referenceobjects_1 = referenceobjects; _i < referenceobjects_1.length; _i++) {\n      var refobj = referenceobjects_1[_i];\n\n      if (orientation == 'vertical') {\n        referenceposshift += refobj.current.offsetHeight + gap;\n      } else {\n        referenceposshift += refobj.current.offsetWidth + gap;\n      }\n    }\n  } // console.log('referenceindex, localrefindex, scrollforward,referenceshift, referenceposshift, referenceelement.offsetTop, referenceelement.offsetHeight, gap, referenceelement',\n  //     referenceindex, localrefindex, scrollforward,referenceshift, referenceposshift, referenceelement.offsetTop, referenceelement.offsetHeight, gap, referenceelement)\n\n\n  if (scrollforward) {\n    spineposref = spineposbase + referenceposshift;\n  } else {\n    spineposref = spineposbase - referenceposshift;\n  } // console.log('in getSpinePosRef referenceobject, scrollforward, spineposbase, localrefindex, referenceposshift, spineposref',\n  //     referenceobject, scrollforward, spineposbase, localrefindex, referenceposshift, spineposref)\n  // console.log('spineposref', spineposref)\n\n\n  return spineposref;\n};\n\nvar emitItem = function emitItem(_a) {\n  var index = _a.index,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      observer = _a.observer,\n      callbacks = _a.callbacks,\n      getItem = _a.getItem,\n      listsize = _a.listsize,\n      placeholder = _a.placeholder;\n  return react_1[\"default\"].createElement(itemshell_1[\"default\"], {\n    key: index,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    index: index,\n    observer: observer,\n    callbacks: callbacks,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder\n  });\n}; // ========================================================================================\n// ------------------------------------[ styles ]------------------------------------------\n// ========================================================================================\n\n\nexports.setCradleGridStyles = function (_a) {\n  var orientation = _a.orientation,\n      headstylesobject = _a.headCradleStyles,\n      tailstylesobject = _a.tailCradleStyles,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      crosscount = _a.crosscount,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth;\n\n  var headstyles = __assign({}, headstylesobject);\n\n  var tailstyles = __assign({}, tailstylesobject);\n\n  headstyles.gridGap = gap + 'px';\n  tailstyles.gridGap = gap + 'px';\n\n  if (orientation == 'horizontal') {\n    headstyles.padding = padding + \"px 0 \" + padding + \"px \" + padding + \"px\";\n    headstyles.width = 'auto';\n    headstyles.height = '100%';\n    headstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    headstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    headstyles.gridTemplateColumns = 'none';\n    tailstyles.padding = padding + \"px \" + padding + \"px \" + padding + \"px 0\";\n    tailstyles.width = 'auto';\n    tailstyles.height = '100%';\n    tailstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    tailstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    tailstyles.gridTemplateColumns = 'none';\n  } else if (orientation == 'vertical') {\n    headstyles.padding = padding + \"px \" + padding + \"px 0 \" + padding + \"px\";\n    headstyles.width = '100%';\n    headstyles.height = 'auto';\n    headstyles.gridAutoFlow = 'row';\n    headstyles.gridTemplateRows = 'none';\n    headstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n    tailstyles.padding = \"0 \" + padding + \"px \" + padding + \"px \" + padding + \"px\";\n    tailstyles.width = '100%';\n    tailstyles.height = 'auto';\n    tailstyles.gridAutoFlow = 'row';\n    tailstyles.gridTemplateRows = 'none';\n    tailstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n  }\n\n  return [headstyles, tailstyles];\n}; // export const setCradleStyleRevisionsForDrop = ({ \n//     headcontentlist,\n//     tailcontentlist,\n//     headCradleElement,\n//     tailCradleElement, \n//     parentElement, \n//     scrollforward, \n//     orientation \n// }) => {\n//     let styles = {} as React.CSSProperties\n//     let tailstyles = {} as React.CSSProperties\n//     let headpos, tailpos\n//     // set styles revisions\n//     if (orientation == 'vertical') {\n//         let offsetHeight = headCradleElement.offsetHeight\n//         let parentHeight = parentElement.offsetHeight\n//         let offsetTop = headCradleElement.offsetTop\n//         styles.left = 'auto'\n//         styles.right = 'auto'\n//         if (scrollforward) {\n//             tailpos = offsetTop + offsetHeight\n//             styles.top = 'auto'\n//             styles.bottom = (parentHeight - tailpos) + 'px'\n//         } else {\n//             headpos = offsetTop\n//             styles.top = headpos + 'px'\n//             styles.bottom = 'auto'\n//         }\n//     } else {\n//         let offsetLeft = headCradleElement.offsetLeft\n//         let offsetWidth = headCradleElement.offsetWidth\n//         let parentWidth = parentElement.offsetWidth\n//         let cssleft = parseInt(headCradleElement.style.left)\n//         let cssright = parseInt(headCradleElement.style.bottom)\n//         styles.top = 'auto'\n//         styles.bottom = 'auto'\n//         if (scrollforward) {\n//             tailpos = offsetLeft + offsetWidth\n//             styles.left = 'auto'\n//             styles.right = (parentWidth - tailpos) + 'px'\n//         } else {\n//             headpos = offsetLeft\n//             styles.left = headpos + 'px'\n//             styles.right = 'auto'\n//         }\n//     }\n//     return [styles,tailstyles]\n// }\n// export const setCradleStyleRevisionsForAdd = ({\n//     headcontentlist,\n//     tailcontentlist,\n//     headCradleElement,\n//     tailCradleElement,\n//     parentElement,\n//     scrollforward,\n//     orientation,\n// }) => {\n//     let styles = {} as React.CSSProperties\n//     let tailstyles = {} as React.CSSProperties\n//     let headpos, tailpos\n//     // set style revisions\n//     if (orientation == 'vertical') {\n//         // let offsetTop\n//         let offsetHeight = headCradleElement.offsetHeight\n//         let parentHeight = parentElement.offsetHeight\n//         let csstop = parseInt(headCradleElement.style.top)\n//         let cssbottom = parseInt(headCradleElement.style.bottom)\n//         let offsetTop = headCradleElement.offsetTop\n//         styles.left = 'auto'\n//         styles.right = 'auto'\n//         if (scrollforward) {\n//             headpos = offsetTop\n//             styles.top = headpos + 'px'\n//             styles.bottom = 'auto'\n//         } else { // scroll backward\n//             tailpos = offsetTop + offsetHeight\n//             styles.top = 'auto'\n//             styles.bottom = (parentHeight - tailpos) + 'px'\n//         }\n//     } else {\n//         let offsetLeft = headCradleElement.offsetLeft\n//         let offsetWidth = headCradleElement.offsetWidth\n//         let parentWidth = parentElement.offsetWidth\n//         let cssleft = parseInt(headCradleElement.style.left)\n//         let cssright = parseInt(headCradleElement.style.bottom)\n//         styles.top = 'auto'\n//         styles.bottom = 'auto'\n//         if (scrollforward) {\n//             headpos = offsetLeft\n//             styles.left = headpos + 'px'\n//             styles.right = 'auto'\n//         } else { // scroll backward\n//             tailpos = offsetLeft + offsetWidth\n//             styles.left = 'auto'\n//             styles.right = (parentWidth - tailpos) + 'px'\n//         }\n//     }\n//     return [styles, tailstyles]\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGVmdW5jdGlvbnMudHN4PzA4YWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVhLDJCQUFtQixVQUFDLFVBQUQsRUFBYSxlQUFiLEVBQThCLGFBQTlCLEVBQTZDLFdBQTdDLEVBQXdEO0FBQ3BGLE1BQUksSUFBSSxHQUFHLEVBQVg7QUFDQSxNQUFJLFNBQVMsR0FBRyxhQUFhLENBQUMsU0FBOUI7QUFBQSxNQUNJLFVBQVUsR0FBRyxhQUFhLENBQUMsVUFEL0I7QUFFQSxNQUFJLG9CQUFvQixHQUFHLENBQUMsZUFBZSxDQUFDLFNBQTVDO0FBQUEsTUFDSSxxQkFBcUIsR0FBRyxDQUFDLGVBQWUsQ0FBQyxVQUQ3QztBQUFBLE1BRUksY0FBYyxHQUFHLGVBQWUsQ0FBQyxZQUZyQztBQUFBLE1BR0ksYUFBYSxHQUFHLGVBQWUsQ0FBQyxXQUhwQztBQUFBLE1BSUksaUJBQWlCLEdBQUcsQ0FBQyxvQkFKekI7QUFBQSxNQUtJLG9CQUFvQixHQUFHLENBQUMsb0JBQUQsR0FBd0IsY0FMbkQ7O0FBT0EsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBL0IsRUFBdUMsQ0FBQyxFQUF4QyxFQUE0QztBQUVwQztBQUFBLFFBQUMsYUFBRDtBQUFBLFFBQVEsa0JBQVI7QUFDSixRQUFJLE9BQU8sR0FBRyxVQUFVLENBQUMsT0FBekI7QUFFQSxRQUFJLEtBQUcsR0FBRyxPQUFPLENBQUMsU0FBbEI7QUFBQSxRQUNJLElBQUksR0FBRyxPQUFPLENBQUMsVUFEbkI7QUFBQSxRQUVJLEtBQUssR0FBRyxPQUFPLENBQUMsV0FGcEI7QUFBQSxRQUdJLE1BQU0sR0FBRyxPQUFPLENBQUMsWUFIckI7QUFBQSxRQUlJLEtBQUssR0FBRyxJQUFJLEdBQUcs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cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU1VQUE9SVElORyBGVU5DVElPTlMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgSXRlbVNoZWxsIGZyb20gJy4vaXRlbXNoZWxsJ1xuXG5leHBvcnQgY29uc3QgY2FsY1Zpc2libGVJdGVtcyA9IChpdGVtc0FycmF5LCB2aWV3cG9ydEVsZW1lbnQsIGNyYWRsZUVsZW1lbnQsIG9yaWVudGF0aW9uKSA9PiB7XG4gICAgbGV0IGxpc3QgPSBbXVxuICAgIGxldCBjcmFkbGVUb3AgPSBjcmFkbGVFbGVtZW50Lm9mZnNldFRvcCwgXG4gICAgICAgIGNyYWRsZUxlZnQgPSBjcmFkbGVFbGVtZW50Lm9mZnNldExlZnRcbiAgICBsZXQgc2Nyb2xsYmxvY2tUb3BPZmZzZXQgPSAtdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCwgXG4gICAgICAgIHNjcm9sbGJsb2NrTGVmdE9mZnNldCA9IC12aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgdmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydFdpZHRoID0gdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICB2aWV3cG9ydFRvcE9mZnNldCA9IC1zY3JvbGxibG9ja1RvcE9mZnNldCxcbiAgICAgICAgdmlld3BvcnRCb3R0b21PZmZzZXQgPSAtc2Nyb2xsYmxvY2tUb3BPZmZzZXQgKyB2aWV3cG9ydEhlaWdodFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgbGV0IFtpbmRleCwgZWxlbWVudFJlZl0gPSBpdGVtc0FycmF5W2ldXG4gICAgICAgIGxldCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IHRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wLCBcbiAgICAgICAgICAgIGxlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQsIFxuICAgICAgICAgICAgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoLCBcbiAgICAgICAgICAgIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHRcblxuICAgICAgICBsZXQgaXRlbVRvcE9mZnNldCA9IHNjcm9sbGJsb2NrVG9wT2Zmc2V0ICsgY3JhZGxlVG9wICsgdG9wLCAvLyBvZmZzZXQgZnJvbSB0b3Agb2Ygdmlld3BvcnRcbiAgICAgICAgICAgIGl0ZW1Cb3R0b21PZmZzZXQgPSBzY3JvbGxibG9ja1RvcE9mZnNldCArIGNyYWRsZVRvcCArIGJvdHRvbSwgLy8gb2Zmc2V0IGZyb20gdG9wIG9mIHZpZXdwb3J0XG4gICAgICAgICAgICBpdGVtTGVmdE9mZnNldCA9IHNjcm9sbGJsb2NrTGVmdE9mZnNldCArIGNyYWRsZUxlZnQgKyBsZWZ0LCBcbiAgICAgICAgICAgIGl0ZW1SaWdodE9mZnNldCA9IHNjcm9sbGJsb2NrTGVmdE9mZnNldCArIGNyYWRsZUxlZnQgKyByaWdodCBcblxuXG4gICAgICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZSAvLyBkZWZhdWx0XG5cbiAgICAgICAgbGV0IHRvcFBvcnRpb24sXG4gICAgICAgICAgICBib3R0b21Qb3J0aW9uLFxuICAgICAgICAgICAgbGVmdFBvcnRpb24sXG4gICAgICAgICAgICByaWdodFBvcnRpb25cblxuICAgICAgICBpZiAoKGl0ZW1Ub3BPZmZzZXQgPCAwKSAmJiAoaXRlbUJvdHRvbU9mZnNldCA+IDApKSB7XG5cbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSAmJiAoaXNWaXNpYmxlID0gdHJ1ZSlcbiAgICAgICAgICAgIGJvdHRvbVBvcnRpb24gPSBpdGVtQm90dG9tT2Zmc2V0XG4gICAgICAgICAgICB0b3BQb3J0aW9uID0gYm90dG9tUG9ydGlvbiAtIGhlaWdodFxuXG4gICAgICAgIH0gZWxzZSBpZiAoKGl0ZW1Ub3BPZmZzZXQgPj0gMCkgJiYgKGl0ZW1Cb3R0b21PZmZzZXQgPCB2aWV3cG9ydEhlaWdodCkpIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgdG9wUG9ydGlvbiA9IGhlaWdodFxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbiA9IDBcblxuICAgICAgICB9IGVsc2UgaWYgKChpdGVtVG9wT2Zmc2V0ID4gMCkgJiYgKChpdGVtVG9wT2Zmc2V0IC0gdmlld3BvcnRIZWlnaHQpIDwgMCkpIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgdG9wUG9ydGlvbiA9IHZpZXdwb3J0SGVpZ2h0IC0gaXRlbVRvcE9mZnNldFxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbiA9IHRvcFBvcnRpb24gLSBoZWlnaHRcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykgY29udGludWVcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1MZWZ0T2Zmc2V0IDwgMCAmJiBpdGVtUmlnaHRPZmZzZXQgPiAwKSB7XG5cbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgcmlnaHRQb3J0aW9uID0gaXRlbVJpZ2h0T2Zmc2V0XG4gICAgICAgICAgICBsZWZ0UG9ydGlvbiA9IHJpZ2h0UG9ydGlvbiAtIHdpZHRoXG5cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtTGVmdE9mZnNldCA+PSAwICYmIGl0ZW1SaWdodE9mZnNldCA8IHZpZXdwb3J0V2lkdGgpIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbiA9IHdpZHRoXG4gICAgICAgICAgICByaWdodFBvcnRpb24gPSAwXG5cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtTGVmdE9mZnNldCA+IDAgJiYgKGl0ZW1MZWZ0T2Zmc2V0IC0gdmlld3BvcnRXaWR0aCkgPCAwKSB7XG5cbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgbGVmdFBvcnRpb24gPSB2aWV3cG9ydFdpZHRoIC0gaXRlbUxlZnRPZmZzZXRcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvbiA9IGxlZnRQb3J0aW9uIC0gd2lkdGhcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSBjb250aW51ZVxuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmVydGljYWxSYXRpbyA9ICh0b3BQb3J0aW9uID4gMCk/dG9wUG9ydGlvbi9oZWlnaHQ6Ym90dG9tUG9ydGlvbi9oZWlnaHQsXG4gICAgICAgICAgICBob3Jpem9udGFsUmF0aW8gPSAobGVmdFBvcnRpb24gPiAwKT9sZWZ0UG9ydGlvbi93aWR0aDpyaWdodFBvcnRpb24vaGVpZ2h0XG5cbiAgICAgICAgbGV0IGl0ZW1EYXRhID0ge1xuXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzVmlzaWJsZSxcblxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG5cbiAgICAgICAgICAgIGl0ZW1Ub3BPZmZzZXQsXG4gICAgICAgICAgICBpdGVtQm90dG9tT2Zmc2V0LFxuICAgICAgICAgICAgdG9wUG9ydGlvbixcbiAgICAgICAgICAgIGJvdHRvbVBvcnRpb24sXG5cbiAgICAgICAgICAgIGl0ZW1MZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgaXRlbVJpZ2h0T2Zmc2V0LFxuICAgICAgICAgICAgbGVmdFBvcnRpb24sXG4gICAgICAgICAgICByaWdodFBvcnRpb24sXG5cbiAgICAgICAgICAgIHZlcnRpY2FsUmF0aW8sXG4gICAgICAgICAgICBob3Jpem9udGFsUmF0aW8sXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtRGF0YSlcblxuICAgIH1cblxuICAgIGxpc3Quc29ydCgoYSxiKSA9PiB7XG4gICAgICAgIHJldHVybiAoYS5pbmRleCAtIGIuaW5kZXgpXG4gICAgfSlcblxuICAgIHJldHVybiBsaXN0XG59XG5cbmV4cG9ydCBjb25zdCBnZXRSZWZlcmVuY2VJbmRleERhdGEgPSAoXG4gICAge1xuICAgICAgICB2aWV3cG9ydERhdGEsXG4gICAgICAgIGNyYWRsZVByb3BzUmVmLFxuICAgICAgICBjcm9zc2NvdW50UmVmLFxuICAgIH0pID0+IHtcblxuICAgIGxldCBjcmFkbGVQcm9wcyA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnRcbiAgICBsZXQgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudFxuICAgIGxldCB7b3JpZW50YXRpb24sIGxpc3RzaXplfSA9IGNyYWRsZVByb3BzXG4gICAgbGV0IHNjcm9sbFBvcywgY2VsbExlbmd0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlUHJvcHMuY2VsbEhlaWdodCArIGNyYWRsZVByb3BzLmdhcFxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlUHJvcHMuY2VsbFdpZHRoICsgY3JhZGxlUHJvcHMuZ2FwXG5cbiAgICB9XG5cbiAgICBsZXQgcmVmZXJlbmNlc2Nyb2xsb2Zmc2V0ID0gY2VsbExlbmd0aCAtIChzY3JvbGxQb3MgJSBjZWxsTGVuZ3RoKSAvLyArIGNlbGxTcGVjcy5wYWRkaW5nXG4gICAgaWYgKHJlZmVyZW5jZXNjcm9sbG9mZnNldCA9PSBjZWxsTGVuZ3RoICsgY3JhZGxlUHJvcHMucGFkZGluZykgcmVmZXJlbmNlc2Nyb2xsb2Zmc2V0ID0gMFxuXG4gICAgbGV0IHJlZmVyZW5jZXJvd2luZGV4ID0gTWF0aC5jZWlsKChzY3JvbGxQb3MgLSBjcmFkbGVQcm9wcy5wYWRkaW5nKS9jZWxsTGVuZ3RoKVxuICAgIGxldCByZWZlcmVuY2VpbmRleCA9IHJlZmVyZW5jZXJvd2luZGV4ICogY3Jvc3Njb3VudFJlZi5jdXJyZW50XG5cbiAgICBsZXQgcmVmZXJlbmNlSW5kZXhEYXRhID0ge1xuICAgICAgICBpbmRleDpNYXRoLm1pbihyZWZlcmVuY2VpbmRleCxsaXN0c2l6ZSAtIDEpLFxuICAgICAgICBzY3JvbGxvZmZzZXQ6cmVmZXJlbmNlc2Nyb2xsb2Zmc2V0XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUluZGV4RGF0YS5pbmRleCA9PSAwKSByZWZlcmVuY2VJbmRleERhdGEuc2Nyb2xsb2Zmc2V0ID0gMCAvLyBkZWZlbnNpdmVcblxuICAgIHJldHVybiByZWZlcmVuY2VJbmRleERhdGFcbn1cblxuLy8gZXZhbHVhdGUgY29udGVudCBmb3IgcmVxdWlyZW1lbnRzXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMgPSAoe1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICByb3djb3VudCxcbiAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgIGdhcCxcbiAgICAgICAgdmlzaWJsZXRhcmdldGluZGV4b2Zmc2V0LFxuICAgICAgICB0YXJnZXRTY3JvbGxPZmZzZXQsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgIH0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS1bIGNhbGMgYmFzaWMgaW5wdXRzOiBjZWxsTGVuZ3RoLCBjb250ZW50Q291bnQuIF0tLS0tLS0tLS0tXG5cbiAgICAvLyBsZXQgY3JhZGxlQ29udGVudExlbmd0aCwgY2VsbExlbmd0aCwgdmlld3BvcnRsZW5ndGhcbiAgICBsZXQgY2VsbExlbmd0aCx2aWV3cG9ydGxlbmd0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIC8vIHZpZXdwb3J0bGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIC8vIHZpZXdwb3J0bGVuZ3RoID0gdmlld3BvcnR3aWR0aFxuICAgIH1cblxuICAgIC8vIGNyYWRsZUNvbnRlbnRMZW5ndGggPSB2aWV3cG9ydGxlbmd0aCArIChydW53YXlsZW5ndGggKiAyKVxuICAgIC8vIGxldCBjcmFkbGVyb3djb3VudCA9IE1hdGguY2VpbChjcmFkbGVDb250ZW50TGVuZ3RoL2NlbGxMZW5ndGgpXG4gICAgbGV0IGNvbnRlbnRDb3VudCA9IHJvd2NvdW50ICogY3Jvc3Njb3VudCAvLyBjcmFkbGVyb3djb3VudCAqIGNyb3NzY291bnRcbiAgICBpZiAoY29udGVudENvdW50ID4gbGlzdHNpemUpIGNvbnRlbnRDb3VudCA9IGxpc3RzaXplXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBsZWFkaW5naXRlbWNvdW50LCByZWZlcmVuY2VvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBsZXQgY3JhZGxlbGVhZGluZ3Jvd2NvdW50ID0gcnVud2F5Y291bnQgLy8gTWF0aC5mbG9vcihydW53YXlsZW5ndGgvY2VsbExlbmd0aClcbiAgICBsZXQgbGVhZGluZ2l0ZW1jb3VudCA9IHJ1bndheWNvdW50ICogY3Jvc3Njb3VudFxuICAgIGxldCB0YXJnZXRkaWZmID0gdmlzaWJsZXRhcmdldGluZGV4b2Zmc2V0ICUgY3Jvc3Njb3VudFxuICAgIGxldCByZWZlcmVuY2VvZmZzZXQgPSB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQgLSB0YXJnZXRkaWZmIC8vIHBhcnQgb2YgcmV0dXJuIG1lc3NhZ2VcblxuICAgIGxlYWRpbmdpdGVtY291bnQgKz0gdGFyZ2V0ZGlmZlxuICAgIGxlYWRpbmdpdGVtY291bnQgPSBNYXRoLm1pbihsZWFkaW5naXRlbWNvdW50LCB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQpIC8vIGZvciBsaXN0IGhlYWRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGluZGV4b2Zmc2V0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGxlYWRpbmcgZWRnZVxuICAgIGxldCBpbmRleG9mZnNldCA9IHZpc2libGV0YXJnZXRpbmRleG9mZnNldCAtIGxlYWRpbmdpdGVtY291bnRcbiAgICBsZXQgZGlmZiA9IGluZGV4b2Zmc2V0ICUgY3Jvc3Njb3VudFxuICAgIGluZGV4b2Zmc2V0IC09IGRpZmZcblxuICAgIC8vIC0tLS0tLS0tLS0tLVsgYWRqdXN0IGluZGV4b2Zmc2V0IGFuZCBjb250ZW50Q291bnQgZm9yIGxpc3RzaXplIF0tLS0tLS0tLS0tLS1cblxuICAgIGRpZmYgPSAwXG4gICAgbGV0IHNoaWZ0ID0gMFxuICAgIGlmICgoaW5kZXhvZmZzZXQgKyBjb250ZW50Q291bnQpID4gbGlzdHNpemUpIHtcbiAgICAgICAgZGlmZiA9IChpbmRleG9mZnNldCArIGNvbnRlbnRDb3VudCkgLSBsaXN0c2l6ZVxuICAgICAgICBzaGlmdCA9IGRpZmYgJSBjcm9zc2NvdW50XG4gICAgfVxuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgICAgaW5kZXhvZmZzZXQgLT0gKGRpZmYgLSBzaGlmdClcbiAgICAgICAgY29udGVudENvdW50IC09IHNoaWZ0XG4gICAgfVxuICAgIFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNzcyBwb3NpdGlvbmluZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBpbmRleHJvd29mZnNldCA9IE1hdGguZmxvb3IoaW5kZXhvZmZzZXQvY3Jvc3Njb3VudClcbiAgICBsZXQgY3JhZGxlb2Zmc2V0ID0gaW5kZXhyb3dvZmZzZXQgKiBjZWxsTGVuZ3RoXG5cbiAgICBsZXQgdGFyZ2V0cm93b2Zmc2V0ID0gTWF0aC5mbG9vcih2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQvY3Jvc3Njb3VudClcblxuICAgIGxldCByb3dzY3JvbGxibG9ja29mZnNldCA9IHRhcmdldHJvd29mZnNldCAqIGNlbGxMZW5ndGhcbiAgICBsZXQgc2Nyb2xsYmxvY2tvZmZzZXQgPSBNYXRoLm1heCgwLHJvd3Njcm9sbGJsb2Nrb2Zmc2V0IC0gdGFyZ2V0U2Nyb2xsT2Zmc2V0KVxuXG4gICAgcmV0dXJuIHtpbmRleG9mZnNldCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBjcmFkbGVvZmZzZXR9IC8vIHN1bW1hcml6ZSByZXF1aXJlbWVudHMgbWVzc2FnZVxuXG59XG5cbi8vIGZpbHRlciBvdXQgaXRlbXMgdGhhdCBub3QgcHJveGltYXRlIHRvIHRoZSBzcGluZVxuZXhwb3J0IGNvbnN0IGlzb2xhdGVSZWxldmFudEludGVyc2VjdGlvbnMgPSAoe1xuICAgIGludGVyc2VjdGlvbnMsXG4gICAgaGVhZGNvbnRlbnQsIFxuICAgIHRhaWxjb250ZW50LFxuICAgIElURU1fT0JTRVJWRVJfVEhSRVNIT0xELFxufSkgPT4ge1xuXG4gICAgbGV0IGhlYWRpbmRleGVzID0gW10sIFxuICAgICAgICB0YWlsaW5kZXhlcyA9IFtdLFxuICAgICAgICBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcyA9IFtdLFxuICAgICAgICBoZWFkaW50ZXJzZWN0aW9ucyA9IFtdLFxuICAgICAgICB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcyA9IFtdLFxuICAgICAgICB0YWlsaW50ZXJzZWN0aW9ucyA9IFtdLFxuICAgICAgICBpbnRlcnNlY3Rpbmc6YW55ID0ge30sXG4gICAgICAgIGZpbHRlcmVkaW50ZXJzZWN0aW9ucyA9IFtdXG5cbiAgICAvLyBjb2xsZWN0IGxpc3RzIG9mIGluZGV4ZXNcbiAgICBmb3IgKGxldCBpdGVtIG9mIGhlYWRjb250ZW50KSB7XG4gICAgICAgIGhlYWRpbmRleGVzLnB1c2goaXRlbS5wcm9wcy5pbmRleClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpdGVtIG9mIHRhaWxjb250ZW50KSB7XG4gICAgICAgIHRhaWxpbmRleGVzLnB1c2goaXRlbS5wcm9wcy5pbmRleClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBlbnRyeSBvZiBpbnRlcnNlY3Rpb25zKSB7XG5cbiAgICAgICAgbGV0IGluZGV4ID0gcGFyc2VJbnQoZW50cnkudGFyZ2V0LmRhdGFzZXQuaW5kZXgpXG5cbiAgICAgICAgaWYgKHRhaWxpbmRleGVzLmluY2x1ZGVzKGluZGV4KSkge1xuXG4gICAgICAgICAgICB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcy5wdXNoKGluZGV4KVxuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbnMucHVzaChlbnRyeSlcblxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRpbmRleGVzLmluY2x1ZGVzKGluZGV4KSkge1xuXG4gICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcy5wdXNoKGluZGV4KVxuICAgICAgICAgICAgaGVhZGludGVyc2VjdGlvbnMucHVzaChlbnRyeSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3dhcm5pbmc6IHVua25vd24gaW50ZXJzZWN0aW9uIGVsZW1lbnQnLGVudHJ5KVxuICAgICAgICAgICAgcmV0dXJuIC8vIHNob3VsZG4ndCBoYXBwZW47IGdpdmUgdXBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByYXRpbyA9IE1hdGgucm91bmQoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gKiAxMDApLzEwMFxuICAgICAgICBpbnRlcnNlY3RpbmdbaW5kZXhdID0ge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW5nOnJhdGlvID49IElURU1fT0JTRVJWRVJfVEhSRVNIT0xELFxuICAgICAgICAgICAgaXNJbnRlcnNlY3Rpbmc6ZW50cnkuaXNJbnRlcnNlY3RpbmcsXG4gICAgICAgICAgICByYXRpb1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBsZXQgaW5kZXhjb21wYXJlID0gKGEsYikgPT4ge1xuICAgICAgICBsZXQgcmV0dmFsID0gKGEgPCBiKT8tMToxXG4gICAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG5cbiAgICBsZXQgZW50cnljb21wYXJlID0gKGEsYikgPT4ge1xuICAgICAgICBsZXQgcmV0dmFsID0gKHBhcnNlSW50KGEudGFyZ2V0LmRhdGFzZXQuaW5kZXgpIDwgcGFyc2VJbnQoYi50YXJnZXQuZGF0YXNldC5pbmRleCkpPyAtMToxXG4gICAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG5cbiAgICBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcy5zb3J0KGluZGV4Y29tcGFyZSlcbiAgICB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcy5zb3J0KGluZGV4Y29tcGFyZSlcblxuICAgIGhlYWRpbnRlcnNlY3Rpb25zLnNvcnQoZW50cnljb21wYXJlKVxuICAgIHRhaWxpbnRlcnNlY3Rpb25zLnNvcnQoZW50cnljb21wYXJlKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0lOUFVUIGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzLCB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcywgaW50ZXJzZWN0aW5nJyxcbiAgICAvLyAgICAgaGVhZGludGVyc2VjdGlvbmluZGV4ZXMsIHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzLCBpbnRlcnNlY3RpbmcpXG5cbiAgICAvLyBzZXQgcmVmZXJlbmNlIHBvaW50cyBpbiByZWxhdGlvbiB0byB0aGUgc3BpbmVcbiAgICBsZXQgaGVhZGluZGV4ID0gaGVhZGluZGV4ZXNbaGVhZGluZGV4ZXMubGVuZ3RoIC0gMV1cbiAgICBsZXQgdGFpbGluZGV4ID0gdGFpbGluZGV4ZXNbMF1cbiAgICBsZXQgaGVhZHB0ciA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzLmluZGV4T2YoaGVhZGluZGV4KVxuICAgIGxldCB0YWlscHRyID0gdGFpbGludGVyc2VjdGlvbmluZGV4ZXMuaW5kZXhPZih0YWlsaW5kZXgpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnaGVhZGluZGV4LCB0YWlsaW5kZXgsIGhlYWRwdHIsdGFpbHB0cicsXG4gICAgLy8gICAgIGhlYWRpbmRleCwgdGFpbGluZGV4LCBoZWFkcHRyLHRhaWxwdHIpXG4gICAgLy8gZmlsdGVyIG91dCBpdGVtcyB0aGF0IHJlZ2lzdGVyIG9ubHkgYmVjYXVzZSB0aGV5IGhhdmUganVzdCBiZWVuIG1vdmVkXG4gICAgaWYgKChoZWFkcHRyID49MCkgJiYgIWludGVyc2VjdGluZ1toZWFkaW5kZXhdLmludGVyc2VjdGluZykge1xuICAgICAgICBoZWFkcHRyID0gLTFcbiAgICB9XG5cbiAgICBpZiAoKHRhaWxwdHIgPj0wKSAmJiBpbnRlcnNlY3RpbmdbdGFpbGluZGV4XS5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgdGFpbHB0ciA9IC0xXG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBjb2xsZWN0IG5vdGlmaWNhdGlvbnMgdG8gbWFpbiB0aHJlYWQgKGZpbHRlcmVkIGludGVyc2VjdGlvbnMpXG4gICAgaWYgKGhlYWRwdHIgPj0gMCkge1xuXG4gICAgICAgIGxldCByZWZpbmRleCA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzW2hlYWRwdHJdICsgMVxuICAgICAgICBsZXQgcmVmaW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0aW5nW3JlZmluZGV4IC0gMV0uaW50ZXJzZWN0aW5nXG5cbiAgICAgICAgZm9yIChsZXQgcHRyID0gaGVhZHB0cjsgcHRyID49IDA7IHB0ci0tKSB7XG5cbiAgICAgICAgICAgIGxldCBpbmRleCA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzW3B0cl1cblxuICAgICAgICAgICAgLy8gdGVzdCBmb3IgY29udGludWl0eSBhbmQgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGlmICgoKGluZGV4ICsgMSkgPT0gcmVmaW5kZXgpICYmIChpbnRlcnNlY3RpbmdbaW5kZXhdLmludGVyc2VjdGluZyA9PSByZWZpbnRlcnNlY3RpbmcpKSB7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJlZGludGVyc2VjdGlvbnMucHVzaChoZWFkaW50ZXJzZWN0aW9uc1twdHJdKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWZpbmRleCA9IGluZGV4XG4gICAgICAgICAgICByZWZpbnRlcnNlY3RpbmcgPSBpbnRlcnNlY3RpbmdbcmVmaW5kZXhdLmludGVyc2VjdGluZ1xuXG4gICAgICAgIH1cbiAgICB9XG4gICAgIFxuICAgIGlmICh0YWlscHRyID49IDApIHtcblxuICAgICAgICBsZXQgcmVmaW5kZXggPSB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlc1t0YWlscHRyXSAtIDFcbiAgICAgICAgbGV0IHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tyZWZpbmRleCArIDFdLmludGVyc2VjdGluZ1xuXG4gICAgICAgIGZvciAobGV0IHB0ciA9IHRhaWxwdHI7IHB0ciA8IHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzLmxlbmd0aDsgcHRyKyspIHtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGFpbGludGVyc2VjdGlvbmluZGV4ZXNbcHRyXVxuXG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBjb250aW51aXR5IGFuZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RhaWwgY29udGludWl0eTogaW5kZXggLTEsIHJlZmluZGV4LCBpbnRlcnNlY3RpbmdbaW5kZXhdLmludGVyc2VjdGluZyxyZWZpbnRlcnNlY3RpbmcnLFxuICAgICAgICAgICAgLy8gICAgIGluZGV4IC0xLCByZWZpbmRleCwgaW50ZXJzZWN0aW5nW2luZGV4XSxyZWZpbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICBpZiAoKChpbmRleCAtIDEpID09IHJlZmluZGV4KSAmJiAoaW50ZXJzZWN0aW5nW2luZGV4XS5pbnRlcnNlY3RpbmcgPT0gcmVmaW50ZXJzZWN0aW5nKSkge1xuXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRpbnRlcnNlY3Rpb25zLnB1c2godGFpbGludGVyc2VjdGlvbnNbcHRyXSlcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVmaW5kZXggPSBpbmRleFxuICAgICAgICAgICAgcmVmaW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0aW5nW2luZGV4XS5pbnRlcnNlY3RpbmdcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkaW50ZXJzZWN0aW9uc1xuXG59XG5cbi8vIHVwZGF0ZSBjb250ZW50XG4vLyBhZGRzIGl0ZW1zaGVsbHMgYXQgZW5kIG9mIGNvbnRlbnRsaXN0IGFjY29yZGluZyB0byBoZWFkaW5kZXhjb3VudCBhbmQgdGFpbGluZGVzY291bnQsXG4vLyBvciBpZiBpbmRleGNvdW50IHZhbHVlcyBhcmUgPDAgcmVtb3ZlcyB0aGVtLlxuZXhwb3J0IGNvbnN0IGdldFVJQ29udGVudExpc3QgPSAocHJvcHMpID0+IHtcblxuICAgIGxldCB7IFxuXG4gICAgICAgIGluZGV4b2Zmc2V0LCBcbiAgICAgICAgaGVhZGluZGV4Y291bnQsIFxuICAgICAgICB0YWlsaW5kZXhjb3VudCwgXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGxvY2FsQ29udGVudExpc3Q6Y29udGVudGxpc3QsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuXG4gICAgICAgIGNhbGxiYWNrcyxcbiAgICAgICAgZ2V0SXRlbSxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9ic2VydmVyLFxuICAgIH0gPSBwcm9wc1xuXG4gICAgbGV0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgbGV0IHRhaWxpbmRleG9mZnNldCA9IGluZGV4b2Zmc2V0ICsgY29udGVudGxpc3QubGVuZ3RoXG4gICAgbGV0IHJldHVybkNvbnRlbnRsaXN0XG5cbiAgICBsZXQgaGVhZENvbnRlbnRsaXN0ID0gW11cblxuICAgIGlmIChoZWFkaW5kZXhjb3VudCA+PSAwKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBpbmRleG9mZnNldCAtIGhlYWRpbmRleGNvdW50OyBpbmRleCA8IChpbmRleG9mZnNldCk7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgaGVhZENvbnRlbnRsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgZW1pdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcywgXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSgwLC1oZWFkaW5kZXhjb3VudClcblxuICAgIH1cblxuICAgIGxldCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgaWYgKHRhaWxpbmRleGNvdW50ID49IDApIHtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRhaWxpbmRleG9mZnNldDsgaW5kZXggPCh0YWlsaW5kZXhvZmZzZXQgKyB0YWlsaW5kZXhjb3VudCk7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgdGFpbENvbnRlbnRsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgZW1pdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcywgXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSh0YWlsaW5kZXhjb3VudCwtdGFpbGluZGV4Y291bnQpXG5cbiAgICB9XG5cbiAgICByZXR1cm5Db250ZW50bGlzdCA9IGhlYWRDb250ZW50bGlzdC5jb25jYXQobG9jYWxDb250ZW50bGlzdCx0YWlsQ29udGVudGxpc3QpXG5cbiAgICByZXR1cm4gcmV0dXJuQ29udGVudGxpc3Rcbn1cblxuLy8gYnV0dGVyZmx5IG1vZGVsLiBMZWFkaW5nIChoZWFkKSBhbGwgb3IgcGFydGlhbGx5IGhpZGRlbjsgdGFpbCwgdmlzaWJsZSBwbHVzIGZvbGxvd2luZyBoaWRkZW5cbmV4cG9ydCBjb25zdCBhbGxvY2F0ZUNvbnRlbnRMaXN0ID0gKFxuICAgIHtcblxuICAgICAgICBjb250ZW50bGlzdCwgLy8gb2YgY3JhZGxlLCBpbiBpdGVtcyAoUmVhY3QgY29tcG9uZW50cylcbiAgICAgICAgcnVud2F5Y291bnQsIC8vIGluIHJvd3NcbiAgICAgICAgcmVmZXJlbmNlaW5kZXgsIC8vIGZpcnN0IHRhaWwgaXRlbVxuICAgICAgICBjcm9zc2NvdW50LFxuXG4gICAgfVxuKSA9PiB7XG5cbiAgICBsZXQgb2Zmc2V0aW5kZXggPSBjb250ZW50bGlzdFswXS5wcm9wcy5pbmRleFxuICAgIGxldCBydW53YXl0YWlsaW5kZXggPSBjb250ZW50bGlzdFsocnVud2F5Y291bnQgKiBjcm9zc2NvdW50KSAtIDFdLnByb3BzLmluZGV4XG4gICAgbGV0IGhlYWRpdGVtY291bnRcblxuICAgIC8vIGlmIChyZWZlcmVuY2VpbmRleCA8PSBydW53YXl0YWlsaW5kZXgpIHtcbiAgICAvLyAgICAgaGVhZGl0ZW1jb3VudCA9IChyZWZlcmVuY2VpbmRleCAtIG9mZnNldGluZGV4KVxuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAgIGhlYWRpdGVtY291bnQgPSAocnVud2F5Y291bnQgKiBjcm9zc2NvdW50KVxuICAgIC8vIH1cbiAgICBoZWFkaXRlbWNvdW50ID0gKHJlZmVyZW5jZWluZGV4IC0gb2Zmc2V0aW5kZXgpXG5cbiAgICBsZXQgaGVhZGxpc3QgPSBjb250ZW50bGlzdC5zbGljZSgwLGhlYWRpdGVtY291bnQpXG4gICAgbGV0IHRhaWxsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoaGVhZGl0ZW1jb3VudClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdoZWFkbGlzdCwgdGFpbGxpc3QnLCBbLi4uaGVhZGxpc3RdLCBbLi4udGFpbGxpc3RdKVxuXG4gICAgcmV0dXJuIFtoZWFkbGlzdCx0YWlsbGlzdF1cblxufVxuXG5leHBvcnQgY29uc3QgZ2V0U3BpbmVQb3NSZWYgPSAoXG4gICAge1xuICAgICAgICBzY3JvbGxmb3J3YXJkLFxuICAgICAgICBpdGVtZWxlbWVudHMsIFxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIHNwaW5lRWxlbWVudCxcbiAgICAgICAgcmVmZXJlbmNlaW5kZXgsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcmVmZXJlbmNlc2hpZnQsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3JlZmVyZW5jZWluZGV4LCByZWZlcmVuY2VzaGlmdCcscmVmZXJlbmNlaW5kZXgsIHJlZmVyZW5jZXNoaWZ0KVxuXG4gICAgbGV0IHNwaW5lcG9zYmFzZSxzcGluZXBvc3JlZlxuICAgIHZhciBsb2NhbHJlZmluZGV4ID0gcmVmZXJlbmNlaW5kZXhcbiAgICBpZiAoIXNjcm9sbGZvcndhcmQpIHtcbiAgICAgICAgLy8gbG9jYWxyZWZpbmRleCArPSBjcm9zc2NvdW50XG4gICAgICAgIGxvY2FscmVmaW5kZXggKz0gcmVmZXJlbmNlc2hpZnRcbiAgICB9XG4gICAgbGV0IHJlZmVyZW5jZW9iamVjdHMgPSBbXVxuICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7XG4gICAgICAgIHJlZmVyZW5jZW9iamVjdHMucHVzaChpdGVtZWxlbWVudHMuZ2V0KGxvY2FscmVmaW5kZXgpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gbG9jYWxyZWZpbmRleDsgaW5kZXggPiByZWZlcmVuY2VpbmRleDsgaW5kZXggLT0gY3Jvc3Njb3VudCApIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZW9iamVjdHMucHVzaChpdGVtZWxlbWVudHMuZ2V0KGluZGV4KSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVmZXJlbmNlcG9zc2hpZnRcblxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIHNwaW5lcG9zYmFzZSA9IHNwaW5lRWxlbWVudC5vZmZzZXRUb3BcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcGluZXBvc2Jhc2UgPSBzcGluZUVsZW1lbnQub2Zmc2V0TGVmdFxuICAgIH1cbiAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuICAgICAgICBsZXQgcmVmZXJlbmNlZWxlbWVudCA9IHJlZmVyZW5jZW9iamVjdHNbMF0uY3VycmVudFxuICAgICAgICBpZiAocmVmZXJlbmNlZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hlYWRpbmRleCwgaGVhZGVsZW1lbnQub2Zmc2V0VG9wJyxoZWFkaW5kZXgsaGVhZGVsZW1lbnQub2Zmc2V0VG9wKVxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2Vwb3NzaGlmdCA9IHJlZmVyZW5jZWVsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXBvc3NoaWZ0ID0gcmVmZXJlbmNlZWxlbWVudC5vZmZzZXRMZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZWZlcmVuY2Vwb3NzaGlmdCA9IDBcbiAgICAgICAgZm9yIChsZXQgcmVmb2JqIG9mIHJlZmVyZW5jZW9iamVjdHMpIHtcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlcG9zc2hpZnQgKz0gcmVmb2JqLmN1cnJlbnQub2Zmc2V0SGVpZ2h0ICsgZ2FwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXBvc3NoaWZ0ICs9IHJlZm9iai5jdXJyZW50Lm9mZnNldFdpZHRoICsgZ2FwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3JlZmVyZW5jZWluZGV4LCBsb2NhbHJlZmluZGV4LCBzY3JvbGxmb3J3YXJkLHJlZmVyZW5jZXNoaWZ0LCByZWZlcmVuY2Vwb3NzaGlmdCwgcmVmZXJlbmNlZWxlbWVudC5vZmZzZXRUb3AsIHJlZmVyZW5jZWVsZW1lbnQub2Zmc2V0SGVpZ2h0LCBnYXAsIHJlZmVyZW5jZWVsZW1lbnQnLFxuICAgIC8vICAgICByZWZlcmVuY2VpbmRleCwgbG9jYWxyZWZpbmRleCwgc2Nyb2xsZm9yd2FyZCxyZWZlcmVuY2VzaGlmdCwgcmVmZXJlbmNlcG9zc2hpZnQsIHJlZmVyZW5jZWVsZW1lbnQub2Zmc2V0VG9wLCByZWZlcmVuY2VlbGVtZW50Lm9mZnNldEhlaWdodCwgZ2FwLCByZWZlcmVuY2VlbGVtZW50KVxuXG4gICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcbiAgICAgICAgc3BpbmVwb3NyZWYgPSBzcGluZXBvc2Jhc2UgKyByZWZlcmVuY2Vwb3NzaGlmdFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaW5lcG9zcmVmID0gc3BpbmVwb3NiYXNlIC0gcmVmZXJlbmNlcG9zc2hpZnRcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnaW4gZ2V0U3BpbmVQb3NSZWYgcmVmZXJlbmNlb2JqZWN0LCBzY3JvbGxmb3J3YXJkLCBzcGluZXBvc2Jhc2UsIGxvY2FscmVmaW5kZXgsIHJlZmVyZW5jZXBvc3NoaWZ0LCBzcGluZXBvc3JlZicsXG4gICAgLy8gICAgIHJlZmVyZW5jZW9iamVjdCwgc2Nyb2xsZm9yd2FyZCwgc3BpbmVwb3NiYXNlLCBsb2NhbHJlZmluZGV4LCByZWZlcmVuY2Vwb3NzaGlmdCwgc3BpbmVwb3NyZWYpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnc3BpbmVwb3NyZWYnLCBzcGluZXBvc3JlZilcblxuICAgIHJldHVybiBzcGluZXBvc3JlZlxufVxuXG5jb25zdCBlbWl0SXRlbSA9ICh7XG4gICAgaW5kZXgsIFxuICAgIG9yaWVudGF0aW9uLCBcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIG9ic2VydmVyLCBcbiAgICBjYWxsYmFja3MsIFxuICAgIGdldEl0ZW0sIFxuICAgIGxpc3RzaXplLCBcbiAgICBwbGFjZWhvbGRlclxufSkgPT4ge1xuXG4gICAgcmV0dXJuIDxJdGVtU2hlbGxcbiAgICAgICAga2V5ID0ge2luZGV4fSBcbiAgICAgICAgb3JpZW50YXRpb24gPSB7b3JpZW50YXRpb259XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgIGluZGV4ID0ge2luZGV4fVxuICAgICAgICBvYnNlcnZlciA9IHtvYnNlcnZlcn1cbiAgICAgICAgY2FsbGJhY2tzID0ge2NhbGxiYWNrc31cbiAgICAgICAgZ2V0SXRlbSA9IHtnZXRJdGVtfVxuICAgICAgICBsaXN0c2l6ZSA9IHtsaXN0c2l6ZX1cbiAgICAgICAgcGxhY2Vob2xkZXIgPSB7IHBsYWNlaG9sZGVyIH1cbiAgICAvPiAgICBcblxufVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzdHlsZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3Qgc2V0Q3JhZGxlR3JpZFN0eWxlcyA9ICh7XG5cbiAgICBvcmllbnRhdGlvbiwgXG4gICAgaGVhZENyYWRsZVN0eWxlczpoZWFkc3R5bGVzb2JqZWN0LCBcbiAgICB0YWlsQ3JhZGxlU3R5bGVzOnRhaWxzdHlsZXNvYmplY3QsXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBnYXAsXG4gICAgcGFkZGluZywgXG4gICAgY3Jvc3Njb3VudCwgXG4gICAgdmlld3BvcnRoZWlnaHQsIFxuICAgIHZpZXdwb3J0d2lkdGhcblxufSkgPT4ge1xuXG4gICAgICAgIGxldCBoZWFkc3R5bGVzID0gey4uLmhlYWRzdHlsZXNvYmplY3R9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICAgICAgbGV0IHRhaWxzdHlsZXMgPSB7Li4udGFpbHN0eWxlc29iamVjdH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuXG4gICAgICAgIGhlYWRzdHlsZXMuZ3JpZEdhcCA9IGdhcCArICdweCdcblxuICAgICAgICB0YWlsc3R5bGVzLmdyaWRHYXAgPSBnYXAgKyAncHgnXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykge1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ2NvbHVtbidcbiAgICAgICAgICAgIC8vIGV4cGxpY3QgY3Jvc3Njb3VudCBuZXh0IGxpbmUgYXMgd29ya2Fyb3VuZCBmb3IgRkYgcHJvYmxlbSAtIFxuICAgICAgICAgICAgLy8gICAgIHNldHMgbGVuZ3RoIG9mIGhvcml6IGNyYWRsZSBpdGVtcyBpbiBvbmUgbGluZSAocm93KSwgbm90IG11bHRpLXJvdyBjb25maWdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IGNlbGxIZWlnaHQ/YHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsSGVpZ2h0fXB4LCAxZnIpKWA6J2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSAnbm9uZSdcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBgXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMud2lkdGggPSAnYXV0bydcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdjb2x1bW4nXG4gICAgICAgICAgICAvLyBleHBsaWN0IGNyb3NzY291bnQgbmV4dCBsaW5lIGFzIHdvcmthcm91bmQgZm9yIEZGIHByb2JsZW0gLSBcbiAgICAgICAgICAgIC8vICAgICBzZXRzIGxlbmd0aCBvZiBob3JpeiBjcmFkbGUgaXRlbXMgaW4gb25lIGxpbmUgKHJvdyksIG5vdCBtdWx0aS1yb3cgY29uZmlnXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSBjZWxsSGVpZ2h0P2ByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgOidhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJ25vbmUnXG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSAnbm9uZSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IGNlbGxXaWR0aD9gcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoJHtjZWxsV2lkdGh9cHgsIDFmcikpYDonYXV0bydcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdyb3cnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9ICdub25lJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gY2VsbFdpZHRoP2ByZXBlYXQoYXV0by1maXQsIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgOidhdXRvJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtoZWFkc3R5bGVzLHRhaWxzdHlsZXNdXG4gICAgICAgIFxufVxuXG4vLyBleHBvcnQgY29uc3Qgc2V0Q3JhZGxlU3R5bGVSZXZpc2lvbnNGb3JEcm9wID0gKHsgXG4vLyAgICAgaGVhZGNvbnRlbnRsaXN0LFxuLy8gICAgIHRhaWxjb250ZW50bGlzdCxcbi8vICAgICBoZWFkQ3JhZGxlRWxlbWVudCxcbi8vICAgICB0YWlsQ3JhZGxlRWxlbWVudCwgXG4vLyAgICAgcGFyZW50RWxlbWVudCwgXG4vLyAgICAgc2Nyb2xsZm9yd2FyZCwgXG4vLyAgICAgb3JpZW50YXRpb24gXG4vLyB9KSA9PiB7XG5cbi8vICAgICBsZXQgc3R5bGVzID0ge30gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuLy8gICAgIGxldCB0YWlsc3R5bGVzID0ge30gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuLy8gICAgIGxldCBoZWFkcG9zLCB0YWlscG9zXG5cbi8vICAgICAvLyBzZXQgc3R5bGVzIHJldmlzaW9uc1xuLy8gICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbi8vICAgICAgICAgbGV0IG9mZnNldEhlaWdodCA9IGhlYWRDcmFkbGVFbGVtZW50Lm9mZnNldEhlaWdodFxuLy8gICAgICAgICBsZXQgcGFyZW50SGVpZ2h0ID0gcGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHRcblxuLy8gICAgICAgICBsZXQgb2Zmc2V0VG9wID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0VG9wXG5cbi8vICAgICAgICAgc3R5bGVzLmxlZnQgPSAnYXV0bydcbi8vICAgICAgICAgc3R5bGVzLnJpZ2h0ID0gJ2F1dG8nXG5cbi8vICAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuLy8gICAgICAgICAgICAgdGFpbHBvcyA9IG9mZnNldFRvcCArIG9mZnNldEhlaWdodFxuLy8gICAgICAgICAgICAgc3R5bGVzLnRvcCA9ICdhdXRvJ1xuLy8gICAgICAgICAgICAgc3R5bGVzLmJvdHRvbSA9IChwYXJlbnRIZWlnaHQgLSB0YWlscG9zKSArICdweCdcblxuLy8gICAgICAgICB9IGVsc2Uge1xuXG4vLyAgICAgICAgICAgICBoZWFkcG9zID0gb2Zmc2V0VG9wXG4vLyAgICAgICAgICAgICBzdHlsZXMudG9wID0gaGVhZHBvcyArICdweCdcbi8vICAgICAgICAgICAgIHN0eWxlcy5ib3R0b20gPSAnYXV0bydcblxuLy8gICAgICAgICB9XG5cbi8vICAgICB9IGVsc2Uge1xuXG4vLyAgICAgICAgIGxldCBvZmZzZXRMZWZ0ID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0TGVmdFxuLy8gICAgICAgICBsZXQgb2Zmc2V0V2lkdGggPSBoZWFkQ3JhZGxlRWxlbWVudC5vZmZzZXRXaWR0aFxuLy8gICAgICAgICBsZXQgcGFyZW50V2lkdGggPSBwYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoXG4vLyAgICAgICAgIGxldCBjc3NsZWZ0ID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUubGVmdClcbi8vICAgICAgICAgbGV0IGNzc3JpZ2h0ID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUuYm90dG9tKVxuXG4vLyAgICAgICAgIHN0eWxlcy50b3AgPSAnYXV0bydcbi8vICAgICAgICAgc3R5bGVzLmJvdHRvbSA9ICdhdXRvJ1xuXG4vLyAgICAgICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7XG5cbi8vICAgICAgICAgICAgIHRhaWxwb3MgPSBvZmZzZXRMZWZ0ICsgb2Zmc2V0V2lkdGhcbi8vICAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gJ2F1dG8nXG4vLyAgICAgICAgICAgICBzdHlsZXMucmlnaHQgPSAocGFyZW50V2lkdGggLSB0YWlscG9zKSArICdweCdcblxuLy8gICAgICAgICB9IGVsc2Uge1xuXG4vLyAgICAgICAgICAgICBoZWFkcG9zID0gb2Zmc2V0TGVmdFxuLy8gICAgICAgICAgICAgc3R5bGVzLmxlZnQgPSBoZWFkcG9zICsgJ3B4J1xuLy8gICAgICAgICAgICAgc3R5bGVzLnJpZ2h0ID0gJ2F1dG8nXG5cbi8vICAgICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIHJldHVybiBbc3R5bGVzLHRhaWxzdHlsZXNdXG5cbi8vIH1cblxuLy8gZXhwb3J0IGNvbnN0IHNldENyYWRsZVN0eWxlUmV2aXNpb25zRm9yQWRkID0gKHtcbi8vICAgICBoZWFkY29udGVudGxpc3QsXG4vLyAgICAgdGFpbGNvbnRlbnRsaXN0LFxuLy8gICAgIGhlYWRDcmFkbGVFbGVtZW50LFxuLy8gICAgIHRhaWxDcmFkbGVFbGVtZW50LFxuLy8gICAgIHBhcmVudEVsZW1lbnQsXG4vLyAgICAgc2Nyb2xsZm9yd2FyZCxcbi8vICAgICBvcmllbnRhdGlvbixcbi8vIH0pID0+IHtcbi8vICAgICBsZXQgc3R5bGVzID0ge30gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuLy8gICAgIGxldCB0YWlsc3R5bGVzID0ge30gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuLy8gICAgIGxldCBoZWFkcG9zLCB0YWlscG9zXG5cbi8vICAgICAvLyBzZXQgc3R5bGUgcmV2aXNpb25zXG4vLyAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuLy8gICAgICAgICAvLyBsZXQgb2Zmc2V0VG9wXG4vLyAgICAgICAgIGxldCBvZmZzZXRIZWlnaHQgPSBoZWFkQ3JhZGxlRWxlbWVudC5vZmZzZXRIZWlnaHRcbi8vICAgICAgICAgbGV0IHBhcmVudEhlaWdodCA9IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4vLyAgICAgICAgIGxldCBjc3N0b3AgPSBwYXJzZUludChoZWFkQ3JhZGxlRWxlbWVudC5zdHlsZS50b3ApXG4vLyAgICAgICAgIGxldCBjc3Nib3R0b20gPSBwYXJzZUludChoZWFkQ3JhZGxlRWxlbWVudC5zdHlsZS5ib3R0b20pXG4vLyAgICAgICAgIGxldCBvZmZzZXRUb3AgPSBoZWFkQ3JhZGxlRWxlbWVudC5vZmZzZXRUb3BcblxuLy8gICAgICAgICBzdHlsZXMubGVmdCA9ICdhdXRvJ1xuLy8gICAgICAgICBzdHlsZXMucmlnaHQgPSAnYXV0bydcblxuLy8gICAgICAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuXG4vLyAgICAgICAgICAgICBoZWFkcG9zID0gb2Zmc2V0VG9wXG4vLyAgICAgICAgICAgICBzdHlsZXMudG9wID0gaGVhZHBvcyArICdweCdcbi8vICAgICAgICAgICAgIHN0eWxlcy5ib3R0b20gPSAnYXV0bydcblxuLy8gICAgICAgICB9IGVsc2UgeyAvLyBzY3JvbGwgYmFja3dhcmRcblxuLy8gICAgICAgICAgICAgdGFpbHBvcyA9IG9mZnNldFRvcCArIG9mZnNldEhlaWdodFxuLy8gICAgICAgICAgICAgc3R5bGVzLnRvcCA9ICdhdXRvJ1xuLy8gICAgICAgICAgICAgc3R5bGVzLmJvdHRvbSA9IChwYXJlbnRIZWlnaHQgLSB0YWlscG9zKSArICdweCdcblxuLy8gICAgICAgICB9XG5cbi8vICAgICB9IGVsc2Uge1xuXG4vLyAgICAgICAgIGxldCBvZmZzZXRMZWZ0ID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0TGVmdFxuLy8gICAgICAgICBsZXQgb2Zmc2V0V2lkdGggPSBoZWFkQ3JhZGxlRWxlbWVudC5vZmZzZXRXaWR0aFxuLy8gICAgICAgICBsZXQgcGFyZW50V2lkdGggPSBwYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoXG5cbi8vICAgICAgICAgbGV0IGNzc2xlZnQgPSBwYXJzZUludChoZWFkQ3JhZGxlRWxlbWVudC5zdHlsZS5sZWZ0KVxuLy8gICAgICAgICBsZXQgY3NzcmlnaHQgPSBwYXJzZUludChoZWFkQ3JhZGxlRWxlbWVudC5zdHlsZS5ib3R0b20pXG5cbi8vICAgICAgICAgc3R5bGVzLnRvcCA9ICdhdXRvJ1xuLy8gICAgICAgICBzdHlsZXMuYm90dG9tID0gJ2F1dG8nXG5cbi8vICAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuLy8gICAgICAgICAgICAgaGVhZHBvcyA9IG9mZnNldExlZnRcbi8vICAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gaGVhZHBvcyArICdweCdcbi8vICAgICAgICAgICAgIHN0eWxlcy5yaWdodCA9ICdhdXRvJ1xuXG4vLyAgICAgICAgIH0gZWxzZSB7IC8vIHNjcm9sbCBiYWNrd2FyZFxuXG4vLyAgICAgICAgICAgICB0YWlscG9zID0gb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoXG4vLyAgICAgICAgICAgICBzdHlsZXMubGVmdCA9ICdhdXRvJ1xuLy8gICAgICAgICAgICAgc3R5bGVzLnJpZ2h0ID0gKHBhcmVudFdpZHRoIC0gdGFpbHBvcykgKyAncHgnXG5cbi8vICAgICAgICAgfVxuXG4vLyAgICAgfVxuXG4vLyAgICAgcmV0dXJuIFtzdHlsZXMsIHRhaWxzdHlsZXNdXG5cbi8vIH0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval(" // itemframe.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nvar requestidlecallback_1 = __webpack_require__(11);\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(2));\n\nvar placeholder_1 = __importDefault(__webpack_require__(12));\n\nvar ItemShell = function ItemShell(props) {\n  var orientation = props.orientation,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      index = props.index,\n      observer = props.observer,\n      callbacks = props.callbacks,\n      getItem = props.getItem,\n      listsize = props.listsize,\n      placeholder = props.placeholder;\n\n  var _a = react_1.useState(null),\n      content = _a[0],\n      saveContent = _a[1];\n\n  var _b = react_1.useState(null),\n      error = _b[0],\n      saveError = _b[1];\n\n  var _c = react_1.useState({\n    overflow: 'hidden'\n  }),\n      styles = _c[0],\n      saveStyles = _c[1];\n\n  var shellRef = react_1.useRef(null);\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // initialize\n\n  react_1.useEffect(function () {\n    var itemrequest = {\n      current: null\n    };\n    var requestidlecallback = window['requestIdleCallback'] ? window['requestIdleCallback'] : requestidlecallback_1.requestIdleCallback;\n    var cancelidlecallback = window['cancelIdleCallback'] ? window['cancelIdleCallback'] : requestidlecallback_1.cancelIdleCallback;\n\n    if (getItem) {\n      itemrequest = requestidlecallback(function () {\n        var value = getItem(index);\n\n        if (value && value.then) {\n          value.then(function (value) {\n            if (isMounted()) {\n              saveContent(value);\n              saveError(null);\n            }\n          })[\"catch\"](function (e) {\n            saveContent(null);\n            saveError(e);\n          });\n        } else {\n          if (isMounted()) {\n            if (value) {\n              saveContent(value);\n              saveError(null);\n            } else {\n              saveError(true);\n              saveContent(null);\n            }\n          }\n        }\n      }, {\n        timeout: 2000\n      });\n    }\n\n    return function () {\n      var requesthandle = itemrequest.current;\n      cancelidlecallback(requesthandle);\n    };\n  }, []); // initialize\n\n  react_1.useEffect(function () {\n    var localcalls = callbacks;\n    localcalls.getElementData && localcalls.getElementData(getElementData(), 'register');\n    return function () {\n      localcalls.getElementData && localcalls.getElementData(getElementData(), 'unregister');\n    };\n  }, [callbacks]);\n  react_1.useEffect(function () {\n    observer.observe(shellRef.current); // console.log('OBSERVE index',index)\n\n    return function () {\n      // console.log('UNOBSERVE index',index)\n      observer.unobserve(shellRef.current);\n    };\n  }, [observer]);\n  react_1.useEffect(function () {\n    var newStyles = getShellStyles(orientation, cellHeight, cellWidth, styles);\n\n    if (isMounted()) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth]); // cradle ondemand callback parameter value\n\n  var getElementData = react_1.useCallback(function () {\n    return [index, shellRef];\n  }, []); // placeholder handling\n\n  var customholderRef = react_1.useRef(placeholder ? react_1[\"default\"].createElement(placeholder, {\n    index: index,\n    listsize: listsize\n  }) : null);\n  return react_1[\"default\"].createElement(\"div\", {\n    ref: shellRef,\n    \"data-index\": index,\n    style: styles\n  }, styles.width ? content ? content : customholderRef.current ? customholderRef.current : react_1[\"default\"].createElement(placeholder_1[\"default\"], {\n    index: index,\n    listsize: listsize,\n    error: error\n  }) : null);\n}; // ItemShell\n// TODO: memoize this\n\n\nvar getShellStyles = function getShellStyles(orientation, cellHeight, cellWidth, styles) {\n  var styleset = Object.assign({\n    position: 'relative'\n  }, styles);\n\n  if (orientation == 'horizontal') {\n    styleset.width = cellWidth ? cellWidth + 'px' : 'auto';\n    styleset.height = 'auto';\n  } else if (orientation === 'vertical') {\n    styleset.width = 'auto';\n    styleset.height = cellHeight ? cellHeight + 'px' : 'auto';\n  }\n\n  return styleset;\n};\n\nexports[\"default\"] = ItemShell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pdGVtc2hlbGwudHN4P2ZhYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQU0sU0FBUyxHQUFHLFNBQVosU0FBWSxDQUFDLEtBQUQsRUFBTTtBQUNiO0FBQUEsTUFBYSw2QkFBYjtBQUFBLE1BQXlCLDJCQUF6QjtBQUFBLE1BQW9DLG1CQUFwQztBQUFBLE1BQTJDLHlCQUEzQztBQUFBLE1BQXFELDJCQUFyRDtBQUFBLE1BQWdFLHVCQUFoRTtBQUFBLE1BQXlFLHlCQUF6RTtBQUFBLE1BQW1GLCtCQUFuRjs7QUFFRDtBQUFBLE1BQUMsZUFBRDtBQUFBLE1BQVUsbUJBQVY7O0FBQ0E7QUFBQSxNQUFDLGFBQUQ7QUFBQSxNQUFRLGlCQUFSOztBQUNBOztBQUFBO0FBQUEsTUFBQyxjQUFEO0FBQUEsTUFBUSxrQkFBUjs7QUFHTixNQUFNLFFBQVEsR0FBRyxlQUFPLElBQVAsQ0FBakI7QUFFQSxNQUFNLFNBQVMsR0FBRyxvQ0FBbEIsQ0FWb0IsQ0FZcEI7O0FBQ0Esb0JBQVU7QUFDTixRQUFJLFdBQVcsR0FBRztBQUFDLGFBQU8sRUFBQztBQUFULEtBQWxCO0FBQ0EsUUFBSSxtQkFBbUIsR0FBRyxNQUFNLENBQUMscUJBQUQsQ0FBTixHQUE4QixNQUFNLENBQUMscUJBQUQsQ0FBcEMsR0FBNEQseUNBQXRGO0FBQ0EsUUFBSSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsb0JBQUQsQ0FBTixHQUE2QixNQUFNLENBQUMsb0JBQUQsQ0FBbkMsR0FBMEQsd0NBQW5GOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1QsaUJBQVcsR0FBRyxtQkFBbUIsQ0FBQztBQUU5QixZQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBRCxDQUFuQjs7QUFDQSxZQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBbkIsRUFBeUI7QUFDckIs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QztBQUU5RCxNQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjO0FBQUMsWUFBUSxFQUFDO0FBQVYsR0FBZCxFQUFvQyxNQUFwQyxDQUFmOztBQUNBLE1BQUksV0FBVyxJQUFJLFlBQW5CLEVBQWlDO0FBQzdCLFlBQVEsQ0FBQyxLQUFULEdBQWlCLFNBQVMsR0FBRSxTQUFTLEdBQUcsSUFBZCxHQUFvQixNQUE5QztBQUNBLFlBQVEsQ0FBQyxNQUFULEdBQWtCLE1BQWxCO0FBQ0gsR0FIRCxNQUdPLElBQUksV0FBVyxLQUFLLFVBQXBCLEVBQWdDO0FBQ25DLFlBQVEsQ0FBQyxLQUFULEdBQWlCLE1BQWpCO0FBQ0EsWUFBUSxDQUFDLE1BQVQsR0FBa0IsVUFBVSxHQUFFLFVBQVUsR0FBRyxJQUFmLEdBQXFCLE1BQWpEO0FBQ0g7O0FBRUQsU0FBTyxRQUFQO0FBRUgsQ0FiRDs7QUFlQSxxQkFBZSxTQUFmIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaXRlbWZyYW1lLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHtyZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2t9IGZyb20gJ3JlcXVlc3RpZGxlY2FsbGJhY2snXG5cbmltcG9ydCB1c2VJc01vdW50ZWQgZnJvbSAncmVhY3QtaXMtbW91bnRlZC1ob29rJ1xuXG5pbXBvcnQgUGxhY2Vob2xkZXIgZnJvbSAnLi9wbGFjZWhvbGRlcidcblxuY29uc3QgSXRlbVNoZWxsID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3Qge29yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGluZGV4LCBvYnNlcnZlciwgY2FsbGJhY2tzLCBnZXRJdGVtLCBsaXN0c2l6ZSwgcGxhY2Vob2xkZXJ9ID0gcHJvcHNcbiAgICBcbiAgICBjb25zdCBbY29udGVudCwgc2F2ZUNvbnRlbnRdID0gdXNlU3RhdGUobnVsbClcbiAgICBjb25zdCBbZXJyb3IsIHNhdmVFcnJvcl0gPSB1c2VTdGF0ZShudWxsKVxuICAgIGNvbnN0IFtzdHlsZXMsc2F2ZVN0eWxlc10gPSB1c2VTdGF0ZSh7XG4gICAgICAgIG92ZXJmbG93OidoaWRkZW4nLFxuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcylcbiAgICBjb25zdCBzaGVsbFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKClcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaXRlbXJlcXVlc3QgPSB7Y3VycmVudDpudWxsfVxuICAgICAgICBsZXQgcmVxdWVzdGlkbGVjYWxsYmFjayA9IHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddP3dpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddOnJlcXVlc3RJZGxlQ2FsbGJhY2tcbiAgICAgICAgbGV0IGNhbmNlbGlkbGVjYWxsYmFjayA9IHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ10/d2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXTpjYW5jZWxJZGxlQ2FsbGJhY2tcbiAgICAgICAgaWYgKGdldEl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW1yZXF1ZXN0ID0gcmVxdWVzdGlkbGVjYWxsYmFjaygoKT0+IHtcblxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEl0ZW0oaW5kZXgpXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQoKSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29udGVudCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDb250ZW50KG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IoZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDb250ZW50KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVFcnJvcihudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29udGVudChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSx7dGltZW91dDoyMDAwfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdGhhbmRsZSA9IGl0ZW1yZXF1ZXN0LmN1cnJlbnRcbiAgICAgICAgICAgIGNhbmNlbGlkbGVjYWxsYmFjayhyZXF1ZXN0aGFuZGxlKVxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGxldCBsb2NhbGNhbGxzID0gY2FsbGJhY2tzXG5cbiAgICAgICAgbG9jYWxjYWxscy5nZXRFbGVtZW50RGF0YSAmJiBsb2NhbGNhbGxzLmdldEVsZW1lbnREYXRhKGdldEVsZW1lbnREYXRhKCksJ3JlZ2lzdGVyJylcbiAgICAgICAgcmV0dXJuICgoKT0+e1xuXG4gICAgICAgICAgICBsb2NhbGNhbGxzLmdldEVsZW1lbnREYXRhICYmIGxvY2FsY2FsbHMuZ2V0RWxlbWVudERhdGEoZ2V0RWxlbWVudERhdGEoKSwndW5yZWdpc3RlcicpXG5cbiAgICAgICAgfSlcblxuICAgIH0sW2NhbGxiYWNrc10pXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHNoZWxsUmVmLmN1cnJlbnQpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdPQlNFUlZFIGluZGV4JyxpbmRleClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1VOT0JTRVJWRSBpbmRleCcsaW5kZXgpXG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoc2hlbGxSZWYuY3VycmVudClcbiAgICAgICAgfVxuXG4gICAgfSxbb2JzZXJ2ZXJdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgbGV0IG5ld1N0eWxlcyA9IGdldFNoZWxsU3R5bGVzKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcylcbiAgICAgICAgaWYgKGlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICBzYXZlU3R5bGVzKG5ld1N0eWxlcylcbiAgICAgICAgfVxuXG4gICAgfSxbb3JpZW50YXRpb24sY2VsbEhlaWdodCxjZWxsV2lkdGhdKVxuXG4gICAgLy8gY3JhZGxlIG9uZGVtYW5kIGNhbGxiYWNrIHBhcmFtZXRlciB2YWx1ZVxuICAgIGNvbnN0IGdldEVsZW1lbnREYXRhID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgcmV0dXJuIFtpbmRleCwgc2hlbGxSZWZdXG4gICAgfSxbXSlcblxuICAgIC8vIHBsYWNlaG9sZGVyIGhhbmRsaW5nXG4gICAgY29uc3QgY3VzdG9taG9sZGVyUmVmID0gdXNlUmVmKHBsYWNlaG9sZGVyP1JlYWN0LmNyZWF0ZUVsZW1lbnQocGxhY2Vob2xkZXIsIHtpbmRleCwgbGlzdHNpemV9KTpudWxsKVxuXG4gICAgcmV0dXJuIDxkaXYgcmVmID0geyBzaGVsbFJlZiB9IGRhdGEtaW5kZXggPSB7aW5kZXh9IHN0eWxlID0ge3N0eWxlc30+XG4gICAgICAgIHtzdHlsZXMud2lkdGg/XG4gICAgICAgICAgICBjb250ZW50P1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6Y3VzdG9taG9sZGVyUmVmLmN1cnJlbnQ/XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWhvbGRlclJlZi5jdXJyZW50OjxQbGFjZWhvbGRlciBpbmRleCA9IHtpbmRleH0gbGlzdHNpemUgPSB7bGlzdHNpemV9IGVycm9yID0ge2Vycm9yfS8+XG4gICAgICAgIDpudWxsfVxuICAgIDwvZGl2PlxuXG59IC8vIEl0ZW1TaGVsbFxuXG4vLyBUT0RPOiBtZW1vaXplIHRoaXNcbmNvbnN0IGdldFNoZWxsU3R5bGVzID0gKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcykgPT4ge1xuXG4gICAgbGV0IHN0eWxlc2V0ID0gT2JqZWN0LmFzc2lnbih7cG9zaXRpb246J3JlbGF0aXZlJ30sc3R5bGVzKVxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSBjZWxsV2lkdGg/KGNlbGxXaWR0aCArICdweCcpOidhdXRvJ1xuICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSAnYXV0bydcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHN0eWxlc2V0LndpZHRoID0gJ2F1dG8nXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IGNlbGxIZWlnaHQ/KGNlbGxIZWlnaHQgKyAncHgnKTonYXV0bydcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzZXRcblxufVxuXG5leHBvcnQgZGVmYXVsdCBJdGVtU2hlbGxcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof global != undefined ?\n\t\t\tglobal :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxLQUFLLElBQTBDO0FBQy9DLEVBQUUsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3JCLEVBQUUsTUFBTSxFQUlOO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyx5REFBeUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixpREFBaUQ7QUFDbkk7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){"use strict";eval(" // placeholder.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nvar Placeholder = function Placeholder(_a) {\n  var index = _a.index,\n      listsize = _a.listsize,\n      error = _a.error;\n  var stylesRef = react_1.useRef({\n    position: 'relative',\n    boxSizing: 'border-box',\n    backgroundColor: 'cyan',\n    border: '2px solid black',\n    height: '100%',\n    width: '100%'\n  });\n  var itemStylesRef = react_1.useRef({\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    padding: '3px',\n    opacity: .5,\n    borderRadius: '8px',\n    backgroundColor: 'white',\n    margin: '3px',\n    fontSize: 'smaller'\n  });\n  return react_1[\"default\"].createElement(\"div\", {\n    style: stylesRef.current\n  }, !error ? react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, index + 1, \"/\", listsize) : react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, \"item is not available at this time\"));\n};\n\nexports[\"default\"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9wbGFjZWhvbGRlci50c3g/MTEzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQUF5QjtNQUF2QixnQjtNQUFPLHNCO01BQVUsZ0I7QUFFbkMsTUFBTSxTQUFTLEdBQUcsZUFBTztBQUNyQixZQUFRLEVBQUMsVUFEWTtBQUVyQixhQUFTLEVBQUMsWUFGVztBQUdyQixtQkFBZSxFQUFDLE1BSEs7QUFJckIsVUFBTSxFQUFDLGlCQUpjO0FBS3JCLFVBQU0sRUFBQyxNQUxjO0FBTXJCLFNBQUssRUFBQztBQU5lLEdBQVAsQ0FBbEI7QUFRQSxNQUFNLGFBQWEsR0FBRyxlQUNsQjtBQUNJLFlBQVEsRUFBQyxVQURiO0FBRUksT0FBRyxFQUFDLENBRlI7QUFHSSxRQUFJLEVBQUMsQ0FIVDtBQUlJLFdBQU8sRUFBQyxLQUpaO0FBS0ksV0FBTyxFQUFDLEVBTFo7QUFNSSxnQkFBWSxFQUFDLEtBTmpCO0FBT0ksbUJBQWUsRUFBQyxPQVBwQjtBQVFJLFVBQU0sRUFBQyxLQVJYO0FBU0ksWUFBUSxFQUFDO0FBVGIsR0FEa0IsQ0FBdEI7QUFjQSxTQUFPO0FBQUssU0FBSyxFQUFJLFNBQVMsQ0FBQztBQUF4QixLQUNELENBQUMsS0FBRCxHQUNFO0FBQUssU0FBSyxFQUFJLGFBQWEsQ0FBQztBQUE1QixLQUFzQyxLQUFLLEdBQUcsQ0FBOUMsRSxHQUFBLEVBQWtELFFBQWxELENBREYsR0FFRTtBQUFLLFNBQUssRUFBSSxhQUFhLENBQUM7QUFBNUIsS0FBbUMsb0NBQW5DLENBSEQsQ0FBUDtBQU9ILENBL0JEOztBQWlDQSxxQkFBZSxXQUFmIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcGxhY2Vob2xkZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBQbGFjZWhvbGRlciA9ICh7aW5kZXgsIGxpc3RzaXplLCBlcnJvcn0pID0+IHtcblxuICAgIGNvbnN0IHN0eWxlc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZScsXG4gICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgIGJvcmRlcjonMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgd2lkdGg6JzEwMCUnXG4gICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzKVxuICAgIGNvbnN0IGl0ZW1TdHlsZXNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6MCxcbiAgICAgICAgICAgIGxlZnQ6MCxcbiAgICAgICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgICAgICBvcGFjaXR5Oi41LFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOic4cHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsIFxuICAgICAgICAgICAgbWFyZ2luOiczcHgnLFxuICAgICAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICApXG5cbiAgICByZXR1cm4gPGRpdiBzdHlsZSA9IHtzdHlsZXNSZWYuY3VycmVudH0+XG4gICAgICAgIHsgIWVycm9yP1xuICAgICAgICAgICAgPGRpdiBzdHlsZSA9IHtpdGVtU3R5bGVzUmVmLmN1cnJlbnR9PntpbmRleCArIDF9L3tsaXN0c2l6ZX08L2Rpdj46XG4gICAgICAgICAgICA8ZGl2IHN0eWxlID0ge2l0ZW1TdHlsZXNSZWYuY3VycmVudH0+aXRlbSBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgdGltZTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){"use strict";eval(" // scrolltracker.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(0));\n\nvar ScrollTracker = function ScrollTracker(_a) {\n  var top = _a.top,\n      left = _a.left,\n      offset = _a.offset,\n      listsize = _a.listsize,\n      styles = _a.styles;\n  var trackdata = offset + 1 + \"/\" + listsize;\n  var styleRef = react_1.useRef(Object.assign({\n    top: top + 'px',\n    left: left + 'px',\n    position: 'fixed',\n    zIndex: 3,\n    backgroundColor: 'white',\n    border: '1px solid gray',\n    borderRadius: '10px',\n    fontSize: 'smaller',\n    padding: '3px'\n  }, styles === null || styles === void 0 ? void 0 : styles.scrolltracker));\n  return react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'scrolltracker',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports[\"default\"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGx0cmFja2VyLnRzeD9mZjgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQSxJQUFNLGFBQWEsR0FBRyxTQUFoQixhQUFnQixDQUFDLEVBQUQsRUFBd0M7TUFBckMsWTtNQUFLLGM7TUFBTSxrQjtNQUFRLHNCO01BQVUsa0I7QUFFbEQsTUFBSSxTQUFTLEdBQU0sTUFBTSxHQUFHLENBQVQsR0FBVSxHQUFWLEdBQWMsUUFBakM7QUFFQSxNQUFJLFFBQVEsR0FBRyxlQUFPLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDaEMsT0FBRyxFQUFFLEdBQUcsR0FBRyxJQURxQjtBQUVoQyxRQUFJLEVBQUUsSUFBSSxHQUFHLElBRm1CO0FBR2hDLFlBQVEsRUFBQyxPQUh1QjtBQUloQyxVQUFNLEVBQUMsQ0FKeUI7QUFLaEMsbUJBQWUsRUFBQyxPQUxnQjtBQU1oQyxVQUFNLEVBQUUsZ0JBTndCO0FBT2hDLGdCQUFZLEVBQUMsTUFQbUI7QUFRaEMsWUFBUSxFQUFDLFNBUnVCO0FBU2hDLFdBQU8sRUFBQztBQVR3QixHQUFkLEVBVUcsTUFBTSxTQUFOLFVBQU0sV0FBTixHQUFNLE1BQU4sU0FBTSxDQUFFLGFBVlgsQ0FBUCxDQUFmO0FBWUEsU0FBTztBQUFBLGlCQUFpQixlQUFqQjtBQUFpQyxTQUFLLEVBQUksUUFBUSxDQUFDO0FBQW5ELEtBQThELFNBQTlELENBQVA7QUFDSCxDQWpCRDs7QUFtQkEscUJBQWUsYUFBZiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmfSBmcm9tICdyZWFjdCdcblxuY29uc3QgU2Nyb2xsVHJhY2tlciA9ICh7IHRvcCwgbGVmdCwgb2Zmc2V0LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGxldCB0cmFja2RhdGEgPSBgJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfWBcblxuICAgIGxldCBzdHlsZVJlZiA9IHVzZVJlZihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246J2ZpeGVkJyxcbiAgICAgICAgekluZGV4OjMsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgZ3JheScsXG4gICAgICAgIGJvcmRlclJhZGl1czonMTBweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgcGFkZGluZzonM3B4J1xuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyxzdHlsZXM/LnNjcm9sbHRyYWNrZXIpKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS1uYW1lID0gJ3Njcm9sbHRyYWNrZXInIHN0eWxlID0ge3N0eWxlUmVmLmN1cnJlbnR9ID57dHJhY2tkYXRhfTwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxUcmFja2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")}])}));