/*! For license information please see build.js.LICENSE.txt */
!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],F):"object"==typeof exports?exports["react-infinite-grid-scroller"]=F(require("react"),require("react-dom")):Q["react-infinite-grid-scroller"]=F(Q.react,Q["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n    Anything else is treated as an error\n\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned from getItem, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its scroller that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical index in the list) and a session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n\n    One CellFrame at a time is designated as the host of the two triggerLines with the isTriggerCell flag.\n    The triggerlines trigger an update of the Cradle through an IntersectionObserver.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\nvar defaultPlaceholderMessages = {\n  loading: \'(loading...)\',\n  retrieving: \'(retrieving from cache)\',\n  "null": \'end of list\',\n  undefined: \'host returned "undefined"\',\n  invalid: \'invalid React element\'\n};\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n    cellHeight = _ref.cellHeight,\n    cellWidth = _ref.cellWidth,\n    cellMinHeight = _ref.cellMinHeight,\n    cellMinWidth = _ref.cellMinWidth,\n    layout = _ref.layout,\n    getItem = _ref.getItem,\n    listsize = _ref.listsize,\n    placeholder = _ref.placeholder,\n    itemID = _ref.itemID,\n    index = _ref.index,\n    instanceID = _ref.instanceID,\n    scrollerID = _ref.scrollerID,\n    isTriggercell = _ref.isTriggercell,\n    placeholderFrameStyles = _ref.placeholderFrameStyles,\n    placeholderLinerStyles = _ref.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref.placeholderErrorLinerStyles,\n    placeholderMessages = _ref.placeholderMessages,\n    usePlaceholder = _ref.usePlaceholder;\n  var coreConfigRef = (0, react_1.useRef)(null);\n  coreConfigRef.current = {\n    orientation: orientation,\n    layout: layout,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight\n  };\n  // ----------------------[ setup ]----------------------\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n    scrollerPropertiesRef = cradleContext.scrollerPropertiesRef,\n    nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n    itemExceptionCallback = cradleContext.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef;\n  // style change generates state refresh\n  var stylesRef = (0, react_1.useRef)({});\n  var holderStylesRef = (0, react_1.useRef)({});\n  var placeholderMessagesRef = (0, react_1.useRef)(null);\n  placeholderMessagesRef.current = (0, react_1.useMemo)(function () {\n    var newMessages = Object.assign(Object.assign({}, defaultPlaceholderMessages), placeholderMessages);\n    return newMessages;\n  }, [placeholderMessages]);\n  // processing state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameState = _ref3[0],\n    setFrameState = _ref3[1];\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState;\n  // DOM ref\n  var frameRef = (0, react_1.useRef)(null);\n  // to track unmount interrupt\n  var isMountedRef = (0, react_1.useRef)(true);\n  // cache data\n  var portalMetadataRef = (0, react_1.useRef)(null);\n  // the placeholder to use\n  var placeholderRef = (0, react_1.useRef)(null);\n  // the session itemID to use; could be updated by parent\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID;\n  var cellFrameDataRef = (0, react_1.useRef)(null);\n  cellFrameDataRef.current = {\n    itemID: itemID,\n    index: index\n  };\n  // fetch error\n  var errorRef = (0, react_1.useRef)(false);\n  // placeholder message\n  var messageRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // for unmount\n  (0, react_1.useEffect)(function () {\n    return function () {\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.unregisterPendingPortal(index);\n    };\n  }, []);\n  // refresh content if itemID changes\n  (0, react_1.useLayoutEffect)(function () {\n    if (frameStateRef.current == \'setup\') return;\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]);\n  // ----------------- [ placeholder definition ] -------------------------\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, messageRef.current, errorRef.current, usePlaceholder]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      key: \'placeholder\',\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userLinerStyles: placeholderLinerStyles,\n      userErrorFrameStyles: placeholderErrorFrameStyles,\n      userErrorLinerStyles: placeholderErrorLinerStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current, usePlaceholder, placeholderFrameStyles, placeholderLinerStyles, placeholderErrorFrameStyles, placeholderErrorLinerStyles]);\n  // ---------------- [ requestidlecallback config ] ------------------------\n  var requestidlecallback =\n  // requestIdleCallback\n  window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback =\n  // cancelIdleCallback\n  window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null);\n  // --------------------[ processing ]-----------------\n  // set styles\n  (0, react_1.useEffect)(function () {\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, stylesRef.current);\n    var newHolderStyles = getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight);\n    if (isMountedRef.current) {\n      stylesRef.current = newStyles;\n      holderStylesRef.current = newHolderStyles;\n    }\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        {\n          setFrameState(\'working\'); // \'getusercontent\' will be called\n          break;\n        }\n      case \'working\':\n        {\n          setFrameState(\'getusercontent\'); // delay paint while working\n          break;\n        }\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID);\n          var _coreConfigRef$curren = coreConfigRef.current,\n            _layout = _coreConfigRef$curren.layout,\n            _orientation = _coreConfigRef$curren.orientation,\n            _cellWidth = _coreConfigRef$curren.cellWidth,\n            _cellHeight = _coreConfigRef$curren.cellHeight;\n          if (cached) {\n            messageRef.current = placeholderMessagesRef.current.retrieving;\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheHandler.getPortalMetadata(_itemID);\n              // get OutPortal node\n              portalMetadataRef.current.scrollerProperties.cellFrameDataRef = cellFrameDataRef;\n              portalNodeRef.current = portalMetadataRef.current.portalNode;\n              setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n              setFrameState(\'retrieved\');\n            }\n          } else {\n            messageRef.current = placeholderMessagesRef.current.loading;\n            // reserve space in the cache\n            cacheHandler.registerPendingPortal(index);\n            // enqueue the fetch\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, isValidElement, content, scrollerProperties;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.prev = 0;\n                      _context.next = 3;\n                      return getItem(index, _itemID);\n                    case 3:\n                      usercontent = _context.sent;\n                      if (usercontent === null) returnvalue = usercontent;\n                      if (usercontent === undefined) {\n                        error = new Error(placeholderMessagesRef.current.undefined);\n                      }\n                      _context.next = 12;\n                      break;\n                    case 8:\n                      _context.prev = 8;\n                      _context.t0 = _context["catch"](0);\n                      returnvalue = usercontent = undefined;\n                      error = _context.t0;\n                    case 12:\n                      // process the return value\n                      if (usercontent !== null && usercontent !== undefined) {\n                        isValidElement = react_1["default"].isValidElement(usercontent);\n                        if (!isValidElement) {\n                          returnvalue = usercontent;\n                          usercontent = undefined;\n                          error = new Error(placeholderMessagesRef.current.invalid);\n                        }\n                      }\n                      if (!isMountedRef.current) {\n                        _context.next = 27;\n                        break;\n                      }\n                      if (!(usercontent !== null && usercontent !== undefined)) {\n                        _context.next = 25;\n                        break;\n                      }\n                      // if usercontent is otherwise disallowed, let error handling deal with it.\n                      scrollerProperties = {\n                        cellFrameDataRef: cellFrameDataRef,\n                        scrollerPropertiesRef: scrollerPropertiesRef\n                      };\n                      if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                        content = react_1["default"].cloneElement(usercontent, {\n                          scrollerProperties: scrollerProperties\n                        });\n                      } else {\n                        content = usercontent;\n                      }\n                      _context.next = 19;\n                      return cacheHandler.createPortal(content, index, _itemID, scrollerProperties);\n                    case 19:\n                      portalMetadataRef.current = _context.sent;\n                      portalNodeRef.current = portalMetadataRef.current.portalNode;\n                      setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n                      isMountedRef.current && setFrameState(\'inserting\');\n                      _context.next = 27;\n                      break;\n                    case 25:\n                      // null or undefined; handle non-component value\n                      cacheHandler.unregisterPendingPortal(index); // create portal failed\n                      if (usercontent === null) {\n                        // truncate listsize at this index\n                        itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(placeholderMessagesRef.current["null"]));\n                        nullItemSetMaxListsize(index);\n                      } else {\n                        // usercontent === undefined, meaning an error has occurred\n                        // change placeholder message to error message\n                        errorRef.current = error;\n                        // notify the host\n                        itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                        isMountedRef.current && setFrameState(\'error\');\n                      }\n                    case 27:\n                    case "end":\n                      return _context.stop();\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n          break;\n        }\n      case \'inserting\':\n      case \'retrieved\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n    }\n  }, [frameState]);\n  // Note: the contentholder type layer is included to provide an anchor for the triggerlines.\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: stylesRef.current\n  }, frameState != \'setup\' ? react_1["default"].createElement("div", {\n    "data-type": \'contentholder\',\n    style: holderStylesRef.current\n  }, frameState != \'ready\' ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    key: \'portal\',\n    node: portalNodeRef.current\n  })) : react_1["default"].createElement("div", null), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\n//(frameState != \'setup\') && \nexports["default"] = CellFrame;\n// utilities\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\',\n    overflow: \'visible\'\n  });\n  if (orientation === \'vertical\') {\n    styleset.width = null;\n    if (layout == \'uniform\') {\n      styleset.height = cellHeight + \'px\';\n      styleset.minHeight = null;\n      styleset.maxHeight = null;\n    } else {\n      // \'variable\'\n      styleset.height = null;\n      styleset.minHeight = cellMinHeight + \'px\';\n      styleset.maxHeight = cellHeight + \'px\';\n    }\n  } else {\n    // \'horizontal\'\n    styleset.height = null;\n    if (layout == \'uniform\') {\n      styleset.width = cellWidth + \'px\';\n      styleset.minWidth = null;\n      styleset.maxWidth = null;\n    } else {\n      // \'variable\'\n      styleset.width = null;\n      styleset.minWidth = cellMinWidth + \'px\';\n      styleset.maxWidth = cellWidth + \'px\';\n    }\n  }\n  return styleset;\n};\nvar getContentHolderStyles = function getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight) {\n  var styles = {};\n  if (layout == \'uniform\') {\n    styles = {\n      inset: \'0px\',\n      position: \'absolute\',\n      height: null,\n      width: null,\n      minWidth: null,\n      minHeight: null\n    };\n  } else {\n    // variable\n    styles.inset = null;\n    styles.position = null;\n    if (orientation == \'vertical\') {\n      styles.width = \'100%\';\n      styles.height = null;\n      styles.minWidth = null;\n      styles.minHeight = cellMinHeight + \'px\';\n    } else {\n      styles.width = null;\n      styles.height = \'100%\';\n      styles.minWidth = cellMinWidth + \'px\';\n      styles.minHeight = null;\n    }\n  }\n  return styles;\n};\n// see also some base styles set in cachehandler\nvar setContainerStyles = function setContainerStyles(container, layout, orientation, cellWidth, cellHeight) {\n  container.style.overflow = \'hidden\';\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n    container.style.maxWidth = null;\n    container.style.maxHeight = null;\n    container.style.height = null;\n    container.style.width = null;\n  } else {\n    // variable\n    container.style.inset = null;\n    container.style.position = null;\n    if (orientation == \'vertical\') {\n      container.style.width = \'100%\';\n      container.style.height = null;\n      container.style.maxWidth = null;\n      container.style.maxHeight = cellHeight + \'px\';\n    } else {\n      container.style.width = null;\n      container.style.height = \'100%\';\n      container.style.maxWidth = cellWidth + \'px\';\n      container.style.maxHeight = null;\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSTtNQUMvQkUsU0FBUyxDQUFDZCxLQUFLLENBQUNVLFNBQVMsR0FBRzFHLFVBQVUsR0FBRyxJQUFJO0tBRWhELE1BQU07TUFFSDhHLFNBQVMsQ0FBQ2QsS0FBSyxDQUFDTyxLQUFLLEdBQUcsSUFBSTtNQUM1Qk8sU0FBUyxDQUFDZCxLQUFLLENBQUNRLE1BQU0sR0FBRyxNQUFNO01BQy9CTSxTQUFTLENBQUNkLEtBQUssQ0FBQ1ksUUFBUSxHQUFHM0csU0FBUyxHQUFHLElBQUk7TUFDM0M2RyxTQUFTLENBQUNkLEtBQUssQ0FBQ1UsU0FBUyxHQUFHLElBQUk7OztBQUs1QyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DZWxsRnJhbWUudHN4P2YxNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VsbEZyYW1lLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiBDZWxsRnJhbWUgaXMgdG8gZmV0Y2ggdXNlciBjb250ZW50IGZyb20gdGhlIGNhY2hlLCBvciBmcm9tIHRoZSBob3N0ICh1c2luZyBnZXRJdGVtKS5cbiAgICBXaGlsZSBhbiBpdGVtIGlzIGJlaW5nIGZldGNoZWQsIENlbGxGcmFtZSBwcmVzZW50cyBhIHBsYWNlaG9sZGVyIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgYW4gXG4gICAgaW1wb3J0ZWQgY3VzdG9tIHZlcnNpb24pLiBJZiB0aGVyZSBpcyBhbiBlcnJvciBpbiBmZXRjaGluZyBjb250ZW50IHRoZW4gdGhlIHBsYWNlaG9sZGVyIGlzIHVzZWRcbiAgICB0byBwcmVzZW50IHRoZSBlcnJvciB0byB0aGUgdXNlci4gSWYgYSBuZXcgaXRlbUlEIGlzIHNldCBieSB0aGUgcGFyZW50ICh0byBzeW5jaHJvbml6ZSB3aXRoIGFuIGFsdGVyZWRcbiAgICBjYWNoZSksIHRoZW4gQ2VsbEZyYW1lIHJlcGxhY2VzIHRoZSBvbGQgaXRlbSB3aXRoIHRoZSBuZXcgaXRlbS5cblxuICAgIGdldEl0ZW0gKHdoaWNoIGlzIGEgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGhvc3QpIGNhbiByZXR1cm4gb25lIG9mIHNldmVyYWwgdmFsdWVzOlxuICAgICAgICAtIGEgUmVhY3QgY29tcG9uZW50XG4gICAgICAgIC0gYSBwcm9taXNlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIC0gbnVsbFxuICAgICAgICAtIHVuZGVmaW5lZFxuICAgIEFueXRoaW5nIGVsc2UgaXMgdHJlYXRlZCBhcyBhbiBlcnJvclxuXG4gICAgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkLCB0aGVuIHRoZSBwcm9taXNlIHJldHVybnMgYSBSZWFjdCBjb21wb25lbnQsIG51bGwgb3IgdW5kZWZpbmVkLlxuXG4gICAgSWYgYSB2YWxpZCByZWFjdCBjb21wb25lbnQgaXMgcmV0dXJuZWQgZnJvbSBnZXRJdGVtLCB0aGVuIGl0IGlzIGluc3RhbnRpYXRlZCBpbiB0aGUgY2FjaGUsIGFuZCByZW5kZXJlZCBpbiB0aGVcbiAgICBDZWxsRnJhbWUuIElmIG51bGwgaXMgcmV0dXJuZWQsIHRoZW4gQ2VsbEZyYW1lIHNlbmRzIGEgbWVzc2FnZSB0byBpdHMgc2Nyb2xsZXIgdGhhdCB0aGUgaG9zdCBoYXMgXG4gICAgaW5kaWNhdGVkIHRoZSB0aGUgaXRlbSBiZWluZyBmZXRjaGVkIGluc3RlYWQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoZSBsaXN0LCBhbmQgdGhlIGxpc3RzaXplIHNob3VsZFxuICAgIGJlIGFkanVzdGVkIGFjY29yZGluZ2x5LiBBbnkgb3RoZXIgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBpcyB0cmVhdGVkIGFzIGFuIGVycm9yLCBhbmQgcHJlc2VudGVkXG4gICAgYXMgc3VjaCB0byB0aGUgdXNlciB0aHJvdWdoIHRoZSBwbGFjZWhvbGRlciBjb21wb25lbnQuXG5cbiAgICBnZXRJdGVtIHNlbmRzIHRoZSBpbmRleCAobG9naWNhbCBpbmRleCBpbiB0aGUgbGlzdCkgYW5kIGEgc2Vzc2lvbiBpdGVtSUQgdG8gdGhlIGhvc3QsIHNvIHRoYXRcbiAgICB0aGUgaG9zdCBjYW4gc3luYyBpdHMgb3duIHRyYWNraW5nIHdpdGggdGhlIHNjcm9sbGVyLlxuXG4gICAgT25lIENlbGxGcmFtZSBhdCBhIHRpbWUgaXMgZGVzaWduYXRlZCBhcyB0aGUgaG9zdCBvZiB0aGUgdHdvIHRyaWdnZXJMaW5lcyB3aXRoIHRoZSBpc1RyaWdnZXJDZWxsIGZsYWcuIFxuICAgIFRoZSB0cmlnZ2VybGluZXMgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIENyYWRsZSB0aHJvdWdoIGFuIEludGVyc2VjdGlvbk9ic2VydmVyLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7XG4gICAgdXNlUmVmLCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZU1lbW8sIFxuICAgIHVzZUNvbnRleHQgXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQge3JlcXVlc3RJZGxlQ2FsbGJhY2ssIGNhbmNlbElkbGVDYWxsYmFja30gZnJvbSAncmVxdWVzdGlkbGVjYWxsYmFjaycgLy8gcG9seWZpbGwgaWYgbmVlZGVkXG5cbmltcG9ydCB7IE91dFBvcnRhbCB9IGZyb20gJ3JlYWN0LXJldmVyc2UtcG9ydGFsJyAvLyBmZXRjaCBmcm9tIGNhY2hlXG5cbmltcG9ydCBQbGFjZWhvbGRlciBmcm9tICcuL2NlbGxmcmFtZS9QbGFjZWhvbGRlcicgLy8gZGVmYXVsdFxuXG5pbXBvcnQgeyBDcmFkbGVDb250ZXh0IH0gZnJvbSAnLi9DcmFkbGUnXG5cbmNvbnN0IGRlZmF1bHRQbGFjZWhvbGRlck1lc3NhZ2VzID0ge1xuICAgIGxvYWRpbmc6Jyhsb2FkaW5nLi4uKScsXG4gICAgcmV0cmlldmluZzonKHJldHJpZXZpbmcgZnJvbSBjYWNoZSknLFxuICAgIG51bGw6J2VuZCBvZiBsaXN0JyxcbiAgICB1bmRlZmluZWQ6J2hvc3QgcmV0dXJuZWQgXCJ1bmRlZmluZWRcIicsXG4gICAgaW52YWxpZDonaW52YWxpZCBSZWFjdCBlbGVtZW50Jyxcbn1cblxuY29uc3QgQ2VsbEZyYW1lID0gKHtcbiAgICBvcmllbnRhdGlvbiwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBjZWxsTWluSGVpZ2h0LFxuICAgIGNlbGxNaW5XaWR0aCxcbiAgICBsYXlvdXQsXG4gICAgZ2V0SXRlbSwgLy8gZnVuY3Rpb24gcHJvdmlkZWQgYnkgaG9zdFxuICAgIGxpc3RzaXplLCAvLyBmb3IgZmVlZGJhY2sgaW4gcGxhY2Vob2xkZXJcbiAgICBwbGFjZWhvbGRlciwgLy8gb3B0aW9uYWxseSBwcm92aWRlZCBieSBob3N0XG4gICAgaXRlbUlELCAvLyBzZXNzaW9uIGl0ZW1JRFxuICAgIGluZGV4LCAvLyBsb2dpY2FsIGluZGV4IGluIGluZmluaXRlIGxpc3RcbiAgICBpbnN0YW5jZUlELCAvLyBDZWxsRnJhbWUgc2Vzc2lvbiBJRFxuICAgIHNjcm9sbGVySUQsIC8vIHNjcm9sbGVyIElEIChmb3IgZGVidWdnaW5nKVxuICAgIGlzVHJpZ2dlcmNlbGwsXG4gICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICB1c2VQbGFjZWhvbGRlcixcbn0pID0+IHtcblxuICAgIGNvbnN0IGNvcmVDb25maWdSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb3JlQ29uZmlnUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbEhlaWdodFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZXh0ID0gdXNlQ29udGV4dChDcmFkbGVDb250ZXh0KVxuXG4gICAgY29uc3QgeyBcbiAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLCAvLyBmb3IgdGhlIHVzZXIgY29udGVudCwgaWYgcmVxdWVzdGVkXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIC8vIGZvciBpbnRlcm5hbCBub3RpZmljYXRpb24gb2YgZW5kLW9mLWxpc3RcbiAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLCAvLyBmb3Igbm90aWZpY2F0aW9uIHRvIGhvc3Qgb2YgZXJyb3JcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsIC8vIHRvIG9wdGltaXplIHJlcXVlc3RJZGxlQ2FsbGJhY2tcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSA9IGNyYWRsZUNvbnRleHRcbiAgICBcbiAgICAvLyBzdHlsZSBjaGFuZ2UgZ2VuZXJhdGVzIHN0YXRlIHJlZnJlc2hcbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoe30pXG4gICAgY29uc3QgaG9sZGVyU3R5bGVzUmVmID0gdXNlUmVmKHt9KVxuXG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBjb25zdCBuZXdNZXNzYWdlcyA9IHsuLi5kZWZhdWx0UGxhY2Vob2xkZXJNZXNzYWdlcywuLi5wbGFjZWhvbGRlck1lc3NhZ2VzfVxuXG4gICAgICAgIHJldHVybiBuZXdNZXNzYWdlc1xuXG4gICAgfSxbcGxhY2Vob2xkZXJNZXNzYWdlc10pXG5cbiAgICAvLyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgY29uc3QgW2ZyYW1lU3RhdGUsIHNldEZyYW1lU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBmcmFtZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpXG4gICAgZnJhbWVTdGF0ZVJlZi5jdXJyZW50ID0gZnJhbWVTdGF0ZVxuXG4gICAgLy8gRE9NIHJlZlxuICAgIGNvbnN0IGZyYW1lUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdG8gdHJhY2sgdW5tb3VudCBpbnRlcnJ1cHRcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICAvLyBjYWNoZSBkYXRhXG4gICAgY29uc3QgcG9ydGFsTWV0YWRhdGFSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgcGxhY2Vob2xkZXIgdG8gdXNlXG4gICAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgc2Vzc2lvbiBpdGVtSUQgdG8gdXNlOyBjb3VsZCBiZSB1cGRhdGVkIGJ5IHBhcmVudFxuICAgIGNvbnN0IGl0ZW1JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGl0ZW1JRFJlZi5jdXJyZW50ID0gaXRlbUlEXG4gICAgY29uc3QgY2VsbEZyYW1lRGF0YVJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNlbGxGcmFtZURhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgaXRlbUlELFxuICAgICAgICBpbmRleFxuICAgIH1cbiAgICAvLyBmZXRjaCBlcnJvclxuICAgIGNvbnN0IGVycm9yUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIC8vIHBsYWNlaG9sZGVyIG1lc3NhZ2VcbiAgICBjb25zdCBtZXNzYWdlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGZvciB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY2FuY2VsaWRsZWNhbGxiYWNrKHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZi5jdXJyZW50KVxuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIudW5yZWdpc3RlclBlbmRpbmdQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIHJlZnJlc2ggY29udGVudCBpZiBpdGVtSUQgY2hhbmdlc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChmcmFtZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpXG5cbiAgICB9LFtpdGVtSURdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gWyBwbGFjZWhvbGRlciBkZWZpbml0aW9uIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3VzdG9tcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBpZiAoIXVzZVBsYWNlaG9sZGVyKSByZXR1cm4gbnVsbCAgICAgICAgXG5cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChwbGFjZWhvbGRlciwgXG4gICAgICAgICAgICAgICAge2luZGV4LCBsaXN0c2l6ZSwgbWVzc2FnZTptZXNzYWdlUmVmLmN1cnJlbnQsIGVycm9yOmVycm9yUmVmLmN1cnJlbnR9KTpcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIFxuICAgIH0sW1xuICAgICAgICBpbmRleCwgXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCwgXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQsIFxuICAgICAgICB1c2VQbGFjZWhvbGRlclxuICAgIF0pXG5cbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGlmICghdXNlUGxhY2Vob2xkZXIpIHJldHVybiBudWxsXG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBcbiAgICAgICAgICAgIGN1c3RvbXBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgICAgIGN1c3RvbXBsYWNlaG9sZGVyOlxuICAgICAgICAgICAgICAgIDxQbGFjZWhvbGRlciBcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJ3BsYWNlaG9sZGVyJ1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH0gXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7IG1lc3NhZ2VSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0geyBlcnJvclJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckZyYW1lU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckxpbmVyU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckVycm9yRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJFcnJvckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMgfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyXG5cbiAgICB9LCBbXG4gICAgICAgIGluZGV4LCBcbiAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXIsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCwgXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQsXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBbIHJlcXVlc3RpZGxlY2FsbGJhY2sgY29uZmlnIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCByZXF1ZXN0aWRsZWNhbGxiYWNrID0gLy8gcmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAgICB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXT9cbiAgICAgICAgICAgIHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFja1xuXG4gICAgY29uc3QgY2FuY2VsaWRsZWNhbGxiYWNrID0gLy8gY2FuY2VsSWRsZUNhbGxiYWNrXG4gICAgICAgIHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ10/XG4gICAgICAgICAgICB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgICBjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gc2V0IHN0eWxlc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IG5ld1N0eWxlcyA9IGdldEZyYW1lU3R5bGVzKFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLCBsYXlvdXQsIHN0eWxlc1JlZi5jdXJyZW50KVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3SG9sZGVyU3R5bGVzID0gZ2V0Q29udGVudEhvbGRlclN0eWxlcyhsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsTWluV2lkdGgsIGNlbGxNaW5IZWlnaHQpXG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHN0eWxlc1JlZi5jdXJyZW50ID0gbmV3U3R5bGVzXG4gICAgICAgICAgICBob2xkZXJTdHlsZXNSZWYuY3VycmVudCA9IG5ld0hvbGRlclN0eWxlc1xuXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0XSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoZnJhbWVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3dvcmtpbmcnKSAvLyAnZ2V0dXNlcmNvbnRlbnQnIHdpbGwgYmUgY2FsbGVkXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dvcmtpbmcnOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpIC8vIGRlbGF5IHBhaW50IHdoaWxlIHdvcmtpbmdcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldHVzZXJjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaXRlbUlEUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZUhhbmRsZXIuaGFzUG9ydGFsKGl0ZW1JRClcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9ID0gY29yZUNvbmZpZ1JlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50LnJldHJpZXZpbmdcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBjYWNoZUhhbmRsZXIuZ2V0UG9ydGFsTWV0YWRhdGEoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IE91dFBvcnRhbCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LnNjcm9sbGVyUHJvcGVydGllcy5jZWxsRnJhbWVEYXRhUmVmID0gY2VsbEZyYW1lRGF0YVJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250YWluZXJTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50LmVsZW1lbnQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodClcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmV0cmlldmVkJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5sb2FkaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZSBzcGFjZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlZ2lzdGVyUGVuZGluZ1BvcnRhbChpbmRleClcblxuICAgICAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soYXN5bmMgKCk9PntcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbHVlLCB1c2VyY29udGVudCwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50LnVuZGVmaW5lZClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IFJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5pbnZhbGlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXJjb250ZW50IGlzIG90aGVyd2lzZSBkaXNhbGxvd2VkLCBsZXQgZXJyb3IgaGFuZGxpbmcgZGVhbCB3aXRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZyYW1lRGF0YVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQucHJvcHM/Lmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudCh1c2VyY29udGVudCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50ID0gYXdhaXQgY2FjaGVIYW5kbGVyLmNyZWF0ZVBvcnRhbChjb250ZW50LCBpbmRleCwgaXRlbUlELCBzY3JvbGxlclByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRhaW5lclN0eWxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudC5lbGVtZW50LCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0RnJhbWVTdGF0ZSgnaW5zZXJ0aW5nJylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG51bGwgb3IgdW5kZWZpbmVkOyBoYW5kbGUgbm9uLWNvbXBvbmVudCB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci51bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbChpbmRleCkgLy8gY3JlYXRlIHBvcnRhbCBmYWlsZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdjZWxsRnJhbWUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQubnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQsIG1lYW5pbmcgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBwbGFjZWhvbGRlciBtZXNzYWdlIHRvIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBob3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRGcmFtZVN0YXRlKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0se3RpbWVvdXQ6SURMRUNBTExCQUNLX1RJTUVPVVR9KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0aW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3JldHJpZXZlZCc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LCBbZnJhbWVTdGF0ZV0pXG5cbiAgICAvLyBOb3RlOiB0aGUgY29udGVudGhvbGRlciB0eXBlIGxheWVyIGlzIGluY2x1ZGVkIHRvIHByb3ZpZGUgYW4gYW5jaG9yIGZvciB0aGUgdHJpZ2dlcmxpbmVzLlxuICAgIHJldHVybiA8ZGl2IFxuXG4gICAgICAgIHJlZiA9IHsgZnJhbWVSZWYgfSBcbiAgICAgICAgZGF0YS10eXBlID0gJ2NlbGxmcmFtZScgXG4gICAgICAgIGRhdGEtc2Nyb2xsZXJpZCA9IHsgc2Nyb2xsZXJJRCB9IFxuICAgICAgICBkYXRhLWluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICBkYXRhLWluc3RhbmNlaWQgPSB7IGluc3RhbmNlSUQgfSBcbiAgICAgICAgc3R5bGUgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cblxuICAgID5cblxuICAgICAgICB7KGZyYW1lU3RhdGUgIT0gJ3NldHVwJyk/XG4gICAgICAgICAgICAoPGRpdiBkYXRhLXR5cGUgPSAnY29udGVudGhvbGRlcicgc3R5bGUgPSB7aG9sZGVyU3R5bGVzUmVmLmN1cnJlbnR9PiBcbiAgICAgICAgICAgICAgICB7KChmcmFtZVN0YXRlICE9ICdyZWFkeScpP1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgPE91dFBvcnRhbCBrZXkgPSAncG9ydGFsJyBub2RlID0geyBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgfS8+KX1cbiAgICAgICAgICAgIDwvZGl2Pik6PGRpdj48L2Rpdj59XG4gICAgICAgIHsoaXNUcmlnZ2VyY2VsbD9cbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICBudWxsKVxuICAgICAgICB9XG5cbiAgICA8L2Rpdj5cblxufSAvLyBDZWxsRnJhbWVcbi8vKGZyYW1lU3RhdGUgIT0gJ3NldHVwJykgJiYgXG5leHBvcnQgZGVmYXVsdCBDZWxsRnJhbWVcblxuLy8gdXRpbGl0aWVzXG5jb25zdCBnZXRGcmFtZVN0eWxlcyA9IFxuICAgIChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsIGxheW91dCwgc3R5bGVzKSA9PiB7XG5cbiAgICBjb25zdCBzdHlsZXNldCA9IHsuLi5zdHlsZXMscG9zaXRpb246J3JlbGF0aXZlJywgb3ZlcmZsb3c6J3Zpc2libGUnfVxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhIZWlnaHQgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBjZWxsTWluSGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWF4SGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCdcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IG51bGxcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gbnVsbFxuXG4gICAgICAgIH0gZWxzZSB7IC8vICd2YXJpYWJsZSdcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IGNlbGxNaW5XaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXNldFxuXG59XG5cbmNvbnN0IGdldENvbnRlbnRIb2xkZXJTdHlsZXMgPSAobGF5b3V0LG9yaWVudGF0aW9uLGNlbGxNaW5XaWR0aCwgY2VsbE1pbkhlaWdodCApID0+IHtcbiAgICBsZXQgc3R5bGVzOlJlYWN0LkNTU1Byb3BlcnRpZXMgPSB7fVxuICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgIHN0eWxlcyA9IHtcbiAgICAgICAgICAgIGluc2V0OicwcHgnLFxuICAgICAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgICAgIGhlaWdodDpudWxsLFxuICAgICAgICAgICAgd2lkdGg6bnVsbCxcbiAgICAgICAgICAgIG1pbldpZHRoOm51bGwsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6bnVsbCxcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIHZhcmlhYmxlXG4gICAgICAgIHN0eWxlcy5pbnNldCA9IG51bGxcbiAgICAgICAgc3R5bGVzLnBvc2l0aW9uID0gbnVsbFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzLm1pbldpZHRoID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgKyAncHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMud2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICBzdHlsZXMubWluV2lkdGggPSBjZWxsTWluV2lkdGggKyAncHgnXG4gICAgICAgICAgICBzdHlsZXMubWluSGVpZ2h0ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXNcbn1cblxuLy8gc2VlIGFsc28gc29tZSBiYXNlIHN0eWxlcyBzZXQgaW4gY2FjaGVoYW5kbGVyXG5jb25zdCBzZXRDb250YWluZXJTdHlsZXMgPSAoY29udGFpbmVyLCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpID0+IHtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5pbnNldCA9ICcwcHgnIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhXaWR0aCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuXG4gICAgfSBlbHNlIHsgLy8gdmFyaWFibGVcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSBudWxsIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBudWxsXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcblxuICAgICAgICB9XG5cbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiZGVzYyIsInZhbHVlIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJjb250ZXh0IiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfX2F3YWl0IiwidGhlbiIsInVud3JhcHBlZCIsImVycm9yIiwicHJldmlvdXNQcm9taXNlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJzdGF0ZSIsIkVycm9yIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJkb25lIiwibWV0aG9kTmFtZSIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImxlbmd0aCIsImkiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwiaXRlciIsImtleXMiLCJ2YWwiLCJvYmplY3QiLCJyZXZlcnNlIiwicG9wIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwiX2NhdGNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiX2kiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwicmVxdWVzdGlkbGVjYWxsYmFja18xIiwicmVhY3RfcmV2ZXJzZV9wb3J0YWxfMSIsIlBsYWNlaG9sZGVyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJDcmFkbGVfMSIsImRlZmF1bHRQbGFjZWhvbGRlck1lc3NhZ2VzIiwibG9hZGluZyIsInJldHJpZXZpbmciLCJpbnZhbGlkIiwiQ2VsbEZyYW1lIiwiX3JlZiIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJsYXlvdXQiLCJnZXRJdGVtIiwibGlzdHNpemUiLCJwbGFjZWhvbGRlciIsIml0ZW1JRCIsImluZGV4IiwiaW5zdGFuY2VJRCIsInNjcm9sbGVySUQiLCJpc1RyaWdnZXJjZWxsIiwicGxhY2Vob2xkZXJGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlck1lc3NhZ2VzIiwidXNlUGxhY2Vob2xkZXIiLCJjb3JlQ29uZmlnUmVmIiwidXNlUmVmIiwiY3VycmVudCIsImNyYWRsZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiQ3JhZGxlQ29udGV4dCIsImNhY2hlSGFuZGxlciIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmIiwic3R5bGVzUmVmIiwiaG9sZGVyU3R5bGVzUmVmIiwicGxhY2Vob2xkZXJNZXNzYWdlc1JlZiIsInVzZU1lbW8iLCJuZXdNZXNzYWdlcyIsImFzc2lnbiIsIl9yZWYyIiwidXNlU3RhdGUiLCJfcmVmMyIsImZyYW1lU3RhdGUiLCJzZXRGcmFtZVN0YXRlIiwiZnJhbWVTdGF0ZVJlZiIsImZyYW1lUmVmIiwiaXNNb3VudGVkUmVmIiwicG9ydGFsTWV0YWRhdGFSZWYiLCJwbGFjZWhvbGRlclJlZiIsIml0ZW1JRFJlZiIsImNlbGxGcmFtZURhdGFSZWYiLCJlcnJvclJlZiIsIm1lc3NhZ2VSZWYiLCJ1c2VFZmZlY3QiLCJjYW5jZWxpZGxlY2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYiLCJ1bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbCIsInVzZUxheW91dEVmZmVjdCIsImN1c3RvbXBsYWNlaG9sZGVyIiwiY3JlYXRlRWxlbWVudCIsIm1lc3NhZ2UiLCJ1c2VyRnJhbWVTdHlsZXMiLCJ1c2VyTGluZXJTdHlsZXMiLCJ1c2VyRXJyb3JGcmFtZVN0eWxlcyIsInVzZXJFcnJvckxpbmVyU3R5bGVzIiwicmVxdWVzdGlkbGVjYWxsYmFjayIsIndpbmRvdyIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJuZXdTdHlsZXMiLCJnZXRGcmFtZVN0eWxlcyIsIm5ld0hvbGRlclN0eWxlcyIsImdldENvbnRlbnRIb2xkZXJTdHlsZXMiLCJwb3J0YWxOb2RlUmVmIiwiY2FjaGVkIiwiaGFzUG9ydGFsIiwiX2NvcmVDb25maWdSZWYkY3VycmVuIiwiZ2V0UG9ydGFsTWV0YWRhdGEiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwb3J0YWxOb2RlIiwic2V0Q29udGFpbmVyU3R5bGVzIiwiZWxlbWVudCIsInJlZ2lzdGVyUGVuZGluZ1BvcnRhbCIsIl9fYXdhaXRlciIsIl9jYWxsZWUiLCJfYSIsInJldHVybnZhbHVlIiwidXNlcmNvbnRlbnQiLCJpc1ZhbGlkRWxlbWVudCIsImNvbnRlbnQiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwidDAiLCJwcm9wcyIsImNsb25lRWxlbWVudCIsImNyZWF0ZVBvcnRhbCIsInRpbWVvdXQiLCJyZWYiLCJzdHlsZSIsIk91dFBvcnRhbCIsIm5vZGUiLCJzdHlsZXMiLCJzdHlsZXNldCIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJ3aWR0aCIsImhlaWdodCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJpbnNldCIsImNvbnRhaW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// Cradle.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers (class instances), and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the ~30 state changes of the system.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be vertical or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'headwards' (up or left) in the Cradle, and\n    below which the cradle content expands 'tailwards' (doen or right). The Cradle content is held in\n    two CSS grids (children of the axis): one above or left (the 'head' grid), and one below or right,\n    of the position of the axis (the 'tail' grid).\n\n    The axis is kept near the leading (headward) edge of the visible cell rows of the Viewport\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is usually\n            the first item in the head section of the Cradle, unless the cradle shows the very top of the\n            list, in which case the cradleReferenceIndex is the same as the AxisReferenceIndex)\n        - axisViewportPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll (Viewport scrollTop or scrollLeft) of the\n            ScrollBlock\n    \n    Overscroll handling (repositioning):\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle (including its two content grids) has entirely passed\n        out of the viewport, then the Cradle component is replaced by a ScrollTracker (or by null if\n        the host takes responsibility for feedback). The ScrollTracker displays to the user the relative\n        location in the virtual list at the edge of the viewport during repositioning. When the scrolling\n        stops Cradle recreates the cradle content, according to the final position of the repositioning\n        process.\n\n    Cradle changes are activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\");\n// popup position tracker for repositioning\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\"));\n// support code; process handlers\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\"));\n// cacheHandler is imported as a property; instantiated at the root\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ./InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// for children\nexports.CradleContext = react_1[\"default\"].createContext(null);\n// component\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n    runwaySize = _ref.runwaySize,\n    listsize = _ref.listsize,\n    updateListsize = _ref.updateListsize,\n    startingIndex = _ref.startingIndex,\n    getItem = _ref.getItem,\n    placeholder = _ref.placeholder,\n    placeholderMessages = _ref.placeholderMessages,\n    userCallbacks = _ref.userCallbacks,\n    styles = _ref.styles,\n    triggerlineOffset = _ref.triggerlineOffset,\n    cache = _ref.cache,\n    cacheMax = _ref.cacheMax,\n    scrollerID = _ref.scrollerID,\n    cacheHandler = _ref.cacheHandler,\n    usePlaceholder = _ref.usePlaceholder,\n    useScrollTracker = _ref.useScrollTracker,\n    showAxis = _ref.showAxis,\n    ONAFTERSCROLL_TIMEOUT = _ref.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _ref.VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerProperties = _ref.scrollerProperties;\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    cellMinHeight = gridSpecs.cellMinHeight,\n    cellMinWidth = gridSpecs.cellMinWidth,\n    layout = gridSpecs.layout;\n  // get viewport context\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n  // flags\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false);\n  // trigger control\n  var triggerHistoryRef = (0, react_1.useRef)({\n    previousReferenceName: null\n  });\n  //  viewport dimensions and cached state\n  var getViewportDimensions = function getViewportDimensions() {\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    return {\n      width: viewportElement.offsetWidth,\n      height: viewportElement.offsetHeight\n    };\n  };\n  // two sources; could use some reconciliation\n  var viewportDimensions = ViewportContextProperties.viewportDimensions; // for scrollTracker\n  var _getViewportDimension = getViewportDimensions(),\n    viewportheight = _getViewportDimension.height,\n    viewportwidth = _getViewportDimension.width; // viewportDimensions\n  // cache test\n  // zero width and height means the component must be in portal (cache) state\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n  // cradle state\n  var _ref2 = (0, react_1.useState)('setup'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    cradleState = _ref3[0],\n    setCradleState = _ref3[1];\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n  cradleStateRef.current = cradleState;\n  // if (!scrollerProperties) {\n  // console.log('--\x3e cradleState','-'+scrollerID+'-', cradleState)\n  // console.log('-- index',~'+scrollerProperties?.cellFrameDataRef.current.index+'~')\n  // }\n  // cradle scaffold element refs\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null);\n  // layout bundle\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  });\n  // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n  var crosscount = (0, react_1.useMemo)(function () {\n    if (isCachedRef.current) return 0;\n    var viewportcrosslength = orientation == 'vertical' ? viewportwidth : viewportheight;\n    // cross length of viewport (gap to match crossLength)\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]);\n  // various row counts\n  var _ref4 = (0, react_1.useMemo)(function () {\n      var viewportLength = orientation == 'vertical' ? viewportheight : viewportwidth;\n      var baseRowLength;\n      if (layout == 'uniform') {\n        if (orientation == 'vertical') {\n          baseRowLength = cellHeight;\n        } else {\n          baseRowLength = cellWidth;\n        }\n      } else {\n        // layout == 'variable'\n        if (orientation == 'vertical') {\n          baseRowLength = cellMinHeight;\n        } else {\n          baseRowLength = cellMinWidth;\n        }\n      }\n      baseRowLength += gap;\n      var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n      var listRowcount = Math.ceil(listsize / crosscount);\n      var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n      var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n      var runwayRowcount;\n      if (calculatedCradleRowcount >= cradleRowcount) {\n        runwayRowcount = runwaySize;\n      } else {\n        var diff = cradleRowcount - calculatedCradleRowcount;\n        runwayRowcount -= Math.floor(diff / 2);\n        runwayRowcount = Math.max(0, runwayRowcount);\n      }\n      var itemcount = cradleRowcount * crosscount;\n      if (itemcount > listsize) {\n        itemcount = listsize;\n        cradleRowcount = Math.ceil(itemcount / crosscount);\n      }\n      return [cradleRowcount, viewportRowcount, listRowcount, runwayRowcount];\n    }, [orientation, gap,\n    // padding,\n    cellWidth, cellHeight, cellMinWidth, cellMinHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount, layout]),\n    _ref5 = _slicedToArray(_ref4, 4),\n    cradleRowcount = _ref5[0],\n    viewportRowcount = _ref5[1],\n    listRowcount = _ref5[2],\n    runwayRowcount = _ref5[3];\n  // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    repositioningIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningIndexCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionCallback\n  });\n  // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    runwaySize: runwaySize,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessages,\n    usePlaceholder: usePlaceholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    // control values\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    scrollerProperties: scrollerProperties\n  };\n  var scrollerPropertiesRef = (0, react_1.useRef)(null);\n  // passed to cellFrame content (user content) if requested\n  scrollerPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    crosscount: crosscount\n  };\n  // configuration properties to share with handlers\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    updateListsize: updateListsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    triggerHistoryRef: triggerHistoryRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  };\n  // placeholder in cradleParameters to make available individual handlers\n  var handlersRef = (0, react_1.useRef)(null);\n  // cradle parameters MASTER BUNDLE\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters;\n  // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  }\n  // make handlers directly available to cradle code below\n  var _handlersRef$current = handlersRef.current,\n    interruptHandler = _handlersRef$current.interruptHandler,\n    scrollHandler = _handlersRef$current.scrollHandler,\n    contentHandler = _handlersRef$current.contentHandler,\n    layoutHandler = _handlersRef$current.layoutHandler,\n    serviceHandler = _handlersRef$current.serviceHandler,\n    stylesHandler = _handlersRef$current.stylesHandler;\n  // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n  /*\n      Intercept change in caching status:\n      when a component is cached in a portal (in the React virtual DOM), including the transition of\n      being moved from one cellFrame to another when crossing the Cradle axis,\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n  \n      This supports InfiniteGridScroller components to be cached as content.\n  \n      The restore scrollPos action must be the first priority to hide these scrollPos adjustments\n      from the user.\n  */\n  var restoreScrollPos = function restoreScrollPos() {\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var blockScrollPos = cradlePositionData.blockScrollPos;\n    var blockXScrollPos = cradlePositionData.blockXScrollPos;\n    if (blockScrollPos !== null) {\n      var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n      viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n      viewportElement[cradlePositionData.blockXScrollProperty] = blockXScrollPos;\n    }\n  };\n  if (isCacheChange && !isCachedRef.current) {\n    restoreScrollPos();\n  }\n  // change state for entering or leaving cache\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached');\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n      if (hasBeenRenderedRef.current) {\n        setCradleState('rerenderfromcache');\n      } else {\n        setCradleState('firstrenderfromcache');\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]);\n  // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  //send call-in functions to host\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.functionsCallback) return;\n    var scrollToIndex = serviceHandler.scrollToIndex,\n      reload = serviceHandler.reload,\n      setListsize = serviceHandler.setListsize,\n      clearCache = serviceHandler.clearCache,\n      getCacheIndexMap = serviceHandler.getCacheIndexMap,\n      getCacheItemMap = serviceHandler.getCacheItemMap,\n      getCradleIndexMap = serviceHandler.getCradleIndexMap,\n      remapIndexes = serviceHandler.remapIndexes,\n      moveIndex = serviceHandler.moveIndex,\n      insertIndex = serviceHandler.insertIndex,\n      removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToIndex: scrollToIndex,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.functionsCallback(functions);\n  }, []);\n  // initialize window scroll listeners\n  (0, react_1.useEffect)(function () {\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []);\n  // iOS Safari requires special handling - it ignores assignments to scrollLeft/scrollTop during scrolling\n  (0, react_1.useEffect)(function () {\n    var layout = cradleInheritedPropertiesRef.current.layout;\n    if (!(0, InfiniteGridScroller_1.isSafariIOS)() || layout == 'uniform') return;\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.iOSonScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.iOSonScroll);\n    };\n  }, []);\n  // observer support\n  /*\n      There are two interection observers: one for the two cradle grids, and another for triggerlines;\n          both against the viewport.\n  */\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n      triggerlinesIntersect = interruptHandler.triggerlinesIntersect;\n    // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements();\n    // triggerobserver triggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n    var triggerobserver = triggerlinesIntersect.createObserver();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n    };\n  }, []);\n  // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // inernal callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize;\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n        deleteListCallback = _serviceHandler$callb.deleteListCallback,\n        changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n      contentHandler.updateListsize(maxListsize);\n      cacheHandler.changeCacheListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []);\n  // caching change\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n    if (cradleStateRef.current == 'setup') return;\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var _dListCallback;\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]);\n  // trigger viewportresizing response based on viewport state\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    // movement to and from cache is independent of ui viewportresizing\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    }\n    // complete viewportresizing mode\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]);\n  // reconfigure for changed size parameters\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [cellHeight, cellWidth, gap, padding, triggerlineOffset, layout, runwaySize]);\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    var _cradleInternalProper = cradleInternalPropertiesRef.current,\n      viewportRowcount = _cradleInternalProper.viewportRowcount,\n      crosscount = _cradleInternalProper.crosscount;\n    var runwaySize = cradleInheritedPropertiesRef.current.runwaySize;\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var calculatedCradleItemcount = calculatedCradleRowcount * crosscount;\n    var indexSpan = contentHandler.indexSpan;\n    var _indexSpan = _slicedToArray(indexSpan, 2),\n      lowIndex = _indexSpan[0],\n      highIndex = _indexSpan[1];\n    var measuredCradleItemCount;\n    var changeIsWithinCradle;\n    if (indexSpan.length == 0) {\n      measuredCradleItemCount = 0;\n      changeIsWithinCradle = true;\n    } else {\n      measuredCradleItemCount = highIndex - lowIndex + 1;\n      changeIsWithinCradle = highIndex >= listsize - 1;\n    }\n    if (measuredCradleItemCount < calculatedCradleItemcount ||\n    // sub-viewport visible listcount\n    changeIsWithinCradle) {\n      // change is not beyond cradle\n      interruptHandler.pauseInterrupts();\n      setCradleState('reconfigureforlistsize');\n    } else {\n      setCradleState('ready');\n    }\n  }, [listsize]);\n  // a new getItem function implies the need to reload\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reload');\n  }, [getItem]);\n  // pivot triggered on change of orientation\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n    layoutHandler.cradlePositionData.blockXScrollProperty = orientation == \"horizontal\" ? \"scrollTop\" : \"scrollLeft\";\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      layoutHandler.cradlePositionData.blockXScrollPos = 0;\n      return;\n    }\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n      layout = _cradleInheritedPrope.layout,\n      gap = _cradleInheritedPrope.gap;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    if (layout == 'uniform') {\n      var _cradleInheritedPrope2 = cradleInheritedPropertiesRef.current,\n        _cellWidth = _cradleInheritedPrope2.cellWidth,\n        _cellHeight = _cradleInheritedPrope2.cellHeight,\n        _gap = _cradleInheritedPrope2.gap;\n      // get previous ratio\n      var previousCellPixelLength = (orientation == 'vertical' ? _cellWidth : _cellHeight) + _gap;\n      var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n      var previousratio = previousAxisOffset / previousCellPixelLength;\n      var pivotCellPixelLength = (orientation == 'vertical' ? _cellHeight : _cellWidth) + _gap;\n      var pivotAxisOffset = previousratio * pivotCellPixelLength;\n      cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    } else {\n      cradlePositionData.targetAxisViewportPixelOffset = gap;\n    }\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]);\n  // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n  var _ref6 = (0, react_1.useMemo)(function () {\n      return stylesHandler.getCradleStyles({\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        cellMinHeight: cellMinHeight,\n        cellMinWidth: cellMinWidth,\n        gap: gap,\n        padding: padding,\n        viewportheight: viewportheight,\n        viewportwidth: viewportwidth,\n        crosscount: crosscount,\n        userstyles: styles,\n        triggerlineOffset: triggerlineOffset,\n        layout: layout\n      });\n    }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset, layout]),\n    _ref7 = _slicedToArray(_ref6, 6),\n    cradleHeadStyle = _ref7[0],\n    cradleTailStyle = _ref7[1],\n    cradleAxisStyle = _ref7[2],\n    cradleDividerStyle = _ref7[3],\n    triggercellTriggerlineHeadStyle = _ref7[4],\n    triggercellTriggerlineTailStyle = _ref7[5];\n  // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (about 30 states), using named states\n  // useLayoutEffect for suppressing flashes\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.renderPortalLists();\n            }\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n          cacheHandler.preload(finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n          break;\n        }\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true;\n          // avoid recursive cradle intersection interrupts\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n          if (scrollHandler.isScrolling) {\n            setCradleState('repositioningRender'); // toggles with repositioningContinuation\n          } else {\n            setCradleState('finishreposition');\n          }\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n      /*\n          the following 12 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts', with a detour for variable layout\n          to reconfigure the scrollblock\n      */\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reconfigureforlistsize':\n      case 'reload':\n        {\n          if (isCachedRef.current) {\n            setCradleState('cached');\n            break;\n          }\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = [];\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n          interruptHandler.triggerlinesIntersect.disconnect();\n          interruptHandler.cradleIntersect.disconnect();\n          if (_layout == 'variable') {\n            // restore base config to scrollblock\n            // already done for reposition\n            cradleState != 'finishreposition' && layoutHandler.restoreBaseScrollblockConfig();\n          }\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          }\n          var _listsize = cradleInternalPropertiesRef.current.listsize;\n          // set data\n          if (_listsize) contentHandler.setCradleContent(cradleState);\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          }\n          // synchronize cache if necessary\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalLists();\n            }\n          }\n          // prepare the cycle for preparerender\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents;\n          // update virtual DOM\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n          break;\n        }\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements was delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements();\n          setCradleState('restoreinterrupts'); // to restore interrupts\n          break;\n        }\n      case 'restoreinterrupts':\n        {\n          // normalize\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          contentHandler.updateCradleContent();\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n          if (_layout2 == 'uniform') {\n            interruptHandler.triggerlinesIntersect.connectElements();\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            // setCradleState('reconnectupdatedcontent')\n            setCradleState('ready');\n          } else {\n            // 'variable' content requiring reconfiguration\n            setCradleState('refreshDOMupdateforvariability');\n          }\n          break;\n        }\n      // ---------------------[ adjust scrollblock for set variable content ]--------------\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n      case 'preparesetforvariability':\n        {\n          setTimeout(function () {\n            if (isMountedRef.current) {\n              contentHandler.adjustScrollblockForVariability('setcradle');\n              setCradleState('finishsetforvariability');\n            }\n          }, VARIABLE_MEASUREMENTS_TIMEOUT);\n          break;\n        }\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n      // ------------------------[ adjust scrollblock for update variable content ]--------------\n      case 'refreshDOMupdateforvariability':\n        {\n          // extra cycle to allow for DOM synchronizion with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n      case 'adjustupdateforvariability':\n        {\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability('updatecradle');\n            setCradleState('finishupdateforvariability');\n          }, 0);\n          break;\n        }\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseCradleIntersectionObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      case 'channelcradleresetafterinsertremove':\n        {\n          applyPortalPartitionItemsForDeleteList(cacheHandler);\n          setCradleState('changelistsizeafterinsertremove');\n          break;\n        }\n      // support for various host service requests; syncs cradle content with cache changes\n      case 'applyinsertremovechanges':\n      case 'applyremapchanges':\n      case 'applymovechanges':\n        {\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          applyPortalPartitionItemsForDeleteList(cacheHandler);\n          if (cradleState == 'applyinsertremovechanges') {\n            setCradleState('changelistsizeafterinsertremove');\n          } else {\n            setCradleState('ready');\n          }\n          break;\n        }\n      case 'changelistsizeafterinsertremove':\n        {\n          var newlistsize = serviceHandler.newlistsize;\n          serviceHandler.newlistsize = null;\n          setCradleState('ready');\n          // service handler called because this is a followon of a user intervention\n          serviceHandler.setListsize(newlistsize);\n          break;\n        }\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]);\n  var applyPortalPartitionItemsForDeleteList = function applyPortalPartitionItemsForDeleteList(cacheHandler) {\n    var portalPartitionItemsForDeleteList = cacheHandler.portalPartitionItemsForDeleteList;\n    if (portalPartitionItemsForDeleteList && portalPartitionItemsForDeleteList.length) {\n      var _iterator = _createForOfIteratorHelper(portalPartitionItemsForDeleteList),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          cacheHandler.removePartitionPortal(item.partitionID, item.itemID);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      cacheHandler.portalPartitionItemsForDeleteList = [];\n      cacheHandler.renderPortalLists();\n    }\n  };\n  // standard rendering states (3 states)\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]);\n  // ==========================[ RENDER ]===========================\n  var scrollAxisReferenceIndex = layoutHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollIndexRef = (0, react_1.useRef)(scrollAxisReferenceIndex);\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!['repositioningContinuation', 'repositioningRender', 'finishreposition'].includes(cradleState)) {\n      return null;\n    }\n    if (scrollAxisReferenceIndex != scrollIndexRef.current) {\n      scrollIndexRef.current = scrollAxisReferenceIndex;\n      var repositioningIndexCallback = serviceHandler.callbacks.repositioningIndexCallback;\n      repositioningIndexCallback && repositioningIndexCallback(scrollAxisReferenceIndex);\n    }\n    if (!useScrollTracker) return null;\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles, useScrollTracker]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'headtrigger',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'tailtrigger',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionCallback: serviceHandler.callbacks.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  });\n  // display the cradle components, the ScrollTracker, or null\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ?\n  // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\nexports[\"default\"] = Cradle;\n// utility\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  cacheHandler.cradleParameters = cradleParameters;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SCxhQUFhLEVBQUM2SCxhQUFhLENBQUN6UCxlQUFBLFdBQWEsQ0FBQztJQUMxQzZILGNBQWMsRUFBQzRILGFBQWEsQ0FBQ3ZQLGdCQUFBLFdBQWMsQ0FBQztJQUM1QzRILGFBQWEsRUFBQzJILGFBQWEsQ0FBQ3RQLGVBQUEsV0FBYTtHQUU1QztBQUVMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL0NyYWRsZS50c3g/NzE5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDcmFkbGUudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSBDcmFkbGUgZG9lcyB0aGUgYnVsayBvZiB0aGUgd29yayBmb3IgdGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIuIEl0IGRvZXMgc28gd2l0aCB0aGUgaGVscCBvZlxuICAgIGVpZ2h0IHByb2Nlc3MgaGFuZGxlcnMgKGNsYXNzIGluc3RhbmNlcyksIGFuZCBvbmUgbWFpbiBzdWItY29tcG9uZW50IC0gdGhlIENlbGxGcmFtZS5cblxuICAgIENyYWRsZSdzIG1haW4gcmVzcG9uc2liaWxpdHkgaXMgdG8gbWFuYWdlIHRoZSB+MzAgc3RhdGUgY2hhbmdlcyBvZiB0aGUgc3lzdGVtLlxuXG4gICAgVGhlIGlsbHVzaW9uIG9mIGluZmluaXRlIGNvbnRlbnQgaXMgbWFpbnRhaW5lZCBieSBzeW5jaHJvbml6aW5nIGNoYW5nZXMgaW4gY3JhZGxlIGNvbnRlbnQgd2l0aCB0aGVcbiAgICBDcmFkbGUgbG9jYXRpb24gaW5zaWRlIHRoZSBTY3JvbGxibG9jaywgc3VjaCB0aGF0IGFzIHRoZSBTY3JvbGxibG9jayBpcyBtb3ZlZCwgdGhlIGNyYWRsZSBtb3ZlcyBcbiAgICBvcHBvc2l0ZWx5IHRvIHN0YXkgdmlzaWJsZSB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuXG4gICAgVGhlIFNjcm9sbGJsb2NrIGlzIHNpemVkIHRvIGFwcHJveGltYXRlIHRoZSBsaXN0IGJlaW5nIHZpZXdlZCwgc28gYXMgdG8gaGF2ZSBhIHNjcm9sbCB0aHVtYiBzaXplIFxuICAgIGFuZCBwb3NpdGlvbiB3aGljaCByZWFsaXN0aWNhbGx5IHJlZmxlY3RzIHRoZSBzaXplIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBjcmFkbGUgaXMgY29udHJvbGxlZCBieSBhbiAnYXhpcycgd2hpY2ggaXMgYSAwcHggaGVpZ2h0L3dpZHRoIGRpdlxuICAgIChhbG9uZyB0aGUgbWVkaWFsIC0gU2Nyb2xsQmxvY2sgY2FuIGJlIHZlcnRpY2FsIG9yIGhvcml6b250YWwpLiBUaGUgcHVycG9zZSBvZiB0aGUgYXhpcyBpcyB0byBcbiAgICBhY3QgYXMgYSAnZm9sZCcsIGFib3ZlIHdoaWNoIGNyYWRsZSBjb250ZW50IGV4cGFuZHMgJ2hlYWR3YXJkcycgKHVwIG9yIGxlZnQpIGluIHRoZSBDcmFkbGUsIGFuZCBcbiAgICBiZWxvdyB3aGljaCB0aGUgY3JhZGxlIGNvbnRlbnQgZXhwYW5kcyAndGFpbHdhcmRzJyAoZG9lbiBvciByaWdodCkuIFRoZSBDcmFkbGUgY29udGVudCBpcyBoZWxkIGluIFxuICAgIHR3byBDU1MgZ3JpZHMgKGNoaWxkcmVuIG9mIHRoZSBheGlzKTogb25lIGFib3ZlIG9yIGxlZnQgKHRoZSAnaGVhZCcgZ3JpZCksIGFuZCBvbmUgYmVsb3cgb3IgcmlnaHQsIFxuICAgIG9mIHRoZSBwb3NpdGlvbiBvZiB0aGUgYXhpcyAodGhlICd0YWlsJyBncmlkKS5cblxuICAgIFRoZSBheGlzIGlzIGtlcHQgbmVhciB0aGUgbGVhZGluZyAoaGVhZHdhcmQpIGVkZ2Ugb2YgdGhlIHZpc2libGUgY2VsbCByb3dzIG9mIHRoZSBWaWV3cG9ydFxuXG4gICAgVGVjaG5pY2FsbHksIHRoZXJlIGFyZSBzZXZlcmFsIGtleSByZWZlcmVuY2UgcG9pbnRzIHRyYWNrZWQgYnkgdGhlIENyYWRsZS4gVGhlc2UgYXJlOlxuICAgICAgICAtIGF4aXNSZWZlcmVuY2VJbmRleCBpcyB0aGUgdmlydHVhbCBpbmRleCBvZiB0aGUgaXRlbSBjb250cm9sbGluZyB0aGUgbG9jYXRpb24gb2YgdGhlIGF4aXMuXG4gICAgICAgICAgICBUaGUgYXhpc1JlZmVyZW5jZUluZGV4IGlzIGFsc28gdXNlZCB0byBhbGxvY2F0ZSBpdGVtcyBhYm92ZSAobG93ZXIgaW5kZXggdmFsdWUpIGFuZCBiZWxvdyBcbiAgICAgICAgICAgIChzYW1lIG9yIGhpZ2hlciBpbmRleCB2YWx1ZSkgdGhlIGF4aXMgZm9sZC4gVGhlIGF4aXNSZWZlcm5jZUluZGV4IGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBcbiAgICAgICAgICAgIHRhaWwgc2VjdGlvbiBvZiB0aGUgQ3JhZGxlLlxuICAgICAgICAtIChjcmFkbGVSZWZlcmVuY2VJbmRleCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBheGlzUmVmZXJlbmNlSW5kZXgsIGFuZCBpcyB0aGUgdmlydHVhbCBpbmRleCBvZiBcbiAgICAgICAgICAgIHRoZSBpdGVtIGRlZmluaW5nIHRoZSBsZWFkaW5nIGJvdW5kIG9mIHRoZSBjcmFkbGUgY29udGVudC4gVGhlIGNyYWRsZVJlZmVyZW5jZUluZGV4IGlzIHVzdWFsbHkgXG4gICAgICAgICAgICB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgaGVhZCBzZWN0aW9uIG9mIHRoZSBDcmFkbGUsIHVubGVzcyB0aGUgY3JhZGxlIHNob3dzIHRoZSB2ZXJ5IHRvcCBvZiB0aGVcbiAgICAgICAgICAgIGxpc3QsIGluIHdoaWNoIGNhc2UgdGhlIGNyYWRsZVJlZmVyZW5jZUluZGV4IGlzIHRoZSBzYW1lIGFzIHRoZSBBeGlzUmVmZXJlbmNlSW5kZXgpXG4gICAgICAgIC0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKHBpeGVscyB0aGF0IHBsYWNlIHRoZSBheGlzIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydCdzIGxlYWRpbmcgZWRnZSlcbiAgICAgICAgLSB0aGUgYmxvY2tTY3JvbGxQb3MsIHdoaWNoIGlzIHRoZSBhbW91bnQgb2Ygc2Nyb2xsIChWaWV3cG9ydCBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCkgb2YgdGhlIFxuICAgICAgICAgICAgU2Nyb2xsQmxvY2tcbiAgICBcbiAgICBPdmVyc2Nyb2xsIGhhbmRsaW5nIChyZXBvc2l0aW9uaW5nKTpcbiAgICAgICAgT3dpbmcgdG8gdGhlIHBvdGVudGlhbCByYXBpZGl0eSBvZiBzY3JvbGxpbmcsIHdoaWNoIGluIHRoZSBjYXNlIG9mIGxhcmdlIGxpc3RzIGFuZCBoZWF2eSBjb250ZW50IFxuICAgICAgICBjYW4gYmUgdG9vIGZhc3QgZm9yIHRoZSBzeXN0ZW0gdG8ga2VlcCB1cCwgdGhlcmUgaXMgYW4gb3ZlcnNjcm9sbCBwcm90b2NvbCBjYWxsZWQgJ3JlcG9zaXRpb25pbmcnLlxuXG4gICAgICAgIElmIHRoZSBvdmVyc2Nyb2xsIGlzIHN1Y2ggdGhhdCB0aGUgY3JhZGxlIChpbmNsdWRpbmcgaXRzIHR3byBjb250ZW50IGdyaWRzKSBoYXMgZW50aXJlbHkgcGFzc2VkIFxuICAgICAgICBvdXQgb2YgdGhlIHZpZXdwb3J0LCB0aGVuIHRoZSBDcmFkbGUgY29tcG9uZW50IGlzIHJlcGxhY2VkIGJ5IGEgU2Nyb2xsVHJhY2tlciAob3IgYnkgbnVsbCBpZiBcbiAgICAgICAgdGhlIGhvc3QgdGFrZXMgcmVzcG9uc2liaWxpdHkgZm9yIGZlZWRiYWNrKS4gVGhlIFNjcm9sbFRyYWNrZXIgZGlzcGxheXMgdG8gdGhlIHVzZXIgdGhlIHJlbGF0aXZlIFxuICAgICAgICBsb2NhdGlvbiBpbiB0aGUgdmlydHVhbCBsaXN0IGF0IHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCBkdXJpbmcgcmVwb3NpdGlvbmluZy4gV2hlbiB0aGUgc2Nyb2xsaW5nXG4gICAgICAgIHN0b3BzIENyYWRsZSByZWNyZWF0ZXMgdGhlIGNyYWRsZSBjb250ZW50LCBhY2NvcmRpbmcgdG8gdGhlIGZpbmFsIHBvc2l0aW9uIG9mIHRoZSByZXBvc2l0aW9uaW5nIFxuICAgICAgICBwcm9jZXNzLlxuXG4gICAgQ3JhZGxlIGNoYW5nZXMgYXJlIGFjdGl2YXRlZCBieSBpbnRlcnJ1cHRzOlxuICAgIC0gc2Nyb2xsaW5nXG4gICAgLSByZXNpemluZyBvZiB0aGUgdmlld3BvcnRcbiAgICAtIG9ic2VydmVyIGNhbGxiYWNrczpcbiAgICAgICAgLSBjcmFkbGUvdmlld3BvcnQgaW50ZXJzZWN0aW9uIGZvciByZXBvc2l0aW9uaW5nIHdoZW4gdGhlIGNyYWRsZSByYWNlcyBvdXQgb2Ygc2NvcGVcbiAgICAgICAgLSB0d28gJ3RyaWdnZXJsaW5lJy92aWV3cG9ydCBpbnRlcnNlY3Rpb25zIHdoaWNoIHRyaWdnZXIgcm9sbGluZyBvZiBjb250ZW50XG4gICAgICAgICAgICAtIHJvbGxpbmcgY29udGVudCB0cmlnZ2VycyByZS1hbGxvY2F0aW9uIG9mIGNvbnRlbnQgYmV0d2VlbiBjcmFkbGUgaGVhZCBhbmQgdGFpbCBncmlkc1xuICAgIC0gcGl2b3QgLSBjaGFuZ2Ugb2Ygb3JpZW50YXRpb25cbiAgICAtIGhvc3QgY2hhbmdlcyBvZiBjb25maWd1cmF0aW9uIHNwZWNzIHRocm91Z2ggcHJvcGVydHkgY2hhbmdlcyBvciBkaXJlY3Qgc2VydmljZSBjYWxsc1xuKi9cblxuaW1wb3J0IFJlYWN0LCB7IFxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VSZWYsIFxuICAgIHVzZUNvbnRleHQsIFxuICAgIHVzZUVmZmVjdCwgXG4gICAgdXNlTGF5b3V0RWZmZWN0LCBcbiAgICB1c2VNZW1vLFxuICAgIHVzZUNhbGxiYWNrLCBcbn0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vVmlld3BvcnQnXG5cbi8vIHBvcHVwIHBvc2l0aW9uIHRyYWNrZXIgZm9yIHJlcG9zaXRpb25pbmdcbmltcG9ydCBTY3JvbGxUcmFja2VyIGZyb20gJy4vY3JhZGxlL1Njcm9sbFRyYWNrZXInXG5cbi8vIHN1cHBvcnQgY29kZTsgcHJvY2VzcyBoYW5kbGVyc1xuaW1wb3J0IFNjcm9sbEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc2Nyb2xsaGFuZGxlcidcbmltcG9ydCBTdGF0ZUhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc3RhdGVoYW5kbGVyJ1xuaW1wb3J0IENvbnRlbnRIYW5kbGVyIGZyb20gJy4vY3JhZGxlL2NvbnRlbnRoYW5kbGVyJ1xuaW1wb3J0IExheW91dEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvbGF5b3V0aGFuZGxlcidcbmltcG9ydCBJbnRlcnJ1cHRIYW5kbGVyIGZyb20gJy4vY3JhZGxlL2ludGVycnVwdGhhbmRsZXInXG5pbXBvcnQgU2VydmljZUhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc2VydmljZWhhbmRsZXInXG5pbXBvcnQgU3R5bGVzSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zdHlsZXNoYW5kbGVyJ1xuLy8gY2FjaGVIYW5kbGVyIGlzIGltcG9ydGVkIGFzIGEgcHJvcGVydHk7IGluc3RhbnRpYXRlZCBhdCB0aGUgcm9vdFxuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4vSW5maW5pdGVHcmlkU2Nyb2xsZXInXG5cbi8vIGZvciBjaGlsZHJlblxuZXhwb3J0IGNvbnN0IENyYWRsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpXG5cbi8vIGNvbXBvbmVudFxuY29uc3QgQ3JhZGxlID0gKHsgXG4gICAgICAgIGdyaWRTcGVjcyxcbiAgICAgICAgLy8gYmFzaWNzXG4gICAgICAgIHJ1bndheVNpemUsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIHVwZGF0ZUxpc3RzaXplLFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgdXNlckNhbGxiYWNrcyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIGZvciBoYW5kbGVyIGxpc3RcbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAvLyBzeXN0ZW1cbiAgICAgICAgdXNlUGxhY2Vob2xkZXIsXG4gICAgICAgIHVzZVNjcm9sbFRyYWNrZXIsXG4gICAgICAgIHNob3dBeGlzLFxuICAgICAgICBPTkFGVEVSU0NST0xMX1RJTUVPVVQsXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG4gICAgICAgIFZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VULFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMsXG5cbiAgICB9KSA9PiB7XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1bIERBVEEgU0VUVVAgXT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdW5wYWNrIGdyaWRTcGVjc1xuICAgIGNvbnN0IHtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgLy8gZ2V0IHZpZXdwb3J0IGNvbnRleHRcbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG5cbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyAvLyBmb3IgY2xvc3VyZXNcblxuICAgIC8vIGZsYWdzXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG4gICAgY29uc3QgaXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3Qgd2FzQ2FjaGVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IGhhc0JlZW5SZW5kZXJlZFJlZiA9IHVzZVJlZihmYWxzZSlcblxuICAgIC8vIHRyaWdnZXIgY29udHJvbFxuICAgIGNvbnN0IHRyaWdnZXJIaXN0b3J5UmVmID0gdXNlUmVmKHtcbiAgICAgICAgcHJldmlvdXNSZWZlcmVuY2VOYW1lOm51bGwsXG4gICAgfSlcblxuICAgIC8vICB2aWV3cG9ydCBkaW1lbnNpb25zIGFuZCBjYWNoZWQgc3RhdGVcbiAgICBjb25zdCBnZXRWaWV3cG9ydERpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDp2aWV3cG9ydEVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6dmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHdvIHNvdXJjZXM7IGNvdWxkIHVzZSBzb21lIHJlY29uY2lsaWF0aW9uXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgLy8gZm9yIHNjcm9sbFRyYWNrZXJcbiAgICBjb25zdCB7IGhlaWdodDp2aWV3cG9ydGhlaWdodCx3aWR0aDp2aWV3cG9ydHdpZHRoIH0gPSBnZXRWaWV3cG9ydERpbWVuc2lvbnMoKSAvLyB2aWV3cG9ydERpbWVuc2lvbnNcblxuICAgIC8vIGNhY2hlIHRlc3RcbiAgICAvLyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgbWVhbnMgdGhlIGNvbXBvbmVudCBtdXN0IGJlIGluIHBvcnRhbCAoY2FjaGUpIHN0YXRlXG4gICAgY29uc3QgaXNJblBvcnRhbCA9ICgodmlld3BvcnR3aWR0aCA9PSAwKSAmJiAodmlld3BvcnRoZWlnaHQgPT0gMCkpIFxuXG4gICAgY29uc3QgaXNDYWNoZUNoYW5nZSA9IChpc0luUG9ydGFsICE9IGlzQ2FjaGVkUmVmLmN1cnJlbnQpXG5cbiAgICBpZiAoaXNDYWNoZUNoYW5nZSkge1xuICAgICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGlzQ2FjaGVkUmVmLmN1cnJlbnRcbiAgICAgICAgaXNDYWNoZWRSZWYuY3VycmVudCA9IGlzSW5Qb3J0YWxcbiAgICB9XG5cbiAgICAvLyBjcmFkbGUgc3RhdGVcbiAgICBjb25zdCBbY3JhZGxlU3RhdGUsIHNldENyYWRsZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgY3JhZGxlU3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzXG4gICAgY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9IGNyYWRsZVN0YXRlXG5cbiAgICAvLyBpZiAoIXNjcm9sbGVyUHJvcGVydGllcykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0+IGNyYWRsZVN0YXRlJywnLScrc2Nyb2xsZXJJRCsnLScsIGNyYWRsZVN0YXRlKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0gaW5kZXgnLH4nK3Njcm9sbGVyUHJvcGVydGllcz8uY2VsbEZyYW1lRGF0YVJlZi5jdXJyZW50LmluZGV4Kyd+JylcbiAgICAvLyB9XG5cbiAgICAvLyBjcmFkbGUgc2NhZmZvbGQgZWxlbWVudCByZWZzXG4gICAgY29uc3QgaGVhZENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGF4aXNDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBsYXlvdXQgYnVuZGxlXG4gICAgY29uc3QgY3JhZGxlRWxlbWVudHNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRSZWY6aGVhZENyYWRsZUVsZW1lbnRSZWYsIFxuICAgICAgICAgICAgdGFpbFJlZjp0YWlsQ3JhZGxlRWxlbWVudFJlZiwgXG4gICAgICAgICAgICBheGlzUmVmOmF4aXNDcmFkbGVFbGVtZW50UmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWY6dHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWY6dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmLFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGVkIHByb3BlcnRpZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNvbmZpZ3VyYXRpb24gY2FsY3VsYXRpb25zXG5cbiAgICAvLyBjcm9zc2NvdW50IChhbHNvIGNhbGN1bGF0ZWQgYnkgU2Nyb2xsYmxvY2sgZm9yIGRlcml2aW5nIFNjcm9sbGJsb2NrIGxlbmd0aClcbiAgICBjb25zdCBjcm9zc2NvdW50ID0gdXNlTWVtbygoKSA9PiB7IC8vIHRoZSBudW1iZXIgb2YgY2VsbHMgY3Jvc3Npbmcgb3JpZW50YXRpb25cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkgcmV0dXJuIDBcblxuICAgICAgICBjb25zdCB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodFxuXG4gICAgICAgIC8vIGNyb3NzIGxlbmd0aCBvZiB2aWV3cG9ydCAoZ2FwIHRvIG1hdGNoIGNyb3NzTGVuZ3RoKVxuICAgICAgICBjb25zdCB2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYyA9IHZpZXdwb3J0Y3Jvc3NsZW5ndGggLSAocGFkZGluZyAqIDIpICsgZ2FwIFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGg6XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCkgXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aGZvcmNhbGMgPSBcbiAgICAgICAgICAgIE1hdGgubWluKGNlbGxjcm9zc2xlbmd0aCx2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYykgLy8gcmVzdWx0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMVxuXG4gICAgICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjL2NlbGxjcm9zc2xlbmd0aGZvcmNhbGMpXG5cbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICAvLyB2YXJpb3VzIHJvdyBjb3VudHNcbiAgICBjb25zdCBbXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LCBcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICBdID0gdXNlTWVtbygoKT0+IHtcblxuICAgICAgICBjb25zdCB2aWV3cG9ydExlbmd0aCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0OlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0d2lkdGhcblxuICAgICAgICBsZXQgYmFzZVJvd0xlbmd0aFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxIZWlnaHRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsV2lkdGhcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGxheW91dCA9PSAndmFyaWFibGUnXG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbE1pbkhlaWdodFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxNaW5XaWR0aFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VSb3dMZW5ndGggKz0gZ2FwXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRSb3djb3VudCA9IE1hdGguY2VpbCh2aWV3cG9ydExlbmd0aC9iYXNlUm93TGVuZ3RoKVxuXG4gICAgICAgIGNvbnN0IGxpc3RSb3djb3VudCA9IE1hdGguY2VpbChsaXN0c2l6ZS9jcm9zc2NvdW50KVxuXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG5cbiAgICAgICAgbGV0IGNyYWRsZVJvd2NvdW50ID0gTWF0aC5taW4obGlzdFJvd2NvdW50LCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG5cbiAgICAgICAgbGV0IHJ1bndheVJvd2NvdW50XG4gICAgICAgIGlmIChjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPj0gY3JhZGxlUm93Y291bnQpIHtcblxuICAgICAgICAgICAgcnVud2F5Um93Y291bnQgPSBydW53YXlTaXplXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IChjcmFkbGVSb3djb3VudCAtIGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudClcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50IC09IE1hdGguZmxvb3IoZGlmZi8yKVxuICAgICAgICAgICAgcnVud2F5Um93Y291bnQgPSBNYXRoLm1heCgwLHJ1bndheVJvd2NvdW50KVxuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbWNvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgICAgIGlmIChpdGVtY291bnQgPiBsaXN0c2l6ZSkge1xuXG4gICAgICAgICAgICBpdGVtY291bnQgPSBsaXN0c2l6ZVxuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQgPSBNYXRoLmNlaWwoaXRlbWNvdW50L2Nyb3NzY291bnQpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjcmFkbGVSb3djb3VudCwgXG4gICAgICAgICAgICB2aWV3cG9ydFJvd2NvdW50LCBcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG5cbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxheW91dCxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsbGJhY2tzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBob3N0IGNhbGxiYWNrcywgdXBhY2tlZCBieSBzZXJ2aWNlSGFuZGxlclxuICAgIGNvbnN0IGV4dGVybmFsQ2FsbGJhY2tzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5yZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmRlbGV0ZUxpc3RDYWxsYmFjayxcbiAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uY2hhbmdlTGlzdHNpemVDYWxsYmFjayxcbiAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5pdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVsgYnVuZGxlIHByb3BlcnRpZXMgZm9yIGhhbmRsZXJzIF0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBidW5kbGUgYWxsIGNyYWRsZSBwcm9wcyB0byBwYXNzIHRvIGhhbmRsZXJzIC0gdWx0aW1hdGVseSBjcmFkbGVQYXJhbWV0ZXJzUmVmXG5cbiAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlcyBhbmQgc3VwcG9ydCBjYWxsYmFja3NcbiAgICAvLyB1cCB0byBkYXRlIHZhbHVlc1xuICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgLy8gZ3JpZFNwZWNzXG4gICAgICAgIG9yaWVudGF0aW9uLCBnYXAsIHBhZGRpbmcsIGxheW91dCxcbiAgICAgICAgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsXG4gICAgICAgIC8vIC4uLnJlc3RcbiAgICAgICAgY2FjaGUsIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBwbGFjZWhvbGRlck1lc3NhZ2VzLCB1c2VQbGFjZWhvbGRlcixcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgdXNlckNhbGxiYWNrcywgc3R5bGVzLCBjYWNoZUhhbmRsZXIsXG4gICAgICAgIC8vIGNvbnRyb2wgdmFsdWVzXG4gICAgICAgIE9OQUZURVJTQ1JPTExfVElNRU9VVCwgTUFYX0NBQ0hFX09WRVJfUlVOLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLFxuXG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gcGFzc2VkIHRvIGNlbGxGcmFtZSBjb250ZW50ICh1c2VyIGNvbnRlbnQpIGlmIHJlcXVlc3RlZFxuICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBvcmllbnRhdGlvbiwgZ2FwLCBwYWRkaW5nLCBsYXlvdXQsXG4gICAgICAgIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBjYWNoZU1heCxcbiAgICAgICAgc3RhcnRpbmdJbmRleCxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gc2hhcmUgd2l0aCBoYW5kbGVyc1xuICAgIGNvbnN0IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuXG4gICAgICAgIC8vIHVwZGF0ZWQgdmFsdWVzXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICB1cGRhdGVMaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG4gICAgICAgIHRyaWdnZXJIaXN0b3J5UmVmLFxuXG4gICAgICAgIC8vIGZvciBzdGF0ZUhhbmRsZXJcbiAgICAgICAgY3JhZGxlU3RhdGVSZWYsXG4gICAgICAgIHNldENyYWRsZVN0YXRlLFxuICAgIH1cblxuICAgIC8vIHBsYWNlaG9sZGVyIGluIGNyYWRsZVBhcmFtZXRlcnMgdG8gbWFrZSBhdmFpbGFibGUgaW5kaXZpZHVhbCBoYW5kbGVyc1xuICAgIGNvbnN0IGhhbmRsZXJzUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBjcmFkbGUgcGFyYW1ldGVycyBNQVNURVIgQlVORExFXG4gICAgY29uc3QgY3JhZGxlUGFyYW1ldGVycyA9IHtcbiAgICAgICAgaGFuZGxlcnNSZWYsXG4gICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGV4dGVybmFsQ2FsbGJhY2tzUmVmLFxuICAgIH1cblxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVQYXJhbWV0ZXJzUmVmLmN1cnJlbnQgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBvbmdvaW5nIHNvdXJjZSBvZiBoYW5kbGVycyAtIG5vdGUgYWxsIEhhbmRsZXJzIGFyZSBnaXZlbiBhbGwgcGFyYW1ldGVycyAoY3JhZGxlUGFyYW1ldGVycylcbiAgICBpZiAoIWhhbmRsZXJzUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICBoYW5kbGVyc1JlZi5jdXJyZW50ID0gZ2V0Q3JhZGxlSGFuZGxlcnMoY3JhZGxlUGFyYW1ldGVycylcblxuICAgIH1cblxuICAgIC8vIG1ha2UgaGFuZGxlcnMgZGlyZWN0bHkgYXZhaWxhYmxlIHRvIGNyYWRsZSBjb2RlIGJlbG93XG4gICAgY29uc3QgeyAvLyBjYWNoZUhhbmRsZXIgYWxyZWFkeSBhdmFpbGFibGVcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgc2Nyb2xsSGFuZGxlcixcbiAgICAgICAgLy8gc3RhdGVIYW5kbGVyLCAvLyBub3QgdXNlZFxuICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgbGF5b3V0SGFuZGxlcixcbiAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgIHN0eWxlc0hhbmRsZXIsXG4gICAgfSA9IGhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09WyBJTlRFUkNFUFQgQ0FDSElORyBTVEFURSBDSEFOR0UgXT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyogICAgXG4gICAgSW50ZXJjZXB0IGNoYW5nZSBpbiBjYWNoaW5nIHN0YXR1czpcbiAgICB3aGVuIGEgY29tcG9uZW50IGlzIGNhY2hlZCBpbiBhIHBvcnRhbCAoaW4gdGhlIFJlYWN0IHZpcnR1YWwgRE9NKSwgaW5jbHVkaW5nIHRoZSB0cmFuc2l0aW9uIG9mIFxuICAgIGJlaW5nIG1vdmVkIGZyb20gb25lIGNlbGxGcmFtZSB0byBhbm90aGVyIHdoZW4gY3Jvc3NpbmcgdGhlIENyYWRsZSBheGlzLCBcbiAgICB0aGUgc2Nyb2xsUG9zIChzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCkgaXMgcmVzZXQgdG8gMCAoemVybykuIFdoZW4gdGhlIHNjcm9sbGVyIGlzIFxuICAgIG1vdmVkIHRvIGEgY2VsbEZyYW1lLCB0aGlzIGNvZGUgdHJpZ2dlcnMgcmVzdG9yYXRpb24gdGhlIHNjcm9sbFBvcyAoc2VlIGNhc2UgJ3BhcmVudGluZ3RyYW5zaXRpb24nXG4gICAgaW4gdGhlIHN0YXRlIG1hbmFnZW1lbnQgc2VjdGlvbiBiZWxvdykuXG5cbiAgICBUaGlzIHN1cHBvcnRzIEluZmluaXRlR3JpZFNjcm9sbGVyIGNvbXBvbmVudHMgdG8gYmUgY2FjaGVkIGFzIGNvbnRlbnQuXG5cbiAgICBUaGUgcmVzdG9yZSBzY3JvbGxQb3MgYWN0aW9uIG11c3QgYmUgdGhlIGZpcnN0IHByaW9yaXR5IHRvIGhpZGUgdGhlc2Ugc2Nyb2xsUG9zIGFkanVzdG1lbnRzXG4gICAgZnJvbSB0aGUgdXNlci5cbiovXG4gICAgXG4gICAgY29uc3QgcmVzdG9yZVNjcm9sbFBvcyA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNvbnN0IGJsb2NrU2Nyb2xsUG9zID0gY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIGNvbnN0IGJsb2NrWFNjcm9sbFBvcyA9IGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3NcbiAgICAgICAgaWYgKGJsb2NrU2Nyb2xsUG9zICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFByb3BlcnR5XSA9IGJsb2NrWFNjcm9sbFBvc1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChpc0NhY2hlQ2hhbmdlICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvcygpICAgICAgICBcblxuICAgIH1cblxuICAgIC8vIGNoYW5nZSBzdGF0ZSBmb3IgZW50ZXJpbmcgb3IgbGVhdmluZyBjYWNoZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVybiAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGludG8gY2FjaGVcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NhY2hlZCcpXG5cbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWNoZWRSZWYuY3VycmVudCAmJiB3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBvdXQgb2YgY2FjaGVcblxuICAgICAgICAgICAgd2FzQ2FjaGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbaXNDYWNoZWRSZWYuY3VycmVudCwgd2FzQ2FjaGVkUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaQVRJT04gZWZmZWN0cyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgYXJlIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcblxuICAgIC8vIGNsZWFyIG1vdW50ZWQgZmxhZyBvbiB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIC8vIHVubW91bnRcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvL3NlbmQgY2FsbC1pbiBmdW5jdGlvbnMgdG8gaG9zdFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICghdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0luZGV4LCBcbiAgICAgICAgICAgIHJlbG9hZCwgXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuXG4gICAgICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgICAgICBtb3ZlSW5kZXgsXG4gICAgICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgICAgIHJlbW92ZUluZGV4LFxuXG4gICAgICAgIH0gPSBzZXJ2aWNlSGFuZGxlclxuXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHtcblxuICAgICAgICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgICAgIHJlbG9hZCxcbiAgICAgICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICAgICAgY2xlYXJDYWNoZSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCxcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgICAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICByZW1vdmVJbmRleCxcblxuICAgICAgICB9XG5cbiAgICAgICAgdXNlckNhbGxiYWNrcy5mdW5jdGlvbnNDYWxsYmFjayhmdW5jdGlvbnMpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc2Nyb2xsIGxpc3RlbmVyc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCAmJiBcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyBpT1MgU2FmYXJpIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmcgLSBpdCBpZ25vcmVzIGFzc2lnbm1lbnRzIHRvIHNjcm9sbExlZnQvc2Nyb2xsVG9wIGR1cmluZyBzY3JvbGxpbmdcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIWlzU2FmYXJpSU9TKCkgfHwgKGxheW91dCA9PSAndW5pZm9ybScpKSByZXR1cm5cblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIuaU9Tb25TY3JvbGwpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50ICYmIFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIuaU9Tb25TY3JvbGwpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIG9ic2VydmVyIHN1cHBvcnRcbiAgICAvKlxuICAgICAgICBUaGVyZSBhcmUgdHdvIGludGVyZWN0aW9uIG9ic2VydmVyczogb25lIGZvciB0aGUgdHdvIGNyYWRsZSBncmlkcywgYW5kIGFub3RoZXIgZm9yIHRyaWdnZXJsaW5lczsgXG4gICAgICAgICAgICBib3RoIGFnYWluc3QgdGhlIHZpZXdwb3J0LlxuICAgICovICAgIFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNyYWRsZUludGVyc2VjdCxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lc0ludGVyc2VjdCxcbiAgICAgICAgfSA9IGludGVycnVwdEhhbmRsZXJcblxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgZm9yIGNyYWRsZSBib2R5XG4gICAgICAgIC8vIHRoaXMgc2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvZiB0aGUgY3JhZGxlIGFnYWluc3QgdGhlIHZpZXdwb3J0LiBXaGVuIHRoZVxuICAgICAgICAvLyBjcmFkbGUgZ29lcyBvdXQgb2YgdGhlIG9ic2VydmVyIHNjb3BlLCB0aGUgJ3JlcG9zaXRpb25pbmdSZW5kZXInIGNyYWRsZSBzdGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGNvbnN0IGNyYWRsZWludGVyc2VjdG9ic2VydmVyID0gY3JhZGxlSW50ZXJzZWN0LmNyZWF0ZU9ic2VydmVyKClcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgLy8gdHJpZ2dlcm9ic2VydmVyIHRyaWdnZXJzIGNyYWRsZSBjb250ZW50IHVwZGF0ZXMgXG4gICAgICAgIC8vICAgICB3aGVuIHRyaWdnZXJsaW5lcyBwYXNzIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAvLyBkZWZlciBjb25uZWN0RWxlbWVudHMgdW50aWwgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzIGhhdmUgYmVlbiBhc3NpZ25lZFxuICAgICAgICBjb25zdCB0cmlnZ2Vyb2JzZXJ2ZXIgPSB0cmlnZ2VybGluZXNJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdHJpZ2dlcm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhbmdlIGxpc3RzaXplLCBjYWNoaW5nLCByZXNpemUgKFVJIHJlc2l6ZSBvZiB0aGUgdmlld3BvcnQpLCByZWNvbmZpZ3VyZSwgb3IgcGl2b3RcblxuICAgIC8vIGluZXJuYWwgY2FsbGJhY2s6IHRoZSBuZXcgbGlzdCBzaXplIHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJyZW50IGxpc3RzaXplXG4gICAgLy8gaW52b2tlZCBpZiBnZXRJdGVtIHJldHVybnMgbnVsbFxuICAgIGNvbnN0IG51bGxJdGVtU2V0TWF4TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobWF4TGlzdHNpemUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdHNpemUgPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5saXN0c2l6ZVxuXG4gICAgICAgIGlmIChtYXhMaXN0c2l6ZSA8IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2dldEl0ZW0gcmV0dXJuZWQgbnVsbCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci51cGRhdGVMaXN0c2l6ZShtYXhMaXN0c2l6ZSlcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jaGFuZ2VDYWNoZUxpc3RzaXplKG1heExpc3RzaXplLCBcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2spXG5cbiAgICAgICAgfVxuICAgIH0sW10pXG5cbiAgICAvLyBjYWNoaW5nIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBpZiAoY2FjaGUgPT0gJ3ByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgc3dpdGNoIChjYWNoZSkge1xuXG4gICAgICAgICAgICBjYXNlICdrZWVwbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNYXggPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZU1heFxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChjYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2ssIHNjcm9sbGVySUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWNhY2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3JhZGxlJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlY2FjaGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW2NhY2hlLCBjYWNoZU1heF0pXG5cbiAgICAvLyB0cmlnZ2VyIHZpZXdwb3J0cmVzaXppbmcgcmVzcG9uc2UgYmFzZWQgb24gdmlld3BvcnQgc3RhdGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICAvLyBtb3ZlbWVudCB0byBhbmQgZnJvbSBjYWNoZSBpcyBpbmRlcGVuZGVudCBvZiB1aSB2aWV3cG9ydHJlc2l6aW5nXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50IHx8IHdhc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nKSAmJiBcbiAgICAgICAgICAgICAgICAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCAhPSAndmlld3BvcnRyZXNpemluZycpKSB7XG5cbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcbiBcbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCd2aWV3cG9ydHJlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcGxldGUgdmlld3BvcnRyZXNpemluZyBtb2RlXG4gICAgICAgIGlmICghVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcgJiYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3ZpZXdwb3J0cmVzaXppbmcnKSkge1xuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodmlld3BvcnRyZXNpemUnKVxuXG4gICAgICAgIH1cblxuICAgIH0sW1ZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nXSlcblxuICAgIC8vIHJlY29uZmlndXJlIGZvciBjaGFuZ2VkIHNpemUgcGFyYW1ldGVyc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlY29uZmlndXJlJylcblxuICAgIH0sW1xuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICBdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnRSb3djb3VudCwgY3Jvc3Njb3VudCB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBydW53YXlTaXplIH0gPSAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQgPSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG5cbiAgICAgICAgY29uc3QgaW5kZXhTcGFuID0gY29udGVudEhhbmRsZXIuaW5kZXhTcGFuXG4gICAgICAgIGNvbnN0IFtsb3dJbmRleCxoaWdoSW5kZXhdID0gaW5kZXhTcGFuXG5cbiAgICAgICAgbGV0IG1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50XG4gICAgICAgIGxldCBjaGFuZ2VJc1dpdGhpbkNyYWRsZVxuXG4gICAgICAgIGlmIChpbmRleFNwYW4ubGVuZ3RoID09IDApIHtcblxuICAgICAgICAgICAgbWVhc3VyZWRDcmFkbGVJdGVtQ291bnQgPSAwXG4gICAgICAgICAgICBjaGFuZ2VJc1dpdGhpbkNyYWRsZSA9IHRydWVcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBtZWFzdXJlZENyYWRsZUl0ZW1Db3VudCA9IGhpZ2hJbmRleCAtIGxvd0luZGV4ICsgMVxuICAgICAgICAgICAgY2hhbmdlSXNXaXRoaW5DcmFkbGUgPSAoaGlnaEluZGV4ID49IChsaXN0c2l6ZSAtIDEpKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50IDwgY2FsY3VsYXRlZENyYWRsZUl0ZW1jb3VudCkgfHwgLy8gc3ViLXZpZXdwb3J0IHZpc2libGUgbGlzdGNvdW50XG4gICAgICAgICAgICBjaGFuZ2VJc1dpdGhpbkNyYWRsZSkgeyAvLyBjaGFuZ2UgaXMgbm90IGJleW9uZCBjcmFkbGVcblxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVjb25maWd1cmVmb3JsaXN0c2l6ZScpXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICB9XG5cbiAgICB9LFtcbiAgICAgICAgbGlzdHNpemUsIFxuICAgIF0pXG5cbiAgICAvLyBhIG5ldyBnZXRJdGVtIGZ1bmN0aW9uIGltcGxpZXMgdGhlIG5lZWQgdG8gcmVsb2FkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlbG9hZCcpXG5cbiAgICB9LFtnZXRJdGVtXSlcblxuICAgIC8vIHBpdm90IHRyaWdnZXJlZCBvbiBjaGFuZ2Ugb2Ygb3JpZW50YXRpb25cbiAgICB1c2VFZmZlY3QoKCk9PiB7XG5cbiAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eSA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09IFwidmVydGljYWxcIik/XG4gICAgICAgICAgICAgICAgXCJzY3JvbGxUb3BcIjpcbiAgICAgICAgICAgICAgICBcInNjcm9sbExlZnRcIlxuXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFByb3BlcnR5ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpP1xuICAgICAgICAgICAgICAgIFwic2Nyb2xsVG9wXCI6XG4gICAgICAgICAgICAgICAgXCJzY3JvbGxMZWZ0XCJcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSB7XG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IDBcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFBvcyA9IDBcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGxheW91dCwgZ2FwIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcbiAgICAgICAgXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAvLyBnZXQgcHJldmlvdXMgcmF0aW9cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoOlxuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0KVxuICAgICAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc09mZnNldCA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzcmF0aW8gPSBwcmV2aW91c0F4aXNPZmZzZXQvcHJldmlvdXNDZWxsUGl4ZWxMZW5ndGhcblxuICAgICAgICAgICAgY29uc3QgcGl2b3RDZWxsUGl4ZWxMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICAgICAgY29uc3QgcGl2b3RBeGlzT2Zmc2V0ID0gcHJldmlvdXNyYXRpbyAqIHBpdm90Q2VsbFBpeGVsTGVuZ3RoXG5cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IE1hdGgucm91bmQocGl2b3RBeGlzT2Zmc2V0KVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGdhcFxuXG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3Bpdm90JylcblxuICAgIH0sW29yaWVudGF0aW9uXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgU1RZTEVTIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN0eWxlcyBmb3IgdGhlIHNpeCBzY2FmZm9sZCBjb21wb25lbnRzXG4gICAgY29uc3QgW1xuICAgICAgICBjcmFkbGVIZWFkU3R5bGUsXG4gICAgICAgIGNyYWRsZVRhaWxTdHlsZSxcbiAgICAgICAgY3JhZGxlQXhpc1N0eWxlLFxuICAgICAgICBjcmFkbGVEaXZpZGVyU3R5bGUsXG4gICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGUsXG4gICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGUsXG4gICAgXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlc0hhbmRsZXIuZ2V0Q3JhZGxlU3R5bGVzKHtcblxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICB1c2Vyc3R5bGVzOnN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICAgICAgbGF5b3V0LFxuXG4gICAgICAgIH0pXG5cbiAgICB9LFtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGxheW91dCxcblxuICAgICAgXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgU1RBVEUgTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgc3RhdGUgZW5naW5lIChhYm91dCAzMCBzdGF0ZXMpLCB1c2luZyBuYW1lZCBzdGF0ZXNcbiAgICAvLyB1c2VMYXlvdXRFZmZlY3QgZm9yIHN1cHByZXNzaW5nIGZsYXNoZXNcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tWyBwcmVjdXJzb3JzIHRvIHNldENyYWRsZUNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGFsbCB3b3JrZmxvdyByZWxhdGVkLCBidXRcbiAgICAgICAgICAgIC8vIHJlc2l6ZSBjb3VsZCBiZSBhc3luY2hyb25vdXMgd2hlbiByb3RhdGluZyBwaG9uZSBkdXJpbmcgc2Nyb2xsIGludGVydGlhXG5cbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzogeyAvLyBjeWNsZSB0byBhbGxvdyBmb3IgcmVmIGFzc2lnbm1lbnRzXG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LmNhY2hlICE9ICdwcmVsb2FkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NhY2hlZCcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXInKSAvLyBsb2FkIGdyaWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ZpZXdwb3J0cmVzaXppbmcnOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBuby1vcCwgd2FpdCBmb3IgcmVzaXppbmcgdG8gZW5kXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRwcmVsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxDYWxsYmFjayA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChjYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2ssIHNjcm9sbGVySUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWNoZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNocHJlbG9hZCcpXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NhY2hlZCcpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnByZWxvYWQoZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRClcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2NhY2hlZCc6IHtcblxuICAgICAgICAgICAgICAgIGlmICghd2FzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlIHdhaXQgZm9yIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdzdGFydHJlcG9zaXRpb24nOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IGludGVycnVwdEhhbmRsZXJcblxuICAgICAgICAgICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcblxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJlY3Vyc2l2ZSBjcmFkbGUgaW50ZXJzZWN0aW9uIGludGVycnVwdHNcbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgICAgICAgICAgc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSBmYWxzZSAvLyBiZWNhdXNlIG5vdyB1bmRlcndheVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEhhbmRsZXIuaXNTY3JvbGxpbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ1JlbmRlcicpIC8vIHRvZ2dsZXMgd2l0aCByZXBvc2l0aW9uaW5nQ29udGludWF0aW9uXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgc2V0Q3JhZGxlQ29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdGhlIGZvbGxvd2luZyAxMiBjcmFkbGUgc3RhdGVzIGFsbCByZXNvbHZlIHdpdGhcbiAgICAgICAgICAgICAgICBhIGNoYWluIHN0YXJ0aW5nIHdpdGggc2V0Q3JhZGxlQ29udGVudCwgXG4gICAgICAgICAgICAgICAgY29udGludWluZyB3aXRoICdwcmVwYXJlcmVuZGVyJywgYW5kIGVuZGluZyB3aXRoXG4gICAgICAgICAgICAgICAgJ3Jlc3RvcmVpbnRlcnJ1cHRzJywgd2l0aCBhIGRldG91ciBmb3IgdmFyaWFibGUgbGF5b3V0IFxuICAgICAgICAgICAgICAgIHRvIHJlY29uZmlndXJlIHRoZSBzY3JvbGxibG9ja1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njcm9sbHRvJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5nZWNhY2hpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocHJlbG9hZCc6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2hyZXBvc2l0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJzpcbiAgICAgICAgICAgIGNhc2UgJ3Bpdm90JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlZm9ybGlzdHNpemUnOlxuICAgICAgICAgICAgY2FzZSAncmVsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NhY2hlZCcpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuY3JhZGxlSW50ZXJzZWN0LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndmFyaWFibGUnKSB7IC8vIHJlc3RvcmUgYmFzZSBjb25maWcgdG8gc2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRvbmUgZm9yIHJlcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgKGNyYWRsZVN0YXRlICE9ICdmaW5pc2hyZXBvc2l0aW9uJykgJiYgbGF5b3V0SGFuZGxlci5yZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnKClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVsb2FkJykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyBzZXQgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChsaXN0c2l6ZSkgY29udGVudEhhbmRsZXIuc2V0Q3JhZGxlQ29udGVudCggY3JhZGxlU3RhdGUgKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlICE9ICdmaW5pc2hwcmVsb2FkJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbml6ZSBjYWNoZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUgPT0gJ2NyYWRsZScpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ21hdGNoIGNhY2hlIHRvIGNyYWRsZScsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLm1hdGNoQ2FjaGVUb0NyYWRsZShtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY3ljbGUgZm9yIHByZXBhcmVyZW5kZXJcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlydHVhbCBET01cbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncHJlcGFyZXJlbmRlcicpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWZyZXNoRE9Nc2V0Zm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncHJlcGFyZXJlbmRlcic6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdEVsZW1lbnRzIHdhcyBkZWxheWVkIGZvciBhIGN5Y2xlIHRvIHJlbmRlciB0cmlnZ2VyY2VsbCB0cmlnZ2VybGluZXNcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIuY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVzdG9yZWludGVycnVwdHMnKSAvLyB0byByZXN0b3JlIGludGVycnVwdHNcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3Jlc3RvcmVpbnRlcnJ1cHRzJzogeyAvLyBub3JtYWxpemVcblxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucmVzdG9yZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrIFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGZvbGxvd3VwIGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudCBdLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBzY3JvbGwgZWZmZWN0c1xuXG4gICAgICAgICAgICAvLyByZW5kZXJ1cGRhdGVkY29udGVudCBpcyBjYWxsZWQgZnJvbSB1cGRhdGVDcmFkbGVDb250ZW50LiBcbiAgICAgICAgICAgIC8vIGl0IGlzIHJlcXVpcmVkIHRvIGludGVncmF0ZSBjaGFuZ2VkIERPTSBjb25maWd1cmF0aW9ucyBiZWZvcmUgJ3JlYWR5JyBpcyBkaXNwbGF5ZWRcbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlcnVwZGF0ZWRjb250ZW50JzogeyAvLyBjeWNsZSBmb3IgRE9NIHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIudXBkYXRlQ3JhZGxlQ29udGVudCgpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9uaXplIGNhY2hlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nKClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtYWN0aXZhdGUgdHJpZ2dlcnM7IHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldENyYWRsZVN0YXRlKCdyZWNvbm5lY3R1cGRhdGVkY29udGVudCcpXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyAndmFyaWFibGUnIGNvbnRlbnQgcmVxdWlyaW5nIHJlY29uZmlndXJhdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWZyZXNoRE9NdXBkYXRlZm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBhZGp1c3Qgc2Nyb2xsYmxvY2sgZm9yIHNldCB2YXJpYWJsZSBjb250ZW50IF0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBjYXNlICdyZWZyZXNoRE9Nc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncHJlcGFyZXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncHJlcGFyZXNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIGdpdmUgdGltZSBmb3IgRE9NIHRvIHByb2R1Y2UgbGF5b3V0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkoJ3NldGNyYWRsZScpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hzZXRmb3J2YXJpYWJpbGl0eScpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2hzZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwcmVwYXJlcmVuZGVyJylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGFkanVzdCBzY3JvbGxibG9jayBmb3IgdXBkYXRlIHZhcmlhYmxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlZnJlc2hET011cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGN5Y2xlIHRvIGFsbG93IGZvciBET00gc3luY2hyb25pemlvbiB3aXRoIGdyaWQgY2hhbmdlc1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT4geyAvLyBhbGxvdyBtb3JlIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCd1cGRhdGVjcmFkbGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICB9LDApXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgLy8gcmUtYWN0aXZhdGUgdHJpZ2dlcnM7IHRyaWdnZXJsaW5lcyB3aWxsIGhhdmUgYmVlbiBhc3NpZ25lZCB0byBhIG5ldyB0cmlnZ2VyQ2VsbCBieSBub3cuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tWyB1c2VyIHJlcXVlc3RzIF0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWxjcmFkbGVyZXNldGFmdGVyaW5zZXJ0cmVtb3ZlJzoge1xuXG4gICAgICAgICAgICAgICAgYXBwbHlQb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QoY2FjaGVIYW5kbGVyKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWxpc3RzaXplYWZ0ZXJpbnNlcnRyZW1vdmUnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgdmFyaW91cyBob3N0IHNlcnZpY2UgcmVxdWVzdHM7IHN5bmNzIGNyYWRsZSBjb250ZW50IHdpdGggY2FjaGUgY2hhbmdlc1xuICAgICAgICAgICAgY2FzZSAnYXBwbHlpbnNlcnRyZW1vdmVjaGFuZ2VzJzpcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5cmVtYXBjaGFuZ2VzJzpcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5bW92ZWNoYW5nZXMnOiB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBhcHBseVBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdChjYWNoZUhhbmRsZXIpXG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ2FwcGx5aW5zZXJ0cmVtb3ZlY2hhbmdlcycpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlbGlzdHNpemVhZnRlcmluc2VydHJlbW92ZScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjaGFuZ2VsaXN0c2l6ZWFmdGVyaW5zZXJ0cmVtb3ZlJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3bGlzdHNpemUgPSBzZXJ2aWNlSGFuZGxlci5uZXdsaXN0c2l6ZVxuICAgICAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLm5ld2xpc3RzaXplID0gbnVsbFxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIC8vIHNlcnZpY2UgaGFuZGxlciBjYWxsZWQgYmVjYXVzZSB0aGlzIGlzIGEgZm9sbG93b24gb2YgYSB1c2VyIGludGVydmVudGlvblxuICAgICAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLnNldExpc3RzaXplKG5ld2xpc3RzaXplKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY2xlYXJjYWNoZSc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmNsZWFyQ3JhZGxlKClcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICBjb25zdCBhcHBseVBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IChjYWNoZUhhbmRsZXIpID0+IHtcblxuICAgICAgICBjb25zdCB7IHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCB9ID0gY2FjaGVIYW5kbGVyXG5cbiAgICAgICAgaWYgKHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCAmJiBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW1vdmVQYXJ0aXRpb25Qb3J0YWwoaXRlbS5wYXJ0aXRpb25JRCwgaXRlbS5pdGVtSUQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5wb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QgPSBbXSAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gc3RhbmRhcmQgcmVuZGVyaW5nIHN0YXRlcyAoMyBzdGF0ZXMpXG4gICAgdXNlRWZmZWN0KCgpPT4geyBcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmdSZW5kZXIgYW5kIHJlcG9zaXRpb25pbmdDb250aW51YXRpb24gYXJlIHRvZ2dsZWQgdG8gZ2VuZXJhdGUgY29udGludW91cyBcbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmcgcmVuZGVyc1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6IC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6IC8vIHNldCBmcm9tIG9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogLy8gbm8tb3BcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlU3RhdGVdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFJFTkRFUiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXggPSBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICBjb25zdCBzY3JvbGxJbmRleFJlZiA9IHVzZVJlZihzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgpXG4gICAgY29uc3Qgc2Nyb2xsVHJhY2tlckFyZ3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFbJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nLCdyZXBvc2l0aW9uaW5nUmVuZGVyJywnZmluaXNocmVwb3NpdGlvbiddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4ICE9IHNjcm9sbEluZGV4UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNjcm9sbEluZGV4UmVmLmN1cnJlbnQgPSBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHsgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2soc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCF1c2VTY3JvbGxUcmFja2VyKSByZXR1cm4gbnVsbFxuICAgICAgICBjb25zdCB0cmFja2VyYXJncyA9IHtcbiAgICAgICAgICAgIHRvcDp2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgMyxcbiAgICAgICAgICAgIGxlZnQ6dmlld3BvcnREaW1lbnNpb25zLmxlZnQgKyAzLFxuICAgICAgICAgICAgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrZXJhcmdzXG4gICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3JhZGxlU3RhdGUsIFxuICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zLCBcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIsXG4gICAgICAgIF1cbiAgICApXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gY29udGVudEhhbmRsZXIuY29udGVudFxuXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5ID0gJ2hlYWQnXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2hlYWR0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PixcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBrZXkgPSAndGFpbCdcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAndGFpbHRyaWdnZXInXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZX1cbiAgICAgICAgICAgICAgICByZWYgPSB7dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIF1cblxuICAgIH0sW1xuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlXG4gICAgXSlcblxuICAgIGNvbnN0IGNvbnRleHR2YWx1ZVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsXG4gICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjazpzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MuaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSlcblxuXG4gICAgLy8gZGlzcGxheSB0aGUgY3JhZGxlIGNvbXBvbmVudHMsIHRoZSBTY3JvbGxUcmFja2VyLCBvciBudWxsXG4gICAgcmV0dXJuIDxDcmFkbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBjb250ZXh0dmFsdWVSZWYuY3VycmVudCB9PlxuXG4gICAgICAgIHsoWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSk/XG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MudG9wIH0gXG4gICAgICAgICAgICAgICAgbGVmdCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MubGVmdCB9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3Muc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IH0gXG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnN0eWxlcyB9XG4gICAgICAgICAgICAvPjpudWxsOlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWF4aXMnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZUF4aXNTdHlsZSB9IFxuICAgICAgICAgICAgICAgIHJlZiA9IHsgYXhpc0NyYWRsZUVsZW1lbnRSZWYgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgc2hvd0F4aXM/IC8vIGZvciBkZWJ1Z1xuICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2NyYWRsZS1kaXZpZGVyJyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVEaXZpZGVyU3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0geyBoZWFkQ3JhZGxlRWxlbWVudFJlZiB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVIZWFkU3R5bGUgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHsgdGFpbENyYWRsZUVsZW1lbnRSZWYgfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZVRhaWxTdHlsZSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB7KGNyYWRsZVN0YXRlICE9ICdzZXR1cCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG5cbiAgICA8L0NyYWRsZUNvbnRleHQuUHJvdmlkZXI+XG5cbn0gLy8gQ3JhZGxlXG5cbmV4cG9ydCBkZWZhdWx0IENyYWRsZVxuXG4vLyB1dGlsaXR5XG5cbmNvbnN0IGdldENyYWRsZUhhbmRsZXJzID0gKGNyYWRsZVBhcmFtZXRlcnMpID0+IHtcblxuICAgIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSBoYW5kbGVyID0+IG5ldyBoYW5kbGVyKGNyYWRsZVBhcmFtZXRlcnMpXG5cbiAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgIGNhY2hlSGFuZGxlci5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIGludGVycnVwdEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihJbnRlcnJ1cHRIYW5kbGVyKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNjcm9sbEhhbmRsZXIpLFxuICAgICAgICBzdGF0ZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdGF0ZUhhbmRsZXIpLFxuICAgICAgICBjb250ZW50SGFuZGxlcjpjcmVhdGVIYW5kbGVyKENvbnRlbnRIYW5kbGVyKSxcbiAgICAgICAgbGF5b3V0SGFuZGxlcjpjcmVhdGVIYW5kbGVyKExheW91dEhhbmRsZXIpLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNlcnZpY2VIYW5kbGVyKSxcbiAgICAgICAgc3R5bGVzSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0eWxlc0hhbmRsZXIpLFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiQXJyYXkiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibGVuZ3RoIiwiaSIsIkYiLCJzIiwibiIsImRvbmUiLCJ2YWx1ZSIsImUiLCJfZTIiLCJmIiwiVHlwZUVycm9yIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsImVyciIsImNhbGwiLCJzdGVwIiwibmV4dCIsIl9lMyIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIl9pIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsInB1c2giLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsIlZpZXdwb3J0XzEiLCJTY3JvbGxUcmFja2VyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJzY3JvbGxoYW5kbGVyXzEiLCJzdGF0ZWhhbmRsZXJfMSIsImNvbnRlbnRoYW5kbGVyXzEiLCJsYXlvdXRoYW5kbGVyXzEiLCJpbnRlcnJ1cHRoYW5kbGVyXzEiLCJzZXJ2aWNlaGFuZGxlcl8xIiwic3R5bGVzaGFuZGxlcl8xIiwiSW5maW5pdGVHcmlkU2Nyb2xsZXJfMSIsImV4cG9ydHMiLCJDcmFkbGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkNyYWRsZSIsIl9yZWYiLCJncmlkU3BlY3MiLCJydW53YXlTaXplIiwibGlzdHNpemUiLCJ1cGRhdGVMaXN0c2l6ZSIsInN0YXJ0aW5nSW5kZXgiLCJnZXRJdGVtIiwicGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlck1lc3NhZ2VzIiwidXNlckNhbGxiYWNrcyIsInN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiY2FjaGUiLCJjYWNoZU1heCIsInNjcm9sbGVySUQiLCJjYWNoZUhhbmRsZXIiLCJ1c2VQbGFjZWhvbGRlciIsInVzZVNjcm9sbFRyYWNrZXIiLCJzaG93QXhpcyIsIk9OQUZURVJTQ1JPTExfVElNRU9VVCIsIklETEVDQUxMQkFDS19USU1FT1VUIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJvcmllbnRhdGlvbiIsImdhcCIsInBhZGRpbmciLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImxheW91dCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJ1c2VDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJpc01vdW50ZWRSZWYiLCJpc0NhY2hlZFJlZiIsIndhc0NhY2hlZFJlZiIsImhhc0JlZW5SZW5kZXJlZFJlZiIsInRyaWdnZXJIaXN0b3J5UmVmIiwicHJldmlvdXNSZWZlcmVuY2VOYW1lIiwiZ2V0Vmlld3BvcnREaW1lbnNpb25zIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJfZ2V0Vmlld3BvcnREaW1lbnNpb24iLCJ2aWV3cG9ydGhlaWdodCIsInZpZXdwb3J0d2lkdGgiLCJpc0luUG9ydGFsIiwiaXNDYWNoZUNoYW5nZSIsIl9yZWYyIiwidXNlU3RhdGUiLCJfcmVmMyIsImNyYWRsZVN0YXRlIiwic2V0Q3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImhlYWRDcmFkbGVFbGVtZW50UmVmIiwidGFpbENyYWRsZUVsZW1lbnRSZWYiLCJheGlzQ3JhZGxlRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiIsImNyYWRsZUVsZW1lbnRzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJheGlzUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZiIsImNyb3NzY291bnQiLCJ1c2VNZW1vIiwidmlld3BvcnRjcm9zc2xlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjIiwiY2VsbGNyb3NzbGVuZ3RoIiwiY2VsbGNyb3NzbGVuZ3RoZm9yY2FsYyIsIk1hdGgiLCJtaW4iLCJmbG9vciIsIl9yZWY0Iiwidmlld3BvcnRMZW5ndGgiLCJiYXNlUm93TGVuZ3RoIiwidmlld3BvcnRSb3djb3VudCIsImNlaWwiLCJsaXN0Um93Y291bnQiLCJjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwiZGlmZiIsIm1heCIsIml0ZW1jb3VudCIsIl9yZWY1IiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsInJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3JhZGxlUGFyYW1ldGVycyIsImNyYWRsZVBhcmFtZXRlcnNSZWYiLCJnZXRDcmFkbGVIYW5kbGVycyIsIl9oYW5kbGVyc1JlZiRjdXJyZW50IiwiaW50ZXJydXB0SGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJjb250ZW50SGFuZGxlciIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsInN0eWxlc0hhbmRsZXIiLCJyZXN0b3JlU2Nyb2xsUG9zIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYmxvY2tTY3JvbGxQb3MiLCJibG9ja1hTY3JvbGxQb3MiLCJibG9ja1Njcm9sbFByb3BlcnR5IiwiYmxvY2tYU2Nyb2xsUHJvcGVydHkiLCJ1c2VFZmZlY3QiLCJmdW5jdGlvbnNDYWxsYmFjayIsInNjcm9sbFRvSW5kZXgiLCJyZWxvYWQiLCJzZXRMaXN0c2l6ZSIsImNsZWFyQ2FjaGUiLCJnZXRDYWNoZUluZGV4TWFwIiwiZ2V0Q2FjaGVJdGVtTWFwIiwiZ2V0Q3JhZGxlSW5kZXhNYXAiLCJyZW1hcEluZGV4ZXMiLCJtb3ZlSW5kZXgiLCJpbnNlcnRJbmRleCIsInJlbW92ZUluZGV4IiwiZnVuY3Rpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uU2Nyb2xsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzU2FmYXJpSU9TIiwiaU9Tb25TY3JvbGwiLCJjcmFkbGVJbnRlcnNlY3QiLCJ0cmlnZ2VybGluZXNJbnRlcnNlY3QiLCJjcmFkbGVpbnRlcnNlY3RvYnNlcnZlciIsImNyZWF0ZU9ic2VydmVyIiwiY29ubmVjdEVsZW1lbnRzIiwidHJpZ2dlcm9ic2VydmVyIiwiZGlzY29ubmVjdCIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJ1c2VDYWxsYmFjayIsIm1heExpc3RzaXplIiwiX3NlcnZpY2VIYW5kbGVyJGNhbGxiIiwiY2FsbGJhY2tzIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJjaGFuZ2VDYWNoZUxpc3RzaXplIiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsInBhcmVDYWNoZVRvTWF4IiwicmVuZGVyUG9ydGFsTGlzdHMiLCJfZExpc3RDYWxsYmFjayIsIm1hdGNoQ2FjaGVUb0NyYWRsZSIsImlzUmVzaXppbmciLCJwYXVzZUludGVycnVwdHMiLCJfY3JhZGxlSW50ZXJuYWxQcm9wZXIiLCJjYWxjdWxhdGVkQ3JhZGxlSXRlbWNvdW50IiwiaW5kZXhTcGFuIiwiX2luZGV4U3BhbiIsImxvd0luZGV4IiwiaGlnaEluZGV4IiwibWVhc3VyZWRDcmFkbGVJdGVtQ291bnQiLCJjaGFuZ2VJc1dpdGhpbkNyYWRsZSIsIl9jcmFkbGVJbmhlcml0ZWRQcm9wZSIsIl9jcmFkbGVJbmhlcml0ZWRQcm9wZTIiLCJwcmV2aW91c0NlbGxQaXhlbExlbmd0aCIsInByZXZpb3VzQXhpc09mZnNldCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwicHJldmlvdXNyYXRpbyIsInBpdm90Q2VsbFBpeGVsTGVuZ3RoIiwicGl2b3RBeGlzT2Zmc2V0Iiwicm91bmQiLCJfcmVmNiIsImdldENyYWRsZVN0eWxlcyIsInVzZXJzdHlsZXMiLCJfcmVmNyIsImNyYWRsZUhlYWRTdHlsZSIsImNyYWRsZVRhaWxTdHlsZSIsImNyYWRsZUF4aXNTdHlsZSIsImNyYWRsZURpdmlkZXJTdHlsZSIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGUiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlIiwidXNlTGF5b3V0RWZmZWN0IiwiZmluYWxDYWxsYmFjayIsInByZWxvYWQiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyZXBvc2l0aW9uaW5nUmVxdWlyZWQiLCJpc1Njcm9sbGluZyIsImNyYWRsZUNvbnRlbnQiLCJjb250ZW50IiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnIiwic2V0Q3JhZGxlQ29udGVudCIsImhlYWREaXNwbGF5Q29tcG9uZW50cyIsInRhaWxEaXNwbGF5Q29tcG9uZW50cyIsInJlc3RvcmVJbnRlcnJ1cHRzIiwidXBkYXRlQ3JhZGxlQ29udGVudCIsImd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nIiwic2V0VGltZW91dCIsImFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkiLCJhcHBseVBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCIsIm5ld2xpc3RzaXplIiwiY2xlYXJDcmFkbGUiLCJwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QiLCJfaXRlcmF0b3IiLCJfc3RlcCIsIml0ZW0iLCJyZW1vdmVQYXJ0aXRpb25Qb3J0YWwiLCJwYXJ0aXRpb25JRCIsIml0ZW1JRCIsInNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInNjcm9sbEluZGV4UmVmIiwic2Nyb2xsVHJhY2tlckFyZ3MiLCJpbmNsdWRlcyIsInRyYWNrZXJhcmdzIiwidG9wIiwibGVmdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmIiwiY3JlYXRlRWxlbWVudCIsImtleSIsInN0eWxlIiwicmVmIiwiY29udGV4dHZhbHVlUmVmIiwiUHJvdmlkZXIiLCJvZmZzZXQiLCJjcmVhdGVIYW5kbGVyIiwiaGFuZGxlciIsInN0YXRlSGFuZGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/InfiniteGridScroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// InfiniteGridScroller.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isSafariIOS = void 0;\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the Scrollblock, which is full size for listsize of given cell height/width.\n    Scrollblock in turn contains the Cradle - a component that contains CellFrames, which contain\n    displayed user content (items) or transitional placeholders.\n\n    Host content is instantiated in a cache of React portals (via cacheHandler). Content is then\n    portal\'d to CellFrames. The cache can be configured to hold more items than the Cradle (limited by\n    device memory). Caching allows host content to maintain state.\n\n    Scrollblock represents the entirety of the list (and is sized accordingly). It is the object that is scrolled.\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as though it scrolls through a filled\n    scrollblock, but in fact it is only slightly larger than the viewport. Content is rotated in and out of the\n    cradle through the cache.\n    \n    Individual host items are framed by CellFrame, which are managed by Cradle.\n\n    Overall the InfiniteGridScroller as a package manages the asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n\n    The Rigs liner (the top level Viewport element) is set with \'display:absolute\' and \'inset:0\', so the user\n    containing block should be styles accordingly.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n// defensive\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ "./node_modules/react-error-boundary/dist/react-error-boundary.module.js"); // www.npmjs.com/package/react-error-boundary\nvar isSafariIOS = function isSafariIOS() {\n  var is_ios = /iP(ad|od|hone)/i.test(window.navigator.userAgent),\n    is_safari = !!navigator.userAgent.match(/Version\\/[\\d\\.]+.*Safari/);\n  return is_ios && is_safari;\n};\nexports.isSafariIOS = isSafariIOS;\n// based on module template\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n    resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert"\n  }, react_1["default"].createElement("p", null, "Oops! Something went wrong inside react-infinite-grid-scroller."), react_1["default"].createElement("p", null, "Click to cancel the error and continue."), react_1["default"].createElement("button", {\n    onClick: resetErrorBoundary\n  }, "Cancel error"), react_1["default"].createElement("pre", null, error));\n}\n// scroller components\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx"));\n// loaded here to minimize redundant renders in Cradle\nvar PortalCache_1 = __importDefault(__webpack_require__(/*! ./PortalCache */ "./src/PortalCache.tsx"));\n// -------------------[ global session ID generator ]----------------\nvar globalScrollerID = 0;\n// ===================================[ INITIALIZE ]===========================\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n    cellWidth = props.cellWidth,\n    _props$startingListSi = props.startingListSize,\n    startingListSize = _props$startingListSi === void 0 ? 0 : _props$startingListSi,\n    getItem = props.getItem,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n    _props$gap = props.gap,\n    gap = _props$gap === void 0 ? 0 : _props$gap,\n    _props$padding = props.padding,\n    padding = _props$padding === void 0 ? 0 : _props$padding,\n    _props$layout = props.layout,\n    layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n    _props$cellMinHeight = props.cellMinHeight,\n    cellMinHeight = _props$cellMinHeight === void 0 ? 25 : _props$cellMinHeight,\n    _props$cellMinWidth = props.cellMinWidth,\n    cellMinWidth = _props$cellMinWidth === void 0 ? 25 : _props$cellMinWidth,\n    _props$runwaySize = props.runwaySize,\n    runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n    _props$startingIndex = props.startingIndex,\n    startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n    _props$cache = props.cache,\n    cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n    _props$cacheMax = props.cacheMax,\n    cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n    placeholder = props.placeholder,\n    _props$usePlaceholder = props.usePlaceholder,\n    usePlaceholder = _props$usePlaceholder === void 0 ? true : _props$usePlaceholder,\n    _props$useScrollTrack = props.useScrollTracker,\n    useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n    _props$styles = props.styles,\n    styles = _props$styles === void 0 ? {} : _props$styles,\n    _props$placeholderMes = props.placeholderMessages,\n    placeholderMessages = _props$placeholderMes === void 0 ? {} : _props$placeholderMes,\n    _props$callbacks = props.callbacks,\n    callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n    _props$technical = props.technical,\n    technical = _props$technical === void 0 ? {} : _props$technical,\n    scrollerProperties = props.scrollerProperties;\n  var isMinimalPropsFail = false;\n  if (!(cellWidth && cellHeight && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight, and getItem are required\');\n    isMinimalPropsFail = true;\n  }\n  // ---------------------[ Data setup ]----------------------\n  var originalValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  // avoid null/undefined\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  technical = technical !== null && technical !== void 0 ? technical : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  startingListSize = startingListSize !== null && startingListSize !== void 0 ? startingListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  usePlaceholder = usePlaceholder !== null && usePlaceholder !== void 0 ? usePlaceholder : true;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  cellMinHeight = cellMinHeight !== null && cellMinHeight !== void 0 ? cellMinHeight : 0;\n  cellMinWidth = cellMinWidth !== null && cellMinWidth !== void 0 ? cellMinWidth : 0;\n  cacheMax = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n  cellHeight = +cellHeight;\n  cellWidth = +cellWidth;\n  cellMinHeight = +cellMinHeight;\n  cellMinWidth = +cellMinWidth;\n  gap = +gap;\n  padding = +padding;\n  startingIndex = +startingIndex;\n  startingListSize = +startingListSize;\n  runwaySize = +runwaySize;\n  cacheMax = +cacheMax;\n  var verifiedValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  cellMinHeight = Math.max(cellMinHeight, 25);\n  cellMinWidth = Math.max(cellMinWidth, 25);\n  cellMinHeight = Math.min(cellHeight, cellMinHeight);\n  cellMinWidth = Math.min(cellWidth, cellMinWidth);\n  // prop constraints - non-negative values\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n  startingListSize = Math.max(0, startingListSize);\n  startingIndex = Math.max(0, startingIndex);\n  // package\n  var problems = 0;\n  for (var prop in verifiedValues) {\n    if (isNaN(verifiedValues[prop])) {\n      problems++;\n    }\n  }\n  if (problems) {\n    console.error(\'Error: invalid number - compare originalValues and verifiedValues\', originalValues, verifiedValues);\n  }\n  // enums\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  }\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs);\n  // state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    scrollerState = _ref3[0],\n    setScrollerState = _ref3[1]; // setup, setlistsize, ready\n  // system\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var placeholderMessagesRef = (0, react_1.useRef)(placeholderMessages);\n  var _technical = technical,\n    showAxis = _technical.showAxis,\n    triggerlineOffset = _technical.triggerlineOffset,\n    VIEWPORT_RESIZE_TIMEOUT = _technical.VIEWPORT_RESIZE_TIMEOUT,\n    ONAFTERSCROLL_TIMEOUT = _technical.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _technical.IDLECALLBACK_TIMEOUT,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _technical.VARIABLE_MEASUREMENTS_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _technical.MAX_CACHE_OVER_RUN,\n    CACHE_PARTITION_SIZE = _technical.CACHE_PARTITION_SIZE;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  ONAFTERSCROLL_TIMEOUT = ONAFTERSCROLL_TIMEOUT !== null && ONAFTERSCROLL_TIMEOUT !== void 0 ? ONAFTERSCROLL_TIMEOUT : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 250;\n  VARIABLE_MEASUREMENTS_TIMEOUT = VARIABLE_MEASUREMENTS_TIMEOUT !== null && VARIABLE_MEASUREMENTS_TIMEOUT !== void 0 ? VARIABLE_MEASUREMENTS_TIMEOUT : 250;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE !== null && CACHE_PARTITION_SIZE !== void 0 ? CACHE_PARTITION_SIZE : 30;\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  triggerlineOffset = triggerlineOffset !== null && triggerlineOffset !== void 0 ? triggerlineOffset : 10;\n  if (typeof usePlaceholder != \'boolean\') usePlaceholder = true;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true;\n  // for mount version\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current;\n  // for children\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(startingListSize);\n  var listsize = listsizeRef.current;\n  // tests for React with Object.is for changed properties; avoid re-renders with no change\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  }\n  if (!compareProps(placeholderMessages, placeholderMessagesRef.current)) {\n    placeholderMessagesRef.current = placeholderMessages;\n  }\n  // -------------------------[ Initialization ]-------------------------------\n  var getCacheAPI = function getCacheAPI(cacheHandler) {\n    cacheHandlerRef.current = cacheHandler;\n  };\n  (0, react_1.useEffect)(function () {\n    if (scrollerSessionIDRef.current === null) {\n      // defend against React.StrictMode double run\n      scrollerSessionIDRef.current = globalScrollerID++;\n      // cacheHandlerRef.current = new CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef, \n      //     CACHE_PARTITION_SIZE)\n    }\n  }, []);\n  // called when getItem returns null, or direct call from user (see serviceHandler)\n  var updateListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize;\n    // inform the user\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistsize\');\n  }, []);\n  // ---------------------[ State handling ]------------------------\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n      case \'setlistsize\':\n        setScrollerState(\'ready\');\n    }\n  }, [scrollerState]);\n  // --------------------[ Render ]---------------------\n  if (problems || isMinimalPropsFail) {\n    return react_1["default"].createElement("div", null, "error: see console.");\n  }\n  // component calls are deferred by scrollerState to give cacheHandler a chance to initialize\n  return react_1["default"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {\n      // response tbd; there may not need to be one\n    },\n    onError: function onError(error, info) {\n      console.log(\'react-infinite-grid-scroller captured error\', error);\n    }\n  }, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    // scrollerProperties = { scrollerProperties }\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    updateListsize: updateListsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessagesRef.current,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    scrollerProperties: scrollerProperties,\n    cacheHandler: cacheHandlerRef.current,\n    usePlaceholder: usePlaceholder,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT: VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerID: scrollerID\n  }))), scrollerState != \'setup\' && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(PortalCache_1["default"], {\n    scrollerSessionIDRef: scrollerSessionIDRef,\n    setListsize: updateListsize,\n    listsizeRef: listsizeRef,\n    getCacheAPI: getCacheAPI,\n    CACHE_PARTITION_SIZE: CACHE_PARTITION_SIZE\n  })));\n};\nexports["default"] = InfiniteGridScroller;\n// ----------------------------[ Support ]------------------------------\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\nfunction compareProps(obj1, obj2) {\n  if (!obj1 || !obj2) return false;\n  var keys = Object.keys(obj1);\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxHQUFBQyxLQUFBLENBQUEvSSxNQUFBLEVBQUE4SSxHQUFBLElBQUU7SUFBbkIsSUFBTUUsR0FBRyxHQUFBRCxLQUFBLENBQUFELEdBQUE7SUFDVixJQUFJLENBQUN6SixNQUFNLENBQUM0SixFQUFFLENBQUNOLElBQUksQ0FBQ0ssR0FBRyxDQUFDLEVBQUNKLElBQUksQ0FBQ0ksR0FBRyxDQUFDLENBQUMsRUFBRTtNQUNqQyxPQUFPLEtBQUs7OztFQUdwQixPQUFPLElBQUk7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvSW5maW5pdGVHcmlkU2Nyb2xsZXIudHN4PzdmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5maW5pdGVHcmlkU2Nyb2xsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIHJlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIgPSBSSUdTXG5cbiAgICBUaGUgam9iIG9mIEluZmluaXRlR3JpZFNjcm9sbGVyIGlzIHRvIHBhc3MgcGFyYW1ldGVycyB0byBkZXBlbmRlbnRzLlxuICAgIFZpZXdwb3J0IGNvbnRhaW5zIHRoZSBTY3JvbGxibG9jaywgd2hpY2ggaXMgZnVsbCBzaXplIGZvciBsaXN0c2l6ZSBvZiBnaXZlbiBjZWxsIGhlaWdodC93aWR0aC5cbiAgICBTY3JvbGxibG9jayBpbiB0dXJuIGNvbnRhaW5zIHRoZSBDcmFkbGUgLSBhIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIENlbGxGcmFtZXMsIHdoaWNoIGNvbnRhaW4gXG4gICAgZGlzcGxheWVkIHVzZXIgY29udGVudCAoaXRlbXMpIG9yIHRyYW5zaXRpb25hbCBwbGFjZWhvbGRlcnMuIFxuXG4gICAgSG9zdCBjb250ZW50IGlzIGluc3RhbnRpYXRlZCBpbiBhIGNhY2hlIG9mIFJlYWN0IHBvcnRhbHMgKHZpYSBjYWNoZUhhbmRsZXIpLiBDb250ZW50IGlzIHRoZW4gXG4gICAgcG9ydGFsJ2QgdG8gQ2VsbEZyYW1lcy4gVGhlIGNhY2hlIGNhbiBiZSBjb25maWd1cmVkIHRvIGhvbGQgbW9yZSBpdGVtcyB0aGFuIHRoZSBDcmFkbGUgKGxpbWl0ZWQgYnkgXG4gICAgZGV2aWNlIG1lbW9yeSkuIENhY2hpbmcgYWxsb3dzIGhvc3QgY29udGVudCB0byBtYWludGFpbiBzdGF0ZS5cblxuICAgIFNjcm9sbGJsb2NrIHJlcHJlc2VudHMgdGhlIGVudGlyZXR5IG9mIHRoZSBsaXN0IChhbmQgaXMgc2l6ZWQgYWNjb3JkaW5nbHkpLiBJdCBpcyB0aGUgb2JqZWN0IHRoYXQgaXMgc2Nyb2xsZWQuXG5cbiAgICBDcmFkbGUgY29udGFpbnMgdGhlIGxpc3QgaXRlbXMsIGFuZCBpcyAndmlydHVhbGl6ZWQnIC0tIGl0IGFwcGVhcnMgYXMgdGhvdWdoIGl0IHNjcm9sbHMgdGhyb3VnaCBhIGZpbGxlZCBcbiAgICBzY3JvbGxibG9jaywgYnV0IGluIGZhY3QgaXQgaXMgb25seSBzbGlnaHRseSBsYXJnZXIgdGhhbiB0aGUgdmlld3BvcnQuIENvbnRlbnQgaXMgcm90YXRlZCBpbiBhbmQgb3V0IG9mIHRoZSBcbiAgICBjcmFkbGUgdGhyb3VnaCB0aGUgY2FjaGUuXG4gICAgXG4gICAgSW5kaXZpZHVhbCBob3N0IGl0ZW1zIGFyZSBmcmFtZWQgYnkgQ2VsbEZyYW1lLCB3aGljaCBhcmUgbWFuYWdlZCBieSBDcmFkbGUuXG5cbiAgICBPdmVyYWxsIHRoZSBJbmZpbml0ZUdyaWRTY3JvbGxlciBhcyBhIHBhY2thZ2UgbWFuYWdlcyB0aGUgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBvZiB0aGUgXG4gICAgY29tcG9uZW50cyBvZiB0aGUgbWVjaGFuaXNtLiBNb3N0IG9mIHRoZSB3b3JrIG9jY3VycyBpbiB0aGUgQ3JhZGxlIGNvbXBvbmVudC5cblxuICAgIFRoZSBSaWdzIGxpbmVyICh0aGUgdG9wIGxldmVsIFZpZXdwb3J0IGVsZW1lbnQpIGlzIHNldCB3aXRoICdkaXNwbGF5OmFic29sdXRlJyBhbmQgJ2luc2V0OjAnLCBzbyB0aGUgdXNlciBcbiAgICBjb250YWluaW5nIGJsb2NrIHNob3VsZCBiZSBzdHlsZXMgYWNjb3JkaW5nbHkuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBkZWZlbnNpdmVcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICdyZWFjdC1lcnJvci1ib3VuZGFyeScgLy8gd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LWVycm9yLWJvdW5kYXJ5XG5cbmV4cG9ydCBjb25zdCBpc1NhZmFyaUlPUyA9ICgpID0+IHtcbiAgICBjb25zdFxuICAgICAgICBpc19pb3MgPSAvaVAoYWR8b2R8aG9uZSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgaXNfc2FmYXJpID0gISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvW1xcZFxcLl0rLipTYWZhcmkvKVxuICAgIHJldHVybiAoIGlzX2lvcyAmJiBpc19zYWZhcmkgKSBcbn1cblxuLy8gYmFzZWQgb24gbW9kdWxlIHRlbXBsYXRlXG5mdW5jdGlvbiBFcnJvckZhbGxiYWNrKHtlcnJvciwgcmVzZXRFcnJvckJvdW5kYXJ5fSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgcm9sZT1cImFsZXJ0XCI+XG4gICAgICA8cD5Pb3BzISBTb21ldGhpbmcgd2VudCB3cm9uZyBpbnNpZGUgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci48L3A+XG4gICAgICA8cD5DbGljayB0byBjYW5jZWwgdGhlIGVycm9yIGFuZCBjb250aW51ZS48L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eyByZXNldEVycm9yQm91bmRhcnkgfT5DYW5jZWwgZXJyb3I8L2J1dHRvbj5cbiAgICAgIDxwcmU+e2Vycm9yfTwvcHJlPlxuICAgIDwvZGl2PlxuICApXG59XG5cbi8vIHNjcm9sbGVyIGNvbXBvbmVudHNcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL1ZpZXdwb3J0J1xuaW1wb3J0IFNjcm9sbGJsb2NrIGZyb20gJy4vU2Nyb2xsYmxvY2snXG5pbXBvcnQgQ3JhZGxlIGZyb20gJy4vQ3JhZGxlJ1xuXG4vLyBsb2FkZWQgaGVyZSB0byBtaW5pbWl6ZSByZWR1bmRhbnQgcmVuZGVycyBpbiBDcmFkbGVcbmltcG9ydCBQb3J0YWxDYWNoZSBmcm9tICcuL1BvcnRhbENhY2hlJ1xuaW1wb3J0IENhY2hlSGFuZGxlciBmcm9tICcuL3BvcnRhbGNhY2hlL2NhY2hlaGFuZGxlcidcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgZ2xvYmFsIHNlc3Npb24gSUQgZ2VuZXJhdG9yIF0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBnbG9iYWxTY3JvbGxlcklEID0gMFxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaRSBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IEluZmluaXRlR3JpZFNjcm9sbGVyID0gKHByb3BzKSA9PiB7XG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVsgbm9ybWFsaXplIHByb3BlcnRpZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgeyBcblxuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICBjZWxsSGVpZ2h0LCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIGhlaWdodCAtIGxpdGVyYWwgZm9yIHZlcnRpY2FsOyBhcHByb3hpbWF0ZSBmb3IgaG9yaXpvbnRhbFxuICAgICAgICAgICAgLy8gbWF4IGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgY2VsbFdpZHRoLCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIHdpZHRoIC0gbGl0ZXJhbCBmb3IgaG9yaXpvbnRhbDsgYXBwcm94aW1hdGUgZm9yIHZlcnRpY2FsXG4gICAgICAgICAgICAvLyBtYXggZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICBzdGFydGluZ0xpc3RTaXplID0gMCwgLy8gdGhlIHN0YXJnaW5nIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdmlydHVhbCBsaXN0LiBjYW4gYmUgY2hhbmdlZFxuICAgICAgICBnZXRJdGVtLCAvLyByZXF1aXJlZC4gZnVuY3Rpb24gcHJvdmlkZWQgYnkgaG9zdCAtIHBhcmFtZXRlcnMgc2V0IGJ5IHN5c3RlbSBhcmUgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAvLyBhbmQgc2Vzc2lvbiBpdGVtSUQgZm9yIHRyYWNraW5nIGFuZCBtYXRjaGluZzsgXG4gICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudCwgb3IgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICAvLyBncmlkIHNwZWNzOlxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwID0gMCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG4gICAgICAgIHBhZGRpbmcgPSAwLCAvLyB0aGUgYm9yZGVyIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBsYXlvdXQgPSAndW5pZm9ybScsIC8vIHVuaWZvcm0sIHZhcmlhYmxlXG4gICAgICAgIGNlbGxNaW5IZWlnaHQgPSAyNSwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCdcbiAgICAgICAgY2VsbE1pbldpZHRoID0gMjUsIC8vIGZvciBsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAvLyBzY3JvbGxlciBzcGVjczpcbiAgICAgICAgcnVud2F5U2l6ZSA9IDMsIC8vIHRoZSBudW1iZXIgb2Ygcm93cyBvdXRzaWRlIHRoZSB2aWV3IG9mIGVhY2ggc2lkZSBvZiB0aGUgdmlld3BvcnQgXG4gICAgICAgICAgICAvLyAtLSBnaXZlcyB0aW1lIHRvIGFzc2VtYmxlIGNlbGxGcmFtZXMgYmVmb3JlIGRpc3BsYXlcbiAgICAgICAgc3RhcnRpbmdJbmRleCA9IDAsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuXG4gICAgICAgIC8vIHN5c3RlbSBzcGVjczpcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJywgLy8gXCJwcmVsb2FkXCIsIFwia2VlcGxvYWRcIiBvciBcImNyYWRsZVwiXG4gICAgICAgIGNhY2hlTWF4ID0gbnVsbCwgLy8gYWx3YXlzIG1pbmltdW0gY3JhZGxlIGNvbnRlbnQgc2l6ZTsgZmFsc2V5IG1lYW5zIGxpbWl0ZWQgYnkgbGlzdHNpemVcbiAgICAgICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsLiBhIHNwYXJzZSBjb21wb25lbnQgdG8gc3RhbmQgaW4gZm9yIGNvbnRlbnQgdW50aWwgdGhlIGNvbnRlbnQgYXJyaXZlczsgXG4gICAgICAgICAgICAvLyByZXBsYWNlcyBkZWZhdWx0IHBsYWNlaG9sZGVyIGlmIHByZXNlbnRcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIgPSB0cnVlLCAvLyBubyBwbGFjZWhvbGRlciByZW5kZXJlZCBpZiBmYWxzZVxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZSwgLy8gdGhlIGludGVybmFsIGNvbXBvbmVudCB0byBnaXZlIGZlZWRiYWNrIGZvciByZXBvc2l0aW9uaW5nXG5cbiAgICAgICAgLy8gYWR2YW5jZWQgb2JqZWN0c1xuICAgICAgICBzdHlsZXMgPSB7fSwgLy8gb3B0aW9uYWwuIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KTsgaGFzIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB2aWV3cG9ydCwgc2Nyb2xsYmxvY2ssIGNyYWRsZSwgc2Nyb2xsdHJhY2tlciwgcGxhY2Vob2xkZXJmcmFtZSwgXG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlcmVycm9yZnJhbWUsIHBsYWNlaG9sZGVybGluZXIgb3IgcGxhY2Vob2xkZXJlcnJvcmxpbmVyLiBEbyBub3QgbWFrZSBzdHJ1Y3R1cmFsIGNoYW5nZXMhXG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7fSwgLy8gbWVzc2FnZXMgcHJlc2VudGVkIGJ5IGRlZmF1bHQgcGxhY2Vob2xkZXIuIFNlZSBkb2N1bWVudGF0aW9uXG4gICAgICAgIGNhbGxiYWNrcyA9IHt9LCAvLyBvcHRpb25hbC4gY2xvc3VyZXMgdG8gZ2V0IGRpcmVjdCBpbmZvcm1hdGlvbiBzdHJlYW1zIG9mIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzXG4gICAgICAgICAgICAvLyBjYW4gY29udGFpbiBmdW5jdGlvbnNDYWxsYmFjaywgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGludGVybmFsIHNjcm9sbGVyIGZ1bmN0aW9ucyBcbiAgICAgICAgICAgIC8vKG1vc3RseSBjYWNoZSBtYW5hZ2VtZW50KVxuICAgICAgICB0ZWNobmljYWwgPSB7fSwgLy8gb3B0aW9uYWwuIHRlY2huaWNhbCBzZXR0aW5ncyBsaWtlIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUXG5cbiAgICAgICAgLy8gaW5mb3JtYXRpb24gZm9yIGhvc3QgY2VsbCBjb250ZW50XG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcywgLy8gcmVxdWlyZWQgZm9yIGVtYmVkZGVkIHNjcm9sbGVyOyBzaGFyZXMgc2Nyb2xsZXIgc2V0dGluZ3Mgd2l0aCBjb250ZW50XG5cbiAgICB9ID0gcHJvcHNcblxuICAgIGxldCBpc01pbmltYWxQcm9wc0ZhaWwgPSBmYWxzZVxuICAgIGlmICghKGNlbGxXaWR0aCAmJiBjZWxsSGVpZ2h0ICYmIGdldEl0ZW0gKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUklHUzogY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBhbmQgZ2V0SXRlbSBhcmUgcmVxdWlyZWQnKVxuICAgICAgICBpc01pbmltYWxQcm9wc0ZhaWwgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBEYXRhIHNldHVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlcyA9IHtcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgc3RhcnRpbmdJbmRleCxcbiAgICAgICAgc3RhcnRpbmdMaXN0U2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgfVxuXG4gICAgLy8gYXZvaWQgbnVsbC91bmRlZmluZWRcbiAgICBzdHlsZXMgPSBzdHlsZXMgPz8ge31cbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgPz8ge31cbiAgICB0ZWNobmljYWwgPSB0ZWNobmljYWwgPz8ge31cbiAgICBzdGFydGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleCA/PyAwXG4gICAgc3RhcnRpbmdMaXN0U2l6ZSA9IHN0YXJ0aW5nTGlzdFNpemUgPz8gMFxuICAgIHJ1bndheVNpemUgPSBydW53YXlTaXplID8/IDNcbiAgICB1c2VQbGFjZWhvbGRlciA9IHVzZVBsYWNlaG9sZGVyID8/IHRydWVcbiAgICB1c2VTY3JvbGxUcmFja2VyID0gdXNlU2Nyb2xsVHJhY2tlciA/PyB0cnVlXG4gICAgY2VsbE1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgPz8gMFxuICAgIGNlbGxNaW5XaWR0aCA9IGNlbGxNaW5XaWR0aCA/PyAwXG4gICAgY2FjaGVNYXggPSBjYWNoZU1heCA/PyAwXG5cbiAgICBjZWxsSGVpZ2h0ID0gK2NlbGxIZWlnaHRcbiAgICBjZWxsV2lkdGggPSArY2VsbFdpZHRoXG4gICAgY2VsbE1pbkhlaWdodCA9ICtjZWxsTWluSGVpZ2h0XG4gICAgY2VsbE1pbldpZHRoID0gK2NlbGxNaW5XaWR0aFxuICAgIGdhcCA9ICtnYXBcbiAgICBwYWRkaW5nID0gK3BhZGRpbmdcbiAgICBzdGFydGluZ0luZGV4ID0gK3N0YXJ0aW5nSW5kZXhcbiAgICBzdGFydGluZ0xpc3RTaXplID0gK3N0YXJ0aW5nTGlzdFNpemVcbiAgICBydW53YXlTaXplID0gK3J1bndheVNpemVcbiAgICBjYWNoZU1heCA9ICtjYWNoZU1heFxuXG4gICAgY29uc3QgdmVyaWZpZWRWYWx1ZXMgPSB7XG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsXG4gICAgICAgIHN0YXJ0aW5nTGlzdFNpemUsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNhY2hlTWF4LCAgICAgICAgXG4gICAgfVxuXG4gICAgY2VsbE1pbkhlaWdodCA9IE1hdGgubWF4KGNlbGxNaW5IZWlnaHQsIDI1KVxuICAgIGNlbGxNaW5XaWR0aCA9IE1hdGgubWF4KGNlbGxNaW5XaWR0aCwgMjUpXG4gICAgY2VsbE1pbkhlaWdodCA9IE1hdGgubWluKGNlbGxIZWlnaHQsIGNlbGxNaW5IZWlnaHQpXG4gICAgY2VsbE1pbldpZHRoID0gTWF0aC5taW4oY2VsbFdpZHRoLCBjZWxsTWluV2lkdGgpXG5cbiAgICAvLyBwcm9wIGNvbnN0cmFpbnRzIC0gbm9uLW5lZ2F0aXZlIHZhbHVlc1xuICAgIHJ1bndheVNpemUgPSBNYXRoLm1heCgxLHJ1bndheVNpemUpIC8vIHJ1bndheXNpemUgbXVzdCBiZSBhdCBsZWFzdCAxXG4gICAgc3RhcnRpbmdMaXN0U2l6ZSA9IE1hdGgubWF4KDAsc3RhcnRpbmdMaXN0U2l6ZSlcbiAgICBzdGFydGluZ0luZGV4ID0gTWF0aC5tYXgoMCxzdGFydGluZ0luZGV4KVxuXG4gICAgLy8gcGFja2FnZVxuICAgIGxldCBwcm9ibGVtcyA9IDBcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gdmVyaWZpZWRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZlcmlmaWVkVmFsdWVzW3Byb3BdKSkge1xuICAgICAgICAgICAgcHJvYmxlbXMrK1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIGlmIChwcm9ibGVtcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogaW52YWxpZCBudW1iZXIgLSBjb21wYXJlIG9yaWdpbmFsVmFsdWVzIGFuZCB2ZXJpZmllZFZhbHVlcycsIFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZXMsIHZlcmlmaWVkVmFsdWVzKVxuICAgIH1cblxuICAgIC8vIGVudW1zXG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkgeyBcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIGlmICghWydwcmVsb2FkJywna2VlcGxvYWQnLCdjcmFkbGUnXS5pbmNsdWRlcyhjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJ1xuICAgIH1cbiAgICBpZiAoIVsndW5pZm9ybScsICd2YXJpYWJsZSddLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nXG4gICAgfVxuXG4gICAgY29uc3QgZ3JpZFNwZWNzID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICAvLyBzdGF0ZVxuICAgIGNvbnN0IFtzY3JvbGxlclN0YXRlLCBzZXRTY3JvbGxlclN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCBzZXRsaXN0c2l6ZSwgcmVhZHlcbiAgICAvLyBzeXN0ZW1cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoc3R5bGVzKVxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZihjYWxsYmFja3MpXG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZiA9IHVzZVJlZihwbGFjZWhvbGRlck1lc3NhZ2VzKVxuXG4gICAgbGV0IHtcblxuICAgICAgICBzaG93QXhpcywgLy8gYm9vbGVhbjsgYXhpcyBjYW4gYmUgbWFkZSB2aXNpYmxlIGZvciBkZWJ1Z1xuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCwgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGhlYWQgb3IgdGFpbCBmb3IgY29udGVudCBzaGlmdHMgYWJvdmUvYmVsb3cgYXhpc1xuICAgICAgICAvLyB0aW1lb3V0c1xuICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCxcbiAgICAgICAgT05BRlRFUlNDUk9MTF9USU1FT1VULFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQsXG4gICAgICAgIC8vIHJhdGlvczpcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLCAvLyBtYXggc3RyZWFtaW5nIG92ZXItcnVuIGFzIHJhdGlvIHRvIGNhY2hlTWF4XG4gICAgICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFLCBcblxuICAgIH0gPSB0ZWNobmljYWxcblxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0gVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPz8gMjUwXG4gICAgT05BRlRFUlNDUk9MTF9USU1FT1VUID0gT05BRlRFUlNDUk9MTF9USU1FT1VUID8/IDEwMFxuICAgIElETEVDQUxMQkFDS19USU1FT1VUID0gSURMRUNBTExCQUNLX1RJTUVPVVQgPz8gMjUwXG4gICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgPSBWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCA/PyAyNTBcbiAgICBcbiAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4gPSBNQVhfQ0FDSEVfT1ZFUl9SVU4gPz8gMS41XG4gICAgQ0FDSEVfUEFSVElUSU9OX1NJWkUgPSBDQUNIRV9QQVJUSVRJT05fU0laRSA/PyAzMFxuXG4gICAgaWYgKHR5cGVvZiBzaG93QXhpcyAhPSAnYm9vbGVhbicpIHNob3dBeGlzID0gZmFsc2VcblxuICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgPz8gMTBcblxuICAgIGlmICh0eXBlb2YgdXNlUGxhY2Vob2xkZXIgIT0gJ2Jvb2xlYW4nKSB1c2VQbGFjZWhvbGRlciA9IHRydWVcbiAgICBpZiAodHlwZW9mIHVzZVNjcm9sbFRyYWNrZXIgIT0gJ2Jvb2xlYW4nKSB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuXG4gICAgLy8gZm9yIG1vdW50IHZlcnNpb25cbiAgICBjb25zdCBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbGVySUQgPSBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50XG5cbiAgICAvLyBmb3IgY2hpbGRyZW5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGxpc3RzaXplUmVmID0gdXNlUmVmKHN0YXJ0aW5nTGlzdFNpemUpXG5cbiAgICBjb25zdCBsaXN0c2l6ZSA9IGxpc3RzaXplUmVmLmN1cnJlbnRcblxuICAgIC8vIHRlc3RzIGZvciBSZWFjdCB3aXRoIE9iamVjdC5pcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzOyBhdm9pZCByZS1yZW5kZXJzIHdpdGggbm8gY2hhbmdlXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoZ3JpZFNwZWNzLCBncmlkU3BlY3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgPSBncmlkU3BlY3NcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhzdHlsZXMsIHN0eWxlc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBzdHlsZXNSZWYuY3VycmVudCA9IHN0eWxlc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhjYWxsYmFja3MsIGNhbGxiYWNrc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudCA9IGNhbGxiYWNrc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhwbGFjZWhvbGRlck1lc3NhZ2VzLCBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbml0aWFsaXphdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgZ2V0Q2FjaGVBUEkgPSAoY2FjaGVIYW5kbGVyKSA9PiB7XG4gICAgICAgIGNhY2hlSGFuZGxlclJlZi5jdXJyZW50ID0gY2FjaGVIYW5kbGVyXG4gICAgfVxuXG4gICAgdXNlRWZmZWN0ICgoKSA9PiB7XG5cbiAgICAgICAgaWYgKHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQgPT09IG51bGwpIHsgLy8gZGVmZW5kIGFnYWluc3QgUmVhY3QuU3RyaWN0TW9kZSBkb3VibGUgcnVuXG4gICAgICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50ID0gZ2xvYmFsU2Nyb2xsZXJJRCsrXG4gICAgICAgICAgICAvLyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCA9IG5ldyBDYWNoZUhhbmRsZXIoc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudCwgc2V0TGlzdHNpemUsIGxpc3RzaXplUmVmLCBcbiAgICAgICAgICAgIC8vICAgICBDQUNIRV9QQVJUSVRJT05fU0laRSlcbiAgICAgICAgfVxuXG4gICAgfSxbXSk7XG5cbiAgICAvLyBjYWxsZWQgd2hlbiBnZXRJdGVtIHJldHVybnMgbnVsbCwgb3IgZGlyZWN0IGNhbGwgZnJvbSB1c2VyIChzZWUgc2VydmljZUhhbmRsZXIpXG4gICAgY29uc3QgdXBkYXRlTGlzdHNpemUgPSB1c2VDYWxsYmFjaygobGlzdHNpemUpID0+e1xuXG4gICAgICAgIGlmIChsaXN0c2l6ZSA9PSBsaXN0c2l6ZVJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBsaXN0c2l6ZVJlZi5jdXJyZW50ID0gbGlzdHNpemVcblxuICAgICAgICAvLyBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUgJiYgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUobGlzdHNpemUpXG5cbiAgICAgICAgc2V0U2Nyb2xsZXJTdGF0ZSgnc2V0bGlzdHNpemUnKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3RhdGUgaGFuZGxpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHNjcm9sbGVyU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldGxpc3RzaXplJzpcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdyZWFkeScpXG4gICAgICAgIH1cblxuICAgIH0sW3Njcm9sbGVyU3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBpZiAocHJvYmxlbXMgfHwgaXNNaW5pbWFsUHJvcHNGYWlsKSB7XG4gICAgICAgIHJldHVybiA8ZGl2PmVycm9yOiBzZWUgY29uc29sZS48L2Rpdj4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudCBjYWxscyBhcmUgZGVmZXJyZWQgYnkgc2Nyb2xsZXJTdGF0ZSB0byBnaXZlIGNhY2hlSGFuZGxlciBhIGNoYW5jZSB0byBpbml0aWFsaXplXG4gICAgcmV0dXJuIDxFcnJvckJvdW5kYXJ5XG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50PSB7IEVycm9yRmFsbGJhY2sgfVxuICAgICAgICBvblJlc2V0PSB7ICgpID0+IHtcbiAgICAgICAgICAvLyByZXNwb25zZSB0YmQ7IHRoZXJlIG1heSBub3QgbmVlZCB0byBiZSBvbmVcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvciA9IHsoZXJyb3I6IEVycm9yLCBpbmZvOiB7Y29tcG9uZW50U3RhY2s6IHN0cmluZ30pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyIGNhcHR1cmVkIGVycm9yJywgZXJyb3IpXG4gICAgICAgIH19XG4gICAgPlxuXG4gICAgICAgIHsoc2Nyb2xsZXJTdGF0ZSAhPSAnc2V0dXAnKSAmJiA8Vmlld3BvcnRcblxuICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIC8vIHNjcm9sbGVyUHJvcGVydGllcyA9IHsgc2Nyb2xsZXJQcm9wZXJ0aWVzIH1cbiAgICAgICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICAgICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPSB7IFZJRVdQT1JUX1JFU0laRV9USU1FT1VUIH1cblxuICAgICAgICA+XG4gICAgICAgIFxuICAgICAgICAgICAgezxTY3JvbGxibG9ja1xuXG4gICAgICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8Q3JhZGxlIFxuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTGlzdHNpemUgPSB7IHVwZGF0ZUxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB7IGNhY2hlIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVNYXggPSB7IGNhY2hlTWF4IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNhbGxiYWNrcyA9IHsgY2FsbGJhY2tzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4ID0geyBzdGFydGluZ0luZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bndheVNpemUgPSB7IHJ1bndheVNpemUgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCA9IHsgdHJpZ2dlcmxpbmVPZmZzZXQgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMgPSB7IHNjcm9sbGVyUHJvcGVydGllcyB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyID0geyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVBsYWNlaG9sZGVyID0geyB1c2VQbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB7IHVzZVNjcm9sbFRyYWNrZXIgfVxuICAgICAgICAgICAgICAgICAgICBzaG93QXhpcyA9IHsgc2hvd0F4aXMgfVxuICAgICAgICAgICAgICAgICAgICBPTkFGVEVSU0NST0xMX1RJTUVPVVQgPSB7IE9OQUZURVJTQ1JPTExfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIElETEVDQUxMQkFDS19USU1FT1VUID0geyBJRExFQ0FMTEJBQ0tfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTiA9IHsgTUFYX0NBQ0hFX09WRVJfUlVOIH1cbiAgICAgICAgICAgICAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgPSB7IFZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VUIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG5cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9TY3JvbGxibG9jaz59XG4gICAgICAgIDwvVmlld3BvcnQ+fVxuICAgICAgICB7KHNjcm9sbGVyU3RhdGUgIT0gJ3NldHVwJykgJiYgPGRpdiBkYXRhLXR5cGUgPSAnY2FjaGVyb290JyBzdHlsZSA9IHsgY2FjaGVyb290c3R5bGUgfT5cbiAgICAgICAgICAgIDxQb3J0YWxDYWNoZSBcbiAgICAgICAgICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHsgc2Nyb2xsZXJTZXNzaW9uSURSZWYgfVxuICAgICAgICAgICAgICAgIHNldExpc3RzaXplID0geyB1cGRhdGVMaXN0c2l6ZSB9IFxuICAgICAgICAgICAgICAgIGxpc3RzaXplUmVmID0geyBsaXN0c2l6ZVJlZiB9IFxuICAgICAgICAgICAgICAgIGdldENhY2hlQVBJID0geyBnZXRDYWNoZUFQSSB9IFxuICAgICAgICAgICAgICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFID0geyBDQUNIRV9QQVJUSVRJT05fU0laRSB9IC8+XG4gICAgICAgIDwvZGl2Pn0gXG4gICAgPC9FcnJvckJvdW5kYXJ5PlxufVxuXG5leHBvcnQgZGVmYXVsdCBJbmZpbml0ZUdyaWRTY3JvbGxlclxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTdXBwb3J0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY2FjaGVyb290c3R5bGUgPSB7ZGlzcGxheTonbm9uZSd9Ly8gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyAvLyBzdGF0aWMsIG91dCBvZiB2aWV3IFxuXG4vLyB1dGlsaXR5XG5mdW5jdGlvbiBjb21wYXJlUHJvcHMgKG9iajEsb2JqMikge1xuICAgIGlmICghb2JqMSB8fCAhb2JqMikgcmV0dXJuIGZhbHNlXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iajEpXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIU9iamVjdC5pcyhvYmoxW2tleV0sb2JqMltrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwicmVhY3RfZXJyb3JfYm91bmRhcnlfMSIsImlzU2FmYXJpSU9TIiwiaXNfaW9zIiwid2luZG93IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNfc2FmYXJpIiwibWF0Y2giLCJleHBvcnRzIiwiRXJyb3JGYWxsYmFjayIsIl9yZWYiLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsImNyZWF0ZUVsZW1lbnQiLCJyb2xlIiwib25DbGljayIsIlZpZXdwb3J0XzEiLCJfX2ltcG9ydERlZmF1bHQiLCJTY3JvbGxibG9ja18xIiwiQ3JhZGxlXzEiLCJQb3J0YWxDYWNoZV8xIiwiZ2xvYmFsU2Nyb2xsZXJJRCIsIkluZmluaXRlR3JpZFNjcm9sbGVyIiwicHJvcHMiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiX3Byb3BzJHN0YXJ0aW5nTGlzdFNpIiwic3RhcnRpbmdMaXN0U2l6ZSIsImdldEl0ZW0iLCJfcHJvcHMkb3JpZW50YXRpb24iLCJvcmllbnRhdGlvbiIsIl9wcm9wcyRnYXAiLCJnYXAiLCJfcHJvcHMkcGFkZGluZyIsInBhZGRpbmciLCJfcHJvcHMkbGF5b3V0IiwibGF5b3V0IiwiX3Byb3BzJGNlbGxNaW5IZWlnaHQiLCJjZWxsTWluSGVpZ2h0IiwiX3Byb3BzJGNlbGxNaW5XaWR0aCIsImNlbGxNaW5XaWR0aCIsIl9wcm9wcyRydW53YXlTaXplIiwicnVud2F5U2l6ZSIsIl9wcm9wcyRzdGFydGluZ0luZGV4Iiwic3RhcnRpbmdJbmRleCIsIl9wcm9wcyRjYWNoZSIsImNhY2hlIiwiX3Byb3BzJGNhY2hlTWF4IiwiY2FjaGVNYXgiLCJwbGFjZWhvbGRlciIsIl9wcm9wcyR1c2VQbGFjZWhvbGRlciIsInVzZVBsYWNlaG9sZGVyIiwiX3Byb3BzJHVzZVNjcm9sbFRyYWNrIiwidXNlU2Nyb2xsVHJhY2tlciIsIl9wcm9wcyRzdHlsZXMiLCJzdHlsZXMiLCJfcHJvcHMkcGxhY2Vob2xkZXJNZXMiLCJwbGFjZWhvbGRlck1lc3NhZ2VzIiwiX3Byb3BzJGNhbGxiYWNrcyIsImNhbGxiYWNrcyIsIl9wcm9wcyR0ZWNobmljYWwiLCJ0ZWNobmljYWwiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJpc01pbmltYWxQcm9wc0ZhaWwiLCJjb25zb2xlIiwibG9nIiwib3JpZ2luYWxWYWx1ZXMiLCJ2ZXJpZmllZFZhbHVlcyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJwcm9ibGVtcyIsInByb3AiLCJpc05hTiIsImluY2x1ZGVzIiwiZ3JpZFNwZWNzIiwiZ3JpZFNwZWNzUmVmIiwidXNlUmVmIiwiX3JlZjIiLCJ1c2VTdGF0ZSIsIl9yZWYzIiwic2Nyb2xsZXJTdGF0ZSIsInNldFNjcm9sbGVyU3RhdGUiLCJzdHlsZXNSZWYiLCJjYWxsYmFja3NSZWYiLCJwbGFjZWhvbGRlck1lc3NhZ2VzUmVmIiwiX3RlY2huaWNhbCIsInNob3dBeGlzIiwidHJpZ2dlcmxpbmVPZmZzZXQiLCJWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCIsIk9OQUZURVJTQ1JPTExfVElNRU9VVCIsIklETEVDQUxMQkFDS19USU1FT1VUIiwiVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJDQUNIRV9QQVJUSVRJT05fU0laRSIsInNjcm9sbGVyU2Vzc2lvbklEUmVmIiwic2Nyb2xsZXJJRCIsImN1cnJlbnQiLCJjYWNoZUhhbmRsZXJSZWYiLCJsaXN0c2l6ZVJlZiIsImxpc3RzaXplIiwiY29tcGFyZVByb3BzIiwiZ2V0Q2FjaGVBUEkiLCJjYWNoZUhhbmRsZXIiLCJ1c2VFZmZlY3QiLCJ1cGRhdGVMaXN0c2l6ZSIsInVzZUNhbGxiYWNrIiwibmV3TGlzdHNpemUiLCJFcnJvckJvdW5kYXJ5IiwiRmFsbGJhY2tDb21wb25lbnQiLCJvblJlc2V0Iiwib25FcnJvciIsImluZm8iLCJ1c2VyQ2FsbGJhY2tzIiwic3R5bGUiLCJjYWNoZXJvb3RzdHlsZSIsInNldExpc3RzaXplIiwiZGlzcGxheSIsIm9iajEiLCJvYmoyIiwia2V5cyIsIl9pMiIsIl9rZXlzIiwia2V5IiwiaXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/InfiniteGridScroller.tsx\n')},"./src/PortalCache.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar cachehandler_1 = __importDefault(__webpack_require__(/*! ./portalcache/cachehandler */ "./src/portalcache/cachehandler.tsx"));\nvar PortalCache = function PortalCache(_ref) {\n  var scrollerSessionIDRef = _ref.scrollerSessionIDRef,\n    setListsize = _ref.setListsize,\n    listsizeRef = _ref.listsizeRef,\n    getCacheAPI = _ref.getCacheAPI,\n    CACHE_PARTITION_SIZE = _ref.CACHE_PARTITION_SIZE;\n  (0, react_1.useEffect)(function () {\n    var cacheHandler = new cachehandler_1["default"](scrollerSessionIDRef.current, listsizeRef, CACHE_PARTITION_SIZE);\n    cacheHandlerRef.current = cacheHandler;\n    getCacheAPI(cacheHandler);\n  }, []);\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalCacheCounter = _ref3[0],\n    setPortalCacheCounter = _ref3[1];\n  var counterRef = (0, react_1.useRef)(portalCacheCounter);\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n    _ref5 = _slicedToArray(_ref4, 2),\n    masterState = _ref5[0],\n    setMasterState = _ref5[1];\n  var isMountedRef = (0, react_1.useRef)(true);\n  var partitionArrayRef = (0, react_1.useRef)(null);\n  var partitionRepoForceUpdate = (0, react_1.useCallback)(function (partitionRenderList) {\n    partitionArrayRef.current = partitionRenderList;\n    isMountedRef.current && setPortalCacheCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    cacheHandlerRef.current.cacheProps.partitionRepoForceUpdate = partitionRepoForceUpdate;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (masterState) {\n      case \'setup\':\n        {\n          setMasterState(\'ready\');\n        }\n    }\n  }, [masterState]);\n  return react_1["default"].createElement("div", {\n    "data-type": \'portal-master\'\n  }, partitionArrayRef.current);\n};\nexports["default"] = PortalCache;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUcsSUFBQTdCLE9BQUEsQ0FBQThCLFdBQVcsRUFBQyxVQUFDQyxtQkFBdUIsRUFBSTtJQUVyRUgsaUJBQWlCLENBQUNkLE9BQU8sR0FBR2lCLG1CQUFtQjtJQUUvQ0osWUFBWSxDQUFDYixPQUFPLElBQUlPLHFCQUFxQixDQUFDLEVBQUVDLFVBQVUsQ0FBQ1IsT0FBTyxDQUFDLEVBQUM7RUFFeEUsQ0FBQyxFQUFDLEVBQUUsQ0FBQztFQUVMLElBQUFkLE9BQUEsQ0FBQVksU0FBUyxFQUFDLFlBQUk7SUFFVmUsWUFBWSxDQUFDYixPQUFPLEdBQUcsSUFBSTtJQUUzQkMsZUFBZSxDQUFDRCxPQUFPLENBQUNrQixVQUFVLENBQUNILHdCQUF3QixHQUFHQSx3QkFBd0I7SUFFdEYsT0FBTyxZQUFLO01BRVJGLFlBQVksQ0FBQ2IsT0FBTyxHQUFHLEtBQUs7SUFFaEMsQ0FBQztFQUVMLENBQUMsRUFBQyxFQUFFLENBQUM7RUFFTCxJQUFBZCxPQUFBLENBQUFZLFNBQVMsRUFBQyxZQUFJO0lBRVYsUUFBUWEsV0FBVztNQUNmLEtBQUssT0FBTztRQUFFO1VBQ1ZDLGNBQWMsQ0FBQyxPQUFPLENBQUM7O0lBQzFCO0VBR1QsQ0FBQyxFQUFDLENBQUNELFdBQVcsQ0FBQyxDQUFDO0VBRWhCLE9BQU96QixPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUI7RUFBZSxHQUFFTCxpQkFBaUIsQ0FBQ2QsT0FBTyxDQUFPO0FBRTdFLENBQUM7QUFFRG9CLGtCQUFBLEdBQWU3QixXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9Qb3J0YWxDYWNoZS50c3g/YjIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDZWxsRnJhbWUudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QsIHtGQywgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFja30gZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDYWNoZUhhbmRsZXIgZnJvbSAnLi9wb3J0YWxjYWNoZS9jYWNoZWhhbmRsZXInXG5cbmNvbnN0IFBvcnRhbENhY2hlOkZDPGFueT4gPSAoe3Njcm9sbGVyU2Vzc2lvbklEUmVmLCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYsIGdldENhY2hlQVBJLCBDQUNIRV9QQVJUSVRJT05fU0laRSB9KSA9PiB7XG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY2FjaGVIYW5kbGVyID0gbmV3IENhY2hlSGFuZGxlcihzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50LCBsaXN0c2l6ZVJlZiwgXG4gICAgICAgICAgICBDQUNIRV9QQVJUSVRJT05fU0laRSlcblxuICAgICAgICBjYWNoZUhhbmRsZXJSZWYuY3VycmVudCA9IGNhY2hlSGFuZGxlclxuXG4gICAgICAgIGdldENhY2hlQVBJKGNhY2hlSGFuZGxlcilcblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IFtwb3J0YWxDYWNoZUNvdW50ZXIsIHNldFBvcnRhbENhY2hlQ291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuICAgIGNvbnN0IGNvdW50ZXJSZWYgPSB1c2VSZWYocG9ydGFsQ2FjaGVDb3VudGVyKVxuXG4gICAgY29uc3QgW21hc3RlclN0YXRlLCBzZXRNYXN0ZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCBwYXJ0aXRpb25BcnJheVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgcGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlID0gdXNlQ2FsbGJhY2soKHBhcnRpdGlvblJlbmRlckxpc3Q6YW55KSA9PiB7XG5cbiAgICAgICAgcGFydGl0aW9uQXJyYXlSZWYuY3VycmVudCA9IHBhcnRpdGlvblJlbmRlckxpc3RcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRQb3J0YWxDYWNoZUNvdW50ZXIoKytjb3VudGVyUmVmLmN1cnJlbnQpIC8vIGZvcmNlIHJlbmRlclxuXG4gICAgfSxbXSlcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIGNhY2hlSGFuZGxlclJlZi5jdXJyZW50LmNhY2hlUHJvcHMucGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlID0gcGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pIFxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChtYXN0ZXJTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiB7XG4gICAgICAgICAgICAgICAgc2V0TWFzdGVyU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxbbWFzdGVyU3RhdGVdKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3BvcnRhbC1tYXN0ZXInPntwYXJ0aXRpb25BcnJheVJlZi5jdXJyZW50fTwvZGl2PlxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvcnRhbENhY2hlXG4iXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsImNhY2hlaGFuZGxlcl8xIiwiX19pbXBvcnREZWZhdWx0IiwiUG9ydGFsQ2FjaGUiLCJfcmVmIiwic2Nyb2xsZXJTZXNzaW9uSURSZWYiLCJzZXRMaXN0c2l6ZSIsImxpc3RzaXplUmVmIiwiZ2V0Q2FjaGVBUEkiLCJDQUNIRV9QQVJUSVRJT05fU0laRSIsInVzZUVmZmVjdCIsImNhY2hlSGFuZGxlciIsImN1cnJlbnQiLCJjYWNoZUhhbmRsZXJSZWYiLCJ1c2VSZWYiLCJfcmVmMiIsInVzZVN0YXRlIiwiX3JlZjMiLCJwb3J0YWxDYWNoZUNvdW50ZXIiLCJzZXRQb3J0YWxDYWNoZUNvdW50ZXIiLCJjb3VudGVyUmVmIiwiX3JlZjQiLCJfcmVmNSIsIm1hc3RlclN0YXRlIiwic2V0TWFzdGVyU3RhdGUiLCJpc01vdW50ZWRSZWYiLCJwYXJ0aXRpb25BcnJheVJlZiIsInBhcnRpdGlvblJlcG9Gb3JjZVVwZGF0ZSIsInVzZUNhbGxiYWNrIiwicGFydGl0aW9uUmVuZGVyTGlzdCIsImNhY2hlUHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/PortalCache.tsx\n')},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Scrollblock.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element (scrolled by Viewport) of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n    listsize = _ref.listsize,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth;\n  // -------------------------[ context and state ]-------------------------\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  // -----------------------------------[ data heap ]-------------------------\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null);\n  // just for init\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n    _ref3 = _slicedToArray(_ref2, 2),\n    divlinerstyle = _ref3[0],\n    saveDivlinerstyle = _ref3[1]; // to trigger render\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n    width = _ViewportContextPrope.width,\n    height = _ViewportContextPrope.height;\n  // reconfigure\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef, cellWidth, cellHeight, padding);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\nexports["default"] = Scrollblock;\n// any of the parameters can affect the length\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n    viewportheight = _ref4.viewportheight,\n    viewportwidth = _ref4.viewportwidth,\n    listsize = _ref4.listsize,\n    cellHeight = _ref4.cellHeight,\n    cellWidth = _ref4.cellWidth,\n    gap = _ref4.gap,\n    padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  }\n  // adjustments to viewportcrosslength\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  // -------------------[ calculate scrollblock length ]-----------------\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap :\n  // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n  return baselength;\n};\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef, cellWidth, cellHeight, padding) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n  var height, width, minHeight, minWidth;\n  if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n    minWidth = cellWidth + padding * 2 + \'px\';\n    minHeight = null;\n  } else {\n    // orientation == \'horizontal\'\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n    minHeight = cellHeight + padding * 2 + \'px\';\n    minWidth = null;\n  }\n  localstyles.height = height;\n  localstyles.width = width;\n  localstyles.minHeight = minHeight;\n  localstyles.minWidth = minWidth;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVEsR0FBR0EsUUFBUTtFQUUvQixPQUFPRixXQUFXO0FBRXRCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1Njcm9sbGJsb2NrLnRzeD8zYjY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNjcm9sbGJsb2NrLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcblxuICAgIFRoZSBzY3JvbGxibG9jayBwcm92aWRlcyB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IChzY3JvbGxlZCBieSBWaWV3cG9ydCkgb2YgdGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIuXG4gICAgSXQgaXMgc2l6ZWQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBjZWxsIHNpemUgYW5kIHJvdyBjb3VudHMsIGFkanVzdGVkIGZvciB2YXJpYWJsZSBjcmFkbGUgY29udGVudC5cbiAgICBJdHMgb25seSBzdGF0ZSBjaGFuZ2UgaXMgY2hhbmdlIG9mIHN0eWxlcy5cblxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlQ29udGV4dCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtb30gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vVmlld3BvcnQnXG5cbmNvbnN0IFNjcm9sbGJsb2NrID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICBsaXN0c2l6ZSxcbiAgICBncmlkU3BlY3MsIFxuICAgIHN0eWxlcyxcbiAgICBzY3JvbGxlcklELFxufSkgPT4ge1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY29udGV4dCBhbmQgc3RhdGUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBkYXRhIGhlYXAgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8ganVzdCBmb3IgaW5pdFxuICAgIGNvbnN0IGxpbmVyU3R5bGUgPSB1c2VNZW1vKCgpID0+e1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdHlsZXMuc2Nyb2xsYmxvY2ssXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICB9XG5cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYobGluZXJTdHlsZSlcblxuICAgIGNvbnN0IFtkaXZsaW5lcnN0eWxlLHNhdmVEaXZsaW5lcnN0eWxlXSA9IHVzZVN0YXRlKGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCkgLy8gdG8gdHJpZ2dlciByZW5kZXJcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy52aWV3cG9ydERpbWVuc2lvbnNcbiAgICBcbiAgICAvLyByZWNvbmZpZ3VyZVxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgdXBkYXRlQmFzZUJsb2NrTGVuZ3RoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0OmhlaWdodCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoOndpZHRoLFxuICAgICAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IFxuICAgICAgICAgICAgdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMoXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgZGl2bGluZXJzdHlsZVJlZixcbiAgICAgICAgICAgICAgICBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYsXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1xuICAgICAgICAgICAgKVxuICAgICAgICBzYXZlRGl2bGluZXJzdHlsZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgY29uc3QgdXBkYXRlQmFzZUJsb2NrTGVuZ3RoID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChsYXlvdXRzcGVjcykgPT4ge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBiYXNlc2Nyb2xsYmxvY2tsZW5ndGggPSBjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoKGxheW91dHNwZWNzKVxuXG4gICAgICAgICAgICBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYuY3VycmVudCA9IGJhc2VzY3JvbGxibG9ja2xlbmd0aFxuXG4gICAgICAgIH0sW11cbiAgICApXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAnc2Nyb2xsYmxvY2snIHN0eWxlPXtkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnR9PntjaGlsZHJlbn08L2Rpdj5cblxufSAvLyBTY3JvbGxibG9ja1xuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxibG9ja1xuXG4vLyBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgY2FuIGFmZmVjdCB0aGUgbGVuZ3RoXG5jb25zdCBjYWxjQmFzZVNjcm9sbGJsb2NrTGVuZ3RoID0gKHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgY3Jvc3Njb3VudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9jcm9zc2NvdW50IGlzIGFsc28gY2FsY3VsYXRlZCBieSBDcmFkbGVcblxuICAgIGxldCBjcm9zc2xlbmd0aFxuICAgIGxldCBjZWxsTGVuZ3RoXG4gICAgbGV0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydHdpZHRoIFxuXG4gICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgY3Jvc3NsZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgdmlld3BvcnRjcm9zc2xlbmd0aCA9IHZpZXdwb3J0aGVpZ2h0XG5cbiAgICB9XG5cbiAgICAvLyBhZGp1c3RtZW50cyB0byB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCAtPSAocGFkZGluZyAqIDIpXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCArPSBnYXAgLy8gdG8gbWF0Y2ggY3Jvc3NMZW5ndGhcblxuICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoIDwgY3Jvc3NsZW5ndGgpIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBjcm9zc2xlbmd0aCAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZVxuXG4gICAgY29uc3QgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRjcm9zc2xlbmd0aC9jcm9zc2xlbmd0aClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBzY3JvbGxibG9jayBsZW5ndGggXS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBsaXN0cm93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IGJhc2VsZW5ndGggPSAobGlzdHJvd2NvdW50ICogY2VsbExlbmd0aCkgLSBcbiAgICAgICAgKChsaXN0cm93Y291bnQgPiAwKT9cbiAgICAgICAgICAgIGdhcDogLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICAwKSBcbiAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgIHJldHVybiBiYXNlbGVuZ3RoXG5cbn1cblxuY29uc3QgdXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMgPSAoXG4gICAgb3JpZW50YXRpb24sIHN0eWxlc1JlZiwgYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHBhZGRpbmcpID0+IHtcblxuICAgIGNvbnN0IGxvY2Fsc3R5bGVzID0gey4uLnN0eWxlc1JlZi5jdXJyZW50fSAvLyBuZXcgb2JqZWN0XG4gICAgbGV0IGhlaWdodCwgd2lkdGgsIG1pbkhlaWdodCwgbWluV2lkdGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBoZWlnaHQgPSBiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgbWluV2lkdGggPSAoY2VsbFdpZHRoICsgKHBhZGRpbmcgKiAyKSkgKyAncHgnXG4gICAgICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgIHdpZHRoID0gYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgICAgIG1pbkhlaWdodCA9IChjZWxsSGVpZ2h0ICsgKHBhZGRpbmcgKiAyKSkgKyAncHgnXG4gICAgICAgIG1pbldpZHRoID0gbnVsbFxuICAgIH1cbiAgICBsb2NhbHN0eWxlcy5oZWlnaHQgPSBoZWlnaHRcbiAgICBsb2NhbHN0eWxlcy53aWR0aCA9IHdpZHRoXG4gICAgbG9jYWxzdHlsZXMubWluSGVpZ2h0ID0gbWluSGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMubWluV2lkdGggPSBtaW5XaWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG5cbn1cbiJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiVmlld3BvcnRfMSIsIlNjcm9sbGJsb2NrIiwiX3JlZiIsImNoaWxkcmVuIiwibGlzdHNpemUiLCJncmlkU3BlY3MiLCJzdHlsZXMiLCJzY3JvbGxlcklEIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJ1c2VDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0IiwiYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmIiwidXNlUmVmIiwibGluZXJTdHlsZSIsInVzZU1lbW8iLCJhc3NpZ24iLCJzY3JvbGxibG9jayIsInBvc2l0aW9uIiwiZGl2bGluZXJzdHlsZVJlZiIsIl9yZWYyIiwidXNlU3RhdGUiLCJjdXJyZW50IiwiX3JlZjMiLCJkaXZsaW5lcnN0eWxlIiwic2F2ZURpdmxpbmVyc3R5bGUiLCJfVmlld3BvcnRDb250ZXh0UHJvcGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInVzZUxheW91dEVmZmVjdCIsInVwZGF0ZUJhc2VCbG9ja0xlbmd0aCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzIiwidXNlQ2FsbGJhY2siLCJsYXlvdXRzcGVjcyIsImJhc2VzY3JvbGxibG9ja2xlbmd0aCIsImNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJleHBvcnRzIiwiX3JlZjQiLCJjcm9zc2xlbmd0aCIsImNlbGxMZW5ndGgiLCJ2aWV3cG9ydGNyb3NzbGVuZ3RoIiwiY3Jvc3Njb3VudCIsIk1hdGgiLCJmbG9vciIsImxpc3Ryb3djb3VudCIsImNlaWwiLCJiYXNlbGVuZ3RoIiwic3R5bGVzUmVmIiwiYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmIiwibG9jYWxzdHlsZXMiLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Viewport.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide viewport data to its children (scrollblock and cradle) through the\n    ViewportContext object, and act as the visible screen portal of the list being shown.\n    If Viewport is resized, it notifies the Cradle to reconfigure.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nexports.ViewportContext = react_1["default"].createContext(null); // for children\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation;\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    viewportState = _ref3[0],\n    setViewportState = _ref3[1]; // setup, resizing, resized, ready\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var viewportElementRef = (0, react_1.useRef)(null);\n  // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  });\n  // mark as unmounted\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // --------------------[ viewport resizer interrupt ]-----------------------\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null);\n  // set up resizeObserver\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current);\n    // unmount\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  // used by resizeObserver; generates interrupt\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target;\n    // no need to trigger interrupt on first resize notification\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    }\n    // generate interrupt response, if initiating resize\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true;\n      // new object creation triggers a realtime interrupt message to cradle through context\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    }\n    // finalize resizing after timeout\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []);\n  // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n  var divlinerstyleRef = (0, react_1.useRef)(null);\n  // initialize with inherited styles\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'scroll\',\n      WebkitOverflowScrolling: \'touch\',\n      overflowAnchor: \'none\'\n    });\n  }, [styles.viewport]);\n  // update ViewportContextPropertiesRef; add viewport dimensions\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n      top = _viewportElementRef$c.top,\n      right = _viewportElementRef$c.right,\n      bottom = _viewportElementRef$c.bottom,\n      left = _viewportElementRef$c.left;\n    var width = right - left;\n    var height = bottom - top;\n    // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    };\n    // trigger context change with new object\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]);\n  // --------------------[ state processing ]---------------------------\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]);\n  // ----------------------[ render ]--------------------------------\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUsyQiw0QkFBNEIsQ0FBQ0g7RUFBTyxHQUMzRXJCLE9BQUEsWUFBQStELGFBQUE7SUFBQSxhQUNnQixVQUFVO0lBQUEsbUJBQ0ZwRCxVQUFVO0lBQzlCc0QsS0FBSyxFQUFLckIsZ0JBQWdCLENBQUN2QixPQUFPO0lBQ2xDNkMsR0FBRyxFQUFLM0M7RUFBa0IsR0FFdkJOLGFBQWEsSUFBSSxPQUFPLElBQUtULFFBQVEsQ0FDdEMsQ0FDaUI7QUFFL0IsQ0FBQyxFQUFDO0FBRUZMLGtCQUFBLEdBQWVHLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL1ZpZXdwb3J0LnRzeD9jODI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXdwb3J0LnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB2aWV3cG9ydCBpcyB0byBwcm92aWRlIHZpZXdwb3J0IGRhdGEgdG8gaXRzIGNoaWxkcmVuIChzY3JvbGxibG9jayBhbmQgY3JhZGxlKSB0aHJvdWdoIHRoZVxuICAgIFZpZXdwb3J0Q29udGV4dCBvYmplY3QsIGFuZCBhY3QgYXMgdGhlIHZpc2libGUgc2NyZWVuIHBvcnRhbCBvZiB0aGUgbGlzdCBiZWluZyBzaG93bi5cbiAgICBJZiBWaWV3cG9ydCBpcyByZXNpemVkLCBpdCBub3RpZmllcyB0aGUgQ3JhZGxlIHRvIHJlY29uZmlndXJlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7XG5cbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlUmVmLCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlTWVtbywgXG4gICAgdXNlQ2FsbGJhY2ssIFxuXG59IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKSAvLyBmb3IgY2hpbGRyZW5cblxuY29uc3QgVmlld3BvcnQgPSAoe1xuXG4gICAgY2hpbGRyZW4sIFxuICAgIGdyaWRTcGVjcyxcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbiAgICAvLyBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG4gICAgXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIC8vIGdhcCxcbiAgICAgICAgLy8gcGFkZGluZyxcbiAgICAgICAgLy8gY2VsbEhlaWdodCxcbiAgICAgICAgLy8gY2VsbFdpZHRoLFxuICAgICAgICAvLyBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICBjb25zdCBbdmlld3BvcnRTdGF0ZSxzZXRWaWV3cG9ydFN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCByZXNpemluZywgcmVzaXplZCwgcmVhZHlcblxuICAgIGNvbnN0IHZpZXdwb3J0U3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gZm9yIHVzZUNhbGxiYWNrIC0+IHJlc2l6ZUNhbGxiYWNrIHNjb3BlXG4gICAgdmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID0gdmlld3BvcnRTdGF0ZVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgaXMgcGFzc2VkIGFzIGEgcmVzaXppbmcgaW50ZXJydXB0ICh0aHJvdWdoIGNvbnRleHQpIHRvIGNoaWxkcmVuXG4gICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgaXNSZXNpemluZzpmYWxzZSwgXG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6bnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6bnVsbFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gbWFyayBhcyB1bm1vdW50ZWRcbiAgICB1c2VFZmZlY3QoKCkgPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHZpZXdwb3J0IHJlc2l6ZXIgaW50ZXJydXB0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVzaXplVGltZXJpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGlzUmVzaXppbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7ICAgIFxuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVudHJpZXNbMF0udGFyZ2V0XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byB0cmlnZ2VyIGludGVycnVwdCBvbiBmaXJzdCByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQgPSAndHJ1ZSdcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJydXB0IHJlc3BvbnNlLCBpZiBpbml0aWF0aW5nIHJlc2l6ZVxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG5cbiAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgY3JlYXRpb24gdHJpZ2dlcnMgYSByZWFsdGltZSBpbnRlcnJ1cHQgbWVzc2FnZSB0byBjcmFkbGUgdGhyb3VnaCBjb250ZXh0XG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxpemUgcmVzaXppbmcgYWZ0ZXIgdGltZW91dFxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNvbmZpZyB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzdHlsZXNcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplIHdpdGggaW5oZXJpdGVkIHN0eWxlc1xuICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIC4uLnN0eWxlcy52aWV3cG9ydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICBpbnNldDowLFxuICAgICAgICAgICAgb3ZlcmZsb3c6J3Njcm9sbCcsLy8nYXV0bycsICdzY3JvbGwnIGZvciBpT1MgU2FmYXJpXG4gICAgICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJywvLyBmb3IgaU9TIFNhZmFyaVxuICAgICAgICAgICAgb3ZlcmZsb3dBbmNob3I6J25vbmUnLCAvLyBjcnVjaWFsIVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH0sW3N0eWxlcy52aWV3cG9ydF0pXG5cbiAgICAvLyB1cGRhdGUgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZjsgYWRkIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZSA9PSAnc2V0dXAnKSByZXR1cm4gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSB2aWV3cG9ydEVsZW1lbnRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBjb25zdCB3aWR0aCA9IChyaWdodCAtIGxlZnQpXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IChib3R0b20gLSB0b3ApXG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIGRpbWVuc2lvbiB1cGRhdGUgcHJvY2VkdXJlIGZvciByZXNpemUuIFxuICAgICAgICAvLyBTZWUgYWxzbyBpbnRlcnJ1cHRoYW5kbGVyLnRzeCBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrIGZvciBjcmFkbGUgaW50ZXJzZWN0aW9uIHVwZGF0ZVxuICAgICAgICBjb25zdCBsb2NhbFZpZXdwb3J0RGF0YSA9IHtcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczp7dG9wLHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgICAgICAgZWxlbWVudFJlZjp2aWV3cG9ydEVsZW1lbnRSZWYsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOmlzUmVzaXppbmdSZWYuY3VycmVudCxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBjaGFuZ2Ugd2l0aCBuZXcgb2JqZWN0XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YW9iamVjdCA9IHsuLi5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsIC4uLmxvY2FsVmlld3BvcnREYXRhfVxuXG4gICAgICAgIHJldHVybiAgdmlld3BvcnRkYXRhb2JqZWN0XG5cbiAgICB9LFtvcmllbnRhdGlvbiwgaXNSZXNpemluZ1JlZi5jdXJyZW50LCB2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzdGF0ZSBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgc3dpdGNoICh2aWV3cG9ydFN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiB7XG4gICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0U3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVuZGVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmV0dXJuIDxWaWV3cG9ydENvbnRleHQuUHJvdmlkZXIgdmFsdWUgPSB7IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCB9PlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgZGF0YS10eXBlID0gJ3ZpZXdwb3J0J1xuICAgICAgICAgICAgZGF0YS1zY3JvbGxlcmlkID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgICAgIHN0eWxlID0geyBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgcmVmID0geyB2aWV3cG9ydEVsZW1lbnRSZWYgfVxuICAgICAgICA+XG4gICAgICAgICAgICB7ICh2aWV3cG9ydFN0YXRlICE9ICdzZXR1cCcpICYmIGNoaWxkcmVuIH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9WaWV3cG9ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgXG59IC8vIFZpZXdwb3J0XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0XG4iXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsImV4cG9ydHMiLCJWaWV3cG9ydENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiVmlld3BvcnQiLCJfcmVmIiwiY2hpbGRyZW4iLCJncmlkU3BlY3MiLCJzdHlsZXMiLCJzY3JvbGxlcklEIiwiVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQiLCJvcmllbnRhdGlvbiIsIl9yZWYyIiwidXNlU3RhdGUiLCJfcmVmMyIsInZpZXdwb3J0U3RhdGUiLCJzZXRWaWV3cG9ydFN0YXRlIiwidmlld3BvcnRTdGF0ZVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJpc01vdW50ZWRSZWYiLCJ2aWV3cG9ydEVsZW1lbnRSZWYiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiaXNSZXNpemluZyIsInZpZXdwb3J0RGltZW5zaW9ucyIsImVsZW1lbnRSZWYiLCJ1c2VFZmZlY3QiLCJyZXNpemVUaW1lcmlkUmVmIiwiaXNSZXNpemluZ1JlZiIsInJlc2l6ZU9ic2VydmVyUmVmIiwiUmVzaXplT2JzZXJ2ZXIiLCJyZXNpemVDYWxsYmFjayIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwidXNlQ2FsbGJhY2siLCJlbnRyaWVzIiwidGFyZ2V0IiwiZGF0YXNldCIsImluaXRpYWxpemVkIiwiYXNzaWduIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImRpdmxpbmVyc3R5bGVSZWYiLCJ1c2VNZW1vIiwidmlld3BvcnQiLCJwb3NpdGlvbiIsImluc2V0Iiwib3ZlcmZsb3ciLCJXZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsIm92ZXJmbG93QW5jaG9yIiwiX3ZpZXdwb3J0RWxlbWVudFJlZiRjIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJsb2NhbFZpZXdwb3J0RGF0YSIsInZpZXdwb3J0ZGF0YW9iamVjdCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInN0eWxlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Placeholder.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n    listsize = _ref.listsize,\n    message = _ref.message,\n    error = _ref.error,\n    userFrameStyles = _ref.userFrameStyles,\n    userLinerStyles = _ref.userLinerStyles,\n    userErrorFrameStyles = _ref.userErrorFrameStyles,\n    userErrorLinerStyles = _ref.userErrorLinerStyles;\n  var _ref2 = (0, react_1.useMemo)(function () {\n      var uFrameStyles = !error ? userFrameStyles : userErrorFrameStyles;\n      var uLinerStyles = !error ? userLinerStyles : userErrorLinerStyles;\n      var frameStyles = Object.assign(Object.assign({\n        border: \'2px solid black\',\n        backgroundColor: \'cyan\'\n      }, uFrameStyles), {\n        position: \'relative\',\n        boxSizing: \'border-box\',\n        height: \'100%\',\n        width: \'100%\',\n        overflow: \'hidden\'\n      });\n      var linerStyles = Object.assign({\n        position: \'absolute\',\n        top: 0,\n        left: 0,\n        padding: \'3px\',\n        margin: \'3px\',\n        fontSize: \'smaller\'\n      }, uLinerStyles);\n      return [frameStyles, linerStyles];\n    }, [error, userFrameStyles, userLinerStyles, userErrorFrameStyles, userErrorLinerStyles]),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameStyles = _ref3[0],\n    linerStyles = _ref3[1];\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    "data-type": \'placeholderframe\',\n    style: frameStyles\n  }, !error ? react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, "item is not available (", error.message, ")"));\n};\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQSxTQUFBQSxlQUFBQyxHQUFBLEVBQUFDLENBQUEsV0FBQUMsZUFBQSxDQUFBRixHQUFBLEtBQUFHLHFCQUFBLENBQUFILEdBQUEsRUFBQUMsQ0FBQSxLQUFBRywyQkFBQSxDQUFBSixHQUFBLEVBQUFDLENBQUEsS0FBQUksZ0JBQUE7QUFBQSxTQUFBQSxpQkFBQSxjQUFBQyxTQUFBO0FBQUEsU0FBQUYsNEJBQUFHLENBQUEsRUFBQUMsTUFBQSxTQUFBRCxDQUFBLHFCQUFBQSxDQUFBLHNCQUFBRSxpQkFBQSxDQUFBRixDQUFBLEVBQUFDLE1BQUEsT0FBQUUsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLFNBQUEsQ0FBQUMsUUFBQSxDQUFBQyxJQUFBLENBQUFQLENBQUEsRUFBQVEsS0FBQSxhQUFBTCxDQUFBLGlCQUFBSCxDQUFBLENBQUFTLFdBQUEsRUFBQU4sQ0FBQSxHQUFBSCxDQUFBLENBQUFTLFdBQUEsQ0FBQUMsSUFBQSxNQUFBUCxDQUFBLGNBQUFBLENBQUEsbUJBQUFRLEtBQUEsQ0FBQUMsSUFBQSxDQUFBWixDQUFBLE9BQUFHLENBQUEsK0RBQUFVLElBQUEsQ0FBQVYsQ0FBQSxVQUFBRCxpQkFBQSxDQUFBRixDQUFBLEVBQUFDLE1BQUE7QUFBQSxTQUFBQyxrQkFBQVQsR0FBQSxFQUFBcUIsR0FBQSxRQUFBQSxHQUFBLFlBQUFBLEdBQUEsR0FBQXJCLEdBQUEsQ0FBQXNCLE1BQUEsRUFBQUQsR0FBQSxHQUFBckIsR0FBQSxDQUFBc0IsTUFBQSxXQUFBckIsQ0FBQSxNQUFBc0IsSUFBQSxPQUFBTCxLQUFBLENBQUFHLEdBQUEsR0FBQXBCLENBQUEsR0FBQW9CLEdBQUEsRUFBQXBCLENBQUEsSUFBQXNCLElBQUEsQ0FBQXRCLENBQUEsSUFBQUQsR0FBQSxDQUFBQyxDQUFBLFVBQUFzQixJQUFBO0FBQUEsU0FBQXBCLHNCQUFBSCxHQUFBLEVBQUFDLENBQUEsUUFBQXVCLEVBQUEsV0FBQXhCLEdBQUEsZ0NBQUF5QixNQUFBLElBQUF6QixHQUFBLENBQUF5QixNQUFBLENBQUFDLFFBQUEsS0FBQTFCLEdBQUEsNEJBQUF3QixFQUFBLFFBQUFHLEVBQUEsRUFBQUMsRUFBQSxFQUFBQyxFQUFBLEVBQUFDLEVBQUEsRUFBQUMsSUFBQSxPQUFBQyxFQUFBLE9BQUFDLEVBQUEsaUJBQUFKLEVBQUEsSUFBQUwsRUFBQSxHQUFBQSxFQUFBLENBQUFWLElBQUEsQ0FBQWQsR0FBQSxHQUFBa0MsSUFBQSxRQUFBakMsQ0FBQSxRQUFBVSxNQUFBLENBQUFhLEVBQUEsTUFBQUEsRUFBQSxVQUFBUSxFQUFBLHVCQUFBQSxFQUFBLElBQUFMLEVBQUEsR0FBQUUsRUFBQSxDQUFBZixJQUFBLENBQUFVLEVBQUEsR0FBQVcsSUFBQSxNQUFBSixJQUFBLENBQUFLLElBQUEsQ0FBQVQsRUFBQSxDQUFBVSxLQUFBLEdBQUFOLElBQUEsQ0FBQVQsTUFBQSxLQUFBckIsQ0FBQSxHQUFBK0IsRUFBQSxpQkFBQU0sR0FBQSxJQUFBTCxFQUFBLE9BQUFMLEVBQUEsR0FBQVUsR0FBQSx5QkFBQU4sRUFBQSxZQUFBUixFQUFBLGVBQUFNLEVBQUEsR0FBQU4sRUFBQSxjQUFBYixNQUFBLENBQUFtQixFQUFBLE1BQUFBLEVBQUEsMkJBQUFHLEVBQUEsUUFBQUwsRUFBQSxhQUFBRyxJQUFBO0FBQUEsU0FBQTdCLGdCQUFBRixHQUFBLFFBQUFrQixLQUFBLENBQUFxQixPQUFBLENBQUF2QyxHQUFBLFVBQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7QUFRQSxJQUFBd0MsT0FBQSxHQUFBQyxZQUFBLENBQUFDLG1CQUFBO0FBRUEsSUFBTUMsV0FBVyxHQUFHLFNBQWRBLFdBQVdBLENBQUFDLElBQUEsRUFTWjtFQUFBLElBUkRDLEtBQUssR0FBQUQsSUFBQSxDQUFMQyxLQUFLO0lBQ0xDLFFBQVEsR0FBQUYsSUFBQSxDQUFSRSxRQUFRO0lBQ1JDLE9BQU8sR0FBQUgsSUFBQSxDQUFQRyxPQUFPO0lBQ1BDLEtBQUssR0FBQUosSUFBQSxDQUFMSSxLQUFLO0lBQ0xDLGVBQWUsR0FBQUwsSUFBQSxDQUFmSyxlQUFlO0lBQ2ZDLGVBQWUsR0FBQU4sSUFBQSxDQUFmTSxlQUFlO0lBQ2ZDLG9CQUFvQixHQUFBUCxJQUFBLENBQXBCTyxvQkFBb0I7SUFDcEJDLG9CQUFvQixHQUFBUixJQUFBLENBQXBCUSxvQkFBb0I7RUFHcEIsSUFBQUMsS0FBQSxHQUFtQyxJQUFBYixPQUFBLENBQUFjLE9BQU8sRUFBQyxZQUFJO01BRTNDLElBQU1DLFlBQVksR0FDYixDQUFDUCxLQUFLLEdBQ0hDLGVBQWUsR0FDZkUsb0JBQW9CO01BRTVCLElBQU1LLFlBQVksR0FDYixDQUFDUixLQUFLLEdBQ0hFLGVBQWUsR0FDZkUsb0JBQW9CO01BRTVCLElBQU1LLFdBQVcsR0FBQTlDLE1BQUEsQ0FBQStDLE1BQUEsQ0FBQS9DLE1BQUEsQ0FBQStDLE1BQUE7UUFDYkMsTUFBTSxFQUFDLGlCQUFpQjtRQUN4QkMsZUFBZSxFQUFDO01BQU0sR0FDbkJMLFlBQVk7UUFDZk0sUUFBUSxFQUFDLFVBQVU7UUFDbkJDLFNBQVMsRUFBQyxZQUFZO1FBQ3RCQyxNQUFNLEVBQUMsTUFBTTtRQUNiQyxLQUFLLEVBQUMsTUFBTTtRQUNaQyxRQUFRLEVBQUM7TUFBUSxFQUNwQjtNQUNELElBQU1DLFdBQVcsR0FBQXZELE1BQUEsQ0FBQStDLE1BQUE7UUFDYkcsUUFBUSxFQUFDLFVBQVU7UUFDbkJNLEdBQUcsRUFBQyxDQUFDO1FBQ0xDLElBQUksRUFBQyxDQUFDO1FBQ05DLE9BQU8sRUFBQyxLQUFLO1FBQ2JDLE1BQU0sRUFBQyxLQUFLO1FBQ1pDLFFBQVEsRUFBQztNQUFTLEdBQ2ZmLFlBQVksQ0FDbEI7TUFFRCxPQUFPLENBQUNDLFdBQVcsRUFBRVMsV0FBVyxDQUFDO0lBRXJDLENBQUMsRUFBRSxDQUNDbEIsS0FBSyxFQUNMQyxlQUFlLEVBQ2ZDLGVBQWUsRUFDZkMsb0JBQW9CLEVBQ3BCQyxvQkFBb0IsQ0FDdkIsQ0FBQztJQUFBb0IsS0FBQSxHQUFBekUsY0FBQSxDQUFBc0QsS0FBQTtJQXhDS0ksV0FBVyxHQUFBZSxLQUFBO0lBQUVOLFdBQVcsR0FBQU0sS0FBQTtFQTJDL0J6QixPQUFPLEdBQUdBLE9BQU8sYUFBUEEsT0FBTyxjQUFQQSxPQUFPLEdBQUksY0FBYztFQUVuQyxPQUFPUCxPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBSWpCO0VBQVcsR0FDekQsQ0FBQ1QsS0FBSyxHQUNKUixPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBS1I7RUFBVyxHQUFJckIsS0FBSyxHQUFHLENBQUMsRSxLQUFHQyxRQUFRLEUsS0FBR0MsT0FBTyxDQUFPLEdBQ2xHUCxPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBS1I7RUFBVyxHLDJCQUEyQmxCLEtBQUssQ0FBQ0QsT0FBTyxFLElBQVEsQ0FHM0c7QUFDVixDQUFDO0FBRUQ0QixrQkFBQSxHQUFlaEMsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB0aGUgZGVmYXVsdCBQbGFjZUhvbGRlciBpcyB0byBob2xkIHRoZSBjb250ZW50IGRpc3BsYXkgdW50aWwgdGhlIGhvc3QgY29udGVudFxuICAgIGlzIHJlY2VpdmVkLiBUaGUgcGxhY2Vob2xkZXIgcHJlc2VudHMgYSB3YWl0aW5nIG1lc3NhZ2UsIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGxvYWRcbiAgICBvZiB0aGUgaG9zdCBjb250ZW50IGZhaWxlZC5cblxuICAgIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNhbiBiZSByZXBsYWNlZCBieSBhIHBsYWNlaG9sZGVyIHByb3ZpZGVkIGJ5IHRoZSBob3N0LlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlTWVtb30gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFBsYWNlaG9sZGVyID0gKHtcbiAgICBpbmRleCwgXG4gICAgbGlzdHNpemUsIFxuICAgIG1lc3NhZ2UsIFxuICAgIGVycm9yLCBcbiAgICB1c2VyRnJhbWVTdHlsZXMsIFxuICAgIHVzZXJMaW5lclN0eWxlcyxcbiAgICB1c2VyRXJyb3JGcmFtZVN0eWxlcywgXG4gICAgdXNlckVycm9yTGluZXJTdHlsZXNcbn0pID0+IHtcblxuICAgIGNvbnN0IFtmcmFtZVN0eWxlcywgbGluZXJTdHlsZXNdID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGNvbnN0IHVGcmFtZVN0eWxlcyA9IFxuICAgICAgICAgICAgKCFlcnJvcik/XG4gICAgICAgICAgICAgICAgdXNlckZyYW1lU3R5bGVzOlxuICAgICAgICAgICAgICAgIHVzZXJFcnJvckZyYW1lU3R5bGVzXG5cbiAgICAgICAgY29uc3QgdUxpbmVyU3R5bGVzID0gXG4gICAgICAgICAgICAoIWVycm9yKT9cbiAgICAgICAgICAgICAgICB1c2VyTGluZXJTdHlsZXM6XG4gICAgICAgICAgICAgICAgdXNlckVycm9yTGluZXJTdHlsZXNcblxuICAgICAgICBjb25zdCBmcmFtZVN0eWxlcyA9IHtcbiAgICAgICAgICAgIGJvcmRlcjonMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgICAgICAuLi51RnJhbWVTdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICB3aWR0aDonMTAwJScsXG4gICAgICAgICAgICBvdmVyZmxvdzonaGlkZGVuJyxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lclN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6MCxcbiAgICAgICAgICAgIGxlZnQ6MCxcbiAgICAgICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgICAgICBtYXJnaW46JzNweCcsXG4gICAgICAgICAgICBmb250U2l6ZTonc21hbGxlcicsXG4gICAgICAgICAgICAuLi51TGluZXJTdHlsZXMsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ZyYW1lU3R5bGVzLCBsaW5lclN0eWxlc11cblxuICAgIH0sIFtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHVzZXJGcmFtZVN0eWxlcywgXG4gICAgICAgIHVzZXJMaW5lclN0eWxlcyxcbiAgICAgICAgdXNlckVycm9yRnJhbWVTdHlsZXMsIFxuICAgICAgICB1c2VyRXJyb3JMaW5lclN0eWxlcyxcbiAgICBdKVxuXG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSA/PyAnKGxvYWRpbmcuLi4pJ1xuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVyZnJhbWUnIHN0eWxlID0ge2ZyYW1lU3R5bGVzfT5cbiAgICAgICAgeyAhZXJyb3I/XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9ICdwbGFjZWhvbGRlcmxpbmVyJyBzdHlsZSA9IHsgbGluZXJTdHlsZXMgfT57aW5kZXggKyAxfS97bGlzdHNpemV9IHttZXNzYWdlfTwvZGl2PjpcbiAgICAgICAgICAgIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVybGluZXInIHN0eWxlID0geyBsaW5lclN0eWxlcyB9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSAoe2Vycm9yLm1lc3NhZ2V9KTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiUGxhY2Vob2xkZXIiLCJfcmVmIiwiaW5kZXgiLCJsaXN0c2l6ZSIsIm1lc3NhZ2UiLCJlcnJvciIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJMaW5lclN0eWxlcyIsInVzZXJFcnJvckZyYW1lU3R5bGVzIiwidXNlckVycm9yTGluZXJTdHlsZXMiLCJfcmVmMiIsInVzZU1lbW8iLCJ1RnJhbWVTdHlsZXMiLCJ1TGluZXJTdHlsZXMiLCJmcmFtZVN0eWxlcyIsImFzc2lnbiIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsInBvc2l0aW9uIiwiYm94U2l6aW5nIiwiaGVpZ2h0Iiwid2lkdGgiLCJvdmVyZmxvdyIsImxpbmVyU3R5bGVzIiwidG9wIiwibGVmdCIsInBhZGRpbmciLCJtYXJnaW4iLCJmb250U2l6ZSIsIl9yZWYzIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// scrolltracker.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n    left = _ref.left,\n    offset = _ref.offset,\n    listsize = _ref.listsize,\n    styles = _ref.styles;\n  var trackdata = "".concat(offset + 1, "/").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0FBT0EsSUFBQUEsT0FBQSxHQUFBQyxZQUFBLENBQUFDLG1CQUFBO0FBRUEsSUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFhQSxDQUFBQyxJQUFBLEVBQStDO0VBQUEsSUFBekNDLEdBQUcsR0FBQUQsSUFBQSxDQUFIQyxHQUFHO0lBQUVDLElBQUksR0FBQUYsSUFBQSxDQUFKRSxJQUFJO0lBQUVDLE1BQU0sR0FBQUgsSUFBQSxDQUFORyxNQUFNO0lBQUVDLFFBQVEsR0FBQUosSUFBQSxDQUFSSSxRQUFRO0lBQUVDLE1BQU0sR0FBQUwsSUFBQSxDQUFOSyxNQUFNO0VBRXhELElBQU1DLFNBQVMsTUFBQUMsTUFBQSxDQUFNSixNQUFNLEdBQUcsQ0FBQyxPQUFBSSxNQUFBLENBQUlILFFBQVEsQ0FBRTtFQUU3QyxJQUFNSSxRQUFRLEdBQUcsSUFBQVosT0FBQSxDQUFBYSxNQUFNLEVBQUFDLE1BQUEsQ0FBQUMsTUFBQTtJQUNuQlYsR0FBRyxFQUFFQSxHQUFHLEdBQUcsSUFBSTtJQUNmQyxJQUFJLEVBQUVBLElBQUksR0FBRyxJQUFJO0lBQ2pCVSxRQUFRLEVBQUMsT0FBTztJQUNoQkMsTUFBTSxFQUFDLENBQUM7SUFDUkMsZUFBZSxFQUFDLE9BQU87SUFDdkJDLE1BQU0sRUFBRSxnQkFBZ0I7SUFDeEJDLFlBQVksRUFBQyxNQUFNO0lBQ25CQyxRQUFRLEVBQUMsU0FBUztJQUNsQkMsT0FBTyxFQUFDO0VBQUssR0FDVmIsTUFBTSxDQUFDYyxhQUFhLEVBQ3pCO0VBRUYsT0FBT3ZCLE9BQUEsWUFBQXdCLGFBQUE7SUFBQSxhQUFpQixlQUFlO0lBQUNDLEtBQUssRUFBSWIsUUFBUSxDQUFDYztFQUFPLEdBQUloQixTQUFTLENBQU87QUFDekYsQ0FBQztBQUVEaUIsa0JBQUEsR0FBZXhCLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9TY3JvbGxUcmFja2VyLnRzeD8wYjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIFNjcm9sbFRyYWNrZXIgaXMgdG8gcHJvdmlkZSBmZWVkYmFjayB0byB0aGUgdXNlciBvZiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlXG4gICAgdmlydHVhbCBsaXN0IGR1cmluZyByZXBvc2l0aW9uZy5cblxuICAgIFNjcm9sbFRyYWNrZXIgY2FuIGJlIHN1cHByZXNzZWQgYnkgdGhlIGhvc3QgKGluIGZhdm91ciBvZiB0aGUgaG9zdCdzIG93biBsb2NhdGlvbiBmZWVkYmFjaylcbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFNjcm9sbFRyYWNrZXIgPSAoeyB0b3AsIGxlZnQsIG9mZnNldCwgbGlzdHNpemUsIHN0eWxlcyB9KSA9PiB7XG5cbiAgICBjb25zdCB0cmFja2RhdGEgPSBgJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfWBcblxuICAgIGNvbnN0IHN0eWxlUmVmID0gdXNlUmVmKHtcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246J2ZpeGVkJyxcbiAgICAgICAgekluZGV4OjMsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgZ3JheScsXG4gICAgICAgIGJvcmRlclJhZGl1czonMTBweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgcGFkZGluZzonM3B4JyxcbiAgICAgICAgLi4uc3R5bGVzLnNjcm9sbHRyYWNrZXJcbiAgICB9KVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS1uYW1lID0gJ3Njcm9sbHRyYWNrZXInIHN0eWxlID0ge3N0eWxlUmVmLmN1cnJlbnR9ID57dHJhY2tkYXRhfTwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxUcmFja2VyIl0sIm5hbWVzIjpbInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiU2Nyb2xsVHJhY2tlciIsIl9yZWYiLCJ0b3AiLCJsZWZ0Iiwib2Zmc2V0IiwibGlzdHNpemUiLCJzdHlsZXMiLCJ0cmFja2RhdGEiLCJjb25jYXQiLCJzdHlsZVJlZiIsInVzZVJlZiIsIk9iamVjdCIsImFzc2lnbiIsInBvc2l0aW9uIiwiekluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiZm9udFNpemUiLCJwYWRkaW5nIiwic2Nyb2xsdHJhY2tlciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImN1cnJlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// contentfunctions.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calculateShiftSpecs = exports.calculateShiftInstruction = exports.calculateContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    calculateContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    calculateShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\"));\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// ======================[ for setCradleContent ]===========================\nvar calculateContentListRequirements = function calculateContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n    baseRowLength = _ref.baseRowLength,\n    targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n    cradleInheritedProperties = _ref.cradleInheritedProperties,\n    cradleInternalProperties = _ref.cradleInternalProperties;\n  var padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount,\n    listRowcount = cradleInternalProperties.listRowcount,\n    listsize = cradleInternalProperties.listsize;\n  // align axis reference to first row item\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount;\n  // derive target row\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  // update will compensate if this is too high\n  var maxAxisRowOffset = Math.max(0, listRowcount - 1);\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  }\n  // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount);\n  // trailing edge\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount;\n  // ---------------------[ calc cradle content count ]---------------------\n  var newCradleContentCount = cradleRowcount * crosscount;\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  }\n  // --------------------[ calc css positioning ]-----------------------\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * baseRowLength + padding - targetAxisViewportPixelOffset;\n  // ----------------------[ return required values ]---------------------\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\nexports.calculateContentListRequirements = calculateContentListRequirements;\n// ======================[ for updateCradleContent ]===========================\n/*\n    the two triggerlines must straddle the head of the viewport (top or left) so that\n    cradle motion can be detected. Motion is most often caused by scrolling, but\n    can also occur with change of size of cradle content rows.\n\n    calculateShiftInstruction determines whether the axis should be moved toward the head or tail\n        to restore the straddling position of the two trigger lines. Lots of relative motion.\n\n    'moveaxisheadward' (scrolling down or right) means moving the axis up or left, adjacent items down\n         or right to the tail, dropping trailing tail items, and adding leading head items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'moveaxistailward' (scrolling up or left) means moving the axis down or right, adjacent items up\n         or left to the head, dropping trailing head items, and adding leading tail items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'none' means no shift is required\n*/\nvar calculateShiftInstruction = function calculateShiftInstruction(_ref2) {\n  var orientation = _ref2.orientation,\n    triggerlineEntries = _ref2.triggerlineEntries,\n    triggerlineSpan = _ref2.triggerlineSpan,\n    scrollerID = _ref2.scrollerID,\n    isFirstRowTriggerConfig = _ref2.isFirstRowTriggerConfig,\n    viewportBoundingRect = _ref2.viewportBoundingRect,\n    triggerHistoryRef = _ref2.triggerHistoryRef;\n  var triggerData = {\n    headOffset: null,\n    tailOffset: null,\n    span: triggerlineSpan,\n    isFirstRowTriggerConfig: isFirstRowTriggerConfig\n  };\n  // most recent; either triggerline will do\n  var entry = triggerlineEntries[triggerlineEntries.length - 1]; //.at(-1) at not available in iOS 15\n  var referencename = entry.target.dataset.type;\n  entry.referencename = referencename;\n  var span = triggerlineSpan;\n  var intersectrootpos = orientation == 'vertical' ? Math.trunc(entry.rootBounds.y) : Math.trunc(entry.rootBounds.x);\n  // entry.rootBounds.y:\n  // entry.rootBounds.x\n  var boundingrootpos = orientation == 'vertical' ? Math.trunc(viewportBoundingRect.y) : Math.trunc(viewportBoundingRect.x);\n  // viewportBoundingRect.y:\n  // viewportBoundingRect.x\n  // this selection is redundant, but documents what's going on\n  var rootpos = intersectrootpos == boundingrootpos ? intersectrootpos : boundingrootpos; // we're in Safari, zoomed\n  var entrypos = orientation == 'vertical' ? Math.trunc(entry.boundingClientRect.y) : Math.trunc(entry.boundingClientRect.x);\n  // entry.boundingClientRect.y:\n  // entry.boundingClientRect.x\n  var viewportTriggerOffset = entrypos - rootpos;\n  if (referencename == 'headtrigger') {\n    triggerData.headOffset = viewportTriggerOffset;\n    triggerData.tailOffset = viewportTriggerOffset + span;\n  } else {\n    // tailtrigger\n    triggerData.headOffset = viewportTriggerOffset - span;\n    triggerData.tailOffset = viewportTriggerOffset;\n  }\n  var shiftinstruction;\n  var triggerHistory = triggerHistoryRef.current;\n  // since triggers are moved and can share the 0 (zero) offset, an infinite loop can occur\n  // between the head and tail triggers. The following short-circuits that.\n  // Obviously needs work to generalize...\n  if ((0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset == 0 || triggerData.tailOffset == 0) || !(0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset >= -1 && triggerData.headOffset <= 1 || triggerData.tailOffset >= -1 && triggerData.tailOffset <= 1)) {\n    // some browsers do an infinite loop with the same previousReferenceName;\n    // usually alternates\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n      shiftinstruction = 'none';\n    } else {\n      if (triggerData.headOffset >= -1 && triggerData.headOffset <= 1) {\n        // if (triggerData.headOffset == 0) {\n        triggerHistory.previousReferenceName = 'headtrigger';\n      } else {\n        triggerHistory.previousReferenceName = 'tailtrigger';\n      }\n    }\n  } else {\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n    }\n  }\n  if (shiftinstruction) {\n    // will be 'none'\n    return [shiftinstruction, 0]; //triggerViewportReferencePos]\n  }\n\n  if (isFirstRowTriggerConfig) {\n    if (triggerData.headOffset <= 0) {\n      shiftinstruction = 'moveaxistailward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  } else {\n    if (triggerData.tailOffset <= 0) {\n      shiftinstruction = 'moveaxistailward';\n    } else if (triggerData.headOffset >= 0) {\n      shiftinstruction = 'moveaxisheadward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  }\n  var triggerViewportReferencePos = shiftinstruction == 'moveaxistailward' ?\n  // block is scrolling up or left\n  triggerData.tailOffset :\n  // needs to move up or left toward head\n  triggerData.headOffset; // needs to move down or right toward tail\n  return [shiftinstruction, triggerViewportReferencePos];\n};\nexports.calculateShiftInstruction = calculateShiftInstruction;\n/*\n    The basic goal of calcContentShoft is to determine the number and direction of rows to shift between\n    the head and tail grids (which determines the new location of the axis), and also to\n    calculate the rolling addition and deletion of cradle content to accommodate the changes.\n\n    The number of rows to shift is determined by the pixel shift required to restore the\n    triggerlines to their straddle configuration around the head (top or left) of the viewport.\n\n    Adjustments are made to accommodate special requirements at the start and end of the virtual list.\n\n    DOM measurements are used where available (to accommodate variable dimension rows), and standard\n    units (cellHeight, cellWidth) used for estimates where necessary.\n*/\n// rowshift is at least 1 by the time this function is reached\n// ie. a shiftinstruction of 'moveaxisheadward' or 'moveaxistailward'\nvar calculateShiftSpecs = function calculateShiftSpecs(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n    triggerViewportReferencePos = _ref3.triggerViewportReferencePos,\n    scrollPos = _ref3.scrollPos,\n    scrollblockElement = _ref3.scrollblockElement,\n    cradleInheritedProperties = _ref3.cradleInheritedProperties,\n    cradleInternalProperties = _ref3.cradleInternalProperties,\n    cradleContent = _ref3.cradleContent,\n    cradleElements = _ref3.cradleElements;\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n  // configuration data\n  var gap = cradleInheritedProperties.gap,\n    padding = cradleInheritedProperties.padding,\n    orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    layout = cradleInheritedProperties.layout;\n  // cradle elements\n  var axisElement = cradleElements.axisRef.current,\n    headGridElement = cradleElements.headRef.current,\n    tailGridElement = cradleElements.tailRef.current;\n  // cradle contents\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n    tailcontentlist = cradleContent.tailModelComponents;\n  // more config data\n  var crosscount = cradleInternalProperties.crosscount,\n    cradleRowcount = cradleInternalProperties.cradleRowcount,\n    listsize = cradleInternalProperties.listsize,\n    listRowcount = cradleInternalProperties.listRowcount,\n    viewportRowcount = cradleInternalProperties.viewportRowcount,\n    runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0,\n    previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0,\n    previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n  var listEndrowOffset = listRowcount - 1;\n  var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n  var spanRowPtr,\n    spanAxisPixelShift = 0,\n    // in relation to viewport head boundary\n    inProcessRowPtr = 0,\n    isListBoundary = false,\n    totalPixelShift,\n    finalVariableRowLength; // special case\n  // measure exising rows for variable length cells\n  if (layout == 'variable') {\n    var referenceGridElement =\n    // moving axis (and triggers) toward the reference grid element\n    shiftinstruction == 'moveaxistailward' ?\n    // scrolling up or left\n    tailGridElement : headGridElement;\n    var gridRowLengths = getGridRowLengths(referenceGridElement, orientation, crosscount, gap);\n    if (shiftinstruction == 'moveaxisheadward') {\n      // scrolling down or right; move triggerlines up or left\n      gridRowLengths.reverse(); // head grid row lengths listed from axis toward head\n    }\n\n    var gridRowAggregateSpans = getGridRowAggregateSpans(gridRowLengths); // count pixels where available\n    // ----------------------------[ 2. calculate base row shift ]--------------------------\n    // first try to find position based on known (instantiated) rows\n    if (shiftinstruction == 'moveaxistailward') {\n      // scroll up\n      // tail trigger needs to move down or right until position relative to viewport top or left is positive\n      spanRowPtr = gridRowAggregateSpans.findIndex(function (aggregatespan) {\n        return triggerViewportReferencePos + aggregatespan >= 0;\n      });\n    } else {\n      // 'moveaxisheadward', scrolldown\n      // head trigger needs to move up or left until position relative to viewport top or left is negative\n      spanRowPtr = gridRowAggregateSpans.findIndex(function (aggregatespan) {\n        return triggerViewportReferencePos - aggregatespan <= 0;\n      });\n    }\n    if (!(spanRowPtr == -1)) {\n      // found measureed row for shift\n      spanAxisPixelShift = shiftinstruction == 'moveaxistailward' ? gridRowAggregateSpans[spanRowPtr] :\n      // move axis toward tail from viewport boundary (positive)\n      -gridRowAggregateSpans[spanRowPtr]; // move axis toward head from viewport boundary (negative)\n    } else {\n      // either in boundary, or shy of target\n      isListBoundary = gridRowAggregateSpans.length == 0; // boundary at head of list\n      if (!isListBoundary) {\n        // interim working result\n        inProcessRowPtr = gridRowAggregateSpans.length - 1; // base: failed measured row ptr\n        totalPixelShift = gridRowAggregateSpans[inProcessRowPtr]; // set base of working overshoot\n        finalVariableRowLength = gridRowLengths.at(-1); // for oversize cell adjustment below\n      }\n    }\n  } else {\n    // layout == 'uniform'; use only defined lengths\n    spanRowPtr = -1; // \"not found\", ie not applicable\n    inProcessRowPtr = 0;\n    totalPixelShift = 0;\n  }\n  // uniform layout, or overshoot of instantiated rows; continue with virtual base rows\n  if (spanRowPtr == -1) {\n    if (!isListBoundary) {\n      if (shiftinstruction == 'moveaxistailward') {\n        // scrolling up/left\n        do {\n          totalPixelShift += baseRowLength;\n          inProcessRowPtr++;\n        } while (triggerViewportReferencePos + totalPixelShift < 0);\n        spanAxisPixelShift = totalPixelShift;\n      } else {\n        // moveaxisheadward; scrolling down/right\n        do {\n          totalPixelShift += baseRowLength;\n          inProcessRowPtr++;\n          if (previousAxisRowOffset - inProcessRowPtr == 0) {\n            // stop cycling at head limit\n            break;\n          }\n        } while (triggerViewportReferencePos - totalPixelShift > 0);\n        spanAxisPixelShift = -totalPixelShift;\n      }\n    }\n    // inProcessRowPtr is one greater than spanRowPtr with actual measurements above\n    // this makes them compativle for span conversion (next step)\n    spanRowPtr = inProcessRowPtr - 1;\n  }\n  var spanRowShift =\n  // pick up row shift with or without overshoot\n  shiftinstruction == 'moveaxistailward' ? spanRowPtr + 1 : -(spanRowPtr + 1);\n  // the following two values (axisReferenceRowShift & axisPixelShift), and no other calcs, \n  //     are carried forward in this function.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n  var axisReferenceRowShift = spanRowShift,\n    axisPixelShift = spanAxisPixelShift;\n  // this can only happen with oversized cellLength (ie > viewportLength)\n  //     and only using measured length\n  // axis must be no farther than 1 back of the last row end position\n  if (previousAxisRowOffset + axisReferenceRowShift > listEndrowOffset) {\n    axisReferenceRowShift -= 1;\n    if (layout == 'variable') {\n      axisPixelShift -= finalVariableRowLength; //gridRowLengths.at(-1)\n    } else {\n      axisPixelShift -= baseRowLength;\n    }\n  }\n  // -----------[ 3. calculate current viewport axis offset ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n  var scrollblockAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockOffset =\n  // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n  // currentViewportAxisOffset will be negative (above viewport edge) for scroll block headward \n  //     and positive for scroll block tailward\n  // the pixel distance between the viewport frame and the axis, toward the head\n  var currentViewportAxisOffset = scrollblockAxisOffset + scrollblockOffset - scrollPos;\n  // -------------[ 4. calculate new axis pixel position ]------------------\n  var newAxisViewportPixelOffset = currentViewportAxisOffset + axisPixelShift;\n  // Note: sections 5, 6 and 7 deal entirely with row calculations; no pixels\n  // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n  var cradleReferenceRowshift = axisReferenceRowShift;\n  // base values\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowShift;\n  // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n  if (shiftinstruction == 'moveaxistailward') {\n    // scrolling up/left\n    // a. if scrolling the block headward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling the block headward (revealing tail of list), as the cradle last row offset \n    // approaches max listrow, new cradle offset and cradle row shift have to be adjusted to prevent \n    // shortening of cradle content.\n    // --- start of list adjustment\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1); // extra row for visibility\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    }\n    // --- end of list adjustment: case of being in bounds of trailing runway (end of list)\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n    if (tailrowdiff > 0) {\n      cradleReferenceRowshift -= tailrowdiff;\n      newCradleReferenceRowOffset -= tailrowdiff;\n    }\n  } else {\n    // shiftinstruction == 'moveaxisheadward'; scrolling down/right\n    // c. if scrolling the block down or right (toward revealing head of list), as the cradlerowoffset \n    // hits 0, cradle changes have to be adjusted to prevent shortening of cradle content\n    // d. if scrolling headward near the end of the list, cradle changes have to be adjusted to \n    // accomodate the trailing runway\n    // --- start of list adjustment\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    }\n    if (layout == 'variable' && newAxisReferenceRowOffset == 0) {\n      newAxisViewportPixelOffset = padding;\n    }\n    // --- end of list adjustment; case of in bounds of trailing runway\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n    var _targetCradleEndrowOffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n    var _tailrowdiff = Math.max(0, _targetCradleEndrowOffset - computedNextCradleEndrowOffset);\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset += _tailrowdiff;\n    }\n  }\n  // ----------------------[ 7. map rows to item references ]----------------------\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowShift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  }\n  // create head and tail change counts\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount;\n  // ---------------------[ 8. return required values ]-------------------\n  return {\n    // newCradleReferenceIndex, \n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisViewportPixelOffset: newAxisViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\nexports.calculateShiftSpecs = calculateShiftSpecs;\n// supports calcContentShift above\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n  return rowLengths;\n};\n// supports calcContentShift above\nvar getGridRowAggregateSpans = function getGridRowAggregateSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n};\n// =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds CellFrames at end of contentlist according to headindexcount and tailindexcount,\n// or if indexcount values are <0 removes them.\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n    cradleInternalProperties = _ref4.cradleInternalProperties,\n    cacheHandler = _ref4.cacheHandler,\n    cradleContentCount = _ref4.cradleContentCount,\n    cradleReferenceIndex = _ref4.cradleReferenceIndex,\n    listStartChangeCount = _ref4.listStartChangeCount,\n    listEndChangeCount = _ref4.listEndChangeCount,\n    contentlist = _ref4.workingContentList,\n    instanceIdCounterRef = _ref4.instanceIdCounterRef,\n    styles = _ref4.styles,\n    placeholderMessages = _ref4.placeholderMessages;\n  var localContentlist = _toConsumableArray(contentlist);\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n    tailContentlist = [];\n  var deletedtailitems = [],\n    deletedheaditems = [];\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    var referenceIndex = cradleReferenceIndex;\n    var changeCount = listStartChangeCount;\n    if (listStartChangeCount > cradleContentCount) {\n      referenceIndex = cradleReferenceIndex - (listStartChangeCount - cradleContentCount);\n      changeCount = cradleContentCount;\n    }\n    for (var newindex = referenceIndex - changeCount; newindex < referenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    var _referenceIndex = lastindexoffset;\n    var _changeCount = listEndChangeCount;\n    if (listEndChangeCount > cradleContentCount) {\n      _referenceIndex = lastindexoffset + (listEndChangeCount - cradleContentCount);\n      _changeCount = cradleContentCount;\n    }\n    for (var _newindex = _referenceIndex + 1; _newindex < _referenceIndex + 1 + _changeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\nexports.getCellFrameComponentList = getCellFrameComponentList;\n// Leading (head) all or partially hidden; tail, visible plus trailing hidden\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n    axisReferenceIndex = _ref5.axisReferenceIndex,\n    layoutHandler = _ref5.layoutHandler;\n  var _a;\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index,\n    highindex = offsetindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n  if (triggercellIndex !== undefined && offsetindex !== undefined) {\n    //&& \n    if (triggercellIndex >= offsetindex && triggercellIndex <= highindex) {\n      var _triggercellPtr = triggercellIndex - offsetindex;\n      var _triggercellComponent = contentlist[_triggercellPtr];\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n  var triggercellPtr = targetTriggercellIndex - offsetindex;\n  var triggercellComponent = contentlist[triggercellPtr];\n  if (triggercellComponent) {\n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    // defensive; shouldn't happen\n    console.log('FAILURE TO REGISTER TRIGGERCELL:');\n    console.log('axisReferenceIndex, triggercellIndex, offsetindex, highindex, headitemcount, targetTriggercellIndex', axisReferenceIndex, triggercellIndex, offsetindex, highindex, headitemcount, targetTriggercellIndex);\n    console.log('triggercellPtr, triggercellComponent, triggercellComponent?.props.isTriggecell, contentlist\\n', triggercellPtr, triggercellComponent, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell, Object.assign({}, contentlist));\n  }\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\nexports.allocateContentList = allocateContentList;\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\nexports.deletePortals = deletePortals;\n// =====================[ internal, acquire item ]======================\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n    cradleInheritedProperties = _ref6.cradleInheritedProperties,\n    cradleInternalProperties = _ref6.cradleInternalProperties,\n    instanceIdCounterRef = _ref6.instanceIdCounterRef,\n    cacheHandler = _ref6.cacheHandler,\n    placeholderFrameStyles = _ref6.placeholderFrameStyles,\n    placeholderLinerStyles = _ref6.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref6.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref6.placeholderErrorLinerStyles,\n    placeholderMessages = _ref6.placeholderMessages;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    cellMinHeight = cradleInheritedProperties.cellMinHeight,\n    cellMinWidth = cradleInheritedProperties.cellMinWidth,\n    getItem = cradleInheritedProperties.getItem,\n    placeholder = cradleInheritedProperties.placeholder,\n    scrollerID = cradleInheritedProperties.scrollerID,\n    layout = cradleInheritedProperties.layout,\n    usePlaceholder = cradleInheritedProperties.usePlaceholder;\n  var listsize = cradleInternalProperties.listsize;\n  // get new or existing itemID\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    usePlaceholder: usePlaceholder,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderLinerStyles: placeholderLinerStyles,\n    placeholderErrorFrameStyles: placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles: placeholderErrorLinerStyles,\n    placeholderMessages: placeholderMessages\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGNBQWM7RUFJbEIsSUFBUXpNLFFBQVEsR0FBS04sd0JBQXdCLENBQXJDTSxRQUFRO0VBRWhCO0VBQ0EsSUFBTTBNLE1BQU0sR0FBR2pFLFlBQVksQ0FBQ2tFLHNCQUFzQixDQUFDakksS0FBSyxDQUFDO0VBRXpELE9BQU8zRixPQUFBLFlBQUE2TixhQUFBLENBQUMxTixXQUFBLFdBQVM7SUFDYjJOLEdBQUcsRUFBS1QsVUFBVTtJQUNsQmxMLFdBQVcsRUFBS0EsV0FBVztJQUMzQnVDLFVBQVUsRUFBS0EsVUFBVTtJQUN6QkMsU0FBUyxFQUFLQSxTQUFTO0lBQ3ZCMkksYUFBYSxFQUFLQSxhQUFhO0lBQy9CQyxZQUFZLEVBQUtBLFlBQVk7SUFDN0IzSSxNQUFNLEVBQUtBLE1BQU07SUFDakJlLEtBQUssRUFBS0EsS0FBSztJQUNmNkgsT0FBTyxFQUFLQSxPQUFPO0lBQ25Cdk0sUUFBUSxFQUFLQSxRQUFRO0lBQ3JCd00sV0FBVyxFQUFLQSxXQUFXO0lBQzNCRSxNQUFNLEVBQUtBLE1BQU07SUFDakJOLFVBQVUsRUFBS0EsVUFBVTtJQUN6Qi9LLFVBQVUsRUFBS0EsVUFBVTtJQUN6QmdLLGFBQWEsRUFBSyxLQUFLO0lBQ3ZCb0IsY0FBYyxFQUFLQSxjQUFjO0lBQ2pDOUMsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqREUsc0JBQXNCLEVBQUtBLHNCQUFzQjtJQUNqREUsMkJBQTJCLEVBQUtBLDJCQUEyQjtJQUMzREUsMkJBQTJCLEVBQUtBLDJCQUEyQjtJQUMzRGpCLG1CQUFtQixFQUFLQTtFQUFtQixFQUM3QztBQUVOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBjb250ZW50aGFuZGxlciBtb2R1bGUuIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgcGVyZm9ybVxuICAgIHRoZSBkZXRhaWxlZCBjYWxjdWxhdGlvbnMgYW5kIHByb2Nlc3NlcyByZXF1aXJlZCBieSB0aGUgY29udGVudGhhbmRsZXIuXG5cbiAgICBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50cyBpcyBjYWxsZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyJ3Mgc2V0Q3JhZGxlQ29udGVudCBmdW5jdGlvbi5cblxuICAgIGNhbGN1bGF0ZVNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4uL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcbiAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgbGlzdHNpemUsXG5cbiAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG4gICAgXG4gICAgLy8gYWxpZ24gYXhpcyByZWZlcmVuY2UgdG8gZmlyc3Qgcm93IGl0ZW1cbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbih0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtPSAodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudClcblxuICAgIC8vIGRlcml2ZSB0YXJnZXQgcm93XG4gICAgbGV0IHRhcmdldEF4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwodGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICAvLyB1cGRhdGUgd2lsbCBjb21wZW5zYXRlIGlmIHRoaXMgaXMgdG9vIGhpZ2hcbiAgICBjb25zdCBtYXhBeGlzUm93T2Zmc2V0ID0gTWF0aC5tYXgoMCxsaXN0Um93Y291bnQgLSAxKVxuICAgIGlmICh0YXJnZXRBeGlzUm93T2Zmc2V0ID4gbWF4QXhpc1Jvd09mZnNldCkge1xuICAgICAgICB0YXJnZXRBeGlzUm93T2Zmc2V0ID0gbWF4QXhpc1Jvd09mZnNldFxuICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRBeGlzUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZVJlZmVyZW5jZVJvdyAmIEluZGV4IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGxlYWRpbmcgZWRnZVxuICAgIGxldCB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgPSBNYXRoLm1heCgwLHRhcmdldEF4aXNSb3dPZmZzZXQgLSBydW53YXlSb3djb3VudClcblxuICAgIC8vIHRyYWlsaW5nIGVkZ2VcbiAgICBsZXQgdGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID0gdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcblxuICAgIGNvbnN0IGxpc3RFbmRSb3dPZmZzZXQgPSAobGlzdFJvd2NvdW50IC0gMSlcblxuICAgIGlmICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPiAobGlzdEVuZFJvd09mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9ICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgLSBsaXN0RW5kUm93T2Zmc2V0KVxuICAgICAgICB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgLT0gZGlmZlxuICAgICAgICB0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgLT0gZGlmZlxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4ID0gdGFyZ2V0Q3JhZGxlUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZSBjb250ZW50IGNvdW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICBpZiAodGFyZ2V0Q3JhZGxlRW5kUm93T2Zmc2V0ID09IGxpc3RFbmRSb3dPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZW5kUm93UmVtYWluZGVyQ291bnQgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgaWYgKGVuZFJvd1JlbWFpbmRlckNvdW50KSB7XG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQgLT0gKGNyb3NzY291bnQgLSBlbmRSb3dSZW1haW5kZXJDb3VudClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNzcyBwb3NpdGlvbmluZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAodGFyZ2V0QXhpc1Jvd09mZnNldCAqIGJhc2VSb3dMZW5ndGgpICsgcGFkZGluZyAtIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZXR1cm4gcmVxdWlyZWQgdmFsdWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIFxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsIFxuICAgIH0gXG5cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PVsgZm9yIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKlxuICAgIHRoZSB0d28gdHJpZ2dlcmxpbmVzIG11c3Qgc3RyYWRkbGUgdGhlIGhlYWQgb2YgdGhlIHZpZXdwb3J0ICh0b3Agb3IgbGVmdCkgc28gdGhhdFxuICAgIGNyYWRsZSBtb3Rpb24gY2FuIGJlIGRldGVjdGVkLiBNb3Rpb24gaXMgbW9zdCBvZnRlbiBjYXVzZWQgYnkgc2Nyb2xsaW5nLCBidXRcbiAgICBjYW4gYWxzbyBvY2N1ciB3aXRoIGNoYW5nZSBvZiBzaXplIG9mIGNyYWRsZSBjb250ZW50IHJvd3MuXG5cbiAgICBjYWxjdWxhdGVTaGlmdEluc3RydWN0aW9uIGRldGVybWluZXMgd2hldGhlciB0aGUgYXhpcyBzaG91bGQgYmUgbW92ZWQgdG93YXJkIHRoZSBoZWFkIG9yIHRhaWxcbiAgICAgICAgdG8gcmVzdG9yZSB0aGUgc3RyYWRkbGluZyBwb3NpdGlvbiBvZiB0aGUgdHdvIHRyaWdnZXIgbGluZXMuIExvdHMgb2YgcmVsYXRpdmUgbW90aW9uLlxuXG4gICAgJ21vdmVheGlzaGVhZHdhcmQnIChzY3JvbGxpbmcgZG93biBvciByaWdodCkgbWVhbnMgbW92aW5nIHRoZSBheGlzIHVwIG9yIGxlZnQsIGFkamFjZW50IGl0ZW1zIGRvd25cbiAgICAgICAgIG9yIHJpZ2h0IHRvIHRoZSB0YWlsLCBkcm9wcGluZyB0cmFpbGluZyB0YWlsIGl0ZW1zLCBhbmQgYWRkaW5nIGxlYWRpbmcgaGVhZCBpdGVtcyBhcyBuZWNlc3NhcnlcbiAgICAgICAgIHRvIG1haW50YWluIG51bWJlciBvZiBjcmFkbGUgcm93cyBvZiBjb250ZW50IGNvbnN0YW50LlxuXG4gICAgJ21vdmVheGlzdGFpbHdhcmQnIChzY3JvbGxpbmcgdXAgb3IgbGVmdCkgbWVhbnMgbW92aW5nIHRoZSBheGlzIGRvd24gb3IgcmlnaHQsIGFkamFjZW50IGl0ZW1zIHVwXG4gICAgICAgICBvciBsZWZ0IHRvIHRoZSBoZWFkLCBkcm9wcGluZyB0cmFpbGluZyBoZWFkIGl0ZW1zLCBhbmQgYWRkaW5nIGxlYWRpbmcgdGFpbCBpdGVtcyBhcyBuZWNlc3NhcnlcbiAgICAgICAgIHRvIG1haW50YWluIG51bWJlciBvZiBjcmFkbGUgcm93cyBvZiBjb250ZW50IGNvbnN0YW50LlxuXG4gICAgJ25vbmUnIG1lYW5zIG5vIHNoaWZ0IGlzIHJlcXVpcmVkXG4qL1xuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU2hpZnRJbnN0cnVjdGlvbiA9ICh7XG5cbiAgICBvcmllbnRhdGlvbixcbiAgICB0cmlnZ2VybGluZUVudHJpZXMsXG4gICAgdHJpZ2dlcmxpbmVTcGFuLFxuICAgIHNjcm9sbGVySUQsIC8vIGZvciBkZWJ1Z1xuICAgIFxuICAgIC8vIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIGlzIHRydWUgaWYgdGhlIHRyaWdnZXJsaW5lcyBhcmUgd2l0aCB0aGUgZmlyc3QgdGFpbCByb3cgaW5zdGVhZCBvZiB0aGVcbiAgICAvLyBsYXN0IGhlYWRyb3cuIFRoYXQgaGFwcGVucyAod29ya2Fyb3VuZCkgd2hlbiB0aGVyZSBhcmUgbm8gaGVhZCByb3dzXG4gICAgaXNGaXJzdFJvd1RyaWdnZXJDb25maWcsIFxuXG4gICAgLy8gU2FmYXJpIGRvZXNuJ3QgbWVhc3VyZSB6b29tZWQgdmFsdWVzIGZvciByb290Ym91bmRzIGluIHRyaWdnZXJsaW5lRW50cmllcywgc28gd2UgdGFrZSBhIGRpcmVjdCByZWFkaW5nXG4gICAgdmlld3BvcnRCb3VuZGluZ1JlY3QsIFxuICAgIHRyaWdnZXJIaXN0b3J5UmVmLFxuXG59KSA9PiB7XG5cbiAgICBjb25zdCB0cmlnZ2VyRGF0YSA9IHtcbiAgICAgICAgaGVhZE9mZnNldDpudWxsLFxuICAgICAgICB0YWlsT2Zmc2V0Om51bGwsXG4gICAgICAgIHNwYW46dHJpZ2dlcmxpbmVTcGFuLFxuICAgICAgICBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZ1xuICAgIH1cblxuICAgIC8vIG1vc3QgcmVjZW50OyBlaXRoZXIgdHJpZ2dlcmxpbmUgd2lsbCBkb1xuICAgIGNvbnN0IGVudHJ5ID0gdHJpZ2dlcmxpbmVFbnRyaWVzW3RyaWdnZXJsaW5lRW50cmllcy5sZW5ndGggLSAxXSAvLy5hdCgtMSkgYXQgbm90IGF2YWlsYWJsZSBpbiBpT1MgMTVcbiAgICBjb25zdCByZWZlcmVuY2VuYW1lID0gZW50cnkudGFyZ2V0LmRhdGFzZXQudHlwZVxuICAgIGVudHJ5LnJlZmVyZW5jZW5hbWUgPSByZWZlcmVuY2VuYW1lXG4gICAgY29uc3Qgc3BhbiA9IHRyaWdnZXJsaW5lU3BhblxuXG4gICAgY29uc3QgaW50ZXJzZWN0cm9vdHBvcyA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBNYXRoLnRydW5jKGVudHJ5LnJvb3RCb3VuZHMueSk6XG4gICAgICAgICAgICBNYXRoLnRydW5jKGVudHJ5LnJvb3RCb3VuZHMueClcbiAgICAgICAgICAgIC8vIGVudHJ5LnJvb3RCb3VuZHMueTpcbiAgICAgICAgICAgIC8vIGVudHJ5LnJvb3RCb3VuZHMueFxuXG4gICAgY29uc3QgYm91bmRpbmdyb290cG9zID1cbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgTWF0aC50cnVuYyh2aWV3cG9ydEJvdW5kaW5nUmVjdC55KTpcbiAgICAgICAgICAgIE1hdGgudHJ1bmModmlld3BvcnRCb3VuZGluZ1JlY3QueClcbiAgICAgICAgICAgIC8vIHZpZXdwb3J0Qm91bmRpbmdSZWN0Lnk6XG4gICAgICAgICAgICAvLyB2aWV3cG9ydEJvdW5kaW5nUmVjdC54XG5cbiAgICAvLyB0aGlzIHNlbGVjdGlvbiBpcyByZWR1bmRhbnQsIGJ1dCBkb2N1bWVudHMgd2hhdCdzIGdvaW5nIG9uXG4gICAgY29uc3Qgcm9vdHBvcyA9IFxuICAgICAgICAoaW50ZXJzZWN0cm9vdHBvcyA9PSBib3VuZGluZ3Jvb3Rwb3MpP1xuICAgICAgICBpbnRlcnNlY3Ryb290cG9zOlxuICAgICAgICBib3VuZGluZ3Jvb3Rwb3MgLy8gd2UncmUgaW4gU2FmYXJpLCB6b29tZWRcblxuICAgIGNvbnN0IGVudHJ5cG9zID0gXG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIE1hdGgudHJ1bmMoZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnkpOlxuICAgICAgICAgICAgTWF0aC50cnVuYyhlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3QueClcbiAgICAgICAgICAgIC8vIGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC55OlxuICAgICAgICAgICAgLy8gZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnhcblxuICAgIGNvbnN0IHZpZXdwb3J0VHJpZ2dlck9mZnNldCA9IGVudHJ5cG9zIC0gcm9vdHBvc1xuXG4gICAgaWYgKHJlZmVyZW5jZW5hbWUgPT0gJ2hlYWR0cmlnZ2VyJykge1xuXG4gICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXRcbiAgICAgICAgdHJpZ2dlckRhdGEudGFpbE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldCArIHNwYW5cblxuICAgIH0gZWxzZSB7IC8vIHRhaWx0cmlnZ2VyXG5cbiAgICAgICAgdHJpZ2dlckRhdGEuaGVhZE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldCAtIHNwYW5cbiAgICAgICAgdHJpZ2dlckRhdGEudGFpbE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldFxuXG4gICAgfVxuXG4gICAgbGV0IHNoaWZ0aW5zdHJ1Y3Rpb25cbiAgICBcbiAgICBjb25zdCB0cmlnZ2VySGlzdG9yeSA9IHRyaWdnZXJIaXN0b3J5UmVmLmN1cnJlbnQ7XG5cbiAgICAvLyBzaW5jZSB0cmlnZ2VycyBhcmUgbW92ZWQgYW5kIGNhbiBzaGFyZSB0aGUgMCAoemVybykgb2Zmc2V0LCBhbiBpbmZpbml0ZSBsb29wIGNhbiBvY2N1clxuICAgIC8vIGJldHdlZW4gdGhlIGhlYWQgYW5kIHRhaWwgdHJpZ2dlcnMuIFRoZSBmb2xsb3dpbmcgc2hvcnQtY2lyY3VpdHMgdGhhdC5cbiAgICAvLyBPYnZpb3VzbHkgbmVlZHMgd29yayB0byBnZW5lcmFsaXplLi4uXG4gICAgaWYgKChpc1NhZmFyaUlPUygpICYmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID09IDAgfHwgdHJpZ2dlckRhdGEudGFpbE9mZnNldCA9PSAwKSkgfHxcbiAgICAgICAgKCFpc1NhZmFyaUlPUygpICYmICgoKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPj0gLTEpICYmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0IDw9IDEpKSB8fCBcbiAgICAgICAgKCh0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0ID49IC0xKSAmJiAodHJpZ2dlckRhdGEudGFpbE9mZnNldCA8PSAxKSkpKSkge1xuXG4gICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gYW4gaW5maW5pdGUgbG9vcCB3aXRoIHRoZSBzYW1lIHByZXZpb3VzUmVmZXJlbmNlTmFtZTtcbiAgICAgICAgLy8gdXN1YWxseSBhbHRlcm5hdGVzXG4gICAgICAgIGlmICh0cmlnZ2VySGlzdG9yeS5wcmV2aW91c1JlZmVyZW5jZU5hbWUpIHtcblxuICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lID0gbnVsbFxuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ25vbmUnXG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKCh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IC0xKSAmJiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA8PSAxKSkge1xuXG4gICAgICAgICAgICAvLyBpZiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICB0cmlnZ2VySGlzdG9yeS5wcmV2aW91c1JlZmVyZW5jZU5hbWUgPSAnaGVhZHRyaWdnZXInXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0cmlnZ2VySGlzdG9yeS5wcmV2aW91c1JlZmVyZW5jZU5hbWUgPSAndGFpbHRyaWdnZXInXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICh0cmlnZ2VySGlzdG9yeS5wcmV2aW91c1JlZmVyZW5jZU5hbWUpIHtcblxuICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lID0gbnVsbFxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbikgeyAvLyB3aWxsIGJlICdub25lJ1xuXG4gICAgICAgIHJldHVybiBbc2hpZnRpbnN0cnVjdGlvbiwgMF0vL3RyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvc11cblxuICAgIH1cblxuICAgIGlmIChpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZykge1xuXG4gICAgICAgIGlmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0IDw9IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdtb3ZlYXhpc3RhaWx3YXJkJ1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnbm9uZSdcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICh0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0IDw9IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdtb3ZlYXhpc3RhaWx3YXJkJ1xuXG4gICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA+PSAwKSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnbW92ZWF4aXNoZWFkd2FyZCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ25vbmUnXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3QgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zID0gXG4gICAgICAgIChzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc3RhaWx3YXJkJyk/IC8vIGJsb2NrIGlzIHNjcm9sbGluZyB1cCBvciBsZWZ0XG4gICAgICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0OiAvLyBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdG93YXJkIGhlYWRcbiAgICAgICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgLy8gbmVlZHMgdG8gbW92ZSBkb3duIG9yIHJpZ2h0IHRvd2FyZCB0YWlsXG5cblxuICAgIHJldHVybiBbc2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zXVxuXG59XG5cbi8qXG4gICAgVGhlIGJhc2ljIGdvYWwgb2YgY2FsY0NvbnRlbnRTaG9mdCBpcyB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBhbmQgZGlyZWN0aW9uIG9mIHJvd3MgdG8gc2hpZnQgYmV0d2VlblxuICAgIHRoZSBoZWFkIGFuZCB0YWlsIGdyaWRzICh3aGljaCBkZXRlcm1pbmVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGF4aXMpLCBhbmQgYWxzbyB0b1xuICAgIGNhbGN1bGF0ZSB0aGUgcm9sbGluZyBhZGRpdGlvbiBhbmQgZGVsZXRpb24gb2YgY3JhZGxlIGNvbnRlbnQgdG8gYWNjb21tb2RhdGUgdGhlIGNoYW5nZXMuXG5cbiAgICBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gc2hpZnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGl4ZWwgc2hpZnQgcmVxdWlyZWQgdG8gcmVzdG9yZSB0aGUgXG4gICAgdHJpZ2dlcmxpbmVzIHRvIHRoZWlyIHN0cmFkZGxlIGNvbmZpZ3VyYXRpb24gYXJvdW5kIHRoZSBoZWFkICh0b3Agb3IgbGVmdCkgb2YgdGhlIHZpZXdwb3J0LlxuXG4gICAgQWRqdXN0bWVudHMgYXJlIG1hZGUgdG8gYWNjb21tb2RhdGUgc3BlY2lhbCByZXF1aXJlbWVudHMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHZpcnR1YWwgbGlzdC5cblxuICAgIERPTSBtZWFzdXJlbWVudHMgYXJlIHVzZWQgd2hlcmUgYXZhaWxhYmxlICh0byBhY2NvbW1vZGF0ZSB2YXJpYWJsZSBkaW1lbnNpb24gcm93cyksIGFuZCBzdGFuZGFyZFxuICAgIHVuaXRzIChjZWxsSGVpZ2h0LCBjZWxsV2lkdGgpIHVzZWQgZm9yIGVzdGltYXRlcyB3aGVyZSBuZWNlc3NhcnkuXG4qL1xuXG4vLyByb3dzaGlmdCBpcyBhdCBsZWFzdCAxIGJ5IHRoZSB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgcmVhY2hlZFxuLy8gaWUuIGEgc2hpZnRpbnN0cnVjdGlvbiBvZiAnbW92ZWF4aXNoZWFkd2FyZCcgb3IgJ21vdmVheGlzdGFpbHdhcmQnXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU2hpZnRTcGVjcyA9ICh7XG5cbiAgICAvLyBkaXJlY3Rpb24gb2YgY2hhbmdlXG4gICAgc2hpZnRpbnN0cnVjdGlvbixcbiAgICB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MsXG5cbiAgICAvLyBwb3NpdGlvbmFsXG4gICAgc2Nyb2xsUG9zLFxuICAgIHNjcm9sbGJsb2NrRWxlbWVudCxcblxuICAgIC8vIHByb3BlcnR5IHJlcG9zXG4gICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG5cbiAgICAvLyBjcmFkbGUgcmVwb3NcbiAgICBjcmFkbGVDb250ZW50LFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBjb25maWd1cmF0aW9uIGRhdGFcbiAgICBjb25zdCB7IFxuXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIC8vIGNyYWRsZSBlbGVtZW50c1xuICAgIGNvbnN0IGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50LFxuICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudFxuXG4gICAgLy8gY3JhZGxlIGNvbnRlbnRzXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czpjcmFkbGVjb250ZW50bGlzdCwgXG4gICAgICAgIHRhaWxNb2RlbENvbXBvbmVudHM6dGFpbGNvbnRlbnRsaXN0LFxuICAgICAgICAvLyBoZWFkTW9kZWxDb21wb25lbnRzOmhlYWRjb250ZW50bGlzdFxuXG4gICAgfSA9IGNyYWRsZUNvbnRlbnRcblxuICAgIC8vIG1vcmUgY29uZmlnIGRhdGFcbiAgICBjb25zdCB7IFxuXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgbGlzdFJvd2NvdW50LFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcblxuICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAoY3JhZGxlY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0NyYWRsZVJvd09mZnNldCA9IE1hdGguY2VpbChwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCA9ICh0YWlsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IGxpc3RFbmRyb3dPZmZzZXQgPSAobGlzdFJvd2NvdW50IC0gMSlcbiAgICBjb25zdCBiYXNlUm93TGVuZ3RoID1cbiAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICBjZWxsV2lkdGgpIFxuICAgICAgICArIGdhcFxuXG4gICAgbGV0IHNwYW5Sb3dQdHIsXG4gICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IDAsIC8vIGluIHJlbGF0aW9uIHRvIHZpZXdwb3J0IGhlYWQgYm91bmRhcnlcbiAgICAgaW5Qcm9jZXNzUm93UHRyID0gMCxcbiAgICAgaXNMaXN0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICAgdG90YWxQaXhlbFNoaWZ0LFxuICAgICBmaW5hbFZhcmlhYmxlUm93TGVuZ3RoIC8vIHNwZWNpYWwgY2FzZVxuXG4gICAgLy8gbWVhc3VyZSBleGlzaW5nIHJvd3MgZm9yIHZhcmlhYmxlIGxlbmd0aCBjZWxsc1xuICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgeyBcblxuICAgICAgICBjb25zdCByZWZlcmVuY2VHcmlkRWxlbWVudCA9IC8vIG1vdmluZyBheGlzIChhbmQgdHJpZ2dlcnMpIHRvd2FyZCB0aGUgcmVmZXJlbmNlIGdyaWQgZWxlbWVudFxuICAgICAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzdGFpbHdhcmQnKT8gLy8gc2Nyb2xsaW5nIHVwIG9yIGxlZnRcbiAgICAgICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQ6XG4gICAgICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50XG5cbiAgICAgICAgY29uc3QgZ3JpZFJvd0xlbmd0aHMgPSBnZXRHcmlkUm93TGVuZ3RocyhyZWZlcmVuY2VHcmlkRWxlbWVudCwgb3JpZW50YXRpb24sIGNyb3NzY291bnQsIGdhcClcblxuICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXNoZWFkd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIGRvd24gb3IgcmlnaHQ7IG1vdmUgdHJpZ2dlcmxpbmVzIHVwIG9yIGxlZnRcblxuICAgICAgICAgICAgZ3JpZFJvd0xlbmd0aHMucmV2ZXJzZSgpIC8vIGhlYWQgZ3JpZCByb3cgbGVuZ3RocyBsaXN0ZWQgZnJvbSBheGlzIHRvd2FyZCBoZWFkXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyaWRSb3dBZ2dyZWdhdGVTcGFucyA9IGdldEdyaWRSb3dBZ2dyZWdhdGVTcGFucyhncmlkUm93TGVuZ3RocykgLy8gY291bnQgcGl4ZWxzIHdoZXJlIGF2YWlsYWJsZVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGNhbGN1bGF0ZSBiYXNlIHJvdyBzaGlmdCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBmaXJzdCB0cnkgdG8gZmluZCBwb3NpdGlvbiBiYXNlZCBvbiBrbm93biAoaW5zdGFudGlhdGVkKSByb3dzXG4gICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGwgdXBcblxuICAgICAgICAgICAgLy8gdGFpbCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBwb3NpdGl2ZVxuICAgICAgICAgICAgc3BhblJvd1B0ciA9IGdyaWRSb3dBZ2dyZWdhdGVTcGFucy5maW5kSW5kZXgoKGFnZ3JlZ2F0ZXNwYW4pID0+IFxuICAgICAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgKyBhZ2dyZWdhdGVzcGFuKSA+PSAwIClcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7IC8vICdtb3ZlYXhpc2hlYWR3YXJkJywgc2Nyb2xsZG93blxuXG4gICAgICAgICAgICAvLyBoZWFkIHRyaWdnZXIgbmVlZHMgdG8gbW92ZSB1cCBvciBsZWZ0IHVudGlsIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcCBvciBsZWZ0IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgICBzcGFuUm93UHRyID0gZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zLmZpbmRJbmRleCgoYWdncmVnYXRlc3BhbikgPT4gXG4gICAgICAgICAgICAgICAgKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyAtIGFnZ3JlZ2F0ZXNwYW4pIDw9IDApXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHNwYW5Sb3dQdHIgPT0gLTEpKSB7IC8vIGZvdW5kIG1lYXN1cmVlZCByb3cgZm9yIHNoaWZ0XG4gICAgICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSBcbiAgICAgICAgICAgICAgICAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgICAgICAgICBncmlkUm93QWdncmVnYXRlU3BhbnNbc3BhblJvd1B0cl06IC8vIG1vdmUgYXhpcyB0b3dhcmQgdGFpbCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5IChwb3NpdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgLWdyaWRSb3dBZ2dyZWdhdGVTcGFuc1tzcGFuUm93UHRyXSAvLyBtb3ZlIGF4aXMgdG93YXJkIGhlYWQgZnJvbSB2aWV3cG9ydCBib3VuZGFyeSAobmVnYXRpdmUpXG4gICAgICAgIH0gZWxzZSB7IC8vIGVpdGhlciBpbiBib3VuZGFyeSwgb3Igc2h5IG9mIHRhcmdldFxuXG4gICAgICAgICAgICBpc0xpc3RCb3VuZGFyeSA9IChncmlkUm93QWdncmVnYXRlU3BhbnMubGVuZ3RoID09IDApIC8vIGJvdW5kYXJ5IGF0IGhlYWQgb2YgbGlzdFxuXG4gICAgICAgICAgICBpZiAoIWlzTGlzdEJvdW5kYXJ5KSB7IC8vIGludGVyaW0gd29ya2luZyByZXN1bHRcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc1Jvd1B0ciA9IGdyaWRSb3dBZ2dyZWdhdGVTcGFucy5sZW5ndGggLSAxIC8vIGJhc2U6IGZhaWxlZCBtZWFzdXJlZCByb3cgcHRyXG4gICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ID0gZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zW2luUHJvY2Vzc1Jvd1B0cl0gLy8gc2V0IGJhc2Ugb2Ygd29ya2luZyBvdmVyc2hvb3RcbiAgICAgICAgICAgICAgICBmaW5hbFZhcmlhYmxlUm93TGVuZ3RoID0gZ3JpZFJvd0xlbmd0aHMuYXQoLTEpIC8vIGZvciBvdmVyc2l6ZSBjZWxsIGFkanVzdG1lbnQgYmVsb3dcblxuICAgICAgICAgICAgfSBcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBsYXlvdXQgPT0gJ3VuaWZvcm0nOyB1c2Ugb25seSBkZWZpbmVkIGxlbmd0aHNcblxuICAgICAgICBzcGFuUm93UHRyID0gLTEgLy8gXCJub3QgZm91bmRcIiwgaWUgbm90IGFwcGxpY2FibGVcblxuICAgICAgICBpblByb2Nlc3NSb3dQdHIgPSAwXG4gICAgICAgIHRvdGFsUGl4ZWxTaGlmdCA9IDBcblxuICAgIH1cblxuICAgIC8vIHVuaWZvcm0gbGF5b3V0LCBvciBvdmVyc2hvb3Qgb2YgaW5zdGFudGlhdGVkIHJvd3M7IGNvbnRpbnVlIHdpdGggdmlydHVhbCBiYXNlIHJvd3NcbiAgICBpZiAoc3BhblJvd1B0ciA9PSAtMSApIHsgXG5cbiAgICAgICAgaWYgKCFpc0xpc3RCb3VuZGFyeSkge1xuXG4gICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIHVwL2xlZnRcblxuICAgICAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgICAgICB0b3RhbFBpeGVsU2hpZnQgKz0gYmFzZVJvd0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyArIHRvdGFsUGl4ZWxTaGlmdCkgPCAwKSBcblxuICAgICAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IHRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtb3ZlYXhpc2hlYWR3YXJkOyBzY3JvbGxpbmcgZG93bi9yaWdodFxuXG4gICAgICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCArPSBiYXNlUm93TGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc1Jvd1B0cisrXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aW91c0F4aXNSb3dPZmZzZXQgLSBpblByb2Nlc3NSb3dQdHIpID09IDApIHsgLy8gc3RvcCBjeWNsaW5nIGF0IGhlYWQgbGltaXRcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyAtIHRvdGFsUGl4ZWxTaGlmdCkgPiAwKVxuXG4gICAgICAgICAgICAgICAgc3BhbkF4aXNQaXhlbFNoaWZ0ID0gLXRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluUHJvY2Vzc1Jvd1B0ciBpcyBvbmUgZ3JlYXRlciB0aGFuIHNwYW5Sb3dQdHIgd2l0aCBhY3R1YWwgbWVhc3VyZW1lbnRzIGFib3ZlXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlbSBjb21wYXRpdmxlIGZvciBzcGFuIGNvbnZlcnNpb24gKG5leHQgc3RlcClcbiAgICAgICAgc3BhblJvd1B0ciA9IGluUHJvY2Vzc1Jvd1B0ciAtIDEgXG5cbiAgICB9XG5cbiAgICBjb25zdCBzcGFuUm93U2hpZnQgPSAvLyBwaWNrIHVwIHJvdyBzaGlmdCB3aXRoIG9yIHdpdGhvdXQgb3ZlcnNob290XG4gICAgICAgIChzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc3RhaWx3YXJkJyk/XG4gICAgICAgICAgICBzcGFuUm93UHRyICsgMTpcbiAgICAgICAgICAgIC0oc3BhblJvd1B0ciArIDEpXG5cbiAgICAvLyB0aGUgZm9sbG93aW5nIHR3byB2YWx1ZXMgKGF4aXNSZWZlcmVuY2VSb3dTaGlmdCAmIGF4aXNQaXhlbFNoaWZ0KSwgYW5kIG5vIG90aGVyIGNhbGNzLCBcbiAgICAvLyAgICAgYXJlIGNhcnJpZWQgZm9yd2FyZCBpbiB0aGlzIGZ1bmN0aW9uLlxuICAgIC8vIGZvciBheGlzUmVmZXJlbmNlUm93c2hpZnQ6XG4gICAgLy8gbmVnYXRpdmUgZm9yIG1vdmluZyByb3dzIG91dCBvZiBoZWFkIGludG8gdGFpbDtcbiAgICAvLyBwb3NpdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIHRhaWwgaW50byBoZWFkXG4gICAgbGV0IGF4aXNSZWZlcmVuY2VSb3dTaGlmdCA9IHNwYW5Sb3dTaGlmdCxcbiAgICAgICAgYXhpc1BpeGVsU2hpZnQgPSBzcGFuQXhpc1BpeGVsU2hpZnQgXG5cbiAgICAvLyB0aGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoIG92ZXJzaXplZCBjZWxsTGVuZ3RoIChpZSA+IHZpZXdwb3J0TGVuZ3RoKVxuICAgIC8vICAgICBhbmQgb25seSB1c2luZyBtZWFzdXJlZCBsZW5ndGhcbiAgICAvLyBheGlzIG11c3QgYmUgbm8gZmFydGhlciB0aGFuIDEgYmFjayBvZiB0aGUgbGFzdCByb3cgZW5kIHBvc2l0aW9uXG4gICAgaWYgKChwcmV2aW91c0F4aXNSb3dPZmZzZXQgKyBheGlzUmVmZXJlbmNlUm93U2hpZnQpID4gbGlzdEVuZHJvd09mZnNldCkge1xuXG4gICAgICAgIGF4aXNSZWZlcmVuY2VSb3dTaGlmdCAtPSAxXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgYXhpc1BpeGVsU2hpZnQgLT0gZmluYWxWYXJpYWJsZVJvd0xlbmd0aCAvL2dyaWRSb3dMZW5ndGhzLmF0KC0xKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpc1BpeGVsU2hpZnQgLT0gYmFzZVJvd0xlbmd0aFxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLVsgMy4gY2FsY3VsYXRlIGN1cnJlbnQgdmlld3BvcnQgYXhpcyBvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnYXBzIGJleW9uZCByZW5kZXJlZCByb3dzIGNhbiBiZSBjYXVzZWQgYnkgcmFwaWQgc2Nyb2xsaW5nXG5cbiAgICBjb25zdCBzY3JvbGxibG9ja0F4aXNPZmZzZXQgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tPZmZzZXQgPSAvLyB0byBjYXB0dXJlIGN1cnJlbnQgdG9wL2xlZnQgYWRqdXN0bWVudCB0byB2aWV3cG9ydCBmb3IgdmFyaWFibGUgbGF5b3V0XG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgLy8gY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCB3aWxsIGJlIG5lZ2F0aXZlIChhYm92ZSB2aWV3cG9ydCBlZGdlKSBmb3Igc2Nyb2xsIGJsb2NrIGhlYWR3YXJkIFxuICAgIC8vICAgICBhbmQgcG9zaXRpdmUgZm9yIHNjcm9sbCBibG9jayB0YWlsd2FyZFxuICAgIC8vIHRoZSBwaXhlbCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB2aWV3cG9ydCBmcmFtZSBhbmQgdGhlIGF4aXMsIHRvd2FyZCB0aGUgaGVhZFxuICAgIGNvbnN0IGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgPSBcbiAgICAgICAgc2Nyb2xsYmxvY2tBeGlzT2Zmc2V0ICsgc2Nyb2xsYmxvY2tPZmZzZXQgLSBzY3JvbGxQb3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS1bIDQuIGNhbGN1bGF0ZSBuZXcgYXhpcyBwaXhlbCBwb3NpdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0ICsgYXhpc1BpeGVsU2hpZnRcblxuICAgIC8vIE5vdGU6IHNlY3Rpb25zIDUsIDYgYW5kIDcgZGVhbCBlbnRpcmVseSB3aXRoIHJvdyBjYWxjdWxhdGlvbnM7IG5vIHBpeGVsc1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tWyA1LiBjYWxjIG5ldyBjcmFkbGUgYW5kIGF4aXMgcmVmZXJlbmNlIHJvdyBvZmZzZXRzIF0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBiYXNlIHZhbHVlIGZvciBjcmFkbGUgcmVmZXJlbmNlIHNoaWZ0OyBtYXkgY2hhbmdlIGlmIGJleW9uZCBsaXN0IGJvdW5kc1xuICAgIGxldCBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCA9IGF4aXNSZWZlcmVuY2VSb3dTaGlmdFxuXG4gICAgLy8gYmFzZSB2YWx1ZXNcbiAgICBsZXQgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ID0gcHJldmlvdXNDcmFkbGVSb3dPZmZzZXQgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdFxuICAgIGNvbnN0IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgPSBwcmV2aW91c0F4aXNSb3dPZmZzZXQgKyBheGlzUmVmZXJlbmNlUm93U2hpZnRcblxuICAgIC8vIC0tLS0tLS0tWyA2LiBhZGp1c3QgY3JhZGxlIGNvbnRlbnRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGxpc3QgXS0tLS0tLS1cbiAgICAvLyAuLi50byBtYWludGFpbiBjb25zdGFudCBudW1iZXIgb2YgY3JhZGxlIHJvd3NcblxuICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGxpbmcgdXAvbGVmdFxuXG4gICAgICAgIC8vIGEuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgaGVhZHdhcmQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIG5ldyBjcmFkbGUgcm93IG9mZnNldCBhbmRcbiAgICAgICAgLy8gY3JhZGxlIHJvdyBzaGlmdCBjb3VudCBoYXMgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxlYWRpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gYi4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayBoZWFkd2FyZCAocmV2ZWFsaW5nIHRhaWwgb2YgbGlzdCksIGFzIHRoZSBjcmFkbGUgbGFzdCByb3cgb2Zmc2V0IFxuICAgICAgICAvLyBhcHByb2FjaGVzIG1heCBsaXN0cm93LCBuZXcgY3JhZGxlIG9mZnNldCBhbmQgY3JhZGxlIHJvdyBzaGlmdCBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgXG4gICAgICAgIC8vIHNob3J0ZW5pbmcgb2YgY3JhZGxlIGNvbnRlbnQuXG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQgLSAxKSkgLy8gZXh0cmEgcm93IGZvciB2aXNpYmlsaXR5XG5cbiAgICAgICAgY29uc3QgaGVhZHJvd0RpZmYgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgaWYgKGhlYWRyb3dEaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gaGVhZHJvd0RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IGhlYWRyb3dEaWZmXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OiBjYXNlIG9mIGJlaW5nIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXkgKGVuZCBvZiBsaXN0KVxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0IC0gbGlzdEVuZHJvd09mZnNldClcblxuICAgICAgICBpZiAodGFpbHJvd2RpZmYgPiAwKSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc2hlYWR3YXJkJzsgc2Nyb2xsaW5nIGRvd24vcmlnaHRcblxuICAgICAgICAvLyBjLiBpZiBzY3JvbGxpbmcgdGhlIGJsb2NrIGRvd24gb3IgcmlnaHQgKHRvd2FyZCByZXZlYWxpbmcgaGVhZCBvZiBsaXN0KSwgYXMgdGhlIGNyYWRsZXJvd29mZnNldCBcbiAgICAgICAgLy8gaGl0cyAwLCBjcmFkbGUgY2hhbmdlcyBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgc2hvcnRlbmluZyBvZiBjcmFkbGUgY29udGVudFxuXG4gICAgICAgIC8vIGQuIGlmIHNjcm9sbGluZyBoZWFkd2FyZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGxpc3QsIGNyYWRsZSBjaGFuZ2VzIGhhdmUgdG8gYmUgYWRqdXN0ZWQgdG8gXG4gICAgICAgIC8vIGFjY29tb2RhdGUgdGhlIHRyYWlsaW5nIHJ1bndheVxuXG4gICAgICAgIC8vIC0tLSBzdGFydCBvZiBsaXN0IGFkanVzdG1lbnRcbiAgICAgICAgaWYgKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA8IDApIHtcblxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQgLT0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0XG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSAwXG5cbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScgJiYgbmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IHBhZGRpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OyBjYXNlIG9mIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXlcbiAgICAgICAgY29uc3QgY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gXG4gICAgICAgICAgICAocHJldmlvdXNDcmFkbGVSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLTEpICsgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQpXG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gTWF0aC5taW4obGlzdEVuZHJvd09mZnNldCwgXG4gICAgICAgICAgICAobmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCArICh2aWV3cG9ydFJvd2NvdW50IC0gMSkgKyAocnVud2F5Um93Y291bnQgLSAxKSkpXG5cbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgLSBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCArPSB0YWlscm93ZGlmZlxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICs9IHRhaWxyb3dkaWZmXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNy4gbWFwIHJvd3MgdG8gaXRlbSByZWZlcmVuY2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50KVxuICAgIGNvbnN0IGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCA9IChjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAqIGNyb3NzY291bnQpXG5cbiAgICBjb25zdCBuZXdBeGlzUmVmZXJlbmNlSW5kZXggPSBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIGNvbnN0IGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQgPSBheGlzUmVmZXJlbmNlUm93U2hpZnQgKiBjcm9zc2NvdW50XG5cbiAgICBsZXQgbmV3Q3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50IC8vIGJhc2UgY291bnRcbiAgICBjb25zdCBpbmNsdWRlc0xhc3RSb3cgPSAoKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCArIGNyYWRsZVJvd2NvdW50KSA+PSBsaXN0Um93Y291bnQpXG5cbiAgICBpZiAoaW5jbHVkZXNMYXN0Um93KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxzcGFjZXMgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgY29uc3QgaXRlbXNTaG9ydGZhbGwgPSBcbiAgICAgICAgICAgIChwYXJ0aWFsc3BhY2VzID09IDApP1xuICAgICAgICAgICAgICAgIDA6XG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCAtIHBhcnRpYWxzcGFjZXNcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IGl0ZW1zU2hvcnRmYWxsXG4gICAgfVxuICAgIC8vIGNyZWF0ZSBoZWFkIGFuZCB0YWlsIGNoYW5nZSBjb3VudHNcbiAgICBjb25zdCBjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudCA9IGNyYWRsZWNvbnRlbnRsaXN0Lmxlbmd0aCAtIG5ld0NyYWRsZUNvbnRlbnRDb3VudFxuXG4gICAgY29uc3QgbGlzdFN0YXJ0Q2hhbmdlQ291bnQgPSAtKGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdClcbiAgICBjb25zdCBsaXN0RW5kQ2hhbmdlQ291bnQgPSAtbGlzdFN0YXJ0Q2hhbmdlQ291bnQgLSBjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA4LiByZXR1cm4gcmVxdWlyZWQgdmFsdWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIC8vIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0LCBcbiAgICAgICAgbmV3QXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCwgXG5cbiAgICAgICAgbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50XG4gICAgfVxuXG59XG5cbi8vIHN1cHBvcnRzIGNhbGNDb250ZW50U2hpZnQgYWJvdmVcbmNvbnN0IGdldEdyaWRSb3dMZW5ndGhzID0gKGdyaWQsIG9yaWVudGF0aW9uLCBjcm9zc2NvdW50LCBnYXApID0+IHtcblxuICAgIGNvbnN0IHJvd0xlbmd0aHMgPSBbXVxuICAgIGNvbnN0IGVsZW1lbnRMaXN0ID0gZ3JpZC5jaGlsZE5vZGVzXG5cbiAgICBsZXQgZWxlbWVudFB0ciA9IDBcbiAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRMaXN0W2VsZW1lbnRQdHJdXG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCByb3dsZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRXaWR0aCkgXG4gICAgICAgICAgICArIGdhcFxuICAgICAgICByb3dMZW5ndGhzLnB1c2gocm93bGVuZ3RoKVxuICAgICAgICBlbGVtZW50UHRyICs9IGNyb3NzY291bnRcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRMaXN0W2VsZW1lbnRQdHJdXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd0xlbmd0aHNcbn1cblxuLy8gc3VwcG9ydHMgY2FsY0NvbnRlbnRTaGlmdCBhYm92ZVxuY29uc3QgZ2V0R3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zID0gKHJvd0xlbmd0aHMpID0+IHtcblxuICAgIGNvbnN0IHJvd1NwYW5zID0gW11cbiAgICBsZXQgc3BhbiA9IDBcbiAgICByb3dMZW5ndGhzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHNwYW4gKz0gdmFsdWVcbiAgICAgICAgcm93U3BhbnMucHVzaChzcGFuKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcm93U3BhbnNcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBzaGFyZWQgYnkgYm90aCBzZXRDcmFkbGVDb250ZW50IGFuZCB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB1cGRhdGUgY29udGVudFxuLy8gYWRkcyBDZWxsRnJhbWVzIGF0IGVuZCBvZiBjb250ZW50bGlzdCBhY2NvcmRpbmcgdG8gaGVhZGluZGV4Y291bnQgYW5kIHRhaWxpbmRleGNvdW50LFxuLy8gb3IgaWYgaW5kZXhjb3VudCB2YWx1ZXMgYXJlIDwwIHJlbW92ZXMgdGhlbS5cbmV4cG9ydCBjb25zdCBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0ID0gKHsgXG5cbiAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCwgXG4gICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCwgXG4gICAgICAgIHdvcmtpbmdDb250ZW50TGlzdDpjb250ZW50bGlzdCxcbiAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICB9KSA9PiB7XG5cbiAgICBjb25zdCBsb2NhbENvbnRlbnRsaXN0ID0gWy4uLmNvbnRlbnRsaXN0XVxuICAgIGNvbnN0IGxhc3RpbmRleG9mZnNldCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4ICsgbG9jYWxDb250ZW50bGlzdC5sZW5ndGggLSAxXG5cbiAgICBjb25zdCBoZWFkQ29udGVudGxpc3QgPSBbXSwgdGFpbENvbnRlbnRsaXN0ID0gW11cblxuICAgIGxldCBkZWxldGVkdGFpbGl0ZW1zID0gW10sIGRlbGV0ZWRoZWFkaXRlbXMgPSBbXVxuXG4gICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50ID49IDApIHsgLy8gYWNxdWlyZSBuZXcgaXRlbXNcbiAgICAgICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgbGV0IGNoYW5nZUNvdW50ID0gbGlzdFN0YXJ0Q2hhbmdlQ291bnRcbiAgICAgICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50ID4gY3JhZGxlQ29udGVudENvdW50KSB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGNyYWRsZVJlZmVyZW5jZUluZGV4IC0gKGxpc3RTdGFydENoYW5nZUNvdW50IC0gY3JhZGxlQ29udGVudENvdW50KVxuICAgICAgICAgICAgY2hhbmdlQ291bnQgPSBjcmFkbGVDb250ZW50Q291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gcmVmZXJlbmNlSW5kZXggLSBjaGFuZ2VDb3VudDsgbmV3aW5kZXggPCByZWZlcmVuY2VJbmRleDsgbmV3aW5kZXgrKykge1xuXG4gICAgICAgICAgICBoZWFkQ29udGVudGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVDZWxsRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Om5ld2luZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmxpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmVycm9yZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZXJyb3JsaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkaGVhZGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UoIDAsIC1saXN0U3RhcnRDaGFuZ2VDb3VudCApXG5cbiAgICB9XG5cbiAgICBpZiAobGlzdEVuZENoYW5nZUNvdW50ID49IDApIHsgLy8gYWNxdWlyZSBuZXcgaXRlbXNcblxuICAgICAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBsYXN0aW5kZXhvZmZzZXRcbiAgICAgICAgbGV0IGNoYW5nZUNvdW50ID0gbGlzdEVuZENoYW5nZUNvdW50XG4gICAgICAgIGlmIChsaXN0RW5kQ2hhbmdlQ291bnQgPiBjcmFkbGVDb250ZW50Q291bnQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4ID0gbGFzdGluZGV4b2Zmc2V0ICsgKGxpc3RFbmRDaGFuZ2VDb3VudCAtIGNyYWRsZUNvbnRlbnRDb3VudClcbiAgICAgICAgICAgIGNoYW5nZUNvdW50ID0gY3JhZGxlQ29udGVudENvdW50XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmV3aW5kZXggPSByZWZlcmVuY2VJbmRleCArIDE7IG5ld2luZGV4IDwgKHJlZmVyZW5jZUluZGV4ICsgMSArIGNoYW5nZUNvdW50KTsgbmV3aW5kZXgrKykge1xuXG4gICAgICAgICAgICB0YWlsQ29udGVudGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVDZWxsRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Om5ld2luZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmxpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmVycm9yZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZXJyb3JsaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkdGFpbGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UobGlzdEVuZENoYW5nZUNvdW50LC1saXN0RW5kQ2hhbmdlQ291bnQpXG5cbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkSXRlbXMgPSBbLi4uZGVsZXRlZGhlYWRpdGVtcywuLi5kZWxldGVkdGFpbGl0ZW1zXVxuXG4gICAgY29uc3QgY29tcG9uZW50TGlzdCA9IFsuLi5oZWFkQ29udGVudGxpc3QsLi4ubG9jYWxDb250ZW50bGlzdCwuLi50YWlsQ29udGVudGxpc3RdXG5cbiAgICByZXR1cm4gW2NvbXBvbmVudExpc3QsZGVsZXRlZEl0ZW1zXVxuXG59XG5cbi8vIExlYWRpbmcgKGhlYWQpIGFsbCBvciBwYXJ0aWFsbHkgaGlkZGVuOyB0YWlsLCB2aXNpYmxlIHBsdXMgdHJhaWxpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZmlyc3QgdGFpbCBpdGVtXG4gICAgICAgIGxheW91dEhhbmRsZXIsXG5cbiAgICB9XG4pID0+IHtcblxuICAgIGNvbnN0IHsgdHJpZ2dlcmNlbGxJbmRleCB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgY29uc3Qgb2Zmc2V0aW5kZXggPSBjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXgsXG4gICAgICAgIGhpZ2hpbmRleCA9IG9mZnNldGluZGV4ICsgY29udGVudGxpc3QubGVuZ3RoXG5cbiAgICBjb25zdCBoZWFkaXRlbWNvdW50ID0gKGF4aXNSZWZlcmVuY2VJbmRleCAtIG9mZnNldGluZGV4KVxuXG4gICAgY29uc3QgdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCA9IFxuICAgICAgICAoaGVhZGl0ZW1jb3VudCA9PSAwKT9cbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDpcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCAtIDFcblxuICAgIGxheW91dEhhbmRsZXIudHJpZ2dlcmNlbGxJc0luVGFpbCA9IFxuICAgICAgICAoaGVhZGl0ZW1jb3VudCA9PSAwKT9cbiAgICAgICAgICAgIHRydWU6XG4gICAgICAgICAgICBmYWxzZVxuXG4gICAgaWYgKCh0cmlnZ2VyY2VsbEluZGV4ICE9PSB1bmRlZmluZWQpICYmIChvZmZzZXRpbmRleCAhPT0gdW5kZWZpbmVkKSkgeyAvLyYmIFxuICAgICAgICBpZiAoKHRyaWdnZXJjZWxsSW5kZXggPj0gb2Zmc2V0aW5kZXgpICYmICh0cmlnZ2VyY2VsbEluZGV4IDw9IGhpZ2hpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsUHRyID0gdHJpZ2dlcmNlbGxJbmRleCAtIG9mZnNldGluZGV4XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbENvbXBvbmVudCA9IGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJjZWxsQ29tcG9uZW50KSB7IC8vIG90aGVyd2lzZSBoYXMgYmVlbiBhc3luY2hyb25vdXNseSBjbGVhcmVkXG4gICAgICAgICAgICAgICAgY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXJjZWxsQ29tcG9uZW50LCB7aXNUcmlnZ2VyY2VsbDpmYWxzZX0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cmlnZ2VyY2VsbFB0ciA9IHRhcmdldFRyaWdnZXJjZWxsSW5kZXggLSBvZmZzZXRpbmRleFxuICAgIGNvbnN0IHRyaWdnZXJjZWxsQ29tcG9uZW50ID0gY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdXG4gICAgaWYgKHRyaWdnZXJjZWxsQ29tcG9uZW50KSB7XG5cbiAgICAgICAgY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXJjZWxsQ29tcG9uZW50LCB7aXNUcmlnZ2VyY2VsbDp0cnVlfSlcbiAgICAgICAgbGF5b3V0SGFuZGxlci50cmlnZ2VyY2VsbEluZGV4ID0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleFxuXG4gICAgfSBlbHNlIHsgLy8gZGVmZW5zaXZlOyBzaG91bGRuJ3QgaGFwcGVuXG5cbiAgICAgICAgY29uc29sZS5sb2coJ0ZBSUxVUkUgVE8gUkVHSVNURVIgVFJJR0dFUkNFTEw6JylcbiAgICAgICAgY29uc29sZS5sb2coJ2F4aXNSZWZlcmVuY2VJbmRleCwgdHJpZ2dlcmNlbGxJbmRleCwgb2Zmc2V0aW5kZXgsIGhpZ2hpbmRleCwgaGVhZGl0ZW1jb3VudCwgdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCcsXG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIHRyaWdnZXJjZWxsSW5kZXgsIG9mZnNldGluZGV4LCBoaWdoaW5kZXgsIGhlYWRpdGVtY291bnQsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXgpXG4gICAgICAgIGNvbnNvbGUubG9nKCd0cmlnZ2VyY2VsbFB0ciwgdHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGwsIGNvbnRlbnRsaXN0XFxuJywgXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFB0ciwgdHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGwsIFxuICAgICAgICAgICAgICAgIHsuLi5jb250ZW50bGlzdH0pXG5cbiAgICB9XG5cbiAgICBjb25zdCBoZWFkbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKDAsaGVhZGl0ZW1jb3VudClcbiAgICBjb25zdCB0YWlsbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKGhlYWRpdGVtY291bnQpXG5cbiAgICByZXR1cm4gWyBoZWFkbGlzdCwgdGFpbGxpc3QgXVxuXG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVQb3J0YWxzID0gKGNhY2hlSGFuZGxlciwgZGVsZXRlTGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG5cbiAgICBjb25zdCBkbGlzdCA9IGRlbGV0ZUxpc3QubWFwKChpdGVtKT0+e1xuXG4gICAgICAgIHJldHVybiBpdGVtLnByb3BzLmluZGV4XG4gICAgICAgIFxuICAgIH0pXG5cbiAgICBjYWNoZUhhbmRsZXIuZGVsZXRlUG9ydGFsKGRsaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PVsgaW50ZXJuYWwsIGFjcXVpcmUgaXRlbSBdPT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBjcmVhdGVDZWxsRnJhbWUgPSAoe1xuICAgIGluZGV4LCBcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICBjYWNoZUhhbmRsZXIsXG4gICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbn0pID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZUlEID0gaW5zdGFuY2VJZENvdW50ZXJSZWYuY3VycmVudCsrXG5cbiAgICBjb25zdCB7IFxuICAgICAgICBcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnZXRJdGVtLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgbGF5b3V0LCBcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIsXG5cbiAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAvLyBnZXQgbmV3IG9yIGV4aXN0aW5nIGl0ZW1JRFxuICAgIGNvbnN0IGl0ZW1JRCA9IGNhY2hlSGFuZGxlci5nZXROZXdPckV4aXN0aW5nSXRlbUlEKGluZGV4KVxuXG4gICAgcmV0dXJuIDxDZWxsRnJhbWUgXG4gICAgICAgIGtleSA9IHsgaW5zdGFuY2VJRCB9IFxuICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfVxuICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsV2lkdGggfVxuICAgICAgICBjZWxsTWluSGVpZ2h0ID0geyBjZWxsTWluSGVpZ2h0IH1cbiAgICAgICAgY2VsbE1pbldpZHRoID0geyBjZWxsTWluV2lkdGggfVxuICAgICAgICBsYXlvdXQgPSB7IGxheW91dCB9XG4gICAgICAgIGluZGV4ID0geyBpbmRleCB9XG4gICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICBpdGVtSUQgPSB7IGl0ZW1JRCB9XG4gICAgICAgIGluc3RhbmNlSUQgPSB7IGluc3RhbmNlSUQgfVxuICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgaXNUcmlnZ2VyY2VsbCA9IHsgZmFsc2UgfVxuICAgICAgICB1c2VQbGFjZWhvbGRlciA9IHsgdXNlUGxhY2Vob2xkZXIgfVxuICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckZyYW1lU3R5bGVzIH1cbiAgICAgICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyA9IHsgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyB9XG4gICAgICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyA9IHsgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzIH1cbiAgICAgICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMgfVxuICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzID0geyBwbGFjZWhvbGRlck1lc3NhZ2VzIH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwibGVuIiwibGVuZ3RoIiwiaSIsImFycjIiLCJyZWFjdF8xIiwiX19pbXBvcnREZWZhdWx0IiwicmVxdWlyZSIsIkNlbGxGcmFtZV8xIiwiSW5maW5pdGVHcmlkU2Nyb2xsZXJfMSIsImNhbGN1bGF0ZUNvbnRlbnRMaXN0UmVxdWlyZW1lbnRzIiwiX3JlZiIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsImJhc2VSb3dMZW5ndGgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJwYWRkaW5nIiwiY3Jvc3Njb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJsaXN0Um93Y291bnQiLCJsaXN0c2l6ZSIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRBeGlzUm93T2Zmc2V0IiwiY2VpbCIsIm1heEF4aXNSb3dPZmZzZXQiLCJtYXgiLCJ0YXJnZXRDcmFkbGVSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQiLCJsaXN0RW5kUm93T2Zmc2V0IiwiZGlmZiIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwibmV3Q3JhZGxlQ29udGVudENvdW50IiwiZW5kUm93UmVtYWluZGVyQ291bnQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJleHBvcnRzIiwiY2FsY3VsYXRlU2hpZnRJbnN0cnVjdGlvbiIsIl9yZWYyIiwib3JpZW50YXRpb24iLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJ0cmlnZ2VybGluZVNwYW4iLCJzY3JvbGxlcklEIiwiaXNGaXJzdFJvd1RyaWdnZXJDb25maWciLCJ2aWV3cG9ydEJvdW5kaW5nUmVjdCIsInRyaWdnZXJIaXN0b3J5UmVmIiwidHJpZ2dlckRhdGEiLCJoZWFkT2Zmc2V0IiwidGFpbE9mZnNldCIsInNwYW4iLCJlbnRyeSIsInJlZmVyZW5jZW5hbWUiLCJ0YXJnZXQiLCJkYXRhc2V0IiwidHlwZSIsImludGVyc2VjdHJvb3Rwb3MiLCJ0cnVuYyIsInJvb3RCb3VuZHMiLCJ5IiwieCIsImJvdW5kaW5ncm9vdHBvcyIsInJvb3Rwb3MiLCJlbnRyeXBvcyIsImJvdW5kaW5nQ2xpZW50UmVjdCIsInZpZXdwb3J0VHJpZ2dlck9mZnNldCIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VySGlzdG9yeSIsImN1cnJlbnQiLCJpc1NhZmFyaUlPUyIsInByZXZpb3VzUmVmZXJlbmNlTmFtZSIsInRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyIsImNhbGN1bGF0ZVNoaWZ0U3BlY3MiLCJfcmVmMyIsInNjcm9sbFBvcyIsInNjcm9sbGJsb2NrRWxlbWVudCIsImNyYWRsZUNvbnRlbnQiLCJjcmFkbGVFbGVtZW50cyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJoZWFkR3JpZEVsZW1lbnQiLCJoZWFkUmVmIiwidGFpbEdyaWRFbGVtZW50IiwidGFpbFJlZiIsImNyYWRsZWNvbnRlbnRsaXN0IiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwidGFpbGNvbnRlbnRsaXN0IiwidGFpbE1vZGVsQ29tcG9uZW50cyIsInZpZXdwb3J0Um93Y291bnQiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2EiLCJwcm9wcyIsImluZGV4IiwicHJldmlvdXNDcmFkbGVSb3dPZmZzZXQiLCJwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCIsIl9iIiwicHJldmlvdXNBeGlzUm93T2Zmc2V0IiwibGlzdEVuZHJvd09mZnNldCIsInNwYW5Sb3dQdHIiLCJzcGFuQXhpc1BpeGVsU2hpZnQiLCJpblByb2Nlc3NSb3dQdHIiLCJpc0xpc3RCb3VuZGFyeSIsInRvdGFsUGl4ZWxTaGlmdCIsImZpbmFsVmFyaWFibGVSb3dMZW5ndGgiLCJyZWZlcmVuY2VHcmlkRWxlbWVudCIsImdyaWRSb3dMZW5ndGhzIiwiZ2V0R3JpZFJvd0xlbmd0aHMiLCJyZXZlcnNlIiwiZ3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zIiwiZ2V0R3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zIiwiZmluZEluZGV4IiwiYWdncmVnYXRlc3BhbiIsImF0Iiwic3BhblJvd1NoaWZ0IiwiYXhpc1JlZmVyZW5jZVJvd1NoaWZ0IiwiYXhpc1BpeGVsU2hpZnQiLCJzY3JvbGxibG9ja0F4aXNPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IiwibmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCIsIm5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCIsIm5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQiLCJoZWFkcm93RGlmZiIsInRhcmdldENyYWRsZUVuZHJvd09mZnNldCIsInRhaWxyb3dkaWZmIiwiY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0IiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzUmVmZXJlbmNlSXRlbVNoaWZ0IiwiaW5jbHVkZXNMYXN0Um93IiwicGFydGlhbHNwYWNlcyIsIml0ZW1zU2hvcnRmYWxsIiwiY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsImdyaWQiLCJyb3dMZW5ndGhzIiwiZWxlbWVudExpc3QiLCJjaGlsZE5vZGVzIiwiZWxlbWVudFB0ciIsImVsZW1lbnQiLCJyb3dsZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInB1c2giLCJyb3dTcGFucyIsImZvckVhY2giLCJ2YWx1ZSIsImdldENlbGxGcmFtZUNvbXBvbmVudExpc3QiLCJfcmVmNCIsImNhY2hlSGFuZGxlciIsImNyYWRsZUNvbnRlbnRDb3VudCIsImNyYWRsZVJlZmVyZW5jZUluZGV4IiwiY29udGVudGxpc3QiLCJ3b3JraW5nQ29udGVudExpc3QiLCJpbnN0YW5jZUlkQ291bnRlclJlZiIsInN0eWxlcyIsInBsYWNlaG9sZGVyTWVzc2FnZXMiLCJsb2NhbENvbnRlbnRsaXN0IiwibGFzdGluZGV4b2Zmc2V0IiwiaGVhZENvbnRlbnRsaXN0IiwidGFpbENvbnRlbnRsaXN0IiwiZGVsZXRlZHRhaWxpdGVtcyIsImRlbGV0ZWRoZWFkaXRlbXMiLCJyZWZlcmVuY2VJbmRleCIsImNoYW5nZUNvdW50IiwibmV3aW5kZXgiLCJjcmVhdGVDZWxsRnJhbWUiLCJwbGFjZWhvbGRlckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJmcmFtZSIsInBsYWNlaG9sZGVyTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlcmxpbmVyIiwicGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJlcnJvcmZyYW1lIiwicGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzIiwicGxhY2Vob2xkZXJlcnJvcmxpbmVyIiwic3BsaWNlIiwiZGVsZXRlZEl0ZW1zIiwiY29uY2F0IiwiY29tcG9uZW50TGlzdCIsImFsbG9jYXRlQ29udGVudExpc3QiLCJfcmVmNSIsImF4aXNSZWZlcmVuY2VJbmRleCIsImxheW91dEhhbmRsZXIiLCJ0cmlnZ2VyY2VsbEluZGV4Iiwib2Zmc2V0aW5kZXgiLCJoaWdoaW5kZXgiLCJoZWFkaXRlbWNvdW50IiwidGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCIsInRyaWdnZXJjZWxsSXNJblRhaWwiLCJ1bmRlZmluZWQiLCJ0cmlnZ2VyY2VsbFB0ciIsInRyaWdnZXJjZWxsQ29tcG9uZW50IiwiY2xvbmVFbGVtZW50IiwiaXNUcmlnZ2VyY2VsbCIsImNvbnNvbGUiLCJsb2ciLCJpc1RyaWdnZWNlbGwiLCJhc3NpZ24iLCJoZWFkbGlzdCIsInRhaWxsaXN0IiwiZGVsZXRlUG9ydGFscyIsImRlbGV0ZUxpc3QiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJkbGlzdCIsIm1hcCIsIml0ZW0iLCJkZWxldGVQb3J0YWwiLCJfcmVmNiIsImluc3RhbmNlSUQiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwiZ2V0SXRlbSIsInBsYWNlaG9sZGVyIiwidXNlUGxhY2Vob2xkZXIiLCJpdGVtSUQiLCJnZXROZXdPckV4aXN0aW5nSXRlbUlEIiwiY3JlYXRlRWxlbWVudCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// contenthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module supports the setup, rollover and positioning of content in the Cradle.\n\n    There are three key functions in this module: setCradleContent, updateCradleContent, and\n    adjustScrollblockForVariability.\n\n    There are also a few functions which support synchronization of Cradle content with cache\n    content (see internal and external services below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    down (or right), content is removed from the Cradle tail and added to the Cradle head (thus moving the\n    Cradle axis), while new content is added to the tail. When scrolling up (or left), the reverse occurs.\n\n    adjustScrollblockForVariability reconfigures the scrollblock to accommodate variable sized grid rows.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ "./src/cradle/contentfunctions.tsx");\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, ContentHandler);\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    };\n    // Three main public methods - setCradleContent, updateCradleContent, and adjustScrollblockForVariability\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n    this.updateListsize = function (newlistsize) {\n      if (newlistsize == 0) {\n        var cradleContent = _this.content;\n        _this.clearCradle();\n        cradleContent.headDisplayComponents = [];\n        cradleContent.tailDisplayComponents = [];\n      }\n      _this.cradleParameters.cradleInternalPropertiesRef.current.updateListsize(newlistsize);\n    };\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n        cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n        layoutHandler = cradleHandlers.layoutHandler,\n        serviceHandler = cradleHandlers.serviceHandler,\n        scrollHandler = cradleHandlers.scrollHandler;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages;\n      var crosscount = cradleInternalProperties.crosscount,\n        listsize = cradleInternalProperties.listsize,\n        listRowcount = cradleInternalProperties.listRowcount;\n      var workingRequestAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingRequestAxisReferenceIndex -= workingRequestAxisReferenceIndex % crosscount;\n      // reposition at row boundary\n      if ([\'firstrender\', \'firstrenderfromcache\', \'finishreposition\', \'reconfigure\', \'scrollto\'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingRequestAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content;\n      // ----------------------[ 2. get content requirements ]----------------------\n      var baseRowLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      // note that targetAxisReferenceIndex replaces requestedAxisReferenceIndex here\n      var _ref = (0, contentfunctions_1.calculateContentListRequirements)({\n          // pixel\n          baseRowLength: baseRowLength,\n          targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n          // index\n          targetAxisReferenceIndex: workingRequestAxisReferenceIndex,\n          // resources\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties\n        }),\n        targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n        targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n        cradleContentCount = _ref.newCradleContentCount,\n        scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset;\n      // reset scrollblock Offset and length\n      var scrollblockElement = viewportElement.firstChild;\n      var baselength = listRowcount * baseRowLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (cradleState == \'pivot\') {\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.left = null;\n        } else {\n          scrollblockElement.style.top = null;\n        }\n      }\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // semantics\n      // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          cradleReferenceIndex: targetCradleReferenceIndex,\n          listStartChangeCount: 0,\n          listEndChangeCount: cradleContentCount,\n          workingContentList: workingContentList,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        }),\n        _ref3 = _slicedToArray(_ref2, 1),\n        newcontentlist = _ref3[0];\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: newcontentlist,\n          axisReferenceIndex: targetAxisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref5 = _slicedToArray(_ref4, 2),\n        headcontentlist = _ref5[0],\n        tailcontentlist = _ref5[1];\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, \'setCradleContent\', cstate);\n      }\n      //  ----------------------[ 4. set CSS ]-----------------------\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset;\n      // avoid bogus call to updateCradleContent\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset);\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current,\n        headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n      if (orientation == \'vertical\') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // orientation = \'horizontal\'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = left + \'px\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element\'s scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler.\n    // typically called for scroll action, but can also be called if the triggerLineCell changes\n    // size with variant layout.\n    this.updateCradleContent = function () {\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a;\n      // handler support\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter.cacheHandler,\n        layoutHandler = _this$cradleParameter.layoutHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        interruptHandler = _this$cradleParameter.interruptHandler,\n        serviceHandler = _this$cradleParameter.serviceHandler;\n      var shiftinstruction = interruptHandler.shiftinstruction,\n        triggerViewportReferencePos = interruptHandler.triggerViewportReferencePos;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n        cache = cradleInheritedProperties.cache,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages,\n        layout = cradleInheritedProperties.layout,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        padding = cradleInheritedProperties.padding,\n        gap = cradleInheritedProperties.gap;\n      var crosscount = cradleInternalProperties.crosscount;\n      var scrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      // cradle scaffold and user cells\n      var cradleElements = layoutHandler.elements;\n      var cradleContent = _this.content,\n        modelcontentlist = cradleContent.cradleModelComponents || [];\n      var oldCradleReferenceIndex = ((_a = modelcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      var _ref6 = (0, contentfunctions_1.calculateShiftSpecs)({\n          shiftinstruction: shiftinstruction,\n          triggerViewportReferencePos: triggerViewportReferencePos,\n          scrollPos: scrollPos,\n          scrollblockElement: viewportElement.firstChild,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContent: cradleContent,\n          cradleElements: cradleElements\n        }),\n        cradleItemShift = _ref6.cradleReferenceItemShift,\n        axisReferenceIndex = _ref6.newAxisReferenceIndex,\n        axisItemShift = _ref6.axisReferenceItemShift,\n        cradleContentCount = _ref6.newCradleContentCount,\n        listStartChangeCount = _ref6.listStartChangeCount,\n        listEndChangeCount = _ref6.listEndChangeCount,\n        newAxisViewportPixelOffset = _ref6.newAxisViewportPixelOffset;\n      var axisViewportPixelOffset = newAxisViewportPixelOffset;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var isShift = !(axisItemShift == 0 && cradleItemShift == 0);\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with \'renderupdatedcontent\' state in cradle.tsx, or at \'finishupdateforvariability\'\n      //    for variable content\n      interruptHandler.triggerlinesIntersect.disconnect();\n      // abandon option; nothing to do but reposition\n      if (!isShift) {\n        // can happen first row; oversized last row\n        cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n        _this.applyStyling({\n          layout: layout,\n          orientation: orientation,\n          padding: padding,\n          gap: gap,\n          cellHeight: cellHeight,\n          cellWidth: cellWidth,\n          crosscount: crosscount,\n          axisReferenceIndex: axisReferenceIndex,\n          axisViewportPixelOffset: axisViewportPixelOffset,\n          scrollPos: scrollPos,\n          headcontent: cradleContent.headModelComponents,\n          axisElement: axisElement,\n          headElement: headElement\n        });\n        return;\n      }\n      // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect changed content\n      var updatedContentList,\n        deletedContentItems = [];\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref7 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        });\n        var _ref8 = _slicedToArray(_ref7, 2);\n        updatedContentList = _ref8[0];\n        deletedContentItems = _ref8[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n      if (deletedContentItems.length && cache == \'cradle\') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cradle\', deleteList);\n          };\n        }\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      }\n      // ----------------------------------[ 5. allocate cradle content ]--------------------------\n      var _ref9 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: updatedContentList,\n          axisReferenceIndex: axisReferenceIndex,\n          layoutHandler: layoutHandler\n        }),\n        _ref10 = _slicedToArray(_ref9, 2),\n        headcontent = _ref10[0],\n        tailcontent = _ref10[1];\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, \'updateCradleContent\', cstate);\n      }\n      // -------------------------------[ 6. css changes ]-------------------------\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      if (isShift) cacheHandler.renderPortalLists();\n      _this.applyStyling({\n        layout: layout,\n        orientation: orientation,\n        padding: padding,\n        gap: gap,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        crosscount: crosscount,\n        axisReferenceIndex: axisReferenceIndex,\n        axisViewportPixelOffset: axisViewportPixelOffset,\n        scrollPos: scrollPos,\n        headcontent: headcontent,\n        axisElement: axisElement,\n        headElement: headElement\n      });\n      // load new display data\n      cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n      cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n    };\n    // move the offset of the axis\n    this.applyStyling = function (_ref11) {\n      var layout = _ref11.layout,\n        orientation = _ref11.orientation,\n        padding = _ref11.padding,\n        gap = _ref11.gap,\n        cellHeight = _ref11.cellHeight,\n        cellWidth = _ref11.cellWidth,\n        crosscount = _ref11.crosscount,\n        axisReferenceIndex = _ref11.axisReferenceIndex,\n        axisViewportPixelOffset = _ref11.axisViewportPixelOffset,\n        scrollPos = _ref11.scrollPos,\n        headcontent = _ref11.headcontent,\n        axisElement = _ref11.axisElement,\n        headElement = _ref11.headElement;\n      if (layout == \'variable\') return;\n      // --------------\n      // Safari when zoomed drifts (calc precision one presumes). This is a hack to correct that.\n      var preAxisRows = Math.ceil(axisReferenceIndex / crosscount);\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var testScrollPos = baseCellLength * preAxisRows + padding - axisViewportPixelOffset;\n      var scrollDiff = testScrollPos - scrollPos;\n      if (scrollDiff) {\n        axisViewportPixelOffset += scrollDiff;\n      }\n      // --------------\n      var topPos, leftPos; // available for debug\n      if (orientation == \'vertical\') {\n        topPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = topPos + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // \'horizontal\'\n        leftPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = leftPos + \'px\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ===================[ RECONFIGURE THE SCROLLBLOCK FOR VARIABLE CONTENT ]=======================\n    /*\n        blockScrollPos is the amount the scrollBlock is scrolled to reveal the centre of the Cradle\n            at the edge of the Viewport\n        \n        newAxisScrollblockOffset is the exact offset of blockScrollPos, plus the axisViewportOffset\n        \n        axisViewportOffset is the amount the axis is ahead of the Viewport edge\n        \n        the length of the Scrollblock is shortened by the amount the measured tail length differs from the\n            base tail length\n    \n        Called for variable layout only. All DOM elements should have been rendered at this point\n        sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n        to get closer to natural proportions to minimize janky scroll thumb\n    */\n    this.adjustScrollblockForVariability = function (source) {\n      // ----------------------[ setup base values and references ]------------------------\n      // resources...\n      var cradleParameters = _this.cradleParameters,\n        cradleHandlers = cradleParameters.handlersRef.current,\n        ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var layoutHandler = cradleHandlers.layoutHandler,\n        scrollHandler = cradleHandlers.scrollHandler,\n        interruptHandler = cradleHandlers.interruptHandler;\n      var cradleElements = layoutHandler.elements,\n        cradlePositionData = layoutHandler.cradlePositionData;\n      // element references...\n      var viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild,\n        headGridElement = cradleElements.headRef.current,\n        tailGridElement = cradleElements.tailRef.current,\n        axisElement = cradleElements.axisRef.current;\n      // current configurations...\n      var axisReferenceIndex = cradlePositionData.targetAxisReferenceIndex,\n        axisViewportOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth;\n      var crosscount = cradleInternalProperties.crosscount,\n        listRowcount = cradleInternalProperties.listRowcount;\n      // ------------------------[ precursor calculations ]------------------------\n      // rowcounts and row offsets for positioning\n      // listRowcount taken from internal properties above\n      var headRowCount = Math.ceil(headGridElement.childNodes.length / crosscount),\n        tailRowCount = Math.ceil(tailGridElement.childNodes.length / crosscount);\n      // reference rows - cradle first/last; axis; list end\n      var axisReferenceRow = Math.ceil(axisReferenceIndex / crosscount),\n        cradleReferenceRow = axisReferenceRow - headRowCount,\n        cradleLastRow = axisReferenceRow + (tailRowCount - 1),\n        listLastRow = listRowcount - 1;\n      var preCradleRowCount = cradleReferenceRow,\n        postCradleRowCount = listLastRow - cradleLastRow;\n      // base pixel values\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var measuredTailLength = orientation == \'vertical\' ? tailGridElement.offsetHeight : tailGridElement.offsetWidth;\n      var basePostCradlePixelLength = postCradleRowCount * baseCellLength;\n      var computedPostAxisPixelLength = basePostCradlePixelLength + measuredTailLength;\n      // base figures used for preAxis #s for compatibility with repositioning, which uses base figures\n      var basePreAxisPixelLength = (preCradleRowCount + headRowCount) * baseCellLength + padding;\n      // ------------------------[ layout adjustments ]----------------------\n      interruptHandler.signals.pauseCradleIntersectionObserver = true;\n      var computedScrollblockLength = basePreAxisPixelLength + computedPostAxisPixelLength;\n      var blockScrollPos = basePreAxisPixelLength - axisViewportOffset;\n      var newAxisScrollblockOffset = blockScrollPos + axisViewportOffset; // ie. basePreAxisPixelLength, but semantics\n      if (orientation == \'vertical\') {\n        axisElement.style.top = newAxisScrollblockOffset + \'px\';\n        scrollblockElement.style.height = computedScrollblockLength + \'px\';\n      } else {\n        // \'horizontal\'\n        axisElement.style.left = newAxisScrollblockOffset + \'px\';\n        scrollblockElement.style.width = computedScrollblockLength + \'px\';\n      }\n      // -----------------------[ scrollPos adjustment ]-------------------------\n      if (orientation == \'vertical\') {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n      if (!(0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // adjust blockScrollPos directly - most browsers including Safari desktop\n        cradlePositionData.blockScrollPos = blockScrollPos;\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n        scrollHandler.resetScrollData(blockScrollPos);\n      } else {\n        // for Safari iOS\n        // temporarily adjust scrollblockElement offset; iOSonAfterScroll transfers shift to blockScrollPos\n        // - direct change of scrollTop/ScrollLeft in Safari iOS is ignored by the browser momentum engine\n        var startingScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollDiff = blockScrollPos - startingScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = -scrollDiff + \'px\';\n        } else {\n          scrollblockElement.style.left = -scrollDiff + \'px\';\n        }\n      }\n      // check for gotoIndex or resize overshoot\n      if (source == \'setcradle\' && !postCradleRowCount) {\n        var viewportLength = orientation == \'vertical\' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n        var alignedEndPosDiff = axisViewportOffset + measuredTailLength - viewportLength;\n        if (alignedEndPosDiff < 0) {\n          // fill the bottom of the viewport using scrollBy\n          var scrollByY = orientation == \'vertical\' ? alignedEndPosDiff : 0;\n          var scrollByX = orientation == \'vertical\' ? 0 : alignedEndPosDiff;\n          viewportElement.scrollBy(scrollByX, scrollByY);\n        }\n      }\n    };\n    // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cacheMax = _this$cradleParameter2.cacheMax,\n        MAX_CACHE_OVER_RUN = _this$cradleParameter2.MAX_CACHE_OVER_RUN;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      var modelComponentList = _this.content.cradleModelComponents;\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n        scrollerID = cradleInheritedProperties.scrollerID;\n      if (cache == \'keepload\') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n          serviceHandler = cradleHandlers.serviceHandler;\n        var modelIndexList = _this.getModelIndexList();\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cacheMax\', deleteList);\n          };\n        }\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.renderPortalLists();\n        }\n      }\n    };\n    // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      // const { cacheHandler } = this.cradleParameters.handlersRef.current\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n    this.cradleParameters = cradleParameters;\n  }\n  // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n  _createClass(ContentHandler, [{\n    key: "getModelIndexList",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    }\n  }, {\n    key: "indexSpan",\n    get: function get() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n      if (cradleModelComponents.length == 0) return [];\n      var lowIndex = cradleModelComponents[0].props.index;\n      var highIndex = lowIndex + (cradleModelComponents.length - 1);\n      return [lowIndex, highIndex];\n    }\n    // called from service handler\'s remapIndexes, as last step\n  }, {\n    key: "reconcileCellFrames",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n      function processComponentFn(component, i, array) {\n        var _component$props = component.props,\n          index = _component$props.index,\n          itemID = _component$props.itemID;\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n          if (newItemID != itemID) {\n            // defensive; shouldn\'t happen\n            array[i] = react_1["default"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n      cradleModelComponents.forEach(processComponentFn);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports moveIndex and insertRemoveIndex, updates cradle contiguous items from startChangeIndex or start of cradle\n  }, {\n    key: "synchronizeCradleItemIDsToCache",\n    value: function synchronizeCradleItemIDsToCache(updatedIndexList) {\n      var isInsertRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var startChangeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      // asssemble resources\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      // assemble parameters\n      var indexSpan = this.indexSpan;\n      if (indexSpan.length == 0) return; // defensive; shouldn\'t be here\n      var _indexSpan = _slicedToArray(indexSpan, 2),\n        lowSpan = _indexSpan[0],\n        highSpan = _indexSpan[1];\n      var startIndex, endIndex;\n      if (isInsertRemove) {\n        if (startChangeIndex > highSpan) return;\n        startIndex = startChangeIndex;\n        endIndex = highSpan;\n      } else {\n        // move\n        if (updatedIndexList.length == 0) return;\n        startIndex = updatedIndexList[0];\n        endIndex = updatedIndexList.at(-1);\n      }\n      var updatedSpan = endIndex - startIndex + 1;\n      var firstIndex = startIndex;\n      if (firstIndex > highSpan) return;\n      if (firstIndex < lowSpan) firstIndex = lowSpan;\n      var lowPtr = firstIndex - lowSpan;\n      var highPtr = isInsertRemove ? cradleModelComponents.length - 1 : Math.min(cradleModelComponents.length - 1, lowPtr + updatedSpan - 1);\n      // function to update individual cradle components to cache changes\n      function processcomponentFn(component, componentptr, componentarray) {\n        var index = component.props.index;\n        var cacheItemID = indexToItemIDMap.get(index);\n        // if cache has no component for cradle item, then get one\n        if (cacheItemID === undefined) {\n          var newItemID = cacheHandler.getNewItemID();\n          componentarray[componentptr] = react_1["default"].cloneElement(component, {\n            itemID: newItemID\n          });\n          return;\n        } else {\n          // match cache itemID to cradle component itemID\n          var cradleItemID = component.props.itemID;\n          var updateptr = updatedIndexList.indexOf(index); // TODO verify need for updatelist\n          if (updateptr != -1) {\n            // update list confirms there is a cache item for this index\n            if (cacheItemID == cradleItemID) return;\n            componentarray[componentptr] = react_1["default"].cloneElement(component, {\n              itemID: cacheItemID\n            });\n          } else {\n            var _newItemID = cacheHandler.getNewItemID();\n            componentarray[componentptr] = react_1["default"].cloneElement(component, {\n              itemID: _newItemID\n            });\n          }\n        }\n      }\n      for (var ptr = lowPtr; ptr <= highPtr; ptr++) {\n        processcomponentFn(cradleModelComponents[ptr], ptr, cradleModelComponents);\n      }\n    }\n    // supports insertRemoveIndex\n  }, {\n    key: "createNewItemIDs",\n    value: function createNewItemIDs(newList) {\n      if (!newList.length) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var indexSpan = this.indexSpan;\n      if (indexSpan.length == 0) return; // defensive\n      var _indexSpan2 = _slicedToArray(indexSpan, 2),\n        lowSpan = _indexSpan2[0],\n        highSpan = _indexSpan2[1];\n      function processcomponentFn(newlistindex) {\n        if (newlistindex < lowSpan || newlistindex > highSpan) return; // defensive\n        var cradlePtr = newlistindex - lowSpan;\n        var component = cradleModelComponents[cradlePtr];\n        var newItemID = cacheHandler.getNewItemID();\n        cradleModelComponents[cradlePtr] = react_1["default"].cloneElement(component, {\n          itemID: newItemID\n        });\n      }\n      // cradleModelComponents.forEach(processcomponentFn)\n      newList.forEach(processcomponentFn);\n    }\n  }]);\n  return ContentHandler;\n}();\nexports["default"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQTRCcVIsU0FBUztRQUE5QkUsT0FBTyxHQUFBbUIsV0FBQTtRQUFFbEIsUUFBUSxHQUFBa0IsV0FBQTtNQUV4QixTQUFTVixrQkFBa0JBLENBQUNXLFlBQVk7UUFFcEMsSUFBSUEsWUFBWSxHQUFHcEIsT0FBTyxJQUFJb0IsWUFBWSxHQUFHbkIsUUFBUSxFQUFFLE9BQU0sQ0FBQztRQUU5RCxJQUFNb0IsU0FBUyxHQUFHRCxZQUFZLEdBQUdwQixPQUFPO1FBRXhDLElBQU1oQixTQUFTLEdBQUcvTCxxQkFBcUIsQ0FBQ29PLFNBQVMsQ0FBQztRQUVsRCxJQUFNakMsU0FBUyxHQUFHOUssWUFBWSxDQUFDZ0wsWUFBWSxFQUFFO1FBRTdDck0scUJBQXFCLENBQUNvTyxTQUFTLENBQUMsR0FBRzdPLE9BQUEsV0FBSyxDQUFDK00sWUFBWSxDQUFDUCxTQUFTLEVBQUU7VUFBQ0csTUFBTSxFQUFDQztRQUFTLENBQUMsQ0FBQztNQUV4RjtNQUVBO01BRUE4QixPQUFPLENBQUMxQixPQUFPLENBQUNpQixrQkFBa0IsQ0FBQztJQUV2QztFQUFDO0VBQUEsT0FBQTVOLGNBQUE7QUFBQTtBQXo5Qkx5TyxrQkFBQSxHQUFBek8sY0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL2NvbnRlbnRoYW5kbGVyLnRzeD9hODlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBzdXBwb3J0cyB0aGUgc2V0dXAsIHJvbGxvdmVyIGFuZCBwb3NpdGlvbmluZyBvZiBjb250ZW50IGluIHRoZSBDcmFkbGUuIFxuXG4gICAgVGhlcmUgYXJlIHRocmVlIGtleSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGU6IHNldENyYWRsZUNvbnRlbnQsIHVwZGF0ZUNyYWRsZUNvbnRlbnQsIGFuZFxuICAgIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkuXG5cbiAgICBUaGVyZSBhcmUgYWxzbyBhIGZldyBmdW5jdGlvbnMgd2hpY2ggc3VwcG9ydCBzeW5jaHJvbml6YXRpb24gb2YgQ3JhZGxlIGNvbnRlbnQgd2l0aCBjYWNoZSBcbiAgICBjb250ZW50IChzZWUgaW50ZXJuYWwgYW5kIGV4dGVybmFsIHNlcnZpY2VzIGJlbG93KS5cblxuICAgIHNldENyYWRsZUNvbnRlbnQgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gQ3JhZGxlIChpbiB0aGUgc3RhdGUgbWFuYWdlciksIGFuZCBpbnN0YW50aWF0ZXMgbmV3IENyYWRsZVxuICAgIGNvbnRlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIHNjcm9sbGVyIHNldHVwLCBvciBjaGFuZ2VzIHRvIGl0cyBjb25maWd1cmF0aW9uLiBzZXRDcmFkbGVDb250ZW50XG4gICAgY3JlYXRlcyBhIGxpc3Qgb2YgQ3JhZGxlIGNvbnRlbnQgQ2VsbEZyYW1lcywgYW5kIGFsbG9jYXRlcyB0aG9zZSB0byB0aGUgdHdvIENyYWRsZSBncmlkcy4gVGhpcyBcbiAgICBwcm9jZXNzIG9jY3VycyBpbiByZXNwb25zZSB0byBtYW55IHN0YXRlIGNoYW5nZXMsIHN1Y2ggYXMgZmluaXNocmVwb3NpdGlvbiwgcGl2b3QsIGEgaG9zdCBzY3JvbGx0b1xuICAgIHJlcXVlc3QsIGFuZCBtb3JlLlxuXG4gICAgdXBkYXRlQ3JhZGxlQ29udGVudCByb2xscyBvdmVyIHRoZSBDcmFkbGUgY29udGVudCBpbiByZXNwb25zZSB0byB1c2VyIHNjcm9sbGluZy4gV2hlbiBzY3JvbGxpbmcgXG4gICAgZG93biAob3IgcmlnaHQpLCBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgQ3JhZGxlIHRhaWwgYW5kIGFkZGVkIHRvIHRoZSBDcmFkbGUgaGVhZCAodGh1cyBtb3ZpbmcgdGhlIFxuICAgIENyYWRsZSBheGlzKSwgd2hpbGUgbmV3IGNvbnRlbnQgaXMgYWRkZWQgdG8gdGhlIHRhaWwuIFdoZW4gc2Nyb2xsaW5nIHVwIChvciBsZWZ0KSwgdGhlIHJldmVyc2Ugb2NjdXJzLlxuXG4gICAgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSByZWNvbmZpZ3VyZXMgdGhlIHNjcm9sbGJsb2NrIHRvIGFjY29tbW9kYXRlIHZhcmlhYmxlIHNpemVkIGdyaWQgcm93cy5cblxuICAgIFRoZSBDcmFkbGUgKHRocm91Z2ggdGhlIGNvbnRlbnRmdW5jdGlvbnMgbW9kdWxlKSBkZWxlZ2F0ZXMgZmV0Y2hpbmcgY29udGVudCBpdGVtcyB0byB0aGUgQ2VsbEZyYW1lLlxuXG4gICAgVGhpcyBtb2R1bGUgaXMgc3VwcG9ydGVkIHByaW1hcmlseSBieSB0aGUgY29udGVudGZ1bmN0aW9ucyBtb2R1bGUuXG5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgXG4gICAgY2FsY3VsYXRlQ29udGVudExpc3RSZXF1aXJlbWVudHMsXG4gICAgY2FsY3VsYXRlU2hpZnRTcGVjcyxcbiAgICBhbGxvY2F0ZUNvbnRlbnRMaXN0LFxuICAgIGRlbGV0ZVBvcnRhbHMsXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgXG5cbn0gZnJvbSAnLi9jb250ZW50ZnVuY3Rpb25zJ1xuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4uL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50SGFuZGxlciB7XG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICB9XG5cbiAgIHB1YmxpYyBjb250ZW50ID0ge1xuXG4gICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICBoZWFkTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgdGFpbE1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIG9ubHkgdXNlZCBpbiBjcmFkbGUgZm9yIHJlbmRlclxuICAgICAgaGVhZERpc3BsYXlDb21wb25lbnRzOiBbXSxcbiAgICAgIHRhaWxEaXNwbGF5Q29tcG9uZW50czogW10sXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHByaXZhdGUgaW5zdGFuY2VJZENvdW50ZXJSZWYgPSB7XG5cbiAgICAgICBjdXJyZW50OjBcblxuICAgIH1cbiAgICAvLyBUaHJlZSBtYWluIHB1YmxpYyBtZXRob2RzIC0gc2V0Q3JhZGxlQ29udGVudCwgdXBkYXRlQ3JhZGxlQ29udGVudCwgYW5kIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBTRVQgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyByZXNldCB0aGUgY3JhZGxlIHdpdGggbmV3IGNvbnRlbnQsIGluY2x1ZGluZyBhbGxvY2F0aW9uIGJldHdlZW4gaGVhZCBhbmQgdGFpbCBwYXJ0cyBvZiB0aGUgY3JhZGxlXG4gICAgLy8gLSBjYWxsZWQgb25seSBmcm9tIHRoZSBDcmFkbGUgc3RhdGUgaGFuZGxlclxuICAgIHB1YmxpYyB1cGRhdGVMaXN0c2l6ZSA9IChuZXdsaXN0c2l6ZSkgPT4ge1xuXG4gICAgICAgIGlmIChuZXdsaXN0c2l6ZSA9PSAwKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnQgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLmNsZWFyQ3JhZGxlKClcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gW11cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LnVwZGF0ZUxpc3RzaXplKG5ld2xpc3RzaXplKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldENyYWRsZUNvbnRlbnQgPSAoIGNyYWRsZVN0YXRlICkgPT4geyAvLyBjcmFkbGVTdGF0ZSBpbmZsdWVuY2VzIHNvbWUgYmVoYXZpb3VyXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSGFuZGxlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgICAgIC8vIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLFxuXG4gICAgICAgIH0gPSBjcmFkbGVIYW5kbGVyc1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4ID0gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuXG4gICAgICAgIGxldCB7IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IH0gPSBjcmFkbGVQb3NpdGlvbkRhdGFcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgLy8gY2FjaGUsXG4gICAgICAgICAgICAvLyBzY3JvbGxlcklELFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgLy8gbGF5b3V0LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCB7Y3Jvc3Njb3VudCwgbGlzdHNpemUsIGxpc3RSb3djb3VudH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICBsZXQgd29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbihyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgICAgICB3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCAtPSAod29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50KVxuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYXQgcm93IGJvdW5kYXJ5XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICAnZmlyc3RyZW5kZXInLCBcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcmZyb21jYWNoZScsXG4gICAgICAgICAgICAnZmluaXNocmVwb3NpdGlvbicsIFxuICAgICAgICAgICAgJ3JlY29uZmlndXJlJywgXG4gICAgICAgICAgICAnc2Nyb2xsdG8nLCBcbiAgICAgICAgXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICAod29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggPT0gMCk/XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6XG4gICAgICAgICAgICAgICAgICAgIGdhcCAvLyBkZWZhdWx0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtpbmdDb250ZW50TGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBnZXQgY29udGVudCByZXF1aXJlbWVudHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBiYXNlUm93TGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICAvLyBub3RlIHRoYXQgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IHJlcGxhY2VzIHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCBoZXJlXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgLy8gYnkgaW5kZXhcbiAgICAgICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcblxuICAgICAgICAgICAgLy8gY291bnRzXG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQ6Y3JhZGxlQ29udGVudENvdW50LCBcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IHNjcm9sbFBvcyBieSBwaXhlbHNcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldDpzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICAgICAgfSA9IGNhbGN1bGF0ZUNvbnRlbnRMaXN0UmVxdWlyZW1lbnRzKHtcblxuICAgICAgICAgICAgICAgIC8vIHBpeGVsXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OndvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgICAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVzZXQgc2Nyb2xsYmxvY2sgT2Zmc2V0IGFuZCBsZW5ndGhcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3RSb3djb3VudCAqIGJhc2VSb3dMZW5ndGgpIC0gZ2FwIC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3Bpdm90Jykge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBiYXNlbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUud2lkdGggPSBiYXNlbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCAvLyBzZW1hbnRpY3NcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAzLiBnZXQgYW5kIGNvbmZpZyBjb250ZW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICAvLyByZXR1cm5zIGNvbnRlbnQgY29uc3RyYWluZWQgYnkgY3JhZGxlUm93Y291bnRcbiAgICAgICAgY29uc3QgW25ld2NvbnRlbnRsaXN0XS8qLGRlbGV0ZWRpdGVtc10qLyA9IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3Qoe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsICAgICAgICAgICAgXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6dGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudDowLFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpuZXdjb250ZW50bGlzdCxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDp0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgIFxuICAgICAgICB9KVxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzID0gbmV3Y29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gaGVhZGNvbnRlbnRsaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IHRhaWxjb250ZW50bGlzdFxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spIHtcblxuICAgICAgICAgICAgY29uc3QgY3N0YXRlID0gY3JhZGxlU3RhdGVcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCdzZXRDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiBzZXQgQ1NTIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCBcbiAgICAgICAgLy8gYXZvaWQgYm9ndXMgY2FsbCB0byB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCkgXG5cbiAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9XG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgXG5cbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBsYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG5cbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0ID0gXG4gICAgICAgICAgICBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKyBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0IFxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSB0b3AgKyAncHgnXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gJ2F1dG8nXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudGxpc3QubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke2dhcH1weCAke3BhZGRpbmd9cHhgOlxuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwcHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4J1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke2dhcH1weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAwcHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT1bIFVQREFURSBDT05URU5UIHRocm91Z2ggc2Nyb2xsIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVwZGF0ZUNyYWRsZUNvbnRlbnQgZG9lcyBub3QgdG91Y2ggdGhlIHZpZXdwb3J0IGVsZW1lbnQncyBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBzY3JvbGxibG9ja1xuICAgIC8vIGluc3RlYWQgaXQgcmVjb25maWd1cmVzIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3JhZGxlLiBJdCBpcyBjYWxsZWQgc29sZWx5IGZyb21cbiAgICAvLyBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayBvZiBpbnRlcnJ1cHRIYW5kbGVyLlxuICAgIC8vIHR5cGljYWxseSBjYWxsZWQgZm9yIHNjcm9sbCBhY3Rpb24sIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgaWYgdGhlIHRyaWdnZXJMaW5lQ2VsbCBjaGFuZ2VzXG4gICAgLy8gc2l6ZSB3aXRoIHZhcmlhbnQgbGF5b3V0LlxuXG4gICAgcHVibGljIHVwZGF0ZUNyYWRsZUNvbnRlbnQgPSAoKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhhbmRsZXIgc3VwcG9ydFxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLCBcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlciwgXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgICAgICBcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3NoaWZ0aW5zdHJ1Y3Rpb24sIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvc30gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgIGxheW91dCwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBwYWRkaW5nLCBnYXBcbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgICAgIC8vIGxpc3RzaXplLFxuICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIC8vIGNyYWRsZSBzY2FmZm9sZCBhbmQgdXNlciBjZWxsc1xuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgbW9kZWxjb250ZW50bGlzdCA9IGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzIHx8IFtdXG5cbiAgICAgICAgY29uc3Qgb2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAobW9kZWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMy4gQ2FsY3VsYXRlIHNoaWZ0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGNyYWRsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgLy8gYnkgaW5kZXhcbiAgICAgICAgICAgIC8vIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0OmNyYWRsZUl0ZW1TaGlmdCwgXG4gICAgICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXg6YXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQ6YXhpc0l0ZW1TaGlmdCwgXG5cbiAgICAgICAgICAgIC8vIGNvdW50c1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LFxuXG4gICAgICAgICAgICAvLyBwaXhlbHNcbiAgICAgICAgICAgIG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcblxuICAgICAgICB9ID0gY2FsY3VsYXRlU2hpZnRTcGVjcyh7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MsXG4gICAgICAgICAgICBzY3JvbGxQb3MsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQ6dmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGQsXG5cbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50LFxuICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMsXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICBjb25zdCBpc1NoaWZ0ID0gISgoYXhpc0l0ZW1TaGlmdCA9PSAwKSAmJiAoY3JhZGxlSXRlbVNoaWZ0ID09IDApKVxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgd2lsbCBiZSBtb3ZlZCwgc28gZGlzY29ubmVjdCB0aGVtIGZyb20gdGhlaXIgb2JzZXJ2ZXIuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4LCBvciBhdCAnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknXG4gICAgICAgIC8vICAgIGZvciB2YXJpYWJsZSBjb250ZW50XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIC8vIGFiYW5kb24gb3B0aW9uOyBub3RoaW5nIHRvIGRvIGJ1dCByZXBvc2l0aW9uXG4gICAgICAgIGlmICghaXNTaGlmdCkgeyAvLyBjYW4gaGFwcGVuIGZpcnN0IHJvdzsgb3ZlcnNpemVkIGxhc3Qgcm93XG4gICAgXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxpbmcoe1xuICAgICAgICAgICAgICAgIGxheW91dCwgb3JpZW50YXRpb24sIHBhZGRpbmcsIGdhcCwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBzY3JvbGxQb3MsIFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50OmNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudCwgaGVhZEVsZW1lbnRcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiByZWNvbmZpZ3VyZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb2xsZWN0IGNoYW5nZWQgY29udGVudFxuICAgICAgICBsZXQgdXBkYXRlZENvbnRlbnRMaXN0LCBkZWxldGVkQ29udGVudEl0ZW1zID0gW11cblxuICAgICAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgfHwgbGlzdEVuZENoYW5nZUNvdW50KSB7IC8vIGlmIGVpdGhlciBpcyBub24tMCB0aGVuIG1vZGlmeSBjb250ZW50XG5cbiAgICAgICAgICAgIFt1cGRhdGVkQ29udGVudExpc3QsZGVsZXRlZENvbnRlbnRJdGVtc10gPSBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0KHtcbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdDptb2RlbGNvbnRlbnRsaXN0LFxuICAgICAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleDpvbGRDcmFkbGVSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZjp0aGlzLmluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29udGVudExpc3QgPSBtb2RlbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxldGVkQ29udGVudEl0ZW1zLmxlbmd0aCAmJiAoY2FjaGUgPT0gJ2NyYWRsZScpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZVBvcnRhbHMoY2FjaGVIYW5kbGVyLCBkZWxldGVkQ29udGVudEl0ZW1zLCBkTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA1LiBhbGxvY2F0ZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBbaGVhZGNvbnRlbnQsIHRhaWxjb250ZW50XSA9IGFsbG9jYXRlQ29udGVudExpc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudGxpc3Q6dXBkYXRlZENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSB1cGRhdGVkQ29udGVudExpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gaGVhZGNvbnRlbnRcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRcblxuICAgICAgICBpZiAoc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spIHtcblxuICAgICAgICAgICAgY29uc3QgY3N0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsJ3VwZGF0ZUNyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNi4gY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKGlzU2hpZnQpIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgdGhpcy5hcHBseVN0eWxpbmcoe1xuICAgICAgICAgICAgbGF5b3V0LCBvcmllbnRhdGlvbiwgcGFkZGluZywgZ2FwLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBzY3JvbGxQb3MsIFxuICAgICAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgICAgICBheGlzRWxlbWVudCwgaGVhZEVsZW1lbnRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBsb2FkIG5ldyBkaXNwbGF5IGRhdGFcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgIH1cblxuICAgIC8vIG1vdmUgdGhlIG9mZnNldCBvZiB0aGUgYXhpc1xuICAgIHByaXZhdGUgYXBwbHlTdHlsaW5nID0gKHtcbiAgICAgICAgbGF5b3V0LCBvcmllbnRhdGlvbiwgcGFkZGluZywgZ2FwLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIFxuICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgc2Nyb2xsUG9zLCBcbiAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgIGF4aXNFbGVtZW50LCBoZWFkRWxlbWVudFxuICAgIH0pID0+IHtcbiAgICAgICAgXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgcmV0dXJuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2FmYXJpIHdoZW4gem9vbWVkIGRyaWZ0cyAoY2FsYyBwcmVjaXNpb24gb25lIHByZXN1bWVzKS4gVGhpcyBpcyBhIGhhY2sgdG8gY29ycmVjdCB0aGF0LlxuICAgICAgICBjb25zdCBwcmVBeGlzUm93cyA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcbiAgICAgICAgY29uc3QgYmFzZUNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IHRlc3RTY3JvbGxQb3MgPSAoYmFzZUNlbGxMZW5ndGggKiBwcmVBeGlzUm93cykgKyBwYWRkaW5nIC0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IHRlc3RTY3JvbGxQb3MgLSBzY3JvbGxQb3NcblxuICAgICAgICBpZiAoc2Nyb2xsRGlmZikge1xuICAgICAgICAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgKz0gc2Nyb2xsRGlmZlxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHRvcFBvcywgbGVmdFBvcyAvLyBhdmFpbGFibGUgZm9yIGRlYnVnXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHRvcFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9IGVsc2UgeyAvLyAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgbGVmdFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRQb3MgKyAncHgnXG5cbiAgICAgICAgICAgIGhlYWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJFIFRIRSBTQ1JPTExCTE9DSyBGT1IgVkFSSUFCTEUgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuLyogIFxuICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHRoZSBhbW91bnQgdGhlIHNjcm9sbEJsb2NrIGlzIHNjcm9sbGVkIHRvIHJldmVhbCB0aGUgY2VudHJlIG9mIHRoZSBDcmFkbGVcbiAgICAgICAgYXQgdGhlIGVkZ2Ugb2YgdGhlIFZpZXdwb3J0XG4gICAgXG4gICAgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0IGlzIHRoZSBleGFjdCBvZmZzZXQgb2YgYmxvY2tTY3JvbGxQb3MsIHBsdXMgdGhlIGF4aXNWaWV3cG9ydE9mZnNldFxuICAgIFxuICAgIGF4aXNWaWV3cG9ydE9mZnNldCBpcyB0aGUgYW1vdW50IHRoZSBheGlzIGlzIGFoZWFkIG9mIHRoZSBWaWV3cG9ydCBlZGdlXG4gICAgXG4gICAgdGhlIGxlbmd0aCBvZiB0aGUgU2Nyb2xsYmxvY2sgaXMgc2hvcnRlbmVkIGJ5IHRoZSBhbW91bnQgdGhlIG1lYXN1cmVkIHRhaWwgbGVuZ3RoIGRpZmZlcnMgZnJvbSB0aGUgXG4gICAgICAgIGJhc2UgdGFpbCBsZW5ndGhcblxuICAgIENhbGxlZCBmb3IgdmFyaWFibGUgbGF5b3V0IG9ubHkuIEFsbCBET00gZWxlbWVudHMgc2hvdWxkIGhhdmUgYmVlbiByZW5kZXJlZCBhdCB0aGlzIHBvaW50XG4gICAgc2V0cyBDU1M6IHNjcm9sbGJsb2NrRWxlbWVudCB0b3AgYW5kIGhlaWdodCAob3IgbGVmdCBhbmQgd2lkdGgpLCBhbmQgYXhpc0VsZW1lbnQgdG9wIChvciBsZWZ0KVxuICAgIHRvIGdldCBjbG9zZXIgdG8gbmF0dXJhbCBwcm9wb3J0aW9ucyB0byBtaW5pbWl6ZSBqYW5reSBzY3JvbGwgdGh1bWJcbiovXG5cbiAgICBwdWJsaWMgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSA9IChzb3VyY2UpID0+IHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBiYXNlIHZhbHVlcyBhbmQgcmVmZXJlbmNlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmVzb3VyY2VzLi4uXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpcyxcbiAgICAgICAgICAgIGNyYWRsZUhhbmRsZXJzID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciwgc2Nyb2xsSGFuZGxlciwgaW50ZXJydXB0SGFuZGxlciB9ID0gY3JhZGxlSGFuZGxlcnNcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBlbGVtZW50czogY3JhZGxlRWxlbWVudHMsIFxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhIFxuXG4gICAgICAgIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgLy8gZWxlbWVudCByZWZlcmVuY2VzLi4uXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGN1cnJlbnQgY29uZmlndXJhdGlvbnMuLi5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OiBheGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDogYXhpc1ZpZXdwb3J0T2Zmc2V0LFxuICAgICAgICAgICAgLy8gYmxvY2tTY3JvbGxQb3M6Zm9yd2FyZGVkQmxvY2tTY3JvbGxQb3MsIFxuXG4gICAgICAgIH0gPSBjcmFkbGVQb3NpdGlvbkRhdGFcblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG5cbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCBcblxuICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcmVjdXJzb3IgY2FsY3VsYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByb3djb3VudHMgYW5kIHJvdyBvZmZzZXRzIGZvciBwb3NpdGlvbmluZ1xuICAgICAgICAvLyBsaXN0Um93Y291bnQgdGFrZW4gZnJvbSBpbnRlcm5hbCBwcm9wZXJ0aWVzIGFib3ZlXG4gICAgICAgIGNvbnN0IGhlYWRSb3dDb3VudCA9IE1hdGguY2VpbChoZWFkR3JpZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgvY3Jvc3Njb3VudCksXG4gICAgICAgICAgICB0YWlsUm93Q291bnQgPSBNYXRoLmNlaWwodGFpbEdyaWRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoL2Nyb3NzY291bnQpXG5cbiAgICAgICAgLy8gcmVmZXJlbmNlIHJvd3MgLSBjcmFkbGUgZmlyc3QvbGFzdDsgYXhpczsgbGlzdCBlbmRcbiAgICAgICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvdyA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudCksXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3cgPSBheGlzUmVmZXJlbmNlUm93IC0gaGVhZFJvd0NvdW50LFxuICAgICAgICAgICAgY3JhZGxlTGFzdFJvdyA9IGF4aXNSZWZlcmVuY2VSb3cgKyAodGFpbFJvd0NvdW50IC0gMSksXG4gICAgICAgICAgICBsaXN0TGFzdFJvdyA9IGxpc3RSb3djb3VudCAtIDFcblxuICAgICAgICBjb25zdCBwcmVDcmFkbGVSb3dDb3VudCA9IGNyYWRsZVJlZmVyZW5jZVJvdyxcbiAgICAgICAgICAgIHBvc3RDcmFkbGVSb3dDb3VudCA9IGxpc3RMYXN0Um93IC0gY3JhZGxlTGFzdFJvd1xuXG4gICAgICAgIC8vIGJhc2UgcGl4ZWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IGJhc2VDZWxsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoXG4gICAgICAgICAgICApICsgZ2FwXG5cbiAgICAgICAgY29uc3QgbWVhc3VyZWRUYWlsTGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdGFpbEdyaWRFbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQub2Zmc2V0V2lkdGhcblxuICAgICAgICBjb25zdCBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoID0gcG9zdENyYWRsZVJvd0NvdW50ICogYmFzZUNlbGxMZW5ndGhcblxuICAgICAgICBjb25zdCBjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGggPSBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoICsgbWVhc3VyZWRUYWlsTGVuZ3RoXG5cbiAgICAgICAgLy8gYmFzZSBmaWd1cmVzIHVzZWQgZm9yIHByZUF4aXMgI3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCByZXBvc2l0aW9uaW5nLCB3aGljaCB1c2VzIGJhc2UgZmlndXJlc1xuICAgICAgICBjb25zdCBiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoID0gKChwcmVDcmFkbGVSb3dDb3VudCArIGhlYWRSb3dDb3VudCkgKiBiYXNlQ2VsbExlbmd0aCkgKyBwYWRkaW5nXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBsYXlvdXQgYWRqdXN0bWVudHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWVcblxuICAgICAgICBjb25zdCBjb21wdXRlZFNjcm9sbGJsb2NrTGVuZ3RoID0gYmFzZVByZUF4aXNQaXhlbExlbmd0aCArIGNvbXB1dGVkUG9zdEF4aXNQaXhlbExlbmd0aFxuICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9IGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGggLSBheGlzVmlld3BvcnRPZmZzZXRcbiAgICAgICAgY29uc3QgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ID0gYmxvY2tTY3JvbGxQb3MgKyBheGlzVmlld3BvcnRPZmZzZXQgLy8gaWUuIGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgsIGJ1dCBzZW1hbnRpY3NcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29tcHV0ZWRTY3JvbGxibG9ja0xlbmd0aCkgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdBeGlzU2Nyb2xsYmxvY2tPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU2Nyb2xsYmxvY2tMZW5ndGggKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgc2Nyb2xsUG9zIGFkanVzdG1lbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRSb3dDb3VudD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWFkR3JpZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRSb3dDb3VudD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke2dhcH1weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAwcHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1NhZmFyaUlPUygpKSB7IC8vIGFkanVzdCBibG9ja1Njcm9sbFBvcyBkaXJlY3RseSAtIG1vc3QgYnJvd3NlcnMgaW5jbHVkaW5nIFNhZmFyaSBkZXNrdG9wXG5cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKGJsb2NrU2Nyb2xsUG9zKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBTYWZhcmkgaU9TXG5cbiAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IGFkanVzdCBzY3JvbGxibG9ja0VsZW1lbnQgb2Zmc2V0OyBpT1NvbkFmdGVyU2Nyb2xsIHRyYW5zZmVycyBzaGlmdCB0byBibG9ja1Njcm9sbFBvc1xuICAgICAgICAgICAgLy8gLSBkaXJlY3QgY2hhbmdlIG9mIHNjcm9sbFRvcC9TY3JvbGxMZWZ0IGluIFNhZmFyaSBpT1MgaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlciBtb21lbnR1bSBlbmdpbmVcblxuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdTY3JvbGxQb3MgPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBibG9ja1Njcm9sbFBvcyAtIHN0YXJ0aW5nU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gLXNjcm9sbERpZmYgKyAncHgnXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxEaWZmICsgJ3B4J1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBnb3RvSW5kZXggb3IgcmVzaXplIG92ZXJzaG9vdFxuICAgICAgICBpZiAoKHNvdXJjZSA9PSAnc2V0Y3JhZGxlJykgJiYgIXBvc3RDcmFkbGVSb3dDb3VudCkgeyBcblxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aFxuXG4gICAgICAgICAgICBjb25zdCBhbGlnbmVkRW5kUG9zRGlmZiA9IFxuICAgICAgICAgICAgICAgIGF4aXNWaWV3cG9ydE9mZnNldCArIG1lYXN1cmVkVGFpbExlbmd0aCAtIHZpZXdwb3J0TGVuZ3RoXG5cbiAgICAgICAgICAgIGlmIChhbGlnbmVkRW5kUG9zRGlmZiA8IDApIHsgLy8gZmlsbCB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydCB1c2luZyBzY3JvbGxCeVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnlZID0gXG4gICAgICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduZWRFbmRQb3NEaWZmOlxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnlYID1cbiAgICAgICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduZWRFbmRQb3NEaWZmXG5cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsQnkoc2Nyb2xsQnlYLCBzY3JvbGxCeVkpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFsgSU5URVJOQUwgQ09OVEVOVCBNQU5BR0VNRU5UIFNFUlZJQ0VTIF09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyA9ICgpID0+IHsgXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZU1heCwgTUFYX0NBQ0hFX09WRVJfUlVOIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgbW9kZWxDb21wb25lbnRMaXN0ID0gdGhpcy5jb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50c1xuIFxuICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLmd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nKGNhY2hlTWF4LCBtb2RlbENvbXBvbmVudExpc3QubGVuZ3RoLCBNQVhfQ0FDSEVfT1ZFUl9SVU4gKSkge1xuXG4gICAgICAgICAgICB0aGlzLnBhcmVDYWNoZVRvTWF4KClcblxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBwYXJlQ2FjaGVUb01heCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIHNjcm9sbGVySUQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcbiAgICAgICAgXG4gICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUhhbmRsZXJzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gY3JhZGxlSGFuZGxlcnNcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSB0aGlzLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIEVYVEVSTkFMIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN1cHBvcnRzIGNsZWFyQ2FjaGVcbiAgICBwdWJsaWMgY2xlYXJDcmFkbGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuICAgICAgICAvLyBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2VIYW5kbGVyIGdldENyYWRsZUluZGV4TWFwXG4gICAgLy8gYWxzbyBzdXBwb3J0cyBwYXJlQ2FjaGVUb01heCwgbWF0Y2hDYWNoZVRvQ3JhZGxlXG4gICAgcHVibGljIGdldE1vZGVsSW5kZXhMaXN0KCkge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBpZiAoIWNyYWRsZU1vZGVsQ29tcG9uZW50cykge1xuXG4gICAgICAgICAgICByZXR1cm4gW10gXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5tYXAoKGl0ZW0pPT5pdGVtLnByb3BzLmluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdldCBpbmRleFNwYW4oKSB7XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuICAgICAgICBcbiAgICAgICAgaWYgKGNyYWRsZU1vZGVsQ29tcG9uZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIFtdXG5cbiAgICAgICAgY29uc3QgbG93SW5kZXggPSAgY3JhZGxlTW9kZWxDb21wb25lbnRzWzBdLnByb3BzLmluZGV4XG4gICAgICAgIGNvbnN0IGhpZ2hJbmRleCA9IGxvd0luZGV4ICsgKGNyYWRsZU1vZGVsQ29tcG9uZW50cy5sZW5ndGggLSAxKVxuICAgICAgICByZXR1cm4gW2xvd0luZGV4LCBoaWdoSW5kZXhdXG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBzZXJ2aWNlIGhhbmRsZXIncyByZW1hcEluZGV4ZXMsIGFzIGxhc3Qgc3RlcFxuICAgIHB1YmxpYyByZWNvbmNpbGVDZWxsRnJhbWVzKG1vZGlmaWVkSW5kZXhlc0xpc3QpIHtcblxuICAgICAgICBpZiAoIW1vZGlmaWVkSW5kZXhlc0xpc3QubGVuZ3RoKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnRGbiAoY29tcG9uZW50LCBpLCBhcnJheSApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIGl0ZW1JRCB9ID0gY29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRleGVzTGlzdC5pbmNsdWRlcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IFxuICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCk/XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtSUQgIT0gaXRlbUlEKSB7IC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGhhcHBlblxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc0NvbXBvbmVudEZuKVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBtb3ZlSW5kZXggYW5kIGluc2VydFJlbW92ZUluZGV4LCB1cGRhdGVzIGNyYWRsZSBjb250aWd1b3VzIGl0ZW1zIGZyb20gc3RhcnRDaGFuZ2VJbmRleCBvciBzdGFydCBvZiBjcmFkbGVcbiAgICBwdWJsaWMgc3luY2hyb25pemVDcmFkbGVJdGVtSURzVG9DYWNoZSh1cGRhdGVkSW5kZXhMaXN0LCBpc0luc2VydFJlbW92ZSA9IDAsIHN0YXJ0Q2hhbmdlSW5kZXggPSBudWxsKSB7IC8vIDAgPSBtb3ZlXG5cbiAgICAgICAgLy8gYXNzc2VtYmxlIHJlc291cmNlc1xuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICAvLyBhc3NlbWJsZSBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGluZGV4U3BhbiA9IHRoaXMuaW5kZXhTcGFuXG5cbiAgICAgICAgaWYgKGluZGV4U3Bhbi5sZW5ndGggPT0gMCkgcmV0dXJuIC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGJlIGhlcmVcblxuICAgICAgICBjb25zdCBbbG93U3BhbixoaWdoU3Bhbl0gPSBpbmRleFNwYW5cblxuICAgICAgICBsZXQgc3RhcnRJbmRleCwgZW5kSW5kZXhcbiAgICAgICAgaWYgKGlzSW5zZXJ0UmVtb3ZlKSB7XG5cbiAgICAgICAgICAgIGlmIChzdGFydENoYW5nZUluZGV4ID4gaGlnaFNwYW4pIHJldHVyblxuXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gc3RhcnRDaGFuZ2VJbmRleFxuICAgICAgICAgICAgZW5kSW5kZXggPSBoaWdoU3BhblxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG1vdmVcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZWRJbmRleExpc3QubGVuZ3RoID09IDApIHJldHVyblxuXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gdXBkYXRlZEluZGV4TGlzdFswXVxuICAgICAgICAgICAgZW5kSW5kZXggPSB1cGRhdGVkSW5kZXhMaXN0LmF0KC0xKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkU3BhbiA9IGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDFcblxuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHN0YXJ0SW5kZXhcblxuICAgICAgICBpZiAoZmlyc3RJbmRleCA+IGhpZ2hTcGFuKSByZXR1cm5cblxuICAgICAgICBpZiAoZmlyc3RJbmRleCA8IGxvd1NwYW4pIGZpcnN0SW5kZXggPSBsb3dTcGFuXG5cbiAgICAgICAgY29uc3QgbG93UHRyID0gZmlyc3RJbmRleCAtIGxvd1NwYW5cblxuICAgICAgICBjb25zdCBoaWdoUHRyID0gaXNJbnNlcnRSZW1vdmU/XG4gICAgICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMubGVuZ3RoIC0gMTpcbiAgICAgICAgICAgIE1hdGgubWluKGNyYWRsZU1vZGVsQ29tcG9uZW50cy5sZW5ndGggLSAxLGxvd1B0ciArIHVwZGF0ZWRTcGFuIC0gMSlcblxuICAgICAgICAvLyBmdW5jdGlvbiB0byB1cGRhdGUgaW5kaXZpZHVhbCBjcmFkbGUgY29tcG9uZW50cyB0byBjYWNoZSBjaGFuZ2VzXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Njb21wb25lbnRGbihjb21wb25lbnQsIGNvbXBvbmVudHB0ciwgY29tcG9uZW50YXJyYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQucHJvcHMuaW5kZXhcblxuICAgICAgICAgICAgY29uc3QgY2FjaGVJdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcblxuICAgICAgICAgICAgLy8gaWYgY2FjaGUgaGFzIG5vIGNvbXBvbmVudCBmb3IgY3JhZGxlIGl0ZW0sIHRoZW4gZ2V0IG9uZVxuICAgICAgICAgICAgaWYgKGNhY2hlSXRlbUlEID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IGNhY2hlSGFuZGxlci5nZXROZXdJdGVtSUQoKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudGFycmF5W2NvbXBvbmVudHB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG4gICAgICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIG1hdGNoIGNhY2hlIGl0ZW1JRCB0byBjcmFkbGUgY29tcG9uZW50IGl0ZW1JRFxuXG4gICAgICAgICAgICAgICAgY29uc3QgY3JhZGxlSXRlbUlEID0gY29tcG9uZW50LnByb3BzLml0ZW1JRFxuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlcHRyID0gdXBkYXRlZEluZGV4TGlzdC5pbmRleE9mKGluZGV4KSAvLyBUT0RPIHZlcmlmeSBuZWVkIGZvciB1cGRhdGVsaXN0XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcHRyICE9IC0xKSB7IC8vIHVwZGF0ZSBsaXN0IGNvbmZpcm1zIHRoZXJlIGlzIGEgY2FjaGUgaXRlbSBmb3IgdGhpcyBpbmRleFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUl0ZW1JRCA9PSBjcmFkbGVJdGVtSUQpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudGFycmF5W2NvbXBvbmVudHB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOmNhY2hlSXRlbUlEfSlcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld0l0ZW1JRCgpXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudGFycmF5W2NvbXBvbmVudHB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcHRyID0gbG93UHRyOyBwdHIgPD0gaGlnaFB0cjsgcHRyKyspIHtcbiAgICAgICAgICAgIHByb2Nlc3Njb21wb25lbnRGbihjcmFkbGVNb2RlbENvbXBvbmVudHNbcHRyXSwgcHRyLCBjcmFkbGVNb2RlbENvbXBvbmVudHMpXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIGluc2VydFJlbW92ZUluZGV4XG4gICAgcHVibGljIGNyZWF0ZU5ld0l0ZW1JRHMobmV3TGlzdCkge1xuXG4gICAgICAgIGlmICghbmV3TGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgY29uc3QgaW5kZXhTcGFuID0gdGhpcy5pbmRleFNwYW5cbiAgICAgICAgaWYgKGluZGV4U3Bhbi5sZW5ndGggPT0gMCkgcmV0dXJuIC8vIGRlZmVuc2l2ZVxuXG4gICAgICAgIGNvbnN0IFtsb3dTcGFuLCBoaWdoU3Bhbl0gPSBpbmRleFNwYW5cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzY29tcG9uZW50Rm4obmV3bGlzdGluZGV4KSB7XG5cbiAgICAgICAgICAgIGlmIChuZXdsaXN0aW5kZXggPCBsb3dTcGFuIHx8IG5ld2xpc3RpbmRleCA+IGhpZ2hTcGFuKSByZXR1cm4gLy8gZGVmZW5zaXZlXG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZVB0ciA9IG5ld2xpc3RpbmRleCAtIGxvd1NwYW5cblxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY3JhZGxlTW9kZWxDb21wb25lbnRzW2NyYWRsZVB0cl1cblxuICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld0l0ZW1JRCgpXG5cbiAgICAgICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50c1tjcmFkbGVQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50Rm4pXG5cbiAgICAgICAgbmV3TGlzdC5mb3JFYWNoKHByb2Nlc3Njb21wb25lbnRGbilcblxuICAgIH1cblxufSJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiTnVtYmVyIiwicmVhY3RfMSIsIl9faW1wb3J0RGVmYXVsdCIsInJlcXVpcmUiLCJjb250ZW50ZnVuY3Rpb25zXzEiLCJJbmZpbml0ZUdyaWRTY3JvbGxlcl8xIiwiQ29udGVudEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJjb250ZW50IiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJpbnN0YW5jZUlkQ291bnRlclJlZiIsImN1cnJlbnQiLCJ1cGRhdGVMaXN0c2l6ZSIsIm5ld2xpc3RzaXplIiwiY3JhZGxlQ29udGVudCIsImNsZWFyQ3JhZGxlIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwic2V0Q3JhZGxlQ29udGVudCIsImNyYWRsZVN0YXRlIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUhhbmRsZXJzIiwiaGFuZGxlcnNSZWYiLCJjYWNoZUhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsInJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsInN0eWxlcyIsInBsYWNlaG9sZGVyTWVzc2FnZXMiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJsaXN0Um93Y291bnQiLCJ3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCIsIk1hdGgiLCJtaW4iLCJpbmNsdWRlcyIsIndvcmtpbmdDb250ZW50TGlzdCIsImJhc2VSb3dMZW5ndGgiLCJfcmVmIiwiY2FsY3VsYXRlQ29udGVudExpc3RSZXF1aXJlbWVudHMiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCIsImNyYWRsZUNvbnRlbnRDb3VudCIsIm5ld0NyYWRsZUNvbnRlbnRDb3VudCIsInNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsInRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsInNjcm9sbGJsb2NrRWxlbWVudCIsImZpcnN0Q2hpbGQiLCJiYXNlbGVuZ3RoIiwic3R5bGUiLCJsZWZ0IiwidG9wIiwiaGVpZ2h0Iiwid2lkdGgiLCJheGlzVmlld3BvcnRQaXhlbE9mZnNldCIsIl9yZWYyIiwiZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCIsImNyYWRsZVJlZmVyZW5jZUluZGV4IiwibGlzdFN0YXJ0Q2hhbmdlQ291bnQiLCJsaXN0RW5kQ2hhbmdlQ291bnQiLCJfcmVmMyIsIm5ld2NvbnRlbnRsaXN0IiwiX3JlZjQiLCJhbGxvY2F0ZUNvbnRlbnRMaXN0IiwiY29udGVudGxpc3QiLCJheGlzUmVmZXJlbmNlSW5kZXgiLCJfcmVmNSIsImhlYWRjb250ZW50bGlzdCIsInRhaWxjb250ZW50bGlzdCIsImNhbGxiYWNrcyIsInJlZmVyZW5jZUluZGV4Q2FsbGJhY2siLCJjc3RhdGUiLCJibG9ja1Njcm9sbFBvcyIsInJlc2V0U2Nyb2xsRGF0YSIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiaGVhZEVsZW1lbnQiLCJoZWFkUmVmIiwiYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQiLCJjb25jYXQiLCJ1cGRhdGVDcmFkbGVDb250ZW50IiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyIiwic3RhdGVIYW5kbGVyIiwiaW50ZXJydXB0SGFuZGxlciIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MiLCJjYWNoZSIsImxheW91dCIsInNjcm9sbFBvcyIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJtb2RlbGNvbnRlbnRsaXN0Iiwib2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJfYSIsImluZGV4IiwiX3JlZjYiLCJjYWxjdWxhdGVTaGlmdFNwZWNzIiwiY3JhZGxlSXRlbVNoaWZ0IiwiY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0IiwibmV3QXhpc1JlZmVyZW5jZUluZGV4IiwiYXhpc0l0ZW1TaGlmdCIsImF4aXNSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImlzU2hpZnQiLCJ0cmlnZ2VybGluZXNJbnRlcnNlY3QiLCJkaXNjb25uZWN0IiwiYXBwbHlTdHlsaW5nIiwiaGVhZGNvbnRlbnQiLCJ1cGRhdGVkQ29udGVudExpc3QiLCJkZWxldGVkQ29udGVudEl0ZW1zIiwiX3JlZjciLCJfcmVmOCIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwiZGVsZXRlUG9ydGFscyIsIl9yZWY5IiwiX3JlZjEwIiwidGFpbGNvbnRlbnQiLCJjcmFkbGVTdGF0ZVJlZiIsInJlbmRlclBvcnRhbExpc3RzIiwiX3JlZjExIiwicHJlQXhpc1Jvd3MiLCJjZWlsIiwiYmFzZUNlbGxMZW5ndGgiLCJ0ZXN0U2Nyb2xsUG9zIiwic2Nyb2xsRGlmZiIsInRvcFBvcyIsImxlZnRQb3MiLCJhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5Iiwic291cmNlIiwiaGVhZEdyaWRFbGVtZW50IiwidGFpbEdyaWRFbGVtZW50IiwidGFpbFJlZiIsImF4aXNWaWV3cG9ydE9mZnNldCIsImhlYWRSb3dDb3VudCIsImNoaWxkTm9kZXMiLCJ0YWlsUm93Q291bnQiLCJheGlzUmVmZXJlbmNlUm93IiwiY3JhZGxlUmVmZXJlbmNlUm93IiwiY3JhZGxlTGFzdFJvdyIsImxpc3RMYXN0Um93IiwicHJlQ3JhZGxlUm93Q291bnQiLCJwb3N0Q3JhZGxlUm93Q291bnQiLCJtZWFzdXJlZFRhaWxMZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImJhc2VQb3N0Q3JhZGxlUGl4ZWxMZW5ndGgiLCJjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGgiLCJiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoIiwic2lnbmFscyIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJjb21wdXRlZFNjcm9sbGJsb2NrTGVuZ3RoIiwibmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0IiwiaXNTYWZhcmlJT1MiLCJzdGFydGluZ1Njcm9sbFBvcyIsInZpZXdwb3J0TGVuZ3RoIiwiYWxpZ25lZEVuZFBvc0RpZmYiLCJzY3JvbGxCeVkiLCJzY3JvbGxCeVgiLCJzY3JvbGxCeSIsImd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyMiIsImNhY2hlTWF4IiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwibW9kZWxDb21wb25lbnRMaXN0IiwicGFyZUNhY2hlVG9NYXgiLCJzY3JvbGxlcklEIiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsIm1hcCIsIml0ZW0iLCJnZXQiLCJsb3dJbmRleCIsImhpZ2hJbmRleCIsInJlY29uY2lsZUNlbGxGcmFtZXMiLCJtb2RpZmllZEluZGV4ZXNMaXN0IiwiaW5kZXhUb0l0ZW1JRE1hcCIsImNhY2hlUHJvcHMiLCJwcm9jZXNzQ29tcG9uZW50Rm4iLCJjb21wb25lbnQiLCJhcnJheSIsIl9jb21wb25lbnQkcHJvcHMiLCJpdGVtSUQiLCJuZXdJdGVtSUQiLCJoYXMiLCJnZXROZXdJdGVtSUQiLCJjbG9uZUVsZW1lbnQiLCJmb3JFYWNoIiwic3luY2hyb25pemVDcmFkbGVJdGVtSURzVG9DYWNoZSIsInVwZGF0ZWRJbmRleExpc3QiLCJpc0luc2VydFJlbW92ZSIsImFyZ3VtZW50cyIsInN0YXJ0Q2hhbmdlSW5kZXgiLCJpbmRleFNwYW4iLCJfaW5kZXhTcGFuIiwibG93U3BhbiIsImhpZ2hTcGFuIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiYXQiLCJ1cGRhdGVkU3BhbiIsImZpcnN0SW5kZXgiLCJsb3dQdHIiLCJoaWdoUHRyIiwicHJvY2Vzc2NvbXBvbmVudEZuIiwiY29tcG9uZW50cHRyIiwiY29tcG9uZW50YXJyYXkiLCJjYWNoZUl0ZW1JRCIsImNyYWRsZUl0ZW1JRCIsInVwZGF0ZXB0ciIsImluZGV4T2YiLCJwdHIiLCJjcmVhdGVOZXdJdGVtSURzIiwibmV3TGlzdCIsIl9pbmRleFNwYW4yIiwibmV3bGlzdGluZGV4IiwiY3JhZGxlUHRyIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n')},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\n// interrupthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleIntersectionObserverCallback: responds to the move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback: responds to crossing of tailward or headward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing interrupts are handled by viewport\n*/\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ "./src/cradle/contentfunctions.tsx");\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, InterruptHandler);\n  this.isHeadCradleInView = true;\n  this.isTailCradleInView = true;\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    var _a;\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n    var testrootbounds = entries[0].rootBounds;\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      contentHandler = _this$cradleParameter.contentHandler,\n      stateHandler = _this$cradleParameter.stateHandler,\n      scrollHandler = _this$cradleParameter.scrollHandler,\n      layoutHandler = _this$cradleParameter.layoutHandler;\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n      scrollData.previousupdate = scrollData.currentupdate;\n      scrollData.currentupdate = scrollData.current;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation;\n      var triggerHistoryRef = cradleInternalProperties.triggerHistoryRef,\n        listsize = cradleInternalProperties.listsize,\n        crosscount = cradleInternalProperties.crosscount;\n      var scrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      var contentLength = orientation == \'vertical\' ? viewportElement.scrollHeight : viewportElement.scrollWidth;\n      var viewportLength = orientation == \'vertical\' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n      // for browser top or bottom bounce\n      // fractional pixels can cause this to fail, hence Math.floor)\n      if (scrollPos >= 0 || Math.floor(scrollPos + viewportLength) <= contentLength) {\n        var viewportBoundingRect = viewportElement.getBoundingClientRect();\n        var _ref = (0, contentfunctions_1.calculateShiftInstruction)({\n            scrollerID: cradleInheritedProperties.scrollerID,\n            orientation: orientation,\n            triggerlineEntries: entries,\n            triggerlineSpan: layoutHandler.triggerlineSpan,\n            isFirstRowTriggerConfig: layoutHandler.triggercellIsInTail,\n            viewportBoundingRect: viewportBoundingRect,\n            triggerHistoryRef: triggerHistoryRef\n          }),\n          _ref2 = _slicedToArray(_ref, 2),\n          shiftinstruction = _ref2[0],\n          triggerViewportReferencePos = _ref2[1];\n        if (shiftinstruction == \'moveaxistailward\') {\n          // filter out oversize last row\n          var lastListRowOffset = Math.ceil(listsize / crosscount) - 1;\n          var tailcontentlist = contentHandler.content.tailModelComponents;\n          var previousAxisReferenceIndex = ((_a = tailcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n          var previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n          if (lastListRowOffset == previousAxisRowOffset) return;\n        }\n        // none == nothing to do\n        if (shiftinstruction != \'none\') {\n          _this.shiftinstruction = shiftinstruction;\n          _this.triggerViewportReferencePos = triggerViewportReferencePos;\n          stateHandler.setCradleState(\'renderupdatedcontent\');\n        }\n      }\n    }\n  };\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler,\n      scrollHandler = _this$cradleParameter2.scrollHandler,\n      layoutHandler = _this$cradleParameter2.layoutHandler;\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (entry.target.dataset.type == \'head\') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (_this.signals.repositioningRequired)\n      // start reposition if no other interrupts are underway\n      {\n        _this.isHeadCradleInView = true;\n        _this.isTailCradleInView = true;\n        var cradleState = stateHandler.cradleStateRef.current;\n        if (![\'repositioningRender\', \'repositioningContinuation\', \'finishreposition\', \'renderupdatedcontent\', \'finishupdatedcontent\', \'finishviewportresize\'].includes(cradleState) && !ViewportContextProperties.isResizing) {\n          var viewportElement = ViewportContextProperties.elementRef.current;\n          var _this$cradleParameter3 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n            scrollerID = _this$cradleParameter3.scrollerID,\n            layout = _this$cradleParameter3.layout;\n          if (!viewportElement) {\n            console.log(\'SYSTEM: viewport element not set in cradleIntersectionObserverCallback\', scrollerID, ViewportContextProperties);\n            return;\n          }\n          // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n          // and getViewportDimensions in Cradle for width/height\n          var rect = viewportElement.getBoundingClientRect();\n          var top = rect.top,\n            right = rect.right,\n            bottom = rect.bottom,\n            left = rect.left;\n          var width = right - left,\n            height = bottom - top;\n          // update for scrolltracker\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          if (layout == \'variable\') {\n            // restore base config to scrollblock\n            layoutHandler.restoreBaseScrollblockConfig();\n            scrollHandler.calcImpliedRepositioningData(\'restoreBaseScrollblockConfig\');\n          }\n          _this.signals.pauseTriggerlinesObserver = true;\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState(\'startreposition\');\n        } else {\n          _this.signals.repositioningRequired = false;\n        }\n      }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.cradleIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n      _this.cradleIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.cradleIntersect.observer.disconnect();\n      _this.cradleIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.triggerlinesIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n      _this.triggerlinesIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.triggerlinesIntersect.observer.disconnect();\n      _this.triggerlinesIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports["default"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLENBQUM2RyxxQkFBcUIsQ0FBQ2QsUUFBUTtJQUM5QztHQUNIO0VBRU0sS0FBQTFGLE9BQU8sR0FBRztJQUNicUUscUJBQXFCLEVBQUUsS0FBSztJQUM1QnBFLHlCQUF5QixFQUFFLEtBQUs7SUFDaEMrRCwrQkFBK0IsRUFBQyxLQUFLO0lBQ3JDMkMseUJBQXlCLEVBQUUsS0FBSztJQUNoQ0MscUJBQXFCLEVBQUU7R0FDMUI7RUFFRDs7Ozs7Ozs7OztFQVVPLEtBQUFDLGVBQWUsR0FBRyxZQUFLO0lBQzFCLElBQVE3RyxPQUFPLEdBQUtMLEtBQUksQ0FBaEJLLE9BQU87SUFDZkEsT0FBTyxDQUFDQyx5QkFBeUIsR0FBRyxJQUFJO0lBQ3hDRCxPQUFPLENBQUNnRSwrQkFBK0IsR0FBRyxJQUFJO0lBQzlDaEUsT0FBTyxDQUFDMkcseUJBQXlCLEdBQUcsSUFBSTtJQUN4QzNHLE9BQU8sQ0FBQzRHLHFCQUFxQixHQUFHLElBQUk7RUFDeEMsQ0FBQztFQUNEOzs7OztFQUtPLEtBQUFFLGlCQUFpQixHQUFHLFlBQUs7SUFDNUIsSUFBUTlHLE9BQU8sR0FBS0wsS0FBSSxDQUFoQkssT0FBTztJQUNmQSxPQUFPLENBQUNDLHlCQUF5QixHQUFHLEtBQUs7SUFDekNELE9BQU8sQ0FBQ2dFLCtCQUErQixHQUFHLEtBQUs7SUFDL0NoRSxPQUFPLENBQUMyRyx5QkFBeUIsR0FBRyxLQUFLO0lBQ3pDM0csT0FBTyxDQUFDNEcscUJBQXFCLEdBQUcsS0FBSztFQUN6QyxDQUFDO0VBNVRFLElBQUksQ0FBQ2xILGdCQUFnQixHQUFHQSxnQkFBZ0I7QUFFM0MsQ0FBQztBQU5McUgsa0JBQUEsR0FBQXRILGdCQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvaW50ZXJydXB0aGFuZGxlci50c3g/YTk2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbnRlcnJ1cHRoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBob2xkcyB0aGUgY2FsbGJhY2tzIGZvciB0aGUgQ3JhZGxlIHN0cnVjdHVyZSBsaXN0ZW5lcnM6XG4gICAgLSBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrOiByZXNwb25kcyB0byB0aGUgbW92ZSBvZiBib3RoIGNyYWRsZSBncmlkcyBvdXRzaWRlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMgaW5pdGlhdGVzIHRoZSByZXBvc2l0aW9uaW5nIHByb3RvY29sXG4gICAgLSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjazogcmVzcG9uZHMgdG8gY3Jvc3Npbmcgb2YgdGFpbHdhcmQgb3IgaGVhZHdhcmQgdHJpZ2dlcmxpbmVzXG4gICAgICAgIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydCwgYW5kIHRyaWdnZXJzIHJvbGxvdmVyIGFuZCByZS1hbGxvY2F0aW9uIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICB2aWV3cG9ydFJlc2l6aW5nIGludGVycnVwdHMgYXJlIGhhbmRsZWQgYnkgdmlld3BvcnRcbiovXG5cbmltcG9ydCB7IGNhbGN1bGF0ZVNoaWZ0SW5zdHJ1Y3Rpb259IGZyb20gJy4vY29udGVudGZ1bmN0aW9ucydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJydXB0SGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHByaXZhdGUgaXNIZWFkQ3JhZGxlSW5WaWV3ID0gdHJ1ZVxuICAgIHByaXZhdGUgaXNUYWlsQ3JhZGxlSW5WaWV3ID0gdHJ1ZVxuXG4gICAgcHJpdmF0ZSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyKSB7IFxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdHJvb3Rib3VuZHMgPSBlbnRyaWVzWzBdLnJvb3RCb3VuZHNcbiAgICAgICAgaWYgKCh0ZXN0cm9vdGJvdW5kcy53aWR0aCA9PSAwKSAmJiAodGVzdHJvb3Rib3VuZHMuaGVpZ2h0ID09IDApKSB7IC8vIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbERhdGEgfSA9IHNjcm9sbEhhbmRsZXJcblxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZVxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50XG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuXG4gICAgICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnlSZWYsXG4gICAgICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCxcblxuICAgICAgICAgICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxQb3MgPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxXaWR0aFxuXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydExlbmd0aCA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG5cbiAgICAgICAgICAgIC8vIGZvciBicm93c2VyIHRvcCBvciBib3R0b20gYm91bmNlXG4gICAgICAgICAgICAvLyBmcmFjdGlvbmFsIHBpeGVscyBjYW4gY2F1c2UgdGhpcyB0byBmYWlsLCBoZW5jZSBNYXRoLmZsb29yKVxuICAgICAgICAgICAgaWYgKCAoc2Nyb2xsUG9zID49IDApIHx8IChNYXRoLmZsb29yKHNjcm9sbFBvcyArIHZpZXdwb3J0TGVuZ3RoKSA8PSBjb250ZW50TGVuZ3RoKSkgeyBcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0Qm91bmRpbmdSZWN0ID0gdmlld3BvcnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBbc2hpZnRpbnN0cnVjdGlvbiwgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zXSA9IGNhbGN1bGF0ZVNoaWZ0SW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEOiBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLnNjcm9sbGVySUQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZUVudHJpZXM6ZW50cmllcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmxpbmVTcGFuOiBsYXlvdXRIYW5kbGVyLnRyaWdnZXJsaW5lU3BhbixcblxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZzpsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwsXG5cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRCb3VuZGluZ1JlY3QsIC8vIFNhZmFyaSBkb2Vzbid0IGNvcnJlY3RseSBtZWFzdXJlIHpvb20gZm9yIHJvb3Rib3VuZHMgaW4gdHJpZ2dlcmxpbmVFbnRyaWVzXG5cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnlSZWYsXG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzdGFpbHdhcmQnKSB7IC8vIGZpbHRlciBvdXQgb3ZlcnNpemUgbGFzdCByb3dcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TGlzdFJvd09mZnNldCA9IE1hdGguY2VpbChsaXN0c2l6ZS9jcm9zc2NvdW50KSAtIDFcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWlsY29udGVudGxpc3QgPSBjb250ZW50SGFuZGxlci5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXggPSAodGFpbGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdExpc3RSb3dPZmZzZXQgPT0gcHJldmlvdXNBeGlzUm93T2Zmc2V0KSByZXR1cm5cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vbmUgPT0gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uICE9ICdub25lJykgeyBcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0aW5zdHJ1Y3Rpb24gPSBzaGlmdGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zID0gdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zXG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZW5kZXJ1cGRhdGVkY29udGVudCcpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGEgdHJhbnNmZXIgdG8gdXBkYXRlQ3JhZGxlQ29udGVudCB0cmlnZ2VyZWQgYnkgY2xvc2luZyBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayBzZXRDcmFkbGVTdGF0ZSBjYWxsXG4gICAgc2hpZnRpbnN0cnVjdGlvblxuICAgIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvc1xuXG4gICAgcHJpdmF0ZSBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcblxuICAgICAgICBjb25zdCBzaWduYWxzID0gdGhpcy5zaWduYWxzXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIHN0YXRlSGFuZGxlciwgXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlciwgXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLCBcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIgXG5cbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWRDcmFkbGVJblZpZXcgPSBcbiAgICAgICAgICAgICAgICAgICAgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUYWlsQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyAgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGVudHJ5LnJvb3RCb3VuZHMud2lkdGggPT0gMCkgJiYgKGVudHJ5LnJvb3RCb3VuZHMuaGVpZ2h0ID09IDApKSAvLyByZXBhcmVudGluZ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSAoIXRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ICYmICF0aGlzLmlzVGFpbENyYWRsZUluVmlldylcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkKSAvLyBzdGFydCByZXBvc2l0aW9uIGlmIG5vIG90aGVyIGludGVycnVwdHMgYXJlIHVuZGVyd2F5XG4gICAgICAgIHtcblxuICAgICAgICAgICAgdGhpcy5pc0hlYWRDcmFkbGVJblZpZXcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmlzVGFpbENyYWRsZUluVmlldyA9IHRydWVcbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgaWYgKFxuXG4gICAgICAgICAgICAgICAgICAgICFbJ3JlcG9zaXRpb25pbmdSZW5kZXInLCdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywnZmluaXNocmVwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVuZGVydXBkYXRlZGNvbnRlbnQnLCdmaW5pc2h1cGRhdGVkY29udGVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmluaXNodmlld3BvcnRyZXNpemUnXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkgJiZcblxuICAgICAgICAgICAgICAgICAgICAhVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nXG5cbiAgICAgICAgICAgICAgICApIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySUQsIFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQsIC8vIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFkZGluZywgZ2FwLFxuICAgICAgICAgICAgICAgICAgICAvLyBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsXG5cbiAgICAgICAgICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTWVNURU06IHZpZXdwb3J0IGVsZW1lbnQgbm90IHNldCBpbiBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySUQsVmlld3BvcnRDb250ZXh0UHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbnMgd2l0aCBjcmFkbGUgaW50ZXJzZWN0aW9uLiBTZWUgYWxzbyBkaW1lbnNpb24gdXBkYXRlIGluIHZpZXdwb3J0LnRzeCBmb3IgcmVzaXplXG4gICAgICAgICAgICAgICAgLy8gYW5kIGdldFZpZXdwb3J0RGltZW5zaW9ucyBpbiBDcmFkbGUgZm9yIHdpZHRoL2hlaWdodFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB2aWV3cG9ydEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9ID0gcmVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0LCBoZWlnaHQgPSBib3R0b20gLSB0b3BcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb3Igc2Nyb2xsdHJhY2tlclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zID0ge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0gXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayh0cnVlKVxuXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndmFyaWFibGUnKSB7IC8vIHJlc3RvcmUgYmFzZSBjb25maWcgdG8gc2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLnJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcoKVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxIYW5kbGVyLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEoJ3Jlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcnKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgIHB1YmxpYyBjcmFkbGVJbnRlcnNlY3QgPSB7ICAgIFxuICAgICAgICBvYnNlcnZlcjpudWxsLCAgICBcbiAgICAgICAgY2FsbGJhY2s6dGhpcy5jcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6dHJ1ZSxcbiAgICAgICAgY29ubmVjdEVsZW1lbnRzOigpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OigpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKSAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICB9XG4gICAgfVxuXG4gICBwdWJsaWMgdHJpZ2dlcmxpbmVzSW50ZXJzZWN0ID0ge1xuICAgICAgICBvYnNlcnZlcjpudWxsLFxuICAgICAgICBjYWxsYmFjazp0aGlzLmF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6dHJ1ZSxcbiAgICAgICAgY29ubmVjdEVsZW1lbnRzOigpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIGlmIChjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OigpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2lnbmFscyA9IHtcbiAgICAgICAgcmVwb3NpdGlvbmluZ1JlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlcjogZmFsc2UsIFxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyOmZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvciBcbiAgICAgICAgY3JhZGxlOlxuICAgICAgICAtIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgIC0gdHJpZ2dlciBjcmFkbGVyZXNpemluZ1xuICAgICAgICAtIHRyaWdnZXIgcmVjb25maWd1cmF0aW9uXG4gICAgICAgIC0gdHJpZ2dlciBwaXZvdFxuICAgICAgICBzZXJ2aWNlaGFuZGxlcjpcbiAgICAgICAgLSBjYWxsIHJlbG9hZFxuICAgICovXG4gICAgcHVibGljIHBhdXNlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuICAgIH1cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvclxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gcmVzdG9yZWludGVycnVwdHNcbiAgICAqL1xuICAgIHB1YmxpYyByZXN0b3JlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gZmFsc2VcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiY29udGVudGZ1bmN0aW9uc18xIiwicmVxdWlyZSIsIkludGVycnVwdEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJpc0hlYWRDcmFkbGVJblZpZXciLCJpc1RhaWxDcmFkbGVJblZpZXciLCJheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayIsImVudHJpZXMiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInRlc3Ryb290Ym91bmRzIiwicm9vdEJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiY29udGVudEhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsImlzTW91bnRlZFJlZiIsInNjcm9sbERhdGEiLCJwcmV2aW91c3VwZGF0ZSIsImN1cnJlbnR1cGRhdGUiLCJ2aWV3cG9ydEVsZW1lbnQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiZWxlbWVudFJlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwib3JpZW50YXRpb24iLCJ0cmlnZ2VySGlzdG9yeVJlZiIsImxpc3RzaXplIiwiY3Jvc3Njb3VudCIsInNjcm9sbFBvcyIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJjb250ZW50TGVuZ3RoIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJ2aWV3cG9ydExlbmd0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwiTWF0aCIsImZsb29yIiwidmlld3BvcnRCb3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfcmVmIiwiY2FsY3VsYXRlU2hpZnRJbnN0cnVjdGlvbiIsInNjcm9sbGVySUQiLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJ0cmlnZ2VybGluZVNwYW4iLCJpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZyIsInRyaWdnZXJjZWxsSXNJblRhaWwiLCJfcmVmMiIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MiLCJsYXN0TGlzdFJvd09mZnNldCIsImNlaWwiLCJ0YWlsY29udGVudGxpc3QiLCJjb250ZW50IiwidGFpbE1vZGVsQ29tcG9uZW50cyIsInByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4IiwiX2EiLCJpbmRleCIsInByZXZpb3VzQXhpc1Jvd09mZnNldCIsInNldENyYWRsZVN0YXRlIiwiY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjIiLCJzZXJ2aWNlSGFuZGxlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyeSIsImRhdGFzZXQiLCJ0eXBlIiwiaXNJbnRlcnNlY3RpbmciLCJyZXBvc2l0aW9uaW5nUmVxdWlyZWQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImluY2x1ZGVzIiwiaXNSZXNpemluZyIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJsYXlvdXQiLCJjb25zb2xlIiwibG9nIiwicmVjdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInZpZXdwb3J0RGltZW5zaW9ucyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnIiwiY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSIsImNyYWRsZUludGVyc2VjdCIsIm9ic2VydmVyIiwiY2FsbGJhY2siLCJkaXNjb25uZWN0ZWQiLCJjb25uZWN0RWxlbWVudHMiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwib2JzZXJ2ZSIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiZGlzY29ubmVjdCIsImNyZWF0ZU9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290IiwidGhyZXNob2xkIiwidHJpZ2dlcmxpbmVzSW50ZXJzZWN0IiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZiIsInBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJwYXVzZUludGVycnVwdHMiLCJyZXN0b3JlSW50ZXJydXB0cyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n')},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\n// layouthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the head and tail triggerlines\n    The key control values are the blockScrollPos & blockXScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferenceIndex (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, LayoutHandler);\n    // cradlePositionData controls the relative positions of the scaffold elements\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n      blockXScrollPos: null,\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n      blockXScrollProperty: null,\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToIndex call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // pixels into the viewport\n    };\n    // called by interruptHandler\n    this.restoreBaseScrollblockConfig = function () {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var scrollblockElement = viewportElement.firstChild;\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        orientation = _this$cradleParameter.orientation,\n        padding = _this$cradleParameter.padding,\n        gap = _this$cradleParameter.gap,\n        cellHeight = _this$cradleParameter.cellHeight,\n        cellWidth = _this$cradleParameter.cellWidth;\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n        listRowcount = _this$cradleParameter2.listRowcount,\n        crosscount = _this$cradleParameter2.crosscount;\n      var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        scrollHandler = _this$cradleParameter3.scrollHandler,\n        layoutHandler = _this$cradleParameter3.layoutHandler;\n      var cellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var baselength = listRowcount * cellLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var axisReference = cradlePositionData.targetAxisReferenceIndex;\n      var rowOffset = Math.ceil(axisReference / crosscount);\n      var calculatedBlockScrollPos = rowOffset * cellLength + padding;\n      if ((0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // scrollPos overwritten by Safari iOS momentum engine\n        var originalScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollShift = calculatedBlockScrollPos - originalScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = scrollShift;\n        } else {\n          scrollblockElement.style.left = scrollShift;\n        }\n      } else {\n        viewportElement[cradlePositionData.blockScrollProperty] = calculatedBlockScrollPos;\n      }\n      cradlePositionData.blockScrollPos = calculatedBlockScrollPos;\n      scrollHandler.resetScrollData(calculatedBlockScrollPos);\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n      axisRef = _cradleParameters$cra.axisRef,\n      headRef = _cradleParameters$cra.headRef,\n      tailRef = _cradleParameters$cra.tailRef,\n      triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      var span = orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop :\n      // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n      return span;\n    }\n  }]);\n  return LayoutHandler;\n}();\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzdELElBQUksQ0FBQ04sUUFBUSxDQUFDRiw2QkFBNkIsQ0FBQzNDLE9BQU8sQ0FBQ21ELFNBQVM7TUFDN0Q7TUFDQSxJQUFJLENBQUNOLFFBQVEsQ0FBQ0QsNkJBQTZCLENBQUM1QyxPQUFPLENBQUNvRCxVQUFVLEdBQzlELElBQUksQ0FBQ1AsUUFBUSxDQUFDRiw2QkFBNkIsQ0FBQzNDLE9BQU8sQ0FBQ29ELFVBQVU7TUFFbEUsT0FBT0YsSUFBSTtJQUNmO0VBQUM7RUFBQSxPQUFBL0QsYUFBQTtBQUFBO0FBdkRMa0Usa0JBQUEsR0FBQWxFLGFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9sYXlvdXRoYW5kbGVyLnRzeD8wN2JmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxheW91dGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHJlZmVyZW5jZXMgdG8gXG4gICAgLSB0aGUgc3RydWN0dXJhbCBlbGVtZW50cyBvZiB0aGUgY3JhZGxlXG4gICAgLSB0aGUga2V5IGNvbnRyb2wgdmFsdWVzIG9mIHRoZSBjcmFkbGVcblxuICAgIFRoZSBzdHJ1Y3R1cmFsIGVsZW1lbnRzIGFyZSB0aGUgYXhpcywgaGVhZCAoZ3JpZCksIHRhaWwgKGdyaWQpLCBcbiAgICAgICAgYW5kIHRoZSBoZWFkIGFuZCB0YWlsIHRyaWdnZXJsaW5lc1xuICAgIFRoZSBrZXkgY29udHJvbCB2YWx1ZXMgYXJlIHRoZSBibG9ja1Njcm9sbFBvcyAmIGJsb2NrWFNjcm9sbFBvcyAoc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpLCB0aGUgYmxvY2sgc2Nyb2xsXG4gICAgICAgIHByb3BlcnR5IChcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiKSwgdGhlIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAoZmlyc3QgaW5kZXggb2YgdGhlXG4gICAgICAgIHRhaWwgYmxvY2spLCBhbmQgdGhlIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IChwaXhlbHMgb2Zmc2V0IGZyb20gdGhlIGVkZ2Ugb2YgdGhlIFxuICAgICAgICB2aWV3cG9ydClcbiovXG5cbmltcG9ydCB7IGlzU2FmYXJpSU9TIH0gZnJvbSAnLi4vSW5maW5pdGVHcmlkU2Nyb2xsZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheW91dEhhbmRsZXIgeyBcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYXhpc1JlZiwgXG4gICAgICAgICAgICBoZWFkUmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLFxuICAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5jcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnRzID0ge1xuICAgICAgICAgICAgYXhpc1JlZixcbiAgICAgICAgICAgIGhlYWRSZWYsXG4gICAgICAgICAgICB0YWlsUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZixcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gXG4gICAgICAgICAgICAoTWF0aC5taW4oc3RhcnRpbmdJbmRleCwobGlzdHNpemUgLSAxKSkgfHwgMClcblxuICAgICAgICB0aGlzLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IDBcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHVibGljIGdldCB0cmlnZ2VybGluZVNwYW4oKSB7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHNwYW4gPSAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0VG9wIC0gXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLmN1cnJlbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZi5jdXJyZW50Lm9mZnNldExlZnQgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgcmV0dXJuIHNwYW5cbiAgICB9XG5cbiAgICBwdWJsaWMgdHJpZ2dlcmNlbGxJbmRleFxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbElzSW5UYWlsIC8vID0gZmFsc2VcblxuICAgIC8vIGNyYWRsZVBvc2l0aW9uRGF0YSBjb250cm9scyB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIHRoZSBzY2FmZm9sZCBlbGVtZW50c1xuICAgIHB1YmxpYyBjcmFkbGVQb3NpdGlvbkRhdGEgPSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFwiYmxvY2tcIiA9IGNyYWRsZWJsb2NrLCB3aGljaCBpcyB0aGUgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGVkXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHNldCBieSBzY3JvbGxIYW5kbGVyIGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsaW5nLFxuICAgICAgICAgICAgYW5kIGJ5IHNldENyYWRsZUNvbnRlbnQgaW4gY29udGVudEhhbmRsZXIsIHdoaWNoIHJlcG9zaXRpb25zIHRoZSBjcmFkbGUuXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIGNyYWRsZSBpbml0aWFsaXphdGlvbiBpbiByZXNwb25zZSB0byByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICBibG9ja1Njcm9sbFBvczpudWxsLCAvLyB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgYmxvY2tYU2Nyb2xsUG9zOm51bGwsIC8vIHRoZSBjcm9zcyBwb3NpdGlvbiBmb3Igb3ZlcnNpemVkIHNjcm9sbEJsb2NrXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHZhbHVlcyBjYW4gYmUgXCJzY3JvbGxUb3BcIiBvciBcInNjcm9sbExlZnRcIiAob2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQpIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvblxuXG4gICAgICAgICAgICBibG9ja1Njcm9sbFByb3BlcnR5IGlzIHNldCBieSB0aGUgb3JpZW50YXRpb24gcmVjb25maWd1cmF0aW9uIGVmZmVjdCBpbiBjcmFkbGUgbW9kdWxlLlxuXG4gICAgICAgICAgICBpdCBpcyB1c2VkIHdoZXJlIGJsb2NrU2Nyb2xsUG9zIGlzIHVzZWQgYWJvdmUuXG4gICAgICAgICovXG4gICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHk6IG51bGwsXG4gICAgICAgIGJsb2NrWFNjcm9sbFByb3BlcnR5OiBudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgc2V0IGJ5XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSBsYXlvdXRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gaG9zdCBzY3JvbGxUb0luZGV4IGNhbGxcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIHNjcm9sbFRyYWNrZXJBcmdzIGluIGNyYWRsZSBtb2R1bGVcbiAgICAgICAgICAgICAgICAtIHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCBpbiBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICovXG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleDpudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCBpcyBzZXQgYnlcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIGxheW91dEhhbmRsZXIgKGluaXRpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsSGFuZGxlciAoZHVyaW5nIGFuZCBhZnRlciBzY3JvbGwpXG4gICAgICAgICAgICAgICAgLSBwaXZvdCBlZmZlY3QgKGNoYW5nZSBvZiBvcmllbnRhdGlvbikgaW4gY3JhZGxlIG1vZHVsZVxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCBpcyB1c2VkIGJ5XG4gICAgICAgICAgICAgICAgLSBwcmV2aW91c0F4aXNPZmZzZXQgaW4gcGl2b3QgZWZmZWN0XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG5cbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6bnVsbCwgLy8gcGl4ZWxzIGludG8gdGhlIHZpZXdwb3J0XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgYnkgaW50ZXJydXB0SGFuZGxlclxuICAgIHB1YmxpYyByZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgLy8gc2Nyb2xsZXJJRCwgXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAvLyBsYXlvdXQgXG5cbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgLy8gc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIC8vIHNlcnZpY2VIYW5kbGVyLCBcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsIFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlciBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjZWxsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3RSb3djb3VudCAqIGNlbGxMZW5ndGgpIC0gZ2FwIC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmhlaWdodCA9IGJhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUud2lkdGggPSBiYXNlbGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBjb25zdCBheGlzUmVmZXJlbmNlID0gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjb25zdCByb3dPZmZzZXQgPSBNYXRoLmNlaWwoYXhpc1JlZmVyZW5jZS9jcm9zc2NvdW50KVxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MgPSBcbiAgICAgICAgICAgIChyb3dPZmZzZXQgKiBjZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuXG4gICAgICAgIGlmIChpc1NhZmFyaUlPUygpKSB7IC8vIHNjcm9sbFBvcyBvdmVyd3JpdHRlbiBieSBTYWZhcmkgaU9TIG1vbWVudHVtIGVuZ2luZVxuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbFBvcyA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsU2hpZnQgPSBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MgLSBvcmlnaW5hbFNjcm9sbFBvc1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IHNjcm9sbFNoaWZ0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IHNjcm9sbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3NcblxuICAgICAgICB9XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvc1xuICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YShjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZWxlbWVudHNcblxufVxuXG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJOdW1iZXIiLCJJbmZpbml0ZUdyaWRTY3JvbGxlcl8xIiwicmVxdWlyZSIsIkxheW91dEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrWFNjcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJibG9ja1hTY3JvbGxQcm9wZXJ0eSIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwicmVzdG9yZUJhc2VTY3JvbGxibG9ja0NvbmZpZyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsIm9yaWVudGF0aW9uIiwicGFkZGluZyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwibGlzdFJvd2NvdW50IiwiY3Jvc3Njb3VudCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJoYW5kbGVyc1JlZiIsInNjcm9sbEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwiY2VsbExlbmd0aCIsImJhc2VsZW5ndGgiLCJzdHlsZSIsInRvcCIsImhlaWdodCIsImxlZnQiLCJ3aWR0aCIsImF4aXNSZWZlcmVuY2UiLCJyb3dPZmZzZXQiLCJNYXRoIiwiY2VpbCIsImNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvcyIsImlzU2FmYXJpSU9TIiwib3JpZ2luYWxTY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsU2hpZnQiLCJyZXNldFNjcm9sbERhdGEiLCJfY3JhZGxlUGFyYW1ldGVycyRjcmEiLCJjcmFkbGVFbGVtZW50c1JlZiIsImF4aXNSZWYiLCJoZWFkUmVmIiwidGFpbFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJlbGVtZW50cyIsInN0YXJ0aW5nSW5kZXgiLCJsaXN0c2l6ZSIsIm1pbiIsImdldCIsInNwYW4iLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// scrollhandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferenceIndex, and\n        targetAxisViewportPixelOffset\n*/\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ScrollHandler);\n  this._isIOSscrolling = false;\n  this.iOSonScroll = function () {\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this._isIOSscrolling) {\n      _this._isIOSscrolling = true;\n      _this._onIOSonAfterScrollTimeout = 1000; // iOS sometimes likes to pause before commencing scrolling\n      clearTimeout(_this._onIOSonAfterScrollTimeout);\n      _this._iOSsetTimeoutTimerid = setTimeout(function () {\n        _this._onIOSonAfterScrollTimeout = 250; // back to more responsive once underway\n      }, 900);\n    }\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    clearTimeout(_this._iOSscrolltimerid);\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockElement = viewportElement.firstChild;\n    var scrollblockLength, viewportLength, blockScrollPos, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollblockLength = viewportElement.scrollHeight;\n      viewportLength = viewportElement.offsetHeight;\n      blockScrollPos = viewportElement.scrollTop;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollblockLength = viewportElement.scrollWidth;\n      viewportLength = viewportElement.offsetWidth;\n      blockScrollPos = viewportElement.scrollLeft;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    if (blockScrollPos - scrollblockOffset < 0 ||\n    // overshoot start\n    scrollblockLength < blockScrollPos - scrollblockOffset + viewportLength) {\n      // overshoot end\n      _this.iOSonAfterScroll(); // immediate halt and adjust\n    } else {\n      _this._iOSscrolltimerid = setTimeout(function () {\n        _this.iOSonAfterScroll(); // deferred halt and adjust\n      }, _this._onIOSonAfterScrollTimeout);\n    }\n  };\n  this.iOSonAfterScroll = function () {\n    _this._isIOSscrolling = false;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var scrollblockElement = viewportElement.firstChild;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockOffset = orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n    var blockScrollPos = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    viewportElement.style.overflow = 'hidden';\n    if (orientation == 'vertical') {\n      viewportElement.scrollTop = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.top = null;\n    } else {\n      // orientation == horizontal\n      viewportElement.scrollLeft = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.left = null;\n    }\n    viewportElement.style.overflow = 'scroll';\n  };\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      scrollerID = _this$cradleParameter.scrollerID,\n      ONAFTERSCROLL_TIMEOUT = _this$cradleParameter.ONAFTERSCROLL_TIMEOUT;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    // const viewportElement = ViewportContextProperties.elementRef.current\n    var viewportElement = e.currentTarget;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollPositionCurrent = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    var scrollXPositionCurrent = orientation == 'horizontal' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    // keep up to date in case of reparenting interrupt\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    cradlePositionData.blockXScrollPos = scrollXPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    // const { contentHandler, serviceHandler } = this.cradleParameters.handlersRef.current\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        _this.calcImpliedRepositioningData('onScroll');\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, ONAFTERSCROLL_TIMEOUT);\n    return false;\n  };\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler;\n    // const ViewportContextProperties = this.cradleParameters.ViewportContextPropertiesRef.current,\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n          break;\n        }\n    }\n    var cache = cradleInheritedProperties.cache;\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n  };\n  // after scroll, but not after repositioning\n  this.updateReferenceData = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter3.stateHandler,\n      layoutHandler = _this$cradleParameter3.layoutHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current,\n      viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var axisViewportPixelOffset;\n    if (cradleProps.orientation == 'vertical') {\n      axisViewportPixelOffset = axisElement.offsetTop + scrollblockElement.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisViewportPixelOffset = axisElement.offsetLeft + scrollblockElement.offsetLeft - viewportElement.scrollLeft;\n    }\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  };\n  // called from finishreposition state change call above\n  // called from updateReferenceData\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollLeft;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollTop;\n      }\n    }\n  };\n  this.calcImpliedRepositioningData = function (source) {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n      cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var crosscount = cradleConfig.crosscount,\n      listsize = cradleConfig.listsize,\n      orientation = cradleProps.orientation;\n    var scrollPos, cellLength, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    var axisPixelOffset = cellLength - (scrollPos + scrollblockOffset) % cellLength;\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZUFBZTtFQUV0RSxDQUFDO0VBdFlHLElBQUksQ0FBQ2pHLGdCQUFnQixHQUFHQSxnQkFBZ0I7QUFFNUMsQ0FBQztBQU5MMEcsa0JBQUEsR0FBQTNHLGFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSByZXNwb25zZSB0byBzY3JvbGxpbmcuIEl0IGFsc28gdHJpZ2dlcnMgYW4gb25BZnRlclNjcm9sbCBldmVudCAoYWZ0ZXIgYSB0aW1lb3V0KVxuICAgIEl0J3MgbWFpbiBqb2IgaXMgdG8gbWFpbnRhaW4gcmVjb3JkcyBvZiBzY3JvbGxQb3MsIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaU9Tc2Nyb2xsdGltZXJpZFxuICAgIHByaXZhdGUgX2lPU3NldFRpbWVvdXRUaW1lcmlkXG5cbiAgICBwcml2YXRlIF9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0XG5cbiAgICBwcml2YXRlIF9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICBwdWJsaWMgaU9Tb25TY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5pbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzSU9Tc2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lzSU9Tc2Nyb2xsaW5nID0gdHJ1ZVxuXG4gICAgICAgICAgICB0aGlzLl9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0ID0gMTAwMCAvLyBpT1Mgc29tZXRpbWVzIGxpa2VzIHRvIHBhdXNlIGJlZm9yZSBjb21tZW5jaW5nIHNjcm9sbGluZ1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dClcblxuICAgICAgICAgICAgdGhpcy5faU9Tc2V0VGltZW91dFRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dCA9IDI1MCAvLyBiYWNrIHRvIG1vcmUgcmVzcG9uc2l2ZSBvbmNlIHVuZGVyd2F5XG4gICAgICAgICAgICB9LDkwMClcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faU9Tc2Nyb2xsdGltZXJpZClcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgc2Nyb2xsYmxvY2tMZW5ndGgsIHZpZXdwb3J0TGVuZ3RoLCBibG9ja1Njcm9sbFBvcywgc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrTGVuZ3RoID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3BcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0xlbmd0aCA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxXaWR0aFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoKCBibG9ja1Njcm9sbFBvcyAtIHNjcm9sbGJsb2NrT2Zmc2V0KSA8IDApIHx8IC8vIG92ZXJzaG9vdCBzdGFydFxuICAgICAgICAgICAgKHNjcm9sbGJsb2NrTGVuZ3RoIDwgKGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXQgKyB2aWV3cG9ydExlbmd0aCkpKSB7IC8vIG92ZXJzaG9vdCBlbmRcblxuICAgICAgICAgICAgdGhpcy5pT1NvbkFmdGVyU2Nyb2xsKCkgLy8gaW1tZWRpYXRlIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lPU3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaU9Tb25BZnRlclNjcm9sbCgpIC8vIGRlZmVycmVkIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgICAgICB9LHRoaXMuX29uSU9Tb25BZnRlclNjcm9sbFRpbWVvdXQpXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaU9Tb25BZnRlclNjcm9sbCA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLl9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cblxuICAgICAgICBjb25zdCBzY3JvbGxibG9ja09mZnNldCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9XG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gaG9yaXpvbnRhbFxuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuXG4gICAgICAgIH1cblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyByZXNldFNjcm9sbERhdGEgPSAoc2Nyb2xsUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSB0aGlzXG4gICAgICAgIHNjcm9sbERhdGEuc3RhcnQgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50ID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXMgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IFxuICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlcklELCBPTkFGVEVSU0NST0xMX1RJTUVPVVQgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAvLyBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IGUuY3VycmVudFRhcmdldFxuXG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5vcmllbnRhdGlvblxuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsWFBvc2l0aW9uQ3VycmVudCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY3JvbGx0aW1lcmlkKVxuXG4gICAgICAgIGlmICgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDAgICYmIHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uQ3VycmVudCA8IDApIHsgLy8gZm9yIFNhZmFyaVxuXG4gICAgICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cykge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuc3RhcnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICAvLyBrZWVwIHVwIHRvIGRhdGUgaW4gY2FzZSBvZiByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSBzY3JvbGxYUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzID0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnRcbiAgICAgICAgdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICBjb25zdCB7c3RhdGVIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBjb25zdCB7IGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICBpZiAoKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgfHwgKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJykpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSgnb25TY3JvbGwnKVxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsdGltZXJpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJTY3JvbGwoKVxuXG4gICAgICAgIH0sT05BRlRFUlNDUk9MTF9USU1FT1VUKVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgfVxuXG5cbiAgICBwcml2YXRlIG9uQWZ0ZXJTY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZVN0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdSZW5kZXInOiBcbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nOlxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Njcm9sbFBvcygpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayhmYWxzZSlcbiAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHJlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNjcm9sbERhdGEuc3RhcnQgIT0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQgIT0gdGhpcy5zY3JvbGxEYXRhLnByZXZpb3VzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KClcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgc2Nyb2xsLCBidXQgbm90IGFmdGVyIHJlcG9zaXRpb25pbmdcbiAgICBwcml2YXRlIHVwZGF0ZVJlZmVyZW5jZURhdGEgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIGxheW91dEhhbmRsZXIgfSBcbiAgICAgICAgICAgID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgaWYgKGNyYWRsZVByb3BzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRUb3AgKyBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wIC0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldExlZnQgKyBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBmaW5pc2hyZXBvc2l0aW9uIHN0YXRlIGNoYW5nZSBjYWxsIGFib3ZlXG4gICAgLy8gY2FsbGVkIGZyb20gdXBkYXRlUmVmZXJlbmNlRGF0YVxuICAgIHByaXZhdGUgdXBkYXRlQmxvY2tTY3JvbGxQb3MgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHtsYXlvdXRIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoISgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDApICAmJiAodmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tYU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIGNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEgPSAoc291cmNlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVDb25maWcgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgeyBjcm9zc2NvdW50LCBsaXN0c2l6ZSB9ID0gY3JhZGxlQ29uZmlnLFxuICAgICAgICAgICAgeyBvcmllbnRhdGlvbiB9ID0gY3JhZGxlUHJvcHNcblxuICAgICAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoLCBzY3JvbGxibG9ja09mZnNldFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlUHJvcHMuY2VsbEhlaWdodCArIGNyYWRsZVByb3BzLmdhcFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tPZmZzZXQgPSBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrT2Zmc2V0ID0gc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF4aXNQaXhlbE9mZnNldCA9IGNlbGxMZW5ndGggLSAoKHNjcm9sbFBvcyArIHNjcm9sbGJsb2NrT2Zmc2V0KSAlIGNlbGxMZW5ndGgpXG4gICAgICAgIGlmIChheGlzUGl4ZWxPZmZzZXQgPT0gKGNlbGxMZW5ndGggKyBjcmFkbGVQcm9wcy5wYWRkaW5nKSkge1xuICAgICAgICAgICAgYXhpc1BpeGVsT2Zmc2V0ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXhpc1Jvd0luZGV4ID0gTWF0aC5jZWlsKChzY3JvbGxQb3MgLSBjcmFkbGVQcm9wcy5wYWRkaW5nKS9jZWxsTGVuZ3RoKVxuXG4gICAgICAgIGxldCBheGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUm93SW5kZXggKiBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKGF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG5cbiAgICAgICAgY29uc3QgZGlmZiA9IGF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnRcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4IC09IGRpZmZcblxuICAgICAgICBpZiAoYXhpc1JlZmVyZW5jZUluZGV4ID09IDApIGF4aXNQaXhlbE9mZnNldCA9IDAgLy8gZGVmZW5zaXZlXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXJcblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNQaXhlbE9mZnNldFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJTY3JvbGxIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIl90aGlzIiwiX2lzSU9Tc2Nyb2xsaW5nIiwiaU9Tb25TY3JvbGwiLCJzaWduYWxzIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiaW50ZXJydXB0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsIl9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiX2lPU3NldFRpbWVvdXRUaW1lcmlkIiwic2V0VGltZW91dCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsIl9pT1NzY3JvbGx0aW1lcmlkIiwib3JpZW50YXRpb24iLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwic2Nyb2xsYmxvY2tFbGVtZW50IiwiZmlyc3RDaGlsZCIsInNjcm9sbGJsb2NrTGVuZ3RoIiwidmlld3BvcnRMZW5ndGgiLCJibG9ja1Njcm9sbFBvcyIsInNjcm9sbGJsb2NrT2Zmc2V0Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwib2Zmc2V0VG9wIiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjcm9sbExlZnQiLCJvZmZzZXRMZWZ0IiwiaU9Tb25BZnRlclNjcm9sbCIsInN0eWxlIiwib3ZlcmZsb3ciLCJ0b3AiLCJsZWZ0Iiwic2Nyb2xsRGF0YSIsInN0YXJ0IiwicHJldmlvdXMiLCJwcmV2aW91c3VwZGF0ZSIsImN1cnJlbnR1cGRhdGUiLCJfc2Nyb2xsdGltZXJpZCIsImlzU2Nyb2xsaW5nIiwicmVzZXRTY3JvbGxEYXRhIiwic2Nyb2xsUG9zaXRpb24iLCJvblNjcm9sbCIsImUiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIiLCJzY3JvbGxlcklEIiwiT05BRlRFUlNDUk9MTF9USU1FT1VUIiwiY3VycmVudFRhcmdldCIsInNjcm9sbFBvc2l0aW9uQ3VycmVudCIsInNjcm9sbFhQb3NpdGlvbkN1cnJlbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImxheW91dEhhbmRsZXIiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1hTY3JvbGxQb3MiLCJzdGF0ZUhhbmRsZXIiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaXNSZXNpemluZyIsImNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEiLCJzZXRDcmFkbGVTdGF0ZSIsIm9uQWZ0ZXJTY3JvbGwiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY29udGVudEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJ1cGRhdGVCbG9ja1Njcm9sbFBvcyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJpc01vdW50ZWRSZWYiLCJ1cGRhdGVSZWZlcmVuY2VEYXRhIiwiY2FjaGUiLCJwYXJlQ2FjaGVUb01heCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJjcmFkbGVQcm9wcyIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJheGlzVmlld3BvcnRQaXhlbE9mZnNldCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwic291cmNlIiwiY3JhZGxlQ29uZmlnIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3Jvc3Njb3VudCIsImxpc3RzaXplIiwic2Nyb2xsUG9zIiwiY2VsbExlbmd0aCIsImNlbGxIZWlnaHQiLCJnYXAiLCJjZWxsV2lkdGgiLCJheGlzUGl4ZWxPZmZzZXQiLCJwYWRkaW5nIiwiYXhpc1Jvd0luZGV4IiwiTWF0aCIsImNlaWwiLCJheGlzUmVmZXJlbmNlSW5kZXgiLCJtaW4iLCJkaWZmIiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// servicehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streams, see the constructor.\n\n    The function calls avaiable to the host are:\n\n        scrollToIndex,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n\n        insertIndex,\n        removeIndex,\n        moveIndex,\n        remapIndexes,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions for these in cacheHandler and contentHandler. stateHandler is\n    often invoked by service functions to change Cradle state upon servicing requests.\n*/\nvar isBlank = function isBlank(value) {\n  var testvalue = value !== null && value !== void 0 ? value : \'\';\n  return testvalue === \'\';\n};\nvar isNumber = function isNumber(value) {\n  return !isNaN(Number(value)) && !isNaN(parseInt(value));\n};\nvar isInteger = function isInteger(value) {\n  var test = +value;\n  return isNumber(value) && Math.floor(test) == test;\n};\nvar minValue = function minValue(value, _minValue) {\n  if (!isInteger(value) || !isInteger(_minValue)) return false;\n  var testvalue = +value;\n  var testMinValue = +_minValue;\n  return testvalue >= testMinValue;\n};\nvar maxValue = function maxValue(value, _maxValue) {\n  if (!isInteger(value) || !isInteger(_maxValue)) return false;\n  var testvalue = +value;\n  var testMaxValue = +_maxValue;\n  return testvalue <= testMaxValue;\n};\nvar errorMessages = {\n  scrollToIndex: \'integer: required, greater than or equal to 0\',\n  setListsize: \'integer: required, greater than or equal to 0\',\n  insertFrom: \'insertFrom - integer: required, greater than or equal to 0\',\n  insertRange: \'insertRange - blank, or integer greater than or equal to the "from" index\',\n  removeFrom: \'removeFrom - integer: required, greater than or equal to 0\',\n  removeRange: \'removeRange - blank, or integer greater than or equal to the "from" index\',\n  moveFrom: \'moveFrom - integer: required, greater than or equal to 0\',\n  moveRange: \'moveRange - blank, or integer greater than or equal to the "from" index\',\n  moveTo: \'moveTo - integer: required, greater than or equal to 0\'\n};\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ServiceHandler);\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState(\'reload\');\n  };\n  this.scrollToIndex = function (index) {\n    var isInvalid = !isInteger(index) || !minValue(index, 0);\n    index = +index;\n    if (isInvalid) {\n      console.log(\'RIGS ERROR scrollToIndex(index)):\', index, errorMessages.scrollToIndex);\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      layoutHandler = _this$cradleParameter.layoutHandler,\n      stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState(\'scrollto\');\n  };\n  this.setListsize = function (newlistsize) {\n    var isInvalid = !isInteger(newlistsize) || !minValue(newlistsize, 0);\n    newlistsize = +newlistsize;\n    if (isInvalid) {\n      console.log(\'RIGS ERROR setListsize(newlistsize)\', newlistsize, errorMessages.setListsize);\n      return;\n    }\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter2.cacheHandler,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n      deleteListCallback = _this$callbacks.deleteListCallback,\n      changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback(\'change list size intervention\', deleteList);\n      };\n    }\n    contentHandler.updateListsize(newlistsize);\n    cacheHandler.changeCacheListsize(newlistsize, dListCallback, changeListsizeCallback);\n    cacheHandler.renderPortalLists();\n    if (cache == \'preload\' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState(\'startpreload\');\n    }\n  };\n  // ======================[ GET SNAPSHOTS ]========================\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter3.cacheHandler,\n      contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  };\n  // =================[ CACHE MANAGEMENT REQUESTS ]==================\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState(\'clearcache\');\n  };\n  // itemID set to null deletes the indexed item\n  // itemID set to undefined replaces the indexed item\n  // the main purpose is to allow itemsIDs to be remapped to new indexes\n  // operations are on existing cache items only\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter4.cacheHandler,\n      contentHandler = _this$cradleParameter4.contentHandler,\n      stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n      metadataMap = _cacheHandler$cachePr.metadataMap,\n      indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var indexesToReplaceItemIDList = [];\n    var partitionItemsToReplaceList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map();\n    // =====================[ PREPARE ]======================\n    // -----------------------[ isolate indexes for which items should be replaced ]--------------\n    var workingChangeMap = new Map();\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === undefined) {\n        if (indexToItemIDMap.has(index)) {\n          var cacheItemID = indexToItemIDMap.get(index);\n          indexesToReplaceItemIDList.push(index);\n          if (!(cacheItemID === undefined)) {\n            // ignore non-existent indexes\n            var _metadataMap$get = metadataMap.get(cacheItemID),\n              partitionID = _metadataMap$get.partitionID;\n            partitionItemsToReplaceList.push({\n              partitionID: partitionID,\n              itemID: cacheItemID\n            });\n          }\n        } else {\n          errorEntriesMap.set(index, \'index to replace is not in cache\');\n        }\n      } else {\n        workingChangeMap.set(index, itemID);\n      }\n    });\n    indexesToReplaceItemIDList.forEach(function (index) {\n      indexToItemIDMap["delete"](index);\n    });\n    // ------------ filter out inoperable indexes and itemIDs ------------\n    var itemsToReplaceSet = new Set();\n    partitionItemsToReplaceList.forEach(function (obj) {\n      itemsToReplaceSet.add(obj.itemID);\n    });\n    // const itemsToReplaceList = Array.from(itemsToReplaceSet)\n    workingChangeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == \'string\') {\n          errorEntriesMap.set(index, \'itemID is a string\');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, \'itemID is not an integer\');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, \'index not in cache\');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " has not changed"));\n        } else if (!metadataMap.has(itemID) || itemsToReplaceSet.has(itemID)) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " not in cache, or has been removed"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    });\n    // -------------- filter out duplicate itemIDs ------------\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, "target itemID ".concat(itemID, " has duplicates (").concat(count, ")"));\n        changeIndexToItemIDMap["delete"](index);\n      });\n    }\n    // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n    var originalMap = new Map(); // index => itemID; before change\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    });\n    // ... and from the list of indexes to be deleted\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    });\n    // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID\'s will be orphaned, but could be remapped.\n    // orphans are resolved below\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap["delete"](index);\n      });\n    }\n    // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n    var processedIndexList = [];\n    // make changes\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n      processedIndexList.push(index);\n    });\n    // -------------- look for and delete item and index orphans --------------------\n    // if the original item\'s index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item\'s index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n    var deletedIndexToItemIDMap = new Map();\n    var portalPartitionItemsForDeleteList = []; // hold deleted portals for deletion until after cradle synch\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        var _metadataMap$get2 = metadataMap.get(originalItemID),\n          partitionID = _metadataMap$get2.partitionID;\n        portalPartitionItemsForDeleteList.push({\n          itemID: originalItemID,\n          partitionID: partitionID\n        });\n        metadataMap["delete"](originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap["delete"](originalItemIDIndex);\n          }\n        }\n      }\n    });\n    // refresh the changed cache\n    // cacheHandler.cacheProps.partitionModified = true\n    // cacheHandler.renderPortalLists()\n    // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys());\n    // for return information...\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n    contentHandler.createNewItemIDs(indexesToReplaceItemIDList);\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    modifiedIndexList = modifiedIndexList.concat(indexesToReplaceItemIDList);\n    cacheHandler.portalPartitionItemsForDeleteList = portalPartitionItemsForDeleteList.concat(partitionItemsToReplaceList);\n    stateHandler.setCradleState(\'applyremapchanges\');\n    // ---------- returns for user information --------------------\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, indexesToReplaceItemIDList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  };\n  // move must be entirely within list bounds\n  // returns list of processed indexes\n  this.moveIndex = function (tolowindex, fromlowindex) {\n    var fromhighindex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------ confirm validity of arguments -------------\n    var isToindexInvalid = !isInteger(tolowindex) || !minValue(tolowindex, 0);\n    var isFromindexInvalid = !isInteger(fromlowindex) || !minValue(fromlowindex, 0);\n    var isHighrangeInvalid = false;\n    if (!isFromindexInvalid) {\n      if (!isBlank(fromhighindex)) {\n        isHighrangeInvalid = !minValue(fromhighindex, fromlowindex);\n      } else {\n        fromhighindex = fromlowindex;\n      }\n    }\n    tolowindex = +tolowindex;\n    fromlowindex = +fromlowindex;\n    fromhighindex = +fromhighindex;\n    // TODO return error array instead\n    if (isToindexInvalid || isFromindexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR moveIndex(toindex, fromindex, fromhighrange)\');\n      isToindexInvalid && console.log(tolowindex, errorMessages.moveTo);\n      isFromindexInvalid && console.log(fromlowindex, errorMessages.moveFrom);\n      isHighrangeInvalid && console.log(fromhighindex, errorMessages.moveRange);\n      return [];\n    }\n    tolowindex = Math.max(0, tolowindex);\n    fromlowindex = Math.max(0, fromlowindex);\n    fromhighindex = Math.max(0, fromhighindex);\n    var fromspan = fromhighindex - fromlowindex + 1;\n    var tohighindex = tolowindex + fromspan - 1;\n    // ------------- coerce parameters to list bounds ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    // keep within current list size\n    var listhighindex = listsize - 1;\n    if (tohighindex > listhighindex) {\n      var diff = tohighindex - listhighindex;\n      tohighindex = Math.max(0, tohighindex - diff);\n      tolowindex = Math.max(0, tolowindex - diff);\n    }\n    if (fromhighindex > listhighindex) {\n      var _diff = fromhighindex - listhighindex;\n      fromhighindex = Math.max(0, fromhighindex - _diff);\n      fromlowindex = Math.max(0, fromlowindex - _diff);\n    }\n    // ---------- constrain parameters --------------\n    // nothing to do; no displacement\n    if (fromlowindex == tolowindex) return [];\n    // ----------- perform cache and cradle operations -----------\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter5.cacheHandler,\n      contentHandler = _this$cradleParameter5.contentHandler,\n      stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList =\n    // both displaced and moved indexes\n    cacheHandler.moveIndex(tolowindex, fromlowindex, fromhighindex);\n    if (processedIndexList.length) {\n      contentHandler.synchronizeCradleItemIDsToCache(processedIndexList);\n      var content = contentHandler.content;\n      content.headModelComponents = content.cradleModelComponents.slice(0, content.headModelComponents.length);\n      content.tailModelComponents = content.cradleModelComponents.slice(content.headModelComponents.length);\n      stateHandler.setCradleState(\'applymovechanges\');\n    }\n    return processedIndexList;\n  };\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isIndexInvalid) {\n      if (!isBlank(rangehighindex)) {\n        isHighrangeInvalid = !minValue(rangehighindex, index);\n      } else {\n        rangehighindex = index;\n      }\n    }\n    index = +index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR insertIndex(index, rangehighindex)\');\n      isIndexInvalid && console.log(index, errorMessages.insertFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.insertRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isIndexInvalid) {\n      if (!isBlank(rangehighindex)) {\n        isHighrangeInvalid = !minValue(rangehighindex, index);\n      } else {\n        rangehighindex = index;\n      }\n    }\n    index = +index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR moveIndex(index, rangehighindex)\');\n      isIndexInvalid && console.log(index, errorMessages.removeFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.removeRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  };\n  // shared logic for insert and remove. Returns lists of indexes shifted, replaced, and removed\n  // this operation changes the listsize\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    // basic assertions\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    // ---------------- assemble resources --------------------\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n      cacheHandler = _this$cradleParameter6.cacheHandler,\n      contentHandler = _this$cradleParameter6.contentHandler,\n      stateHandler = _this$cradleParameter6.stateHandler;\n    var cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    // ------------------- process cache ----------------\n    var listsize = cradleInternalProperties.listsize;\n    if (listsize == 0) {\n      if (increment > 0) {\n        return _this.setListsize(rangehighindex - index + 1);\n      }\n      return [[], [], []];\n    }\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n      _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 6),\n      startChangeIndex = _cacheHandler$insertR2[0],\n      rangeincrement = _cacheHandler$insertR2[1],\n      shiftedList = _cacheHandler$insertR2[2],\n      removedList = _cacheHandler$insertR2[3],\n      replaceList = _cacheHandler$insertR2[4],\n      portalPartitionItemsForDeleteList = _cacheHandler$insertR2[5]; //, cradleIndexSpan)\n    if (rangeincrement === null) return [[], [], []]; // no action\n    // partitionItems to delete with followup state changes - must happen after cradle update\n    cacheHandler.portalPartitionItemsForDeleteList = portalPartitionItemsForDeleteList;\n    // ------------- synchronize cradle to cache changes -------------\n    // determine if cradle must be reset or simply adjusted\n    var changecount = rangeincrement; // semantics\n    var newlistsize = _this.newlistsize = listsize + changecount;\n    var viewportRowcount = cradleInternalProperties.viewportRowcount,\n      crosscount = cradleInternalProperties.crosscount;\n    var runwaySize = cradleInheritedProperties.runwaySize;\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var calculatedCradleItemcount = calculatedCradleRowcount * crosscount;\n    var indexSpan = contentHandler.indexSpan;\n    var _indexSpan = _slicedToArray(indexSpan, 2),\n      lowIndex = _indexSpan[0],\n      highIndex = _indexSpan[1];\n    var measuredCradleItemCount = indexSpan.length == 0 ? 0 : highIndex - lowIndex + 1;\n    var resetCradle = measuredCradleItemCount < calculatedCradleItemcount || contentHandler.indexSpan[1] >= newlistsize - 1;\n    if (!resetCradle) {\n      // synchronize cradle contents to changes\n      contentHandler.synchronizeCradleItemIDsToCache(shiftedList, increment, startChangeIndex); // non-zero communications isInsertRemove\n      // if (increment == +1) contentHandler.createNewItemIDs(replaceList)\n      var content = contentHandler.content;\n      var requestedSet = cacheHandler.cacheProps.requestedSet;\n      var timeout = setInterval(function () {\n        if (!requestedSet.size) {\n          // finished collecting new cache entries\n          clearInterval(timeout);\n          content.headModelComponents = content.cradleModelComponents.slice(0, content.headModelComponents.length);\n          content.tailModelComponents = content.cradleModelComponents.slice(content.headModelComponents.length);\n          stateHandler.setCradleState(\'applyinsertremovechanges\');\n        }\n      }, 100);\n    } else {\n      // cradle to be completely reset if listsize change encroaches on cradle\n      stateHandler.setCradleState(\'channelcradleresetafterinsertremove\');\n    }\n    var replacedList = replaceList; // semantics\n    return [shiftedList, replacedList, removedList]; // inform caller\n  };\n\n  this.cradleParameters = cradleParameters;\n  // doing this explicitly here for documentation\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n    referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n    preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n    deleteListCallback = _cradleParameters$ext.deleteListCallback,\n    changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n    itemExceptionCallback = _cradleParameters$ext.itemExceptionCallback,\n    repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback,\n    repositioningIndexCallback = _cradleParameters$ext.repositioningIndexCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionCallback: itemExceptionCallback,\n    repositioningFlagCallback: repositioningFlagCallback,\n    repositioningIndexCallback: repositioningIndexCallback\n  };\n  this.callbacks = callbacks;\n});\nexports["default"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3NlcnZpY2VoYW5kbGVyLnRzeD85Y2IwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZpY2VoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBmaWVsZHMgc2VydmljZSByZXF1ZXN0cyBmcm9tIHRoZSBob3N0LiBUaGVyZSBhcmUgdHdvIGZvcm1zXG4gICAgLSBzdHJlYW1pbmcgZnJvbSB0aGUgc2Nyb2xsZXIgdG8gdGhlIGhvc3RcbiAgICAtIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIHVzZXIgdG8gdGhlIHNjcm9sbGVyXG5cbiAgICBGb3IgdGhlIGxpc3Qgb2YgZGF0YSBzdHJlYW1zLCBzZWUgdGhlIGNvbnN0cnVjdG9yLlxuXG4gICAgVGhlIGZ1bmN0aW9uIGNhbGxzIGF2YWlhYmxlIHRvIHRoZSBob3N0IGFyZTpcblxuICAgICAgICBzY3JvbGxUb0luZGV4LCBcbiAgICAgICAgcmVsb2FkLCBcbiAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgIGdldENhY2hlSW5kZXhNYXAsIFxuICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuXG4gICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICByZW1vdmVJbmRleCxcbiAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgXG4gICAgVGhlIGZ1bmN0aW9ucyBsaXN0ZWQgYXJlIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUuXG5cbiAgICBUaGVyZSBhcmUgaW1wb3J0YW50IHN1cHBvcnRpbmcgZnVuY3Rpb25zIGZvciB0aGVzZSBpbiBjYWNoZUhhbmRsZXIgYW5kIGNvbnRlbnRIYW5kbGVyLiBzdGF0ZUhhbmRsZXIgaXNcbiAgICBvZnRlbiBpbnZva2VkIGJ5IHNlcnZpY2UgZnVuY3Rpb25zIHRvIGNoYW5nZSBDcmFkbGUgc3RhdGUgdXBvbiBzZXJ2aWNpbmcgcmVxdWVzdHMuXG4qL1xuXG5jb25zdCBpc0JsYW5rID0gKHZhbHVlOmFueSkgPT4ge1xuICAgIGNvbnN0IHRlc3R2YWx1ZSA9IHZhbHVlID8/ICcnXG4gICAgcmV0dXJuIHRlc3R2YWx1ZSA9PT0gJydcbn1cblxuY29uc3QgaXNOdW1iZXIgPSAodmFsdWU6YW55KSA9PiB7XG5cbiAgICByZXR1cm4gKCBcbiAgICAgICAgKCFpc05hTihOdW1iZXIodmFsdWUpKSkgJiYgXG4gICAgICAgICghaXNOYU4ocGFyc2VJbnQodmFsdWUpKSkgXG4gICAgKVxuXG59XG5cbmNvbnN0IGlzSW50ZWdlciA9ICh2YWx1ZTphbnkpID0+IHtcblxuICAgIGNvbnN0IHRlc3QgPSArdmFsdWVcblxuICAgIHJldHVybiAoaXNOdW1iZXIodmFsdWUpICYmIChNYXRoLmZsb29yKHRlc3QpID09IHRlc3QpKVxuXG59XG5cbmNvbnN0IG1pblZhbHVlID0gKHZhbHVlOmFueSwgbWluVmFsdWU6YW55KSA9PiB7XG5cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZSkgfHwgIWlzSW50ZWdlcihtaW5WYWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgdGVzdHZhbHVlID0gK3ZhbHVlXG4gICAgY29uc3QgdGVzdE1pblZhbHVlID0gK21pblZhbHVlXG5cbiAgICByZXR1cm4gdGVzdHZhbHVlID49IHRlc3RNaW5WYWx1ZVxuXG59XG5cbmNvbnN0IG1heFZhbHVlID0gKHZhbHVlOmFueSwgbWF4VmFsdWU6YW55KSA9PiB7XG5cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZSkgfHwgIWlzSW50ZWdlcihtYXhWYWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgdGVzdHZhbHVlID0gK3ZhbHVlXG4gICAgY29uc3QgdGVzdE1heFZhbHVlID0gK21heFZhbHVlXG5cbiAgICByZXR1cm4gdGVzdHZhbHVlIDw9IHRlc3RNYXhWYWx1ZVxuXG59XG5cbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XG4gICAgc2Nyb2xsVG9JbmRleDonaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbiAgICBzZXRMaXN0c2l6ZTonaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbiAgICBpbnNlcnRGcm9tOidpbnNlcnRGcm9tIC0gaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbiAgICBpbnNlcnRSYW5nZTonaW5zZXJ0UmFuZ2UgLSBibGFuaywgb3IgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIFwiZnJvbVwiIGluZGV4JyxcbiAgICByZW1vdmVGcm9tOidyZW1vdmVGcm9tIC0gaW50ZWdlcjogcmVxdWlyZWQsIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyxcbiAgICByZW1vdmVSYW5nZToncmVtb3ZlUmFuZ2UgLSBibGFuaywgb3IgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIFwiZnJvbVwiIGluZGV4JyxcbiAgICBtb3ZlRnJvbTonbW92ZUZyb20gLSBpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxuICAgIG1vdmVSYW5nZTonbW92ZVJhbmdlIC0gYmxhbmssIG9yIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBcImZyb21cIiBpbmRleCcsXG4gICAgbW92ZVRvOidtb3ZlVG8gLSBpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJ2aWNlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAvLyBkb2luZyB0aGlzIGV4cGxpY2l0bHkgaGVyZSBmb3IgZG9jdW1lbnRhdGlvblxuICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFjaywgLy8gKGluZGV4LCBsb2NhdGlvbiwgY3JhZGxlU3RhdGUpXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgpXG4gICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaywgLy8gKHJlYXNvbiwgZGVsZXRlTGlzdClcbiAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjaywgLy8gKG5ld2xpc3RzaXplKVxuICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssIC8vIChpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgbG9jYXRpb24sIGVycm9yKVxuICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLCAvLyAoZmxhZykgLy8gYm9vbGVhblxuICAgICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgXG4gICAgICAgfSA9IGNyYWRsZVBhcmFtZXRlcnMuZXh0ZXJuYWxDYWxsYmFja3NSZWYuY3VycmVudFxuXG4gICAgICAgY29uc3QgY2FsbGJhY2tzID0ge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLFxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLFxuICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrXG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgLy8gc2VlIGFib3ZlIGZvciBsaXN0XG4gICAgcHVibGljIGNhbGxiYWNrc1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBHRU5FUkFMIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgcmVsb2FkID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgaW50ZXJydXB0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNjcm9sbFRvSW5kZXggPSAoaW5kZXgpID0+IHtcblxuICAgICAgICBjb25zdCBpc0ludmFsaWQgPSAoIWlzSW50ZWdlcihpbmRleCkgfHwgIW1pblZhbHVlKGluZGV4LCAwKSlcblxuICAgICAgICBpbmRleCA9ICtpbmRleFxuXG4gICAgICAgIGlmIChpc0ludmFsaWQpIHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1Igc2Nyb2xsVG9JbmRleChpbmRleCkpOicsIGluZGV4LCBlcnJvck1lc3NhZ2VzLnNjcm9sbFRvSW5kZXgpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5pbnRlcnJ1cHRIYW5kbGVyXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0SGFuZGxlciwgc3RhdGVIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSB0cnVlXG5cbiAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gaW5kZXhcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3Njcm9sbHRvJylcblxuICAgIH1cblxuICAgIHB1YmxpYyBzZXRMaXN0c2l6ZSA9IChuZXdsaXN0c2l6ZSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW52YWxpZCA9ICghaXNJbnRlZ2VyKG5ld2xpc3RzaXplKSB8fCAhbWluVmFsdWUobmV3bGlzdHNpemUsIDApKVxuXG4gICAgICAgIG5ld2xpc3RzaXplID0gK25ld2xpc3RzaXplXG5cbiAgICAgICAgaWYgKGlzSW52YWxpZCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUklHUyBFUlJPUiBzZXRMaXN0c2l6ZShuZXdsaXN0c2l6ZSknLCBuZXdsaXN0c2l6ZSwgZXJyb3JNZXNzYWdlcy5zZXRMaXN0c2l6ZSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjayB9ID0gdGhpcy5jYWxsYmFja3NcblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplOmN1cnJlbnRsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdjaGFuZ2UgbGlzdCBzaXplIGludGVydmVudGlvbicsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50SGFuZGxlci51cGRhdGVMaXN0c2l6ZShuZXdsaXN0c2l6ZSlcbiAgICAgICAgY2FjaGVIYW5kbGVyLmNoYW5nZUNhY2hlTGlzdHNpemUobmV3bGlzdHNpemUsIFxuICAgICAgICAgICAgZExpc3RDYWxsYmFjayxcbiAgICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2tcbiAgICAgICAgKVxuXG4gICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0cygpXG5cblxuICAgICAgICBpZiAoKGNhY2hlID09ICdwcmVsb2FkJykgJiYgKG5ld2xpc3RzaXplID4gY3VycmVudGxpc3RzaXplKSkge1xuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBHRVQgU05BUFNIT1RTIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBnZXRDYWNoZUluZGV4TWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJbmRleE1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJdGVtTWFwID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q2FjaGVJdGVtTWFwKClcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDcmFkbGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG4gICAgICAgIHJldHVybiBjYWNoZUhhbmRsZXIuZ2V0Q3JhZGxlSW5kZXhNYXAobW9kZWxJbmRleExpc3QpXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT1bIENBQ0hFIE1BTkFHRU1FTlQgUkVRVUVTVFMgXT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdjbGVhcmNhY2hlJylcblxuICAgIH1cblxuICAgIC8vIGl0ZW1JRCBzZXQgdG8gbnVsbCBkZWxldGVzIHRoZSBpbmRleGVkIGl0ZW1cbiAgICAvLyBpdGVtSUQgc2V0IHRvIHVuZGVmaW5lZCByZXBsYWNlcyB0aGUgaW5kZXhlZCBpdGVtXG4gICAgLy8gdGhlIG1haW4gcHVycG9zZSBpcyB0byBhbGxvdyBpdGVtc0lEcyB0byBiZSByZW1hcHBlZCB0byBuZXcgaW5kZXhlc1xuICAgIC8vIG9wZXJhdGlvbnMgYXJlIG9uIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIG9ubHlcbiAgICBwdWJsaWMgcmVtYXBJbmRleGVzID0gKGNoYW5nZU1hcCkgPT4geyAvLyBpbmRleCA9PiBpdGVtSURcblxuICAgICAgICBpZiAoY2hhbmdlTWFwLnNpemUgPT0gMCkgcmV0dXJuIFtdIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLCAvLyBpdGVtSUQgdG8gY29tcG9uZW50IGRhdGEsIGluY2x1ZGluZyBpbmRleFxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcCAvLyBpbmRleCB0byBpdGVtSURcblxuICAgICAgICB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc1RvRGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0ID0gW11cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBlcnJvckVudHJpZXNNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFBSRVBBUkUgXT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaXNvbGF0ZSBpbmRleGVzIGZvciB3aGljaCBpdGVtcyBzaG91bGQgYmUgcmVwbGFjZWQgXS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NoYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjaGFuZ2VNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVJdGVtSUQgPT09IHVuZGVmaW5lZCkpIHsgLy8gaWdub3JlIG5vbi1leGlzdGVudCBpbmRleGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IG1ldGFkYXRhTWFwLmdldChjYWNoZUl0ZW1JRClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0LnB1c2goe3BhcnRpdGlvbklELCBpdGVtSUQ6Y2FjaGVJdGVtSUR9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCAnaW5kZXggdG8gcmVwbGFjZSBpcyBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHdvcmtpbmdDaGFuZ2VNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdC5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgaW5vcGVyYWJsZSBpbmRleGVzIGFuZCBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGl0ZW1zVG9SZXBsYWNlU2V0ID0gbmV3IFNldCgpXG4gICAgICAgIHBhcnRpdGlvbkl0ZW1zVG9SZXBsYWNlTGlzdC5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgICAgIGl0ZW1zVG9SZXBsYWNlU2V0LmFkZChvYmouaXRlbUlEKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnN0IGl0ZW1zVG9SZXBsYWNlTGlzdCA9IEFycmF5LmZyb20oaXRlbXNUb1JlcGxhY2VTZXQpXG5cbiAgICAgICAgd29ya2luZ0NoYW5nZU1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PntcblxuICAgICAgICAgICAgaWYgKChpdGVtSUQgPT09IG51bGwpIHx8IChpdGVtSUQgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QucHVzaChpbmRleClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGl0ZW1JRCkgPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgYSBzdHJpbmcnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwnaXRlbUlEIGlzIG5vdCBhbiBpbnRlZ2VyJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsICdpbmRleCBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkgPT0gaXRlbUlEKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBub3QgY2hhbmdlZGApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFtZXRhZGF0YU1hcC5oYXMoaXRlbUlEKSB8fCBpdGVtc1RvUmVwbGFjZVNldC5oYXMoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBub3QgaW4gY2FjaGUsIG9yIGhhcyBiZWVuIHJlbW92ZWRgKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBmaWx0ZXIgb3V0IGR1cGxpY2F0ZSBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IG1hcHNpemUgPSBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNpemVcblxuICAgICAgICBjb25zdCBpdGVtSURTZXQgPSBuZXcgU2V0KGNoYW5nZUluZGV4VG9JdGVtSURNYXAudmFsdWVzKCkpXG5cbiAgICAgICAgY29uc3QgaXRlbXNldHNpemUgPSBpdGVtSURTZXQuc2l6ZVxuXG4gICAgICAgIGlmIChtYXBzaXplICE9IGl0ZW1zZXRzaXplKSB7IC8vIHRoZXJlIG11c3QgYmUgZHVwbGljYXRlIGl0ZW1JRHNcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEQ291bnRNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlEQ291bnRNYXAuaGFzKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCAxKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBpdGVtSURDb3VudE1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCArK2NvdW50IClcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZUl0ZW1zTWFwID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBpdGVtSURDb3VudE1hcC5mb3JFYWNoKChjb3VudCxpdGVtSUQpPT57XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlSXRlbXNNYXAuc2V0KGl0ZW1JRCwgY291bnQpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCA9IFtdXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJdGVtc01hcC5oYXMoaXRlbUlEKSkge1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LnB1c2goaW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LmZvckVhY2goKGluZGV4KT0+e1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkdXBsaWNhdGVJdGVtc01hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBkdXBsaWNhdGVzICgke2NvdW50fSlgKVxuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gY2FwdHVyZSBtYXAgYmVmb3JlIGNoYW5nZXMgLS0tLS0tLS0tLVxuICAgICAgICAvLyAuLi4gdGhpcyBtYXAgaXMgdXNlZCBsYXRlciB0byBpZGVudGlmeSBvcnBoYW5lZCBpdGVtIGFuZCBpbmRleCBjYWNoZSByZWNvcmRzIGZvciBkZWxldGlvblxuXG4gICAgICAgIC8vIGZyb20gdGhlIGxpc3Qgb2YgY2hhbmdlc1xuICAgICAgICAvLyBib3RoIHNpZGVzIG9mIGNoYW5nZSBtYXAuLi5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBiZWZvcmUgY2hhbmdlXG4gICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCk9PntcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSkgLy8gaW5kZXggdG8gYmUgbWFwcGVkXG4gICAgICAgICAgICBvcmlnaW5hbE1hcC5zZXQobWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXgsaXRlbUlEKSAvLyB0YXJnZXQgaXRlbUlEXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAuLi4gYW5kIGZyb20gdGhlIGxpc3Qgb2YgaW5kZXhlcyB0byBiZSBkZWxldGVkXG4gICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBPUEVSQVRJT05TIF09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRlbGV0ZSBsaXN0ZWQgaW5kZXhlcyAtLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIGluZGV4ZXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgaXRlbUlEJ3Mgd2lsbCBiZSBvcnBoYW5lZCwgYnV0IGNvdWxkIGJlIHJlbWFwcGVkLlxuICAgICAgICAvLyBvcnBoYW5zIGFyZSByZXNvbHZlZCBiZWxvd1xuXG4gICAgICAgIGlmIChpbmRleGVzVG9EZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gYXBwbHkgZmlsdGVyZWQgY2hhbmdlcyB0byBjYWNoZSBpbmRleCBtYXAgYW5kIGl0ZW1JRCBtYXAgLS0tLS0tLS0tLVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGV2ZXJ5IHJlbWFpbmluZyBpbmRleCBsaXN0ZWQgd2lsbCBjaGFuZ2UgaXRzIG1hcHBpbmdcblxuICAgICAgICAvLyBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICBpdGVtZGF0YS5pbmRleCA9IGluZGV4IC8vIG1vZGlmaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDJcblxuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkTWFwLnNldChpbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBwcm9jZXNzZWRJbmRleExpc3QucHVzaChpbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGxvb2sgZm9yIGFuZCBkZWxldGUgaXRlbSBhbmQgaW5kZXggb3JwaGFucyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luYWwgaXRlbSdzIGluZGV4IGhhcyBub3QgY2hhbmdlZCwgdGhlbiBpdCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIFxuICAgICAgICAvLyAgICAgaXQgaXMgb3JwaGFuZWQsIGFuZCB0aGUgaXRlbSBpcyBkZWxldGVkXG4gICAgICAgIC8vIGlmIHRoZSBpdGVtJ3MgaW5kZXggaGFzIGNoYW5nZWQsIGJ1dCB0aGUgb3JpZ2luYWwgaXRlbSBpbmRleCBtYXAgc3RpbGwgcG9pbnRzIHRvIHRoZSBpdGVtLFxuICAgICAgICAvLyAgICAgdGhlbiB0aGUgaW5kZXggaXMgb3JwaGFuZWQgKGR1cGxpY2F0ZSksIGFuZCBkZWxldGVkXG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBvcnBoYW5lZCBpbmRleFxuICAgICAgICBjb25zdCBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IFtdIC8vIGhvbGQgZGVsZXRlZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBjcmFkbGUgc3luY2hcblxuICAgICAgICBvcmlnaW5hbE1hcC5mb3JFYWNoKChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JREluZGV4ID0gbWV0YWRhdGFNYXAuZ2V0KG9yaWdpbmFsSXRlbUlEKS5pbmRleFxuXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJdGVtSURJbmRleCA9PSBmaW5hbEl0ZW1JREluZGV4KSB7IC8vIG5vdCByZW1hcHBlZCwgdGhlcmVmb3JlIG9ycGhhbmVkXG5cbiAgICAgICAgICAgICAgICBkZWxldGVkSXRlbUlEVG9JbmRleE1hcC5zZXQob3JpZ2luYWxJdGVtSUQsIG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRpdGlvbklEIH0gPSBtZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0LnB1c2goe2l0ZW1JRDpvcmlnaW5hbEl0ZW1JRCwgcGFydGl0aW9uSUR9KVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JRClcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVtYXBwZWQsIGNoZWNrIGZvciBvcnBoYW5lZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKG9yaWdpbmFsSXRlbUlESW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxJdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEl0ZW1JRCA9PSBvcmlnaW5hbEl0ZW1JRCkgeyAvLyB0aGUgaW5kZXggaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAuc2V0KG9yaWdpbmFsSXRlbUlESW5kZXgsIG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgY2hhbmdlZCBjYWNoZVxuICAgICAgICAvLyBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZCA9IHRydWVcbiAgICAgICAgLy8gY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGFwcGx5IGNoYW5nZXMgdG8gZXh0YW50IGNlbGxGcmFtZXMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHVzZWQgdG8gcmVjb25jaWxlIGNyYWRsZSBjZWxsRnJhbWVzLCBhbmQgYWxzbyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGNvbnN0IHByb2Nlc3NlZEluZGV4TGlzdCA9IEFycmF5LmZyb20ocHJvY2Vzc2VkTWFwLmtleXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAudmFsdWVzKCkpXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICAvLyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uLi4uXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QgPSBBcnJheS5mcm9tKGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLmtleXMoKSkgXG5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kZXhMaXN0ID0gW1xuICAgICAgICAgICAgLi4ucHJvY2Vzc2VkSW5kZXhMaXN0LFxuICAgICAgICAgICAgLi4uaW5kZXhlc1RvRGVsZXRlTGlzdCwgXG4gICAgICAgICAgICAuLi5kZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdFxuICAgICAgICBdXG5cbiAgICAgICAgbW9kaWZpZWRJbmRleExpc3QgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kaWZpZWRJbmRleExpc3QudmFsdWVzKCkpKSAvLyByZW1vdmUgZHVwbGljYXRlc1xuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLmNyZWF0ZU5ld0l0ZW1JRHMoaW5kZXhlc1RvUmVwbGFjZUl0ZW1JRExpc3QpXG5cbiAgICAgICAgY29udGVudEhhbmRsZXIucmVjb25jaWxlQ2VsbEZyYW1lcyhtb2RpZmllZEluZGV4TGlzdClcblxuICAgICAgICBtb2RpZmllZEluZGV4TGlzdCA9IG1vZGlmaWVkSW5kZXhMaXN0LmNvbmNhdChpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdClcblxuICAgICAgICBjYWNoZUhhbmRsZXIucG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0ID0gcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0LmNvbmNhdChwYXJ0aXRpb25JdGVtc1RvUmVwbGFjZUxpc3QpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseXJlbWFwY2hhbmdlcycpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSByZXR1cm5zIGZvciB1c2VyIGluZm9ybWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgcmV0dXJuIFtcblxuICAgICAgICAgICAgbW9kaWZpZWRJbmRleExpc3QsIFxuICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QsIFxuICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUl0ZW1JRExpc3QsXG4gICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJdGVtSURMaXN0LCBcbiAgICAgICAgICAgIGRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCxcbiAgICAgICAgICAgIGVycm9yRW50cmllc01hcCwgXG4gICAgICAgICAgICBjaGFuZ2VNYXBcblxuICAgICAgICBdXG5cbiAgICB9XG5cbiAgICAvLyBtb3ZlIG11c3QgYmUgZW50aXJlbHkgd2l0aGluIGxpc3QgYm91bmRzXG4gICAgLy8gcmV0dXJucyBsaXN0IG9mIHByb2Nlc3NlZCBpbmRleGVzXG4gICAgcHVibGljIG1vdmVJbmRleCA9ICh0b2xvd2luZGV4LCBmcm9tbG93aW5kZXgsIGZyb21oaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGNvbmZpcm0gdmFsaWRpdHkgb2YgYXJndW1lbnRzIC0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBpc1RvaW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIodG9sb3dpbmRleCkgfHwgIW1pblZhbHVlKHRvbG93aW5kZXgsIDApKVxuICAgICAgICBjb25zdCBpc0Zyb21pbmRleEludmFsaWQgPSAoIWlzSW50ZWdlcihmcm9tbG93aW5kZXgpIHx8ICFtaW5WYWx1ZShmcm9tbG93aW5kZXgsIDApKVxuICAgICAgICBsZXQgaXNIaWdocmFuZ2VJbnZhbGlkID0gZmFsc2VcblxuICAgICAgICBpZiAoKCFpc0Zyb21pbmRleEludmFsaWQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQmxhbmsoZnJvbWhpZ2hpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpc0hpZ2hyYW5nZUludmFsaWQgPSAhbWluVmFsdWUoZnJvbWhpZ2hpbmRleCwgZnJvbWxvd2luZGV4KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9taGlnaGluZGV4ID0gZnJvbWxvd2luZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRvbG93aW5kZXggPSArdG9sb3dpbmRleFxuICAgICAgICBmcm9tbG93aW5kZXggPSArZnJvbWxvd2luZGV4XG4gICAgICAgIGZyb21oaWdoaW5kZXggPSArZnJvbWhpZ2hpbmRleFxuXG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIGVycm9yIGFycmF5IGluc3RlYWRcbiAgICAgICAgaWYgKGlzVG9pbmRleEludmFsaWQgfHwgaXNGcm9taW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgbW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgZnJvbWhpZ2hyYW5nZSknKVxuICAgICAgICAgICAgaXNUb2luZGV4SW52YWxpZCAmJiBjb25zb2xlLmxvZyh0b2xvd2luZGV4LCBlcnJvck1lc3NhZ2VzLm1vdmVUbylcbiAgICAgICAgICAgIGlzRnJvbWluZGV4SW52YWxpZCAmJiBjb25zb2xlLmxvZyhmcm9tbG93aW5kZXgsIGVycm9yTWVzc2FnZXMubW92ZUZyb20pXG4gICAgICAgICAgICBpc0hpZ2hyYW5nZUludmFsaWQgJiYgY29uc29sZS5sb2coZnJvbWhpZ2hpbmRleCwgZXJyb3JNZXNzYWdlcy5tb3ZlUmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIHRvbG93aW5kZXggPSBNYXRoLm1heCgwLHRvbG93aW5kZXgpXG4gICAgICAgIGZyb21sb3dpbmRleCA9IE1hdGgubWF4KDAsZnJvbWxvd2luZGV4KVxuICAgICAgICBmcm9taGlnaGluZGV4ID0gTWF0aC5tYXgoMCxmcm9taGlnaGluZGV4KVxuXG4gICAgICAgIGNvbnN0IGZyb21zcGFuID0gZnJvbWhpZ2hpbmRleCAtIGZyb21sb3dpbmRleCArIDFcblxuICAgICAgICBsZXQgdG9oaWdoaW5kZXggPSB0b2xvd2luZGV4ICsgZnJvbXNwYW4gLSAxXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBjb2VyY2UgcGFyYW1ldGVycyB0byBsaXN0IGJvdW5kcyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBrZWVwIHdpdGhpbiBjdXJyZW50IGxpc3Qgc2l6ZVxuICAgICAgICBjb25zdCBsaXN0aGlnaGluZGV4ID0gbGlzdHNpemUgLSAxXG5cbiAgICAgICAgaWYgKHRvaGlnaGluZGV4ID4gbGlzdGhpZ2hpbmRleCkge1xuXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdG9oaWdoaW5kZXggLSBsaXN0aGlnaGluZGV4XG4gICAgICAgICAgICB0b2hpZ2hpbmRleCA9IE1hdGgubWF4KDAsdG9oaWdoaW5kZXggLSBkaWZmKVxuICAgICAgICAgICAgdG9sb3dpbmRleCA9IE1hdGgubWF4KDAsdG9sb3dpbmRleCAtIGRpZmYpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9taGlnaGluZGV4ID4gbGlzdGhpZ2hpbmRleCkge1xuXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZnJvbWhpZ2hpbmRleCAtIGxpc3RoaWdoaW5kZXhcbiAgICAgICAgICAgIGZyb21oaWdoaW5kZXggPSBNYXRoLm1heCgwLGZyb21oaWdoaW5kZXggLSBkaWZmKVxuICAgICAgICAgICAgZnJvbWxvd2luZGV4ID0gTWF0aC5tYXgoMCxmcm9tbG93aW5kZXggLSBkaWZmKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGNvbnN0cmFpbiBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkbzsgbm8gZGlzcGxhY2VtZW50XG4gICAgICAgIGlmIChmcm9tbG93aW5kZXggPT0gdG9sb3dpbmRleCkgcmV0dXJuIFtdIFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIHBlcmZvcm0gY2FjaGUgYW5kIGNyYWRsZSBvcGVyYXRpb25zIC0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSAvLyBib3RoIGRpc3BsYWNlZCBhbmQgbW92ZWQgaW5kZXhlc1xuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLm1vdmVJbmRleCh0b2xvd2luZGV4LCBmcm9tbG93aW5kZXgsIGZyb21oaWdoaW5kZXgpXG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZEluZGV4TGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY29udGVudEhhbmRsZXIuc3luY2hyb25pemVDcmFkbGVJdGVtSURzVG9DYWNoZShwcm9jZXNzZWRJbmRleExpc3QpXG5cbiAgICAgICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gY29udGVudEhhbmRsZXJcblxuICAgICAgICAgICAgY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoMCxjb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICAgICAgY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseW1vdmVjaGFuZ2VzJylcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEluZGV4TGlzdFxuXG4gICAgfVxuXG4gICAgcHVibGljIGluc2VydEluZGV4ID0gKGluZGV4LCByYW5nZWhpZ2hpbmRleCA9IG51bGwpID0+IHtcblxuICAgICAgICBjb25zdCBpc0luZGV4SW52YWxpZCA9ICghaXNJbnRlZ2VyKGluZGV4KSB8fCAhbWluVmFsdWUoaW5kZXgsIDApKVxuICAgICAgICBsZXQgaXNIaWdocmFuZ2VJbnZhbGlkID0gZmFsc2VcblxuICAgICAgICBpZiAoKCFpc0luZGV4SW52YWxpZCkpIHtcbiAgICAgICAgICAgIGlmICghaXNCbGFuayhyYW5nZWhpZ2hpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpc0hpZ2hyYW5nZUludmFsaWQgPSAhbWluVmFsdWUocmFuZ2VoaWdoaW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZWhpZ2hpbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICtpbmRleFxuXG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gK3JhbmdlaGlnaGluZGV4XG5cbiAgICAgICAgaWYgKGlzSW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgaW5zZXJ0SW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4KScpXG4gICAgICAgICAgICBpc0luZGV4SW52YWxpZCAmJiBjb25zb2xlLmxvZyhpbmRleCwgZXJyb3JNZXNzYWdlcy5pbnNlcnRGcm9tKVxuICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkICYmIGNvbnNvbGUubG9nKHJhbmdlaGlnaGluZGV4LCBlcnJvck1lc3NhZ2VzLmluc2VydFJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgKzEpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIoaW5kZXgpIHx8ICFtaW5WYWx1ZShpbmRleCwgMCkpXG4gICAgICAgIGxldCBpc0hpZ2hyYW5nZUludmFsaWQgPSBmYWxzZVxuXG4gICAgICAgIGlmICgoIWlzSW5kZXhJbnZhbGlkKSkge1xuICAgICAgICAgICAgaWYgKCFpc0JsYW5rKHJhbmdlaGlnaGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCA9ICFtaW5WYWx1ZShyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlaGlnaGluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gK2luZGV4XG4gICAgICAgIHJhbmdlaGlnaGluZGV4ID0gK3JhbmdlaGlnaGluZGV4XG5cbiAgICAgICAgaWYgKGlzSW5kZXhJbnZhbGlkIHx8IGlzSGlnaHJhbmdlSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JJR1MgRVJST1IgbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCknKVxuICAgICAgICAgICAgaXNJbmRleEludmFsaWQgJiYgY29uc29sZS5sb2coaW5kZXgsIGVycm9yTWVzc2FnZXMucmVtb3ZlRnJvbSlcbiAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCAmJiBjb25zb2xlLmxvZyhyYW5nZWhpZ2hpbmRleCwgZXJyb3JNZXNzYWdlcy5yZW1vdmVSYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRSZW1vdmVJbmRleChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIC0xKVxuXG4gICAgfVxuXG4gICAgbmV3bGlzdHNpemVcblxuICAgIC8vIHNoYXJlZCBsb2dpYyBmb3IgaW5zZXJ0IGFuZCByZW1vdmUuIFJldHVybnMgbGlzdHMgb2YgaW5kZXhlcyBzaGlmdGVkLCByZXBsYWNlZCwgYW5kIHJlbW92ZWRcbiAgICAvLyB0aGlzIG9wZXJhdGlvbiBjaGFuZ2VzIHRoZSBsaXN0c2l6ZVxuICAgIHByaXZhdGUgaW5zZXJ0UmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCBpbmNyZW1lbnQpID0+IHtcblxuICAgICAgICAvLyBiYXNpYyBhc3NlcnRpb25zXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCxpbmRleClcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSBNYXRoLm1heChyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBhc3NlbWJsZSByZXNvdXJjZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gcHJvY2VzcyBjYWNoZSAtLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuICAgICAgICBpZiAobGlzdHNpemUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKGluY3JlbWVudCA+IDApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldExpc3RzaXplKHJhbmdlaGlnaGluZGV4IC0gaW5kZXggKyAxKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1tdLFtdLFtdXVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3N0YXJ0Q2hhbmdlSW5kZXgsIHJhbmdlaW5jcmVtZW50LCBzaGlmdGVkTGlzdCwgcmVtb3ZlZExpc3QsIHJlcGxhY2VMaXN0LCBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3RdID0gXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCBpbmNyZW1lbnQsIGxpc3RzaXplKSAvLywgY3JhZGxlSW5kZXhTcGFuKVxuXG4gICAgICAgIGlmIChyYW5nZWluY3JlbWVudCA9PT0gbnVsbCkgcmV0dXJuIFtbXSxbXSxbXV0gLy8gbm8gYWN0aW9uXG5cbiAgICAgICAgLy8gcGFydGl0aW9uSXRlbXMgdG8gZGVsZXRlIHdpdGggZm9sbG93dXAgc3RhdGUgY2hhbmdlcyAtIG11c3QgaGFwcGVuIGFmdGVyIGNyYWRsZSB1cGRhdGVcbiAgICAgICAgY2FjaGVIYW5kbGVyLnBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gc3luY2hyb25pemUgY3JhZGxlIHRvIGNhY2hlIGNoYW5nZXMgLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiBjcmFkbGUgbXVzdCBiZSByZXNldCBvciBzaW1wbHkgYWRqdXN0ZWRcbiAgICAgICAgY29uc3QgY2hhbmdlY291bnQgPSByYW5nZWluY3JlbWVudCAvLyBzZW1hbnRpY3NcbiAgICAgICAgY29uc3QgbmV3bGlzdHNpemUgPSB0aGlzLm5ld2xpc3RzaXplID0gbGlzdHNpemUgKyBjaGFuZ2Vjb3VudFxuXG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnRSb3djb3VudCwgY3Jvc3Njb3VudCB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHsgcnVud2F5U2l6ZSB9ID0gIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50ID0gdmlld3BvcnRSb3djb3VudCArIChydW53YXlTaXplICogMilcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZENyYWRsZUl0ZW1jb3VudCA9IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcblxuICAgICAgICBjb25zdCBpbmRleFNwYW4gPSBjb250ZW50SGFuZGxlci5pbmRleFNwYW5cbiAgICAgICAgY29uc3QgW2xvd0luZGV4LGhpZ2hJbmRleF0gPSBpbmRleFNwYW5cbiAgICAgICAgY29uc3QgbWVhc3VyZWRDcmFkbGVJdGVtQ291bnQgPSAoaW5kZXhTcGFuLmxlbmd0aCA9PSAwKT8wOmhpZ2hJbmRleCAtIGxvd0luZGV4ICsgMVxuXG4gICAgICAgIGNvbnN0IHJlc2V0Q3JhZGxlID0gKChtZWFzdXJlZENyYWRsZUl0ZW1Db3VudCA8IGNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQpIHx8IFxuICAgICAgICAgICAgKGNvbnRlbnRIYW5kbGVyLmluZGV4U3BhblsxXSA+PSAobmV3bGlzdHNpemUgLSAxKSkpXG5cbiAgICAgICAgaWYgKCFyZXNldENyYWRsZSkgeyAvLyBzeW5jaHJvbml6ZSBjcmFkbGUgY29udGVudHMgdG8gY2hhbmdlc1xuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5zeW5jaHJvbml6ZUNyYWRsZUl0ZW1JRHNUb0NhY2hlKHNoaWZ0ZWRMaXN0LCBpbmNyZW1lbnQsIHN0YXJ0Q2hhbmdlSW5kZXgpIC8vIG5vbi16ZXJvIGNvbW11bmljYXRpb25zIGlzSW5zZXJ0UmVtb3ZlXG5cbiAgICAgICAgICAgIC8vIGlmIChpbmNyZW1lbnQgPT0gKzEpIGNvbnRlbnRIYW5kbGVyLmNyZWF0ZU5ld0l0ZW1JRHMocmVwbGFjZUxpc3QpXG5cbiAgICAgICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gY29udGVudEhhbmRsZXJcblxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkU2V0ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IC8vIHdhaXQgdW50aWwgY2hhbmdlZCBjYWNoZSBlbnRyaWVzIHVwZGF0ZSB0aGUgY3JhZGxlXG5cbiAgICAgICAgICAgICAgICBpZighcmVxdWVzdGVkU2V0LnNpemUpIHsgLy8gZmluaXNoZWQgY29sbGVjdGluZyBuZXcgY2FjaGUgZW50cmllc1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZW91dCk7IFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5aW5zZXJ0cmVtb3ZlY2hhbmdlcycpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gY3JhZGxlIHRvIGJlIGNvbXBsZXRlbHkgcmVzZXQgaWYgbGlzdHNpemUgY2hhbmdlIGVuY3JvYWNoZXMgb24gY3JhZGxlXG5cbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2hhbm5lbGNyYWRsZXJlc2V0YWZ0ZXJpbnNlcnRyZW1vdmUnKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXBsYWNlZExpc3QgPSByZXBsYWNlTGlzdCAvLyBzZW1hbnRpY3NcblxuICAgICAgICByZXR1cm4gW3NoaWZ0ZWRMaXN0LCByZXBsYWNlZExpc3QsIHJlbW92ZWRMaXN0XSAvLyBpbmZvcm0gY2FsbGVyXG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiaXNCbGFuayIsInRlc3R2YWx1ZSIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUludCIsImlzSW50ZWdlciIsIk1hdGgiLCJmbG9vciIsIm1pblZhbHVlIiwidGVzdE1pblZhbHVlIiwibWF4VmFsdWUiLCJ0ZXN0TWF4VmFsdWUiLCJlcnJvck1lc3NhZ2VzIiwic2Nyb2xsVG9JbmRleCIsInNldExpc3RzaXplIiwiaW5zZXJ0RnJvbSIsImluc2VydFJhbmdlIiwicmVtb3ZlRnJvbSIsInJlbW92ZVJhbmdlIiwibW92ZUZyb20iLCJtb3ZlUmFuZ2UiLCJtb3ZlVG8iLCJTZXJ2aWNlSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJfdGhpcyIsInJlbG9hZCIsInN0YXRlSGFuZGxlciIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImludGVycnVwdEhhbmRsZXIiLCJwYXVzZUludGVycnVwdHMiLCJzZXRDcmFkbGVTdGF0ZSIsImluZGV4IiwiaXNJbnZhbGlkIiwiY29uc29sZSIsImxvZyIsInNpZ25hbHMiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIiLCJsYXlvdXRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwibmV3bGlzdHNpemUiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY2FjaGVIYW5kbGVyIiwiY29udGVudEhhbmRsZXIiLCJfdGhpcyRjYWxsYmFja3MiLCJjYWxsYmFja3MiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwiY3VycmVudGxpc3RzaXplIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwibGlzdHNpemUiLCJjYWNoZSIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsInVwZGF0ZUxpc3RzaXplIiwiY2hhbmdlQ2FjaGVMaXN0c2l6ZSIsInJlbmRlclBvcnRhbExpc3RzIiwiZ2V0Q2FjaGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsImdldENyYWRsZUluZGV4TWFwIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyMyIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJjbGVhckNhY2hlIiwicmVtYXBJbmRleGVzIiwiY2hhbmdlTWFwIiwic2l6ZSIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjQiLCJfY2FjaGVIYW5kbGVyJGNhY2hlUHIiLCJjYWNoZVByb3BzIiwibWV0YWRhdGFNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwiaW5kZXhlc1RvRGVsZXRlTGlzdCIsImluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0IiwicGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0IiwiY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCIsIk1hcCIsImVycm9yRW50cmllc01hcCIsIndvcmtpbmdDaGFuZ2VNYXAiLCJmb3JFYWNoIiwiaXRlbUlEIiwiaGFzIiwiY2FjaGVJdGVtSUQiLCJnZXQiLCJfbWV0YWRhdGFNYXAkZ2V0IiwicGFydGl0aW9uSUQiLCJzZXQiLCJpdGVtc1RvUmVwbGFjZVNldCIsIlNldCIsImFkZCIsImNvbmNhdCIsIm1hcHNpemUiLCJpdGVtSURTZXQiLCJ2YWx1ZXMiLCJpdGVtc2V0c2l6ZSIsIml0ZW1JRENvdW50TWFwIiwiY291bnQiLCJkdXBsaWNhdGVJdGVtc01hcCIsImR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QiLCJvcmlnaW5hbE1hcCIsInByb2Nlc3NlZEluZGV4TGlzdCIsIml0ZW1kYXRhIiwiZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAiLCJkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCIsInBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCIsIm9yaWdpbmFsSXRlbUlEIiwib3JpZ2luYWxJdGVtSURJbmRleCIsImZpbmFsSXRlbUlESW5kZXgiLCJfbWV0YWRhdGFNYXAkZ2V0MiIsImZpbmFsSXRlbUlEIiwiZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCIsImRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCIsImtleXMiLCJkZWxldGVkT3JwaGFuZWRJdGVtSURMaXN0IiwibW9kaWZpZWRJbmRleExpc3QiLCJjcmVhdGVOZXdJdGVtSURzIiwicmVjb25jaWxlQ2VsbEZyYW1lcyIsIm1vdmVJbmRleCIsInRvbG93aW5kZXgiLCJmcm9tbG93aW5kZXgiLCJmcm9taGlnaGluZGV4IiwiYXJndW1lbnRzIiwiaXNUb2luZGV4SW52YWxpZCIsImlzRnJvbWluZGV4SW52YWxpZCIsImlzSGlnaHJhbmdlSW52YWxpZCIsIm1heCIsImZyb21zcGFuIiwidG9oaWdoaW5kZXgiLCJsaXN0aGlnaGluZGV4IiwiZGlmZiIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjUiLCJzeW5jaHJvbml6ZUNyYWRsZUl0ZW1JRHNUb0NhY2hlIiwiY29udGVudCIsImhlYWRNb2RlbENvbXBvbmVudHMiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwiaW5zZXJ0SW5kZXgiLCJyYW5nZWhpZ2hpbmRleCIsImlzSW5kZXhJbnZhbGlkIiwiaW5zZXJ0UmVtb3ZlSW5kZXgiLCJyZW1vdmVJbmRleCIsImluY3JlbWVudCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjYiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiX2NhY2hlSGFuZGxlciRpbnNlcnRSIiwiX2NhY2hlSGFuZGxlciRpbnNlcnRSMiIsInN0YXJ0Q2hhbmdlSW5kZXgiLCJyYW5nZWluY3JlbWVudCIsInNoaWZ0ZWRMaXN0IiwicmVtb3ZlZExpc3QiLCJyZXBsYWNlTGlzdCIsImNoYW5nZWNvdW50Iiwidmlld3BvcnRSb3djb3VudCIsImNyb3NzY291bnQiLCJydW53YXlTaXplIiwiY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50IiwiY2FsY3VsYXRlZENyYWRsZUl0ZW1jb3VudCIsImluZGV4U3BhbiIsIl9pbmRleFNwYW4iLCJsb3dJbmRleCIsImhpZ2hJbmRleCIsIm1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50IiwicmVzZXRDcmFkbGUiLCJyZXF1ZXN0ZWRTZXQiLCJ0aW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmVwbGFjZWRMaXN0IiwiX2NyYWRsZVBhcmFtZXRlcnMkZXh0IiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n')},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// statehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to the cradle state and the state setting for other handlers.\n   It also provides access to the isMountedRef reference.\n*/\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUEsU0FBQUEsUUFBQUMsR0FBQSxzQ0FBQUQsT0FBQSx3QkFBQUUsTUFBQSx1QkFBQUEsTUFBQSxDQUFBQyxRQUFBLGFBQUFGLEdBQUEsa0JBQUFBLEdBQUEsZ0JBQUFBLEdBQUEsV0FBQUEsR0FBQSx5QkFBQUMsTUFBQSxJQUFBRCxHQUFBLENBQUFHLFdBQUEsS0FBQUYsTUFBQSxJQUFBRCxHQUFBLEtBQUFDLE1BQUEsQ0FBQUcsU0FBQSxxQkFBQUosR0FBQSxLQUFBRCxPQUFBLENBQUFDLEdBQUE7QUFBQSxTQUFBSyxrQkFBQUMsTUFBQSxFQUFBQyxLQUFBLGFBQUFDLENBQUEsTUFBQUEsQ0FBQSxHQUFBRCxLQUFBLENBQUFFLE1BQUEsRUFBQUQsQ0FBQSxVQUFBRSxVQUFBLEdBQUFILEtBQUEsQ0FBQUMsQ0FBQSxHQUFBRSxVQUFBLENBQUFDLFVBQUEsR0FBQUQsVUFBQSxDQUFBQyxVQUFBLFdBQUFELFVBQUEsQ0FBQUUsWUFBQSx3QkFBQUYsVUFBQSxFQUFBQSxVQUFBLENBQUFHLFFBQUEsU0FBQUMsTUFBQSxDQUFBQyxjQUFBLENBQUFULE1BQUEsRUFBQVUsY0FBQSxDQUFBTixVQUFBLENBQUFPLEdBQUEsR0FBQVAsVUFBQTtBQUFBLFNBQUFRLGFBQUFDLFdBQUEsRUFBQUMsVUFBQSxFQUFBQyxXQUFBLFFBQUFELFVBQUEsRUFBQWYsaUJBQUEsQ0FBQWMsV0FBQSxDQUFBZixTQUFBLEVBQUFnQixVQUFBLE9BQUFDLFdBQUEsRUFBQWhCLGlCQUFBLENBQUFjLFdBQUEsRUFBQUUsV0FBQSxHQUFBUCxNQUFBLENBQUFDLGNBQUEsQ0FBQUksV0FBQSxpQkFBQU4sUUFBQSxtQkFBQU0sV0FBQTtBQUFBLFNBQUFILGVBQUFNLEdBQUEsUUFBQUwsR0FBQSxHQUFBTSxZQUFBLENBQUFELEdBQUEsb0JBQUF2QixPQUFBLENBQUFrQixHQUFBLGlCQUFBQSxHQUFBLEdBQUFPLE1BQUEsQ0FBQVAsR0FBQTtBQUFBLFNBQUFNLGFBQUFFLEtBQUEsRUFBQUMsSUFBQSxRQUFBM0IsT0FBQSxDQUFBMEIsS0FBQSxrQkFBQUEsS0FBQSxrQkFBQUEsS0FBQSxNQUFBRSxJQUFBLEdBQUFGLEtBQUEsQ0FBQXhCLE1BQUEsQ0FBQTJCLFdBQUEsT0FBQUQsSUFBQSxLQUFBRSxTQUFBLFFBQUFDLEdBQUEsR0FBQUgsSUFBQSxDQUFBSSxJQUFBLENBQUFOLEtBQUEsRUFBQUMsSUFBQSxvQkFBQTNCLE9BQUEsQ0FBQStCLEdBQUEsdUJBQUFBLEdBQUEsWUFBQUUsU0FBQSw0REFBQU4sSUFBQSxnQkFBQUYsTUFBQSxHQUFBUyxNQUFBLEVBQUFSLEtBQUE7QUFBQSxTQUFBUyxnQkFBQUMsUUFBQSxFQUFBaEIsV0FBQSxVQUFBZ0IsUUFBQSxZQUFBaEIsV0FBQSxlQUFBYSxTQUFBOzs7O0FBRUE7Ozs7QUFBQSxJQUtxQkksWUFBWSxnQkFBQWxCLFlBQUEsQ0FFN0IsU0FBQWtCLGFBQVlDLGdCQUFnQjtFQUFBSCxlQUFBLE9BQUFFLFlBQUE7RUFFekIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0EsZ0JBQWdCO0VBRXhDLElBQU1DLGtCQUFrQixHQUFHRCxnQkFBZ0IsQ0FBQ0UsMkJBQTJCLENBQUNDLE9BQU87RUFFL0UsSUFBSSxDQUFDQyxjQUFjLEdBQUdILGtCQUFrQixDQUFDRyxjQUFjO0VBQ3ZELElBQUksQ0FBQ0MsY0FBYyxHQUFHSixrQkFBa0IsQ0FBQ0ksY0FBYztFQUN2RCxJQUFJLENBQUNDLFlBQVksR0FBR0wsa0JBQWtCLENBQUNLLFlBQVk7QUFFdEQsQ0FBQztBQVpMQyxrQkFBQSxHQUFBUixZQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvc3RhdGVoYW5kbGVyLnRzeD82Mzk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICBUaGlzIG1vZHVsZSBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGNyYWRsZSBzdGF0ZSBhbmQgdGhlIHN0YXRlIHNldHRpbmcgZm9yIG90aGVyIGhhbmRsZXJzLlxuICAgSXQgYWxzbyBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGlzTW91bnRlZFJlZiByZWZlcmVuY2UuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgY29uc3QgaW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgdGhpcy5zZXRDcmFkbGVTdGF0ZSA9IGludGVybmFsUHJvcGVydGllcy5zZXRDcmFkbGVTdGF0ZVxuICAgICAgIHRoaXMuY3JhZGxlU3RhdGVSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuY3JhZGxlU3RhdGVSZWZcbiAgICAgICB0aGlzLmlzTW91bnRlZFJlZiA9IGludGVybmFsUHJvcGVydGllcy5pc01vdW50ZWRSZWZcbiAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBjcmFkbGVTdGF0ZVJlZlxuICAgIHB1YmxpYyBzZXRDcmFkbGVTdGF0ZVxuICAgIHB1YmxpYyBpc01vdW50ZWRSZWZcblxufVxuIl0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiY2FsbCIsIlR5cGVFcnJvciIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiU3RhdGVIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImN1cnJlbnQiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaXNNb3VudGVkUmVmIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// styleshandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        cradledividerstyles\n        triggercelltriggerlineheadstyles,\n        triggercelltriggerlinetailstyles,\n*/\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, StylesHandler);\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      gap = _ref.gap,\n      padding = _ref.padding,\n      crosscount = _ref.crosscount,\n      userstyles = _ref.userstyles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      layout = _ref.layout;\n    var headstyles = _this.getBaseHeadStyles(gap, padding, orientation, userstyles.cradle);\n    var tailstyles = _this.getBaseTailStyles(gap, padding, orientation, userstyles.cradle);\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation);\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gap = tailstyles.gap = gap + 'px';\n    // headstyles.padding set in contentHandler setCradleContent and updateCradleContent\n    if (orientation == 'vertical') {\n      // padding varies\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      // the following are identical for head and tail\n      headstyles.width = tailstyles.width = '100%';\n      headstyles.height = tailstyles.height = 'auto';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = null;\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellWidth, \"px, 1fr))\");\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'row';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = layout == 'uniform' ? null : 'max-content';\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = null;\n    } else {\n      // orientation == 'horizontal'\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      headstyles.width = tailstyles.width = 'auto';\n      headstyles.height = tailstyles.height = '100%';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\");\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = null;\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'column';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = null;\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = layout == 'uniform' ? null : 'max-content';\n    }\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = null;\n      right = null;\n      top = null;\n    } else {\n      bottom = null;\n      left = null;\n      right = 0;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = null;\n      left = null;\n      right = null;\n      top = 0;\n    } else {\n      bottom = null;\n      left = 0;\n      right = null;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n  this.getAxisStyles = function (gap, padding, orientation) {\n    var top, left, width, height; // for axis\n    if (orientation == 'vertical') {\n      top = padding + 'px'; // default\n      left = 'auto';\n      width = '100%';\n      height = 0;\n    } else {\n      top = 'auto';\n      left = padding + 'px'; // default\n      width = 0;\n      height = '100%';\n    }\n    return {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = triggerlineOffset + 'px';\n      right = '0px';\n      bottom = null;\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = null;\n      bottom = '0px';\n      left = triggerlineOffset + 'px';\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = null;\n      right = '0px';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = -(triggerlineOffset + gap) + 'px';\n      bottom = '0px';\n      left = null;\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVLLGlCQUFpQixFQUFFSixHQUFHLEVBQUk7SUFFL0QsSUFBTW1CLFFBQVEsR0FBRyxVQUFVO0lBRTNCLElBQUlDLEtBQUssRUFBRUMsTUFBTSxFQUFFVyxHQUFHLEVBQUVDLEtBQUssRUFBRUgsTUFBTSxFQUFFQyxJQUFJO0lBQzNDLElBQUlsQyxXQUFXLElBQUksVUFBVSxFQUFFO01BRTNCdUIsS0FBSyxHQUFHLE1BQU07TUFDZEMsTUFBTSxHQUFHLENBQUM7TUFDVlcsR0FBRyxHQUFHLElBQUk7TUFDVkMsS0FBSyxHQUFHLEtBQUs7TUFDYkgsTUFBTSxHQUFHLEVBQUUxQixpQkFBaUIsR0FBR0osR0FBRyxDQUFDLEdBQUcsSUFBSTtNQUMxQytCLElBQUksR0FBRyxLQUFLO0tBRWYsTUFBTTtNQUVIWCxLQUFLLEdBQUcsQ0FBQztNQUNUQyxNQUFNLEdBQUcsTUFBTTtNQUNmVyxHQUFHLEdBQUcsS0FBSztNQUNYQyxLQUFLLEdBQUcsRUFBRTdCLGlCQUFpQixHQUFHSixHQUFHLENBQUMsR0FBRyxJQUFJO01BQ3pDOEIsTUFBTSxHQUFHLEtBQUs7TUFDZEMsSUFBSSxHQUFHLElBQUk7O0lBSWYsT0FBTztNQUVIWixRQUFRLEVBQVJBLFFBQVE7TUFDUkMsS0FBSyxFQUFMQSxLQUFLO01BQ0xDLE1BQU0sRUFBTkEsTUFBTTtNQUNOVyxHQUFHLEVBQUhBLEdBQUc7TUFDSEMsS0FBSyxFQUFMQSxLQUFLO01BQ0xILE1BQU0sRUFBTkEsTUFBTTtNQUNOQyxJQUFJLEVBQUpBO0tBRUg7RUFDTCxDQUFDO0VBdlJDLElBQUksQ0FBQ3RDLGdCQUFnQixHQUFHQSxnQkFBZ0I7QUFFMUMsQ0FBQztBQU5MOEMsa0JBQUEsR0FBQS9DLGFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zdHlsZXNoYW5kbGVyLnRzeD80NWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlc2hhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBDcmFkbGUgY29tcG9uZW50IHdpdGggb25lIGtleSBmdW5jdGlvbjogZ2V0Q3JhZGxlU3R5bGVzLlxuICAgIEl0IHJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyBmb3JcbiAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgdGFpbHN0eWxlcyxcbiAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgY3JhZGxlZGl2aWRlcnN0eWxlc1xuICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMsXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZXNIYW5kbGVyIHsgXG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlU3R5bGVzID0gKHtcblxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAvLyBjZWxsTWluSGVpZ2h0LFxuICAgICAgICAvLyBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAvLyB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIC8vIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHVzZXJzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgaGVhZHN0eWxlcyA9IHRoaXMuZ2V0QmFzZUhlYWRTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IHRhaWxzdHlsZXMgPSB0aGlzLmdldEJhc2VUYWlsU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24sIHVzZXJzdHlsZXMuY3JhZGxlKVxuICAgICAgICBjb25zdCBheGlzc3R5bGVzID0gdGhpcy5nZXRBeGlzU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24pXG5cbiAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZWhlYWRzdHlsZXMgPVxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyhcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApXG4gICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzID0gXG4gICAgICAgICAgICB0aGlzLmdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcClcblxuICAgICAgICBjb25zdCBjcmFkbGVkaXZpZGVyc3R5bGVzID0gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgekluZGV4OjEsIFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OicwIDAgNXB4IDNweCByZWQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaGVhZHN0eWxlcy5nYXAgPSB0YWlsc3R5bGVzLmdhcCA9IGdhcCArICdweCdcblxuICAgICAgICAvLyBoZWFkc3R5bGVzLnBhZGRpbmcgc2V0IGluIGNvbnRlbnRIYW5kbGVyIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgLy8gcGFkZGluZyB2YXJpZXNcbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAwICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBpZGVudGljYWwgZm9yIGhlYWQgYW5kIHRhaWxcbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSB0YWlsc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9IHRhaWxzdHlsZXMuaGVpZ2h0ID0gJ2F1dG8nXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsV2lkdGh9cHgsIDFmcikpYFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvRmxvdyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ3JvdydcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b1Jvd3MgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9Sb3dzID1cbiAgICAgICAgICAgICAgICAobGF5b3V0ID09ICd1bmlmb3JtJyk/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICdtYXgtY29udGVudCdcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSB0YWlsc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IG51bGxcblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSB0YWlsc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9IHRhaWxzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdjb2x1bW4nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvUm93cyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9Sb3dzID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICAobGF5b3V0ID09ICd1bmlmb3JtJyk/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICdtYXgtY29udGVudCdcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhlYWRzdHlsZXMsXG4gICAgICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzLFxuICAgICAgICBdXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIHRoZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgc2V0dGluZyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiBleHBhbnNpb24gb2YgdGhlIGdyaWQgYmxvY2tcbiAgICBwcml2YXRlIGdldEJhc2VIZWFkU3R5bGVzID0gXG4gICAgICAgIChnYXAscGFkZGluZyxvcmllbnRhdGlvbix1c2VyaGVhZHN0eWxlcykgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gMFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnVzZXJoZWFkc3R5bGVzLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBzZXR0aW5nIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIGV4cGFuc2lvbiBvZiB0aGUgZ3JpZCBibG9ja1xuICAgIHByaXZhdGUgZ2V0QmFzZVRhaWxTdHlsZXMgPSBcbiAgICAgICAgKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJ0YWlsc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gMFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udXNlcnRhaWxzdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRBeGlzU3R5bGVzID0gXG4gICAgICAgIChnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uKSA9PiB7XG5cbiAgICAgICAgbGV0IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCAvLyBmb3IgYXhpc1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHRvcCA9IHBhZGRpbmcgKyAncHgnIC8vIGRlZmF1bHRcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWlnaHQgPSAwXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBsZWZ0ID0gcGFkZGluZyArICdweCcgLy8gZGVmYXVsdFxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IHRyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgcmlnaHQgPSAnMHB4J1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9ICcwcHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRvcCA9ICcwcHgnXG4gICAgICAgICAgICByaWdodCA9IG51bGxcbiAgICAgICAgICAgIGJvdHRvbSA9ICcwcHgnXG4gICAgICAgICAgICBsZWZ0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gJzBweCdcbiAgICAgICAgICAgIGJvdHRvbSA9IC0odHJpZ2dlcmxpbmVPZmZzZXQgKyBnYXApICsgJ3B4J1xuICAgICAgICAgICAgbGVmdCA9ICcwcHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRvcCA9ICcwcHgnXG4gICAgICAgICAgICByaWdodCA9IC0odHJpZ2dlcmxpbmVPZmZzZXQgKyBnYXApICsgJ3B4J1xuICAgICAgICAgICAgYm90dG9tID0gJzBweCdcbiAgICAgICAgICAgIGxlZnQgPSBudWxsXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJTdHlsZXNIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIl90aGlzIiwiZ2V0Q3JhZGxlU3R5bGVzIiwiX3JlZiIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImdhcCIsInBhZGRpbmciLCJjcm9zc2NvdW50IiwidXNlcnN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwibGF5b3V0IiwiaGVhZHN0eWxlcyIsImdldEJhc2VIZWFkU3R5bGVzIiwiY3JhZGxlIiwidGFpbHN0eWxlcyIsImdldEJhc2VUYWlsU3R5bGVzIiwiYXhpc3N0eWxlcyIsImdldEF4aXNTdHlsZXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzIiwidHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMiLCJnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiY29uY2F0IiwiZ3JpZFRlbXBsYXRlUm93cyIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkQXV0b0Zsb3ciLCJncmlkQXV0b1Jvd3MiLCJncmlkQXV0b0NvbHVtbnMiLCJ1c2VyaGVhZHN0eWxlcyIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImFzc2lnbiIsImRpc3BsYXkiLCJncmlkR2FwIiwiYm94U2l6aW5nIiwidXNlcnRhaWxzdHlsZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./src/portalcache/CachePartition.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar CachePartition = function CachePartition(_ref) {\n  var cacheProps = _ref.cacheProps,\n    partitionID = _ref.partitionID,\n    callback = _ref.callback;\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalListCounter = _ref3[0],\n    setPortalListCounter = _ref3[1];\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n    _ref5 = _slicedToArray(_ref4, 2),\n    partitionState = _ref5[0],\n    setPartitionState = _ref5[1];\n  var counterRef = (0, react_1.useRef)(portalListCounter);\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null);\n  var partitionMetadata = cacheProps.partitionMetadataMap.get(partitionID);\n  var forceUpdate = (0, react_1.useCallback)(function (portalRenderList) {\n    portalArrayRef.current = portalRenderList;\n    isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    partitionMetadata.forceUpdate = forceUpdate;\n    callback();\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (partitionState) {\n      case \'setup\':\n        {\n          setPartitionState(\'ready\');\n          break;\n        }\n    }\n  }, [partitionState]);\n  return react_1["default"].createElement("div", {\n    key: partitionID,\n    "data-type": \'cachepartition\',\n    "data-partitionid": partitionID\n  }, portalArrayRef.current);\n};\nexports["default"] = CachePartition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcG9ydGFsY2FjaGUvQ2FjaGVQYXJ0aXRpb24udHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBLFNBQUFBLGVBQUFDLEdBQUEsRUFBQUMsQ0FBQSxXQUFBQyxlQUFBLENBQUFGLEdBQUEsS0FBQUcscUJBQUEsQ0FBQUgsR0FBQSxFQUFBQyxDQUFBLEtBQUFHLDJCQUFBLENBQUFKLEdBQUEsRUFBQUMsQ0FBQSxLQUFBSSxnQkFBQTtBQUFBLFNBQUFBLGlCQUFBLGNBQUFDLFNBQUE7QUFBQSxTQUFBRiw0QkFBQUcsQ0FBQSxFQUFBQyxNQUFBLFNBQUFELENBQUEscUJBQUFBLENBQUEsc0JBQUFFLGlCQUFBLENBQUFGLENBQUEsRUFBQUMsTUFBQSxPQUFBRSxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsU0FBQSxDQUFBQyxRQUFBLENBQUFDLElBQUEsQ0FBQVAsQ0FBQSxFQUFBUSxLQUFBLGFBQUFMLENBQUEsaUJBQUFILENBQUEsQ0FBQVMsV0FBQSxFQUFBTixDQUFBLEdBQUFILENBQUEsQ0FBQVMsV0FBQSxDQUFBQyxJQUFBLE1BQUFQLENBQUEsY0FBQUEsQ0FBQSxtQkFBQVEsS0FBQSxDQUFBQyxJQUFBLENBQUFaLENBQUEsT0FBQUcsQ0FBQSwrREFBQVUsSUFBQSxDQUFBVixDQUFBLFVBQUFELGlCQUFBLENBQUFGLENBQUEsRUFBQUMsTUFBQTtBQUFBLFNBQUFDLGtCQUFBVCxHQUFBLEVBQUFxQixHQUFBLFFBQUFBLEdBQUEsWUFBQUEsR0FBQSxHQUFBckIsR0FBQSxDQUFBc0IsTUFBQSxFQUFBRCxHQUFBLEdBQUFyQixHQUFBLENBQUFzQixNQUFBLFdBQUFyQixDQUFBLE1BQUFzQixJQUFBLE9BQUFMLEtBQUEsQ0FBQUcsR0FBQSxHQUFBcEIsQ0FBQSxHQUFBb0IsR0FBQSxFQUFBcEIsQ0FBQSxJQUFBc0IsSUFBQSxDQUFBdEIsQ0FBQSxJQUFBRCxHQUFBLENBQUFDLENBQUEsVUFBQXNCLElBQUE7QUFBQSxTQUFBcEIsc0JBQUFILEdBQUEsRUFBQUMsQ0FBQSxRQUFBdUIsRUFBQSxXQUFBeEIsR0FBQSxnQ0FBQXlCLE1BQUEsSUFBQXpCLEdBQUEsQ0FBQXlCLE1BQUEsQ0FBQUMsUUFBQSxLQUFBMUIsR0FBQSw0QkFBQXdCLEVBQUEsUUFBQUcsRUFBQSxFQUFBQyxFQUFBLEVBQUFDLEVBQUEsRUFBQUMsRUFBQSxFQUFBQyxJQUFBLE9BQUFDLEVBQUEsT0FBQUMsRUFBQSxpQkFBQUosRUFBQSxJQUFBTCxFQUFBLEdBQUFBLEVBQUEsQ0FBQVYsSUFBQSxDQUFBZCxHQUFBLEdBQUFrQyxJQUFBLFFBQUFqQyxDQUFBLFFBQUFVLE1BQUEsQ0FBQWEsRUFBQSxNQUFBQSxFQUFBLFVBQUFRLEVBQUEsdUJBQUFBLEVBQUEsSUFBQUwsRUFBQSxHQUFBRSxFQUFBLENBQUFmLElBQUEsQ0FBQVUsRUFBQSxHQUFBVyxJQUFBLE1BQUFKLElBQUEsQ0FBQUssSUFBQSxDQUFBVCxFQUFBLENBQUFVLEtBQUEsR0FBQU4sSUFBQSxDQUFBVCxNQUFBLEtBQUFyQixDQUFBLEdBQUErQixFQUFBLGlCQUFBTSxHQUFBLElBQUFMLEVBQUEsT0FBQUwsRUFBQSxHQUFBVSxHQUFBLHlCQUFBTixFQUFBLFlBQUFSLEVBQUEsZUFBQU0sRUFBQSxHQUFBTixFQUFBLGNBQUFiLE1BQUEsQ0FBQW1CLEVBQUEsTUFBQUEsRUFBQSwyQkFBQUcsRUFBQSxRQUFBTCxFQUFBLGFBQUFHLElBQUE7QUFBQSxTQUFBN0IsZ0JBQUFGLEdBQUEsUUFBQWtCLEtBQUEsQ0FBQXFCLE9BQUEsQ0FBQXZDLEdBQUEsVUFBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFBd0MsT0FBQSxHQUFBQyxZQUFBLENBQUFDLG1CQUFBO0FBRUEsSUFBTUMsY0FBYyxHQUFHLFNBQWpCQSxjQUFjQSxDQUFBQyxJQUFBLEVBQTZDO0VBQUEsSUFBdkNDLFVBQVUsR0FBQUQsSUFBQSxDQUFWQyxVQUFVO0lBQUVDLFdBQVcsR0FBQUYsSUFBQSxDQUFYRSxXQUFXO0lBQUVDLFFBQVEsR0FBQUgsSUFBQSxDQUFSRyxRQUFRO0VBRXZELElBQUFDLEtBQUEsR0FBa0QsSUFBQVIsT0FBQSxDQUFBUyxRQUFRLEVBQUMsQ0FBQyxDQUFDO0lBQUFDLEtBQUEsR0FBQW5ELGNBQUEsQ0FBQWlELEtBQUE7SUFBdERHLGlCQUFpQixHQUFBRCxLQUFBO0lBQUVFLG9CQUFvQixHQUFBRixLQUFBO0VBRTlDLElBQUFHLEtBQUEsR0FBNEMsSUFBQWIsT0FBQSxDQUFBUyxRQUFRLEVBQUMsT0FBTyxDQUFDO0lBQUFLLEtBQUEsR0FBQXZELGNBQUEsQ0FBQXNELEtBQUE7SUFBdERFLGNBQWMsR0FBQUQsS0FBQTtJQUFFRSxpQkFBaUIsR0FBQUYsS0FBQTtFQUV4QyxJQUFNRyxVQUFVLEdBQUcsSUFBQWpCLE9BQUEsQ0FBQWtCLE1BQU0sRUFBQ1AsaUJBQWlCLENBQUM7RUFFNUMsSUFBTVEsWUFBWSxHQUFHLElBQUFuQixPQUFBLENBQUFrQixNQUFNLEVBQUMsSUFBSSxDQUFDO0VBRWpDLElBQU1FLGNBQWMsR0FBRyxJQUFBcEIsT0FBQSxDQUFBa0IsTUFBTSxFQUFDLElBQUksQ0FBQztFQUVuQyxJQUFNRyxpQkFBaUIsR0FBR2hCLFVBQVUsQ0FBQ2lCLG9CQUFvQixDQUFDQyxHQUFHLENBQUNqQixXQUFXLENBQUM7RUFFMUUsSUFBTWtCLFdBQVcsR0FBRyxJQUFBeEIsT0FBQSxDQUFBeUIsV0FBVyxFQUFDLFVBQUNDLGdCQUFnQixFQUFJO0lBRWpETixjQUFjLENBQUNPLE9BQU8sR0FBR0QsZ0JBQWdCO0lBRXpDUCxZQUFZLENBQUNRLE9BQU8sSUFBSWYsb0JBQW9CLENBQUMsRUFBRUssVUFBVSxDQUFDVSxPQUFPLENBQUMsRUFBQztFQUV2RSxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUwsSUFBQTNCLE9BQUEsQ0FBQTRCLFNBQVMsRUFBQyxZQUFJO0lBRVZULFlBQVksQ0FBQ1EsT0FBTyxHQUFHLElBQUk7SUFFM0JOLGlCQUFpQixDQUFDRyxXQUFXLEdBQUdBLFdBQVc7SUFFM0NqQixRQUFRLEVBQUU7SUFFVixPQUFPLFlBQUs7TUFFUlksWUFBWSxDQUFDUSxPQUFPLEdBQUcsS0FBSztJQUVoQyxDQUFDO0VBRUwsQ0FBQyxFQUFDLEVBQUUsQ0FBQztFQUVMLElBQUEzQixPQUFBLENBQUE0QixTQUFTLEVBQUMsWUFBSTtJQUVWLFFBQVFiLGNBQWM7TUFDbEIsS0FBSyxPQUFPO1FBQUU7VUFDVkMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO1VBQzFCOztJQUNIO0VBR1QsQ0FBQyxFQUFDLENBQUNELGNBQWMsQ0FBQyxDQUFDO0VBRW5CLE9BQU9mLE9BQUEsWUFBQTZCLGFBQUE7SUFBS0MsR0FBRyxFQUFJeEIsV0FBVztJQUFBLGFBQWMsZ0JBQWdCO0lBQUEsb0JBQXFCQTtFQUFXLEdBQ3ZGYyxjQUFjLENBQUNPLE9BQU8sQ0FDckI7QUFFVixDQUFDO0FBRURJLGtCQUFBLEdBQWU1QixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9wb3J0YWxjYWNoZS9DYWNoZVBhcnRpdGlvbi50c3g/NTk0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDZWxsRnJhbWUudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrfSBmcm9tICdyZWFjdCdcblxuY29uc3QgQ2FjaGVQYXJ0aXRpb24gPSAoeyBjYWNoZVByb3BzLCBwYXJ0aXRpb25JRCwgY2FsbGJhY2sgfSkgPT4ge1xuXG4gICAgY29uc3QgW3BvcnRhbExpc3RDb3VudGVyLCBzZXRQb3J0YWxMaXN0Q291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuXG4gICAgY29uc3QgW3BhcnRpdGlvblN0YXRlLCBzZXRQYXJ0aXRpb25TdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3QgY291bnRlclJlZiA9IHVzZVJlZihwb3J0YWxMaXN0Q291bnRlcilcblxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgY29uc3QgcG9ydGFsQXJyYXlSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gY2FjaGVQcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUNhbGxiYWNrKChwb3J0YWxSZW5kZXJMaXN0KSA9PiB7XG5cbiAgICAgICAgcG9ydGFsQXJyYXlSZWYuY3VycmVudCA9IHBvcnRhbFJlbmRlckxpc3RcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRQb3J0YWxMaXN0Q291bnRlcigrK2NvdW50ZXJSZWYuY3VycmVudCkgLy8gZm9yY2UgcmVuZGVyXG5cbiAgICB9LFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEuZm9yY2VVcGRhdGUgPSBmb3JjZVVwZGF0ZVxuXG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSkgXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBzd2l0Y2ggKHBhcnRpdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcbiAgICAgICAgICAgICAgICBzZXRQYXJ0aXRpb25TdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sW3BhcnRpdGlvblN0YXRlXSlcblxuICAgIHJldHVybiA8ZGl2IGtleSA9IHtwYXJ0aXRpb25JRH0gZGF0YS10eXBlID0gJ2NhY2hlcGFydGl0aW9uJyBkYXRhLXBhcnRpdGlvbmlkID0ge3BhcnRpdGlvbklEfT5cbiAgICAgICAge3BvcnRhbEFycmF5UmVmLmN1cnJlbnR9XG4gICAgPC9kaXY+XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FjaGVQYXJ0aXRpb24iXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsIkNhY2hlUGFydGl0aW9uIiwiX3JlZiIsImNhY2hlUHJvcHMiLCJwYXJ0aXRpb25JRCIsImNhbGxiYWNrIiwiX3JlZjIiLCJ1c2VTdGF0ZSIsIl9yZWYzIiwicG9ydGFsTGlzdENvdW50ZXIiLCJzZXRQb3J0YWxMaXN0Q291bnRlciIsIl9yZWY0IiwiX3JlZjUiLCJwYXJ0aXRpb25TdGF0ZSIsInNldFBhcnRpdGlvblN0YXRlIiwiY291bnRlclJlZiIsInVzZVJlZiIsImlzTW91bnRlZFJlZiIsInBvcnRhbEFycmF5UmVmIiwicGFydGl0aW9uTWV0YWRhdGEiLCJwYXJ0aXRpb25NZXRhZGF0YU1hcCIsImdldCIsImZvcmNlVXBkYXRlIiwidXNlQ2FsbGJhY2siLCJwb3J0YWxSZW5kZXJMaXN0IiwiY3VycmVudCIsInVzZUVmZmVjdCIsImNyZWF0ZUVsZW1lbnQiLCJrZXkiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/portalcache/CachePartition.tsx\n')},"./src/portalcache/cachehandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// cachehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user functionsCallback callback for details. The cacheMax property allows for control of the\n    maximum device memory consumption of the cache.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden cache,\n    from whence the components are pulled into the relevant CellFrames for display. The user components are\n    stored in React portals, with each portal instantiated in a container div (data-type = \'portalwrapper\').\n    These container divs are part of a standard React component list in the real DOM. The contained portals\n    themselves are not part of the real DOM, but are part of React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle without losing state, and the ability to maintain state for\n    complex components which move beyond the scope of the content of the Cradle.\n\n    There is an important side effect to consider. Instantiated components which are removed from the real DOM\n    into the portal of the virtual DOM have their scroll positions, width, and height set to zero. Therefore if\n    components rely on these values for configuration, they must have a way of storing those values in state\n    (notably the Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing scrollerPropertiesRef and cellFrameDataRef\n        - if your component does not scroll, there should be no issues.\n\n    Note that in the following, scrollerID is provided as a paramter to some functions for debug purposes, but not used.\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\nvar CachePartition_1 = __importDefault(__webpack_require__(/*! ./CachePartition */ "./src/portalcache/CachePartition.tsx"));\n// the cache itself is maintained in the root infinitegridscroller component\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, listsizeRef, CACHE_PARTITION_SIZE) {\n    var _this = this;\n    _classCallCheck(this, CacheHandler);\n    this.globalItemID = 0;\n    this.globalPartitionID = 0;\n    this.cacheProps = {\n      // item data\n      metadataMap: new Map(),\n      indexToItemIDMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      // partition data\n      partitionMetadataMap: new Map(),\n      // for rendering partitions...\n      partitionMap: new Map(),\n      partitionRenderList: null,\n      partitionRepoForceUpdate: null,\n      partitionModifiedSet: new Set(),\n      partitionPtr: null,\n      scrollerID: null // for debug\n    };\n    // updateListsize(listsize) causes an InfiniteGridScroller useState update\n    // of the listsize throughout\n    // updateListsize // function passed from InfiniteGridScroller\n    // ===========================[ CACHE PARTITION MANAGEMENT ]===============================\n    // partitions are added but not removed\n    this.renderPartitionRepo = function () {\n      _this.cacheProps.partitionRenderList = Array.from(_this.cacheProps.partitionMap.values());\n      _this.cacheProps.partitionRepoForceUpdate(_this.cacheProps.partitionRenderList);\n    };\n    this.addPartition = function () {\n      var partitionID = _this.globalPartitionID++;\n      _this.cacheProps.partitionMetadataMap.set(partitionID, {\n        portalMap: new Map(),\n        mapcount: 0,\n        portalRenderList: null,\n        modified: false,\n        forceUpdate: null,\n        partitionID: partitionID\n      });\n      var resolvefunc = {\n        current: null\n      };\n      var promise = new Promise(function (resolve) {\n        resolvefunc.current = resolve;\n      });\n      var callback = function callback() {\n        resolvefunc.current(partitionID);\n      };\n      _this.cacheProps.partitionMap.set(partitionID, react_1["default"].createElement(CachePartition_1["default"], {\n        key: partitionID,\n        cacheProps: _this.cacheProps,\n        partitionID: partitionID,\n        callback: callback\n      }));\n      _this.renderPartitionRepo();\n      return promise;\n    };\n    this.addPartitionPortal = function (partitionID, itemID, portal) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap.set(itemID, portal);\n      _this.cacheProps.partitionModifiedSet.add(partitionID);\n    };\n    this.removePartitionPortal = function (partitionID, itemID) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap["delete"](itemID);\n      partitionMetadata.mapcount -= 1;\n      _this.cacheProps.partitionModifiedSet.add(partitionID);\n    };\n    this.renderPartition = function (partitionID) {\n      var partitionMetadata = _this.cacheProps.partitionMetadataMap.get(partitionID);\n      if (!partitionMetadata) return;\n      partitionMetadata.portalRenderList = Array.from(partitionMetadata.portalMap.values());\n      // if forceUpdate has not yet been assigned, it is in the works from first call of partition\n      partitionMetadata.forceUpdate && partitionMetadata.forceUpdate(partitionMetadata.portalRenderList);\n    };\n    // set state of the CachePartition component of the scroller to trigger render\n    this.renderPortalLists = function () {\n      var partitionModifiedSet = _this.cacheProps.partitionModifiedSet;\n      if (partitionModifiedSet.size) {\n        partitionModifiedSet.forEach(function (partitionID) {\n          _this.renderPartition(partitionID);\n        });\n        _this.cacheProps.partitionModifiedSet.clear();\n      }\n    };\n    this.clearCache = function () {\n      // clear base data\n      _this.cacheProps.metadataMap.clear();\n      _this.cacheProps.indexToItemIDMap.clear();\n      _this.cacheProps.requestedSet.clear();\n      // clear cache partitions\n      _this.cacheProps.partitionMetadataMap.clear();\n      _this.cacheProps.partitionMap.clear();\n      _this.cacheProps.partitionRenderList = [];\n      _this.cacheProps.partitionModifiedSet.clear();\n      _this.cacheProps.partitionPtr = null;\n      _this.cacheProps.partitionRepoForceUpdate(null);\n    };\n    //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n    // called from Cradle.nullItemSetMaxListsize, and serviceHandler.setListsize\n    this.changeCacheListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      // this.updateListsize(newlistsize)\n      // match cache to newlistsize\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n    // ----------------------[ cache size limit enforceent ]------------------\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      var modelLength = cradleIndexList.length;\n      // determine need for paring\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap,\n        requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexMap.size + requestedSet.size <= max) return false;\n      // sort the map keys\n      var mapkeyslist = Array.from(portalIndexMap.keys()),\n        requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      });\n      // get number to pare\n      var mapLength = mapkeys.length,\n        parecount = mapLength - max;\n      // distribute paring proportionally at front and back\n      var headindex = cradleIndexList[0],\n        tailindex = cradleIndexList[modelLength - 1],\n        headpos = mapkeys.indexOf(headindex),\n        tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos,\n        tailroom = mapLength - (tailpos + 1),\n        pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount),\n        tailparecount = parecount - headparecount;\n      // collect indexes to pare\n      var headlist = mapkeys.slice(0, headparecount),\n        taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n      _this.deletePortal(delList, deleteListCallback);\n      return true;\n    };\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var _this$cacheProps = _this.cacheProps,\n        indexToItemIDMap = _this$cacheProps.indexToItemIDMap,\n        requestedSet = _this$cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n      if (indexToItemIDMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n    this.cacheProps.scrollerID = scrollerID; // for debug\n    // this.updateListsize = updateListsize // passed from InfiniteGridScroller.updateListsize(listsize)\n    this.listsizeRef = listsizeRef; // current list size\n    this.CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE;\n  }\n  _createClass(CacheHandler, [{\n    key: "findPartitionWithRoom",\n    value: function findPartitionWithRoom() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var CACHE_PARTITION_SIZE, partitionMetadataMap, partitionPtr, partitionMetadata, _iterator, _step, _step$value, partitionID, _partitionMetadata;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              CACHE_PARTITION_SIZE = this.CACHE_PARTITION_SIZE;\n              partitionMetadataMap = this.cacheProps.partitionMetadataMap;\n              partitionPtr = this.cacheProps.partitionPtr;\n              if (!(partitionPtr !== null)) {\n                _context.next = 8;\n                break;\n              }\n              partitionMetadata = partitionMetadataMap.get(partitionPtr);\n              if (!(partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                _context.next = 8;\n                break;\n              }\n              partitionMetadata.mapcount += 1;\n              return _context.abrupt("return", partitionPtr);\n            case 8:\n              partitionPtr = null;\n              _iterator = _createForOfIteratorHelper(partitionMetadataMap);\n              _context.prev = 10;\n              _iterator.s();\n            case 12:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 20;\n                break;\n              }\n              _step$value = _slicedToArray(_step.value, 2), partitionID = _step$value[0], _partitionMetadata = _step$value[1];\n              if (!(_partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                _context.next = 18;\n                break;\n              }\n              _partitionMetadata.mapcount += 1;\n              partitionPtr = partitionID;\n              return _context.abrupt("break", 20);\n            case 18:\n              _context.next = 12;\n              break;\n            case 20:\n              _context.next = 25;\n              break;\n            case 22:\n              _context.prev = 22;\n              _context.t0 = _context["catch"](10);\n              _iterator.e(_context.t0);\n            case 25:\n              _context.prev = 25;\n              _iterator.f();\n              return _context.finish(25);\n            case 28:\n              if (!(partitionPtr === null)) {\n                _context.next = 34;\n                break;\n              }\n              _context.next = 31;\n              return this.addPartition();\n            case 31:\n              partitionPtr = _context.sent;\n              partitionMetadata = partitionMetadataMap.get(partitionPtr);\n              partitionMetadata.mapcount += 1;\n            case 34:\n              this.cacheProps.partitionPtr = partitionPtr;\n              return _context.abrupt("return", partitionPtr);\n            case 36:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this, [[10, 22, 25, 28]]);\n      }));\n    }\n    // --------------------------------[ preload ]--------------------------------\n  }, {\n    key: "preload",\n    value: function preload(finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n      var cradleParameters = this.cradleParameters;\n      var scrollerPropertiesRef = cradleParameters.scrollerPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n        stateHandler = _cradleParameters$han.stateHandler,\n        serviceHandler = _cradleParameters$han.serviceHandler,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n        cacheMax = cradleInheritedProperties.cacheMax,\n        listsize = cradleInternalProperties.listsize;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      };\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n          preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n          itemExceptionCallback = _serviceHandler$callb.itemExceptionCallback;\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n          if (!indexToItemIDMap.has(index)) {\n            var promise = this.preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n          if (breakloop.current) break;\n        }\n      }\n      Promise.allSettled(promises).then(function () {\n        _this2.renderPortalLists();\n        finalCallback();\n      });\n    }\n    // =========================[ SNAPSHOTS ]=========================\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map(),\n        indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var _iterator2 = _createForOfIteratorHelper(cradleIndexList),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var index = _step2.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n      var _iterator3 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            key = _step3$value[0],\n            value = _step3$value[1];\n          var index = value.index,\n            component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return cachelist;\n    }\n    // ==========================[ SERVICE SUPPORT ]=========================\n    // --------------------------[ move indexes ]-------------------------------\n    // move is coerced by servicehandler to be within current list bounds\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(tolowindex, fromlowindex, fromhighindex) {\n      var _this$cacheProps2 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n        metadataMap = _this$cacheProps2.metadataMap;\n      // ----------- define parameters ---------------\n      var moveblocksize = fromhighindex - fromlowindex + 1,\n        moveincrement = tolowindex - fromlowindex,\n        tohighindex = tolowindex + (moveblocksize - 1);\n      var movedirection = moveincrement > 0 ?\n      // move block up in list\n      \'up\' :\n      // shift down, make room for shiftingindex above\n      \'down\'; // shift up, make room for shiftingindex below\n      // ------------ find bounds of from and to blocks in cache -------------\n      var orderedindexlist = Array.from(indexToItemIDMap.keys()).sort(function (a, b) {\n        return a - b;\n      });\n      var reverseorderedindexlist = orderedindexlist.slice().reverse();\n      var tolowindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= tolowindex;\n        }),\n        fromlowindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromlowindex;\n        });\n      var tohighindexptr = reverseorderedindexlist.findIndex(function (value) {\n          return value <= tohighindex;\n        }),\n        fromhighindexptr = reverseorderedindexlist.findIndex(function (value) {\n          return value <= fromhighindex;\n        });\n      // get required inverse\n      {\n        var cachelistcount = orderedindexlist.length;\n        if (tohighindexptr != -1) tohighindexptr = cachelistcount - 1 - tohighindexptr;\n        if (fromhighindexptr != -1) fromhighindexptr = cachelistcount - 1 - fromhighindexptr;\n      }\n      // ---------------- capture index data to move ----------------\n      var listtoprocessformove;\n      if (fromlowindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        listtoprocessformove = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        listtoprocessformove = orderedindexlist.slice(fromlowindexptr);\n      } else {\n        // scope is entirely in view\n        listtoprocessformove = orderedindexlist.slice(fromlowindexptr, fromhighindexptr + 1);\n      }\n      var processtomoveMap = new Map();\n      var capturemoveindexFn = function capturemoveindexFn(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n      listtoprocessformove.forEach(capturemoveindexFn);\n      // ------------- get list of indexes to shift out of the way ---------------\n      var listtoprocessfordisplace;\n      if (movedirection == \'down\') {\n        // block is moving down, shift is up; toindex < fromindex\n        if (tolowindexptr == -1 && fromlowindexptr == -1) {\n          listtoprocessfordisplace = [];\n        } else if (fromlowindexptr == -1) {\n          listtoprocessfordisplace = orderedindexlist.slice(tolowindexptr);\n        } else {\n          listtoprocessfordisplace = orderedindexlist.slice(tolowindexptr, fromlowindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          listtoprocessfordisplace = [];\n        } else if (tohighindexptr == -1) {\n          listtoprocessfordisplace = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          listtoprocessfordisplace = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n      if (movedirection == \'down\') listtoprocessfordisplace.reverse();\n      // -------------- move indexes out of the way --------------\n      var processeddisplaceList = [];\n      var processsdisplaceindexFn = function processsdisplaceindexFn(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = movedirection == \'up\' ? index - moveblocksize : index + moveblocksize;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processeddisplaceList.push(newIndex);\n      };\n      listtoprocessfordisplace.forEach(processsdisplaceindexFn);\n      // ------------ replace shifted index space with moved indexes ----------\n      var processedmoveList = [];\n      var processmoveindexFn = function processmoveindexFn(itemID, index) {\n        var newIndex = index + moveincrement; // swap\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n      processtomoveMap.forEach(processmoveindexFn);\n      // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n      var processedIndexes = [].concat(processeddisplaceList, processedmoveList).sort(function (a, b) {\n        return a - b;\n      });\n      return processedIndexes;\n    }\n    // ----------------------------[ insert/remove indexes ]------------------------------\n    // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      // clarity\n      var isInserting = increment == 1;\n      var isRemoving = increment == -1;\n      var emptyreturn = [null, null, [], [], [], []]; // no action return value\n      // cache resources\n      var _this$cacheProps3 = this.cacheProps,\n        indexToItemIDMap = _this$cacheProps3.indexToItemIDMap,\n        metadataMap = _this$cacheProps3.metadataMap;\n      var orderedCacheIndexList = Array.from(indexToItemIDMap.keys()).sort(function (a, b) {\n        return a - b;\n      }); // ascending order\n      // ---------- define contiguous range parameters; add sentinels ---------------\n      // high range is the highest index number of the insert/remove range\n      var highrangeindex = highrange;\n      var lowrangeindex = index; // semantics - name symmetry\n      if (isRemoving) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) {\n          highrangeindex = listsize - 1;\n          if (highrangeindex < lowrangeindex) return emptyreturn;\n        }\n      } else {\n        // isInserting\n        // addition can at most start at the next lowrangeindex above the current list; aka append\n        if (lowrangeindex > listsize) {\n          var diff = lowrangeindex - listsize;\n          lowrangeindex -= diff;\n          highrangeindex -= diff;\n          // return emptyreturn\n        }\n      }\n      // rangecount is the absolute number in the insert/remove contiguous range\n      var rangecount = highrangeindex - lowrangeindex + 1;\n      // range increment adds sign to rangecount to indicate add/remove\n      var rangeincrement = rangecount * increment;\n      var startChangeIndex = increment == 1 ? lowrangeindex : highrangeindex + (rangeincrement + 1);\n      var toShiftStartIndex; // start of indexes to shift up (insert) or down (remove)\n      if (isInserting) {\n        toShiftStartIndex = lowrangeindex;\n      } else {\n        // isRemoving\n        toShiftStartIndex = highrangeindex + 1;\n      }\n      // ---------- define range boundaries within ordered cache index list ------------\n      // obtain starptr for indexes to shift\n      var toShiftStartCachePtr = orderedCacheIndexList.findIndex(function (value) {\n        return value >= toShiftStartIndex;\n      });\n      // obtain lowCacheRangePtr...\n      var lowCacheRangePtr = orderedCacheIndexList.findIndex(function (value) {\n        return value >= lowrangeindex && value <= highrangeindex;\n      });\n      // obtain highCacheRangePtr...\n      var reverseCacheIndexList = Array.from(orderedCacheIndexList).reverse();\n      var highCacheRangePtr = reverseCacheIndexList.findIndex(function (value) {\n        return value <= highrangeindex && value >= lowrangeindex;\n      });\n      // take inverse of highCacheRangePtr for non-reverse sort\n      if (highCacheRangePtr != -1) {\n        highCacheRangePtr = orderedCacheIndexList.length - 1 - highCacheRangePtr;\n        if (highCacheRangePtr < lowCacheRangePtr) highCacheRangePtr = -1;\n      }\n      // ----------- isolate index range list and shift list ------------\n      // cache inputs\n      var cacheRangeIndexesList,\n        // for either insert or remove\n        cacheToShiftIndexesList; // for either insert or remove\n      // get inputs\n      if (lowCacheRangePtr == -1) {\n        // core scope is out of view\n        cacheRangeIndexesList = [];\n        cacheToShiftIndexesList = [];\n      } else if (highCacheRangePtr == -1) {\n        // core scope is partially in view; lowCacheRangePtr is available\n        // all items above lowCacheRangePtr must have indexes reset\n        cacheRangeIndexesList = orderedCacheIndexList.slice(lowCacheRangePtr);\n        if (isInserting) {\n          cacheToShiftIndexesList = cacheRangeIndexesList.slice();\n        } else {\n          if (toShiftStartCachePtr == -1) {\n            cacheToShiftIndexesList = [];\n          } else {\n            cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n          }\n        }\n      } else {\n        // range fully in view\n        cacheRangeIndexesList = orderedCacheIndexList.slice(lowCacheRangePtr, highCacheRangePtr + 1);\n        if (isInserting) {\n          cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n        } else {\n          if (toShiftStartCachePtr == -1) {\n            cacheToShiftIndexesList = [];\n          } else {\n            cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n          }\n        }\n      }\n      // ----------- list cache indexes and items to replace or remove -----------\n      // cache outputs\n      // for insert, the range being inserted; for remove, any tail cradle items abandoned\n      var cacheIndexesToReplaceList = [],\n        // for insert, the range being inserted\n        cacheIndexesToRemoveList = [],\n        // for remove, the range being removed\n        cacheItemsToRemoveList = []; // for remove, derived from the previous\n      if (isInserting) {\n        cacheIndexesToReplaceList = cacheRangeIndexesList;\n      } else {\n        // isRemoving\n        cacheIndexesToRemoveList = cacheRangeIndexesList;\n        // get cacheItemsToRemoveList\n        var _iterator4 = _createForOfIteratorHelper(cacheIndexesToRemoveList),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index = _step4.value;\n            cacheItemsToRemoveList.push(indexToItemIDMap.get(_index));\n            indexToItemIDMap["delete"](_index);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      // ----------- conduct cache operations; capture list of shifted indexes ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n      if (isInserting) cacheToShiftIndexesList.reverse();\n      var cacheIndexesShiftedList = []; // track shifted indexes\n      var cacheIndexesTransferredSet = new Set(); // obtain list of orphaned indexes\n      // function modify index-to-itemid map, and metadata map, for index shifts\n      var processIndexFn = function processIndexFn(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        if (isRemoving) {\n          cacheIndexesTransferredSet.add(index);\n          cacheIndexesTransferredSet["delete"](newIndex);\n        }\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        cacheIndexesShiftedList.push(newIndex);\n      };\n      // walk through items to shift\n      cacheToShiftIndexesList.forEach(processIndexFn);\n      // delete remaining indexes and items now duplicates; track portal data to remove after cradle updated\n      var portalPartitionItemsForDeleteList = []; // hold portals for deletion until after after cradle synch\n      var cacheIndexesRemovedList = [];\n      if (isInserting) {\n        var _iterator5 = _createForOfIteratorHelper(cacheIndexesToReplaceList),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index2 = _step5.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else {\n        // isRemoving\n        var _iterator6 = _createForOfIteratorHelper(cacheItemsToRemoveList),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var itemID = _step6.value;\n            var _metadataMap$get = metadataMap.get(itemID),\n              partitionID = _metadataMap$get.partitionID;\n            portalPartitionItemsForDeleteList.push({\n              itemID: itemID,\n              partitionID: partitionID\n            });\n            metadataMap["delete"](itemID);\n          }\n          // abandoned indexes from remove process\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        var orphanedIndexesTransferredList = Array.from(cacheIndexesTransferredSet);\n        for (var _i2 = 0, _orphanedIndexesTrans = orphanedIndexesTransferredList; _i2 < _orphanedIndexesTrans.length; _i2++) {\n          var _index3 = _orphanedIndexesTrans[_i2];\n          indexToItemIDMap["delete"](_index3);\n        }\n        cacheIndexesRemovedList = cacheIndexesToRemoveList.concat(orphanedIndexesTransferredList);\n      }\n      if (isInserting) cacheIndexesShiftedList.reverse(); // return to ascending order\n      // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n      return [startChangeIndex, rangeincrement, cacheIndexesShiftedList, cacheIndexesRemovedList, cacheIndexesToReplaceList, portalPartitionItemsForDeleteList];\n    }\n    // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n  }, {\n    key: "registerPendingPortal",\n    value: function registerPendingPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: "unregisterPendingPortal",\n    value: function unregisterPendingPortal(index) {\n      this.cacheProps.requestedSet["delete"](index);\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return this.globalItemID++;\n    }\n    // get new or existing itemID for contentfunctions.createCellFrame\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    }\n    // create new portal\n  }, {\n    key: "createPortal",\n    value: function createPortal(component, index, itemID, scrollerProperties) {\n      var isPreload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this$cradleParameter, layout, cellHeight, cellWidth, orientation, portalNode, partitionID, portal, portalMetadata;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.unregisterPendingPortal(index);\n              _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current, layout = _this$cradleParameter.layout, cellHeight = _this$cradleParameter.cellHeight, cellWidth = _this$cradleParameter.cellWidth, orientation = _this$cradleParameter.orientation;\n              portalNode = createPortalNode(index, itemID);\n              _context2.next = 5;\n              return this.findPartitionWithRoom();\n            case 5:\n              partitionID = _context2.sent;\n              portal = react_1["default"].createElement("div", {\n                "data-type": \'portalwrapper\',\n                key: itemID,\n                "data-itemid": itemID,\n                "data-index": index\n              }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n                key: itemID,\n                node: portalNode\n              }, " ", component, " "));\n              this.addPartitionPortal(partitionID, itemID, portal);\n              portalMetadata = {\n                portalNode: portalNode,\n                index: index,\n                itemID: itemID,\n                scrollerProperties: scrollerProperties,\n                component: component,\n                partitionID: partitionID\n              };\n              this.cacheProps.metadataMap.set(itemID, portalMetadata);\n              this.cacheProps.indexToItemIDMap.set(index, itemID);\n              if (!isPreload) this.renderPortalLists();\n              return _context2.abrupt("return", portalMetadata);\n            case 13:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    // used for preloading new item\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              itemID = this.getNewItemID();\n              _context3.prev = 1;\n              _context3.next = 4;\n              return getItem(index, itemID);\n            case 4:\n              usercontent = _context3.sent;\n              if (usercontent === null) returnvalue = usercontent;\n              _context3.next = 12;\n              break;\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3["catch"](1);\n              returnvalue = usercontent = undefined;\n              error = _context3.t0;\n            case 12:\n              if (usercontent !== null && usercontent !== undefined) {\n                if (!react_1["default"].isValidElement(usercontent)) {\n                  returnvalue = usercontent;\n                  usercontent = undefined;\n                  error = new Error(\'invalid React element\');\n                }\n              }\n              if (!(usercontent !== null && usercontent !== undefined)) {\n                _context3.next = 20;\n                break;\n              }\n              scrollerProperties = {\n                scrollerPropertiesRef: scrollerPropertiesRef\n              };\n              if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                content = react_1["default"].cloneElement(usercontent, {\n                  scrollerProperties: scrollerProperties\n                });\n              } else {\n                content = usercontent;\n              }\n              // const portalData = \n              _context3.next = 18;\n              return this.createPortal(content, index, itemID, scrollerProperties, true);\n            case 18:\n              _context3.next = 21;\n              break;\n            case 20:\n              if (usercontent === undefined) {\n                itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', error);\n              } else {\n                // usercontent === null; last item in list\n                itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                maxListsizeInterrupt(index);\n              }\n            case 21:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 8]]);\n      }));\n    }\n    // delete a portal list item\n    // accepts an array of indexes\n  }, {\n    key: "deletePortal",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps4 = this.cacheProps,\n        metadataMap = _this$cacheProps4.metadataMap,\n        indexToItemIDMap = _this$cacheProps4.indexToItemIDMap;\n      var removePartitionPortal = this.removePartitionPortal;\n      var deleteList = [];\n      var _iterator7 = _createForOfIteratorHelper(indexArray),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _index4 = _step7.value;\n          var itemID = indexToItemIDMap.get(_index4);\n          if (itemID === undefined) continue; // async mismatch\n          deleteList.push({\n            index: _index4,\n            itemID: itemID\n          });\n          var _metadataMap$get2 = metadataMap.get(itemID),\n            partitionID = _metadataMap$get2.partitionID;\n          removePartitionPortal(partitionID, itemID);\n          metadataMap["delete"](itemID);\n          indexToItemIDMap["delete"](_index4);\n        }\n        // this.renderPortalLists()\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      deleteListCallback && deleteListCallback(deleteList);\n    }\n    // query existence of a portal list item\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortalMetadata",\n    value: function getPortalMetadata(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n  return CacheHandler;\n}();\nexports["default"] = CacheHandler;\n// ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n// see also some styles set in CellFrame\nvar createPortalNode = function createPortalNode(index, itemID) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcG9ydGFsY2FjaGUvY2FjaGVoYW5kbGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQSxTQUFBQSxRQUFBQyxHQUFBLHNDQUFBRCxPQUFBLHdCQUFBRSxNQUFBLHVCQUFBQSxNQUFBLENBQUFDLFFBQUEsYUFBQUYsR0FBQSxrQkFBQUEsR0FBQSxnQkFBQUEsR0FBQSxXQUFBQSxHQUFBLHlCQUFBQyxNQUFBLElBQUFELEdBQUEsQ0FBQUcsV0FBQSxLQUFBRixNQUFBLElBQUFELEdBQUEsS0FBQUMsTUFBQSxDQUFBRyxTQUFBLHFCQUFBSixHQUFBLEtBQUFELE9BQUEsQ0FBQUMsR0FBQTtBQUFBLFNBQUFLLG9CQUFBLGtCQURBLHFKQUFBQSxtQkFBQSxZQUFBQSxvQkFBQSxXQUFBQyxPQUFBLFNBQUFBLE9BQUEsT0FBQUMsRUFBQSxHQUFBQyxNQUFBLENBQUFKLFNBQUEsRUFBQUssTUFBQSxHQUFBRixFQUFBLENBQUFHLGNBQUEsRUFBQUMsY0FBQSxHQUFBSCxNQUFBLENBQUFHLGNBQUEsY0FBQVgsR0FBQSxFQUFBWSxHQUFBLEVBQUFDLElBQUEsSUFBQWIsR0FBQSxDQUFBWSxHQUFBLElBQUFDLElBQUEsQ0FBQUMsS0FBQSxLQUFBQyxPQUFBLHdCQUFBZCxNQUFBLEdBQUFBLE1BQUEsT0FBQWUsY0FBQSxHQUFBRCxPQUFBLENBQUFiLFFBQUEsa0JBQUFlLG1CQUFBLEdBQUFGLE9BQUEsQ0FBQUcsYUFBQSx1QkFBQUMsaUJBQUEsR0FBQUosT0FBQSxDQUFBSyxXQUFBLDhCQUFBQyxPQUFBckIsR0FBQSxFQUFBWSxHQUFBLEVBQUFFLEtBQUEsV0FBQU4sTUFBQSxDQUFBRyxjQUFBLENBQUFYLEdBQUEsRUFBQVksR0FBQSxJQUFBRSxLQUFBLEVBQUFBLEtBQUEsRUFBQVEsVUFBQSxNQUFBQyxZQUFBLE1BQUFDLFFBQUEsU0FBQXhCLEdBQUEsQ0FBQVksR0FBQSxXQUFBUyxNQUFBLG1CQUFBSSxHQUFBLElBQUFKLE1BQUEsWUFBQUEsT0FBQXJCLEdBQUEsRUFBQVksR0FBQSxFQUFBRSxLQUFBLFdBQUFkLEdBQUEsQ0FBQVksR0FBQSxJQUFBRSxLQUFBLGdCQUFBWSxLQUFBQyxPQUFBLEVBQUFDLE9BQUEsRUFBQUMsSUFBQSxFQUFBQyxXQUFBLFFBQUFDLGNBQUEsR0FBQUgsT0FBQSxJQUFBQSxPQUFBLENBQUF4QixTQUFBLFlBQUE0QixTQUFBLEdBQUFKLE9BQUEsR0FBQUksU0FBQSxFQUFBQyxTQUFBLEdBQUF6QixNQUFBLENBQUEwQixNQUFBLENBQUFILGNBQUEsQ0FBQTNCLFNBQUEsR0FBQStCLE9BQUEsT0FBQUMsT0FBQSxDQUFBTixXQUFBLGdCQUFBbkIsY0FBQSxDQUFBc0IsU0FBQSxlQUFBbkIsS0FBQSxFQUFBdUIsZ0JBQUEsQ0FBQVYsT0FBQSxFQUFBRSxJQUFBLEVBQUFNLE9BQUEsTUFBQUYsU0FBQSxhQUFBSyxTQUFBQyxFQUFBLEVBQUF2QyxHQUFBLEVBQUF3QyxHQUFBLG1CQUFBQyxJQUFBLFlBQUFELEdBQUEsRUFBQUQsRUFBQSxDQUFBRyxJQUFBLENBQUExQyxHQUFBLEVBQUF3QyxHQUFBLGNBQUFmLEdBQUEsYUFBQWdCLElBQUEsV0FBQUQsR0FBQSxFQUFBZixHQUFBLFFBQUFuQixPQUFBLENBQUFvQixJQUFBLEdBQUFBLElBQUEsTUFBQWlCLGdCQUFBLGdCQUFBWCxVQUFBLGNBQUFZLGtCQUFBLGNBQUFDLDJCQUFBLFNBQUFDLGlCQUFBLE9BQUF6QixNQUFBLENBQUF5QixpQkFBQSxFQUFBOUIsY0FBQSxxQ0FBQStCLFFBQUEsR0FBQXZDLE1BQUEsQ0FBQXdDLGNBQUEsRUFBQUMsdUJBQUEsR0FBQUYsUUFBQSxJQUFBQSxRQUFBLENBQUFBLFFBQUEsQ0FBQUcsTUFBQSxRQUFBRCx1QkFBQSxJQUFBQSx1QkFBQSxLQUFBMUMsRUFBQSxJQUFBRSxNQUFBLENBQUFpQyxJQUFBLENBQUFPLHVCQUFBLEVBQUFqQyxjQUFBLE1BQUE4QixpQkFBQSxHQUFBRyx1QkFBQSxPQUFBRSxFQUFBLEdBQUFOLDBCQUFBLENBQUF6QyxTQUFBLEdBQUE0QixTQUFBLENBQUE1QixTQUFBLEdBQUFJLE1BQUEsQ0FBQTBCLE1BQUEsQ0FBQVksaUJBQUEsWUFBQU0sc0JBQUFoRCxTQUFBLGdDQUFBaUQsT0FBQSxXQUFBQyxNQUFBLElBQUFqQyxNQUFBLENBQUFqQixTQUFBLEVBQUFrRCxNQUFBLFlBQUFkLEdBQUEsZ0JBQUFlLE9BQUEsQ0FBQUQsTUFBQSxFQUFBZCxHQUFBLHNCQUFBZ0IsY0FBQXZCLFNBQUEsRUFBQXdCLFdBQUEsYUFBQUMsT0FBQUosTUFBQSxFQUFBZCxHQUFBLEVBQUFtQixPQUFBLEVBQUFDLE1BQUEsUUFBQUMsTUFBQSxHQUFBdkIsUUFBQSxDQUFBTCxTQUFBLENBQUFxQixNQUFBLEdBQUFyQixTQUFBLEVBQUFPLEdBQUEsbUJBQUFxQixNQUFBLENBQUFwQixJQUFBLFFBQUFxQixNQUFBLEdBQUFELE1BQUEsQ0FBQXJCLEdBQUEsRUFBQTFCLEtBQUEsR0FBQWdELE1BQUEsQ0FBQWhELEtBQUEsU0FBQUEsS0FBQSxnQkFBQWYsT0FBQSxDQUFBZSxLQUFBLEtBQUFMLE1BQUEsQ0FBQWlDLElBQUEsQ0FBQTVCLEtBQUEsZUFBQTJDLFdBQUEsQ0FBQUUsT0FBQSxDQUFBN0MsS0FBQSxDQUFBaUQsT0FBQSxFQUFBQyxJQUFBLFdBQUFsRCxLQUFBLElBQUE0QyxNQUFBLFNBQUE1QyxLQUFBLEVBQUE2QyxPQUFBLEVBQUFDLE1BQUEsZ0JBQUFuQyxHQUFBLElBQUFpQyxNQUFBLFVBQUFqQyxHQUFBLEVBQUFrQyxPQUFBLEVBQUFDLE1BQUEsUUFBQUgsV0FBQSxDQUFBRSxPQUFBLENBQUE3QyxLQUFBLEVBQUFrRCxJQUFBLFdBQUFDLFNBQUEsSUFBQUgsTUFBQSxDQUFBaEQsS0FBQSxHQUFBbUQsU0FBQSxFQUFBTixPQUFBLENBQUFHLE1BQUEsZ0JBQUFJLEtBQUEsV0FBQVIsTUFBQSxVQUFBUSxLQUFBLEVBQUFQLE9BQUEsRUFBQUMsTUFBQSxTQUFBQSxNQUFBLENBQUFDLE1BQUEsQ0FBQXJCLEdBQUEsU0FBQTJCLGVBQUEsRUFBQXhELGNBQUEsb0JBQUFHLEtBQUEsV0FBQUEsTUFBQXdDLE1BQUEsRUFBQWQsR0FBQSxhQUFBNEIsMkJBQUEsZUFBQVgsV0FBQSxXQUFBRSxPQUFBLEVBQUFDLE1BQUEsSUFBQUYsTUFBQSxDQUFBSixNQUFBLEVBQUFkLEdBQUEsRUFBQW1CLE9BQUEsRUFBQUMsTUFBQSxnQkFBQU8sZUFBQSxHQUFBQSxlQUFBLEdBQUFBLGVBQUEsQ0FBQUgsSUFBQSxDQUFBSSwwQkFBQSxFQUFBQSwwQkFBQSxJQUFBQSwwQkFBQSxxQkFBQS9CLGlCQUFBVixPQUFBLEVBQUFFLElBQUEsRUFBQU0sT0FBQSxRQUFBa0MsS0FBQSxzQ0FBQWYsTUFBQSxFQUFBZCxHQUFBLHdCQUFBNkIsS0FBQSxZQUFBQyxLQUFBLHNEQUFBRCxLQUFBLG9CQUFBZixNQUFBLFFBQUFkLEdBQUEsU0FBQStCLFVBQUEsV0FBQXBDLE9BQUEsQ0FBQW1CLE1BQUEsR0FBQUEsTUFBQSxFQUFBbkIsT0FBQSxDQUFBSyxHQUFBLEdBQUFBLEdBQUEsVUFBQWdDLFFBQUEsR0FBQXJDLE9BQUEsQ0FBQXFDLFFBQUEsTUFBQUEsUUFBQSxRQUFBQyxjQUFBLEdBQUFDLG1CQUFBLENBQUFGLFFBQUEsRUFBQXJDLE9BQUEsT0FBQXNDLGNBQUEsUUFBQUEsY0FBQSxLQUFBOUIsZ0JBQUEsbUJBQUE4QixjQUFBLHFCQUFBdEMsT0FBQSxDQUFBbUIsTUFBQSxFQUFBbkIsT0FBQSxDQUFBd0MsSUFBQSxHQUFBeEMsT0FBQSxDQUFBeUMsS0FBQSxHQUFBekMsT0FBQSxDQUFBSyxHQUFBLHNCQUFBTCxPQUFBLENBQUFtQixNQUFBLDZCQUFBZSxLQUFBLFFBQUFBLEtBQUEsZ0JBQUFsQyxPQUFBLENBQUFLLEdBQUEsRUFBQUwsT0FBQSxDQUFBMEMsaUJBQUEsQ0FBQTFDLE9BQUEsQ0FBQUssR0FBQSx1QkFBQUwsT0FBQSxDQUFBbUIsTUFBQSxJQUFBbkIsT0FBQSxDQUFBMkMsTUFBQSxXQUFBM0MsT0FBQSxDQUFBSyxHQUFBLEdBQUE2QixLQUFBLG9CQUFBUixNQUFBLEdBQUF2QixRQUFBLENBQUFYLE9BQUEsRUFBQUUsSUFBQSxFQUFBTSxPQUFBLG9CQUFBMEIsTUFBQSxDQUFBcEIsSUFBQSxRQUFBNEIsS0FBQSxHQUFBbEMsT0FBQSxDQUFBNEMsSUFBQSxtQ0FBQWxCLE1BQUEsQ0FBQXJCLEdBQUEsS0FBQUcsZ0JBQUEscUJBQUE3QixLQUFBLEVBQUErQyxNQUFBLENBQUFyQixHQUFBLEVBQUF1QyxJQUFBLEVBQUE1QyxPQUFBLENBQUE0QyxJQUFBLGtCQUFBbEIsTUFBQSxDQUFBcEIsSUFBQSxLQUFBNEIsS0FBQSxnQkFBQWxDLE9BQUEsQ0FBQW1CLE1BQUEsWUFBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBcUIsTUFBQSxDQUFBckIsR0FBQSxtQkFBQWtDLG9CQUFBRixRQUFBLEVBQUFyQyxPQUFBLFFBQUE2QyxVQUFBLEdBQUE3QyxPQUFBLENBQUFtQixNQUFBLEVBQUFBLE1BQUEsR0FBQWtCLFFBQUEsQ0FBQXRFLFFBQUEsQ0FBQThFLFVBQUEsT0FBQUMsU0FBQSxLQUFBM0IsTUFBQSxTQUFBbkIsT0FBQSxDQUFBcUMsUUFBQSxxQkFBQVEsVUFBQSxJQUFBUixRQUFBLENBQUF0RSxRQUFBLGVBQUFpQyxPQUFBLENBQUFtQixNQUFBLGFBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQXlDLFNBQUEsRUFBQVAsbUJBQUEsQ0FBQUYsUUFBQSxFQUFBckMsT0FBQSxlQUFBQSxPQUFBLENBQUFtQixNQUFBLGtCQUFBMEIsVUFBQSxLQUFBN0MsT0FBQSxDQUFBbUIsTUFBQSxZQUFBbkIsT0FBQSxDQUFBSyxHQUFBLE9BQUEwQyxTQUFBLHVDQUFBRixVQUFBLGlCQUFBckMsZ0JBQUEsTUFBQWtCLE1BQUEsR0FBQXZCLFFBQUEsQ0FBQWdCLE1BQUEsRUFBQWtCLFFBQUEsQ0FBQXRFLFFBQUEsRUFBQWlDLE9BQUEsQ0FBQUssR0FBQSxtQkFBQXFCLE1BQUEsQ0FBQXBCLElBQUEsU0FBQU4sT0FBQSxDQUFBbUIsTUFBQSxZQUFBbkIsT0FBQSxDQUFBSyxHQUFBLEdBQUFxQixNQUFBLENBQUFyQixHQUFBLEVBQUFMLE9BQUEsQ0FBQXFDLFFBQUEsU0FBQTdCLGdCQUFBLE1BQUF3QyxJQUFBLEdBQUF0QixNQUFBLENBQUFyQixHQUFBLFNBQUEyQyxJQUFBLEdBQUFBLElBQUEsQ0FBQUosSUFBQSxJQUFBNUMsT0FBQSxDQUFBcUMsUUFBQSxDQUFBWSxVQUFBLElBQUFELElBQUEsQ0FBQXJFLEtBQUEsRUFBQXFCLE9BQUEsQ0FBQWtELElBQUEsR0FBQWIsUUFBQSxDQUFBYyxPQUFBLGVBQUFuRCxPQUFBLENBQUFtQixNQUFBLEtBQUFuQixPQUFBLENBQUFtQixNQUFBLFdBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQXlDLFNBQUEsR0FBQTlDLE9BQUEsQ0FBQXFDLFFBQUEsU0FBQTdCLGdCQUFBLElBQUF3QyxJQUFBLElBQUFoRCxPQUFBLENBQUFtQixNQUFBLFlBQUFuQixPQUFBLENBQUFLLEdBQUEsT0FBQTBDLFNBQUEsc0NBQUEvQyxPQUFBLENBQUFxQyxRQUFBLFNBQUE3QixnQkFBQSxjQUFBNEMsYUFBQUMsSUFBQSxRQUFBQyxLQUFBLEtBQUFDLE1BQUEsRUFBQUYsSUFBQSxZQUFBQSxJQUFBLEtBQUFDLEtBQUEsQ0FBQUUsUUFBQSxHQUFBSCxJQUFBLFdBQUFBLElBQUEsS0FBQUMsS0FBQSxDQUFBRyxVQUFBLEdBQUFKLElBQUEsS0FBQUMsS0FBQSxDQUFBSSxRQUFBLEdBQUFMLElBQUEsV0FBQU0sVUFBQSxDQUFBQyxJQUFBLENBQUFOLEtBQUEsY0FBQU8sY0FBQVAsS0FBQSxRQUFBNUIsTUFBQSxHQUFBNEIsS0FBQSxDQUFBUSxVQUFBLFFBQUFwQyxNQUFBLENBQUFwQixJQUFBLG9CQUFBb0IsTUFBQSxDQUFBckIsR0FBQSxFQUFBaUQsS0FBQSxDQUFBUSxVQUFBLEdBQUFwQyxNQUFBLGFBQUF6QixRQUFBTixXQUFBLFNBQUFnRSxVQUFBLE1BQUFKLE1BQUEsYUFBQTVELFdBQUEsQ0FBQXVCLE9BQUEsQ0FBQWtDLFlBQUEsY0FBQVcsS0FBQSxpQkFBQWhELE9BQUFpRCxRQUFBLFFBQUFBLFFBQUEsUUFBQUMsY0FBQSxHQUFBRCxRQUFBLENBQUFuRixjQUFBLE9BQUFvRixjQUFBLFNBQUFBLGNBQUEsQ0FBQTFELElBQUEsQ0FBQXlELFFBQUEsNEJBQUFBLFFBQUEsQ0FBQWQsSUFBQSxTQUFBYyxRQUFBLE9BQUFFLEtBQUEsQ0FBQUYsUUFBQSxDQUFBRyxNQUFBLFNBQUFDLENBQUEsT0FBQWxCLElBQUEsWUFBQUEsS0FBQSxhQUFBa0IsQ0FBQSxHQUFBSixRQUFBLENBQUFHLE1BQUEsT0FBQTdGLE1BQUEsQ0FBQWlDLElBQUEsQ0FBQXlELFFBQUEsRUFBQUksQ0FBQSxVQUFBbEIsSUFBQSxDQUFBdkUsS0FBQSxHQUFBcUYsUUFBQSxDQUFBSSxDQUFBLEdBQUFsQixJQUFBLENBQUFOLElBQUEsT0FBQU0sSUFBQSxTQUFBQSxJQUFBLENBQUF2RSxLQUFBLEdBQUFtRSxTQUFBLEVBQUFJLElBQUEsQ0FBQU4sSUFBQSxPQUFBTSxJQUFBLFlBQUFBLElBQUEsQ0FBQUEsSUFBQSxHQUFBQSxJQUFBLGVBQUFBLElBQUEsRUFBQWQsVUFBQSxlQUFBQSxXQUFBLGFBQUF6RCxLQUFBLEVBQUFtRSxTQUFBLEVBQUFGLElBQUEsaUJBQUFuQyxpQkFBQSxDQUFBeEMsU0FBQSxHQUFBeUMsMEJBQUEsRUFBQWxDLGNBQUEsQ0FBQXdDLEVBQUEsbUJBQUFyQyxLQUFBLEVBQUErQiwwQkFBQSxFQUFBdEIsWUFBQSxTQUFBWixjQUFBLENBQUFrQywwQkFBQSxtQkFBQS9CLEtBQUEsRUFBQThCLGlCQUFBLEVBQUFyQixZQUFBLFNBQUFxQixpQkFBQSxDQUFBNEQsV0FBQSxHQUFBbkYsTUFBQSxDQUFBd0IsMEJBQUEsRUFBQTFCLGlCQUFBLHdCQUFBYixPQUFBLENBQUFtRyxtQkFBQSxhQUFBQyxNQUFBLFFBQUFDLElBQUEsd0JBQUFELE1BQUEsSUFBQUEsTUFBQSxDQUFBdkcsV0FBQSxXQUFBd0csSUFBQSxLQUFBQSxJQUFBLEtBQUEvRCxpQkFBQSw2QkFBQStELElBQUEsQ0FBQUgsV0FBQSxJQUFBRyxJQUFBLENBQUFDLElBQUEsT0FBQXRHLE9BQUEsQ0FBQXVHLElBQUEsYUFBQUgsTUFBQSxXQUFBbEcsTUFBQSxDQUFBc0csY0FBQSxHQUFBdEcsTUFBQSxDQUFBc0csY0FBQSxDQUFBSixNQUFBLEVBQUE3RCwwQkFBQSxLQUFBNkQsTUFBQSxDQUFBSyxTQUFBLEdBQUFsRSwwQkFBQSxFQUFBeEIsTUFBQSxDQUFBcUYsTUFBQSxFQUFBdkYsaUJBQUEseUJBQUF1RixNQUFBLENBQUF0RyxTQUFBLEdBQUFJLE1BQUEsQ0FBQTBCLE1BQUEsQ0FBQWlCLEVBQUEsR0FBQXVELE1BQUEsS0FBQXBHLE9BQUEsQ0FBQTBHLEtBQUEsYUFBQXhFLEdBQUEsYUFBQXVCLE9BQUEsRUFBQXZCLEdBQUEsT0FBQVkscUJBQUEsQ0FBQUksYUFBQSxDQUFBcEQsU0FBQSxHQUFBaUIsTUFBQSxDQUFBbUMsYUFBQSxDQUFBcEQsU0FBQSxFQUFBYSxtQkFBQSxpQ0FBQVgsT0FBQSxDQUFBa0QsYUFBQSxHQUFBQSxhQUFBLEVBQUFsRCxPQUFBLENBQUEyRyxLQUFBLGFBQUF0RixPQUFBLEVBQUFDLE9BQUEsRUFBQUMsSUFBQSxFQUFBQyxXQUFBLEVBQUEyQixXQUFBLGVBQUFBLFdBQUEsS0FBQUEsV0FBQSxHQUFBeUQsT0FBQSxPQUFBQyxJQUFBLE9BQUEzRCxhQUFBLENBQUE5QixJQUFBLENBQUFDLE9BQUEsRUFBQUMsT0FBQSxFQUFBQyxJQUFBLEVBQUFDLFdBQUEsR0FBQTJCLFdBQUEsVUFBQW5ELE9BQUEsQ0FBQW1HLG1CQUFBLENBQUE3RSxPQUFBLElBQUF1RixJQUFBLEdBQUFBLElBQUEsQ0FBQTlCLElBQUEsR0FBQXJCLElBQUEsV0FBQUYsTUFBQSxXQUFBQSxNQUFBLENBQUFpQixJQUFBLEdBQUFqQixNQUFBLENBQUFoRCxLQUFBLEdBQUFxRyxJQUFBLENBQUE5QixJQUFBLFdBQUFqQyxxQkFBQSxDQUFBRCxFQUFBLEdBQUE5QixNQUFBLENBQUE4QixFQUFBLEVBQUFoQyxpQkFBQSxnQkFBQUUsTUFBQSxDQUFBOEIsRUFBQSxFQUFBbkMsY0FBQSxpQ0FBQUssTUFBQSxDQUFBOEIsRUFBQSw2REFBQTdDLE9BQUEsQ0FBQThHLElBQUEsYUFBQUMsR0FBQSxRQUFBQyxNQUFBLEdBQUE5RyxNQUFBLENBQUE2RyxHQUFBLEdBQUFELElBQUEsZ0JBQUF4RyxHQUFBLElBQUEwRyxNQUFBLEVBQUFGLElBQUEsQ0FBQXJCLElBQUEsQ0FBQW5GLEdBQUEsVUFBQXdHLElBQUEsQ0FBQUcsT0FBQSxhQUFBbEMsS0FBQSxXQUFBK0IsSUFBQSxDQUFBZCxNQUFBLFNBQUExRixHQUFBLEdBQUF3RyxJQUFBLENBQUFJLEdBQUEsUUFBQTVHLEdBQUEsSUFBQTBHLE1BQUEsU0FBQWpDLElBQUEsQ0FBQXZFLEtBQUEsR0FBQUYsR0FBQSxFQUFBeUUsSUFBQSxDQUFBTixJQUFBLE9BQUFNLElBQUEsV0FBQUEsSUFBQSxDQUFBTixJQUFBLE9BQUFNLElBQUEsUUFBQS9FLE9BQUEsQ0FBQTRDLE1BQUEsR0FBQUEsTUFBQSxFQUFBZCxPQUFBLENBQUFoQyxTQUFBLEtBQUFELFdBQUEsRUFBQWlDLE9BQUEsRUFBQThELEtBQUEsV0FBQUEsTUFBQXVCLGFBQUEsYUFBQUMsSUFBQSxXQUFBckMsSUFBQSxXQUFBVixJQUFBLFFBQUFDLEtBQUEsR0FBQUssU0FBQSxPQUFBRixJQUFBLFlBQUFQLFFBQUEsY0FBQWxCLE1BQUEsZ0JBQUFkLEdBQUEsR0FBQXlDLFNBQUEsT0FBQWEsVUFBQSxDQUFBekMsT0FBQSxDQUFBMkMsYUFBQSxJQUFBeUIsYUFBQSxXQUFBYixJQUFBLGtCQUFBQSxJQUFBLENBQUFlLE1BQUEsT0FBQWxILE1BQUEsQ0FBQWlDLElBQUEsT0FBQWtFLElBQUEsTUFBQVAsS0FBQSxFQUFBTyxJQUFBLENBQUFnQixLQUFBLGNBQUFoQixJQUFBLElBQUEzQixTQUFBLE1BQUE0QyxJQUFBLFdBQUFBLEtBQUEsU0FBQTlDLElBQUEsV0FBQStDLFVBQUEsUUFBQWhDLFVBQUEsSUFBQUcsVUFBQSxrQkFBQTZCLFVBQUEsQ0FBQXJGLElBQUEsUUFBQXFGLFVBQUEsQ0FBQXRGLEdBQUEsY0FBQXVGLElBQUEsS0FBQWxELGlCQUFBLFdBQUFBLGtCQUFBbUQsU0FBQSxhQUFBakQsSUFBQSxRQUFBaUQsU0FBQSxNQUFBN0YsT0FBQSxrQkFBQThGLE9BQUFDLEdBQUEsRUFBQUMsTUFBQSxXQUFBdEUsTUFBQSxDQUFBcEIsSUFBQSxZQUFBb0IsTUFBQSxDQUFBckIsR0FBQSxHQUFBd0YsU0FBQSxFQUFBN0YsT0FBQSxDQUFBa0QsSUFBQSxHQUFBNkMsR0FBQSxFQUFBQyxNQUFBLEtBQUFoRyxPQUFBLENBQUFtQixNQUFBLFdBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQXlDLFNBQUEsS0FBQWtELE1BQUEsYUFBQTVCLENBQUEsUUFBQVQsVUFBQSxDQUFBUSxNQUFBLE1BQUFDLENBQUEsU0FBQUEsQ0FBQSxRQUFBZCxLQUFBLFFBQUFLLFVBQUEsQ0FBQVMsQ0FBQSxHQUFBMUMsTUFBQSxHQUFBNEIsS0FBQSxDQUFBUSxVQUFBLGlCQUFBUixLQUFBLENBQUFDLE1BQUEsU0FBQXVDLE1BQUEsYUFBQXhDLEtBQUEsQ0FBQUMsTUFBQSxTQUFBZ0MsSUFBQSxRQUFBVSxRQUFBLEdBQUEzSCxNQUFBLENBQUFpQyxJQUFBLENBQUErQyxLQUFBLGVBQUE0QyxVQUFBLEdBQUE1SCxNQUFBLENBQUFpQyxJQUFBLENBQUErQyxLQUFBLHFCQUFBMkMsUUFBQSxJQUFBQyxVQUFBLGFBQUFYLElBQUEsR0FBQWpDLEtBQUEsQ0FBQUUsUUFBQSxTQUFBc0MsTUFBQSxDQUFBeEMsS0FBQSxDQUFBRSxRQUFBLGdCQUFBK0IsSUFBQSxHQUFBakMsS0FBQSxDQUFBRyxVQUFBLFNBQUFxQyxNQUFBLENBQUF4QyxLQUFBLENBQUFHLFVBQUEsY0FBQXdDLFFBQUEsYUFBQVYsSUFBQSxHQUFBakMsS0FBQSxDQUFBRSxRQUFBLFNBQUFzQyxNQUFBLENBQUF4QyxLQUFBLENBQUFFLFFBQUEscUJBQUEwQyxVQUFBLFlBQUEvRCxLQUFBLHFEQUFBb0QsSUFBQSxHQUFBakMsS0FBQSxDQUFBRyxVQUFBLFNBQUFxQyxNQUFBLENBQUF4QyxLQUFBLENBQUFHLFVBQUEsWUFBQWQsTUFBQSxXQUFBQSxPQUFBckMsSUFBQSxFQUFBRCxHQUFBLGFBQUErRCxDQUFBLFFBQUFULFVBQUEsQ0FBQVEsTUFBQSxNQUFBQyxDQUFBLFNBQUFBLENBQUEsUUFBQWQsS0FBQSxRQUFBSyxVQUFBLENBQUFTLENBQUEsT0FBQWQsS0FBQSxDQUFBQyxNQUFBLFNBQUFnQyxJQUFBLElBQUFqSCxNQUFBLENBQUFpQyxJQUFBLENBQUErQyxLQUFBLHdCQUFBaUMsSUFBQSxHQUFBakMsS0FBQSxDQUFBRyxVQUFBLFFBQUEwQyxZQUFBLEdBQUE3QyxLQUFBLGFBQUE2QyxZQUFBLGlCQUFBN0YsSUFBQSxtQkFBQUEsSUFBQSxLQUFBNkYsWUFBQSxDQUFBNUMsTUFBQSxJQUFBbEQsR0FBQSxJQUFBQSxHQUFBLElBQUE4RixZQUFBLENBQUExQyxVQUFBLEtBQUEwQyxZQUFBLGNBQUF6RSxNQUFBLEdBQUF5RSxZQUFBLEdBQUFBLFlBQUEsQ0FBQXJDLFVBQUEsY0FBQXBDLE1BQUEsQ0FBQXBCLElBQUEsR0FBQUEsSUFBQSxFQUFBb0IsTUFBQSxDQUFBckIsR0FBQSxHQUFBQSxHQUFBLEVBQUE4RixZQUFBLFNBQUFoRixNQUFBLGdCQUFBK0IsSUFBQSxHQUFBaUQsWUFBQSxDQUFBMUMsVUFBQSxFQUFBakQsZ0JBQUEsU0FBQTRGLFFBQUEsQ0FBQTFFLE1BQUEsTUFBQTBFLFFBQUEsV0FBQUEsU0FBQTFFLE1BQUEsRUFBQWdDLFFBQUEsb0JBQUFoQyxNQUFBLENBQUFwQixJQUFBLFFBQUFvQixNQUFBLENBQUFyQixHQUFBLHFCQUFBcUIsTUFBQSxDQUFBcEIsSUFBQSxtQkFBQW9CLE1BQUEsQ0FBQXBCLElBQUEsUUFBQTRDLElBQUEsR0FBQXhCLE1BQUEsQ0FBQXJCLEdBQUEsZ0JBQUFxQixNQUFBLENBQUFwQixJQUFBLFNBQUFzRixJQUFBLFFBQUF2RixHQUFBLEdBQUFxQixNQUFBLENBQUFyQixHQUFBLE9BQUFjLE1BQUEsa0JBQUErQixJQUFBLHlCQUFBeEIsTUFBQSxDQUFBcEIsSUFBQSxJQUFBb0QsUUFBQSxVQUFBUixJQUFBLEdBQUFRLFFBQUEsR0FBQWxELGdCQUFBLEtBQUE2RixNQUFBLFdBQUFBLE9BQUE1QyxVQUFBLGFBQUFXLENBQUEsUUFBQVQsVUFBQSxDQUFBUSxNQUFBLE1BQUFDLENBQUEsU0FBQUEsQ0FBQSxRQUFBZCxLQUFBLFFBQUFLLFVBQUEsQ0FBQVMsQ0FBQSxPQUFBZCxLQUFBLENBQUFHLFVBQUEsS0FBQUEsVUFBQSxjQUFBMkMsUUFBQSxDQUFBOUMsS0FBQSxDQUFBUSxVQUFBLEVBQUFSLEtBQUEsQ0FBQUksUUFBQSxHQUFBRyxhQUFBLENBQUFQLEtBQUEsR0FBQTlDLGdCQUFBLHlCQUFBOEYsT0FBQS9DLE1BQUEsYUFBQWEsQ0FBQSxRQUFBVCxVQUFBLENBQUFRLE1BQUEsTUFBQUMsQ0FBQSxTQUFBQSxDQUFBLFFBQUFkLEtBQUEsUUFBQUssVUFBQSxDQUFBUyxDQUFBLE9BQUFkLEtBQUEsQ0FBQUMsTUFBQSxLQUFBQSxNQUFBLFFBQUE3QixNQUFBLEdBQUE0QixLQUFBLENBQUFRLFVBQUEsa0JBQUFwQyxNQUFBLENBQUFwQixJQUFBLFFBQUFpRyxNQUFBLEdBQUE3RSxNQUFBLENBQUFyQixHQUFBLEVBQUF3RCxhQUFBLENBQUFQLEtBQUEsWUFBQWlELE1BQUEsZ0JBQUFwRSxLQUFBLDhCQUFBcUUsYUFBQSxXQUFBQSxjQUFBeEMsUUFBQSxFQUFBZixVQUFBLEVBQUFFLE9BQUEsZ0JBQUFkLFFBQUEsS0FBQXRFLFFBQUEsRUFBQWdELE1BQUEsQ0FBQWlELFFBQUEsR0FBQWYsVUFBQSxFQUFBQSxVQUFBLEVBQUFFLE9BQUEsRUFBQUEsT0FBQSxvQkFBQWhDLE1BQUEsVUFBQWQsR0FBQSxHQUFBeUMsU0FBQSxHQUFBdEMsZ0JBQUEsT0FBQXJDLE9BQUE7QUFBQSxTQUFBc0ksZUFBQUMsR0FBQSxFQUFBdEMsQ0FBQSxXQUFBdUMsZUFBQSxDQUFBRCxHQUFBLEtBQUFFLHFCQUFBLENBQUFGLEdBQUEsRUFBQXRDLENBQUEsS0FBQXlDLDJCQUFBLENBQUFILEdBQUEsRUFBQXRDLENBQUEsS0FBQTBDLGdCQUFBO0FBQUEsU0FBQUEsaUJBQUEsY0FBQS9ELFNBQUE7QUFBQSxTQUFBNkQsc0JBQUFGLEdBQUEsRUFBQXRDLENBQUEsUUFBQTJDLEVBQUEsV0FBQUwsR0FBQSxnQ0FBQTVJLE1BQUEsSUFBQTRJLEdBQUEsQ0FBQTVJLE1BQUEsQ0FBQUMsUUFBQSxLQUFBMkksR0FBQSw0QkFBQUssRUFBQSxRQUFBQyxFQUFBLEVBQUFDLEVBQUEsRUFBQUMsRUFBQSxFQUFBQyxFQUFBLEVBQUFDLElBQUEsT0FBQUMsRUFBQSxPQUFBQyxFQUFBLGlCQUFBSixFQUFBLElBQUFILEVBQUEsR0FBQUEsRUFBQSxDQUFBeEcsSUFBQSxDQUFBbUcsR0FBQSxHQUFBeEQsSUFBQSxRQUFBa0IsQ0FBQSxRQUFBL0YsTUFBQSxDQUFBMEksRUFBQSxNQUFBQSxFQUFBLFVBQUFNLEVBQUEsdUJBQUFBLEVBQUEsSUFBQUwsRUFBQSxHQUFBRSxFQUFBLENBQUEzRyxJQUFBLENBQUF3RyxFQUFBLEdBQUFuRSxJQUFBLE1BQUF3RSxJQUFBLENBQUF4RCxJQUFBLENBQUFvRCxFQUFBLENBQUFySSxLQUFBLEdBQUF5SSxJQUFBLENBQUFqRCxNQUFBLEtBQUFDLENBQUEsR0FBQWlELEVBQUEsaUJBQUEvSCxHQUFBLElBQUFnSSxFQUFBLE9BQUFMLEVBQUEsR0FBQTNILEdBQUEseUJBQUErSCxFQUFBLFlBQUFOLEVBQUEsZUFBQUksRUFBQSxHQUFBSixFQUFBLGNBQUExSSxNQUFBLENBQUE4SSxFQUFBLE1BQUFBLEVBQUEsMkJBQUFHLEVBQUEsUUFBQUwsRUFBQSxhQUFBRyxJQUFBO0FBQUEsU0FBQVQsZ0JBQUFELEdBQUEsUUFBQWEsS0FBQSxDQUFBQyxPQUFBLENBQUFkLEdBQUEsVUFBQUEsR0FBQTtBQUFBLFNBQUFlLDJCQUFBQyxDQUFBLEVBQUFDLGNBQUEsUUFBQUMsRUFBQSxVQUFBOUosTUFBQSxvQkFBQTRKLENBQUEsQ0FBQTVKLE1BQUEsQ0FBQUMsUUFBQSxLQUFBMkosQ0FBQSxxQkFBQUUsRUFBQSxRQUFBTCxLQUFBLENBQUFDLE9BQUEsQ0FBQUUsQ0FBQSxNQUFBRSxFQUFBLEdBQUFmLDJCQUFBLENBQUFhLENBQUEsTUFBQUMsY0FBQSxJQUFBRCxDQUFBLFdBQUFBLENBQUEsQ0FBQXZELE1BQUEscUJBQUF5RCxFQUFBLEVBQUFGLENBQUEsR0FBQUUsRUFBQSxNQUFBeEQsQ0FBQSxVQUFBeUQsQ0FBQSxZQUFBQSxFQUFBLGVBQUFDLENBQUEsRUFBQUQsQ0FBQSxFQUFBRSxDQUFBLFdBQUFBLEVBQUEsUUFBQTNELENBQUEsSUFBQXNELENBQUEsQ0FBQXZELE1BQUEsV0FBQXZCLElBQUEsbUJBQUFBLElBQUEsU0FBQWpFLEtBQUEsRUFBQStJLENBQUEsQ0FBQXRELENBQUEsVUFBQTRELENBQUEsV0FBQUEsRUFBQUMsR0FBQSxVQUFBQSxHQUFBLEtBQUFDLENBQUEsRUFBQUwsQ0FBQSxnQkFBQTlFLFNBQUEsaUpBQUFvRixnQkFBQSxTQUFBQyxNQUFBLFVBQUE5SSxHQUFBLFdBQUF3SSxDQUFBLFdBQUFBLEVBQUEsSUFBQUYsRUFBQSxHQUFBQSxFQUFBLENBQUFySCxJQUFBLENBQUFtSCxDQUFBLE1BQUFLLENBQUEsV0FBQUEsRUFBQSxRQUFBTSxJQUFBLEdBQUFULEVBQUEsQ0FBQTFFLElBQUEsSUFBQWlGLGdCQUFBLEdBQUFFLElBQUEsQ0FBQXpGLElBQUEsU0FBQXlGLElBQUEsS0FBQUwsQ0FBQSxXQUFBQSxFQUFBTSxHQUFBLElBQUFGLE1BQUEsU0FBQTlJLEdBQUEsR0FBQWdKLEdBQUEsS0FBQUosQ0FBQSxXQUFBQSxFQUFBLGVBQUFDLGdCQUFBLElBQUFQLEVBQUEsb0JBQUFBLEVBQUEsOEJBQUFRLE1BQUEsUUFBQTlJLEdBQUE7QUFBQSxTQUFBaUosbUJBQUE3QixHQUFBLFdBQUE4QixrQkFBQSxDQUFBOUIsR0FBQSxLQUFBK0IsZ0JBQUEsQ0FBQS9CLEdBQUEsS0FBQUcsMkJBQUEsQ0FBQUgsR0FBQSxLQUFBZ0Msa0JBQUE7QUFBQSxTQUFBQSxtQkFBQSxjQUFBM0YsU0FBQTtBQUFBLFNBQUE4RCw0QkFBQWEsQ0FBQSxFQUFBaUIsTUFBQSxTQUFBakIsQ0FBQSxxQkFBQUEsQ0FBQSxzQkFBQWtCLGlCQUFBLENBQUFsQixDQUFBLEVBQUFpQixNQUFBLE9BQUFaLENBQUEsR0FBQTFKLE1BQUEsQ0FBQUosU0FBQSxDQUFBNEssUUFBQSxDQUFBdEksSUFBQSxDQUFBbUgsQ0FBQSxFQUFBakMsS0FBQSxhQUFBc0MsQ0FBQSxpQkFBQUwsQ0FBQSxDQUFBMUosV0FBQSxFQUFBK0osQ0FBQSxHQUFBTCxDQUFBLENBQUExSixXQUFBLENBQUF5RyxJQUFBLE1BQUFzRCxDQUFBLGNBQUFBLENBQUEsbUJBQUFSLEtBQUEsQ0FBQXVCLElBQUEsQ0FBQXBCLENBQUEsT0FBQUssQ0FBQSwrREFBQWdCLElBQUEsQ0FBQWhCLENBQUEsVUFBQWEsaUJBQUEsQ0FBQWxCLENBQUEsRUFBQWlCLE1BQUE7QUFBQSxTQUFBRixpQkFBQXpELElBQUEsZUFBQWxILE1BQUEsb0JBQUFrSCxJQUFBLENBQUFsSCxNQUFBLENBQUFDLFFBQUEsYUFBQWlILElBQUEsK0JBQUF1QyxLQUFBLENBQUF1QixJQUFBLENBQUE5RCxJQUFBO0FBQUEsU0FBQXdELG1CQUFBOUIsR0FBQSxRQUFBYSxLQUFBLENBQUFDLE9BQUEsQ0FBQWQsR0FBQSxVQUFBa0MsaUJBQUEsQ0FBQWxDLEdBQUE7QUFBQSxTQUFBa0Msa0JBQUFsQyxHQUFBLEVBQUFzQyxHQUFBLFFBQUFBLEdBQUEsWUFBQUEsR0FBQSxHQUFBdEMsR0FBQSxDQUFBdkMsTUFBQSxFQUFBNkUsR0FBQSxHQUFBdEMsR0FBQSxDQUFBdkMsTUFBQSxXQUFBQyxDQUFBLE1BQUE2RSxJQUFBLE9BQUExQixLQUFBLENBQUF5QixHQUFBLEdBQUE1RSxDQUFBLEdBQUE0RSxHQUFBLEVBQUE1RSxDQUFBLElBQUE2RSxJQUFBLENBQUE3RSxDQUFBLElBQUFzQyxHQUFBLENBQUF0QyxDQUFBLFVBQUE2RSxJQUFBO0FBQUEsU0FBQUMsZ0JBQUFDLFFBQUEsRUFBQUMsV0FBQSxVQUFBRCxRQUFBLFlBQUFDLFdBQUEsZUFBQXJHLFNBQUE7QUFBQSxTQUFBc0csa0JBQUFDLE1BQUEsRUFBQUMsS0FBQSxhQUFBbkYsQ0FBQSxNQUFBQSxDQUFBLEdBQUFtRixLQUFBLENBQUFwRixNQUFBLEVBQUFDLENBQUEsVUFBQW9GLFVBQUEsR0FBQUQsS0FBQSxDQUFBbkYsQ0FBQSxHQUFBb0YsVUFBQSxDQUFBckssVUFBQSxHQUFBcUssVUFBQSxDQUFBckssVUFBQSxXQUFBcUssVUFBQSxDQUFBcEssWUFBQSx3QkFBQW9LLFVBQUEsRUFBQUEsVUFBQSxDQUFBbkssUUFBQSxTQUFBaEIsTUFBQSxDQUFBRyxjQUFBLENBQUE4SyxNQUFBLEVBQUFHLGNBQUEsQ0FBQUQsVUFBQSxDQUFBL0ssR0FBQSxHQUFBK0ssVUFBQTtBQUFBLFNBQUFFLGFBQUFOLFdBQUEsRUFBQU8sVUFBQSxFQUFBQyxXQUFBLFFBQUFELFVBQUEsRUFBQU4saUJBQUEsQ0FBQUQsV0FBQSxDQUFBbkwsU0FBQSxFQUFBMEwsVUFBQSxPQUFBQyxXQUFBLEVBQUFQLGlCQUFBLENBQUFELFdBQUEsRUFBQVEsV0FBQSxHQUFBdkwsTUFBQSxDQUFBRyxjQUFBLENBQUE0SyxXQUFBLGlCQUFBL0osUUFBQSxtQkFBQStKLFdBQUE7QUFBQSxTQUFBSyxlQUFBcEosR0FBQSxRQUFBNUIsR0FBQSxHQUFBb0wsWUFBQSxDQUFBeEosR0FBQSxvQkFBQXpDLE9BQUEsQ0FBQWEsR0FBQSxpQkFBQUEsR0FBQSxHQUFBcUwsTUFBQSxDQUFBckwsR0FBQTtBQUFBLFNBQUFvTCxhQUFBRSxLQUFBLEVBQUFDLElBQUEsUUFBQXBNLE9BQUEsQ0FBQW1NLEtBQUEsa0JBQUFBLEtBQUEsa0JBQUFBLEtBQUEsTUFBQUUsSUFBQSxHQUFBRixLQUFBLENBQUFqTSxNQUFBLENBQUFvTSxXQUFBLE9BQUFELElBQUEsS0FBQW5ILFNBQUEsUUFBQXFILEdBQUEsR0FBQUYsSUFBQSxDQUFBMUosSUFBQSxDQUFBd0osS0FBQSxFQUFBQyxJQUFBLG9CQUFBcE0sT0FBQSxDQUFBdU0sR0FBQSx1QkFBQUEsR0FBQSxZQUFBcEgsU0FBQSw0REFBQWlILElBQUEsZ0JBQUFGLE1BQUEsR0FBQU0sTUFBQSxFQUFBTCxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBLElBQUFNLE9BQUEsR0FBQUMsZUFBQSxDQUFBQyxtQkFBQTtBQUVBLElBQUFDLHNCQUFBLEdBQUFELG1CQUFBO0FBRUEsSUFBQUUsZ0JBQUEsR0FBQUgsZUFBQSxDQUFBQyxtQkFBQTtBQUVBO0FBQUEsSUFDcUJHLFlBQVk7RUFFN0IsU0FBQUEsYUFBWUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLG9CQUFvQjtJQUFBLElBQUFDLEtBQUE7SUFBQTVCLGVBQUEsT0FBQXdCLFlBQUE7SUFRekQsS0FBQUssWUFBWSxHQUFHLENBQUM7SUFDaEIsS0FBQUMsaUJBQWlCLEdBQUcsQ0FBQztJQUVyQixLQUFBQyxVQUFVLEdBQUc7TUFFVDtNQUNBQyxXQUFXLEVBQUMsSUFBSUMsR0FBRyxFQUFFO01BQ3JCQyxnQkFBZ0IsRUFBQyxJQUFJRCxHQUFHLEVBQUU7TUFFMUI7TUFDQUUsWUFBWSxFQUFDLElBQUlDLEdBQUcsRUFBRTtNQUV0QjtNQUNBQyxvQkFBb0IsRUFBQyxJQUFJSixHQUFHLEVBQUU7TUFDOUI7TUFDQUssWUFBWSxFQUFFLElBQUlMLEdBQUcsRUFBRTtNQUN2Qk0sbUJBQW1CLEVBQUMsSUFBSTtNQUN4QkMsd0JBQXdCLEVBQUMsSUFBSTtNQUM3QkMsb0JBQW9CLEVBQUUsSUFBSUwsR0FBRyxFQUFFO01BRS9CTSxZQUFZLEVBQUMsSUFBSTtNQUVqQmpCLFVBQVUsRUFBQyxJQUFJLENBQUM7S0FDbkI7SUFVRDtJQUNBO0lBQ0E7SUFFQTtJQUVBO0lBRUEsS0FBQWtCLG1CQUFtQixHQUFHLFlBQUs7TUFFdkJmLEtBQUksQ0FBQ0csVUFBVSxDQUFDUSxtQkFBbUIsR0FBR2xFLEtBQUssQ0FBQ3VCLElBQUksQ0FBQ2dDLEtBQUksQ0FBQ0csVUFBVSxDQUFDTyxZQUFZLENBQUN6SyxNQUFNLEVBQUUsQ0FBQztNQUV2RitKLEtBQUksQ0FBQ0csVUFBVSxDQUFDUyx3QkFBd0IsQ0FBQ1osS0FBSSxDQUFDRyxVQUFVLENBQUNRLG1CQUFtQixDQUFDO0lBRWpGLENBQUM7SUFFRCxLQUFBSyxZQUFZLEdBQUcsWUFBSztNQUVoQixJQUFNQyxXQUFXLEdBQUdqQixLQUFJLENBQUNFLGlCQUFpQixFQUFFO01BQzVDRixLQUFJLENBQUNHLFVBQVUsQ0FBQ00sb0JBQW9CLENBQUNTLEdBQUcsQ0FBQ0QsV0FBVyxFQUNoRDtRQUNJRSxTQUFTLEVBQUMsSUFBSWQsR0FBRyxFQUFFO1FBQ25CZSxRQUFRLEVBQUMsQ0FBQztRQUNWQyxnQkFBZ0IsRUFBQyxJQUFJO1FBQ3JCQyxRQUFRLEVBQUMsS0FBSztRQUNkQyxXQUFXLEVBQUMsSUFBSTtRQUNoQk4sV0FBVyxFQUFYQTtPQUNILENBQUM7TUFFTixJQUFNTyxXQUFXLEdBQUc7UUFDaEJDLE9BQU8sRUFBQztPQUNYO01BRUQsSUFBTUMsT0FBTyxHQUFHLElBQUl6SCxPQUFPLENBQUMsVUFBQ3ZELE9BQU8sRUFBSTtRQUNwQzhLLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHL0ssT0FBTztNQUNqQyxDQUFDLENBQUM7TUFFRixJQUFNaUwsUUFBUSxHQUFHLFNBQVhBLFFBQVFBLENBQUEsRUFBUTtRQUVsQkgsV0FBVyxDQUFDQyxPQUFPLENBQUNSLFdBQVcsQ0FBQztNQUVwQyxDQUFDO01BRURqQixLQUFJLENBQUNHLFVBQVUsQ0FBQ08sWUFBWSxDQUFDUSxHQUFHLENBQUNELFdBQVcsRUFDeEMxQixPQUFBLFlBQUFxQyxhQUFBLENBQUNqQyxnQkFBQSxXQUFjO1FBQ1hoTSxHQUFHLEVBQUlzTixXQUFXO1FBQ2xCZCxVQUFVLEVBQUlILEtBQUksQ0FBQ0csVUFBVTtRQUM3QmMsV0FBVyxFQUFJQSxXQUFXO1FBQzFCVSxRQUFRLEVBQUtBO01BQVEsRUFBSyxDQUFDO01BRW5DM0IsS0FBSSxDQUFDZSxtQkFBbUIsRUFBRTtNQUUxQixPQUFPVyxPQUFPO0lBRWxCLENBQUM7SUFnREQsS0FBQUcsa0JBQWtCLEdBQUcsVUFBQ1osV0FBVyxFQUFFYSxNQUFNLEVBQUVDLE1BQU0sRUFBSTtNQUVqRCxJQUFNQyxpQkFBaUIsR0FBR2hDLEtBQUksQ0FBQ0csVUFBVSxDQUFDTSxvQkFBb0IsQ0FBQ3dCLEdBQUcsQ0FBQ2hCLFdBQVcsQ0FBQztNQUUvRWUsaUJBQWlCLENBQUNiLFNBQVMsQ0FBQ0QsR0FBRyxDQUFDWSxNQUFNLEVBQUNDLE1BQU0sQ0FBQztNQUU5Qy9CLEtBQUksQ0FBQ0csVUFBVSxDQUFDVSxvQkFBb0IsQ0FBQ3FCLEdBQUcsQ0FBQ2pCLFdBQVcsQ0FBQztJQUV6RCxDQUFDO0lBRUQsS0FBQWtCLHFCQUFxQixHQUFHLFVBQUNsQixXQUFXLEVBQUVhLE1BQU0sRUFBSTtNQUU1QyxJQUFNRSxpQkFBaUIsR0FBR2hDLEtBQUksQ0FBQ0csVUFBVSxDQUFDTSxvQkFBb0IsQ0FBQ3dCLEdBQUcsQ0FBQ2hCLFdBQVcsQ0FBQztNQUUvRWUsaUJBQWlCLENBQUNiLFNBQVMsVUFBTyxDQUFDVyxNQUFNLENBQUM7TUFDMUNFLGlCQUFpQixDQUFDWixRQUFRLElBQUksQ0FBQztNQUUvQnBCLEtBQUksQ0FBQ0csVUFBVSxDQUFDVSxvQkFBb0IsQ0FBQ3FCLEdBQUcsQ0FBQ2pCLFdBQVcsQ0FBQztJQUV6RCxDQUFDO0lBRUQsS0FBQW1CLGVBQWUsR0FBRyxVQUFDbkIsV0FBVyxFQUFJO01BRTlCLElBQU1lLGlCQUFpQixHQUFHaEMsS0FBSSxDQUFDRyxVQUFVLENBQUNNLG9CQUFvQixDQUFDd0IsR0FBRyxDQUFDaEIsV0FBVyxDQUFDO01BRS9FLElBQUksQ0FBQ2UsaUJBQWlCLEVBQUU7TUFFeEJBLGlCQUFpQixDQUFDWCxnQkFBZ0IsR0FBSTVFLEtBQUssQ0FBQ3VCLElBQUksQ0FBQ2dFLGlCQUFpQixDQUFDYixTQUFTLENBQUNsTCxNQUFNLEVBQUUsQ0FBQztNQUV0RjtNQUNBK0wsaUJBQWlCLENBQUNULFdBQVcsSUFBSVMsaUJBQWlCLENBQUNULFdBQVcsQ0FBQ1MsaUJBQWlCLENBQUNYLGdCQUFnQixDQUFDO0lBRXRHLENBQUM7SUFFRDtJQUNBLEtBQUFnQixpQkFBaUIsR0FBRyxZQUFLO01BRXJCLElBQVF4QixvQkFBb0IsR0FBS2IsS0FBSSxDQUFDRyxVQUFVLENBQXhDVSxvQkFBb0I7TUFFNUIsSUFBSUEsb0JBQW9CLENBQUN5QixJQUFJLEVBQUU7UUFFM0J6QixvQkFBb0IsQ0FBQ3pLLE9BQU8sQ0FBQyxVQUFDNkssV0FBVyxFQUFJO1VBRXpDakIsS0FBSSxDQUFDb0MsZUFBZSxDQUFDbkIsV0FBVyxDQUFDO1FBRXJDLENBQUMsQ0FBQztRQUVGakIsS0FBSSxDQUFDRyxVQUFVLENBQUNVLG9CQUFvQixDQUFDMEIsS0FBSyxFQUFFOztJQUlwRCxDQUFDO0lBRUQsS0FBQUMsVUFBVSxHQUFHLFlBQUs7TUFFZDtNQUNBeEMsS0FBSSxDQUFDRyxVQUFVLENBQUNDLFdBQVcsQ0FBQ21DLEtBQUssRUFBRTtNQUNuQ3ZDLEtBQUksQ0FBQ0csVUFBVSxDQUFDRyxnQkFBZ0IsQ0FBQ2lDLEtBQUssRUFBRTtNQUN4Q3ZDLEtBQUksQ0FBQ0csVUFBVSxDQUFDSSxZQUFZLENBQUNnQyxLQUFLLEVBQUU7TUFDcEM7TUFDQXZDLEtBQUksQ0FBQ0csVUFBVSxDQUFDTSxvQkFBb0IsQ0FBQzhCLEtBQUssRUFBRTtNQUM1Q3ZDLEtBQUksQ0FBQ0csVUFBVSxDQUFDTyxZQUFZLENBQUM2QixLQUFLLEVBQUU7TUFDcEN2QyxLQUFJLENBQUNHLFVBQVUsQ0FBQ1EsbUJBQW1CLEdBQUcsRUFBRTtNQUN4Q1gsS0FBSSxDQUFDRyxVQUFVLENBQUNVLG9CQUFvQixDQUFDMEIsS0FBSyxFQUFFO01BQzVDdkMsS0FBSSxDQUFDRyxVQUFVLENBQUNXLFlBQVksR0FBRyxJQUFJO01BQ25DZCxLQUFJLENBQUNHLFVBQVUsQ0FBQ1Msd0JBQXdCLENBQUMsSUFBSSxDQUFDO0lBRWxELENBQUM7SUFFRDtJQUVBO0lBRUE7SUFDQSxLQUFBNkIsbUJBQW1CLEdBQUcsVUFBQ0MsV0FBVyxFQUFFQyxrQkFBa0IsRUFBRUMsc0JBQXNCLEVBQUk7TUFFOUU7TUFFQTtNQUNBLElBQU1DLGNBQWMsR0FBRzdDLEtBQUksQ0FBQ0csVUFBVSxDQUFDRyxnQkFBZ0I7TUFDdkQsSUFBTXdDLFdBQVcsR0FBR3JHLEtBQUssQ0FBQ3VCLElBQUksQ0FBQzZFLGNBQWMsQ0FBQzFJLElBQUksRUFBRSxDQUFDO01BQ3JEMkksV0FBVyxDQUFDQyxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBS0QsQ0FBQyxHQUFHQyxDQUFDO01BQUEsRUFBQztNQUVoQyxJQUFNQyxZQUFZLEdBQUdKLFdBQVcsQ0FBQ0ssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BRXZDLElBQUlELFlBQVksR0FBSVIsV0FBVyxHQUFFLENBQUUsRUFBRTtRQUFFO1FBRW5DLElBQU1VLFFBQVEsR0FBR04sV0FBVyxDQUFDTyxNQUFNLENBQUMsVUFBQ0MsS0FBSyxFQUFHO1VBQ3pDLE9BQU9BLEtBQUssR0FBSVosV0FBVyxHQUFFLENBQUU7UUFDbkMsQ0FBQyxDQUFDO1FBRUYxQyxLQUFJLENBQUN1RCxZQUFZLENBQUNILFFBQVEsRUFBRVQsa0JBQWtCLENBQUM7O01BSW5EQyxzQkFBc0IsSUFBSUEsc0JBQXNCLENBQUNGLFdBQVcsQ0FBQztJQUVqRSxDQUFDO0lBRUQ7SUFFQSxLQUFBYyxrQkFBa0IsR0FBRyxVQUFDQyxlQUFlLEVBQUVkLGtCQUFrQixFQUFJO01BRXpELElBQU1lLE9BQU8sR0FBR2pILEtBQUssQ0FBQ3VCLElBQUksQ0FBQ2dDLEtBQUksQ0FBQ0csVUFBVSxDQUFDRyxnQkFBZ0IsQ0FBQ25HLElBQUksRUFBRSxDQUFDO01BRW5FLElBQU13SixPQUFPLEdBQUdELE9BQU8sQ0FBQ0wsTUFBTSxDQUFDLFVBQUExUCxHQUFHO1FBQUEsT0FBSSxDQUFDOFAsZUFBZSxDQUFDRyxRQUFRLENBQUNqUSxHQUFHLENBQUM7TUFBQSxFQUFDO01BRXJFLElBQUlnUSxPQUFPLENBQUN0SyxNQUFNLEVBQUU7UUFFaEIyRyxLQUFJLENBQUN1RCxZQUFZLENBQUNJLE9BQU8sRUFBRWhCLGtCQUFrQixDQUFDO1FBQzlDLE9BQU8sSUFBSTtPQUVkLE1BQU07UUFFSCxPQUFPLEtBQUs7O0lBSXBCLENBQUM7SUFFRCxLQUFBa0IsY0FBYyxHQUFHLFVBQUNDLFFBQVEsRUFBRUwsZUFBZSxFQUFFZCxrQkFBa0IsRUFBNEI7TUFBQSxJQUExQjlDLFVBQVUsR0FBQWtFLFNBQUEsQ0FBQTFLLE1BQUEsUUFBQTBLLFNBQUEsUUFBQS9MLFNBQUEsR0FBQStMLFNBQUEsTUFBRy9MLFNBQVM7TUFFbkYsSUFBTWdNLFdBQVcsR0FBR1AsZUFBZSxDQUFDcEssTUFBTTtNQUUxQztNQUNBLElBQUssQ0FBQ3lLLFFBQVEsSUFBTSxDQUFDRSxXQUFZLEVBQUUsT0FBTyxLQUFLO01BRS9DLElBQU1DLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQUNELFdBQVcsRUFBRUYsUUFBUSxDQUFDO01BRTNDLElBQU1qQixjQUFjLEdBQUc3QyxLQUFJLENBQUNHLFVBQVUsQ0FBQ0csZ0JBQWdCO1FBQ25EQyxZQUFZLEdBQUdQLEtBQUksQ0FBQ0csVUFBVSxDQUFDSSxZQUFZO01BRS9DLElBQUtzQyxjQUFjLENBQUNQLElBQUksR0FBRy9CLFlBQVksQ0FBQytCLElBQUksSUFBSzJCLEdBQUcsRUFBRSxPQUFPLEtBQUs7TUFFbEU7TUFDQSxJQUFNRSxXQUFXLEdBQUcxSCxLQUFLLENBQUN1QixJQUFJLENBQUM2RSxjQUFjLENBQUMxSSxJQUFJLEVBQUUsQ0FBQztRQUNqRGlLLGFBQWEsR0FBRzNILEtBQUssQ0FBQ3VCLElBQUksQ0FBQ3VDLFlBQVksQ0FBQ3BHLElBQUksRUFBRSxDQUFDO01BRW5ELElBQU11SixPQUFPLE1BQUFXLE1BQUEsQ0FBT0YsV0FBVyxFQUFJQyxhQUFhLENBQUM7TUFFakRWLE9BQU8sQ0FBQ1gsSUFBSSxDQUFDLFVBQUNDLENBQUMsRUFBQ0MsQ0FBQztRQUFBLE9BQUtELENBQUMsR0FBR0MsQ0FBQztNQUFBLEVBQUM7TUFFNUI7TUFDQSxJQUFNcUIsU0FBUyxHQUFHWixPQUFPLENBQUNySyxNQUFNO1FBQzVCa0wsU0FBUyxHQUFHRCxTQUFTLEdBQUdMLEdBQUc7TUFFL0I7TUFDQSxJQUFNTyxTQUFTLEdBQUdmLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDaENnQixTQUFTLEdBQUdoQixlQUFlLENBQUNPLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDNUNVLE9BQU8sR0FBR2hCLE9BQU8sQ0FBQ2lCLE9BQU8sQ0FBQ0gsU0FBUyxDQUFDO1FBQ3BDSSxPQUFPLEdBQUdsQixPQUFPLENBQUNpQixPQUFPLENBQUNGLFNBQVMsQ0FBQztNQUV4QyxJQUFNSSxRQUFRLEdBQUdILE9BQU87UUFDcEJJLFFBQVEsR0FBR1IsU0FBUyxJQUFJTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDRyxRQUFRLEdBQUdGLFFBQVEsR0FBR0MsUUFBUTtNQUVsQyxJQUFNRSxhQUFhLEdBQUdkLElBQUksQ0FBQ2UsS0FBSyxDQUFFSixRQUFRLEdBQUNFLFFBQVEsR0FBRVIsU0FBUyxDQUFDO1FBQzNEVyxhQUFhLEdBQUdYLFNBQVMsR0FBR1MsYUFBYTtNQUU3QztNQUNBLElBQU1HLFFBQVEsR0FBR3pCLE9BQU8sQ0FBQy9JLEtBQUssQ0FBQyxDQUFDLEVBQUNxSyxhQUFhLENBQUM7UUFDM0NJLFFBQVEsR0FBRzFCLE9BQU8sQ0FBQy9JLEtBQUssQ0FBQzJKLFNBQVMsR0FBR1ksYUFBYSxDQUFDO01BRXZELElBQU1HLE9BQU8sTUFBQWhCLE1BQUEsQ0FBQTVHLGtCQUFBLENBQU8wSCxRQUFRLEdBQUExSCxrQkFBQSxDQUFJMkgsUUFBUSxFQUFDO01BRXpDcEYsS0FBSSxDQUFDdUQsWUFBWSxDQUFDOEIsT0FBTyxFQUFFMUMsa0JBQWtCLENBQUM7TUFFOUMsT0FBTyxJQUFJO0lBRWYsQ0FBQztJQUVELEtBQUEyQywwQkFBMEIsR0FBRyxVQUFDeEIsUUFBUSxFQUFFeUIsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFJO01BRTVFLElBQUksQ0FBQzFCLFFBQVEsRUFBRSxPQUFPLEtBQUs7TUFFM0IsSUFBQTJCLGdCQUFBLEdBR0l6RixLQUFJLENBQUNHLFVBQVU7UUFGZkcsZ0JBQWdCLEdBQUFtRixnQkFBQSxDQUFoQm5GLGdCQUFnQjtRQUNoQkMsWUFBWSxHQUFBa0YsZ0JBQUEsQ0FBWmxGLFlBQVk7TUFHaEIsSUFBTTBELEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQUNzQixnQkFBZ0IsRUFBRXpCLFFBQVEsQ0FBQztNQUVoRCxJQUFLeEQsZ0JBQWdCLENBQUNnQyxJQUFJLEdBQUcvQixZQUFZLENBQUMrQixJQUFJLElBQU8yQixHQUFHLEdBQUl1QixrQkFBbUIsRUFBRTtRQUU3RSxPQUFPLEtBQUs7T0FFZixNQUFNO1FBRUgsT0FBTyxJQUFJOztJQUluQixDQUFDO0lBOVVHLElBQUksQ0FBQ3JGLFVBQVUsQ0FBQ04sVUFBVSxHQUFHQSxVQUFVLEVBQUM7SUFDeEM7SUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBR0EsV0FBVyxFQUFDO0lBRS9CLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUdBLG9CQUFvQjtFQUNwRDtFQUFDbkIsWUFBQSxDQUFBZ0IsWUFBQTtJQUFBak0sR0FBQTtJQUFBRSxLQUFBLEVBMkZLLFNBQUE2UixzQkFBQSxFQUFxQjs7Ozs7O2NBRWYzRixvQkFBb0IsR0FBSyxJQUFJLENBQTdCQSxvQkFBb0I7Y0FFcEJVLG9CQUFvQixHQUFLLElBQUksQ0FBQ04sVUFBVSxDQUF4Q00sb0JBQW9CO2NBQ3RCSyxZQUFZLEdBQUssSUFBSSxDQUFDWCxVQUFVLENBQWhDVyxZQUFZO2NBQUEsTUFHZEEsWUFBWSxLQUFLLElBQUk7Z0JBQUE2RSxRQUFBLENBQUF2TixJQUFBO2dCQUFBO2NBQUE7Y0FFckI0SixpQkFBaUIsR0FBR3ZCLG9CQUFvQixDQUFDd0IsR0FBRyxDQUFDbkIsWUFBWSxDQUFDO2NBQUEsTUFFdERrQixpQkFBaUIsQ0FBQ1osUUFBUSxHQUFHckIsb0JBQW9CO2dCQUFBNEYsUUFBQSxDQUFBdk4sSUFBQTtnQkFBQTtjQUFBO2NBRWpENEosaUJBQWlCLENBQUNaLFFBQVEsSUFBSSxDQUFDO2NBQUEsT0FBQXVFLFFBQUEsQ0FBQTlOLE1BQUEsV0FDeEJpSixZQUFZO1lBQUE7Y0FNM0JBLFlBQVksR0FBRyxJQUFJO2NBQUE4RSxTQUFBLEdBQUFqSiwwQkFBQSxDQUM0QjhELG9CQUFvQjtjQUFBa0YsUUFBQSxDQUFBbEwsSUFBQTtjQUFBbUwsU0FBQSxDQUFBNUksQ0FBQTtZQUFBO2NBQUEsS0FBQTZJLEtBQUEsR0FBQUQsU0FBQSxDQUFBM0ksQ0FBQSxJQUFBbkYsSUFBQTtnQkFBQTZOLFFBQUEsQ0FBQXZOLElBQUE7Z0JBQUE7Y0FBQTtjQUFBME4sV0FBQSxHQUFBbkssY0FBQSxDQUFBa0ssS0FBQSxDQUFBaFMsS0FBQSxNQUF2RG9OLFdBQVcsR0FBQTZFLFdBQUEsS0FBRTlELGtCQUFpQixHQUFBOEQsV0FBQTtjQUFBLE1BRWxDOUQsa0JBQWlCLENBQUNaLFFBQVEsR0FBR3JCLG9CQUFvQjtnQkFBQTRGLFFBQUEsQ0FBQXZOLElBQUE7Z0JBQUE7Y0FBQTtjQUNqRDRKLGtCQUFpQixDQUFDWixRQUFRLElBQUksQ0FBQztjQUMvQk4sWUFBWSxHQUFHRyxXQUFXO2NBQUEsT0FBQTBFLFFBQUEsQ0FBQTlOLE1BQUE7WUFBQTtjQUFBOE4sUUFBQSxDQUFBdk4sSUFBQTtjQUFBO1lBQUE7Y0FBQXVOLFFBQUEsQ0FBQXZOLElBQUE7Y0FBQTtZQUFBO2NBQUF1TixRQUFBLENBQUFsTCxJQUFBO2NBQUFrTCxRQUFBLENBQUFJLEVBQUEsR0FBQUosUUFBQTtjQUFBQyxTQUFBLENBQUExSSxDQUFBLENBQUF5SSxRQUFBLENBQUFJLEVBQUE7WUFBQTtjQUFBSixRQUFBLENBQUFsTCxJQUFBO2NBQUFtTCxTQUFBLENBQUF4SSxDQUFBO2NBQUEsT0FBQXVJLFFBQUEsQ0FBQXBLLE1BQUE7WUFBQTtjQUFBLE1BTTlCdUYsWUFBWSxLQUFLLElBQUk7Z0JBQUE2RSxRQUFBLENBQUF2TixJQUFBO2dCQUFBO2NBQUE7Y0FBQXVOLFFBQUEsQ0FBQXZOLElBQUE7Y0FFTixPQUFNLElBQUksQ0FBQzRJLFlBQVksRUFBRTtZQUFBO2NBQXhDRixZQUFZLEdBQUE2RSxRQUFBLENBQUFqTyxJQUFBO2NBQ1pzSyxpQkFBaUIsR0FBR3ZCLG9CQUFvQixDQUFDd0IsR0FBRyxDQUFDbkIsWUFBWSxDQUFDO2NBQzFEa0IsaUJBQWlCLENBQUNaLFFBQVEsSUFBSSxDQUFDO1lBQUE7Y0FJbkMsSUFBSSxDQUFDakIsVUFBVSxDQUFDVyxZQUFZLEdBQUdBLFlBQVk7Y0FBQSxPQUFBNkUsUUFBQSxDQUFBOU4sTUFBQSxXQUVwQ2lKLFlBQVk7WUFBQTtZQUFBO2NBQUEsT0FBQTZFLFFBQUEsQ0FBQS9LLElBQUE7VUFBQTtRQUFBLEdBQUFvTCxPQUFBO01BQUEsQ0FFdEI7O0lBb01EO0VBQUE7SUFBQXJTLEdBQUE7SUFBQUUsS0FBQSxFQUVBLFNBQUFvUyxRQUFRQyxhQUFhLEVBQUVDLHNCQUFzQixFQUFFdEcsVUFBVTtNQUFBLElBQUF1RyxNQUFBO01BRXJELElBQVFDLGdCQUFnQixHQUFLLElBQUksQ0FBekJBLGdCQUFnQjtNQUV4QixJQUFRQyxxQkFBcUIsR0FBS0QsZ0JBQWdCLENBQTFDQyxxQkFBcUI7TUFFN0IsSUFBQUMscUJBQUEsR0FBeUNGLGdCQUFnQixDQUFDRyxXQUFXLENBQUMvRSxPQUFPO1FBQXJFZ0YsWUFBWSxHQUFBRixxQkFBQSxDQUFaRSxZQUFZO1FBQUVDLGNBQWMsR0FBQUgscUJBQUEsQ0FBZEcsY0FBYztRQUNoQ0MseUJBQXlCLEdBQUdOLGdCQUFnQixDQUFDTyw0QkFBNEIsQ0FBQ25GLE9BQU87UUFDakZvRix3QkFBd0IsR0FBR1IsZ0JBQWdCLENBQUNTLDJCQUEyQixDQUFDckYsT0FBTztNQUVuRixJQUFRc0YsT0FBTyxHQUFlSix5QkFBeUIsQ0FBL0NJLE9BQU87UUFBRWpELFFBQVEsR0FBSzZDLHlCQUF5QixDQUF0QzdDLFFBQVE7UUFDbkJrRCxRQUFRLEdBQUtILHdCQUF3QixDQUFyQ0csUUFBUTtNQUVkLElBQU1DLFFBQVEsR0FBRyxFQUFFO01BRW5CLElBQUlDLFNBQVMsR0FBR3BELFFBQVEsYUFBUkEsUUFBUSxjQUFSQSxRQUFRLEdBQUksQ0FBQztNQUU3Qm9ELFNBQVMsR0FBR2hELElBQUksQ0FBQ2lELEdBQUcsQ0FBQ0QsU0FBUyxFQUFFRixRQUFRLENBQUM7TUFFekMsSUFBTUksV0FBVyxHQUNiRixTQUFTLEdBQ0xBLFNBQVMsR0FDVEYsUUFBUTtNQUVoQixJQUFNSyxTQUFTLEdBQUc7UUFDZDVGLE9BQU8sRUFBQztPQUNYO01BRUQsSUFBTTZGLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBb0JBLENBQUloRSxLQUFLLEVBQUk7UUFDbkMrRCxTQUFTLENBQUM1RixPQUFPLEdBQUcsSUFBSTtRQUN4QjBFLHNCQUFzQixDQUFDN0MsS0FBSyxDQUFDO01BQ2pDLENBQUM7TUFFRCxJQUFJbUQsWUFBWSxDQUFDYyxZQUFZLENBQUM5RixPQUFPLEVBQUU7UUFFbkMsSUFBTW5CLGdCQUFnQixHQUFHLElBQUksQ0FBQ0gsVUFBVSxDQUFDRyxnQkFBZ0I7UUFFekQsSUFBQWtILHFCQUFBLEdBQXdEZCxjQUFjLENBQUNlLFNBQVM7VUFBeEVDLG9CQUFvQixHQUFBRixxQkFBQSxDQUFwQkUsb0JBQW9CO1VBQUVDLHFCQUFxQixHQUFBSCxxQkFBQSxDQUFyQkcscUJBQXFCO1FBRW5ELEtBQUssSUFBSXJFLEtBQUssR0FBRyxDQUFDLEVBQUVBLEtBQUssR0FBRzhELFdBQVcsRUFBRTlELEtBQUssRUFBRSxFQUFFO1VBRTlDb0Usb0JBQW9CLElBQUlBLG9CQUFvQixDQUFDcEUsS0FBSyxDQUFDO1VBQ25ELElBQUksQ0FBQ2hELGdCQUFnQixDQUFDc0gsR0FBRyxDQUFDdEUsS0FBSyxDQUFDLEVBQUU7WUFFOUIsSUFBTTVCLE9BQU8sR0FBRyxJQUFJLENBQUNtRyxXQUFXLENBQzVCdkUsS0FBSyxFQUNMeUQsT0FBTyxFQUNQVCxxQkFBcUIsRUFDckJxQixxQkFBcUIsRUFDckJMLG9CQUFvQixFQUNwQnpILFVBQVUsQ0FDYjtZQUNEb0gsUUFBUSxDQUFDbk8sSUFBSSxDQUFDNEksT0FBTyxDQUFDOztVQUkxQixJQUFJMkYsU0FBUyxDQUFDNUYsT0FBTyxFQUFFOzs7TUFJL0J4SCxPQUFPLENBQUM2TixVQUFVLENBQUNiLFFBQVEsQ0FBQyxDQUFDbFEsSUFBSSxDQUM3QixZQUFJO1FBQ0FxUCxNQUFJLENBQUMvRCxpQkFBaUIsRUFBRTtRQUN4QjZELGFBQWEsRUFBRTtNQUNuQixDQUFDLENBQ0o7SUFFTDtJQUVBO0VBQUE7SUFBQXZTLEdBQUE7SUFBQUUsS0FBQSxFQUVBLFNBQUFrVSxpQkFBQSxFQUFnQjtNQUVaLE9BQU8sSUFBSTFILEdBQUcsQ0FBQyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0csZ0JBQWdCLENBQUM7SUFFcEQ7RUFBQztJQUFBM00sR0FBQTtJQUFBRSxLQUFBLEVBRUQsU0FBQW1VLGtCQUFrQnZFLGVBQWU7TUFFdkIsSUFBQXdFLFNBQVMsR0FBRyxJQUFJNUgsR0FBRyxFQUFFO1FBQ3JCQyxnQkFBZ0IsR0FBSyxJQUFJLENBQUNILFVBQVUsQ0FBcENHLGdCQUFnQjtNQURLLElBQUE0SCxVQUFBLEdBQUF2TCwwQkFBQSxDQUdQOEcsZUFBZTtRQUFBMEUsTUFBQTtNQUFBO1FBQW5DLEtBQUFELFVBQUEsQ0FBQWxMLENBQUEsTUFBQW1MLE1BQUEsR0FBQUQsVUFBQSxDQUFBakwsQ0FBQSxJQUFBbkYsSUFBQSxHQUFxQztVQUFBLElBQTFCd0wsS0FBSyxHQUFBNkUsTUFBQSxDQUFBdFUsS0FBQTtVQUVab1UsU0FBUyxDQUFDL0csR0FBRyxDQUFDb0MsS0FBSyxFQUFFaEQsZ0JBQWdCLENBQUMyQixHQUFHLENBQUNxQixLQUFLLENBQUMsQ0FBQzs7TUFFcEQsU0FBQTlPLEdBQUE7UUFBQTBULFVBQUEsQ0FBQWhMLENBQUEsQ0FBQTFJLEdBQUE7TUFBQTtRQUFBMFQsVUFBQSxDQUFBOUssQ0FBQTtNQUFBO01BRUQsT0FBTzZLLFNBQVM7SUFFcEI7RUFBQztJQUFBdFUsR0FBQTtJQUFBRSxLQUFBLEVBRUQsU0FBQXVVLGdCQUFBLEVBQWU7TUFFWCxJQUFNQyxTQUFTLEdBQUcsSUFBSWhJLEdBQUcsRUFBRTtNQUFBLElBQUFpSSxVQUFBLEdBQUEzTCwwQkFBQSxDQUVBLElBQUksQ0FBQ3dELFVBQVUsQ0FBQ0MsV0FBVztRQUFBbUksTUFBQTtNQUFBO1FBQXRELEtBQUFELFVBQUEsQ0FBQXRMLENBQUEsTUFBQXVMLE1BQUEsR0FBQUQsVUFBQSxDQUFBckwsQ0FBQSxJQUFBbkYsSUFBQSxHQUF3RDtVQUFBLElBQUEwUSxZQUFBLEdBQUE3TSxjQUFBLENBQUE0TSxNQUFBLENBQUExVSxLQUFBO1lBQTVDRixHQUFHLEdBQUE2VSxZQUFBO1lBQUUzVSxLQUFLLEdBQUEyVSxZQUFBO1VBQ2xCLElBQ0lsRixLQUFLLEdBRUx6UCxLQUFLLENBRkx5UCxLQUFLO1lBQ0xtRixTQUFTLEdBQ1Q1VSxLQUFLLENBREw0VSxTQUFTO1VBR2JKLFNBQVMsQ0FBQ25ILEdBQUcsQ0FBQ3ZOLEdBQUcsRUFBQztZQUNkMlAsS0FBSyxFQUFMQSxLQUFLO1lBQ0xtRixTQUFTLEVBQVRBO1dBQ0gsQ0FBQzs7TUFFTCxTQUFBalUsR0FBQTtRQUFBOFQsVUFBQSxDQUFBcEwsQ0FBQSxDQUFBMUksR0FBQTtNQUFBO1FBQUE4VCxVQUFBLENBQUFsTCxDQUFBO01BQUE7TUFFRCxPQUFPaUwsU0FBUztJQUVwQjtJQUVBO0lBRUE7SUFFQTtFQUFBO0lBQUExVSxHQUFBO0lBQUFFLEtBQUEsRUFDQSxTQUFBNlUsVUFBVUMsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLGFBQWE7TUFFN0MsSUFBQUMsaUJBQUEsR0FBdUMsSUFBSSxDQUFDM0ksVUFBVTtRQUEvQ0csZ0JBQWdCLEdBQUF3SSxpQkFBQSxDQUFoQnhJLGdCQUFnQjtRQUFDRixXQUFXLEdBQUEwSSxpQkFBQSxDQUFYMUksV0FBVztNQUVuQztNQUVBLElBQU0ySSxhQUFhLEdBQUdGLGFBQWEsR0FBR0QsWUFBWSxHQUFHLENBQUM7UUFDbERJLGFBQWEsR0FBR0wsVUFBVSxHQUFHQyxZQUFZO1FBQ3pDSyxXQUFXLEdBQUdOLFVBQVUsSUFBSUksYUFBYSxHQUFHLENBQUMsQ0FBQztNQUVsRCxJQUFNRyxhQUFhLEdBQ2RGLGFBQWEsR0FBRyxDQUFDO01BQUc7TUFDakIsSUFBSTtNQUFFO01BQ04sTUFBTSxFQUFHO01BRWpCO01BRUEsSUFBTUcsZ0JBQWdCLEdBQUcxTSxLQUFLLENBQUN1QixJQUFJLENBQUNzQyxnQkFBZ0IsQ0FBQ25HLElBQUksRUFBRSxDQUFDLENBQUM0SSxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBR0QsQ0FBQyxHQUFDQyxDQUFDO01BQUEsRUFBQztNQUU3RSxJQUFNbUcsdUJBQXVCLEdBQUdELGdCQUFnQixDQUFDeE8sS0FBSyxFQUFFLENBQUNMLE9BQU8sRUFBRTtNQUVsRSxJQUFNK08sYUFBYSxHQUFHRixnQkFBZ0IsQ0FBQ0csU0FBUyxDQUFDLFVBQUF6VixLQUFLO1VBQUEsT0FBSUEsS0FBSyxJQUFJOFUsVUFBVTtRQUFBLEVBQUM7UUFDMUVZLGVBQWUsR0FBR0osZ0JBQWdCLENBQUNHLFNBQVMsQ0FBQyxVQUFBelYsS0FBSztVQUFBLE9BQUlBLEtBQUssSUFBSStVLFlBQVk7UUFBQSxFQUFDO01BRWhGLElBQUlZLGNBQWMsR0FBR0osdUJBQXVCLENBQUNFLFNBQVMsQ0FBQyxVQUFBelYsS0FBSztVQUFBLE9BQUlBLEtBQUssSUFBSW9WLFdBQVc7UUFBQSxFQUFDO1FBQ2pGUSxnQkFBZ0IsR0FBR0wsdUJBQXVCLENBQUNFLFNBQVMsQ0FBQyxVQUFBelYsS0FBSztVQUFBLE9BQUlBLEtBQUssSUFBSWdWLGFBQWE7UUFBQSxFQUFDO01BRXpGO01BQ0E7UUFDSSxJQUFNYSxjQUFjLEdBQUdQLGdCQUFnQixDQUFDOVAsTUFBTTtRQUM5QyxJQUFJbVEsY0FBYyxJQUFJLENBQUMsQ0FBQyxFQUFFQSxjQUFjLEdBQUlFLGNBQWMsR0FBRSxDQUFDLEdBQUlGLGNBQWM7UUFDL0UsSUFBSUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLEVBQUVBLGdCQUFnQixHQUFJQyxjQUFjLEdBQUUsQ0FBQyxHQUFJRCxnQkFBZ0I7O01BR3pGO01BRUEsSUFBSUUsb0JBQW9CO01BQ3hCLElBQUtKLGVBQWUsSUFBSSxDQUFDLENBQUMsSUFBTUUsZ0JBQWdCLElBQUksQ0FBQyxDQUFFLEVBQUU7UUFBRTtRQUV2REUsb0JBQW9CLEdBQUcsRUFBRTtPQUU1QixNQUFNLElBQUlGLGdCQUFnQixJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQUU7UUFFakNFLG9CQUFvQixHQUFHUixnQkFBZ0IsQ0FBQ3hPLEtBQUssQ0FBQzRPLGVBQWUsQ0FBQztPQUVqRSxNQUFNO1FBQUU7UUFFTEksb0JBQW9CLEdBQUdSLGdCQUFnQixDQUFDeE8sS0FBSyxDQUFDNE8sZUFBZSxFQUFFRSxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7O01BSXhGLElBQU1HLGdCQUFnQixHQUFHLElBQUl2SixHQUFHLEVBQUU7TUFDbEMsSUFBTXdKLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBa0JBLENBQUl2RyxLQUFLLEVBQUk7UUFFakNzRyxnQkFBZ0IsQ0FBQzFJLEdBQUcsQ0FBQ29DLEtBQUssRUFBRWhELGdCQUFnQixDQUFDMkIsR0FBRyxDQUFDcUIsS0FBSyxDQUFDLENBQUM7TUFFNUQsQ0FBQztNQUVEcUcsb0JBQW9CLENBQUN2VCxPQUFPLENBQUN5VCxrQkFBa0IsQ0FBQztNQUVoRDtNQUVBLElBQUlDLHdCQUF3QjtNQUM1QixJQUFJWixhQUFhLElBQUksTUFBTSxFQUFFO1FBQUU7UUFFM0IsSUFBS0csYUFBYSxJQUFJLENBQUMsQ0FBQyxJQUFNRSxlQUFlLElBQUksQ0FBQyxDQUFFLEVBQUU7VUFFbERPLHdCQUF3QixHQUFHLEVBQUU7U0FFaEMsTUFBTSxJQUFJUCxlQUFlLElBQUksQ0FBQyxDQUFDLEVBQUU7VUFFOUJPLHdCQUF3QixHQUFHWCxnQkFBZ0IsQ0FBQ3hPLEtBQUssQ0FBQzBPLGFBQWEsQ0FBQztTQUVuRSxNQUFNO1VBRUhTLHdCQUF3QixHQUFHWCxnQkFBZ0IsQ0FBQ3hPLEtBQUssQ0FBQzBPLGFBQWEsRUFBRUUsZUFBZSxDQUFDOztPQUl4RixNQUFNO1FBQUU7UUFFTCxJQUFJQyxjQUFjLElBQUksQ0FBQyxDQUFDLElBQUlDLGdCQUFnQixJQUFJLENBQUMsQ0FBQyxFQUFFO1VBRWhESyx3QkFBd0IsR0FBRyxFQUFFO1NBRWhDLE1BQU0sSUFBSU4sY0FBYyxJQUFJLENBQUMsQ0FBQyxFQUFFO1VBRTdCTSx3QkFBd0IsR0FBR1gsZ0JBQWdCLENBQUN4TyxLQUFLLENBQUM4TyxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7U0FFMUUsTUFBTTtVQUVISyx3QkFBd0IsR0FBR1gsZ0JBQWdCLENBQUN4TyxLQUFLLENBQUM4TyxnQkFBZ0IsR0FBRyxDQUFDLEVBQUVELGNBQWMsR0FBRyxDQUFDLENBQUM7OztNQUtuRyxJQUFJTixhQUFhLElBQUksTUFBTSxFQUFFWSx3QkFBd0IsQ0FBQ3hQLE9BQU8sRUFBRTtNQUUvRDtNQUVBLElBQU15UCxxQkFBcUIsR0FBRyxFQUFFO01BRWhDLElBQU1DLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBdUJBLENBQUkxRyxLQUFLLEVBQUk7UUFFdEMsSUFBTXhCLE1BQU0sR0FBR3hCLGdCQUFnQixDQUFDMkIsR0FBRyxDQUFDcUIsS0FBSyxDQUFDO1FBRTFDLElBQU0yRyxRQUFRLEdBQ1RmLGFBQWEsSUFBSSxJQUFJLEdBQ2xCNUYsS0FBSyxHQUFHeUYsYUFBYSxHQUNyQnpGLEtBQUssR0FBR3lGLGFBQWE7UUFFN0J6SSxnQkFBZ0IsQ0FBQ1ksR0FBRyxDQUFDK0ksUUFBUSxFQUFDbkksTUFBTSxDQUFDO1FBQ3JDMUIsV0FBVyxDQUFDNkIsR0FBRyxDQUFDSCxNQUFNLENBQUMsQ0FBQ3dCLEtBQUssR0FBRzJHLFFBQVE7UUFDeENGLHFCQUFxQixDQUFDalIsSUFBSSxDQUFDbVIsUUFBUSxDQUFDO01BRXhDLENBQUM7TUFFREgsd0JBQXdCLENBQUMxVCxPQUFPLENBQUM0VCx1QkFBdUIsQ0FBQztNQUV6RDtNQUVBLElBQU1FLGlCQUFpQixHQUFHLEVBQUU7TUFDNUIsSUFBTUMsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFrQkEsQ0FBSXJJLE1BQU0sRUFBRXdCLEtBQUssRUFBSTtRQUN6QyxJQUFNMkcsUUFBUSxHQUFHM0csS0FBSyxHQUFHMEYsYUFBYSxFQUFDO1FBRXZDMUksZ0JBQWdCLENBQUNZLEdBQUcsQ0FBQytJLFFBQVEsRUFBRW5JLE1BQU0sQ0FBQztRQUN0QzFCLFdBQVcsQ0FBQzZCLEdBQUcsQ0FBQ0gsTUFBTSxDQUFDLENBQUN3QixLQUFLLEdBQUcyRyxRQUFRO1FBQ3hDQyxpQkFBaUIsQ0FBQ3BSLElBQUksQ0FBQ21SLFFBQVEsQ0FBQztNQUVwQyxDQUFDO01BRURMLGdCQUFnQixDQUFDeFQsT0FBTyxDQUFDK1Qsa0JBQWtCLENBQUM7TUFFNUM7TUFDQTtNQUVBLElBQU1DLGdCQUFnQixHQUFHLEdBQUEvRixNQUFBLENBQUkwRixxQkFBcUIsRUFBSUcsaUJBQWlCLEVBQUVuSCxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBR0QsQ0FBQyxHQUFDQyxDQUFDO01BQUEsRUFBQztNQUV6RixPQUFPbUgsZ0JBQWdCO0lBRTNCO0lBRUE7SUFFQTtFQUFBO0lBQUF6VyxHQUFBO0lBQUFFLEtBQUEsRUFDQSxTQUFBd1csa0JBQWtCL0csS0FBSyxFQUFFZ0gsU0FBUyxFQUFFQyxTQUFTLEVBQUV2RCxRQUFRO01BRW5EO01BQ0EsSUFBTXdELFdBQVcsR0FBSUQsU0FBUyxJQUFJLENBQUU7TUFDcEMsSUFBTUUsVUFBVSxHQUFJRixTQUFTLElBQUksQ0FBQyxDQUFFO01BRXBDLElBQU1HLFdBQVcsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUM7TUFFL0M7TUFDQSxJQUFBQyxpQkFBQSxHQUEwQyxJQUFJLENBQUN4SyxVQUFVO1FBQWpERyxnQkFBZ0IsR0FBQXFLLGlCQUFBLENBQWhCckssZ0JBQWdCO1FBQUVGLFdBQVcsR0FBQXVLLGlCQUFBLENBQVh2SyxXQUFXO01BQ3JDLElBQU13SyxxQkFBcUIsR0FBR25PLEtBQUssQ0FBQ3VCLElBQUksQ0FBQ3NDLGdCQUFnQixDQUFDbkcsSUFBSSxFQUFFLENBQUMsQ0FBQzRJLElBQUksQ0FBQyxVQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBQSxPQUFHRCxDQUFDLEdBQUNDLENBQUM7TUFBQSxFQUFDLEVBQUM7TUFFbkY7TUFFQTtNQUNBLElBQUk0SCxjQUFjLEdBQUdQLFNBQVM7TUFDOUIsSUFBSVEsYUFBYSxHQUFHeEgsS0FBSyxFQUFDO01BRTFCLElBQUltSCxVQUFVLEVBQUU7UUFFWjtRQUNBLElBQUlJLGNBQWMsR0FBSTdELFFBQVEsR0FBRyxDQUFFLEVBQUU7VUFFakM2RCxjQUFjLEdBQUk3RCxRQUFRLEdBQUcsQ0FBRTtVQUMvQixJQUFJNkQsY0FBYyxHQUFHQyxhQUFhLEVBQUUsT0FBT0osV0FBVzs7T0FJN0QsTUFBTTtRQUFFO1FBRUw7UUFDQSxJQUFJSSxhQUFhLEdBQUc5RCxRQUFRLEVBQUU7VUFFMUIsSUFBTStELElBQUksR0FBR0QsYUFBYSxHQUFHOUQsUUFBUTtVQUNyQzhELGFBQWEsSUFBSUMsSUFBSTtVQUNyQkYsY0FBYyxJQUFJRSxJQUFJO1VBRXRCOzs7TUFNUjtNQUNBLElBQU1DLFVBQVUsR0FBR0gsY0FBYyxHQUFHQyxhQUFhLEdBQUcsQ0FBQztNQUVyRDtNQUNBLElBQU1HLGNBQWMsR0FBR0QsVUFBVSxHQUFHVCxTQUFTO01BQzdDLElBQU1XLGdCQUFnQixHQUNqQlgsU0FBUyxJQUFJLENBQUMsR0FDWE8sYUFBYSxHQUNiRCxjQUFjLElBQUlJLGNBQWMsR0FBRyxDQUFDLENBQUM7TUFFN0MsSUFBSUUsaUJBQWlCLEVBQUM7TUFDdEIsSUFBSVgsV0FBVyxFQUFFO1FBQ2JXLGlCQUFpQixHQUFHTCxhQUFhO09BQ3BDLE1BQU07UUFBRTtRQUNMSyxpQkFBaUIsR0FBR04sY0FBYyxHQUFHLENBQUM7O01BRzFDO01BRUE7TUFDQSxJQUFNTyxvQkFBb0IsR0FBR1IscUJBQXFCLENBQUN0QixTQUFTLENBQUMsVUFBQXpWLEtBQUssRUFBRztRQUVqRSxPQUFRQSxLQUFLLElBQUlzWCxpQkFBaUI7TUFFdEMsQ0FBQyxDQUFDO01BRUY7TUFDQSxJQUFNRSxnQkFBZ0IsR0FBR1QscUJBQXFCLENBQUN0QixTQUFTLENBQUMsVUFBQXpWLEtBQUssRUFBRztRQUU3RCxPQUFRQSxLQUFLLElBQUlpWCxhQUFhLElBQU1qWCxLQUFLLElBQUlnWCxjQUFlO01BRWhFLENBQUMsQ0FBQztNQUVGO01BQ0EsSUFBTVMscUJBQXFCLEdBQUc3TyxLQUFLLENBQUN1QixJQUFJLENBQUM0TSxxQkFBcUIsQ0FBQyxDQUFDdFEsT0FBTyxFQUFFO01BQ3pFLElBQUlpUixpQkFBaUIsR0FBR0QscUJBQXFCLENBQUNoQyxTQUFTLENBQUMsVUFBQXpWLEtBQUssRUFBRTtRQUUzRCxPQUFRQSxLQUFLLElBQUlnWCxjQUFjLElBQU1oWCxLQUFLLElBQUlpWCxhQUFjO01BRWhFLENBQUMsQ0FBQztNQUNGO01BQ0EsSUFBSVMsaUJBQWlCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFFekJBLGlCQUFpQixHQUFJWCxxQkFBcUIsQ0FBQ3ZSLE1BQU0sR0FBRyxDQUFDLEdBQUlrUyxpQkFBaUI7UUFDMUUsSUFBSUEsaUJBQWlCLEdBQUdGLGdCQUFnQixFQUFFRSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7O01BSXBFO01BRUE7TUFDQSxJQUFJQyxxQkFBcUI7UUFBRTtRQUN2QkMsdUJBQXVCLEVBQUM7TUFFNUI7TUFDQSxJQUFJSixnQkFBZ0IsSUFBSSxDQUFDLENBQUMsRUFBRTtRQUFFO1FBRTFCRyxxQkFBcUIsR0FBRyxFQUFFO1FBQzFCQyx1QkFBdUIsR0FBRyxFQUFFO09BRS9CLE1BQU0sSUFBSUYsaUJBQWlCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUVsQztRQUNBQyxxQkFBcUIsR0FBR1oscUJBQXFCLENBQUNqUSxLQUFLLENBQUMwUSxnQkFBZ0IsQ0FBQztRQUVyRSxJQUFJYixXQUFXLEVBQUU7VUFFYmlCLHVCQUF1QixHQUFHRCxxQkFBcUIsQ0FBQzdRLEtBQUssRUFBRTtTQUUxRCxNQUFNO1VBRUgsSUFBSXlRLG9CQUFvQixJQUFJLENBQUMsQ0FBQyxFQUFFO1lBRTVCSyx1QkFBdUIsR0FBRyxFQUFFO1dBRS9CLE1BQU07WUFFSEEsdUJBQXVCLEdBQUdiLHFCQUFxQixDQUFDalEsS0FBSyxDQUFDeVEsb0JBQW9CLENBQUM7OztPQU10RixNQUFNO1FBQUU7UUFFTEkscUJBQXFCLEdBQUdaLHFCQUFxQixDQUFDalEsS0FBSyxDQUFDMFEsZ0JBQWdCLEVBQUVFLGlCQUFpQixHQUFHLENBQUMsQ0FBQztRQUU1RixJQUFJZixXQUFXLEVBQUU7VUFFYmlCLHVCQUF1QixHQUFHYixxQkFBcUIsQ0FBQ2pRLEtBQUssQ0FBQ3lRLG9CQUFvQixDQUFDO1NBRTlFLE1BQU07VUFFSCxJQUFJQSxvQkFBb0IsSUFBSSxDQUFDLENBQUMsRUFBRTtZQUU1QkssdUJBQXVCLEdBQUcsRUFBRTtXQUUvQixNQUFNO1lBRUhBLHVCQUF1QixHQUFHYixxQkFBcUIsQ0FBQ2pRLEtBQUssQ0FBQ3lRLG9CQUFvQixDQUFDOzs7O01BUXZGO01BRUE7TUFDQTtNQUNBLElBQUlNLHlCQUF5QixHQUFHLEVBQUU7UUFBRTtRQUNoQ0Msd0JBQXdCLEdBQUcsRUFBRTtRQUFFO1FBQy9CQyxzQkFBc0IsR0FBRyxFQUFFLEVBQUM7TUFFaEMsSUFBSXBCLFdBQVcsRUFBRTtRQUVia0IseUJBQXlCLEdBQUdGLHFCQUFxQjtPQUVwRCxNQUFNO1FBQUU7UUFFTEcsd0JBQXdCLEdBQUdILHFCQUFxQjtRQUVoRDtRQUFBLElBQUFLLFVBQUEsR0FBQWxQLDBCQUFBLENBQ29CZ1Asd0JBQXdCO1VBQUFHLE1BQUE7UUFBQTtVQUE1QyxLQUFBRCxVQUFBLENBQUE3TyxDQUFBLE1BQUE4TyxNQUFBLEdBQUFELFVBQUEsQ0FBQTVPLENBQUEsSUFBQW5GLElBQUEsR0FBOEM7WUFBQSxJQUFuQ3dMLE1BQUssR0FBQXdJLE1BQUEsQ0FBQWpZLEtBQUE7WUFFWitYLHNCQUFzQixDQUFDOVMsSUFBSSxDQUFDd0gsZ0JBQWdCLENBQUMyQixHQUFHLENBQUNxQixNQUFLLENBQUMsQ0FBQztZQUN4RGhELGdCQUFnQixVQUFPLENBQUNnRCxNQUFLLENBQUM7O1FBRWpDLFNBQUE5TyxHQUFBO1VBQUFxWCxVQUFBLENBQUEzTyxDQUFBLENBQUExSSxHQUFBO1FBQUE7VUFBQXFYLFVBQUEsQ0FBQXpPLENBQUE7UUFBQTs7TUFJTDtNQUVBO01BQ0EsSUFBSW9OLFdBQVcsRUFBRWlCLHVCQUF1QixDQUFDblIsT0FBTyxFQUFFO01BRWxELElBQU15Uix1QkFBdUIsR0FBRyxFQUFFLEVBQUM7TUFDbkMsSUFBTUMsMEJBQTBCLEdBQUcsSUFBSXhMLEdBQUcsRUFBRSxFQUFDO01BRTdDO01BQ0EsSUFBTXlMLGNBQWMsR0FBRyxTQUFqQkEsY0FBY0EsQ0FBRzNJLEtBQUssRUFBRztRQUUzQixJQUFNeEIsTUFBTSxHQUFHeEIsZ0JBQWdCLENBQUMyQixHQUFHLENBQUNxQixLQUFLLENBQUM7UUFDMUMsSUFBTTJHLFFBQVEsR0FBRzNHLEtBQUssR0FBRzJILGNBQWM7UUFFdkMsSUFBSVIsVUFBVSxFQUFFO1VBQ1p1QiwwQkFBMEIsQ0FBQzlKLEdBQUcsQ0FBQ29CLEtBQUssQ0FBQztVQUNyQzBJLDBCQUEwQixVQUFPLENBQUMvQixRQUFRLENBQUM7O1FBRy9DM0osZ0JBQWdCLENBQUNZLEdBQUcsQ0FBQytJLFFBQVEsRUFBRW5JLE1BQU0sQ0FBQztRQUN0QzFCLFdBQVcsQ0FBQzZCLEdBQUcsQ0FBQ0gsTUFBTSxDQUFDLENBQUN3QixLQUFLLEdBQUcyRyxRQUFRO1FBQ3hDOEIsdUJBQXVCLENBQUNqVCxJQUFJLENBQUNtUixRQUFRLENBQUM7TUFFMUMsQ0FBQztNQUVEO01BQ0F3Qix1QkFBdUIsQ0FBQ3JWLE9BQU8sQ0FBQzZWLGNBQWMsQ0FBQztNQUUvQztNQUVBLElBQU1DLGlDQUFpQyxHQUFHLEVBQUUsRUFBQztNQUM3QyxJQUFJQyx1QkFBdUIsR0FBRyxFQUFFO01BRWhDLElBQUkzQixXQUFXLEVBQUU7UUFBQSxJQUFBNEIsVUFBQSxHQUFBelAsMEJBQUEsQ0FFTytPLHlCQUF5QjtVQUFBVyxNQUFBO1FBQUE7VUFBN0MsS0FBQUQsVUFBQSxDQUFBcFAsQ0FBQSxNQUFBcVAsTUFBQSxHQUFBRCxVQUFBLENBQUFuUCxDQUFBLElBQUFuRixJQUFBLEdBQStDO1lBQUEsSUFBcEN3TCxPQUFLLEdBQUErSSxNQUFBLENBQUF4WSxLQUFBO1lBRVp5TSxnQkFBZ0IsVUFBTyxDQUFDZ0QsT0FBSyxDQUFDOztRQUVqQyxTQUFBOU8sR0FBQTtVQUFBNFgsVUFBQSxDQUFBbFAsQ0FBQSxDQUFBMUksR0FBQTtRQUFBO1VBQUE0WCxVQUFBLENBQUFoUCxDQUFBO1FBQUE7T0FFSixNQUFNO1FBQUU7UUFBQSxJQUFBa1AsVUFBQSxHQUFBM1AsMEJBQUEsQ0FFZ0JpUCxzQkFBc0I7VUFBQVcsTUFBQTtRQUFBO1VBQTNDLEtBQUFELFVBQUEsQ0FBQXRQLENBQUEsTUFBQXVQLE1BQUEsR0FBQUQsVUFBQSxDQUFBclAsQ0FBQSxJQUFBbkYsSUFBQSxHQUE2QztZQUFBLElBQWxDZ0ssTUFBTSxHQUFBeUssTUFBQSxDQUFBMVksS0FBQTtZQUViLElBQUEyWSxnQkFBQSxHQUF3QnBNLFdBQVcsQ0FBQzZCLEdBQUcsQ0FBQ0gsTUFBTSxDQUFDO2NBQXZDYixXQUFXLEdBQUF1TCxnQkFBQSxDQUFYdkwsV0FBVztZQUNuQmlMLGlDQUFpQyxDQUFDcFQsSUFBSSxDQUFDO2NBQUNnSixNQUFNLEVBQU5BLE1BQU07Y0FBRWIsV0FBVyxFQUFYQTtZQUFXLENBQUMsQ0FBQztZQUM3RGIsV0FBVyxVQUFPLENBQUMwQixNQUFNLENBQUM7O1VBSTlCO1FBQUEsU0FBQXROLEdBQUE7VUFBQThYLFVBQUEsQ0FBQXBQLENBQUEsQ0FBQTFJLEdBQUE7UUFBQTtVQUFBOFgsVUFBQSxDQUFBbFAsQ0FBQTtRQUFBO1FBQ0EsSUFBTXFQLDhCQUE4QixHQUFHaFEsS0FBSyxDQUFDdUIsSUFBSSxDQUFDZ08sMEJBQTBCLENBQUM7UUFFN0UsU0FBQVUsR0FBQSxNQUFBQyxxQkFBQSxHQUFvQkYsOEJBQThCLEVBQUFDLEdBQUEsR0FBQUMscUJBQUEsQ0FBQXRULE1BQUEsRUFBQXFULEdBQUEsSUFBRTtVQUEvQyxJQUFNcEosT0FBSyxHQUFBcUoscUJBQUEsQ0FBQUQsR0FBQTtVQUVacE0sZ0JBQWdCLFVBQU8sQ0FBQ2dELE9BQUssQ0FBQzs7UUFJbEM2SSx1QkFBdUIsR0FBR1Isd0JBQXdCLENBQUN0SCxNQUFNLENBQUNvSSw4QkFBOEIsQ0FBQzs7TUFJN0YsSUFBSWpDLFdBQVcsRUFBRXVCLHVCQUF1QixDQUFDelIsT0FBTyxFQUFFLEVBQUM7TUFFbkQ7TUFFQTtNQUNBLE9BQU8sQ0FBQzRRLGdCQUFnQixFQUFFRCxjQUFjLEVBQUVjLHVCQUF1QixFQUFFSSx1QkFBdUIsRUFBRVQseUJBQXlCLEVBQUVRLGlDQUFpQyxDQUFDO0lBRTdKO0lBRUE7SUFFQTtJQUNBO0VBQUE7SUFBQXZZLEdBQUE7SUFBQUUsS0FBQSxFQUNBLFNBQUErWSxzQkFBc0J0SixLQUFLO01BRXZCLElBQUksQ0FBQ25ELFVBQVUsQ0FBQ0ksWUFBWSxDQUFDMkIsR0FBRyxDQUFDb0IsS0FBSyxDQUFDO0lBRTNDO0VBQUM7SUFBQTNQLEdBQUE7SUFBQUUsS0FBQSxFQUVELFNBQUFnWix3QkFBd0J2SixLQUFLO01BRXpCLElBQUksQ0FBQ25ELFVBQVUsQ0FBQ0ksWUFBWSxVQUFPLENBQUMrQyxLQUFLLENBQUM7SUFFOUM7RUFBQztJQUFBM1AsR0FBQTtJQUFBRSxLQUFBLEVBRUQsU0FBQWlaLGFBQUEsRUFBWTtNQUVSLE9BQU8sSUFBSSxDQUFDN00sWUFBWSxFQUFFO0lBRTlCO0lBRUE7RUFBQTtJQUFBdE0sR0FBQTtJQUFBRSxLQUFBLEVBQ0EsU0FBQWtaLHVCQUF1QnpKLEtBQUs7TUFFeEIsSUFBUWhELGdCQUFnQixHQUFLLElBQUksQ0FBQ0gsVUFBVSxDQUFwQ0csZ0JBQWdCO01BRXhCLElBQU13QixNQUFNLEdBQ1B4QixnQkFBZ0IsQ0FBQ3NILEdBQUcsQ0FBQ3RFLEtBQUssQ0FBQyxHQUN4QmhELGdCQUFnQixDQUFDMkIsR0FBRyxDQUFDcUIsS0FBSyxDQUFDLEdBQzFCLElBQUksQ0FBQ3dKLFlBQVksRUFBRztNQUU3QixPQUFPaEwsTUFBTTtJQUVqQjtJQUVDO0VBQUE7SUFBQW5PLEdBQUE7SUFBQUUsS0FBQSxFQUNLLFNBQUFtWixhQUFhdkUsU0FBUyxFQUFFbkYsS0FBSyxFQUFFeEIsTUFBTSxFQUFFbUwsa0JBQWtCLEVBQW1CO01BQUEsSUFBakJDLFNBQVMsR0FBQW5KLFNBQUEsQ0FBQTFLLE1BQUEsUUFBQTBLLFNBQUEsUUFBQS9MLFNBQUEsR0FBQStMLFNBQUEsTUFBRyxLQUFLOzs7Ozs7Y0FFOUUsSUFBSSxDQUFDOEksdUJBQXVCLENBQUN2SixLQUFLLENBQUM7Y0FBQTZKLHFCQUFBLEdBRy9CLElBQUksQ0FBQzlHLGdCQUFnQixDQUFDTyw0QkFBNEIsQ0FBQ25GLE9BQU8sRUFEdEQyTCxNQUFNLEdBQUFELHFCQUFBLENBQU5DLE1BQU0sRUFBRUMsVUFBVSxHQUFBRixxQkFBQSxDQUFWRSxVQUFVLEVBQUVDLFNBQVMsR0FBQUgscUJBQUEsQ0FBVEcsU0FBUyxFQUFFQyxXQUFXLEdBQUFKLHFCQUFBLENBQVhJLFdBQVc7Y0FHNUNDLFVBQVUsR0FBR0MsZ0JBQWdCLENBQUNuSyxLQUFLLEVBQUV4QixNQUFNLENBQUM7Y0FBQTRMLFNBQUEsQ0FBQXRWLElBQUE7Y0FFOUIsT0FBTSxJQUFJLENBQUNzTixxQkFBcUIsRUFBRTtZQUFBO2NBQWhEekUsV0FBVyxHQUFBeU0sU0FBQSxDQUFBaFcsSUFBQTtjQUVYcUssTUFBTSxHQUNSeEMsT0FBQSxZQUFBcUMsYUFBQTtnQkFBQSxhQUFpQixlQUFlO2dCQUFDak8sR0FBRyxFQUFJbU8sTUFBTTtnQkFBQSxlQUFpQkEsTUFBTTtnQkFBQSxjQUFnQndCO2NBQUssR0FDdEYvRCxPQUFBLFlBQUFxQyxhQUFBLENBQUNsQyxzQkFBQSxDQUFBaU8sUUFBUTtnQkFBQ2hhLEdBQUcsRUFBSW1PLE1BQU07Z0JBQUU4TCxJQUFJLEVBQUlKO2NBQVUsRyxLQUFNL0UsU0FBUyxFLElBQWMsQ0FDdEU7Y0FFVixJQUFJLENBQUM1RyxrQkFBa0IsQ0FBQ1osV0FBVyxFQUFFYSxNQUFNLEVBQUVDLE1BQU0sQ0FBQztjQUU5QzhMLGNBQWMsR0FBRztnQkFDbkJMLFVBQVUsRUFBVkEsVUFBVTtnQkFDVmxLLEtBQUssRUFBTEEsS0FBSztnQkFDTHhCLE1BQU0sRUFBTkEsTUFBTTtnQkFDTm1MLGtCQUFrQixFQUFsQkEsa0JBQWtCO2dCQUNsQnhFLFNBQVMsRUFBVEEsU0FBUztnQkFDVHhILFdBQVcsRUFBWEE7ZUFDSDtjQUVELElBQUksQ0FBQ2QsVUFBVSxDQUFDQyxXQUFXLENBQUNjLEdBQUcsQ0FBQ1ksTUFBTSxFQUFFK0wsY0FBYyxDQUFDO2NBQ3ZELElBQUksQ0FBQzFOLFVBQVUsQ0FBQ0csZ0JBQWdCLENBQUNZLEdBQUcsQ0FBQ29DLEtBQUssRUFBRXhCLE1BQU0sQ0FBQztjQUVuRCxJQUFJLENBQUNvTCxTQUFTLEVBQUUsSUFBSSxDQUFDN0ssaUJBQWlCLEVBQUU7Y0FBQSxPQUFBcUwsU0FBQSxDQUFBN1YsTUFBQSxXQUVqQ2dXLGNBQWM7WUFBQTtZQUFBO2NBQUEsT0FBQUgsU0FBQSxDQUFBOVMsSUFBQTtVQUFBO1FBQUEsR0FBQWtULFFBQUE7TUFBQSxDQUV4Qjs7SUFFRDtFQUFBO0lBQUFuYSxHQUFBO0lBQUFFLEtBQUEsRUFDYyxTQUFBZ1UsWUFDVnZFLEtBQUssRUFDTHlELE9BQU8sRUFDUFQscUJBQXFCLEVBQ3JCcUIscUJBQXFCLEVBQ3JCTCxvQkFBb0IsRUFDcEJ6SCxVQUFVOzs7Ozs7Y0FHSmlDLE1BQU0sR0FBRyxJQUFJLENBQUNnTCxZQUFZLEVBQUU7Y0FBQWlCLFNBQUEsQ0FBQXRULElBQUE7Y0FBQXNULFNBQUEsQ0FBQTNWLElBQUE7Y0FNaEIsT0FBTTJPLE9BQU8sQ0FBQ3pELEtBQUssRUFBRXhCLE1BQU0sQ0FBQztZQUFBO2NBQTFDa00sV0FBVyxHQUFBRCxTQUFBLENBQUFyVyxJQUFBO2NBQ1gsSUFBSXNXLFdBQVcsS0FBSyxJQUFJLEVBQUVDLFdBQVcsR0FBR0QsV0FBVztjQUFBRCxTQUFBLENBQUEzVixJQUFBO2NBQUE7WUFBQTtjQUFBMlYsU0FBQSxDQUFBdFQsSUFBQTtjQUFBc1QsU0FBQSxDQUFBaEksRUFBQSxHQUFBZ0ksU0FBQTtjQUluREUsV0FBVyxHQUFHRCxXQUFXLEdBQUdoVyxTQUFTO2NBQ3JDZixLQUFLLEdBQUE4VyxTQUFBLENBQUFoSSxFQUFJO1lBQUE7Y0FJYixJQUFLaUksV0FBVyxLQUFLLElBQUksSUFBTUEsV0FBVyxLQUFLaFcsU0FBVSxFQUFFO2dCQUV2RCxJQUFJLENBQUN1SCxPQUFBLFdBQUssQ0FBQzJPLGNBQWMsQ0FBQ0YsV0FBVyxDQUFDLEVBQUU7a0JBQ3BDQyxXQUFXLEdBQUdELFdBQVc7a0JBQ3pCQSxXQUFXLEdBQUdoVyxTQUFTO2tCQUN2QmYsS0FBSyxHQUFHLElBQUlJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQzs7O2NBR2pELE1BRUkyVyxXQUFXLEtBQUssSUFBSSxJQUFNQSxXQUFXLEtBQUtoVyxTQUFVO2dCQUFBK1YsU0FBQSxDQUFBM1YsSUFBQTtnQkFBQTtjQUFBO2NBRy9DNlUsa0JBQWtCLEdBQUc7Z0JBQ3ZCM0cscUJBQXFCLEVBQXJCQTtlQUNIO2NBQ0QsSUFBSTBILFdBQVcsQ0FBQ3ZQLEtBQUssQ0FBQ2hMLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO2dCQUN4RDBhLE9BQU8sR0FBRzVPLE9BQUEsV0FBSyxDQUFDNk8sWUFBWSxDQUFDSixXQUFXLEVBQUU7a0JBQUNmLGtCQUFrQixFQUFsQkE7Z0JBQWtCLENBQUMsQ0FBQztlQUNsRSxNQUFNO2dCQUNIa0IsT0FBTyxHQUFHSCxXQUFXOztjQUd6QjtjQUFBRCxTQUFBLENBQUEzVixJQUFBO2NBQ0ksT0FBTSxJQUFJLENBQUM0VSxZQUFZLENBQUNtQixPQUFPLEVBQUU3SyxLQUFLLEVBQUV4QixNQUFNLEVBQUVtTCxrQkFBa0IsRUFBRSxJQUFJLENBQUM7WUFBQTtjQUFBYyxTQUFBLENBQUEzVixJQUFBO2NBQUE7WUFBQTtjQUk3RSxJQUFJNFYsV0FBVyxLQUFLaFcsU0FBUyxFQUFFO2dCQUUzQjJQLHFCQUFxQixJQUNqQkEscUJBQXFCLENBQUNyRSxLQUFLLEVBQUV4QixNQUFNLEVBQUVtTSxXQUFXLEVBQUUsU0FBUyxFQUFFaFgsS0FBSyxDQUFDO2VBRTFFLE1BQU07Z0JBQUU7Z0JBRUwwUSxxQkFBcUIsSUFDakJBLHFCQUFxQixDQUFDckUsS0FBSyxFQUFFeEIsTUFBTSxFQUFFbU0sV0FBVyxFQUFFLFNBQVMsRUFBRSxJQUFJNVcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUUxRmlRLG9CQUFvQixDQUFDaEUsS0FBSyxDQUFDOztZQUU5QjtZQUFBO2NBQUEsT0FBQXlLLFNBQUEsQ0FBQW5ULElBQUE7VUFBQTtRQUFBLEdBQUF5VCxRQUFBO01BQUEsQ0FJUjs7SUFFRDtJQUNBO0VBQUE7SUFBQTFhLEdBQUE7SUFBQUUsS0FBQSxFQUNBLFNBQUEwUCxhQUFhRCxLQUFLLEVBQUVYLGtCQUFrQjtNQUVsQyxJQUFNMkwsVUFBVSxHQUNYLENBQUM3UixLQUFLLENBQUNDLE9BQU8sQ0FBQzRHLEtBQUssQ0FBQyxHQUNsQixDQUFDQSxLQUFLLENBQUMsR0FDUEEsS0FBSztNQUViLElBQUFpTCxpQkFBQSxHQUdJLElBQUksQ0FBQ3BPLFVBQVU7UUFGZkMsV0FBVyxHQUFBbU8saUJBQUEsQ0FBWG5PLFdBQVc7UUFDWEUsZ0JBQWdCLEdBQUFpTyxpQkFBQSxDQUFoQmpPLGdCQUFnQjtNQUdwQixJQUFRNkIscUJBQXFCLEdBQUssSUFBSSxDQUE5QkEscUJBQXFCO01BRTdCLElBQU1xTSxVQUFVLEdBQUcsRUFBRTtNQUFBLElBQUFDLFVBQUEsR0FBQTlSLDBCQUFBLENBRUQyUixVQUFVO1FBQUFJLE1BQUE7TUFBQTtRQUE5QixLQUFBRCxVQUFBLENBQUF6UixDQUFBLE1BQUEwUixNQUFBLEdBQUFELFVBQUEsQ0FBQXhSLENBQUEsSUFBQW5GLElBQUEsR0FBZ0M7VUFBQSxJQUFyQndMLE9BQUssR0FBQW9MLE1BQUEsQ0FBQTdhLEtBQUE7VUFFWixJQUFNaU8sTUFBTSxHQUFHeEIsZ0JBQWdCLENBQUMyQixHQUFHLENBQUNxQixPQUFLLENBQUM7VUFFMUMsSUFBSXhCLE1BQU0sS0FBSzlKLFNBQVMsRUFBRSxTQUFRLENBQUM7VUFFbkN3VyxVQUFVLENBQUMxVixJQUFJLENBQUM7WUFBQ3dLLEtBQUssRUFBTEEsT0FBSztZQUFDeEIsTUFBTSxFQUFOQTtVQUFNLENBQUMsQ0FBQztVQUMvQixJQUFBNk0saUJBQUEsR0FBd0J2TyxXQUFXLENBQUM2QixHQUFHLENBQUNILE1BQU0sQ0FBQztZQUF2Q2IsV0FBVyxHQUFBME4saUJBQUEsQ0FBWDFOLFdBQVc7VUFFbkJrQixxQkFBcUIsQ0FBQ2xCLFdBQVcsRUFBQ2EsTUFBTSxDQUFDO1VBRXpDMUIsV0FBVyxVQUFPLENBQUMwQixNQUFNLENBQUM7VUFDMUJ4QixnQkFBZ0IsVUFBTyxDQUFDZ0QsT0FBSyxDQUFDOztRQUlsQztNQUFBLFNBQUE5TyxHQUFBO1FBQUFpYSxVQUFBLENBQUF2UixDQUFBLENBQUExSSxHQUFBO01BQUE7UUFBQWlhLFVBQUEsQ0FBQXJSLENBQUE7TUFBQTtNQUVBdUYsa0JBQWtCLElBQUlBLGtCQUFrQixDQUFDNkwsVUFBVSxDQUFDO0lBRXhEO0lBRUE7RUFBQTtJQUFBN2EsR0FBQTtJQUFBRSxLQUFBLEVBQ0EsU0FBQSthLFVBQVU5TSxNQUFNO01BRVosT0FBTyxJQUFJLENBQUMzQixVQUFVLENBQUNDLFdBQVcsQ0FBQ3dILEdBQUcsQ0FBQzlGLE1BQU0sQ0FBQztJQUVsRDtFQUFDO0lBQUFuTyxHQUFBO0lBQUFFLEtBQUEsRUFFRCxTQUFBZ2Isa0JBQWtCL00sTUFBTTtNQUVwQixJQUFJLElBQUksQ0FBQzhNLFNBQVMsQ0FBQzlNLE1BQU0sQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDM0IsVUFBVSxDQUFDQyxXQUFXLENBQUM2QixHQUFHLENBQUNILE1BQU0sQ0FBQzs7SUFHdEQ7RUFBQztFQUFBLE9BQUFsQyxZQUFBO0FBQUE7QUExaENMdk0sa0JBQUEsR0FBQXVNLFlBQUE7QUE4aENBO0FBRUE7QUFDQTtBQUNBO0FBRUEsSUFBTTZOLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBZ0JBLENBQUluSyxLQUFLLEVBQUV4QixNQUFNLEVBQUk7RUFFdkMsSUFBTTBMLFVBQVUsR0FBRyxJQUFBOU4sc0JBQUEsQ0FBQW9QLG9CQUFvQixHQUFFO0VBRXpDLElBQU1DLFNBQVMsR0FBR3ZCLFVBQVUsQ0FBQ3dCLE9BQU87RUFDcENELFNBQVMsQ0FBQ0UsS0FBSyxDQUFDQyxRQUFRLEdBQUcsUUFBUTtFQUVuQ0gsU0FBUyxDQUFDSSxPQUFPLENBQUMzWixJQUFJLEdBQUcsaUJBQWlCO0VBQzFDdVosU0FBUyxDQUFDSSxPQUFPLENBQUM3TCxLQUFLLEdBQUdBLEtBQUs7RUFDL0J5TCxTQUFTLENBQUNJLE9BQU8sQ0FBQ0MsV0FBVyxHQUFHdE4sTUFBTTtFQUV0QyxPQUFPMEwsVUFBVTtBQUVyQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9wb3J0YWxjYWNoZS9jYWNoZWhhbmRsZXIudHN4P2Q4OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FjaGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBtYW5hZ2VzIHRoZSBJbmZpbml0ZUdyaWRTY3JvbGxlciBsaW1pdGVkIChzcGFyc2UpIGNhY2hlLiBJdCBhbHNvIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFxuICAgIHNlcnZpY2VzIHdoaWNoIGFsbG93IHRoZSBob3N0IHRvIGFjdGl2ZWx5IG1hbmFnZSBtYW55IGFzcGVjdHMgb2YgdGhlIGNhY2hlLiBTZWUgZG9jdW1lbnRhdGlvblxuICAgIGFib3V0IHRoZSB1c2VyIGZ1bmN0aW9uc0NhbGxiYWNrIGNhbGxiYWNrIGZvciBkZXRhaWxzLiBUaGUgY2FjaGVNYXggcHJvcGVydHkgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZVxuICAgIG1heGltdW0gZGV2aWNlIG1lbW9yeSBjb25zdW1wdGlvbiBvZiB0aGUgY2FjaGUuXG5cbiAgICBUaGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlciBzdG9yZXMgdXNlciBjZWxsIGNvbnRlbnQgKGNvbXBvbmVudHMpIGluIGEgY2VudHJhbCBoaWRkZW4gY2FjaGUsIFxuICAgIGZyb20gd2hlbmNlIHRoZSBjb21wb25lbnRzIGFyZSBwdWxsZWQgaW50byB0aGUgcmVsZXZhbnQgQ2VsbEZyYW1lcyBmb3IgZGlzcGxheS4gVGhlIHVzZXIgY29tcG9uZW50cyBhcmUgXG4gICAgc3RvcmVkIGluIFJlYWN0IHBvcnRhbHMsIHdpdGggZWFjaCBwb3J0YWwgaW5zdGFudGlhdGVkIGluIGEgY29udGFpbmVyIGRpdiAoZGF0YS10eXBlID0gJ3BvcnRhbHdyYXBwZXInKS4gXG4gICAgVGhlc2UgY29udGFpbmVyIGRpdnMgYXJlIHBhcnQgb2YgYSBzdGFuZGFyZCBSZWFjdCBjb21wb25lbnQgbGlzdCBpbiB0aGUgcmVhbCBET00uIFRoZSBjb250YWluZWQgcG9ydGFscyBcbiAgICB0aGVtc2VsdmVzIGFyZSBub3QgcGFydCBvZiB0aGUgcmVhbCBET00sIGJ1dCBhcmUgcGFydCBvZiBSZWFjdCdzIHZpcnR1YWwgRE9NLlxuXG4gICAgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9wb3J0YWxzLmh0bWwgZm9yIGdlbmVyYWwgaW5mb3JtYXRpb24gYWJvdXQgUmVhY3QgcG9ydGFscy5cbiAgICBTZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtcmV2ZXJzZS1wb3J0YWwgZm9yIHRoZSB1dGlsaXR5IHRoYXQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcbiAgICB1c2VzIHRvIG1hbmFnZSBwb3J0YWxzLlxuXG4gICAgVGhpcyBjYWNoaW5nIGhhcyBtYW55IGFkdmFudGFnZXMsIG5vdGFibHkgdGhlIGFiaWxpdHkgdG8gbW92ZSBjZWxscyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZVxuICAgIGhlYWQgYW5kIHRhaWwgZ3JpZHMgb2YgdGhlIENyYWRsZSB3aXRob3V0IGxvc2luZyBzdGF0ZSwgYW5kIHRoZSBhYmlsaXR5IHRvIG1haW50YWluIHN0YXRlIGZvciBcbiAgICBjb21wbGV4IGNvbXBvbmVudHMgd2hpY2ggbW92ZSBiZXlvbmQgdGhlIHNjb3BlIG9mIHRoZSBjb250ZW50IG9mIHRoZSBDcmFkbGUuIFxuXG4gICAgVGhlcmUgaXMgYW4gaW1wb3J0YW50IHNpZGUgZWZmZWN0IHRvIGNvbnNpZGVyLiBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZWFsIERPTSBcbiAgICBpbnRvIHRoZSBwb3J0YWwgb2YgdGhlIHZpcnR1YWwgRE9NIGhhdmUgdGhlaXIgc2Nyb2xsIHBvc2l0aW9ucywgd2lkdGgsIGFuZCBoZWlnaHQgc2V0IHRvIHplcm8uIFRoZXJlZm9yZSBpZiBcbiAgICBjb21wb25lbnRzIHJlbHkgb24gdGhlc2UgdmFsdWVzIGZvciBjb25maWd1cmF0aW9uLCB0aGV5IG11c3QgaGF2ZSBhIHdheSBvZiBzdG9yaW5nIHRob3NlIHZhbHVlcyBpbiBzdGF0ZSBcbiAgICAobm90YWJseSB0aGUgU2Nyb2xsIFBvcyAtIHNjcm9sbExlZnQgb3Igc2Nyb2xsVG9wKSwgcmVjb2duaXppbmcgd2hlbiB0aGUgY29tcG9uZW50IGNvbWVzIG91dCBvZiB0aGUgcG9ydGFsIGNhY2hlIFxuICAgIGludG8gdGhlIHJlYWwgRE9NICh3aWR0aCBhbmQgaGVpZ2h0IGFyZSB0eXBpY2FsbHkgbm8gbG9uZ2VyIGJvdGggMCksIGFuZCByZXNwb25kaW5nIHRvIGNoYW5nZSBpbiBcbiAgICBjYWNoZSBzdGF0ZSBhcHByb3ByaWF0ZWx5LlxuXG4gICAgVGlwczpcbiAgICAgICAgLSB5b3VyIGNvbXBvbmVudCBpcyBpbiBjYWNoZSB3aGVuIGJvdGggd2lkdGggYW5kIGhlaWdodCA9IDBcbiAgICAgICAgLSB5b3VyIGNvbXBvbmVudCBpcyBvdXQgb2YgY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGJhY2sgdG8gbm9ybWFsXG4gICAgICAgIC0gaWYgeW91IGNyZWF0ZSBhbiBlbXB0eSAnc2Nyb2xsZXJQcm9wZXJ0aWVzJyBwcm9wZXJ0eSBmb3IgeW91ciBjb21wb25lbnQsIENlbGxGcmFtZSB3aWxsXG4gICAgICAgICAgICBzZXQgaXQgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIGFuZCBjZWxsRnJhbWVEYXRhUmVmXG4gICAgICAgIC0gaWYgeW91ciBjb21wb25lbnQgZG9lcyBub3Qgc2Nyb2xsLCB0aGVyZSBzaG91bGQgYmUgbm8gaXNzdWVzLlxuXG4gICAgTm90ZSB0aGF0IGluIHRoZSBmb2xsb3dpbmcsIHNjcm9sbGVySUQgaXMgcHJvdmlkZWQgYXMgYSBwYXJhbXRlciB0byBzb21lIGZ1bmN0aW9ucyBmb3IgZGVidWcgcHVycG9zZXMsIGJ1dCBub3QgdXNlZC5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2t9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgSW5Qb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCdcblxuaW1wb3J0IENhY2hlUGFydGl0aW9uIGZyb20gJy4vQ2FjaGVQYXJ0aXRpb24nXG5cbi8vIHRoZSBjYWNoZSBpdHNlbGYgaXMgbWFpbnRhaW5lZCBpbiB0aGUgcm9vdCBpbmZpbml0ZWdyaWRzY3JvbGxlciBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhY2hlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxlcklELCBsaXN0c2l6ZVJlZiwgQ0FDSEVfUEFSVElUSU9OX1NJWkUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnNjcm9sbGVySUQgPSBzY3JvbGxlcklEIC8vIGZvciBkZWJ1Z1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZUxpc3RzaXplID0gdXBkYXRlTGlzdHNpemUgLy8gcGFzc2VkIGZyb20gSW5maW5pdGVHcmlkU2Nyb2xsZXIudXBkYXRlTGlzdHNpemUobGlzdHNpemUpXG4gICAgICAgIHRoaXMubGlzdHNpemVSZWYgPSBsaXN0c2l6ZVJlZiAvLyBjdXJyZW50IGxpc3Qgc2l6ZVxuXG4gICAgICAgIHRoaXMuQ0FDSEVfUEFSVElUSU9OX1NJWkUgPSBDQUNIRV9QQVJUSVRJT05fU0laRVxuICAgIH1cblxuICAgIGdsb2JhbEl0ZW1JRCA9IDBcbiAgICBnbG9iYWxQYXJ0aXRpb25JRCA9IDBcblxuICAgIGNhY2hlUHJvcHMgPSB7XG5cbiAgICAgICAgLy8gaXRlbSBkYXRhXG4gICAgICAgIG1ldGFkYXRhTWFwOm5ldyBNYXAoKSwgLy8gaXRlbSA9PiB7aW5kZXgsIGNvbXBvbmVudH1cbiAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcDpuZXcgTWFwKCksXG5cbiAgICAgICAgLy8gc29tZSBwb3J0YWxzIG1heSBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ5IHJlcXVlc3RpZGxlY2FsbGJhY2ssIG5vdCB5ZXQgY3JlYXRlZFxuICAgICAgICByZXF1ZXN0ZWRTZXQ6bmV3IFNldCgpLCAvLyByZXF1ZXN0ZWRTZXQgb2YgaW5kZXhlcyAodHJhbnNpdGlvbmFsKVxuXG4gICAgICAgIC8vIHBhcnRpdGlvbiBkYXRhXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhTWFwOm5ldyBNYXAoKSxcbiAgICAgICAgLy8gZm9yIHJlbmRlcmluZyBwYXJ0aXRpb25zLi4uXG4gICAgICAgIHBhcnRpdGlvbk1hcDogbmV3IE1hcCgpLFxuICAgICAgICBwYXJ0aXRpb25SZW5kZXJMaXN0Om51bGwsXG4gICAgICAgIHBhcnRpdGlvblJlcG9Gb3JjZVVwZGF0ZTpudWxsLFxuICAgICAgICBwYXJ0aXRpb25Nb2RpZmllZFNldDogbmV3IFNldCgpLFxuXG4gICAgICAgIHBhcnRpdGlvblB0cjpudWxsLCAvLyBhY3RpdmUgcGFydGl0aW9uLCBmb3IgZm9sbG93dXBcblxuICAgICAgICBzY3JvbGxlcklEOm51bGwgLy8gZm9yIGRlYnVnXG4gICAgfVxuXG4gICAgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgQ0FDSEVfUEFSVElUSU9OX1NJWkVcblxuICAgIHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCAvLyBhcnJheSBvZiB7aXRlbUlELHBhcnRpdGlvbklEfVxuXG4gICAgbGlzdHNpemVSZWZcblxuICAgIC8vIHVwZGF0ZUxpc3RzaXplKGxpc3RzaXplKSBjYXVzZXMgYW4gSW5maW5pdGVHcmlkU2Nyb2xsZXIgdXNlU3RhdGUgdXBkYXRlXG4gICAgLy8gb2YgdGhlIGxpc3RzaXplIHRocm91Z2hvdXRcbiAgICAvLyB1cGRhdGVMaXN0c2l6ZSAvLyBmdW5jdGlvbiBwYXNzZWQgZnJvbSBJbmZpbml0ZUdyaWRTY3JvbGxlclxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBQQVJUSVRJT04gTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gcGFydGl0aW9ucyBhcmUgYWRkZWQgYnV0IG5vdCByZW1vdmVkXG5cbiAgICByZW5kZXJQYXJ0aXRpb25SZXBvID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25SZW5kZXJMaXN0ID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTWFwLnZhbHVlcygpKVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUodGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvblJlbmRlckxpc3QpXG5cbiAgICB9XG5cbiAgICBhZGRQYXJ0aXRpb24gPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSUQgPSB0aGlzLmdsb2JhbFBhcnRpdGlvbklEKytcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1ldGFkYXRhTWFwLnNldChwYXJ0aXRpb25JRCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3J0YWxNYXA6bmV3IE1hcCgpLCBcbiAgICAgICAgICAgICAgICBtYXBjb3VudDowLCAvLyBwb3J0YWxNYXAgdXBkYXRlIGNhbiBiZSBhc3luYywgc28gbWFwY291bnQgaXMgdXNlZFxuICAgICAgICAgICAgICAgIHBvcnRhbFJlbmRlckxpc3Q6bnVsbCwgXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6ZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGU6bnVsbCxcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb25JRCxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWZ1bmMgPSB7XG4gICAgICAgICAgICBjdXJyZW50Om51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZWZ1bmMuY3VycmVudCA9IHJlc29sdmVcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcblxuICAgICAgICAgICAgcmVzb2x2ZWZ1bmMuY3VycmVudChwYXJ0aXRpb25JRClcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1hcC5zZXQocGFydGl0aW9uSUQsXG4gICAgICAgICAgICA8Q2FjaGVQYXJ0aXRpb24gXG4gICAgICAgICAgICAgICAga2V5ID0ge3BhcnRpdGlvbklEfSBcbiAgICAgICAgICAgICAgICBjYWNoZVByb3BzID0ge3RoaXMuY2FjaGVQcm9wc30gXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uSUQgPSB7cGFydGl0aW9uSUR9IFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0geyBjYWxsYmFjayB9IC8+KVxuXG4gICAgICAgIHRoaXMucmVuZGVyUGFydGl0aW9uUmVwbygpXG5cbiAgICAgICAgcmV0dXJuIHByb21pc2VcblxuICAgIH1cblxuICAgIGFzeW5jIGZpbmRQYXJ0aXRpb25XaXRoUm9vbSgpIHtcblxuICAgICAgICBjb25zdCB7IENBQ0hFX1BBUlRJVElPTl9TSVpFIH0gPSB0aGlzXG5cbiAgICAgICAgY29uc3QgeyBwYXJ0aXRpb25NZXRhZGF0YU1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG4gICAgICAgIGxldCB7IHBhcnRpdGlvblB0ciB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgbGV0IHBhcnRpdGlvbk1ldGFkYXRhXG4gICAgICAgIGlmIChwYXJ0aXRpb25QdHIgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEgPSBwYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uUHRyKVxuXG4gICAgICAgICAgICBpZiAocGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgPCBDQUNIRV9QQVJUSVRJT05fU0laRSkge1xuXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgKz0gMSBcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGl0aW9uUHRyXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcGFydGl0aW9uUHRyID0gbnVsbFxuICAgICAgICBmb3IgKGNvbnN0IFtwYXJ0aXRpb25JRCwgcGFydGl0aW9uTWV0YWRhdGFdIG9mIHBhcnRpdGlvbk1ldGFkYXRhTWFwKSB7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0aXRpb25NZXRhZGF0YS5tYXBjb3VudCA8IENBQ0hFX1BBUlRJVElPTl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgKz0gMSBcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb25QdHIgPSBwYXJ0aXRpb25JRFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aXRpb25QdHIgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgcGFydGl0aW9uUHRyID0gYXdhaXQgdGhpcy5hZGRQYXJ0aXRpb24oKVxuICAgICAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEgPSBwYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uUHRyKVxuICAgICAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgKz0gMSBcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvblB0ciA9IHBhcnRpdGlvblB0clxuXG4gICAgICAgIHJldHVybiBwYXJ0aXRpb25QdHJcblxuICAgIH1cblxuICAgIGFkZFBhcnRpdGlvblBvcnRhbCA9IChwYXJ0aXRpb25JRCwgaXRlbUlELCBwb3J0YWwpID0+IHtcblxuICAgICAgICBjb25zdCBwYXJ0aXRpb25NZXRhZGF0YSA9IHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEucG9ydGFsTWFwLnNldChpdGVtSUQscG9ydGFsKVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZFNldC5hZGQocGFydGl0aW9uSUQpXG5cbiAgICB9XG5cbiAgICByZW1vdmVQYXJ0aXRpb25Qb3J0YWwgPSAocGFydGl0aW9uSUQsIGl0ZW1JRCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1ldGFkYXRhTWFwLmdldChwYXJ0aXRpb25JRClcblxuICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5wb3J0YWxNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEubWFwY291bnQgLT0gMSBcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTW9kaWZpZWRTZXQuYWRkKHBhcnRpdGlvbklEKVxuXG4gICAgfVxuXG4gICAgcmVuZGVyUGFydGl0aW9uID0gKHBhcnRpdGlvbklEKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uTWV0YWRhdGEgPSB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uTWV0YWRhdGFNYXAuZ2V0KHBhcnRpdGlvbklEKVxuXG4gICAgICAgIGlmICghcGFydGl0aW9uTWV0YWRhdGEpIHJldHVyblxuXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLnBvcnRhbFJlbmRlckxpc3QgPSAgQXJyYXkuZnJvbShwYXJ0aXRpb25NZXRhZGF0YS5wb3J0YWxNYXAudmFsdWVzKCkpXG5cbiAgICAgICAgLy8gaWYgZm9yY2VVcGRhdGUgaGFzIG5vdCB5ZXQgYmVlbiBhc3NpZ25lZCwgaXQgaXMgaW4gdGhlIHdvcmtzIGZyb20gZmlyc3QgY2FsbCBvZiBwYXJ0aXRpb25cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEuZm9yY2VVcGRhdGUgJiYgcGFydGl0aW9uTWV0YWRhdGEuZm9yY2VVcGRhdGUocGFydGl0aW9uTWV0YWRhdGEucG9ydGFsUmVuZGVyTGlzdClcblxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZSBvZiB0aGUgQ2FjaGVQYXJ0aXRpb24gY29tcG9uZW50IG9mIHRoZSBzY3JvbGxlciB0byB0cmlnZ2VyIHJlbmRlclxuICAgIHJlbmRlclBvcnRhbExpc3RzID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgcGFydGl0aW9uTW9kaWZpZWRTZXQgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGlmIChwYXJ0aXRpb25Nb2RpZmllZFNldC5zaXplKSB7XG5cbiAgICAgICAgICAgIHBhcnRpdGlvbk1vZGlmaWVkU2V0LmZvckVhY2goKHBhcnRpdGlvbklEKSA9PiB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBhcnRpdGlvbihwYXJ0aXRpb25JRClcblxuICAgICAgICAgICAgfSkgICAgICAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLnBhcnRpdGlvbk1vZGlmaWVkU2V0LmNsZWFyKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIGNsZWFyIGJhc2UgZGF0YVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuY2xlYXIoKVxuICAgICAgICAvLyBjbGVhciBjYWNoZSBwYXJ0aXRpb25zXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25NYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucGFydGl0aW9uUmVuZGVyTGlzdCA9IFtdXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZFNldC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25QdHIgPSBudWxsXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUobnVsbClcblxuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09WyBSRVBPU0lUT1JZIEFORCBMSVNUIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGJhc2ljIG9wZXJhdGlvbnMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBjYWxsZWQgZnJvbSBDcmFkbGUubnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgYW5kIHNlcnZpY2VIYW5kbGVyLnNldExpc3RzaXplXG4gICAgY2hhbmdlQ2FjaGVMaXN0c2l6ZSA9IChuZXdsaXN0c2l6ZSwgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgLy8gdGhpcy51cGRhdGVMaXN0c2l6ZShuZXdsaXN0c2l6ZSlcblxuICAgICAgICAvLyBtYXRjaCBjYWNoZSB0byBuZXdsaXN0c2l6ZVxuICAgICAgICBjb25zdCBwb3J0YWxJbmRleE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG4gICAgICAgIGNvbnN0IG1hcGtleXNMaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleE1hcC5rZXlzKCkpXG4gICAgICAgIG1hcGtleXNMaXN0LnNvcnQoKGEsYikgPT4gYSAtIGIpXG5cbiAgICAgICAgY29uc3QgaGlnaGVzdGluZGV4ID0gbWFwa2V5c0xpc3QuYXQoLTEpXG5cbiAgICAgICAgaWYgKGhpZ2hlc3RpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSkpIHsgLy8gcGFyZSB0aGUgY2FjaGVcblxuICAgICAgICAgICAgY29uc3QgcGFyZWxpc3QgPSBtYXBrZXlzTGlzdC5maWx0ZXIoKGluZGV4KT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKHBhcmVsaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgJiYgY2hhbmdlTGlzdHNpemVDYWxsYmFjayhuZXdsaXN0c2l6ZSlcblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhY2hlIHNpemUgbGltaXQgZW5mb3JjZWVudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBtYXRjaENhY2hlVG9DcmFkbGUgPSAoY3JhZGxlSW5kZXhMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgICAgICBjb25zdCBtYXBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgZGVsa2V5cyA9IG1hcGtleXMuZmlsdGVyKGtleSA9PiAhY3JhZGxlSW5kZXhMaXN0LmluY2x1ZGVzKGtleSkpXG5cbiAgICAgICAgaWYgKGRlbGtleXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbGtleXMsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcGFyZUNhY2hlVG9NYXggPSAoY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEID0gdW5kZWZpbmVkKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbW9kZWxMZW5ndGggPSBjcmFkbGVJbmRleExpc3QubGVuZ3RoXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5lZWQgZm9yIHBhcmluZ1xuICAgICAgICBpZiAoKCFjYWNoZU1heCkgfHwgKCFtb2RlbExlbmd0aCkpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KG1vZGVsTGVuZ3RoLCBjYWNoZU1heClcblxuICAgICAgICBjb25zdCBwb3J0YWxJbmRleE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLFxuICAgICAgICAgICAgcmVxdWVzdGVkU2V0ID0gdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldFxuXG4gICAgICAgIGlmICgocG9ydGFsSW5kZXhNYXAuc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSBtYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIG1hcCBrZXlzXG4gICAgICAgIGNvbnN0IG1hcGtleXNsaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleE1hcC5rZXlzKCkpLFxuICAgICAgICAgICAgcmVxdWVzdGVka2V5cyA9IEFycmF5LmZyb20ocmVxdWVzdGVkU2V0LmtleXMoKSlcblxuICAgICAgICBjb25zdCBtYXBrZXlzID0gWy4uLm1hcGtleXNsaXN0LC4uLnJlcXVlc3RlZGtleXNdXG5cbiAgICAgICAgbWFwa2V5cy5zb3J0KChhLGIpID0+IGEgLSBiKVxuXG4gICAgICAgIC8vIGdldCBudW1iZXIgdG8gcGFyZVxuICAgICAgICBjb25zdCBtYXBMZW5ndGggPSBtYXBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIHBhcmVjb3VudCA9IG1hcExlbmd0aCAtIG1heFxuXG4gICAgICAgIC8vIGRpc3RyaWJ1dGUgcGFyaW5nIHByb3BvcnRpb25hbGx5IGF0IGZyb250IGFuZCBiYWNrXG4gICAgICAgIGNvbnN0IGhlYWRpbmRleCA9IGNyYWRsZUluZGV4TGlzdFswXSxcbiAgICAgICAgICAgIHRhaWxpbmRleCA9IGNyYWRsZUluZGV4TGlzdFttb2RlbExlbmd0aCAtIDFdLFxuICAgICAgICAgICAgaGVhZHBvcyA9IG1hcGtleXMuaW5kZXhPZihoZWFkaW5kZXgpLFxuICAgICAgICAgICAgdGFpbHBvcyA9IG1hcGtleXMuaW5kZXhPZih0YWlsaW5kZXgpXG5cbiAgICAgICAgY29uc3QgaGVhZHJvb20gPSBoZWFkcG9zLFxuICAgICAgICAgICAgdGFpbHJvb20gPSBtYXBMZW5ndGggLSAodGFpbHBvcyArIDEpLFxuICAgICAgICAgICAgcGFyZXJvb20gPSBoZWFkcm9vbSArIHRhaWxyb29tXG5cbiAgICAgICAgY29uc3QgaGVhZHBhcmVjb3VudCA9IE1hdGguZmxvb3IoKGhlYWRyb29tL3BhcmVyb29tKSpwYXJlY291bnQpLFxuICAgICAgICAgICAgdGFpbHBhcmVjb3VudCA9IHBhcmVjb3VudCAtIGhlYWRwYXJlY291bnRcblxuICAgICAgICAvLyBjb2xsZWN0IGluZGV4ZXMgdG8gcGFyZVxuICAgICAgICBjb25zdCBoZWFkbGlzdCA9IG1hcGtleXMuc2xpY2UoMCxoZWFkcGFyZWNvdW50KSxcbiAgICAgICAgICAgIHRhaWxsaXN0ID0gbWFwa2V5cy5zbGljZShtYXBMZW5ndGggLSB0YWlscGFyZWNvdW50KVxuXG4gICAgICAgIGNvbnN0IGRlbExpc3QgPSBbLi4uaGVhZGxpc3QsLi4udGFpbGxpc3RdXG5cbiAgICAgICAgdGhpcy5kZWxldGVQb3J0YWwoZGVsTGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICB9XG5cbiAgICBndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyA9IChjYWNoZU1heCwgY3JhZGxlTGlzdExlbmd0aCwgTUFYX0NBQ0hFX09WRVJfUlVOKSA9PiB7XG5cbiAgICAgICAgaWYgKCFjYWNoZU1heCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcCxcbiAgICAgICAgICAgIHJlcXVlc3RlZFNldCBcbiAgICAgICAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGNyYWRsZUxpc3RMZW5ndGgsIGNhY2hlTWF4KVxuXG4gICAgICAgIGlmICgoaW5kZXhUb0l0ZW1JRE1hcC5zaXplICsgcmVxdWVzdGVkU2V0LnNpemUpIDw9ICgobWF4KSAqIE1BWF9DQUNIRV9PVkVSX1JVTikpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcHJlbG9hZCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZWxvYWQoZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRCkge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpc1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIH0gPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBnZXRJdGVtLCBjYWNoZU1heCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgIHsgbGlzdHNpemUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW11cblxuICAgICAgICBsZXQgY2FjaGVTaXplID0gY2FjaGVNYXggPz8gMFxuXG4gICAgICAgIGNhY2hlU2l6ZSA9IE1hdGgubWluKGNhY2hlU2l6ZSwgbGlzdHNpemUpXG5cbiAgICAgICAgY29uc3QgcHJlbG9hZHNpemUgPSBcbiAgICAgICAgICAgIGNhY2hlU2l6ZT9cbiAgICAgICAgICAgICAgICBjYWNoZVNpemU6XG4gICAgICAgICAgICAgICAgbGlzdHNpemVcblxuICAgICAgICBjb25zdCBicmVha2xvb3AgPSB7XG4gICAgICAgICAgICBjdXJyZW50OmZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhMaXN0c2l6ZUludGVycnVwdCA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgYnJlYWtsb29wLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbmRleFRvSXRlbUlETWFwID0gdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXBcblxuICAgICAgICAgICAgY29uc3QgeyBwcmVsb2FkSW5kZXhDYWxsYmFjaywgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByZWxvYWRzaXplOyBpbmRleCsrKSB7XG5cbiAgICAgICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjayAmJiBwcmVsb2FkSW5kZXhDYWxsYmFjayhpbmRleClcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnByZWxvYWRJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySURcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYnJlYWtsb29wLmN1cnJlbnQpIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpLnRoZW4oXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUG9ydGFsTGlzdHMoKVxuICAgICAgICAgICAgICAgIGZpbmFsQ2FsbGJhY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09WyBTTkFQU0hPVFMgXT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGdldENhY2hlSW5kZXhNYXAoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXApXG5cbiAgICB9XG5cbiAgICBnZXRDcmFkbGVJbmRleE1hcChjcmFkbGVJbmRleExpc3QpIHtcblxuICAgICAgICBjb25zdCBjcmFkbGVNYXAgPSBuZXcgTWFwKCksXG4gICAgICAgICAgICB7IGluZGV4VG9JdGVtSURNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgICAgIGNyYWRsZU1hcC5zZXQoaW5kZXgsIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyYWRsZU1hcFxuXG4gICAgfVxuXG4gICAgZ2V0Q2FjaGVJdGVtTWFwKCkge1xuXG4gICAgICAgIGNvbnN0IGNhY2hlbGlzdCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIH0gPSB2YWx1ZVxuXG4gICAgICAgICAgICBjYWNoZWxpc3Quc2V0KGtleSx7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlbGlzdFxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIG1vdmUgaW5kZXhlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gbW92ZSBpcyBjb2VyY2VkIGJ5IHNlcnZpY2VoYW5kbGVyIHRvIGJlIHdpdGhpbiBjdXJyZW50IGxpc3QgYm91bmRzXG4gICAgbW92ZUluZGV4KHRvbG93aW5kZXgsIGZyb21sb3dpbmRleCwgZnJvbWhpZ2hpbmRleCApIHtcblxuICAgICAgICBjb25zdCB7aW5kZXhUb0l0ZW1JRE1hcCxtZXRhZGF0YU1hcH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBkZWZpbmUgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBtb3ZlYmxvY2tzaXplID0gZnJvbWhpZ2hpbmRleCAtIGZyb21sb3dpbmRleCArIDEsXG4gICAgICAgICAgICBtb3ZlaW5jcmVtZW50ID0gdG9sb3dpbmRleCAtIGZyb21sb3dpbmRleCxcbiAgICAgICAgICAgIHRvaGlnaGluZGV4ID0gdG9sb3dpbmRleCArIChtb3ZlYmxvY2tzaXplIC0gMSlcblxuICAgICAgICBjb25zdCBtb3ZlZGlyZWN0aW9uID0gXG4gICAgICAgICAgICAobW92ZWluY3JlbWVudCA+IDApPyAvLyBtb3ZlIGJsb2NrIHVwIGluIGxpc3RcbiAgICAgICAgICAgICAgICAndXAnOiAvLyBzaGlmdCBkb3duLCBtYWtlIHJvb20gZm9yIHNoaWZ0aW5naW5kZXggYWJvdmVcbiAgICAgICAgICAgICAgICAnZG93bicgICAvLyBzaGlmdCB1cCwgbWFrZSByb29tIGZvciBzaGlmdGluZ2luZGV4IGJlbG93XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGZpbmQgYm91bmRzIG9mIGZyb20gYW5kIHRvIGJsb2NrcyBpbiBjYWNoZSAtLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3Qgb3JkZXJlZGluZGV4bGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpLnNvcnQoKGEsYik9PmEtYilcblxuICAgICAgICBjb25zdCByZXZlcnNlb3JkZXJlZGluZGV4bGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoKS5yZXZlcnNlKClcblxuICAgICAgICBjb25zdCB0b2xvd2luZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gdG9sb3dpbmRleCksXG4gICAgICAgICAgICBmcm9tbG93aW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSBmcm9tbG93aW5kZXgpXG5cbiAgICAgICAgbGV0IHRvaGlnaGluZGV4cHRyID0gcmV2ZXJzZW9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlIDw9IHRvaGlnaGluZGV4KSxcbiAgICAgICAgICAgIGZyb21oaWdoaW5kZXhwdHIgPSByZXZlcnNlb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPD0gZnJvbWhpZ2hpbmRleClcblxuICAgICAgICAvLyBnZXQgcmVxdWlyZWQgaW52ZXJzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWxpc3Rjb3VudCA9IG9yZGVyZWRpbmRleGxpc3QubGVuZ3RoXG4gICAgICAgICAgICBpZiAodG9oaWdoaW5kZXhwdHIgIT0gLTEpIHRvaGlnaGluZGV4cHRyID0gKGNhY2hlbGlzdGNvdW50IC0xKSAtIHRvaGlnaGluZGV4cHRyXG4gICAgICAgICAgICBpZiAoZnJvbWhpZ2hpbmRleHB0ciAhPSAtMSkgZnJvbWhpZ2hpbmRleHB0ciA9IChjYWNoZWxpc3Rjb3VudCAtMSkgLSBmcm9taGlnaGluZGV4cHRyXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIGNhcHR1cmUgaW5kZXggZGF0YSB0byBtb3ZlIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgbGlzdHRvcHJvY2Vzc2Zvcm1vdmVcbiAgICAgICAgaWYgKChmcm9tbG93aW5kZXhwdHIgPT0gLTEpICYmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSkgeyAvLyBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9ybW92ZSA9IFtdXG5cbiAgICAgICAgfSBlbHNlIGlmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSB7IC8vIHNjb3BlIGlzIHBhcnRpYWxseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3Jtb3ZlID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9tbG93aW5kZXhwdHIpXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc2NvcGUgaXMgZW50aXJlbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9ybW92ZSA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWxvd2luZGV4cHRyLCBmcm9taGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc3RvbW92ZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBjYXB0dXJlbW92ZWluZGV4Rm4gPSAoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5zZXQoaW5kZXgsIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdHRvcHJvY2Vzc2Zvcm1vdmUuZm9yRWFjaChjYXB0dXJlbW92ZWluZGV4Rm4pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBnZXQgbGlzdCBvZiBpbmRleGVzIHRvIHNoaWZ0IG91dCBvZiB0aGUgd2F5IC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBcbiAgICAgICAgbGV0IGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZVxuICAgICAgICBpZiAobW92ZWRpcmVjdGlvbiA9PSAnZG93bicpIHsgLy8gYmxvY2sgaXMgbW92aW5nIGRvd24sIHNoaWZ0IGlzIHVwOyB0b2luZGV4IDwgZnJvbWluZGV4XG5cbiAgICAgICAgICAgIGlmICgodG9sb3dpbmRleHB0ciA9PSAtMSkgJiYgKGZyb21sb3dpbmRleHB0ciA9PSAtMSkpIHtcblxuICAgICAgICAgICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZSA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbWxvd2luZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKHRvbG93aW5kZXhwdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKHRvbG93aW5kZXhwdHIsIGZyb21sb3dpbmRleHB0cilcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHNoaWZ0ZGlyZWN0aW9uID09IC0xOyBibG9jayBpcyBtb3ZpbmcgdXAsIHNoaWZ0IGlzIGRvd247IGZyb21pbmRleCA8IHRvaW5kZXhcblxuICAgICAgICAgICAgaWYgKHRvaGlnaGluZGV4cHRyID09IC0xICYmIGZyb21oaWdoaW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZSA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9oaWdoaW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZSA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWhpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21oaWdoaW5kZXhwdHIgKyAxLCB0b2hpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3ZlZGlyZWN0aW9uID09ICdkb3duJykgbGlzdHRvcHJvY2Vzc2ZvcmRpc3BsYWNlLnJldmVyc2UoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIG1vdmUgaW5kZXhlcyBvdXQgb2YgdGhlIHdheSAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZGRpc3BsYWNlTGlzdCA9IFtdXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc3NkaXNwbGFjZWluZGV4Rm4gPSAoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gXG4gICAgICAgICAgICAgICAgKG1vdmVkaXJlY3Rpb24gPT0gJ3VwJyk/XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC0gbW92ZWJsb2Nrc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKyBtb3ZlYmxvY2tzaXplXG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIHByb2Nlc3NlZGRpc3BsYWNlTGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UuZm9yRWFjaChwcm9jZXNzc2Rpc3BsYWNlaW5kZXhGbilcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gcmVwbGFjZSBzaGlmdGVkIGluZGV4IHNwYWNlIHdpdGggbW92ZWQgaW5kZXhlcyAtLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkbW92ZUxpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzbW92ZWluZGV4Rm4gPSAoaXRlbUlELCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBpbmRleCArIG1vdmVpbmNyZW1lbnQgLy8gc3dhcFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkbW92ZUxpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5mb3JFYWNoKHByb2Nlc3Ntb3ZlaW5kZXhGbilcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLXJldHVybiBsaXN0IG9mIHByb2Nlc3NlZCBpbmRleGVzIHRvIGNhbGxlciAtLS0tLS0tLVxuICAgICAgICAvLyBmb3Igc3luY2hybml6YXRpb24gd2l0aCBjcmFkbGUgY2VsbEZyYW1lc1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEluZGV4ZXMgPSBbLi4ucHJvY2Vzc2VkZGlzcGxhY2VMaXN0LC4uLnByb2Nlc3NlZG1vdmVMaXN0XS5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEluZGV4ZXNcblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluc2VydC9yZW1vdmUgaW5kZXhlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBpbnNlcnQgb3IgcmVtb3ZlIGluZGV4ZXM6IG11Y2ggb2YgdGhpcyBkZWFscyB3aXRoIHRoZSBmYWN0IHRoYXQgdGhlIGNhY2hlIGlzIHNwYXJzZS5cbiAgICBpbnNlcnRSZW1vdmVJbmRleChpbmRleCwgaGlnaHJhbmdlLCBpbmNyZW1lbnQsIGxpc3RzaXplICkgeyAvLyBpbmNyZW1lbnQgaXMgKzEgb3IgLTFcblxuICAgICAgICAvLyBjbGFyaXR5XG4gICAgICAgIGNvbnN0IGlzSW5zZXJ0aW5nID0gKGluY3JlbWVudCA9PSAxKVxuICAgICAgICBjb25zdCBpc1JlbW92aW5nID0gKGluY3JlbWVudCA9PSAtMSlcblxuICAgICAgICBjb25zdCBlbXB0eXJldHVybiA9IFtudWxsLCBudWxsLCBbXSxbXSxbXSwgW11dIC8vIG5vIGFjdGlvbiByZXR1cm4gdmFsdWVcblxuICAgICAgICAvLyBjYWNoZSByZXNvdXJjZXNcbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwLCBtZXRhZGF0YU1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG4gICAgICAgIGNvbnN0IG9yZGVyZWRDYWNoZUluZGV4TGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpLnNvcnQoKGEsYik9PmEtYikgLy8gYXNjZW5kaW5nIG9yZGVyXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBkZWZpbmUgY29udGlndW91cyByYW5nZSBwYXJhbWV0ZXJzOyBhZGQgc2VudGluZWxzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhpZ2ggcmFuZ2UgaXMgdGhlIGhpZ2hlc3QgaW5kZXggbnVtYmVyIG9mIHRoZSBpbnNlcnQvcmVtb3ZlIHJhbmdlXG4gICAgICAgIGxldCBoaWdocmFuZ2VpbmRleCA9IGhpZ2hyYW5nZVxuICAgICAgICBsZXQgbG93cmFuZ2VpbmRleCA9IGluZGV4IC8vIHNlbWFudGljcyAtIG5hbWUgc3ltbWV0cnlcblxuICAgICAgICBpZiAoaXNSZW1vdmluZykge1xuXG4gICAgICAgICAgICAvLyByZW1vdmFsIG11c3QgYmUgZW50aXJlbHkgd2l0aGluIHNjb3BlIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoaGlnaHJhbmdlaW5kZXggPiAobGlzdHNpemUgLSAxKSkge1xuXG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXggPSAobGlzdHNpemUgLSAxKVxuICAgICAgICAgICAgICAgIGlmIChoaWdocmFuZ2VpbmRleCA8IGxvd3JhbmdlaW5kZXgpIHJldHVybiBlbXB0eXJldHVyblxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gaXNJbnNlcnRpbmdcblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gY2FuIGF0IG1vc3Qgc3RhcnQgYXQgdGhlIG5leHQgbG93cmFuZ2VpbmRleCBhYm92ZSB0aGUgY3VycmVudCBsaXN0OyBha2EgYXBwZW5kXG4gICAgICAgICAgICBpZiAobG93cmFuZ2VpbmRleCA+IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gbG93cmFuZ2VpbmRleCAtIGxpc3RzaXplXG4gICAgICAgICAgICAgICAgbG93cmFuZ2VpbmRleCAtPSBkaWZmXG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXggLT0gZGlmZlxuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFuZ2Vjb3VudCBpcyB0aGUgYWJzb2x1dGUgbnVtYmVyIGluIHRoZSBpbnNlcnQvcmVtb3ZlIGNvbnRpZ3VvdXMgcmFuZ2VcbiAgICAgICAgY29uc3QgcmFuZ2Vjb3VudCA9IGhpZ2hyYW5nZWluZGV4IC0gbG93cmFuZ2VpbmRleCArIDFcblxuICAgICAgICAvLyByYW5nZSBpbmNyZW1lbnQgYWRkcyBzaWduIHRvIHJhbmdlY291bnQgdG8gaW5kaWNhdGUgYWRkL3JlbW92ZVxuICAgICAgICBjb25zdCByYW5nZWluY3JlbWVudCA9IHJhbmdlY291bnQgKiBpbmNyZW1lbnRcbiAgICAgICAgY29uc3Qgc3RhcnRDaGFuZ2VJbmRleCA9IFxuICAgICAgICAgICAgKGluY3JlbWVudCA9PSAxKT9cbiAgICAgICAgICAgICAgICBsb3dyYW5nZWluZGV4OlxuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZWluZGV4ICsgKHJhbmdlaW5jcmVtZW50ICsgMSlcblxuICAgICAgICBsZXQgdG9TaGlmdFN0YXJ0SW5kZXggLy8gc3RhcnQgb2YgaW5kZXhlcyB0byBzaGlmdCB1cCAoaW5zZXJ0KSBvciBkb3duIChyZW1vdmUpXG4gICAgICAgIGlmIChpc0luc2VydGluZykge1xuICAgICAgICAgICAgdG9TaGlmdFN0YXJ0SW5kZXggPSBsb3dyYW5nZWluZGV4XG4gICAgICAgIH0gZWxzZSB7IC8vIGlzUmVtb3ZpbmdcbiAgICAgICAgICAgIHRvU2hpZnRTdGFydEluZGV4ID0gaGlnaHJhbmdlaW5kZXggKyAxXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSByYW5nZSBib3VuZGFyaWVzIHdpdGhpbiBvcmRlcmVkIGNhY2hlIGluZGV4IGxpc3QgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gb2J0YWluIHN0YXJwdHIgZm9yIGluZGV4ZXMgdG8gc2hpZnRcbiAgICAgICAgY29uc3QgdG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSB0b1NoaWZ0U3RhcnRJbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIG9idGFpbiBsb3dDYWNoZVJhbmdlUHRyLi4uXG4gICAgICAgIGNvbnN0IGxvd0NhY2hlUmFuZ2VQdHIgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSBsb3dyYW5nZWluZGV4KSAmJiAodmFsdWUgPD0gaGlnaHJhbmdlaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBvYnRhaW4gaGlnaENhY2hlUmFuZ2VQdHIuLi5cbiAgICAgICAgY29uc3QgcmV2ZXJzZUNhY2hlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShvcmRlcmVkQ2FjaGVJbmRleExpc3QpLnJldmVyc2UoKVxuICAgICAgICBsZXQgaGlnaENhY2hlUmFuZ2VQdHIgPSByZXZlcnNlQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIDw9IGhpZ2hyYW5nZWluZGV4KSAmJiAodmFsdWUgPj0gbG93cmFuZ2VpbmRleClcblxuICAgICAgICB9KVxuICAgICAgICAvLyB0YWtlIGludmVyc2Ugb2YgaGlnaENhY2hlUmFuZ2VQdHIgZm9yIG5vbi1yZXZlcnNlIHNvcnRcbiAgICAgICAgaWYgKGhpZ2hDYWNoZVJhbmdlUHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgIGhpZ2hDYWNoZVJhbmdlUHRyID0gKG9yZGVyZWRDYWNoZUluZGV4TGlzdC5sZW5ndGggLSAxKSAtIGhpZ2hDYWNoZVJhbmdlUHRyXG4gICAgICAgICAgICBpZiAoaGlnaENhY2hlUmFuZ2VQdHIgPCBsb3dDYWNoZVJhbmdlUHRyKSBoaWdoQ2FjaGVSYW5nZVB0ciA9IC0xXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGlzb2xhdGUgaW5kZXggcmFuZ2UgbGlzdCBhbmQgc2hpZnQgbGlzdCAtLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjYWNoZSBpbnB1dHNcbiAgICAgICAgbGV0IGNhY2hlUmFuZ2VJbmRleGVzTGlzdCwgLy8gZm9yIGVpdGhlciBpbnNlcnQgb3IgcmVtb3ZlXG4gICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCAvLyBmb3IgZWl0aGVyIGluc2VydCBvciByZW1vdmVcblxuICAgICAgICAvLyBnZXQgaW5wdXRzXG4gICAgICAgIGlmIChsb3dDYWNoZVJhbmdlUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgY2FjaGVSYW5nZUluZGV4ZXNMaXN0ID0gW11cbiAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gW11cblxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2hDYWNoZVJhbmdlUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgcGFydGlhbGx5IGluIHZpZXc7IGxvd0NhY2hlUmFuZ2VQdHIgaXMgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBhYm92ZSBsb3dDYWNoZVJhbmdlUHRyIG11c3QgaGF2ZSBpbmRleGVzIHJlc2V0XG4gICAgICAgICAgICBjYWNoZVJhbmdlSW5kZXhlc0xpc3QgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3Quc2xpY2UobG93Q2FjaGVSYW5nZVB0cilcblxuICAgICAgICAgICAgaWYgKGlzSW5zZXJ0aW5nKSB7XG5cbiAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IGNhY2hlUmFuZ2VJbmRleGVzTGlzdC5zbGljZSgpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IFtdXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gb3JkZXJlZENhY2hlSW5kZXhMaXN0LnNsaWNlKHRvU2hpZnRTdGFydENhY2hlUHRyKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyByYW5nZSBmdWxseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIGNhY2hlUmFuZ2VJbmRleGVzTGlzdCA9IG9yZGVyZWRDYWNoZUluZGV4TGlzdC5zbGljZShsb3dDYWNoZVJhbmdlUHRyLCBoaWdoQ2FjaGVSYW5nZVB0ciArIDEpXG5cbiAgICAgICAgICAgIGlmIChpc0luc2VydGluZykge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVUb1NoaWZ0SW5kZXhlc0xpc3QgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3Quc2xpY2UodG9TaGlmdFN0YXJ0Q2FjaGVQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IFtdXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gb3JkZXJlZENhY2hlSW5kZXhMaXN0LnNsaWNlKHRvU2hpZnRTdGFydENhY2hlUHRyKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGxpc3QgY2FjaGUgaW5kZXhlcyBhbmQgaXRlbXMgdG8gcmVwbGFjZSBvciByZW1vdmUgLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjYWNoZSBvdXRwdXRzXG4gICAgICAgIC8vIGZvciBpbnNlcnQsIHRoZSByYW5nZSBiZWluZyBpbnNlcnRlZDsgZm9yIHJlbW92ZSwgYW55IHRhaWwgY3JhZGxlIGl0ZW1zIGFiYW5kb25lZFxuICAgICAgICBsZXQgY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCA9IFtdLCAvLyBmb3IgaW5zZXJ0LCB0aGUgcmFuZ2UgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCA9IFtdLCAvLyBmb3IgcmVtb3ZlLCB0aGUgcmFuZ2UgYmVpbmcgcmVtb3ZlZFxuICAgICAgICAgICAgY2FjaGVJdGVtc1RvUmVtb3ZlTGlzdCA9IFtdIC8vIGZvciByZW1vdmUsIGRlcml2ZWQgZnJvbSB0aGUgcHJldmlvdXNcblxuICAgICAgICBpZiAoaXNJbnNlcnRpbmcpIHtcblxuICAgICAgICAgICAgY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCA9IGNhY2hlUmFuZ2VJbmRleGVzTGlzdFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGlzUmVtb3ZpbmdcblxuICAgICAgICAgICAgY2FjaGVJbmRleGVzVG9SZW1vdmVMaXN0ID0gY2FjaGVSYW5nZUluZGV4ZXNMaXN0XG5cbiAgICAgICAgICAgIC8vIGdldCBjYWNoZUl0ZW1zVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVJdGVtc1RvUmVtb3ZlTGlzdC5wdXNoKGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBjb25kdWN0IGNhY2hlIG9wZXJhdGlvbnM7IGNhcHR1cmUgbGlzdCBvZiBzaGlmdGVkIGluZGV4ZXMgLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGluY3JlbWVudCBoaWdoZXIgZnJvbSB0b3Agb2YgbGlzdCB0byBwcmVzZXJ2ZSBsb3dlciB2YWx1ZXMgZm9yIHN1YnNlcXVlbnQgaW5jcmVtZW50XG4gICAgICAgIGlmIChpc0luc2VydGluZykgY2FjaGVUb1NoaWZ0SW5kZXhlc0xpc3QucmV2ZXJzZSgpIFxuXG4gICAgICAgIGNvbnN0IGNhY2hlSW5kZXhlc1NoaWZ0ZWRMaXN0ID0gW10gLy8gdHJhY2sgc2hpZnRlZCBpbmRleGVzXG4gICAgICAgIGNvbnN0IGNhY2hlSW5kZXhlc1RyYW5zZmVycmVkU2V0ID0gbmV3IFNldCgpIC8vIG9idGFpbiBsaXN0IG9mIG9ycGhhbmVkIGluZGV4ZXNcblxuICAgICAgICAvLyBmdW5jdGlvbiBtb2RpZnkgaW5kZXgtdG8taXRlbWlkIG1hcCwgYW5kIG1ldGFkYXRhIG1hcCwgZm9yIGluZGV4IHNoaWZ0c1xuICAgICAgICBjb25zdCBwcm9jZXNzSW5kZXhGbiA9IGluZGV4ID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgcmFuZ2VpbmNyZW1lbnRcblxuICAgICAgICAgICAgaWYgKGlzUmVtb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBjYWNoZUluZGV4ZXNUcmFuc2ZlcnJlZFNldC5hZGQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY2FjaGVJbmRleGVzVHJhbnNmZXJyZWRTZXQuZGVsZXRlKG5ld0luZGV4KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgY2FjaGVJbmRleGVzU2hpZnRlZExpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FsayB0aHJvdWdoIGl0ZW1zIHRvIHNoaWZ0XG4gICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0LmZvckVhY2gocHJvY2Vzc0luZGV4Rm4pXG5cbiAgICAgICAgLy8gZGVsZXRlIHJlbWFpbmluZyBpbmRleGVzIGFuZCBpdGVtcyBub3cgZHVwbGljYXRlczsgdHJhY2sgcG9ydGFsIGRhdGEgdG8gcmVtb3ZlIGFmdGVyIGNyYWRsZSB1cGRhdGVkXG5cbiAgICAgICAgY29uc3QgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0ID0gW10gLy8gaG9sZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBhZnRlciBjcmFkbGUgc3luY2hcbiAgICAgICAgbGV0IGNhY2hlSW5kZXhlc1JlbW92ZWRMaXN0ID0gW11cblxuICAgICAgICBpZiAoaXNJbnNlcnRpbmcpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjYWNoZUluZGV4ZXNUb1JlcGxhY2VMaXN0KSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBpc1JlbW92aW5nXG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbUlEIG9mIGNhY2hlSXRlbXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IG1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0LnB1c2goe2l0ZW1JRCwgcGFydGl0aW9uSUR9KVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWJhbmRvbmVkIGluZGV4ZXMgZnJvbSByZW1vdmUgcHJvY2Vzc1xuICAgICAgICAgICAgY29uc3Qgb3JwaGFuZWRJbmRleGVzVHJhbnNmZXJyZWRMaXN0ID0gQXJyYXkuZnJvbShjYWNoZUluZGV4ZXNUcmFuc2ZlcnJlZFNldClcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBvcnBoYW5lZEluZGV4ZXNUcmFuc2ZlcnJlZExpc3QpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlSW5kZXhlc1JlbW92ZWRMaXN0ID0gY2FjaGVJbmRleGVzVG9SZW1vdmVMaXN0LmNvbmNhdChvcnBoYW5lZEluZGV4ZXNUcmFuc2ZlcnJlZExpc3QpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luc2VydGluZykgY2FjaGVJbmRleGVzU2hpZnRlZExpc3QucmV2ZXJzZSgpIC8vIHJldHVybiB0byBhc2NlbmRpbmcgb3JkZXJcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0gcmV0dXJucyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXR1cm4gdmFsdWVzIGZvciBjYWxsZXIgdG8gc2VuZCB0byBjb250ZW50aGFuZGxlciBmb3IgY3JhZGxlIHN5bmNocm9uaXphdGlvblxuICAgICAgICByZXR1cm4gW3N0YXJ0Q2hhbmdlSW5kZXgsIHJhbmdlaW5jcmVtZW50LCBjYWNoZUluZGV4ZXNTaGlmdGVkTGlzdCwgY2FjaGVJbmRleGVzUmVtb3ZlZExpc3QsIGNhY2hlSW5kZXhlc1RvUmVwbGFjZUxpc3QsIHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdF1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBJTkRJVklEVUFMIFBPUlRBTCBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1c2VkIGZvciBzaXplIGNhbGN1bGF0aW9uIGluIHBhcmVDYWNoZVRvTWF4XG4gICAgLy8gcmVnaXN0ZXJzIGluZGV4ZXMgd2hlbiByZXF1ZXN0ZWQgYnV0IGJlZm9yZSByZXRyaWV2ZWQgYW5kIGVudGVyZWQgaW50byBjYWNoZVxuICAgIHJlZ2lzdGVyUGVuZGluZ1BvcnRhbChpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuYWRkKGluZGV4KVxuXG4gICAgfVxuXG4gICAgdW5yZWdpc3RlclBlbmRpbmdQb3J0YWwoaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmRlbGV0ZShpbmRleClcblxuICAgIH1cblxuICAgIGdldE5ld0l0ZW1JRCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxJdGVtSUQrK1xuXG4gICAgfVxuXG4gICAgLy8gZ2V0IG5ldyBvciBleGlzdGluZyBpdGVtSUQgZm9yIGNvbnRlbnRmdW5jdGlvbnMuY3JlYXRlQ2VsbEZyYW1lXG4gICAgZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRChpbmRleCkge1xuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gXG4gICAgICAgICAgICAoaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKT9cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgKHRoaXMuZ2V0TmV3SXRlbUlEKCkpXG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JRFxuXG4gICAgfVxuXG4gICAgIC8vIGNyZWF0ZSBuZXcgcG9ydGFsXG4gICAgYXN5bmMgY3JlYXRlUG9ydGFsKGNvbXBvbmVudCwgaW5kZXgsIGl0ZW1JRCwgc2Nyb2xsZXJQcm9wZXJ0aWVzLCBpc1ByZWxvYWQgPSBmYWxzZSkge1xuXG4gICAgICAgIHRoaXMudW5yZWdpc3RlclBlbmRpbmdQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgb3JpZW50YXRpb24gfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSUQgPSBhd2FpdCB0aGlzLmZpbmRQYXJ0aXRpb25XaXRoUm9vbSgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsID0gXG4gICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9ICdwb3J0YWx3cmFwcGVyJyBrZXkgPSB7aXRlbUlEfSBkYXRhLWl0ZW1pZCA9IHtpdGVtSUR9IGRhdGEtaW5kZXggPSB7aW5kZXh9PlxuICAgICAgICAgICAgICAgIDxJblBvcnRhbCBrZXkgPSB7aXRlbUlEfSBub2RlID0ge3BvcnRhbE5vZGV9ID4geyBjb21wb25lbnQgfSA8L0luUG9ydGFsPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgdGhpcy5hZGRQYXJ0aXRpb25Qb3J0YWwocGFydGl0aW9uSUQsIGl0ZW1JRCwgcG9ydGFsKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgcG9ydGFsTm9kZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbUlELFxuICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgcGFydGl0aW9uSUQsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuc2V0KGl0ZW1JRCwgcG9ydGFsTWV0YWRhdGEpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgIGlmICghaXNQcmVsb2FkKSB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICByZXR1cm4gcG9ydGFsTWV0YWRhdGFcblxuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHByZWxvYWRpbmcgbmV3IGl0ZW1cbiAgICBwcml2YXRlIGFzeW5jIHByZWxvYWRJdGVtKFxuICAgICAgICBpbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0LFxuICAgICAgICBzY3JvbGxlcklEXG4gICAgKSB7XG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gdGhpcy5nZXROZXdJdGVtSUQoKVxuXG4gICAgICAgIGxldCByZXR1cm52YWx1ZSwgdXNlcmNvbnRlbnQsIGVycm9yXG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzLmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQodXNlcmNvbnRlbnQsIHtzY3JvbGxlclByb3BlcnRpZXN9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29uc3QgcG9ydGFsRGF0YSA9IFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUG9ydGFsKGNvbnRlbnQsIGluZGV4LCBpdGVtSUQsIHNjcm9sbGVyUHJvcGVydGllcywgdHJ1ZSkgLy8gdHJ1ZSA9IGlzUHJlbG9hZFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBlcnJvcilcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IG51bGw7IGxhc3QgaXRlbSBpbiBsaXN0XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBuZXcgRXJyb3IoJ2VuZCBvZiBsaXN0JykpXG5cbiAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdChpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBhIHBvcnRhbCBsaXN0IGl0ZW1cbiAgICAvLyBhY2NlcHRzIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICBkZWxldGVQb3J0YWwoaW5kZXgsIGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuXG4gICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBcbiAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShpbmRleCkpP1xuICAgICAgICAgICAgICAgIFtpbmRleF06XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIFxuICAgICAgICB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgeyByZW1vdmVQYXJ0aXRpb25Qb3J0YWwgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCBkZWxldGVMaXN0ID0gW11cblxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4QXJyYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChpdGVtSUQgPT09IHVuZGVmaW5lZCkgY29udGludWUgLy8gYXN5bmMgbWlzbWF0Y2hcblxuICAgICAgICAgICAgZGVsZXRlTGlzdC5wdXNoKHtpbmRleCxpdGVtSUR9KVxuICAgICAgICAgICAgY29uc3QgeyBwYXJ0aXRpb25JRCB9ID0gbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgcmVtb3ZlUGFydGl0aW9uUG9ydGFsKHBhcnRpdGlvbklELGl0ZW1JRClcblxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2sgJiYgZGVsZXRlTGlzdENhbGxiYWNrKGRlbGV0ZUxpc3QpXG5cbiAgICB9XG5cbiAgICAvLyBxdWVyeSBleGlzdGVuY2Ugb2YgYSBwb3J0YWwgbGlzdCBpdGVtXG4gICAgaGFzUG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuaGFzKGl0ZW1JRClcblxuICAgIH1cblxuICAgIGdldFBvcnRhbE1ldGFkYXRhKGl0ZW1JRCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1BvcnRhbChpdGVtSUQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBmdW5jdGlvbiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBnZXQgYSByZWFjdC1yZXZlcnNlLXBvcnRhbCBJblBvcnRhbCBjb21wb25lbnQsIHdpdGggaXRzIG1ldGFkYXRhXG4vLyB3aXRoIHVzZXIgY29udGVudCBhbmQgY29udGFpbmVyXG4vLyBzZWUgYWxzbyBzb21lIHN0eWxlcyBzZXQgaW4gQ2VsbEZyYW1lXG5cbmNvbnN0IGNyZWF0ZVBvcnRhbE5vZGUgPSAoaW5kZXgsIGl0ZW1JRCkgPT4ge1xuXG4gICAgY29uc3QgcG9ydGFsTm9kZSA9IGNyZWF0ZUh0bWxQb3J0YWxOb2RlKClcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcnRhbE5vZGUuZWxlbWVudFxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBjb250YWluZXIuZGF0YXNldC50eXBlID0gJ2NvbnRlbnRlbnZlbG9wZSdcbiAgICBjb250YWluZXIuZGF0YXNldC5pbmRleCA9IGluZGV4XG4gICAgY29udGFpbmVyLmRhdGFzZXQuY2FjaGVpdGVtaWQgPSBpdGVtSURcblxuICAgIHJldHVybiBwb3J0YWxOb2RlXG5cbn0gICAgIFxuIl0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImV4cG9ydHMiLCJPcCIsIk9iamVjdCIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJkZXNjIiwidmFsdWUiLCIkU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJfaW52b2tlIiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsIl9fYXdhaXQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsImRvbmUiLCJtZXRob2ROYW1lIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaW5mbyIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmFibGUiLCJpdGVyYXRvck1ldGhvZCIsImlzTmFOIiwibGVuZ3RoIiwiaSIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJpdGVyIiwia2V5cyIsInZhbCIsIm9iamVjdCIsInJldmVyc2UiLCJwb3AiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiX2kiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwiQXJyYXkiLCJpc0FycmF5IiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIkYiLCJzIiwibiIsImUiLCJfZTIiLCJmIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsInN0ZXAiLCJfZTMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwicmVzIiwiTnVtYmVyIiwicmVhY3RfMSIsIl9faW1wb3J0RGVmYXVsdCIsInJlcXVpcmUiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwiQ2FjaGVQYXJ0aXRpb25fMSIsIkNhY2hlSGFuZGxlciIsInNjcm9sbGVySUQiLCJsaXN0c2l6ZVJlZiIsIkNBQ0hFX1BBUlRJVElPTl9TSVpFIiwiX3RoaXMiLCJnbG9iYWxJdGVtSUQiLCJnbG9iYWxQYXJ0aXRpb25JRCIsImNhY2hlUHJvcHMiLCJtZXRhZGF0YU1hcCIsIk1hcCIsImluZGV4VG9JdGVtSURNYXAiLCJyZXF1ZXN0ZWRTZXQiLCJTZXQiLCJwYXJ0aXRpb25NZXRhZGF0YU1hcCIsInBhcnRpdGlvbk1hcCIsInBhcnRpdGlvblJlbmRlckxpc3QiLCJwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUiLCJwYXJ0aXRpb25Nb2RpZmllZFNldCIsInBhcnRpdGlvblB0ciIsInJlbmRlclBhcnRpdGlvblJlcG8iLCJhZGRQYXJ0aXRpb24iLCJwYXJ0aXRpb25JRCIsInNldCIsInBvcnRhbE1hcCIsIm1hcGNvdW50IiwicG9ydGFsUmVuZGVyTGlzdCIsIm1vZGlmaWVkIiwiZm9yY2VVcGRhdGUiLCJyZXNvbHZlZnVuYyIsImN1cnJlbnQiLCJwcm9taXNlIiwiY2FsbGJhY2siLCJjcmVhdGVFbGVtZW50IiwiYWRkUGFydGl0aW9uUG9ydGFsIiwiaXRlbUlEIiwicG9ydGFsIiwicGFydGl0aW9uTWV0YWRhdGEiLCJnZXQiLCJhZGQiLCJyZW1vdmVQYXJ0aXRpb25Qb3J0YWwiLCJyZW5kZXJQYXJ0aXRpb24iLCJyZW5kZXJQb3J0YWxMaXN0cyIsInNpemUiLCJjbGVhciIsImNsZWFyQ2FjaGUiLCJjaGFuZ2VDYWNoZUxpc3RzaXplIiwibmV3bGlzdHNpemUiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwicG9ydGFsSW5kZXhNYXAiLCJtYXBrZXlzTGlzdCIsInNvcnQiLCJhIiwiYiIsImhpZ2hlc3RpbmRleCIsImF0IiwicGFyZWxpc3QiLCJmaWx0ZXIiLCJpbmRleCIsImRlbGV0ZVBvcnRhbCIsIm1hdGNoQ2FjaGVUb0NyYWRsZSIsImNyYWRsZUluZGV4TGlzdCIsIm1hcGtleXMiLCJkZWxrZXlzIiwiaW5jbHVkZXMiLCJwYXJlQ2FjaGVUb01heCIsImNhY2hlTWF4IiwiYXJndW1lbnRzIiwibW9kZWxMZW5ndGgiLCJtYXgiLCJNYXRoIiwibWFwa2V5c2xpc3QiLCJyZXF1ZXN0ZWRrZXlzIiwiY29uY2F0IiwibWFwTGVuZ3RoIiwicGFyZWNvdW50IiwiaGVhZGluZGV4IiwidGFpbGluZGV4IiwiaGVhZHBvcyIsImluZGV4T2YiLCJ0YWlscG9zIiwiaGVhZHJvb20iLCJ0YWlscm9vbSIsInBhcmVyb29tIiwiaGVhZHBhcmVjb3VudCIsImZsb29yIiwidGFpbHBhcmVjb3VudCIsImhlYWRsaXN0IiwidGFpbGxpc3QiLCJkZWxMaXN0IiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJjcmFkbGVMaXN0TGVuZ3RoIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiX3RoaXMkY2FjaGVQcm9wcyIsImZpbmRQYXJ0aXRpb25XaXRoUm9vbSIsIl9jb250ZXh0IiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfc3RlcCR2YWx1ZSIsInQwIiwiX2NhbGxlZSIsInByZWxvYWQiLCJmaW5hbENhbGxiYWNrIiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsIl90aGlzMiIsImNyYWRsZVBhcmFtZXRlcnMiLCJzY3JvbGxlclByb3BlcnRpZXNSZWYiLCJfY3JhZGxlUGFyYW1ldGVycyRoYW4iLCJoYW5kbGVyc1JlZiIsInN0YXRlSGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJnZXRJdGVtIiwibGlzdHNpemUiLCJwcm9taXNlcyIsImNhY2hlU2l6ZSIsIm1pbiIsInByZWxvYWRzaXplIiwiYnJlYWtsb29wIiwibWF4TGlzdHNpemVJbnRlcnJ1cHQiLCJpc01vdW50ZWRSZWYiLCJfc2VydmljZUhhbmRsZXIkY2FsbGIiLCJjYWxsYmFja3MiLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsIml0ZW1FeGNlcHRpb25DYWxsYmFjayIsImhhcyIsInByZWxvYWRJdGVtIiwiYWxsU2V0dGxlZCIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsImNyYWRsZU1hcCIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJnZXRDYWNoZUl0ZW1NYXAiLCJjYWNoZWxpc3QiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX3N0ZXAzJHZhbHVlIiwiY29tcG9uZW50IiwibW92ZUluZGV4IiwidG9sb3dpbmRleCIsImZyb21sb3dpbmRleCIsImZyb21oaWdoaW5kZXgiLCJfdGhpcyRjYWNoZVByb3BzMiIsIm1vdmVibG9ja3NpemUiLCJtb3ZlaW5jcmVtZW50IiwidG9oaWdoaW5kZXgiLCJtb3ZlZGlyZWN0aW9uIiwib3JkZXJlZGluZGV4bGlzdCIsInJldmVyc2VvcmRlcmVkaW5kZXhsaXN0IiwidG9sb3dpbmRleHB0ciIsImZpbmRJbmRleCIsImZyb21sb3dpbmRleHB0ciIsInRvaGlnaGluZGV4cHRyIiwiZnJvbWhpZ2hpbmRleHB0ciIsImNhY2hlbGlzdGNvdW50IiwibGlzdHRvcHJvY2Vzc2Zvcm1vdmUiLCJwcm9jZXNzdG9tb3ZlTWFwIiwiY2FwdHVyZW1vdmVpbmRleEZuIiwibGlzdHRvcHJvY2Vzc2ZvcmRpc3BsYWNlIiwicHJvY2Vzc2VkZGlzcGxhY2VMaXN0IiwicHJvY2Vzc3NkaXNwbGFjZWluZGV4Rm4iLCJuZXdJbmRleCIsInByb2Nlc3NlZG1vdmVMaXN0IiwicHJvY2Vzc21vdmVpbmRleEZuIiwicHJvY2Vzc2VkSW5kZXhlcyIsImluc2VydFJlbW92ZUluZGV4IiwiaGlnaHJhbmdlIiwiaW5jcmVtZW50IiwiaXNJbnNlcnRpbmciLCJpc1JlbW92aW5nIiwiZW1wdHlyZXR1cm4iLCJfdGhpcyRjYWNoZVByb3BzMyIsIm9yZGVyZWRDYWNoZUluZGV4TGlzdCIsImhpZ2hyYW5nZWluZGV4IiwibG93cmFuZ2VpbmRleCIsImRpZmYiLCJyYW5nZWNvdW50IiwicmFuZ2VpbmNyZW1lbnQiLCJzdGFydENoYW5nZUluZGV4IiwidG9TaGlmdFN0YXJ0SW5kZXgiLCJ0b1NoaWZ0U3RhcnRDYWNoZVB0ciIsImxvd0NhY2hlUmFuZ2VQdHIiLCJyZXZlcnNlQ2FjaGVJbmRleExpc3QiLCJoaWdoQ2FjaGVSYW5nZVB0ciIsImNhY2hlUmFuZ2VJbmRleGVzTGlzdCIsImNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0IiwiY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCIsImNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCIsImNhY2hlSXRlbXNUb1JlbW92ZUxpc3QiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiY2FjaGVJbmRleGVzU2hpZnRlZExpc3QiLCJjYWNoZUluZGV4ZXNUcmFuc2ZlcnJlZFNldCIsInByb2Nlc3NJbmRleEZuIiwicG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0IiwiY2FjaGVJbmRleGVzUmVtb3ZlZExpc3QiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwiX2l0ZXJhdG9yNiIsIl9zdGVwNiIsIl9tZXRhZGF0YU1hcCRnZXQiLCJvcnBoYW5lZEluZGV4ZXNUcmFuc2ZlcnJlZExpc3QiLCJfaTIiLCJfb3JwaGFuZWRJbmRleGVzVHJhbnMiLCJyZWdpc3RlclBlbmRpbmdQb3J0YWwiLCJ1bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbCIsImdldE5ld0l0ZW1JRCIsImdldE5ld09yRXhpc3RpbmdJdGVtSUQiLCJjcmVhdGVQb3J0YWwiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJpc1ByZWxvYWQiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIiLCJsYXlvdXQiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwib3JpZW50YXRpb24iLCJwb3J0YWxOb2RlIiwiY3JlYXRlUG9ydGFsTm9kZSIsIl9jb250ZXh0MiIsIkluUG9ydGFsIiwibm9kZSIsInBvcnRhbE1ldGFkYXRhIiwiX2NhbGxlZTIiLCJfY29udGV4dDMiLCJ1c2VyY29udGVudCIsInJldHVybnZhbHVlIiwiaXNWYWxpZEVsZW1lbnQiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwiX2NhbGxlZTMiLCJpbmRleEFycmF5IiwiX3RoaXMkY2FjaGVQcm9wczQiLCJkZWxldGVMaXN0IiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9tZXRhZGF0YU1hcCRnZXQyIiwiaGFzUG9ydGFsIiwiZ2V0UG9ydGFsTWV0YWRhdGEiLCJjcmVhdGVIdG1sUG9ydGFsTm9kZSIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzdHlsZSIsIm92ZXJmbG93IiwiZGF0YXNldCIsImNhY2hlaXRlbWlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/portalcache/cachehandler.tsx\n')},"./node_modules/react-error-boundary/dist/react-error-boundary.module.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ErrorBoundary": () => (/* binding */ $44d7e150ebc754d2$export$e926676385687eaf),\n/* harmony export */   "ErrorBoundaryContext": () => (/* binding */ $ebb31c7feaa4405e$export$b16d9fb1a22de840),\n/* harmony export */   "useErrorBoundary": () => (/* binding */ $7c3c25b3f398a9d6$export$c052f6604b7d51fe),\n/* harmony export */   "withErrorBoundary": () => (/* binding */ $62ff477d53f02a5b$export$f0c7a449e0cfaec7)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $44d7e150ebc754d2$exports = {};\n\n$parcel$export($44d7e150ebc754d2$exports, "ErrorBoundary", () => $44d7e150ebc754d2$export$e926676385687eaf);\n\nvar $ebb31c7feaa4405e$exports = {};\n\n$parcel$export($ebb31c7feaa4405e$exports, "ErrorBoundaryContext", () => $ebb31c7feaa4405e$export$b16d9fb1a22de840);\n\nconst $ebb31c7feaa4405e$export$b16d9fb1a22de840 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\n\nconst $44d7e150ebc754d2$var$initialState = {\n    didCatch: false,\n    error: null\n};\nclass $44d7e150ebc754d2$export$e926676385687eaf extends (0, react__WEBPACK_IMPORTED_MODULE_0__.Component) {\n    state = $44d7e150ebc754d2$var$initialState;\n    static getDerivedStateFromError(error) {\n        return {\n            didCatch: true,\n            error: error\n        };\n    }\n    resetErrorBoundary = (...args)=>{\n        const { error: error  } = this.state;\n        if (error !== null) {\n            this.props.onReset?.({\n                args: args,\n                reason: "imperative-api"\n            });\n            this.setState($44d7e150ebc754d2$var$initialState);\n        }\n    };\n    componentDidCatch(error, info) {\n        this.props.onError?.(error, info);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { didCatch: didCatch  } = this.state;\n        const { resetKeys: resetKeys  } = this.props;\n        // There\'s an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n        // we\'d end up resetting the error boundary immediately.\n        // This would likely trigger a second error to be thrown.\n        // So we make sure that we don\'t check the resetKeys on the first call of cDU after the error is set.\n        if (didCatch && prevState.error !== null && $44d7e150ebc754d2$var$hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n            this.props.onReset?.({\n                next: resetKeys,\n                prev: prevProps.resetKeys,\n                reason: "keys"\n            });\n            this.setState($44d7e150ebc754d2$var$initialState);\n        }\n    }\n    render() {\n        const { children: children , fallbackRender: fallbackRender , FallbackComponent: FallbackComponent , fallback: fallback  } = this.props;\n        const { didCatch: didCatch , error: error  } = this.state;\n        let childToRender = children;\n        if (didCatch) {\n            const props = {\n                error: error,\n                resetErrorBoundary: this.resetErrorBoundary\n            };\n            if ((0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(fallback)) childToRender = fallback;\n            else if (typeof fallbackRender === "function") childToRender = fallbackRender(props);\n            else if (FallbackComponent) childToRender = (0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FallbackComponent, props);\n            else throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");\n        }\n        return (0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)((0, $ebb31c7feaa4405e$export$b16d9fb1a22de840).Provider, {\n            value: {\n                didCatch: didCatch,\n                error: error,\n                resetErrorBoundary: this.resetErrorBoundary\n            }\n        }, childToRender);\n    }\n}\nfunction $44d7e150ebc754d2$var$hasArrayChanged(a = [], b = []) {\n    return a.length !== b.length || a.some((item, index)=>!Object.is(item, b[index]));\n}\n\n\n\nvar $7c3c25b3f398a9d6$exports = {};\n\n$parcel$export($7c3c25b3f398a9d6$exports, "useErrorBoundary", () => $7c3c25b3f398a9d6$export$c052f6604b7d51fe);\n\nfunction $75c9d331f9c1ed1a$export$f20aa86254872370(value) {\n    if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") throw new Error("ErrorBoundaryContext not found");\n    return true;\n}\n\n\n\nfunction $7c3c25b3f398a9d6$export$c052f6604b7d51fe() {\n    const context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ebb31c7feaa4405e$export$b16d9fb1a22de840));\n    (0, $75c9d331f9c1ed1a$export$f20aa86254872370)(context);\n    const [state, setState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        error: null,\n        hasError: false\n    });\n    const memoized = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resetBoundary: ()=>{\n                context?.resetErrorBoundary();\n                setState({\n                    error: null,\n                    hasError: false\n                });\n            },\n            showBoundary: (error)=>setState({\n                    error: error,\n                    hasError: true\n                })\n        }), [\n        context?.resetErrorBoundary\n    ]);\n    if (state.hasError) throw state.error;\n    return memoized;\n}\n\n\nvar $62ff477d53f02a5b$exports = {};\n\n$parcel$export($62ff477d53f02a5b$exports, "withErrorBoundary", () => $62ff477d53f02a5b$export$f0c7a449e0cfaec7);\n\n\nfunction $62ff477d53f02a5b$export$f0c7a449e0cfaec7(component, errorBoundaryProps) {\n    const Wrapped = (0, react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>(0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)((0, $44d7e150ebc754d2$export$e926676385687eaf), errorBoundaryProps, (0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)(component, {\n            ...props,\n            ref: ref\n        })));\n    // Format for display in DevTools\n    const name = component.displayName || component.name || "Unknown";\n    Wrapped.displayName = `withErrorBoundary(${name})`;\n    return Wrapped;\n}\n\n\nvar $81c1b644006d48ec$exports = {};\n\n\n"use client";\n\n\n\n//# sourceMappingURL=react-error-boundary.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS5tb2R1bGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFTOztBQUVyUztBQUNBLCtCQUErQixxREFBcUQ7QUFDcEY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzREFBc0QsZ0RBQW9COzs7QUFHMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNENBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtSEFBbUg7QUFDbkksZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQXFCO0FBQ3pDO0FBQ0EsNERBQTRELGdEQUFvQjtBQUNoRjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0Esd0JBQXdCLDZDQUFpQjtBQUN6QztBQUNBLGtDQUFrQywyQ0FBZTtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QiwwQ0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7QUFHQTtBQUNBLHdCQUF3Qiw2Q0FBaUIsb0JBQW9CLGdEQUFvQiwwRUFBMEUsZ0RBQW9CO0FBQy9LO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR3NRO0FBQ3RRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1lcnJvci1ib3VuZGFyeS9kaXN0L3JlYWN0LWVycm9yLWJvdW5kYXJ5Lm1vZHVsZS5qcz83NDlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNWYWxpZEVsZW1lbnQgYXMgJGhnVVcxJGlzVmFsaWRFbGVtZW50LCBjcmVhdGVFbGVtZW50IGFzICRoZ1VXMSRjcmVhdGVFbGVtZW50LCBDb21wb25lbnQgYXMgJGhnVVcxJENvbXBvbmVudCwgY3JlYXRlQ29udGV4dCBhcyAkaGdVVzEkY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCBhcyAkaGdVVzEkdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJGhnVVcxJHVzZVN0YXRlLCB1c2VNZW1vIGFzICRoZ1VXMSR1c2VNZW1vLCBmb3J3YXJkUmVmIGFzICRoZ1VXMSRmb3J3YXJkUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuZnVuY3Rpb24gJHBhcmNlbCRleHBvcnQoZSwgbiwgdiwgcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge2dldDogdiwgc2V0OiBzLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbn1cbnZhciAkNDRkN2UxNTBlYmM3NTRkMiRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCQ0NGQ3ZTE1MGViYzc1NGQyJGV4cG9ydHMsIFwiRXJyb3JCb3VuZGFyeVwiLCAoKSA9PiAkNDRkN2UxNTBlYmM3NTRkMiRleHBvcnQkZTkyNjY3NjM4NTY4N2VhZik7XG5cbnZhciAkZWJiMzFjN2ZlYWE0NDA1ZSRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCRlYmIzMWM3ZmVhYTQ0MDVlJGV4cG9ydHMsIFwiRXJyb3JCb3VuZGFyeUNvbnRleHRcIiwgKCkgPT4gJGViYjMxYzdmZWFhNDQwNWUkZXhwb3J0JGIxNmQ5ZmIxYTIyZGU4NDApO1xuXG5jb25zdCAkZWJiMzFjN2ZlYWE0NDA1ZSRleHBvcnQkYjE2ZDlmYjFhMjJkZTg0MCA9ICgwLCAkaGdVVzEkY3JlYXRlQ29udGV4dCkobnVsbCk7XG5cblxuY29uc3QgJDQ0ZDdlMTUwZWJjNzU0ZDIkdmFyJGluaXRpYWxTdGF0ZSA9IHtcbiAgICBkaWRDYXRjaDogZmFsc2UsXG4gICAgZXJyb3I6IG51bGxcbn07XG5jbGFzcyAkNDRkN2UxNTBlYmM3NTRkMiRleHBvcnQkZTkyNjY3NjM4NTY4N2VhZiBleHRlbmRzICgwLCAkaGdVVzEkQ29tcG9uZW50KSB7XG4gICAgc3RhdGUgPSAkNDRkN2UxNTBlYmM3NTRkMiR2YXIkaW5pdGlhbFN0YXRlO1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZENhdGNoOiB0cnVlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc2V0RXJyb3JCb3VuZGFyeSA9ICguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCB7IGVycm9yOiBlcnJvciAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2V0Py4oe1xuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgkNDRkN2UxNTBlYmM3NTRkMiR2YXIkaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkVycm9yPy4oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBkaWRDYXRjaDogZGlkQ2F0Y2ggIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IHJlc2V0S2V5czogcmVzZXRLZXlzICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgaWYgdGhlIHRoaW5nIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvciBoYXBwZW5zIHRvICphbHNvKiBiZSBpbiB0aGUgcmVzZXRLZXlzIGFycmF5LFxuICAgICAgICAvLyB3ZSdkIGVuZCB1cCByZXNldHRpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAgICAgLy8gU28gd2UgbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhlIHJlc2V0S2V5cyBvbiB0aGUgZmlyc3QgY2FsbCBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldC5cbiAgICAgICAgaWYgKGRpZENhdGNoICYmIHByZXZTdGF0ZS5lcnJvciAhPT0gbnVsbCAmJiAkNDRkN2UxNTBlYmM3NTRkMiR2YXIkaGFzQXJyYXlDaGFuZ2VkKHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNldD8uKHtcbiAgICAgICAgICAgICAgICBuZXh0OiByZXNldEtleXMsXG4gICAgICAgICAgICAgICAgcHJldjogcHJldlByb3BzLnJlc2V0S2V5cyxcbiAgICAgICAgICAgICAgICByZWFzb246IFwia2V5c1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJDQ0ZDdlMTUwZWJjNzU0ZDIkdmFyJGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBjaGlsZHJlbiAsIGZhbGxiYWNrUmVuZGVyOiBmYWxsYmFja1JlbmRlciAsIEZhbGxiYWNrQ29tcG9uZW50OiBGYWxsYmFja0NvbXBvbmVudCAsIGZhbGxiYWNrOiBmYWxsYmFjayAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZGlkQ2F0Y2g6IGRpZENhdGNoICwgZXJyb3I6IGVycm9yICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGNoaWxkVG9SZW5kZXIgPSBjaGlsZHJlbjtcbiAgICAgICAgaWYgKGRpZENhdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzZXRFcnJvckJvdW5kYXJ5OiB0aGlzLnJlc2V0RXJyb3JCb3VuZGFyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoMCwgJGhnVVcxJGlzVmFsaWRFbGVtZW50KShmYWxsYmFjaykpIGNoaWxkVG9SZW5kZXIgPSBmYWxsYmFjaztcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gXCJmdW5jdGlvblwiKSBjaGlsZFRvUmVuZGVyID0gZmFsbGJhY2tSZW5kZXIocHJvcHMpO1xuICAgICAgICAgICAgZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIGNoaWxkVG9SZW5kZXIgPSAoMCwgJGhnVVcxJGNyZWF0ZUVsZW1lbnQpKEZhbGxiYWNrQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcInJlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsICRoZ1VXMSRjcmVhdGVFbGVtZW50KSgoMCwgJGViYjMxYzdmZWFhNDQwNWUkZXhwb3J0JGIxNmQ5ZmIxYTIyZGU4NDApLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGRpZENhdGNoOiBkaWRDYXRjaCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzZXRFcnJvckJvdW5kYXJ5OiB0aGlzLnJlc2V0RXJyb3JCb3VuZGFyeVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZFRvUmVuZGVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNDRkN2UxNTBlYmM3NTRkMiR2YXIkaGFzQXJyYXlDaGFuZ2VkKGEgPSBbXSwgYiA9IFtdKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoKGl0ZW0sIGluZGV4KT0+IU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSkpO1xufVxuXG5cblxudmFyICQ3YzNjMjViM2YzOThhOWQ2JGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDdjM2MyNWIzZjM5OGE5ZDYkZXhwb3J0cywgXCJ1c2VFcnJvckJvdW5kYXJ5XCIsICgpID0+ICQ3YzNjMjViM2YzOThhOWQ2JGV4cG9ydCRjMDUyZjY2MDRiN2Q1MWZlKTtcblxuZnVuY3Rpb24gJDc1YzlkMzMxZjljMWVkMWEkZXhwb3J0JGYyMGFhODYyNTQ4NzIzNzAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUuZGlkQ2F0Y2ggIT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB2YWx1ZS5yZXNldEVycm9yQm91bmRhcnkgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JCb3VuZGFyeUNvbnRleHQgbm90IGZvdW5kXCIpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5cblxuZnVuY3Rpb24gJDdjM2MyNWIzZjM5OGE5ZDYkZXhwb3J0JGMwNTJmNjYwNGI3ZDUxZmUoKSB7XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCAkaGdVVzEkdXNlQ29udGV4dCkoKDAsICRlYmIzMWM3ZmVhYTQ0MDVlJGV4cG9ydCRiMTZkOWZiMWEyMmRlODQwKSk7XG4gICAgKDAsICQ3NWM5ZDMzMWY5YzFlZDFhJGV4cG9ydCRmMjBhYTg2MjU0ODcyMzcwKShjb250ZXh0KTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9ICgwLCAkaGdVVzEkdXNlU3RhdGUpKHtcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGhhc0Vycm9yOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IG1lbW9pemVkID0gKDAsICRoZ1VXMSR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHJlc2V0Qm91bmRhcnk6ICgpPT57XG4gICAgICAgICAgICAgICAgY29udGV4dD8ucmVzZXRFcnJvckJvdW5kYXJ5KCk7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3I6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0JvdW5kYXJ5OiAoZXJyb3IpPT5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3I6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KSwgW1xuICAgICAgICBjb250ZXh0Py5yZXNldEVycm9yQm91bmRhcnlcbiAgICBdKTtcbiAgICBpZiAoc3RhdGUuaGFzRXJyb3IpIHRocm93IHN0YXRlLmVycm9yO1xuICAgIHJldHVybiBtZW1vaXplZDtcbn1cblxuXG52YXIgJDYyZmY0NzdkNTNmMDJhNWIkZXhwb3J0cyA9IHt9O1xuXG4kcGFyY2VsJGV4cG9ydCgkNjJmZjQ3N2Q1M2YwMmE1YiRleHBvcnRzLCBcIndpdGhFcnJvckJvdW5kYXJ5XCIsICgpID0+ICQ2MmZmNDc3ZDUzZjAyYTViJGV4cG9ydCRmMGM3YTQ0OWUwY2ZhZWM3KTtcblxuXG5mdW5jdGlvbiAkNjJmZjQ3N2Q1M2YwMmE1YiRleHBvcnQkZjBjN2E0NDllMGNmYWVjNyhjb21wb25lbnQsIGVycm9yQm91bmRhcnlQcm9wcykge1xuICAgIGNvbnN0IFdyYXBwZWQgPSAoMCwgJGhnVVcxJGZvcndhcmRSZWYpKChwcm9wcywgcmVmKT0+KDAsICRoZ1VXMSRjcmVhdGVFbGVtZW50KSgoMCwgJDQ0ZDdlMTUwZWJjNzU0ZDIkZXhwb3J0JGU5MjY2NzYzODU2ODdlYWYpLCBlcnJvckJvdW5kYXJ5UHJvcHMsICgwLCAkaGdVVzEkY3JlYXRlRWxlbWVudCkoY29tcG9uZW50LCB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIHJlZjogcmVmXG4gICAgICAgIH0pKSk7XG4gICAgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG4gICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnQubmFtZSB8fCBcIlVua25vd25cIjtcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gYHdpdGhFcnJvckJvdW5kYXJ5KCR7bmFtZX0pYDtcbiAgICByZXR1cm4gV3JhcHBlZDtcbn1cblxuXG52YXIgJDgxYzFiNjQ0MDA2ZDQ4ZWMkZXhwb3J0cyA9IHt9O1xuXG5cblwidXNlIGNsaWVudFwiO1xuXG5cbmV4cG9ydCB7JDQ0ZDdlMTUwZWJjNzU0ZDIkZXhwb3J0JGU5MjY2NzYzODU2ODdlYWYgYXMgRXJyb3JCb3VuZGFyeSwgJGViYjMxYzdmZWFhNDQwNWUkZXhwb3J0JGIxNmQ5ZmIxYTIyZGU4NDAgYXMgRXJyb3JCb3VuZGFyeUNvbnRleHQsICQ3YzNjMjViM2YzOThhOWQ2JGV4cG9ydCRjMDUyZjY2MDRiN2Q1MWZlIGFzIHVzZUVycm9yQm91bmRhcnksICQ2MmZmNDc3ZDUzZjAyYTViJGV4cG9ydCRmMGM3YTQ0OWUwY2ZhZWM3IGFzIHdpdGhFcnJvckJvdW5kYXJ5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWVycm9yLWJvdW5kYXJ5Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.module.js\n')},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InPortal": () => (/* binding */ InPortal),\n/* harmony export */   "OutPortal": () => (/* binding */ OutPortal),\n/* harmony export */   "createHtmlPortalNode": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   "createSvgPortalNode": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:Q=>{"use strict";Q.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":Q=>{"use strict";Q.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(Q){var F=__webpack_module_cache__[Q];if(void 0!==F)return F.exports;var B=__webpack_module_cache__[Q]={exports:{}};return __webpack_modules__[Q].call(B.exports,B,B.exports,__webpack_require__),B.exports}__webpack_require__.n=Q=>{var F=Q&&Q.__esModule?()=>Q.default:()=>Q;return __webpack_require__.d(F,{a:F}),F},__webpack_require__.d=(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(Q){if("object"==typeof window)return window}}(),__webpack_require__.o=(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),__webpack_require__.r=Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/InfiniteGridScroller.tsx");return __webpack_exports__})()));