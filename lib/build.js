/*! For license information please see build.js.LICENSE.txt */
!function(e,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],I):"object"==typeof exports?exports["react-infinite-grid-scroller"]=I(require("react"),require("react-dom")):e["react-infinite-grid-scroller"]=I(e.react,e["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DOMRectReadOnly": () => (/* binding */ DOMRectReadOnly)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvRE9NUmVjdFJlYWRPbmx5LmpzP2ZkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObservation": () => (/* binding */ ResizeObservation)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === \'inline\';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJGQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzPzQ0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserver\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RkFBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsdUZBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHlGQUFrQztBQUMxQztBQUNBO0FBQ0EsUUFBUSwwRkFBbUM7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlci5qcz9kMDIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n")},"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverBoxOptions": () => (/* binding */ ResizeObserverBoxOptions)\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";\n    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";\n    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLmpzP2U1NTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverController": () => (/* binding */ ResizeObserverController)\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdFQUFvQjtBQUNwRCwrQ0FBK0MsaUVBQWlCO0FBQ2hFLFlBQVksNkRBQVc7QUFDdkIsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQXNCLENBQUMsMkVBQXVCO0FBQzdFO0FBQ0EsWUFBWSw2REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9EQUFvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmpzP2YzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9IGZyb20gJy4vdXRpbHMvc2NoZWR1bGVyJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmF0aW9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZhdGlvbic7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlckRldGFpbCB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJEZXRhaWwnO1xuaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRPYnNlcnZhdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9ic2VydmF0aW9uVGFyZ2V0c1tpXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBuZXcgUmVzaXplT2JzZXJ2ZXJEZXRhaWwocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXJNYXAuc2V0KHJlc2l6ZU9ic2VydmVyLCBkZXRhaWwpO1xuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgIGZpcnN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnB1c2goZGV0YWlsKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMucHVzaChuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvcHRpb25zICYmIG9wdGlvbnMuYm94KSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgxKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIHZhciBpbmRleCA9IGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIGxhc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAxO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGFzdE9ic2VydmF0aW9uICYmIHJlc2l6ZU9ic2VydmVycy5zcGxpY2UocmVzaXplT2JzZXJ2ZXJzLmluZGV4T2YoZGV0YWlsKSwgMSk7XG4gICAgICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAob3QpIHsgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTsgfSk7XG4gICAgICAgIGRldGFpbC5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCBkZXRhaWwuYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverDetail": () => (/* binding */ ResizeObserverDetail)\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanM/NzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverEntry": () => (/* binding */ ResizeObserverEntry)\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanM/NDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n')},"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserverSize": () => (/* binding */ ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcz9jNjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "broadcastActiveObservations": () => (/* binding */ broadcastActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLDhCQUE4Qiw2RUFBcUI7QUFDbkQ7QUFDQSxrQ0FBa0MsbUVBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzP2NhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckVudHJ5JztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJveFNpemUgfSBmcm9tICcuL2NhbGN1bGF0ZUJveFNpemUnO1xudmFyIGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hhbGxvd2VzdERlcHRoID0gSW5maW5pdHk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHJlc2l6ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NPYnNlcnZlcihybykge1xuICAgICAgICBpZiAocm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob3QudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZXB0aCA9IGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIG90Lmxhc3RSZXBvcnRlZFNpemUgPSBjYWxjdWxhdGVCb3hTaXplKG90LnRhcmdldCwgb3Qub2JzZXJ2ZWRCb3gpO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgc2hhbGxvd2VzdERlcHRoKSB7XG4gICAgICAgICAgICAgICAgc2hhbGxvd2VzdERlcHRoID0gdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgcm8uY2FsbGJhY2suY2FsbChyby5vYnNlcnZlciwgZW50cmllcywgcm8ub2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dlc3REZXB0aDtcbn07XG5leHBvcnQgeyBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateBoxSize": () => (/* binding */ calculateBoxSize),\n/* harmony export */   "calculateBoxSizes": () => (/* binding */ calculateBoxSizes)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ "./node_modules/@juggle/resize-observer/lib/utils/global.js");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || \'0\'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === \'border-box\';\n    var switchSizes = verticalRegexp.test(cs.writingMode || \'\');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || \'\');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || \'\');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFnQixJQUFJLHFFQUEwQjtBQUM5RSx3Q0FBd0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxlQUFlLG1FQUFrQjtBQUNqQztBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEMsQ0FBQztBQUNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0dBQWlEO0FBQzlEO0FBQ0EsYUFBYSwwRkFBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcz8xMDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlclNpemUnO1xuaW1wb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH0gZnJvbSAnLi4vRE9NUmVjdFJlYWRPbmx5JztcbmltcG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiB9IGZyb20gJy4uL3V0aWxzL2VsZW1lbnQnO1xuaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi4vdXRpbHMvZnJlZXplJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbCc7XG52YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNjcm9sbFJlZ2V4cCA9IC9hdXRvfHNjcm9sbC87XG52YXIgdmVydGljYWxSZWdleHAgPSAvXnRifHZlcnRpY2FsLztcbnZhciBJRSA9ICgvbXNpZXx0cmlkZW50L2kpLnRlc3QoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgcGFyc2VEaW1lbnNpb24gPSBmdW5jdGlvbiAocGl4ZWwpIHsgcmV0dXJuIHBhcnNlRmxvYXQocGl4ZWwgfHwgJzAnKTsgfTtcbnZhciBzaXplID0gZnVuY3Rpb24gKGlubGluZVNpemUsIGJsb2NrU2l6ZSwgc3dpdGNoU2l6ZXMpIHtcbiAgICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7IGlubGluZVNpemUgPSAwOyB9XG4gICAgaWYgKGJsb2NrU2l6ZSA9PT0gdm9pZCAwKSB7IGJsb2NrU2l6ZSA9IDA7IH1cbiAgICBpZiAoc3dpdGNoU2l6ZXMgPT09IHZvaWQgMCkgeyBzd2l0Y2hTaXplcyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG59O1xudmFyIHplcm9Cb3hlcyA9IGZyZWV6ZSh7XG4gICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGJvcmRlckJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KDAsIDAsIDAsIDApXG59KTtcbnZhciBjYWxjdWxhdGVCb3hTaXplcyA9IGZ1bmN0aW9uICh0YXJnZXQsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIGlmIChmb3JjZVJlY2FsY3VsYXRpb24gPT09IHZvaWQgMCkgeyBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChjYWNoZS5oYXModGFyZ2V0KSAmJiAhZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGlzSGlkZGVuKHRhcmdldCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgemVyb0JveGVzKTtcbiAgICAgICAgcmV0dXJuIHplcm9Cb3hlcztcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcbiAgICB2YXIgcmVtb3ZlUGFkZGluZyA9ICFJRSAmJiBjcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgICB2YXIgc3dpdGNoU2l6ZXMgPSB2ZXJ0aWNhbFJlZ2V4cC50ZXN0KGNzLndyaXRpbmdNb2RlIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsVmVydGljYWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dZIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gIXN2ZyAmJiBzY3JvbGxSZWdleHAudGVzdChjcy5vdmVyZmxvd1ggfHwgJycpO1xuICAgIHZhciBwYWRkaW5nVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdUb3ApO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ1JpZ2h0KTtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nQm90dG9tKTtcbiAgICB2YXIgcGFkZGluZ0xlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0xlZnQpO1xuICAgIHZhciBib3JkZXJUb3AgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbEJvcmRlckFyZWEgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsQm9yZGVyQXJlYSA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxIb3Jpem9udGFsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldEhlaWdodCAtIHZlcnRpY2FsQm9yZGVyQXJlYSAtIHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzID0gIWNhblNjcm9sbFZlcnRpY2FsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpZHRoUmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlckFyZWEgOiAwO1xuICAgIHZhciBoZWlnaHRSZWR1Y3Rpb24gPSByZW1vdmVQYWRkaW5nID8gdmVydGljYWxQYWRkaW5nICsgdmVydGljYWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gc3ZnID8gc3ZnLndpZHRoIDogcGFyc2VEaW1lbnNpb24oY3Mud2lkdGgpIC0gd2lkdGhSZWR1Y3Rpb24gLSB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgY29udGVudEhlaWdodCA9IHN2ZyA/IHN2Zy5oZWlnaHQgOiBwYXJzZURpbWVuc2lvbihjcy5oZWlnaHQpIC0gaGVpZ2h0UmVkdWN0aW9uIC0gaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgYm9yZGVyQm94V2lkdGggPSBjb250ZW50V2lkdGggKyBob3Jpem9udGFsUGFkZGluZyArIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzICsgaG9yaXpvbnRhbEJvcmRlckFyZWE7XG4gICAgdmFyIGJvcmRlckJveEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmcgKyBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzICsgdmVydGljYWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3hlcyA9IGZyZWV6ZSh7XG4gICAgICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoTWF0aC5yb3VuZChjb250ZW50V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSwgTWF0aC5yb3VuZChjb250ZW50SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpbyksIHN3aXRjaFNpemVzKSxcbiAgICAgICAgYm9yZGVyQm94U2l6ZTogc2l6ZShib3JkZXJCb3hXaWR0aCwgYm9yZGVyQm94SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGNvbnRlbnRCb3hTaXplOiBzaXplKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seShwYWRkaW5nTGVmdCwgcGFkZGluZ1RvcCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0KVxuICAgIH0pO1xuICAgIGNhY2hlLnNldCh0YXJnZXQsIGJveGVzKTtcbiAgICByZXR1cm4gYm94ZXM7XG59O1xudmFyIGNhbGN1bGF0ZUJveFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYnNlcnZlZEJveCwgZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgdmFyIF9hID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pLCBib3JkZXJCb3hTaXplID0gX2EuYm9yZGVyQm94U2l6ZSwgY29udGVudEJveFNpemUgPSBfYS5jb250ZW50Qm94U2l6ZSwgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IF9hLmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgc3dpdGNoIChvYnNlcnZlZEJveCkge1xuICAgICAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5ERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1g6XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQk9SREVSX0JPWDpcbiAgICAgICAgICAgIHJldHVybiBib3JkZXJCb3hTaXplO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3hTaXplO1xuICAgIH1cbn07XG5leHBvcnQgeyBjYWxjdWxhdGVCb3hTaXplLCBjYWxjdWxhdGVCb3hTaXplcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calculateDepthForNode": () => (/* binding */ calculateDepthForNode)\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ "./node_modules/@juggle/resize-observer/lib/utils/element.js");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzP2M5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deliverResizeLoopError\": () => (/* binding */ deliverResizeLoopError)\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2RlbGl2ZXJSZXNpemVMb29wRXJyb3IuanM/YzJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n")},"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "gatherActiveObservationsAtDepth": () => (/* binding */ gatherActiveObservationsAtDepth)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQzJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9nYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoLmpzPzQ1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbnZhciBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMuc3BsaWNlKDAsIHJvLnNraXBwZWRUYXJnZXRzLmxlbmd0aCk7XG4gICAgICAgIHJvLm9ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NUYXJnZXQob3QpIHtcbiAgICAgICAgICAgIGlmIChvdC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5wdXNoKG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasActiveObservations": () => (/* binding */ hasActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyx3RUFBb0IsaUJBQWlCLHFDQUFxQztBQUNyRjtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzP2RkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbnZhciBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hasSkippedObservations": () => (/* binding */ hasSkippedObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsd0VBQW9CLGlCQUFpQixzQ0FBc0M7QUFDdEY7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc1NraXBwZWRPYnNlcnZhdGlvbnMuanM/YzEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc1NraXBwZWRPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoID4gMDsgfSk7XG59O1xuZXhwb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n')},"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ResizeObserver": () => (/* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver),\n/* harmony export */   "ResizeObserverEntry": () => (/* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry),\n/* harmony export */   "ResizeObserverSize": () => (/* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9leHBvcnRzL3Jlc2l6ZS1vYnNlcnZlci5qcz8xZDFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/element.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isElement\": () => (/* binding */ isElement),\n/* harmony export */   \"isHidden\": () => (/* binding */ isHidden),\n/* harmony export */   \"isReplacedElement\": () => (/* binding */ isReplacedElement),\n/* harmony export */   \"isSVG\": () => (/* binding */ isSVG)\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9lbGVtZW50LmpzPzNjZDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/freeze.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "freeze": () => (/* binding */ freeze)\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvZnJlZXplLmpzP2ZjZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/global.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"global\": () => (/* binding */ global)\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9nbG9iYWwuanM/Y2I3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n")},"./node_modules/@juggle/resize-observer/lib/utils/process.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "process": () => (/* binding */ process)\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzP2Q0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueMicroTask": () => (/* binding */ queueMicroTask)\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode(\'\');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVNaWNyb1Rhc2suanM/YTk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "queueResizeObserver": () => (/* binding */ queueResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVSZXNpemVPYnNlcnZlci5qcz9hMzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "resizeObservers": () => (/* binding */ resizeObservers)\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9yZXNpemVPYnNlcnZlcnMuanM/YThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n')},"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduler\": () => (/* binding */ scheduler),\n/* harmony export */   \"updateCount\": () => (/* binding */ updateCount)\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDREQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDREQUF1QiwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sK0RBQTBCLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n")},"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // CellFrame.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n        - anything else is treated as an error\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its parent that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical position in the list) and session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n\n    One CellFrame at a time is desgnated as the host of the two triggerLines (which trigger an update\n    of the Cradle), with the isTriggerCell flag.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\n\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\n\n\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\n\n\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\n\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      cellMinHeight = _ref.cellMinHeight,\n      cellMinWidth = _ref.cellMinWidth,\n      layout = _ref.layout,\n      getItem = _ref.getItem,\n      listsize = _ref.listsize,\n      placeholder = _ref.placeholder,\n      itemID = _ref.itemID,\n      index = _ref.index,\n      instanceID = _ref.instanceID,\n      scrollerID = _ref.scrollerID,\n      isTriggercell = _ref.isTriggercell,\n      placeholderFrameStyles = _ref.placeholderFrameStyles,\n      placeholderContentStyles = _ref.placeholderContentStyles;\n  var coreConfigRef = (0, react_1.useRef)(null);\n  coreConfigRef.current = {\n    layout: layout,\n    orientation: orientation,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight\n  }; // ----------------------[ setup ]----------------------\n\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n      scrollerPropertiesRef = cradleContext.scrollerPropertiesRef,\n      nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n      itemExceptionsCallback = cradleContext.itemExceptionsCallback,\n      IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n      triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef; // style change generates state refresh\n\n  var _ref2 = (0, react_1.useState)({// overflow:\'visible\',\n  }),\n      _ref3 = _slicedToArray(_ref2, 2),\n      styles = _ref3[0],\n      saveStyles = _ref3[1]; // processing state\n\n\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n      _ref5 = _slicedToArray(_ref4, 2),\n      frameState = _ref5[0],\n      setFrameState = _ref5[1];\n\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState; // DOM ref\n\n  var frameRef = (0, react_1.useRef)(null); // to track unmount interrupt\n\n  var isMountedRef = (0, react_1.useRef)(true); // cache data\n\n  var portalMetadataRef = (0, react_1.useRef)(null); // the placeholder to use\n\n  var placeholderRef = (0, react_1.useRef)(null); // the session itemID to use; could be updated by parent\n\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID; // fetch error\n\n  var errorRef = (0, react_1.useRef)(false); // placeholder message\n\n  var messageRef = (0, react_1.useRef)(null); // for unmount\n\n  (0, react_1.useEffect)(function () {\n    return function () {\n      isMountedRef.current = false;\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.removeRequestedPortal(index);\n    };\n  }, []); // refresh content if itemID changes\n\n  (0, react_1.useEffect)(function () {\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]); // ----------------- [ placeholder definition ] -------------------------\n\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, errorRef.current]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userContentStyles: placeholderContentStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current]); // ---------------- [ requestidlecallback config ] ------------------------\n\n  var requestidlecallback = window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback = window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null); // --------------------[ processing ]-----------------\n  // set styles\n\n  (0, react_1.useEffect)(function () {\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles);\n\n    if (isMountedRef.current) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  var isReparentingRef = (0, react_1.useRef)(false);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        // no-op\n        break;\n\n      case \'inserting\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID);\n          var _coreConfigRef$curren = coreConfigRef.current,\n              _layout = _coreConfigRef$curren.layout,\n              _orientation = _coreConfigRef$curren.orientation,\n              _cellWidth = _coreConfigRef$curren.cellWidth,\n              _cellHeight = _coreConfigRef$curren.cellHeight;\n\n          if (cached) {\n            messageRef.current = \'(retrieving from cache)\';\n\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheHandler.getPortal(_itemID); // get OutPortal node\n\n              portalNodeRef.current = portalMetadataRef.current.portalNode;\n              setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight); // notify fetched component that reparenting is underway\n\n              portalMetadataRef.current.isReparentingRef.current = true;\n              setFrameState(\'inserting\');\n            }\n          } else {\n            messageRef.current = \'(loading...)\';\n            setFrameState(\'waiting\'); // reserve space in the cache\n\n            cacheHandler.registerRequestedPortal(index); // enqueue the fetch\n\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, content, scrollerProperties;\n\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return getItem(index, _itemID);\n\n                      case 3:\n                        usercontent = _context.sent;\n                        if (usercontent === null) returnvalue = usercontent;\n\n                        if (usercontent === undefined) {\n                          error = new Error(\'host returned "undefined"\');\n                        }\n\n                        _context.next = 12;\n                        break;\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context["catch"](0);\n                        returnvalue = usercontent = undefined;\n                        error = _context.t0;\n\n                      case 12:\n                        // process the return value\n                        if (usercontent !== null && usercontent !== undefined) {\n                          if (!react_1["default"].isValidElement(usercontent)) {\n                            returnvalue = usercontent;\n                            usercontent = undefined;\n                            error = new Error(\'invalid React element\');\n                          }\n                        }\n\n                        if (isMountedRef.current) {\n                          // prepare the content\n                          if (usercontent !== null && usercontent !== undefined) {\n                            // if usercontent is otherwise disallowed, let error handling deal with it.\n                            scrollerProperties = {\n                              isReparentingRef: null,\n                              scrollerPropertiesRef: scrollerPropertiesRef\n                            };\n\n                            if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                              content = react_1["default"].cloneElement(usercontent, {\n                                scrollerProperties: scrollerProperties\n                              });\n                            } else {\n                              content = usercontent;\n                            }\n\n                            portalMetadataRef.current = cacheHandler.createPortal(content, index, _itemID);\n                            portalNodeRef.current = portalMetadataRef.current.portalNode;\n                            setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight); // make available to user content\n\n                            scrollerProperties.isReparentingRef = portalMetadataRef.current.isReparentingRef;\n                            isMountedRef.current && setFrameState(\'inserting\');\n                          } else {\n                            // null or undefined; handle non-component value\n                            if (usercontent === null) {\n                              // truncate listsize at this index\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(\'end of list\'));\n                              nullItemSetMaxListsize(index);\n                            } else {\n                              // usercontent === undefined, meaning an error has occurred\n                              // change placeholder message to error message\n                              errorRef.current = error; // notify the host\n\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                              isMountedRef.current && setFrameState(\'error\');\n                            }\n                          }\n                        }\n\n                      case 14:\n                      case "end":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n\n          break;\n        }\n\n      case \'waiting\':\n        {\n          break;\n        }\n    }\n  }, [frameState]);\n  (0, react_1.useEffect)(function () {\n    switch (frameState) {\n      case \'ready\':\n        {\n          // no-op\n          break;\n        }\n    }\n  }, [frameState]); // with \'inserting\' the content is still in cache\n  // the content re-renders with \'ready\' when the height/width have returned to normal after-cache\n  // React re-renders on diff between the two (virtual vs real DOM)\n  // this gives the content component a chance to respond to uncaching\n\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: styles\n  }, ![\'inserting\', \'ready\'].includes(frameState) ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    node: portalNodeRef.current\n  }), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\n\n\nexports["default"] = CellFrame; // utilities\n\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\',\n    overflow: \'visible\'\n  });\n\n  if (orientation === \'vertical\') {\n    styleset.width = null;\n\n    if (layout == \'uniform\') {\n      styleset.height = cellHeight + \'px\';\n      styleset.minHeight = null;\n      styleset.maxHeight = null;\n    } else {\n      styleset.height = null;\n      styleset.minHeight = cellMinHeight + \'px\';\n      styleset.maxHeight = cellHeight + \'px\';\n    }\n  } else {\n    // horizontal\n    styleset.height = null;\n\n    if (layout == \'uniform\') {\n      styleset.width = cellWidth + \'px\';\n      styleset.minWidth = null;\n      styleset.maxWidth = null;\n    } else {\n      styleset.width = null;\n      styleset.minWidth = cellMinWidth + \'px\';\n      styleset.maxWidth = cellWidth + \'px\';\n    }\n  }\n\n  return styleset;\n}; // see also some base styles set in cachehandler\n\n\nvar setContainerStyles = function setContainerStyles(container, layout, orientation, cellWidth, cellHeight) {\n  container.style.overflow = \'hidden\';\n\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n    container.style.maxWidth = null;\n    container.style.maxHeight = null;\n    container.style.height = null;\n    container.style.width = null;\n  } else {\n    // variable\n    container.style.inset = null;\n    container.style.position = null;\n\n    if (orientation == \'vertical\') {\n      container.style.width = \'100%\';\n      container.style.height = null;\n      container.style.maxWidth = null;\n      container.style.maxHeight = cellHeight + \'px\';\n    } else {\n      container.style.width = null;\n      container.style.height = \'100%\';\n      container.style.maxWidth = cellWidth + \'px\';\n      container.style.maxHeight = null;\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UEQsTUFPTztNQUVIMkYsU0FBUyxDQUFDZCxLQUFWLENBQWdCUSxLQUFoQixHQUF3QixJQUF4QjtNQUNBTSxTQUFTLENBQUNkLEtBQVYsQ0FBZ0JTLE1BQWhCLEdBQXlCLE1BQXpCO01BQ0FLLFNBQVMsQ0FBQ2QsS0FBVixDQUFnQmEsUUFBaEIsR0FBMkJ6RixTQUFTLEdBQUcsSUFBdkM7TUFDQTBGLFNBQVMsQ0FBQ2QsS0FBVixDQUFnQlcsU0FBaEIsR0FBNEIsSUFBNUI7SUFFSDtFQUVKO0FBQ0osQ0FuQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL0NlbGxGcmFtZS50c3g/ZjE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDZWxsRnJhbWUudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIENlbGxGcmFtZSBpcyB0byBmZXRjaCB1c2VyIGNvbnRlbnQgZnJvbSB0aGUgY2FjaGUsIG9yIGZyb20gdGhlIGhvc3QgKHVzaW5nIGdldEl0ZW0pLlxuICAgIFdoaWxlIGFuIGl0ZW0gaXMgYmVpbmcgZmV0Y2hlZCwgQ2VsbEZyYW1lIHByZXNlbnRzIGEgcGxhY2Vob2xkZXIgKGVpdGhlciB0aGUgZGVmYXVsdCBvciBhbiBcbiAgICBpbXBvcnRlZCBjdXN0b20gdmVyc2lvbikuIElmIHRoZXJlIGlzIGFuIGVycm9yIGluIGZldGNoaW5nIGNvbnRlbnQgdGhlbiB0aGUgcGxhY2Vob2xkZXIgaXMgdXNlZFxuICAgIHRvIHByZXNlbnQgdGhlIGVycm9yIHRvIHRoZSB1c2VyLiBJZiBhIG5ldyBpdGVtSUQgaXMgc2V0IGJ5IHRoZSBwYXJlbnQgKHRvIHN5bmNocm9uaXplIHdpdGggYW4gYWx0ZXJlZFxuICAgIGNhY2hlKSwgdGhlbiBDZWxsRnJhbWUgcmVwbGFjZXMgdGhlIG9sZCBpdGVtIHdpdGggdGhlIG5ldyBpdGVtLlxuXG4gICAgZ2V0SXRlbSAod2hpY2ggaXMgYSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgaG9zdCkgY2FuIHJldHVybiBvbmUgb2Ygc2V2ZXJhbCB2YWx1ZXM6XG4gICAgICAgIC0gYSBSZWFjdCBjb21wb25lbnRcbiAgICAgICAgLSBhIHByb21pc2Ugb2YgYSBjb21wb25lbnRcbiAgICAgICAgLSBudWxsXG4gICAgICAgIC0gdW5kZWZpbmVkXG4gICAgICAgIC0gYW55dGhpbmcgZWxzZSBpcyB0cmVhdGVkIGFzIGFuIGVycm9yXG4gICAgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkLCB0aGVuIHRoZSBwcm9taXNlIHJldHVybnMgYSBSZWFjdCBjb21wb25lbnQsIG51bGwgb3IgdW5kZWZpbmVkLlxuXG4gICAgSWYgYSB2YWxpZCByZWFjdCBjb21wb25lbnQgaXMgcmV0dXJuZWQsIHRoZW4gaXQgaXMgaW5zdGFudGlhdGVkIGluIHRoZSBjYWNoZSwgYW5kIHJlbmRlcmVkIGluIHRoZVxuICAgIENlbGxGcmFtZS4gSWYgbnVsbCBpcyByZXR1cm5lZCwgdGhlbiBDZWxsRnJhbWUgc2VuZHMgYSBtZXNzYWdlIHRvIGl0cyBwYXJlbnQgdGhhdCB0aGUgaG9zdCBoYXMgXG4gICAgaW5kaWNhdGVkIHRoZSB0aGUgaXRlbSBiZWluZyBmZXRjaGVkIGluc3RlYWQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoZSBsaXN0LCBhbmQgdGhlIGxpc3RzaXplIHNob3VsZFxuICAgIGJlIGFkanVzdGVkIGFjY29yZGluZ2x5LiBBbnkgb3RoZXIgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBpcyB0cmVhdGVkIGFzIGFuIGVycm9yLCBhbmQgcHJlc2VudGVkXG4gICAgYXMgc3VjaCB0byB0aGUgdXNlciB0aHJvdWdoIHRoZSBwbGFjZWhvbGRlciBjb21wb25lbnQuXG5cbiAgICBnZXRJdGVtIHNlbmRzIHRoZSBpbmRleCAobG9naWNhbCBwb3NpdGlvbiBpbiB0aGUgbGlzdCkgYW5kIHNlc3Npb24gaXRlbUlEIHRvIHRoZSBob3N0LCBzbyB0aGF0XG4gICAgdGhlIGhvc3QgY2FuIHN5bmMgaXRzIG93biB0cmFja2luZyB3aXRoIHRoZSBzY3JvbGxlci5cblxuICAgIE9uZSBDZWxsRnJhbWUgYXQgYSB0aW1lIGlzIGRlc2duYXRlZCBhcyB0aGUgaG9zdCBvZiB0aGUgdHdvIHRyaWdnZXJMaW5lcyAod2hpY2ggdHJpZ2dlciBhbiB1cGRhdGUgXG4gICAgb2YgdGhlIENyYWRsZSksIHdpdGggdGhlIGlzVHJpZ2dlckNlbGwgZmxhZy5cbiovXG5cbmltcG9ydCBSZWFjdCwge1xuICAgIHVzZVJlZiwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VDYWxsYmFjaywgXG4gICAgdXNlTWVtbywgXG4gICAgdXNlQ29udGV4dCBcbn0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7cmVxdWVzdElkbGVDYWxsYmFjaywgY2FuY2VsSWRsZUNhbGxiYWNrfSBmcm9tICdyZXF1ZXN0aWRsZWNhbGxiYWNrJyAvLyBwb2x5ZmlsbCBpZiBuZWVkZWRcblxuaW1wb3J0IHsgT3V0UG9ydGFsIH0gZnJvbSAncmVhY3QtcmV2ZXJzZS1wb3J0YWwnIC8vIGZldGNoIGZyb20gY2FjaGVcblxuaW1wb3J0IFBsYWNlaG9sZGVyIGZyb20gJy4vY2VsbGZyYW1lL1BsYWNlaG9sZGVyJyAvLyBkZWZhdWx0XG5cbmltcG9ydCB7IENyYWRsZUNvbnRleHQgfSBmcm9tICcuL0NyYWRsZSdcblxuY29uc3QgQ2VsbEZyYW1lID0gKHtcbiAgICBvcmllbnRhdGlvbiwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBjZWxsTWluSGVpZ2h0LFxuICAgIGNlbGxNaW5XaWR0aCxcbiAgICBsYXlvdXQsXG4gICAgZ2V0SXRlbSwgLy8gZnVuY3Rpb24gcHJvdmlkZWQgYnkgaG9zdFxuICAgIGxpc3RzaXplLCAvLyBmb3IgZmVlZGJhY2sgaW4gcGxhY2Vob2xkZXJcbiAgICBwbGFjZWhvbGRlciwgLy8gb3B0aW9uYWxseSBwcm92aWRlZCBieSBob3N0XG4gICAgaXRlbUlELCAvLyBzZXNzaW9uIGl0ZW1JRFxuICAgIGluZGV4LCAvLyBsb2dpY2FsIHBvc2l0aW9uIGluIGluZmluaXRlIGxpc3RcbiAgICBpbnN0YW5jZUlELCAvLyBDZWxsRnJhbWUgc2Vzc2lvbiBJRFxuICAgIHNjcm9sbGVySUQsIC8vIHNjcm9sbGVyIElEIChmb3IgZGVidWdnaW5nKVxuICAgIGlzVHJpZ2dlcmNlbGwsXG4gICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckNvbnRlbnRTdHlsZXMsXG59KSA9PiB7XG5cbiAgICBjb25zdCBjb3JlQ29uZmlnUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29yZUNvbmZpZ1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBsYXlvdXQsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxIZWlnaHRcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGV4dCA9IHVzZUNvbnRleHQoQ3JhZGxlQ29udGV4dClcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllc1JlZiwgLy8gZm9yIHRoZSB1c2VyIGNvbnRlbnQsIGlmIHJlcXVlc3RlZFxuICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplLCAvLyBmb3IgaW50ZXJuYWwgbm90aWZpY2F0aW9uIG9mIGVuZC1vZi1saXN0XG4gICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssIC8vIG9yIG5vdGlmaWNhdGlvbiB0byBob3N0IG9mIGVycm9yXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULCAvLyB0byBvcHRpbWl6ZSByZXF1ZXN0SWRsZUNhbGxiYWNrXG4gICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLFxuICAgIH0gPSBjcmFkbGVDb250ZXh0XG4gICAgXG4gICAgLy8gc3R5bGUgY2hhbmdlIGdlbmVyYXRlcyBzdGF0ZSByZWZyZXNoXG4gICAgY29uc3QgW3N0eWxlcyxzYXZlU3R5bGVzXSA9IHVzZVN0YXRlKHtcbiAgICAgICAgLy8gb3ZlcmZsb3c6J3Zpc2libGUnLFxuICAgIH0pXG5cbiAgICAvLyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgY29uc3QgW2ZyYW1lU3RhdGUsIHNldEZyYW1lU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBmcmFtZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpXG4gICAgZnJhbWVTdGF0ZVJlZi5jdXJyZW50ID0gZnJhbWVTdGF0ZVxuXG4gICAgLy8gRE9NIHJlZlxuICAgIGNvbnN0IGZyYW1lUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdG8gdHJhY2sgdW5tb3VudCBpbnRlcnJ1cHRcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICAvLyBjYWNoZSBkYXRhXG4gICAgY29uc3QgcG9ydGFsTWV0YWRhdGFSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgcGxhY2Vob2xkZXIgdG8gdXNlXG4gICAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgc2Vzc2lvbiBpdGVtSUQgdG8gdXNlOyBjb3VsZCBiZSB1cGRhdGVkIGJ5IHBhcmVudFxuICAgIGNvbnN0IGl0ZW1JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGl0ZW1JRFJlZi5jdXJyZW50ID0gaXRlbUlEXG4gICAgLy8gZmV0Y2ggZXJyb3JcbiAgICBjb25zdCBlcnJvclJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICAvLyBwbGFjZWhvbGRlciBtZXNzYWdlXG4gICAgY29uc3QgbWVzc2FnZVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gZm9yIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGNhbmNlbGlkbGVjYWxsYmFjayhyZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudClcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gcmVmcmVzaCBjb250ZW50IGlmIGl0ZW1JRCBjaGFuZ2VzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpXG5cbiAgICB9LFtpdGVtSURdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gWyBwbGFjZWhvbGRlciBkZWZpbml0aW9uIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3VzdG9tcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQocGxhY2Vob2xkZXIsIFxuICAgICAgICAgICAgICAgICAgICB7aW5kZXgsIGxpc3RzaXplLCBtZXNzYWdlOm1lc3NhZ2VSZWYuY3VycmVudCwgZXJyb3I6ZXJyb3JSZWYuY3VycmVudH0pOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIFxuICAgIH0sW2luZGV4LCBwbGFjZWhvbGRlcixsaXN0c2l6ZSwgZXJyb3JSZWYuY3VycmVudF0pXG5cbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gXG4gICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcj9cbiAgICAgICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcjpcbiAgICAgICAgICAgICAgICA8UGxhY2Vob2xkZXIgXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfSBcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHsgbWVzc2FnZVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7IGVycm9yUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29udGVudFN0eWxlcyA9IHsgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzIH1cbiAgICAgICAgICAgICAgICAvPlxuXG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlclxuXG4gICAgfSwgW1xuICAgICAgICBpbmRleCwgXG4gICAgICAgIGN1c3RvbXBsYWNlaG9sZGVyLCBcbiAgICAgICAgbGlzdHNpemUsIFxuICAgICAgICBtZXNzYWdlUmVmLmN1cnJlbnQsIFxuICAgICAgICBlcnJvclJlZi5jdXJyZW50XG4gICAgXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gWyByZXF1ZXN0aWRsZWNhbGxiYWNrIGNvbmZpZyBdIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVxdWVzdGlkbGVjYWxsYmFjayA9IFxuICAgICAgICB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXT9cbiAgICAgICAgICAgIHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFja1xuXG4gICAgY29uc3QgY2FuY2VsaWRsZWNhbGxiYWNrID0gXG4gICAgICAgIHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ10/XG4gICAgICAgICAgICB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddOlxuICAgICAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgICBjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcm9jZXNzaW5nIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gc2V0IHN0eWxlc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGxldCBuZXdTdHlsZXMgPSBnZXRGcmFtZVN0eWxlcyhcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCwgbGF5b3V0LCBzdHlsZXMpXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNhdmVTdHlsZXMobmV3U3R5bGVzKVxuICAgICAgICB9XG5cbiAgICB9LFtvcmllbnRhdGlvbixjZWxsSGVpZ2h0LGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLCBsYXlvdXRdKSBcblxuICAgIGNvbnN0IHBvcnRhbE5vZGVSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGlzUmVwYXJlbnRpbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoZnJhbWVTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOlxuICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZ2V0dXNlcmNvbnRlbnQnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpdGVtSURSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlSGFuZGxlci5oYXNQb3J0YWwoaXRlbUlEKVxuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gPSBjb3JlQ29uZmlnUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gJyhyZXRyaWV2aW5nIGZyb20gY2FjaGUpJ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBjYWNoZUhhbmRsZXIuZ2V0UG9ydGFsKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBPdXRQb3J0YWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250YWluZXJTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50LmVsZW1lbnQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBmZXRjaGVkIGNvbXBvbmVudCB0aGF0IHJlcGFyZW50aW5nIGlzIHVuZGVyd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LmlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnaW5zZXJ0aW5nJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9ICcobG9hZGluZy4uLiknXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnd2FpdGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZSBzcGFjZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYuY3VycmVudCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soYXN5bmMgKCk9PntcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbHVlLCB1c2VyY29udGVudCwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2hvc3QgcmV0dXJuZWQgXCJ1bmRlZmluZWRcIicpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXJjb250ZW50IGlzIG90aGVyd2lzZSBkaXNhbGxvd2VkLCBsZXQgZXJyb3IgaGFuZGxpbmcgZGVhbCB3aXRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjpudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudC5wcm9wcz8uaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KHVzZXJjb250ZW50LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jcmVhdGVQb3J0YWwoY29udGVudCwgaW5kZXgsIGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRhaW5lclN0eWxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudC5lbGVtZW50LCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHRvIHVzZXIgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZiA9IHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZDsgaGFuZGxlIG5vbi1jb21wb25lbnQgdmFsdWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIG5ldyBFcnJvcignZW5kIG9mIGxpc3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlcmNvbnRlbnQgPT09IHVuZGVmaW5lZCwgbWVhbmluZyBhbiBlcnJvciBoYXMgb2NjdXJyZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHBsYWNlaG9sZGVyIG1lc3NhZ2UgdG8gZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RpZnkgdGhlIGhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdjZWxsRnJhbWUnLCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0RnJhbWVTdGF0ZSgnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9LHt0aW1lb3V0OklETEVDQUxMQkFDS19USU1FT1VUfSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dhaXRpbmcnOiB7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtmcmFtZVN0YXRlXSlcblxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChmcmFtZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogeyAvLyBuby1vcFxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2ZyYW1lU3RhdGVdKVxuXG4gICAgLy8gd2l0aCAnaW5zZXJ0aW5nJyB0aGUgY29udGVudCBpcyBzdGlsbCBpbiBjYWNoZVxuICAgIC8vIHRoZSBjb250ZW50IHJlLXJlbmRlcnMgd2l0aCAncmVhZHknIHdoZW4gdGhlIGhlaWdodC93aWR0aCBoYXZlIHJldHVybmVkIHRvIG5vcm1hbCBhZnRlci1jYWNoZVxuICAgIC8vIFJlYWN0IHJlLXJlbmRlcnMgb24gZGlmZiBiZXR3ZWVuIHRoZSB0d28gKHZpcnR1YWwgdnMgcmVhbCBET00pXG4gICAgLy8gdGhpcyBnaXZlcyB0aGUgY29udGVudCBjb21wb25lbnQgYSBjaGFuY2UgdG8gcmVzcG9uZCB0byB1bmNhY2hpbmdcbiAgICByZXR1cm4gPGRpdiBcblxuICAgICAgICByZWYgPSB7IGZyYW1lUmVmIH0gXG4gICAgICAgIGRhdGEtdHlwZSA9ICdjZWxsZnJhbWUnIFxuICAgICAgICBkYXRhLXNjcm9sbGVyaWQgPSB7IHNjcm9sbGVySUQgfSBcbiAgICAgICAgZGF0YS1pbmRleCA9IHsgaW5kZXggfSBcbiAgICAgICAgZGF0YS1pbnN0YW5jZWlkID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIHN0eWxlID0geyBzdHlsZXMgfVxuXG4gICAgPlxuXG4gICAgICAgIHsgXG4gICAgICAgICAgICAoIVsnaW5zZXJ0aW5nJywncmVhZHknXS5pbmNsdWRlcyhmcmFtZVN0YXRlKSk/XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudDpcbiAgICAgICAgICAgICAgICA8T3V0UG9ydGFsIG5vZGUgPSB7IHBvcnRhbE5vZGVSZWYuY3VycmVudCB9Lz5cbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBpc1RyaWdnZXJjZWxsP1xuICAgICAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxuXG59IC8vIENlbGxGcmFtZVxuXG5leHBvcnQgZGVmYXVsdCBDZWxsRnJhbWVcblxuLy8gdXRpbGl0aWVzXG5jb25zdCBnZXRGcmFtZVN0eWxlcyA9IChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsIGxheW91dCwgc3R5bGVzKSA9PiB7XG5cbiAgICBsZXQgc3R5bGVzZXQgPSB7Li4uc3R5bGVzLHBvc2l0aW9uOidyZWxhdGl2ZScsIG92ZXJmbG93Oid2aXNpYmxlJ31cblxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgIHN0eWxlc2V0LndpZHRoID0gbnVsbFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSBjZWxsSGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWluSGVpZ2h0ID1udWxsXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhIZWlnaHQgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzZXQubWluSGVpZ2h0ID0gY2VsbE1pbkhlaWdodCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heEhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9IGVsc2UgeyAvLyBob3Jpem9udGFsXG5cbiAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gbnVsbFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBzdHlsZXNldC53aWR0aCA9IGNlbGxXaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbldpZHRoID1udWxsXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhXaWR0aCA9IG51bGxcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzdHlsZXNldC53aWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1pbldpZHRoID0gY2VsbE1pbldpZHRoICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWF4V2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2V0XG5cbn1cblxuLy8gc2VlIGFsc28gc29tZSBiYXNlIHN0eWxlcyBzZXQgaW4gY2FjaGVoYW5kbGVyXG5jb25zdCBzZXRDb250YWluZXJTdHlsZXMgPSAoY29udGFpbmVyLCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpID0+IHtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5pbnNldCA9ICcwcHgnIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhXaWR0aCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuXG4gICAgfSBlbHNlIHsgLy8gdmFyaWFibGVcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSBudWxsIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBudWxsXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcblxuICAgICAgICB9XG5cbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6WyJDZWxsRnJhbWUiLCJvcmllbnRhdGlvbiIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwibGF5b3V0IiwiZ2V0SXRlbSIsImxpc3RzaXplIiwicGxhY2Vob2xkZXIiLCJpdGVtSUQiLCJpbmRleCIsImluc3RhbmNlSUQiLCJzY3JvbGxlcklEIiwiaXNUcmlnZ2VyY2VsbCIsInBsYWNlaG9sZGVyRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlckNvbnRlbnRTdHlsZXMiLCJjb3JlQ29uZmlnUmVmIiwiY3VycmVudCIsImNyYWRsZUNvbnRleHQiLCJDcmFkbGVfMSIsImNhY2hlSGFuZGxlciIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJpdGVtRXhjZXB0aW9uc0NhbGxiYWNrIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZiIsInN0eWxlcyIsInNhdmVTdHlsZXMiLCJmcmFtZVN0YXRlIiwic2V0RnJhbWVTdGF0ZSIsImZyYW1lU3RhdGVSZWYiLCJmcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInBvcnRhbE1ldGFkYXRhUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJpdGVtSURSZWYiLCJlcnJvclJlZiIsIm1lc3NhZ2VSZWYiLCJjYW5jZWxpZGxlY2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrSWRSZWYiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJjdXN0b21wbGFjZWhvbGRlciIsInJlYWN0XzEiLCJjcmVhdGVFbGVtZW50IiwibWVzc2FnZSIsImVycm9yIiwiUGxhY2Vob2xkZXJfMSIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJDb250ZW50U3R5bGVzIiwicmVxdWVzdGlkbGVjYWxsYmFjayIsIndpbmRvdyIsInJlcXVlc3RpZGxlY2FsbGJhY2tfMSIsIm5ld1N0eWxlcyIsImdldEZyYW1lU3R5bGVzIiwicG9ydGFsTm9kZVJlZiIsImlzUmVwYXJlbnRpbmdSZWYiLCJjYWNoZWQiLCJoYXNQb3J0YWwiLCJnZXRQb3J0YWwiLCJwb3J0YWxOb2RlIiwic2V0Q29udGFpbmVyU3R5bGVzIiwiZWxlbWVudCIsInJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsIiwiX19hd2FpdGVyIiwidXNlcmNvbnRlbnQiLCJyZXR1cm52YWx1ZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNWYWxpZEVsZW1lbnQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsIl9hIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlUG9ydGFsIiwidGltZW91dCIsInJlZiIsInN0eWxlIiwiaW5jbHVkZXMiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsImV4cG9ydHMiLCJzdHlsZXNldCIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJ3aWR0aCIsImhlaWdodCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJjb250YWluZXIiLCJpbnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // Cradle.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers (class instances), and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the ~30 state changes of the system.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be vertical or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'headwards' (up or left) in the Cradle, and\n    below which the cradle content expands 'tailwards' (doen or right). The Cradle content is held in\n    two CSS grids (children of the axis): one above or left (the 'head' grid), and one below or right,\n    of the position of the axis (the 'tail' grid).\n\n    The axis is always kept near the leading (headward) edge of the visible cell rows of the Viewport\n    (there are some edge-case exceptions).\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is usually\n            the first item in the head section of the Cradle, unless the cradle shows the very top of the\n            list, in which case the cradleReferenceIndex is the same as the AxisReferenceIndex)\n        - axisViewportPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll (Viewport scrollTop or scrollLeft) of the\n            ScrollBlock\n    \n    Overscroll handling (repositioning):\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle (including its two content grids) has entirely passed\n        out of the viewport, then the Cradle component is replaced by a ScrollTracker (or by null if\n        the host takes responsibility for feedback). The ScrollTracker displays to the user the relative\n        location in the virtual list at the edge of the viewport during repositioning. When the scrolling\n        stops Cradle recreates the cradle content, according to the final position of the repositioning\n        process.\n\n    Cradle is activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\"); // popup position tracker for repositioning\n\n\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\")); // support code; process handlers\n\n\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\n\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\n\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\n\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\n\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\n\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\n\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\")); // cacheHandler is imported as a property; instantiated at the root\n// for children\n\n\nexports.CradleContext = react_1[\"default\"].createContext(null); // component\n\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n      runwaySize = _ref.runwaySize,\n      listsize = _ref.listsize,\n      startingIndex = _ref.startingIndex,\n      getItem = _ref.getItem,\n      placeholder = _ref.placeholder,\n      userCallbacks = _ref.userCallbacks,\n      styles = _ref.styles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      cache = _ref.cache,\n      cacheMax = _ref.cacheMax,\n      scrollerID = _ref.scrollerID,\n      cacheHandler = _ref.cacheHandler,\n      useScrollTracker = _ref.useScrollTracker,\n      showAxis = _ref.showAxis,\n      SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _ref.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n      IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n      MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n      TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _ref.TIMEOUT_FOR_VARIABLE_MEASUREMENTS;\n\n  var _a, _b;\n\n  if (listsize == 0) return null; // nothing to do\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      cellMinHeight = gridSpecs.cellMinHeight,\n      cellMinWidth = gridSpecs.cellMinWidth,\n      layout = gridSpecs.layout; // get viewport context\n\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n\n  var viewportDimensions = ViewportContextProperties.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width; // state\n\n  var _ref2 = (0, react_1.useState)('setup'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      cradleState = _ref3[0],\n      setCradleState = _ref3[1];\n\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n\n  cradleStateRef.current = cradleState; // console.log('==> cradleState','-'+scrollerID+'-',cradleState)\n  // flags\n\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var parentingTransitionRequiredRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false); // cradle scaffold element refs\n\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null); // layout bundle\n\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  }); // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n\n  var crosscount = (0, react_1.useMemo)(function () {\n    var viewportcrosslength = orientation == 'vertical' ? viewportwidth : viewportheight;\n\n    if (viewportcrosslength == 0) {\n      return 0;\n    } // cross length of viewport (gap to match crossLength)\n\n\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = orientation == 'vertical' ? cellWidth + gap : cellHeight + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]); // various row counts\n\n  var _ref4 = (0, react_1.useMemo)(function () {\n    var viewportLength = orientation == 'vertical' ? viewportheight : viewportwidth;\n    var baseRowLength;\n\n    if (layout == 'uniform') {\n      if (orientation == 'vertical') {\n        baseRowLength = cellHeight;\n      } else {\n        baseRowLength = cellWidth;\n      }\n    } else {\n      // layout == 'variable'\n      if (orientation == 'vertical') {\n        baseRowLength = cellMinHeight;\n      } else {\n        baseRowLength = cellMinWidth;\n      }\n    }\n\n    baseRowLength += gap;\n    var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n    var viewportVisibleRowcount = Math.floor(viewportLength / baseRowLength);\n    var listRowcount = Math.ceil(listsize / crosscount);\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n    var runwayRowcount;\n\n    if (calculatedCradleRowcount >= cradleRowcount) {\n      runwayRowcount = runwaySize;\n    } else {\n      var diff = cradleRowcount - calculatedCradleRowcount;\n      runwayRowcount -= Math.floor(diff / 2);\n      runwayRowcount = Math.max(0, runwayRowcount);\n    }\n\n    var itemcount = cradleRowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradleRowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradleRowcount, viewportRowcount, viewportVisibleRowcount, listRowcount, runwayRowcount];\n  }, [orientation, gap, // padding,\n  cellWidth, cellHeight, cellMinWidth, cellMinHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount, layout]),\n      _ref5 = _slicedToArray(_ref4, 5),\n      cradleRowcount = _ref5[0],\n      viewportRowcount = _ref5[1],\n      viewportVisibleRowcount = _ref5[2],\n      // maximum number of rows completely visible at once\n  listRowcount = _ref5[3],\n      runwayRowcount = _ref5[4]; // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n\n\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionsCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionsCallback\n  }); // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    // control values\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN\n  };\n  var scrollerPropertiesRef = (0, react_1.useRef)(null); // passed to cellFrame content (user content) if requested\n\n  scrollerPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    triggerlineOffset: triggerlineOffset\n  }; // configuration properties to share with handlers\n\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    viewportVisibleRowcount: viewportVisibleRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  }; // placeholder in cradleParameters to make available individual handlers\n\n  var handlersRef = (0, react_1.useRef)(null); // cradle parameters MASTER BUNDLE\n\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters; // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  } // make handlers directly available to cradle code below\n\n\n  var _handlersRef$current = handlersRef.current,\n      interruptHandler = _handlersRef$current.interruptHandler,\n      scrollHandler = _handlersRef$current.scrollHandler,\n      stateHandler = _handlersRef$current.stateHandler,\n      contentHandler = _handlersRef$current.contentHandler,\n      layoutHandler = _handlersRef$current.layoutHandler,\n      serviceHandler = _handlersRef$current.serviceHandler,\n      stylesHandler = _handlersRef$current.stylesHandler; // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n\n  /*\n      Intercept change in caching status:\n      when a component is is cached in a portal (in the React virtual DOM), including the transition of\n      being moved from one cellFrame to another when crossing the Cradle axis,\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n  \n      Not that InfiniteGridScroller components can themselves be cached as content.\n  \n      The restore scrollPos action must be the first priority to hide these scrollPos adjustments\n      from the user.\n  */\n  // zero width and height means the component must be in portal (cache) state\n\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n\n  var isCachingUnderway = isCachedRef.current || wasCachedRef.current;\n\n  if (isCacheChange || ((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) || ViewportContextProperties.isResizing && isCachingUnderway) {\n    if ((_b = ViewportContextProperties.isReparentingRef) === null || _b === void 0 ? void 0 : _b.current) {\n      ViewportContextProperties.isReparentingRef.current = false; // no longer needed\n\n      parentingTransitionRequiredRef.current = true;\n    }\n\n    if (ViewportContextProperties.isResizing) {\n      // caching op is underway, so cancel\n      ViewportContextProperties.isResizing = false;\n    }\n\n    if (isCacheChange) {\n      // into or out of caching\n      if (isCachedRef.current && !wasCachedRef.current) {\n        // change into cache\n        interruptHandler.pauseInterrupts();\n      }\n    }\n  } // generate state for restoring scrollPos\n\n\n  (0, react_1.useEffect)(function () {\n    // if is cached, then the next effect (for entering or leaving cache) has another turn\n    if (parentingTransitionRequiredRef.current && !isCachedRef.current) {\n      parentingTransitionRequiredRef.current = false;\n      setCradleState('parentingtransition');\n    }\n  }, [parentingTransitionRequiredRef.current]); // change state for entering or leaving cache\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached'); // replaces 'ready' as steady state\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n\n      if (parentingTransitionRequiredRef.current) {\n        parentingTransitionRequiredRef.current = false;\n        setCradleState('parentingtransition');\n      } else {\n        if (hasBeenRenderedRef.current) {\n          setCradleState('rerenderfromcache');\n        } else {\n          setCradleState('firstrenderfromcache');\n        }\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]); // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n\n  (0, react_1.useEffect)(function () {\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []); //send call-in functions to host\n\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.getFunctions) return;\n    var scrollToItem = serviceHandler.scrollToItem,\n        reload = serviceHandler.reload,\n        setListsize = serviceHandler.setListsize,\n        clearCache = serviceHandler.clearCache,\n        getCacheIndexMap = serviceHandler.getCacheIndexMap,\n        getCacheItemMap = serviceHandler.getCacheItemMap,\n        getCradleIndexMap = serviceHandler.getCradleIndexMap,\n        remapIndexes = serviceHandler.remapIndexes,\n        moveIndex = serviceHandler.moveIndex,\n        insertIndex = serviceHandler.insertIndex,\n        removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToItem: scrollToItem,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.getFunctions(functions);\n  }, []); // initialize window scroll listener\n\n  (0, react_1.useEffect)(function () {\n    var viewportdata = ViewportContextPropertiesRef.current;\n    viewportdata.elementRef.current.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportdata.elementRef.current && viewportdata.elementRef.current.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []); // observer support\n\n  /*\n      There are two interection observers: one for the cradle wings, and another for triggerlines;\n          both against the viewport.\n  */\n\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n        triggerlinesIntersect = interruptHandler.triggerlinesIntersect; // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements(); // triggerobserver tiggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n\n    var triggerobserver = triggerlinesIntersect.createObserver();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n    };\n  }, []); // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize;\n\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n          deleteListCallback = _serviceHandler$callb.deleteListCallback,\n          changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n\n      cacheHandler.changeListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []); // caching change\n\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n\n    if (cradleStateRef.current == 'setup') return;\n\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('changecaching');\n          break;\n        }\n\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n\n          var _dListCallback;\n\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]); // trigger viewportresizing response based on viewport state\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // movement to and from cache is independent of ui viewportresizing\n\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    } // complete viewportresizing mode\n\n\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]); // reconfigure for changed size parameters\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [listsize, cellHeight, cellWidth, gap, padding, triggerlineOffset]); // pivot triggered on change of orientation\n\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      return;\n    }\n\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n        cellWidth = _cradleInheritedPrope.cellWidth,\n        cellHeight = _cradleInheritedPrope.cellHeight,\n        gap = _cradleInheritedPrope.gap; // get previous ratio\n\n    var previousCellPixelLength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n    var previousratio = previousAxisOffset / previousCellPixelLength;\n    var pivotCellPixelLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n    var pivotAxisOffset = previousratio * pivotCellPixelLength;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]); // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n\n  var _ref6 = (0, react_1.useMemo)(function () {\n    return stylesHandler.getCradleStyles({\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      cellMinHeight: cellMinHeight,\n      cellMinWidth: cellMinWidth,\n      gap: gap,\n      padding: padding,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth,\n      crosscount: crosscount,\n      userstyles: styles,\n      triggerlineOffset: triggerlineOffset,\n      layout: layout\n    });\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset, layout]),\n      _ref7 = _slicedToArray(_ref6, 6),\n      cradleHeadStyle = _ref7[0],\n      cradleTailStyle = _ref7[1],\n      cradleAxisStyle = _ref7[2],\n      cradleDividerStyle = _ref7[3],\n      triggercellTriggerlineHeadStyle = _ref7[4],\n      triggercellTriggerlineTailStyle = _ref7[5]; // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (about 30 states), using named states\n  // useLayoutEffect for suppressing flashes\n\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.cacheProps.modified = true;\n              cacheHandler.renderPortalList();\n            }\n\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n\n          cacheHandler.preload(finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n\n\n          break;\n        }\n      // moving out of cache into visible DOM tree (cellFrame)\n      // resets scrollPos (scrollLeft/scrollTop) to last UI value\n\n      case 'parentingtransition':\n        {\n          var cradlePositionData = layoutHandler.cradlePositionData; // reset scroll position to previous value\n\n          if (cradlePositionData.blockScrollPos !== null) {\n            var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n            viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n          }\n\n          setCradleState('finishparenting');\n          break;\n        }\n\n      case 'finishparenting':\n        {\n          interruptHandler.restoreInterrupts();\n\n          if (hasBeenRenderedRef.current) {\n            setCradleState('ready'); // setCradleState('restoreinterrupts')\n          } else {\n            setCradleState('firstrenderfromcache');\n          }\n\n          break;\n        }\n\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true; // avoid recursive cradle intersection interrupts\n\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n\n          if (scrollHandler.isScrolling) {\n            setCradleState('repositioningRender'); // toggles with repositioningContinuation\n          } else {\n            setCradleState('finishreposition');\n          }\n\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n\n      /*\n          the following 11 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts'\n      */\n\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reload':\n        {\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = [];\n\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          } // set data\n\n\n          contentHandler.setCradleContent(cradleState);\n\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          } // synchronize cache if necessary\n\n\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalList();\n            }\n          } // prepare the cycle for preparerender\n\n\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents; // update virtual DOM\n\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n\n          break;\n        }\n\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n\n      case 'preparesetforvariability':\n        {\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability('setcradle');\n            setCradleState('finishsetforvariability');\n          }, TIMEOUT_FOR_VARIABLE_MEASUREMENTS);\n          break;\n        }\n\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements(); // this can be pre-empted by reparenting, which itself restores interrupts\n\n          setCradleState('restoreinterrupts'); // to restore interrupts\n\n          break;\n        }\n\n      case 'restoreinterrupts':\n        {\n          // normalize or resume cycling\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents; // update virtual DOM\n\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n\n          cacheHandler.renderPortalList();\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n\n          if (_layout2 == 'uniform') {\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            interruptHandler.triggerlinesIntersect.connectElements();\n            interruptHandler.signals.pauseTriggerlinesObserver = false;\n            setCradleState('ready');\n          } else {\n            setCradleState('refreshDOMupdateforvariability');\n          }\n\n          break;\n        }\n\n      case 'refreshDOMupdateforvariability':\n        {\n          // extra cycle needed to allow time to synchronize DOM with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n\n      case 'adjustupdateforvariability':\n        {\n          contentHandler.adjustScrollblockForVariability('updatecradle');\n          setCradleState('finishupdateforvariability');\n          break;\n        }\n      // called from onAfterScroll. \n      // This can be called twice in succession with short onAfterScroll timeout\n\n      case 'adjustupdateforvariabilityafterscroll':\n        {\n          contentHandler.adjustScrollblockForVariability('afterscroll');\n          setCradleState('finishupdateforvariability');\n          break;\n        }\n\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseTriggerlinesObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      // support for various host service requests; syncs cradle content with cache changes\n\n      case 'applycellframechanges':\n        {\n          // user intervention\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          var portalHoldList = cacheHandler.portalHoldList;\n          var portalMap = cacheHandler.cacheProps.portalMap;\n\n          if (portalHoldList && portalHoldList.length) {\n            var _iterator = _createForOfIteratorHelper(portalHoldList),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var itemID = _step.value;\n                portalMap[\"delete\"](itemID);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n\n          setCradleState('ready');\n          break;\n        }\n\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]); // standard rendering states (3 states)\n\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]); // ==========================[ RENDER ]===========================\n\n  var scrollAxisReferenceIndex = layoutHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!useScrollTracker) return null;\n\n    if (!['repositioningContinuation', 'repositioningRender'].includes(cradleState)) {\n      return null;\n    }\n\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'headtrigger',\n      \"data-direction\": 'tailward',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'tailtrigger',\n      \"data-direction\": 'headward',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionsCallback: serviceHandler.callbacks.itemExceptionsCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  }); // display the cradle components, the ScrollTracker, or null\n\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ? // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\n\n\nexports[\"default\"] = Cradle; // utility\n\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  cacheHandler.cradleParameters = cradleParameters;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQUEsYUFFZ0IsTUFGaEI7SUFHSXFNLEdBQUcsRUFBS3JKLG9CQUhaO0lBSUlvSixLQUFLLEVBQUt0QztFQUpkLEdBT012SCxXQUFXLElBQUksT0FBaEIsR0FDR3FJLGFBQWEsQ0FBQ00scUJBRGpCLEdBRUcsSUFUUixDQTNCSixDQVZELENBQVA7QUF1REgsQ0FqMkNELEMsQ0FpMkNFOzs7QUFFRm5MLGtCQUFBQSxHQUFlRyxNQUFmLEMsQ0FFQTs7QUFFQSxJQUFNeUYsaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQixDQUFDRixnQkFBRCxFQUFxQjtFQUUzQyxJQUFNa0gsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixRQUFPO0lBQUEsT0FBSSxJQUFJQyxPQUFKLENBQVluSCxnQkFBWixDQUFKO0VBQUEsQ0FBN0I7O0VBRUEsSUFBUTFFLFlBQVIsR0FBeUIwRSxnQkFBZ0IsQ0FBQ0osNEJBQWpCLENBQThDcEQsT0FBdkUsQ0FBUWxCLFlBQVI7RUFFQUEsWUFBWSxDQUFDMEUsZ0JBQWIsR0FBZ0NBLGdCQUFoQztFQUVBLE9BQU87SUFFSDFFLFlBQVksRUFBWkEsWUFGRztJQUdINkUsZ0JBQWdCLEVBQUMrRyxhQUFhLENBQUNFLDZCQUFELENBSDNCO0lBSUhoSCxhQUFhLEVBQUM4RyxhQUFhLENBQUNHLDBCQUFELENBSnhCO0lBS0hoSCxZQUFZLEVBQUM2RyxhQUFhLENBQUNJLHlCQUFELENBTHZCO0lBTUhoSCxjQUFjLEVBQUM0RyxhQUFhLENBQUNLLDJCQUFELENBTnpCO0lBT0hoSCxhQUFhLEVBQUMyRyxhQUFhLENBQUNNLDBCQUFELENBUHhCO0lBUUhoSCxjQUFjLEVBQUMwRyxhQUFhLENBQUNPLDJCQUFELENBUnpCO0lBU0hoSCxhQUFhLEVBQUN5RyxhQUFhLENBQUNRLDBCQUFEO0VBVHhCLENBQVA7QUFhSCxDQXJCRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvQ3JhZGxlLnRzeD83MTk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyYWRsZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIENyYWRsZSBkb2VzIHRoZSBidWxrIG9mIHRoZSB3b3JrIGZvciB0aGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlci4gSXQgZG9lcyBzbyB3aXRoIHRoZSBoZWxwIG9mXG4gICAgZWlnaHQgcHJvY2VzcyBoYW5kbGVycyAoY2xhc3MgaW5zdGFuY2VzKSwgYW5kIG9uZSBtYWluIHN1Yi1jb21wb25lbnQgLSB0aGUgQ2VsbEZyYW1lLlxuXG4gICAgQ3JhZGxlJ3MgbWFpbiByZXNwb25zaWJpbGl0eSBpcyB0byBtYW5hZ2UgdGhlIH4zMCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBzeXN0ZW0uXG5cbiAgICBUaGUgaWxsdXNpb24gb2YgaW5maW5pdGUgY29udGVudCBpcyBtYWludGFpbmVkIGJ5IHN5bmNocm9uaXppbmcgY2hhbmdlcyBpbiBjcmFkbGUgY29udGVudCB3aXRoIHRoZVxuICAgIENyYWRsZSBsb2NhdGlvbiBpbnNpZGUgdGhlIFNjcm9sbGJsb2NrLCBzdWNoIHRoYXQgYXMgdGhlIFNjcm9sbGJsb2NrIGlzIG1vdmVkLCB0aGUgY3JhZGxlIG1vdmVzIFxuICAgIG9wcG9zaXRlbHkgdG8gc3RheSB2aXNpYmxlIHdpdGhpbiB0aGUgdmlld3BvcnQuXG5cbiAgICBUaGUgU2Nyb2xsYmxvY2sgaXMgc2l6ZWQgdG8gYXBwcm94aW1hdGUgdGhlIGxpc3QgYmVpbmcgdmlld2VkLCBzbyBhcyB0byBoYXZlIGEgc2Nyb2xsIHRodW1iIHNpemUgXG4gICAgYW5kIHBvc2l0aW9uIHdoaWNoIHJlYWxpc3RpY2FsbHkgcmVmbGVjdHMgdGhlIHNpemUgb2YgdGhlIGxpc3QgYmVpbmcgc2hvd24uXG5cbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGNyYWRsZSBpcyBjb250cm9sbGVkIGJ5IGFuICdheGlzJyB3aGljaCBpcyBhIDBweCBoZWlnaHQvd2lkdGggZGl2XG4gICAgKGFsb25nIHRoZSBtZWRpYWwgLSBTY3JvbGxCbG9jayBjYW4gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCkuIFRoZSBwdXJwb3NlIG9mIHRoZSBheGlzIGlzIHRvIFxuICAgIGFjdCBhcyBhICdmb2xkJywgYWJvdmUgd2hpY2ggY3JhZGxlIGNvbnRlbnQgZXhwYW5kcyAnaGVhZHdhcmRzJyAodXAgb3IgbGVmdCkgaW4gdGhlIENyYWRsZSwgYW5kIFxuICAgIGJlbG93IHdoaWNoIHRoZSBjcmFkbGUgY29udGVudCBleHBhbmRzICd0YWlsd2FyZHMnIChkb2VuIG9yIHJpZ2h0KS4gVGhlIENyYWRsZSBjb250ZW50IGlzIGhlbGQgaW4gXG4gICAgdHdvIENTUyBncmlkcyAoY2hpbGRyZW4gb2YgdGhlIGF4aXMpOiBvbmUgYWJvdmUgb3IgbGVmdCAodGhlICdoZWFkJyBncmlkKSwgYW5kIG9uZSBiZWxvdyBvciByaWdodCwgXG4gICAgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBheGlzICh0aGUgJ3RhaWwnIGdyaWQpLlxuXG4gICAgVGhlIGF4aXMgaXMgYWx3YXlzIGtlcHQgbmVhciB0aGUgbGVhZGluZyAoaGVhZHdhcmQpIGVkZ2Ugb2YgdGhlIHZpc2libGUgY2VsbCByb3dzIG9mIHRoZSBWaWV3cG9ydFxuICAgICh0aGVyZSBhcmUgc29tZSBlZGdlLWNhc2UgZXhjZXB0aW9ucykuXG5cbiAgICBUZWNobmljYWxseSwgdGhlcmUgYXJlIHNldmVyYWwga2V5IHJlZmVyZW5jZSBwb2ludHMgdHJhY2tlZCBieSB0aGUgQ3JhZGxlLiBUaGVzZSBhcmU6XG4gICAgICAgIC0gYXhpc1JlZmVyZW5jZUluZGV4IGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIHRoZSBpdGVtIGNvbnRyb2xsaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgYXhpcy5cbiAgICAgICAgICAgIFRoZSBheGlzUmVmZXJlbmNlSW5kZXggaXMgYWxzbyB1c2VkIHRvIGFsbG9jYXRlIGl0ZW1zIGFib3ZlIChsb3dlciBpbmRleCB2YWx1ZSkgYW5kIGJlbG93IFxuICAgICAgICAgICAgKHNhbWUgb3IgaGlnaGVyIGluZGV4IHZhbHVlKSB0aGUgYXhpcyBmb2xkLiBUaGUgYXhpc1JlZmVybmNlSW5kZXggaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIFxuICAgICAgICAgICAgdGFpbCBzZWN0aW9uIG9mIHRoZSBDcmFkbGUuXG4gICAgICAgIC0gKGNyYWRsZVJlZmVyZW5jZUluZGV4IGlzIGluZmVycmVkIGZyb20gdGhlIGF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIFxuICAgICAgICAgICAgdGhlIGl0ZW0gZGVmaW5pbmcgdGhlIGxlYWRpbmcgYm91bmQgb2YgdGhlIGNyYWRsZSBjb250ZW50LiBUaGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdXN1YWxseSBcbiAgICAgICAgICAgIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBoZWFkIHNlY3Rpb24gb2YgdGhlIENyYWRsZSwgdW5sZXNzIHRoZSBjcmFkbGUgc2hvd3MgdGhlIHZlcnkgdG9wIG9mIHRoZVxuICAgICAgICAgICAgbGlzdCwgaW4gd2hpY2ggY2FzZSB0aGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIEF4aXNSZWZlcmVuY2VJbmRleClcbiAgICAgICAgLSBheGlzVmlld3BvcnRQaXhlbE9mZnNldCAocGl4ZWxzIHRoYXQgcGxhY2UgdGhlIGF4aXMgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0J3MgbGVhZGluZyBlZGdlKVxuICAgICAgICAtIHRoZSBibG9ja1Njcm9sbFBvcywgd2hpY2ggaXMgdGhlIGFtb3VudCBvZiBzY3JvbGwgKFZpZXdwb3J0IHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0KSBvZiB0aGUgXG4gICAgICAgICAgICBTY3JvbGxCbG9ja1xuICAgIFxuICAgIE92ZXJzY3JvbGwgaGFuZGxpbmcgKHJlcG9zaXRpb25pbmcpOlxuICAgICAgICBPd2luZyB0byB0aGUgcG90ZW50aWFsIHJhcGlkaXR5IG9mIHNjcm9sbGluZywgd2hpY2ggaW4gdGhlIGNhc2Ugb2YgbGFyZ2UgbGlzdHMgYW5kIGhlYXZ5IGNvbnRlbnQgXG4gICAgICAgIGNhbiBiZSB0b28gZmFzdCBmb3IgdGhlIHN5c3RlbSB0byBrZWVwIHVwLCB0aGVyZSBpcyBhbiBvdmVyc2Nyb2xsIHByb3RvY29sIGNhbGxlZCAncmVwb3NpdGlvbmluZycuXG5cbiAgICAgICAgSWYgdGhlIG92ZXJzY3JvbGwgaXMgc3VjaCB0aGF0IHRoZSBjcmFkbGUgKGluY2x1ZGluZyBpdHMgdHdvIGNvbnRlbnQgZ3JpZHMpIGhhcyBlbnRpcmVseSBwYXNzZWQgXG4gICAgICAgIG91dCBvZiB0aGUgdmlld3BvcnQsIHRoZW4gdGhlIENyYWRsZSBjb21wb25lbnQgaXMgcmVwbGFjZWQgYnkgYSBTY3JvbGxUcmFja2VyIChvciBieSBudWxsIGlmIFxuICAgICAgICB0aGUgaG9zdCB0YWtlcyByZXNwb25zaWJpbGl0eSBmb3IgZmVlZGJhY2spLiBUaGUgU2Nyb2xsVHJhY2tlciBkaXNwbGF5cyB0byB0aGUgdXNlciB0aGUgcmVsYXRpdmUgXG4gICAgICAgIGxvY2F0aW9uIGluIHRoZSB2aXJ0dWFsIGxpc3QgYXQgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGR1cmluZyByZXBvc2l0aW9uaW5nLiBXaGVuIHRoZSBzY3JvbGxpbmdcbiAgICAgICAgc3RvcHMgQ3JhZGxlIHJlY3JlYXRlcyB0aGUgY3JhZGxlIGNvbnRlbnQsIGFjY29yZGluZyB0byB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIHJlcG9zaXRpb25pbmcgXG4gICAgICAgIHByb2Nlc3MuXG5cbiAgICBDcmFkbGUgaXMgYWN0aXZhdGVkIGJ5IGludGVycnVwdHM6XG4gICAgLSBzY3JvbGxpbmdcbiAgICAtIHJlc2l6aW5nIG9mIHRoZSB2aWV3cG9ydFxuICAgIC0gb2JzZXJ2ZXIgY2FsbGJhY2tzOlxuICAgICAgICAtIGNyYWRsZS92aWV3cG9ydCBpbnRlcnNlY3Rpb24gZm9yIHJlcG9zaXRpb25pbmcgd2hlbiB0aGUgY3JhZGxlIHJhY2VzIG91dCBvZiBzY29wZVxuICAgICAgICAtIHR3byAndHJpZ2dlcmxpbmUnL3ZpZXdwb3J0IGludGVyc2VjdGlvbnMgd2hpY2ggdHJpZ2dlciByb2xsaW5nIG9mIGNvbnRlbnRcbiAgICAgICAgICAgIC0gcm9sbGluZyBjb250ZW50IHRyaWdnZXJzIHJlLWFsbG9jYXRpb24gb2YgY29udGVudCBiZXR3ZWVuIGNyYWRsZSBoZWFkIGFuZCB0YWlsIGdyaWRzXG4gICAgLSBwaXZvdCAtIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIC0gaG9zdCBjaGFuZ2VzIG9mIGNvbmZpZ3VyYXRpb24gc3BlY3MgdGhyb3VnaCBwcm9wZXJ0eSBjaGFuZ2VzIG9yIGRpcmVjdCBzZXJ2aWNlIGNhbGxzXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZVJlZiwgXG4gICAgdXNlQ29udGV4dCwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZU1lbW8sXG4gICAgdXNlQ2FsbGJhY2ssIFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgVmlld3BvcnRDb250ZXh0IH0gZnJvbSAnLi9WaWV3cG9ydCdcblxuLy8gcG9wdXAgcG9zaXRpb24gdHJhY2tlciBmb3IgcmVwb3NpdGlvbmluZ1xuaW1wb3J0IFNjcm9sbFRyYWNrZXIgZnJvbSAnLi9jcmFkbGUvU2Nyb2xsVHJhY2tlcidcblxuLy8gc3VwcG9ydCBjb2RlOyBwcm9jZXNzIGhhbmRsZXJzXG5pbXBvcnQgU2Nyb2xsSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zY3JvbGxoYW5kbGVyJ1xuaW1wb3J0IFN0YXRlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zdGF0ZWhhbmRsZXInXG5pbXBvcnQgQ29udGVudEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvY29udGVudGhhbmRsZXInXG5pbXBvcnQgTGF5b3V0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9sYXlvdXRoYW5kbGVyJ1xuaW1wb3J0IEludGVycnVwdEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvaW50ZXJydXB0aGFuZGxlcidcbmltcG9ydCBTZXJ2aWNlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zZXJ2aWNlaGFuZGxlcidcbmltcG9ydCBTdHlsZXNIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3N0eWxlc2hhbmRsZXInXG4vLyBjYWNoZUhhbmRsZXIgaXMgaW1wb3J0ZWQgYXMgYSBwcm9wZXJ0eTsgaW5zdGFudGlhdGVkIGF0IHRoZSByb290XG5cbi8vIGZvciBjaGlsZHJlblxuZXhwb3J0IGNvbnN0IENyYWRsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpXG5cbi8vIGNvbXBvbmVudFxuY29uc3QgQ3JhZGxlID0gKHsgXG4gICAgICAgIGdyaWRTcGVjcyxcblxuICAgICAgICBydW53YXlTaXplLCBcbiAgICAgICAgbGlzdHNpemUsIFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgdXNlckNhbGxiYWNrcyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIGZvciBoYW5kbGVyIGxpc3RcbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAvLyBzeXN0ZW1cbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlcixcbiAgICAgICAgc2hvd0F4aXMsXG4gICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLFxuICAgICAgICBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMsXG4gICAgfSkgPT4ge1xuXG4gICAgaWYgKGxpc3RzaXplID09IDApIHJldHVybiBudWxsIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PVsgREFUQSBTRVRVUCBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1bnBhY2sgZ3JpZFNwZWNzXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICAvLyBnZXQgdmlld3BvcnQgY29udGV4dFxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIC8vIGZvciBjbG9zdXJlc1xuXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNcbiAgICBjb25zdCB7IGhlaWdodDp2aWV3cG9ydGhlaWdodCx3aWR0aDp2aWV3cG9ydHdpZHRoIH0gPSB2aWV3cG9ydERpbWVuc2lvbnNcblxuICAgIC8vIHN0YXRlXG4gICAgY29uc3QgW2NyYWRsZVN0YXRlLCBzZXRDcmFkbGVTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuICAgIGNvbnN0IGNyYWRsZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPSBjcmFkbGVTdGF0ZVxuXG4gICAgLy8gY29uc29sZS5sb2coJz09PiBjcmFkbGVTdGF0ZScsJy0nK3Njcm9sbGVySUQrJy0nLGNyYWRsZVN0YXRlKVxuXG4gICAgLy8gZmxhZ3NcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0NhY2hlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCB3YXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IGhhc0JlZW5SZW5kZXJlZFJlZiA9IHVzZVJlZihmYWxzZSlcblxuICAgIC8vIGNyYWRsZSBzY2FmZm9sZCBlbGVtZW50IHJlZnNcbiAgICBjb25zdCBoZWFkQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRhaWxDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgYXhpc0NyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGxheW91dCBidW5kbGVcbiAgICBjb25zdCBjcmFkbGVFbGVtZW50c1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZFJlZjpoZWFkQ3JhZGxlRWxlbWVudFJlZiwgXG4gICAgICAgICAgICB0YWlsUmVmOnRhaWxDcmFkbGVFbGVtZW50UmVmLCBcbiAgICAgICAgICAgIGF4aXNSZWY6YXhpc0NyYWRsZUVsZW1lbnRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZjp0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZjp0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbEVsZW1lbnRSZWYsXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZWQgcHJvcGVydGllcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29uZmlndXJhdGlvbiBjYWxjdWxhdGlvbnNcblxuICAgIC8vIGNyb3NzY291bnQgKGFsc28gY2FsY3VsYXRlZCBieSBTY3JvbGxibG9jayBmb3IgZGVyaXZpbmcgU2Nyb2xsYmxvY2sgbGVuZ3RoKVxuICAgIGNvbnN0IGNyb3NzY291bnQgPSB1c2VNZW1vKCgpID0+IHsgLy8gdGhlIG51bWJlciBvZiBjZWxscyBjcm9zc2luZyBvcmllbnRhdGlvblxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0Y3Jvc3NsZW5ndGggPT0gMCkge1xuXG4gICAgICAgICAgICByZXR1cm4gMFxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcm9zcyBsZW5ndGggb2Ygdmlld3BvcnQgKGdhcCB0byBtYXRjaCBjcm9zc0xlbmd0aClcbiAgICAgICAgY29uc3Qgdmlld3BvcnRjcm9zc2xlbmd0aGZvcmNhbGMgPSB2aWV3cG9ydGNyb3NzbGVuZ3RoIC0gKHBhZGRpbmcgKiAyKSArIGdhcCBcblxuICAgICAgICBjb25zdCBjZWxsY3Jvc3NsZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKyBnYXA6XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCArIGdhcFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aGZvcmNhbGMgPSBcbiAgICAgICAgICAgIE1hdGgubWluKGNlbGxjcm9zc2xlbmd0aCx2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYykgLy8gcmVzdWx0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMVxuXG4gICAgICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjL2NlbGxjcm9zc2xlbmd0aGZvcmNhbGMpXG5cbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICAvLyB2YXJpb3VzIHJvdyBjb3VudHNcbiAgICBjb25zdCBbXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LCBcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LCAvLyBtYXhpbXVtIG51bWJlciBvZiByb3dzIGNvbXBsZXRlbHkgdmlzaWJsZSBhdCBvbmNlXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRMZW5ndGggPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoXG5cbiAgICAgICAgbGV0IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsSGVpZ2h0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbFdpZHRoXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBsYXlvdXQgPT0gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxNaW5IZWlnaHRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsTWluV2lkdGhcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBiYXNlUm93TGVuZ3RoICs9IGdhcFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Um93Y291bnQgPSBNYXRoLmNlaWwodmlld3BvcnRMZW5ndGgvYmFzZVJvd0xlbmd0aClcblxuICAgICAgICBjb25zdCB2aWV3cG9ydFZpc2libGVSb3djb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRMZW5ndGgvYmFzZVJvd0xlbmd0aClcblxuICAgICAgICBjb25zdCBsaXN0Um93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPSB2aWV3cG9ydFJvd2NvdW50ICsgKHJ1bndheVNpemUgKiAyKVxuXG4gICAgICAgIGxldCBjcmFkbGVSb3djb3VudCA9IE1hdGgubWluKGxpc3RSb3djb3VudCwgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50KVxuXG4gICAgICAgIGxldCBydW53YXlSb3djb3VudFxuICAgICAgICBpZiAoY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50ID49IGNyYWRsZVJvd2NvdW50KSB7XG5cbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gcnVud2F5U2l6ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAoY3JhZGxlUm93Y291bnQgLSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCAtPSBNYXRoLmZsb29yKGRpZmYvMilcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gTWF0aC5tYXgoMCxydW53YXlSb3djb3VudClcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW1jb3VudCA9IGNyYWRsZVJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgICAgICBpZiAoaXRlbWNvdW50ID4gbGlzdHNpemUpIHtcblxuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRSb3djb3VudCwgXG4gICAgICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG5cbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxheW91dCxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsbGJhY2tzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBob3N0IGNhbGxiYWNrcywgdXBhY2tlZCBieSBzZXJ2aWNlSGFuZGxlclxuICAgIGNvbnN0IGV4dGVybmFsQ2FsbGJhY2tzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5wcmVsb2FkSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5kZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/Lml0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVsgYnVuZGxlIHByb3BlcnRpZXMgZm9yIGhhbmRsZXJzIF0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBidW5kbGUgYWxsIGNyYWRsZSBwcm9wcyB0byBwYXNzIHRvIGhhbmRsZXJzIC0gdWx0aW1hdGVseSBjcmFkbGVQYXJhbWV0ZXJzUmVmXG4gICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXMgYW5kIHN1cHBvcnQgY2FsbGJhY2tzXG4gICAgLy8gdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIC8vIGdyaWRTcGVjc1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIC8vIC4uLnJlc3RcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgdXNlckNhbGxiYWNrcyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIC8vIGNvbnRyb2wgdmFsdWVzXG4gICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMLFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG5cbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyBwYXNzZWQgdG8gY2VsbEZyYW1lIGNvbnRlbnQgKHVzZXIgY29udGVudCkgaWYgcmVxdWVzdGVkXG4gICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCwgXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBjYWNoZU1heCxcbiAgICAgICAgc3RhcnRpbmdJbmRleCwgXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgIH1cblxuICAgIC8vIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBzaGFyZSB3aXRoIGhhbmRsZXJzXG4gICAgY29uc3QgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG5cbiAgICAgICAgLy8gdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBydW53YXlSb3djb3VudCxcblxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgbWFpbnRhaW5lZCBlbHNld2hlcmVcbiAgICAgICAgaXNNb3VudGVkUmVmLFxuICAgICAgICBjcmFkbGVFbGVtZW50c1JlZixcbiAgICAgICAgaXNDYWNoZWRSZWYsXG4gICAgICAgIHdhc0NhY2hlZFJlZixcblxuICAgICAgICAvLyBmb3Igc3RhdGVIYW5kbGVyXG4gICAgICAgIGNyYWRsZVN0YXRlUmVmLFxuICAgICAgICBzZXRDcmFkbGVTdGF0ZSxcbiAgICB9XG5cbiAgICAvLyBwbGFjZWhvbGRlciBpbiBjcmFkbGVQYXJhbWV0ZXJzIHRvIG1ha2UgYXZhaWxhYmxlIGluZGl2aWR1YWwgaGFuZGxlcnNcbiAgICBjb25zdCBoYW5kbGVyc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gY3JhZGxlIHBhcmFtZXRlcnMgTUFTVEVSIEJVTkRMRVxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnMgPSB7XG4gICAgICAgIGhhbmRsZXJzUmVmLFxuICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLFxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBleHRlcm5hbENhbGxiYWNrc1JlZixcbiAgICB9XG5cbiAgICBjb25zdCBjcmFkbGVQYXJhbWV0ZXJzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY3JhZGxlUGFyYW1ldGVyc1JlZi5jdXJyZW50ID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgLy8gb25nb2luZyBzb3VyY2Ugb2YgaGFuZGxlcnMgLSBub3RlIGFsbCBIYW5kbGVycyBhcmUgZ2l2ZW4gYWxsIHBhcmFtZXRlcnMgKGNyYWRsZVBhcmFtZXRlcnMpXG4gICAgaWYgKCFoYW5kbGVyc1JlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgaGFuZGxlcnNSZWYuY3VycmVudCA9IGdldENyYWRsZUhhbmRsZXJzKGNyYWRsZVBhcmFtZXRlcnMpXG5cbiAgICB9XG5cbiAgICAvLyBtYWtlIGhhbmRsZXJzIGRpcmVjdGx5IGF2YWlsYWJsZSB0byBjcmFkbGUgY29kZSBiZWxvd1xuICAgIGNvbnN0IHsgLy8gY2FjaGVIYW5kbGVyIGFscmVhZHkgYXZhaWxhYmxlXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgIHNjcm9sbEhhbmRsZXIsXG4gICAgICAgIHN0YXRlSGFuZGxlcixcbiAgICAgICAgY29udGVudEhhbmRsZXIsXG4gICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICBzdHlsZXNIYW5kbGVyLFxuICAgIH0gPSBoYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVsgSU5URVJDRVBUIENBQ0hJTkcgU1RBVEUgQ0hBTkdFIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qICAgIFxuICAgIEludGVyY2VwdCBjaGFuZ2UgaW4gY2FjaGluZyBzdGF0dXM6XG4gICAgd2hlbiBhIGNvbXBvbmVudCBpcyBpcyBjYWNoZWQgaW4gYSBwb3J0YWwgKGluIHRoZSBSZWFjdCB2aXJ0dWFsIERPTSksIGluY2x1ZGluZyB0aGUgdHJhbnNpdGlvbiBvZiBcbiAgICBiZWluZyBtb3ZlZCBmcm9tIG9uZSBjZWxsRnJhbWUgdG8gYW5vdGhlciB3aGVuIGNyb3NzaW5nIHRoZSBDcmFkbGUgYXhpcywgXG4gICAgdGhlIHNjcm9sbFBvcyAoc2Nyb2xsTGVmdCBvciBzY3JvbGxUb3ApIGlzIHJlc2V0IHRvIDAgKHplcm8pLiBXaGVuIHRoZSBzY3JvbGxlciBpcyBcbiAgICBtb3ZlZCB0byBhIGNlbGxGcmFtZSwgdGhpcyBjb2RlIHRyaWdnZXJzIHJlc3RvcmF0aW9uIHRoZSBzY3JvbGxQb3MgKHNlZSBjYXNlICdwYXJlbnRpbmd0cmFuc2l0aW9uJ1xuICAgIGluIHRoZSBzdGF0ZSBtYW5hZ2VtZW50IHNlY3Rpb24gYmVsb3cpLlxuXG4gICAgTm90IHRoYXQgSW5maW5pdGVHcmlkU2Nyb2xsZXIgY29tcG9uZW50cyBjYW4gdGhlbXNlbHZlcyBiZSBjYWNoZWQgYXMgY29udGVudC5cblxuICAgIFRoZSByZXN0b3JlIHNjcm9sbFBvcyBhY3Rpb24gbXVzdCBiZSB0aGUgZmlyc3QgcHJpb3JpdHkgdG8gaGlkZSB0aGVzZSBzY3JvbGxQb3MgYWRqdXN0bWVudHNcbiAgICBmcm9tIHRoZSB1c2VyLlxuKi9cbiAgICAvLyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgbWVhbnMgdGhlIGNvbXBvbmVudCBtdXN0IGJlIGluIHBvcnRhbCAoY2FjaGUpIHN0YXRlXG4gICAgY29uc3QgaXNJblBvcnRhbCA9ICgodmlld3BvcnR3aWR0aCA9PSAwKSAmJiAodmlld3BvcnRoZWlnaHQgPT0gMCkpIFxuXG4gICAgY29uc3QgaXNDYWNoZUNoYW5nZSA9IChpc0luUG9ydGFsICE9IGlzQ2FjaGVkUmVmLmN1cnJlbnQpXG5cbiAgICBpZiAoaXNDYWNoZUNoYW5nZSkge1xuICAgICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGlzQ2FjaGVkUmVmLmN1cnJlbnRcbiAgICAgICAgaXNDYWNoZWRSZWYuY3VycmVudCA9IGlzSW5Qb3J0YWxcbiAgICB9XG5cbiAgICBjb25zdCBpc0NhY2hpbmdVbmRlcndheSA9IChpc0NhY2hlZFJlZi5jdXJyZW50IHx8IHdhc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UgfHwgXG4gICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZj8uY3VycmVudCB8fFxuICAgICAgICAoVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nICYmIGlzQ2FjaGluZ1VuZGVyd2F5KSkgeyBcblxuICAgICAgICBpZiAoVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZi5jdXJyZW50ID0gZmFsc2UgLy8gbm8gbG9uZ2VyIG5lZWRlZFxuXG4gICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHsgLy8gY2FjaGluZyBvcCBpcyB1bmRlcndheSwgc28gY2FuY2VsXG5cbiAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZyA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhY2hlQ2hhbmdlKSB7IC8vIGludG8gb3Igb3V0IG9mIGNhY2hpbmdcblxuICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgc3RhdGUgZm9yIHJlc3RvcmluZyBzY3JvbGxQb3NcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyBpZiBpcyBjYWNoZWQsIHRoZW4gdGhlIG5leHQgZWZmZWN0IChmb3IgZW50ZXJpbmcgb3IgbGVhdmluZyBjYWNoZSkgaGFzIGFub3RoZXIgdHVyblxuICAgICAgICBpZiAocGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgPSBmYWxzZSAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuICAgICAgICB9XG5cbiAgICB9LFtwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyBjaGFuZ2Ugc3RhdGUgZm9yIGVudGVyaW5nIG9yIGxlYXZpbmcgY2FjaGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm4gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50ICYmICF3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBpbnRvIGNhY2hlXG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKSAvLyByZXBsYWNlcyAncmVhZHknIGFzIHN0ZWFkeSBzdGF0ZVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHsgLy8gb3V0IG9mIGNhY2hlXG5cbiAgICAgICAgICAgIHdhc0NhY2hlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IGZhbHNlICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtpc0NhY2hlZFJlZi5jdXJyZW50LCB3YXNDYWNoZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09WyBJTklUSUFMSVpBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWZmZWN0cyBhcmUgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xuXG4gICAgLy8gY2xlYXIgbW91bnRlZCBmbGFnIG9uIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyB1bm1vdW50XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy9zZW5kIGNhbGwtaW4gZnVuY3Rpb25zIHRvIGhvc3RcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoIXVzZXJDYWxsYmFja3MuZ2V0RnVuY3Rpb25zKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIHNjcm9sbFRvSXRlbSwgXG4gICAgICAgICAgICByZWxvYWQsIFxuICAgICAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgICAgICBjbGVhckNhY2hlLCBcblxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCwgXG4gICAgICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcbiAgICAgICAgICAgIHJlbWFwSW5kZXhlcyxcbiAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlSW5kZXgsXG5cbiAgICAgICAgfSA9IHNlcnZpY2VIYW5kbGVyXG5cbiAgICAgICAgY29uc3QgZnVuY3Rpb25zID0ge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0l0ZW0sXG4gICAgICAgICAgICByZWxvYWQsXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdldENhY2hlSW5kZXhNYXAsXG4gICAgICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgICAgICBnZXRDcmFkbGVJbmRleE1hcCxcbiAgICAgICAgICAgIHJlbWFwSW5kZXhlcyxcbiAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlSW5kZXgsXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHVzZXJDYWxsYmFja3MuZ2V0RnVuY3Rpb25zKGZ1bmN0aW9ucylcblxuICAgIH0sW10pXG5cbiAgICAvLyBpbml0aWFsaXplIHdpbmRvdyBzY3JvbGwgbGlzdGVuZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5vblNjcm9sbClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50ICYmIHZpZXdwb3J0ZGF0YS5lbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxzY3JvbGxIYW5kbGVyLm9uU2Nyb2xsKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyBvYnNlcnZlciBzdXBwb3J0XG4gICAgLypcbiAgICAgICAgVGhlcmUgYXJlIHR3byBpbnRlcmVjdGlvbiBvYnNlcnZlcnM6IG9uZSBmb3IgdGhlIGNyYWRsZSB3aW5ncywgYW5kIGFub3RoZXIgZm9yIHRyaWdnZXJsaW5lczsgXG4gICAgICAgICAgICBib3RoIGFnYWluc3QgdGhlIHZpZXdwb3J0LlxuICAgICovICAgIFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNyYWRsZUludGVyc2VjdCxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lc0ludGVyc2VjdCxcbiAgICAgICAgfSA9IGludGVycnVwdEhhbmRsZXJcblxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgZm9yIGNyYWRsZSBib2R5XG4gICAgICAgIC8vIHRoaXMgc2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvZiB0aGUgY3JhZGxlIGFnYWluc3QgdGhlIHZpZXdwb3J0LiBXaGVuIHRoZVxuICAgICAgICAvLyBjcmFkbGUgZ29lcyBvdXQgb2YgdGhlIG9ic2VydmVyIHNjb3BlLCB0aGUgJ3JlcG9zaXRpb25pbmdSZW5kZXInIGNyYWRsZSBzdGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGNvbnN0IGNyYWRsZWludGVyc2VjdG9ic2VydmVyID0gY3JhZGxlSW50ZXJzZWN0LmNyZWF0ZU9ic2VydmVyKClcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgLy8gdHJpZ2dlcm9ic2VydmVyIHRpZ2dlcnMgY3JhZGxlIGNvbnRlbnQgdXBkYXRlcyBcbiAgICAgICAgLy8gICAgIHdoZW4gdHJpZ2dlcmxpbmVzIHBhc3MgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIC8vIGRlZmVyIGNvbm5lY3RFbGVtZW50cyB1bnRpbCB0cmlnZ2VyY2VsbCB0cmlnZ2VybGluZXMgaGF2ZSBiZWVuIGFzc2lnbmVkXG4gICAgICAgIGNvbnN0IHRyaWdnZXJvYnNlcnZlciA9IHRyaWdnZXJsaW5lc0ludGVyc2VjdC5jcmVhdGVPYnNlcnZlcigpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB0cmlnZ2Vyb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgUkVDT05GSUdVUkFUSU9OIGVmZmVjdHMgXT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBjaGFuZ2UgbGlzdHNpemUsIGNhY2hpbmcsIHJlc2l6ZSAoVUkgcmVzaXplIG9mIHRoZSB2aWV3cG9ydCksIHJlY29uZmlndXJlLCBvciBwaXZvdFxuXG4gICAgLy8gY2FsbGJhY2s6IHRoZSBuZXcgbGlzdCBzaXplIHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJyZW50IGxpc3RzaXplXG4gICAgLy8gaW52b2tlZCBpZiBnZXRJdGVtIHJldHVybnMgbnVsbFxuICAgIGNvbnN0IG51bGxJdGVtU2V0TWF4TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobWF4TGlzdHNpemUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdHNpemUgPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5saXN0c2l6ZVxuXG4gICAgICAgIGlmIChtYXhMaXN0c2l6ZSA8IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2dldEl0ZW0gcmV0dXJuZWQgbnVsbCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2hhbmdlTGlzdHNpemUobWF4TGlzdHNpemUsIFxuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjaylcblxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIGNhY2hpbmcgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIGlmIChjYWNoZSA9PSAncHJlbG9hZCcpIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3N0YXJ0cHJlbG9hZCcpXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBzd2l0Y2ggKGNhY2hlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2tlZXBsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1heCA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LmNhY2hlTWF4XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KGNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2hhbmdlY2FjaGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjcmFkbGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjaGFuZ2VjYWNoaW5nJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbY2FjaGUsIGNhY2hlTWF4XSlcblxuICAgIC8vIHRyaWdnZXIgdmlld3BvcnRyZXNpemluZyByZXNwb25zZSBiYXNlZCBvbiB2aWV3cG9ydCBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIC8vIG1vdmVtZW50IHRvIGFuZCBmcm9tIGNhY2hlIGlzIGluZGVwZW5kZW50IG9mIHVpIHZpZXdwb3J0cmVzaXppbmdcbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgfHwgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcpICYmIFxuICAgICAgICAgICAgICAgIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ICE9ICd2aWV3cG9ydHJlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ZpZXdwb3J0cmVzaXppbmcnKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wbGV0ZSB2aWV3cG9ydHJlc2l6aW5nIG1vZGVcbiAgICAgICAgaWYgKCFWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyAmJiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAndmlld3BvcnRyZXNpemluZycpKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h2aWV3cG9ydHJlc2l6ZScpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmddKVxuXG4gICAgLy8gcmVjb25maWd1cmUgZm9yIGNoYW5nZWQgc2l6ZSBwYXJhbWV0ZXJzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVjb25maWd1cmUnKVxuXG4gICAgfSxbXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXRcbiAgICBdKVxuXG4gICAgLy8gcGl2b3QgdHJpZ2dlcmVkIG9uIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKT9cInNjcm9sbFRvcFwiOlwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBnZXQgcHJldmlvdXMgcmF0aW9cbiAgICAgICAgY29uc3QgcHJldmlvdXNDZWxsUGl4ZWxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoOlxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQpXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc09mZnNldCA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNyYXRpbyA9IHByZXZpb3VzQXhpc09mZnNldC9wcmV2aW91c0NlbGxQaXhlbExlbmd0aFxuXG4gICAgICAgIGNvbnN0IHBpdm90Q2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBwaXZvdEF4aXNPZmZzZXQgPSBwcmV2aW91c3JhdGlvICogcGl2b3RDZWxsUGl4ZWxMZW5ndGhcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gTWF0aC5yb3VuZChwaXZvdEF4aXNPZmZzZXQpXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZUF4aXNTdHlsZSxcbiAgICAgICAgY3JhZGxlRGl2aWRlclN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlLFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLmdldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgdXNlcnN0eWxlczpzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgICAgIGxheW91dCxcblxuICAgICAgICB9KVxuXG4gICAgfSxbXG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUQVRFIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZSAoYWJvdXQgMzAgc3RhdGVzKSwgdXNpbmcgbmFtZWQgc3RhdGVzXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGZvciBzdXBwcmVzc2luZyBmbGFzaGVzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29ycyB0byBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhbGwgd29ya2Zsb3cgcmVsYXRlZCwgYnV0XG4gICAgICAgICAgICAvLyByZXNpemUgY291bGQgYmUgYXN5bmNocm9ub3VzIHdoZW4gcm90YXRpbmcgcGhvbmUgZHVyaW5nIHNjcm9sbCBpbnRlcnRpYVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBhc3NpZ25tZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZSAhPSAncHJlbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyJykgLy8gbG9hZCBncmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydHJlc2l6aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgLy8gbm8tb3AsIHdhaXQgZm9yIHJlc2l6aW5nIHRvIGVuZFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cHJlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIucGFyZUNhY2hlVG9NYXgoY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHByZWxvYWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5wcmVsb2FkKGZpbmFsQ2FsbGJhY2ssIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIHNjcm9sbGVySUQpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjYWNoZWQnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXdhc0NhY2hlZFJlZi5jdXJyZW50ICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KXtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB3YWl0IGZvciByZXBhcmVudGluZ1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92aW5nIG91dCBvZiBjYWNoZSBpbnRvIHZpc2libGUgRE9NIHRyZWUgKGNlbGxGcmFtZSlcbiAgICAgICAgICAgIC8vIHJlc2V0cyBzY3JvbGxQb3MgKHNjcm9sbExlZnQvc2Nyb2xsVG9wKSB0byBsYXN0IFVJIHZhbHVlXG4gICAgICAgICAgICBjYXNlICdwYXJlbnRpbmd0cmFuc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgc2Nyb2xsIHBvc2l0aW9uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hwYXJlbnRpbmcnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2hwYXJlbnRpbmcnOntcblxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucmVzdG9yZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0Q3JhZGxlU3RhdGUoJ3Jlc3RvcmVpbnRlcnJ1cHRzJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cmVwb3NpdGlvbic6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgcmVjdXJzaXZlIGNyYWRsZSBpbnRlcnNlY3Rpb24gaW50ZXJydXB0c1xuICAgICAgICAgICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWVcbiAgICAgICAgICAgICAgICBzaWduYWxzLnJlcG9zaXRpb25pbmdSZXF1aXJlZCA9IGZhbHNlIC8vIGJlY2F1c2Ugbm93IHVuZGVyd2F5XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSGFuZGxlci5pc1Njcm9sbGluZykge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nUmVuZGVyJykgLy8gdG9nZ2xlcyB3aXRoIHJlcG9zaXRpb25pbmdDb250aW51YXRpb25cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHJlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0aGUgZm9sbG93aW5nIDExIGNyYWRsZSBzdGF0ZXMgYWxsIHJlc29sdmUgd2l0aFxuICAgICAgICAgICAgICAgIGEgY2hhaW4gc3RhcnRpbmcgd2l0aCBzZXRDcmFkbGVDb250ZW50LCBcbiAgICAgICAgICAgICAgICBjb250aW51aW5nIHdpdGggJ3ByZXBhcmVyZW5kZXInLCBhbmQgZW5kaW5nIHdpdGhcbiAgICAgICAgICAgICAgICAncmVzdG9yZWludGVycnVwdHMnXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FzZSAnZmlyc3RyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAnZmlyc3RyZW5kZXJmcm9tY2FjaGUnOlxuICAgICAgICAgICAgY2FzZSAncmVyZW5kZXJmcm9tY2FjaGUnOlxuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsdG8nOlxuICAgICAgICAgICAgY2FzZSAnY2hhbmdlY2FjaGluZyc6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2hwcmVsb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHJlcG9zaXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNodmlld3BvcnRyZXNpemUnOlxuICAgICAgICAgICAgY2FzZSAncGl2b3QnOlxuICAgICAgICAgICAgY2FzZSAncmVjb25maWd1cmUnOlxuICAgICAgICAgICAgY2FzZSAncmVsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVsb2FkJykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGRhdGFcbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5zZXRDcmFkbGVDb250ZW50KCBjcmFkbGVTdGF0ZSApXG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgIT0gJ2ZpbmlzaHByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9uaXplIGNhY2hlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PSAnY3JhZGxlJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGN5Y2xlIGZvciBwcmVwYXJlcmVuZGVyXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZpcnR1YWwgRE9NXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwcmVwYXJlcmVuZGVyJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlZnJlc2hET01zZXRmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZWZyZXNoRE9Nc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncHJlcGFyZXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncHJlcGFyZXNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIGdpdmUgdGltZSBmb3IgRE9NIHRvIHByb2R1Y2UgbGF5b3V0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgnc2V0Y3JhZGxlJylcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNoc2V0Zm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgfSxUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2hzZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdwcmVwYXJlcmVuZGVyJylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlcmVuZGVyJzogeyAvLyBjeWNsZSBmb3IgRE9NIHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmxpbmVzIHdpbGwgaGF2ZSBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IHRyaWdnZXJDZWxsIGJ5IG5vdy5cbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0RWxlbWVudHMgZGVsYXllZCBmb3IgYSBjeWNsZSB0byByZW5kZXIgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gYmUgcHJlLWVtcHRlZCBieSByZXBhcmVudGluZywgd2hpY2ggaXRzZWxmIHJlc3RvcmVzIGludGVycnVwdHNcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVzdG9yZWludGVycnVwdHMnKSAvLyB0byByZXN0b3JlIGludGVycnVwdHNcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3Jlc3RvcmVpbnRlcnJ1cHRzJzogeyAvLyBub3JtYWxpemUgb3IgcmVzdW1lIGN5Y2xpbmdcblxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucmVzdG9yZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrIFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGZvbGxvd3VwIGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudCBdLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBzY3JvbGwgZWZmZWN0c1xuXG4gICAgICAgICAgICAvLyByZW5kZXJ1cGRhdGVkY29udGVudCBpcyBjYWxsZWQgZnJvbSB1cGRhdGVDcmFkbGVDb250ZW50LiBcbiAgICAgICAgICAgIC8vIGl0IGlzIHJlcXVpcmVkIHRvIGludGVncmF0ZSBjaGFuZ2VkIERPTSBjb25maWd1cmF0aW9ucyBiZWZvcmUgJ3JlYWR5JyBpcyBkaXNwbGF5ZWRcbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlcnVwZGF0ZWRjb250ZW50JzogeyAvLyBjeWNsZSBmb3IgRE9NIHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZpcnR1YWwgRE9NXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHVwZGF0ZWRjb250ZW50JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNodXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cblxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9uaXplIGNhY2hlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nKClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlZnJlc2hET011cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZWZyZXNoRE9NdXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYSBjeWNsZSBuZWVkZWQgdG8gYWxsb3cgdGltZSB0byBzeW5jaHJvbml6ZSBET00gd2l0aCBncmlkIGNoYW5nZXNcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdhZGp1c3R1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgndXBkYXRlY3JhZGxlJylcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGxlZCBmcm9tIG9uQWZ0ZXJTY3JvbGwuIFxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gYmUgY2FsbGVkIHR3aWNlIGluIHN1Y2Nlc3Npb24gd2l0aCBzaG9ydCBvbkFmdGVyU2Nyb2xsIHRpbWVvdXRcbiAgICAgICAgICAgIGNhc2UgJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5YWZ0ZXJzY3JvbGwnOiB7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCdhZnRlcnNjcm9sbCcpXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLVsgdXNlciByZXF1ZXN0cyBdLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciB2YXJpb3VzIGhvc3Qgc2VydmljZSByZXF1ZXN0czsgc3luY3MgY3JhZGxlIGNvbnRlbnQgd2l0aCBjYWNoZSBjaGFuZ2VzXG4gICAgICAgICAgICBjYXNlICdhcHBseWNlbGxmcmFtZWNoYW5nZXMnOiB7IC8vIHVzZXIgaW50ZXJ2ZW50aW9uXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnRhbEhvbGRMaXN0IH0gPSBjYWNoZUhhbmRsZXJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnRhbE1hcCB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHNcblxuICAgICAgICAgICAgICAgIGlmIChwb3J0YWxIb2xkTGlzdCAmJiBwb3J0YWxIb2xkTGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW1JRCBvZiBwb3J0YWxIb2xkTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY2xlYXJjYWNoZSc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmNsZWFyQ3JhZGxlKClcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyBzdGFuZGFyZCByZW5kZXJpbmcgc3RhdGVzICgzIHN0YXRlcylcbiAgICB1c2VFZmZlY3QoKCk9PiB7IFxuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlU3RhdGUpIHtcblxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbmluZ1JlbmRlciBhbmQgcmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbiBhcmUgdG9nZ2xlZCB0byBnZW5lcmF0ZSBjb250aW51b3VzIFxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbmluZyByZW5kZXJzXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nUmVuZGVyJzogLy8gbm8tb3BcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJzogLy8gc2V0IGZyb20gb25TY3JvbGxcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ1JlbmRlcicpXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVhZHknOiAvLyBuby1vcFxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVOREVSIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGNvbnN0IHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgIGNvbnN0IHNjcm9sbFRyYWNrZXJBcmdzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghdXNlU2Nyb2xsVHJhY2tlcikgcmV0dXJuIG51bGxcbiAgICAgICAgaWYgKCFbJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nLCdyZXBvc2l0aW9uaW5nUmVuZGVyJ10uaW5jbHVkZXMoY3JhZGxlU3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrZXJhcmdzID0ge1xuICAgICAgICAgICAgdG9wOnZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyAzLFxuICAgICAgICAgICAgbGVmdDp2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIDMsXG4gICAgICAgICAgICBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2tlcmFyZ3NcbiAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgICBjcmFkbGVTdGF0ZSwgXG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnMsIFxuICAgICAgICAgICAgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYuY3VycmVudCA9IHVzZU1lbW8oKCk9PntcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleSA9ICdoZWFkJ1xuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdoZWFkdHJpZ2dlcidcbiAgICAgICAgICAgICAgICBkYXRhLWRpcmVjdGlvbiA9ICd0YWlsd2FyZCdcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlfVxuICAgICAgICAgICAgICAgIHJlZiA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWZ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5ID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWx0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIGRhdGEtZGlyZWN0aW9uID0gJ2hlYWR3YXJkJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZVxuICAgIF0pXG5cbiAgICBjb25zdCBjb250ZXh0dmFsdWVSZWYgPSB1c2VSZWYoe1xuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBjYWNoZUhhbmRsZXIsIFxuICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplLFxuICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrOnNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5pdGVtRXhjZXB0aW9uc0NhbGxiYWNrLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSlcblxuXG4gICAgLy8gZGlzcGxheSB0aGUgY3JhZGxlIGNvbXBvbmVudHMsIHRoZSBTY3JvbGxUcmFja2VyLCBvciBudWxsXG4gICAgcmV0dXJuIDxDcmFkbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBjb250ZXh0dmFsdWVSZWYuY3VycmVudCB9PlxuXG4gICAgICAgIHsoWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSk/XG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MudG9wIH0gXG4gICAgICAgICAgICAgICAgbGVmdCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MubGVmdCB9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3Muc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IH0gXG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnN0eWxlcyB9XG4gICAgICAgICAgICAvPjpudWxsOlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWF4aXMnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZUF4aXNTdHlsZSB9IFxuICAgICAgICAgICAgICAgIHJlZiA9IHsgYXhpc0NyYWRsZUVsZW1lbnRSZWYgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgc2hvd0F4aXM/IC8vIGZvciBkZWJ1Z1xuICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2NyYWRsZS1kaXZpZGVyJyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVEaXZpZGVyU3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0geyBoZWFkQ3JhZGxlRWxlbWVudFJlZiB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVIZWFkU3R5bGUgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHsgdGFpbENyYWRsZUVsZW1lbnRSZWYgfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZVRhaWxTdHlsZSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7KGNyYWRsZVN0YXRlICE9ICdzZXR1cCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG5cbiAgICA8L0NyYWRsZUNvbnRleHQuUHJvdmlkZXI+XG5cbn0gLy8gQ3JhZGxlXG5cbmV4cG9ydCBkZWZhdWx0IENyYWRsZVxuXG4vLyB1dGlsaXR5XG5cbmNvbnN0IGdldENyYWRsZUhhbmRsZXJzID0gKGNyYWRsZVBhcmFtZXRlcnMpID0+IHtcblxuICAgIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSBoYW5kbGVyID0+IG5ldyBoYW5kbGVyKGNyYWRsZVBhcmFtZXRlcnMpXG5cbiAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgIGNhY2hlSGFuZGxlci5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIGludGVycnVwdEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihJbnRlcnJ1cHRIYW5kbGVyKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNjcm9sbEhhbmRsZXIpLFxuICAgICAgICBzdGF0ZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdGF0ZUhhbmRsZXIpLFxuICAgICAgICBjb250ZW50SGFuZGxlcjpjcmVhdGVIYW5kbGVyKENvbnRlbnRIYW5kbGVyKSxcbiAgICAgICAgbGF5b3V0SGFuZGxlcjpjcmVhdGVIYW5kbGVyKExheW91dEhhbmRsZXIpLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNlcnZpY2VIYW5kbGVyKSxcbiAgICAgICAgc3R5bGVzSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0eWxlc0hhbmRsZXIpLFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWN0XzEiLCJjcmVhdGVDb250ZXh0IiwiQ3JhZGxlIiwiZ3JpZFNwZWNzIiwicnVud2F5U2l6ZSIsImxpc3RzaXplIiwic3RhcnRpbmdJbmRleCIsImdldEl0ZW0iLCJwbGFjZWhvbGRlciIsInVzZXJDYWxsYmFja3MiLCJzdHlsZXMiLCJ0cmlnZ2VybGluZU9mZnNldCIsImNhY2hlIiwiY2FjaGVNYXgiLCJzY3JvbGxlcklEIiwiY2FjaGVIYW5kbGVyIiwidXNlU2Nyb2xsVHJhY2tlciIsInNob3dBeGlzIiwiU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwiLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsIlRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwibGF5b3V0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RGltZW5zaW9ucyIsInZpZXdwb3J0aGVpZ2h0IiwiaGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsIndpZHRoIiwiY3JhZGxlU3RhdGUiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaXNNb3VudGVkUmVmIiwiaXNDYWNoZWRSZWYiLCJ3YXNDYWNoZWRSZWYiLCJwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYiLCJoYXNCZWVuUmVuZGVyZWRSZWYiLCJoZWFkQ3JhZGxlRWxlbWVudFJlZiIsInRhaWxDcmFkbGVFbGVtZW50UmVmIiwiYXhpc0NyYWRsZUVsZW1lbnRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbEVsZW1lbnRSZWYiLCJjcmFkbGVFbGVtZW50c1JlZiIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiYXhpc1JlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJjcm9zc2NvdW50Iiwidmlld3BvcnRjcm9zc2xlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjIiwiY2VsbGNyb3NzbGVuZ3RoIiwiY2VsbGNyb3NzbGVuZ3RoZm9yY2FsYyIsIk1hdGgiLCJtaW4iLCJmbG9vciIsInZpZXdwb3J0TGVuZ3RoIiwiYmFzZVJvd0xlbmd0aCIsInZpZXdwb3J0Um93Y291bnQiLCJjZWlsIiwidmlld3BvcnRWaXNpYmxlUm93Y291bnQiLCJsaXN0Um93Y291bnQiLCJjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwiZGlmZiIsIm1heCIsIml0ZW1jb3VudCIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uc0NhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3JhZGxlUGFyYW1ldGVycyIsImNyYWRsZVBhcmFtZXRlcnNSZWYiLCJnZXRDcmFkbGVIYW5kbGVycyIsImludGVycnVwdEhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwic3RhdGVIYW5kbGVyIiwiY29udGVudEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJzdHlsZXNIYW5kbGVyIiwiaXNJblBvcnRhbCIsImlzQ2FjaGVDaGFuZ2UiLCJpc0NhY2hpbmdVbmRlcndheSIsImlzUmVwYXJlbnRpbmdSZWYiLCJfYSIsImlzUmVzaXppbmciLCJfYiIsInBhdXNlSW50ZXJydXB0cyIsImdldEZ1bmN0aW9ucyIsInNjcm9sbFRvSXRlbSIsInJlbG9hZCIsInNldExpc3RzaXplIiwiY2xlYXJDYWNoZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsInJlbWFwSW5kZXhlcyIsIm1vdmVJbmRleCIsImluc2VydEluZGV4IiwicmVtb3ZlSW5kZXgiLCJmdW5jdGlvbnMiLCJ2aWV3cG9ydGRhdGEiLCJlbGVtZW50UmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uU2Nyb2xsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyYWRsZUludGVyc2VjdCIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsImNyYWRsZWludGVyc2VjdG9ic2VydmVyIiwiY3JlYXRlT2JzZXJ2ZXIiLCJjb25uZWN0RWxlbWVudHMiLCJ0cmlnZ2Vyb2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsIm1heExpc3RzaXplIiwiY2FsbGJhY2tzIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJjaGFuZ2VMaXN0c2l6ZSIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJwYXJlQ2FjaGVUb01heCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXRjaENhY2hlVG9DcmFkbGUiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1Njcm9sbFByb3BlcnR5IiwiYmxvY2tTY3JvbGxQb3MiLCJwcmV2aW91c0NlbGxQaXhlbExlbmd0aCIsInByZXZpb3VzQXhpc09mZnNldCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwicHJldmlvdXNyYXRpbyIsInBpdm90Q2VsbFBpeGVsTGVuZ3RoIiwicGl2b3RBeGlzT2Zmc2V0Iiwicm91bmQiLCJnZXRDcmFkbGVTdHlsZXMiLCJ1c2Vyc3R5bGVzIiwiY3JhZGxlSGVhZFN0eWxlIiwiY3JhZGxlVGFpbFN0eWxlIiwiY3JhZGxlQXhpc1N0eWxlIiwiY3JhZGxlRGl2aWRlclN0eWxlIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGUiLCJmaW5hbENhbGxiYWNrIiwicHJlbG9hZCIsInZpZXdwb3J0RWxlbWVudCIsInJlc3RvcmVJbnRlcnJ1cHRzIiwic2lnbmFscyIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyIiwicmVwb3NpdGlvbmluZ1JlcXVpcmVkIiwiaXNTY3JvbGxpbmciLCJjcmFkbGVDb250ZW50IiwiY29udGVudCIsImhlYWRNb2RlbENvbXBvbmVudHMiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwic2V0Q3JhZGxlQ29udGVudCIsImhlYWREaXNwbGF5Q29tcG9uZW50cyIsInRhaWxEaXNwbGF5Q29tcG9uZW50cyIsInNldFRpbWVvdXQiLCJhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJwb3J0YWxIb2xkTGlzdCIsInBvcnRhbE1hcCIsImxlbmd0aCIsIml0ZW1JRCIsImNsZWFyQ3JhZGxlIiwic2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Iiwic2Nyb2xsVHJhY2tlckFyZ3MiLCJpbmNsdWRlcyIsInRyYWNrZXJhcmdzIiwidG9wIiwibGVmdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmIiwia2V5Iiwic3R5bGUiLCJyZWYiLCJjb250ZXh0dmFsdWVSZWYiLCJQcm92aWRlciIsInZhbHVlIiwiU2Nyb2xsVHJhY2tlcl8xIiwib2Zmc2V0IiwiY3JlYXRlSGFuZGxlciIsImhhbmRsZXIiLCJpbnRlcnJ1cHRoYW5kbGVyXzEiLCJzY3JvbGxoYW5kbGVyXzEiLCJzdGF0ZWhhbmRsZXJfMSIsImNvbnRlbnRoYW5kbGVyXzEiLCJsYXlvdXRoYW5kbGVyXzEiLCJzZXJ2aWNlaGFuZGxlcl8xIiwic3R5bGVzaGFuZGxlcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Scrollblock.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element (scrolled by Viewport) of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\n\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n      listsize = _ref.listsize,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout; // -------------------------[ context and state ]-------------------------\n\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext); // -----------------------------------[ data heap ]-------------------------\n\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null); // just for init\n\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n      _ref3 = _slicedToArray(_ref2, 2),\n      divlinerstyle = _ref3[0],\n      saveDivlinerstyle = _ref3[1]; // to trigger render\n\n\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n      width = _ViewportContextPrope.width,\n      height = _ViewportContextPrope.height; // reconfigure\n\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\n\n\nexports["default"] = Scrollblock; // any of the parameters can affect the length\n\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n      viewportheight = _ref4.viewportheight,\n      viewportwidth = _ref4.viewportwidth,\n      listsize = _ref4.listsize,\n      cellHeight = _ref4.cellHeight,\n      cellWidth = _ref4.cellWidth,\n      gap = _ref4.gap,\n      padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength); // -------------------[ calculate scrollblock length ]-----------------\n\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap : // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n\n  return baselength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n\n  var height;\n  var width;\n\n  if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n  } else {\n    // orientation == \'horizontal\'\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBckI7RUFFQSxJQUFNSyxVQUFVLEdBQUlGLFlBQVksR0FBR0wsVUFBaEIsSUFDYkssWUFBWSxHQUFHLENBQWhCLEdBQ0dsQyxHQURILEdBQ1E7RUFDTCxDQUhXLElBSVpDLE9BQU8sR0FBRyxDQUpqQixDQWxDSyxDQXNDZTs7RUFFcEIsT0FBT21DLFVBQVA7QUFFSCxDQW5ERDs7QUFxREEsSUFBTWYsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQixDQUFDdEIsV0FBRCxFQUFjc0MsU0FBZCxFQUF5QkMsd0JBQXpCLEVBQXFEO0VBRWpGLElBQUlDLFdBQVcscUJBQU9GLFNBQVMsQ0FBQ3pCLE9BQWpCLENBQWYsQ0FGaUYsQ0FFeEM7O0VBQ3pDLElBQUlLLE1BQUo7RUFDQSxJQUFJRCxLQUFKOztFQUNBLElBQUlqQixXQUFXLElBQUksVUFBbkIsRUFBK0I7SUFDM0JrQixNQUFNLEdBQUdxQix3QkFBd0IsQ0FBQzFCLE9BQXpCLEdBQW1DLElBQTVDO0lBQ0FJLEtBQUssR0FBRyxNQUFSO0VBQ0gsQ0FIRCxNQUdPO0lBQUU7SUFDTEMsTUFBTSxHQUFHLE1BQVQ7SUFDQUQsS0FBSyxHQUFHc0Isd0JBQXdCLENBQUMxQixPQUF6QixHQUFtQyxJQUEzQztFQUNIOztFQUNEMkIsV0FBVyxDQUFDdEIsTUFBWixHQUFxQkEsTUFBckI7RUFDQXNCLFdBQVcsQ0FBQ3ZCLEtBQVosR0FBb0JBLEtBQXBCO0VBRUEsT0FBT3VCLFdBQVA7QUFDSCxDQWhCRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvU2Nyb2xsYmxvY2sudHN4PzNiNjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2Nyb2xsYmxvY2sudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuXG4gICAgVGhlIHNjcm9sbGJsb2NrIHByb3ZpZGVzIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgKHNjcm9sbGVkIGJ5IFZpZXdwb3J0KSBvZiB0aGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlci5cbiAgICBJdCBpcyBzaXplZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGNlbGwgc2l6ZSBhbmQgcm93IGNvdW50cywgYWRqdXN0ZWQgZm9yIHZhcmlhYmxlIGNyYWRsZSBjb250ZW50LlxuICAgIEl0cyBvbmx5IHN0YXRlIGNoYW5nZSBpcyBjaGFuZ2Ugb2Ygc3R5bGVzLlxuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlLCB1c2VNZW1vfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgVmlld3BvcnRDb250ZXh0IH0gZnJvbSAnLi9WaWV3cG9ydCdcblxuY29uc3QgU2Nyb2xsYmxvY2sgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIGxpc3RzaXplLFxuICAgIGdyaWRTcGVjcywgXG4gICAgc3R5bGVzLFxuICAgIHNjcm9sbGVySUQsXG59KSA9PiB7XG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIFxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZGF0YSBoZWFwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGp1c3QgZm9yIGluaXRcbiAgICBjb25zdCBsaW5lclN0eWxlID0gdXNlTWVtbygoKSA9PntcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3R5bGVzLnNjcm9sbGJsb2NrLFxuICAgICAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgfVxuXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKGxpbmVyU3R5bGUpXG5cbiAgICBjb25zdCBbZGl2bGluZXJzdHlsZSxzYXZlRGl2bGluZXJzdHlsZV0gPSB1c2VTdGF0ZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpIC8vIHRvIHRyaWdnZXIgcmVuZGVyXG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zXG4gICAgXG4gICAgLy8gcmVjb25maWd1cmVcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHVwZGF0ZUJhc2VCbG9ja0xlbmd0aChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpoZWlnaHQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDp3aWR0aCxcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGRpdmxpbmVyc3R5bGVSZWYsXG4gICAgICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmXG4gICAgICAgICAgICApXG4gICAgICAgIHNhdmVEaXZsaW5lcnN0eWxlKGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudClcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIF0pXG5cbiAgICBjb25zdCB1cGRhdGVCYXNlQmxvY2tMZW5ndGggPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGxheW91dHNwZWNzKSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzY3JvbGxibG9ja2xlbmd0aCA9IGNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgobGF5b3V0c3BlY3MpXG5cbiAgICAgICAgICAgIGJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZi5jdXJyZW50ID0gYmFzZXNjcm9sbGJsb2NrbGVuZ3RoXG5cbiAgICAgICAgfSxbXVxuICAgIClcblxuICAgIHJldHVybiA8ZGl2IGRhdGEtdHlwZSA9ICdzY3JvbGxibG9jaycgc3R5bGU9e2RpdmxpbmVyc3R5bGVSZWYuY3VycmVudH0+e2NoaWxkcmVufTwvZGl2PlxuXG59IC8vIFNjcm9sbGJsb2NrXG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbGJsb2NrXG5cbi8vIGFueSBvZiB0aGUgcGFyYW1ldGVycyBjYW4gYWZmZWN0IHRoZSBsZW5ndGhcbmNvbnN0IGNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGggPSAoe1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICB9KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBjcm9zc2NvdW50IF0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL2Nyb3NzY291bnQgaXMgYWxzbyBjYWxjdWxhdGVkIGJ5IENyYWRsZVxuXG4gICAgbGV0IGNyb3NzbGVuZ3RoXG4gICAgbGV0IGNlbGxMZW5ndGhcbiAgICBsZXQgdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgY3Jvc3NsZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgdmlld3BvcnRjcm9zc2xlbmd0aCA9IHZpZXdwb3J0d2lkdGggXG5cbiAgICB9IGVsc2UgeyAvLyAnaG9yaXpvbnRhbCdcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcblxuICAgIH1cblxuICAgIC8vIGFkanVzdG1lbnRzIHRvIHZpZXdwb3J0Y3Jvc3NsZW5ndGhcbiAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoIC09IChwYWRkaW5nICogMilcbiAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoICs9IGdhcCAvLyB0byBtYXRjaCBjcm9zc0xlbmd0aFxuXG4gICAgaWYgKHZpZXdwb3J0Y3Jvc3NsZW5ndGggPCBjcm9zc2xlbmd0aCkgdmlld3BvcnRjcm9zc2xlbmd0aCA9IGNyb3NzbGVuZ3RoIC8vIG11c3QgYmUgYXQgbGVhc3Qgb25lXG5cbiAgICBjb25zdCBjcm9zc2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydGNyb3NzbGVuZ3RoL2Nyb3NzbGVuZ3RoKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIHNjcm9sbGJsb2NrIGxlbmd0aCBdLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGxpc3Ryb3djb3VudCA9IE1hdGguY2VpbChsaXN0c2l6ZS9jcm9zc2NvdW50KVxuXG4gICAgY29uc3QgYmFzZWxlbmd0aCA9IChsaXN0cm93Y291bnQgKiBjZWxsTGVuZ3RoKSAtIFxuICAgICAgICAoKGxpc3Ryb3djb3VudCA+IDApP1xuICAgICAgICAgICAgZ2FwOiAvLyBmaW5hbCBjZWxsIGhhcyBubyB0cmFpbGluZyBnYXBcbiAgICAgICAgICAgIDApIFxuICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgcmV0dXJuIGJhc2VsZW5ndGhcblxufVxuXG5jb25zdCB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyA9IChvcmllbnRhdGlvbiwgc3R5bGVzUmVmLCBiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYpID0+IHtcblxuICAgIGxldCBsb2NhbHN0eWxlcyA9IHsuLi5zdHlsZXNSZWYuY3VycmVudH0gLy8gbmV3IG9iamVjdFxuICAgIGxldCBoZWlnaHQgXG4gICAgbGV0IHdpZHRoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnXG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgIH1cbiAgICBsb2NhbHN0eWxlcy5oZWlnaHQgPSBoZWlnaHRcbiAgICBsb2NhbHN0eWxlcy53aWR0aCA9IHdpZHRoXG5cbiAgICByZXR1cm4gbG9jYWxzdHlsZXNcbn1cbiJdLCJuYW1lcyI6WyJTY3JvbGxibG9jayIsImNoaWxkcmVuIiwibGlzdHNpemUiLCJncmlkU3BlY3MiLCJzdHlsZXMiLCJzY3JvbGxlcklEIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydF8xIiwiYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmIiwibGluZXJTdHlsZSIsInNjcm9sbGJsb2NrIiwicG9zaXRpb24iLCJkaXZsaW5lcnN0eWxlUmVmIiwiY3VycmVudCIsImRpdmxpbmVyc3R5bGUiLCJzYXZlRGl2bGluZXJzdHlsZSIsInZpZXdwb3J0RGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwidXBkYXRlQmFzZUJsb2NrTGVuZ3RoIiwidmlld3BvcnRoZWlnaHQiLCJ2aWV3cG9ydHdpZHRoIiwidXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMiLCJsYXlvdXRzcGVjcyIsImJhc2VzY3JvbGxibG9ja2xlbmd0aCIsImNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgiLCJyZWFjdF8xIiwic3R5bGUiLCJleHBvcnRzIiwiY3Jvc3NsZW5ndGgiLCJjZWxsTGVuZ3RoIiwidmlld3BvcnRjcm9zc2xlbmd0aCIsImNyb3NzY291bnQiLCJNYXRoIiwiZmxvb3IiLCJsaXN0cm93Y291bnQiLCJjZWlsIiwiYmFzZWxlbmd0aCIsInN0eWxlc1JlZiIsImJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZiIsImxvY2Fsc3R5bGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Viewport.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible screen portal of the list being shown.\n    If it is resized, it notifies the Cradle to reconfigure.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nexports.ViewportContext = react_1["default"].createContext(null); // for children\n\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js");\n\nvar ResizeObserver = window[\'ResizeObserver\'] || resize_observer_1.ResizeObserver;\n\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID,\n      scrollerProperties = _ref.scrollerProperties,\n      VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout;\n\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      viewportState = _ref3[0],\n      setViewportState = _ref3[1]; // setup, resizing, resized, ready\n\n\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true); // monitor for unmounted\n\n  var viewportElementRef = (0, react_1.useRef)(null); // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  // initialize\n\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isReparentingRef: scrollerProperties === null || scrollerProperties === void 0 ? void 0 : scrollerProperties.isReparentingRef,\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  }); // mark as unmounted\n\n  (0, react_1.useEffect)(function () {\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []); // --------------------[ viewport resizer interrupt ]-----------------------\n\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null); // set up resizeObserver\n\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current); // unmount\n\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []); // used by resizeObserver; generates interrupt\n\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target; // no need to trigger interrupt on first resize notification\n\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    } // generate interrupt response, if initiating resize\n\n\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true; // new object creation triggers a realtime interrupt message to cradle through context\n\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    } // finalize resizing after timeout\n\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []); // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n\n  var divlinerstyleRef = (0, react_1.useRef)(null); // initialize with inherited styles\n\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'auto\',\n      overflowAnchor: \'none\' // crucial!\n\n    });\n  }, [styles.viewport]); // update ViewportContextPropertiesRef; add viewport dimensions\n\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n        top = _viewportElementRef$c.top,\n        right = _viewportElementRef$c.right,\n        bottom = _viewportElementRef$c.bottom,\n        left = _viewportElementRef$c.left;\n\n    var width = right - left;\n    var height = bottom - top; // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    }; // trigger context change with new object\n\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]); // --------------------[ state processing ]---------------------------\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]); // ----------------------[ render ]--------------------------------\n\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\n\n\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBckJxQyxDQUF2QyxDQTlIQyxDQXFKRDs7RUFFQSw2QkFBZ0IsWUFBSTtJQUNoQixRQUFRQSxhQUFSO01BRUksS0FBSyxTQUFMO01BQ0EsS0FBSyxPQUFMO1FBQWM7VUFDVkMsZ0JBQWdCLENBQUMsT0FBRCxDQUFoQjtVQUNBO1FBQ0g7SUFOTDtFQVNILENBVkQsRUFVRSxDQUFDRCxhQUFELENBVkYsRUF2SkMsQ0FtS0Q7O0VBRUEsT0FBT2xCLGlDQUFDRCx3QkFBZ0IwRCxRQUFqQixFQUF5QjtJQUFDQyxLQUFLLEVBQUtsQyw0QkFBNEIsQ0FBQ0g7RUFBeEMsQ0FBekIsRUFDSHJCO0lBQUEsYUFDZ0IsVUFEaEI7SUFDMEIsbUJBQ0ZTLFVBRnhCO0lBR0lrRCxLQUFLLEVBQUtqQixnQkFBZ0IsQ0FBQ3JCLE9BSC9CO0lBSUl1QyxHQUFHLEVBQUtyQztFQUpaLEdBTU9MLGFBQWEsSUFBSSxPQUFsQixJQUE4QlosUUFOcEMsQ0FERyxDQUFQO0FBV0gsQ0F6TEQsQyxDQXlMRTs7O0FBRUZQLGtCQUFBQSxHQUFlTSxRQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9WaWV3cG9ydC50c3g/YzgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3cG9ydC50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2Ygdmlld3BvcnQgaXMgdG8gcHJvdmlkZSBkYXRhIHRvIGl0cyBjaGlsZHJlbiAoc2Nyb2xsYmxvY2sgYW5kIGNyYWRsZSksXG4gICAgYW5kIGFjdCBhcyB0aGUgdmlzaWJsZSBzY3JlZW4gcG9ydGFsIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuICAgIElmIGl0IGlzIHJlc2l6ZWQsIGl0IG5vdGlmaWVzIHRoZSBDcmFkbGUgdG8gcmVjb25maWd1cmUuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHtcblxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VSZWYsIFxuICAgIHVzZUVmZmVjdCwgXG4gICAgdXNlTGF5b3V0RWZmZWN0LCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDYWxsYmFjaywgXG4gICAgdXNlQ29udGV4dFxuXG59IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKSAvLyBmb3IgY2hpbGRyZW5cblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgYXMgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGwgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcidcblxuY29uc3QgUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3dbJ1Jlc2l6ZU9ic2VydmVyJ10gfHwgUmVzaXplT2JzZXJ2ZXJQb2xseWZpbGxcblxuY29uc3QgVmlld3BvcnQgPSAoe1xuXG4gICAgY2hpbGRyZW4sIFxuICAgIGdyaWRTcGVjcyxcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbiAgICBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG4gICAgXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICBjb25zdCBbdmlld3BvcnRTdGF0ZSxzZXRWaWV3cG9ydFN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpIC8vIHNldHVwLCByZXNpemluZywgcmVzaXplZCwgcmVhZHlcblxuICAgIGNvbnN0IHZpZXdwb3J0U3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gZm9yIHVzZUNhbGxiYWNrIC0+IHJlc2l6ZUNhbGxiYWNrIHNjb3BlXG4gICAgdmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID0gdmlld3BvcnRTdGF0ZVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpIC8vIG1vbml0b3IgZm9yIHVubW91bnRlZFxuXG4gICAgY29uc3Qgdmlld3BvcnRFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIGlzIHBhc3NlZCBhcyBhIHJlc2l6aW5nIGludGVycnVwdCAodGhyb3VnaCBjb250ZXh0KSB0byBjaGlsZHJlblxuICAgIC8vIGluaXRpYWxpemVcbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBpc1JlcGFyZW50aW5nUmVmOnNjcm9sbGVyUHJvcGVydGllcz8uaXNSZXBhcmVudGluZ1JlZiwgXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOmZhbHNlLCBcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczpudWxsLFxuICAgICAgICAgICAgZWxlbWVudFJlZjpudWxsXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyBtYXJrIGFzIHVubW91bnRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PntcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHZpZXdwb3J0IHJlc2l6ZXIgaW50ZXJydXB0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcmVzaXplVGltZXJpZFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGlzUmVzaXppbmdSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7ICAgIFxuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICBpZiAodmlld3BvcnRTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVudHJpZXNbMF0udGFyZ2V0XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byB0cmlnZ2VyIGludGVycnVwdCBvbiBmaXJzdCByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICghdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuaW5pdGlhbGl6ZWQgPSAndHJ1ZSdcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJydXB0IHJlc3BvbnNlLCBpZiBpbml0aWF0aW5nIHJlc2l6ZVxuICAgICAgICBpZiAoIWlzUmVzaXppbmdSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG5cbiAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgY3JlYXRpb24gdHJpZ2dlcnMgYSByZWFsdGltZSBpbnRlcnJ1cHQgbWVzc2FnZSB0byBjcmFkbGUgdGhyb3VnaCBjb250ZXh0XG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50fVxuXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxpemUgcmVzaXppbmcgYWZ0ZXIgdGltZW91dFxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXJpZFJlZi5jdXJyZW50KVxuICAgICAgICByZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgaXNSZXNpemluZ1JlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3Jlc2l6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNvbmZpZyB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzdHlsZXNcbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBpbml0aWFsaXplIHdpdGggaW5oZXJpdGVkIHN0eWxlc1xuICAgIGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdHlsZXMudmlld3BvcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgaW5zZXQ6MCxcbiAgICAgICAgICAgIG92ZXJmbG93OidhdXRvJyxcbiAgICAgICAgICAgIG92ZXJmbG93QW5jaG9yOidub25lJyAvLyBjcnVjaWFsIVxuICAgICAgICB9XG5cbiAgICB9LFtzdHlsZXMudmlld3BvcnRdKVxuXG4gICAgLy8gdXBkYXRlIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWY7IGFkZCB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0U3RhdGUgPT0gJ3NldHVwJykgcmV0dXJuIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gdmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgY29uc3Qgd2lkdGggPSAocmlnaHQgLSBsZWZ0KVxuICAgICAgICBjb25zdCBoZWlnaHQgPSAoYm90dG9tIC0gdG9wKVxuXG4gICAgICAgIC8vIHRoaXMgaXMgYSBkaW1lbnNpb24gdXBkYXRlIHByb2NlZHVyZSBmb3IgcmVzaXplLiBcbiAgICAgICAgLy8gU2VlIGFsc28gaW50ZXJydXB0aGFuZGxlci50c3ggY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayBmb3IgY3JhZGxlIGludGVyc2VjdGlvbiB1cGRhdGVcbiAgICAgICAgY29uc3QgbG9jYWxWaWV3cG9ydERhdGEgPSB7XG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6e3RvcCxyaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6dmlld3BvcnRFbGVtZW50UmVmLFxuICAgICAgICAgICAgaXNSZXNpemluZzppc1Jlc2l6aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGNvbnRleHQgY2hhbmdlIHdpdGggbmV3IG9iamVjdFxuICAgICAgICBjb25zdCB2aWV3cG9ydGRhdGFvYmplY3QgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LCAuLi5sb2NhbFZpZXdwb3J0RGF0YX1cblxuICAgICAgICByZXR1cm4gIHZpZXdwb3J0ZGF0YW9iamVjdFxuXG4gICAgfSxbb3JpZW50YXRpb24sIGlzUmVzaXppbmdSZWYuY3VycmVudCwgdmlld3BvcnRTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgc3RhdGUgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHN3aXRjaCAodmlld3BvcnRTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZXNpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzoge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LFt2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiA8Vmlld3BvcnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgfT5cbiAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd2aWV3cG9ydCdcbiAgICAgICAgICAgIGRhdGEtc2Nyb2xsZXJpZCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICBzdHlsZSA9IHsgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIHJlZiA9IHsgdmlld3BvcnRFbGVtZW50UmVmIH1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyAodmlld3BvcnRTdGF0ZSAhPSAnc2V0dXAnKSAmJiBjaGlsZHJlbiB9XG4gICAgICAgIDwvZGl2PlxuICAgIDwvVmlld3BvcnRDb250ZXh0LlByb3ZpZGVyPlxuICAgIFxufSAvLyBWaWV3cG9ydFxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydFxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJyZWFjdF8xIiwiY3JlYXRlQ29udGV4dCIsIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwicmVzaXplX29ic2VydmVyXzEiLCJWaWV3cG9ydCIsImNoaWxkcmVuIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsInNjcm9sbGVyUHJvcGVydGllcyIsIlZJRVdQT1JUX1JFU0laRV9USU1FT1VUIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsInZpZXdwb3J0U3RhdGUiLCJzZXRWaWV3cG9ydFN0YXRlIiwidmlld3BvcnRTdGF0ZVJlZiIsImN1cnJlbnQiLCJpc01vdW50ZWRSZWYiLCJ2aWV3cG9ydEVsZW1lbnRSZWYiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiaXNSZXBhcmVudGluZ1JlZiIsImlzUmVzaXppbmciLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJlbGVtZW50UmVmIiwicmVzaXplVGltZXJpZFJlZiIsImlzUmVzaXppbmdSZWYiLCJyZXNpemVPYnNlcnZlclJlZiIsInJlc2l6ZUNhbGxiYWNrIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJlbnRyaWVzIiwidGFyZ2V0IiwiZGF0YXNldCIsImluaXRpYWxpemVkIiwiT2JqZWN0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImRpdmxpbmVyc3R5bGVSZWYiLCJ2aWV3cG9ydCIsInBvc2l0aW9uIiwiaW5zZXQiLCJvdmVyZmxvdyIsIm92ZXJmbG93QW5jaG9yIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJsb2NhbFZpZXdwb3J0RGF0YSIsInZpZXdwb3J0ZGF0YW9iamVjdCIsIlByb3ZpZGVyIiwidmFsdWUiLCJzdHlsZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // Placeholder.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n      listsize = _ref.listsize,\n      message = _ref.message,\n      error = _ref.error,\n      userFrameStyles = _ref.userFrameStyles,\n      userContentStyles = _ref.userContentStyles;\n  var frameStylesRef = (0, react_1.useRef)(Object.assign(Object.assign({\n    border: \'2px solid black\',\n    backgroundColor: \'cyan\'\n  }, userFrameStyles), {\n    position: \'relative\',\n    boxSizing: \'border-box\',\n    height: \'100%\',\n    width: \'100%\'\n  }));\n  var contentStylesRef = (0, react_1.useRef)(Object.assign({\n    position: \'absolute\',\n    top: 0,\n    left: 0,\n    padding: \'3px\',\n    opacity: .5,\n    borderRadius: \'8px\',\n    backgroundColor: \'white\',\n    margin: \'3px\',\n    fontSize: \'smaller\'\n  }, userContentStyles));\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    style: frameStylesRef.current\n  }, !error ? react_1["default"].createElement("div", {\n    style: contentStylesRef.current\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    style: contentStylesRef.current\n  }, "item is not available (", error.message, ")"));\n};\n\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTs7QUFFQSxJQUFNQSxXQUFXLEdBQUcsU0FBZEEsV0FBYyxPQUEwRTtFQUFBLElBQXhFQyxLQUF3RSxRQUF4RUEsS0FBd0U7RUFBQSxJQUFqRUMsUUFBaUUsUUFBakVBLFFBQWlFO0VBQUEsSUFBdkRDLE9BQXVELFFBQXZEQSxPQUF1RDtFQUFBLElBQTlDQyxLQUE4QyxRQUE5Q0EsS0FBOEM7RUFBQSxJQUF2Q0MsZUFBdUMsUUFBdkNBLGVBQXVDO0VBQUEsSUFBdEJDLGlCQUFzQixRQUF0QkEsaUJBQXNCO0VBRTFGLElBQU1DLGNBQWMsR0FBRyxvQkFBTUM7SUFDekJDLE1BQU0sRUFBQyxpQkFEa0I7SUFFekJDLGVBQWUsRUFBQztFQUZTLEdBR3RCTCxlQUhzQixHQUdQO0lBQ2xCTSxRQUFRLEVBQUMsVUFEUztJQUVsQkMsU0FBUyxFQUFDLFlBRlE7SUFHbEJDLE1BQU0sRUFBQyxNQUhXO0lBSWxCQyxLQUFLLEVBQUM7RUFKWSxDQUhPLENBQU4sQ0FBdkI7RUFTQSxJQUFNQyxnQkFBZ0IsR0FBRyxvQkFBTVA7SUFDM0JHLFFBQVEsRUFBQyxVQURrQjtJQUUzQkssR0FBRyxFQUFDLENBRnVCO0lBRzNCQyxJQUFJLEVBQUMsQ0FIc0I7SUFJM0JDLE9BQU8sRUFBQyxLQUptQjtJQUszQkMsT0FBTyxFQUFDLEVBTG1CO0lBTTNCQyxZQUFZLEVBQUMsS0FOYztJQU8zQlYsZUFBZSxFQUFDLE9BUFc7SUFRM0JXLE1BQU0sRUFBQyxLQVJvQjtJQVMzQkMsUUFBUSxFQUFDO0VBVGtCLEdBVXhCaEIsaUJBVndCLENBQU4sQ0FBekI7RUFhQUgsT0FBTyxHQUFHQSxPQUFPLFNBQVAsV0FBTyxXQUFQLGFBQVcsY0FBckI7RUFFQSxPQUFPb0I7SUFBS0MsS0FBSyxFQUFJakIsY0FBYyxDQUFDa0I7RUFBN0IsR0FDRCxDQUFDckIsS0FBRCxHQUNFbUI7SUFBS0MsS0FBSyxFQUFLVCxnQkFBZ0IsQ0FBQ1U7RUFBaEMsR0FBMkN4QixLQUFLLEdBQUcsQ0FBbkQsT0FBdURDLFFBQXZELE9BQWtFQyxPQUFsRSxDQURGLEdBRUVvQjtJQUFLQyxLQUFLLEVBQUtULGdCQUFnQixDQUFDVTtFQUFoQyw4QkFBa0VyQixLQUFLLENBQUNELE9BQXhFLE1BSEQsQ0FBUDtBQU9ILENBakNEOztBQW1DQXVCLGtCQUFBQSxHQUFlMUIsV0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB0aGUgZGVmYXVsdCBQbGFjZUhvbGRlciBpcyB0byBob2xkIHRoZSBjb250ZW50IGRpc3BsYXkgdW50aWwgdGhlIGhvc3QgY29udGVudFxuICAgIGlzIHJlY2VpdmVkLiBUaGUgcGxhY2Vob2xkZXIgcHJlc2VudHMgYSB3YWl0aW5nIG1lc3NhZ2UsIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGxvYWRcbiAgICBvZiB0aGUgaG9zdCBjb250ZW50IGZhaWxlZC5cblxuICAgIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNhbiBiZSByZXBsYWNlZCBieSBhIHBsYWNlaG9sZGVyIHByb3ZpZGVkIGJ5IHRoZSBob3N0LlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmIH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFBsYWNlaG9sZGVyID0gKHtpbmRleCwgbGlzdHNpemUsIG1lc3NhZ2UsIGVycm9yLCB1c2VyRnJhbWVTdHlsZXMsIHVzZXJDb250ZW50U3R5bGVzfSkgPT4ge1xuXG4gICAgY29uc3QgZnJhbWVTdHlsZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBib3JkZXI6JzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgIC4uLnVzZXJGcmFtZVN0eWxlcyxcbiAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgIH0pXG4gICAgY29uc3QgY29udGVudFN0eWxlc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgIHRvcDowLFxuICAgICAgICBsZWZ0OjAsXG4gICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgIG9wYWNpdHk6LjUsXG4gICAgICAgIGJvcmRlclJhZGl1czonOHB4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsIFxuICAgICAgICBtYXJnaW46JzNweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgLi4udXNlckNvbnRlbnRTdHlsZXMsXG4gICAgfSlcblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlID8/ICcobG9hZGluZy4uLiknXG5cbiAgICByZXR1cm4gPGRpdiBzdHlsZSA9IHtmcmFtZVN0eWxlc1JlZi5jdXJyZW50fT5cbiAgICAgICAgeyAhZXJyb3I/XG4gICAgICAgICAgICA8ZGl2IHN0eWxlID0geyBjb250ZW50U3R5bGVzUmVmLmN1cnJlbnQgfT57aW5kZXggKyAxfS97bGlzdHNpemV9IHttZXNzYWdlfTwvZGl2PjpcbiAgICAgICAgICAgIDxkaXYgc3R5bGUgPSB7IGNvbnRlbnRTdHlsZXNSZWYuY3VycmVudCB9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSAoe2Vycm9yLm1lc3NhZ2V9KTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJuYW1lcyI6WyJQbGFjZWhvbGRlciIsImluZGV4IiwibGlzdHNpemUiLCJtZXNzYWdlIiwiZXJyb3IiLCJ1c2VyRnJhbWVTdHlsZXMiLCJ1c2VyQ29udGVudFN0eWxlcyIsImZyYW1lU3R5bGVzUmVmIiwiT2JqZWN0IiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwicG9zaXRpb24iLCJib3hTaXppbmciLCJoZWlnaHQiLCJ3aWR0aCIsImNvbnRlbnRTdHlsZXNSZWYiLCJ0b3AiLCJsZWZ0IiwicGFkZGluZyIsIm9wYWNpdHkiLCJib3JkZXJSYWRpdXMiLCJtYXJnaW4iLCJmb250U2l6ZSIsInJlYWN0XzEiLCJzdHlsZSIsImN1cnJlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // scrolltracker.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      offset = _ref.offset,\n      listsize = _ref.listsize,\n      styles = _ref.styles;\n  var trackdata = "".concat(offset + 1, "/").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0FBT0E7O0FBRUEsSUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixPQUE0QztFQUFBLElBQXpDQyxHQUF5QyxRQUF6Q0EsR0FBeUM7RUFBQSxJQUFwQ0MsSUFBb0MsUUFBcENBLElBQW9DO0VBQUEsSUFBOUJDLE1BQThCLFFBQTlCQSxNQUE4QjtFQUFBLElBQXRCQyxRQUFzQixRQUF0QkEsUUFBc0I7RUFBQSxJQUFaQyxNQUFZLFFBQVpBLE1BQVk7RUFFOUQsSUFBSUMsU0FBUyxhQUFNSCxNQUFNLEdBQUcsQ0FBZixjQUFvQkMsUUFBcEIsQ0FBYjtFQUVBLElBQUlHLFFBQVEsR0FBRyxvQkFBTUM7SUFDakJQLEdBQUcsRUFBRUEsR0FBRyxHQUFHLElBRE07SUFFakJDLElBQUksRUFBRUEsSUFBSSxHQUFHLElBRkk7SUFHakJPLFFBQVEsRUFBQyxPQUhRO0lBSWpCQyxNQUFNLEVBQUMsQ0FKVTtJQUtqQkMsZUFBZSxFQUFDLE9BTEM7SUFNakJDLE1BQU0sRUFBRSxnQkFOUztJQU9qQkMsWUFBWSxFQUFDLE1BUEk7SUFRakJDLFFBQVEsRUFBQyxTQVJRO0lBU2pCQyxPQUFPLEVBQUM7RUFUUyxHQVVkVixNQUFNLENBQUNXLGFBVk8sQ0FBTixDQUFmO0VBYUEsT0FBT0M7SUFBQSxhQUFpQixlQUFqQjtJQUFpQ0MsS0FBSyxFQUFJWCxRQUFRLENBQUNZO0VBQW5ELEdBQThEYixTQUE5RCxDQUFQO0FBQ0gsQ0FsQkQ7O0FBb0JBYyxrQkFBQUEsR0FBZXBCLGFBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9TY3JvbGxUcmFja2VyLnRzeD8wYjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIFNjcm9sbFRyYWNrZXIgaXMgdG8gcHJvdmlkZSBmZWVkYmFjayB0byB0aGUgdXNlciBvZiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlXG4gICAgdmlydHVhbCBsaXN0IGR1cmluZyByZXBvc2l0aW9uZy5cblxuICAgIFNjcm9sbFRyYWNrZXIgY2FuIGJlIHN1cHByZXNzZWQgYnkgdGhlIGhvc3QgKGluIGZhdm91ciBvZiB0aGUgaG9zdCdzIG93biBsb2NhdGlvbiBmZWVkYmFjaylcbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFNjcm9sbFRyYWNrZXIgPSAoeyB0b3AsIGxlZnQsIG9mZnNldCwgbGlzdHNpemUsIHN0eWxlcyB9KSA9PiB7XG5cbiAgICBsZXQgdHJhY2tkYXRhID0gYCR7b2Zmc2V0ICsgMX0vJHtsaXN0c2l6ZX1gXG5cbiAgICBsZXQgc3R5bGVSZWYgPSB1c2VSZWYoe1xuICAgICAgICB0b3A6IHRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjonZml4ZWQnLFxuICAgICAgICB6SW5kZXg6MyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBncmF5JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOicxMHB4JyxcbiAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICBwYWRkaW5nOiczcHgnLFxuICAgICAgICAuLi5zdHlsZXMuc2Nyb2xsdHJhY2tlclxuICAgIH0pXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLW5hbWUgPSAnc2Nyb2xsdHJhY2tlcicgc3R5bGUgPSB7c3R5bGVSZWYuY3VycmVudH0gPnt0cmFja2RhdGF9PC9kaXY+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFRyYWNrZXIiXSwibmFtZXMiOlsiU2Nyb2xsVHJhY2tlciIsInRvcCIsImxlZnQiLCJvZmZzZXQiLCJsaXN0c2l6ZSIsInN0eWxlcyIsInRyYWNrZGF0YSIsInN0eWxlUmVmIiwiT2JqZWN0IiwicG9zaXRpb24iLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJmb250U2l6ZSIsInBhZGRpbmciLCJzY3JvbGx0cmFja2VyIiwicmVhY3RfMSIsInN0eWxlIiwiY3VycmVudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/cachehandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // cachehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PortalList = exports.CacheHandler = void 0;\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user getFunctions callback for details. Note that overly large caches of complex components\n    can impair performance. This can be optimized with the cacheMax property.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden portal cache\n    for each InfiniteGridScroller root, from whence the components are pulled into the relevant CellFrames\n    for display. The user components are stored in React portals, with each portal instantiated in\n    a container div (\'portalwrapper\'). These container divs are included in a standard React component\n    list in the real DOM. The contained portals themselves are not part of the real DOM, but are part of\n    React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle without losing state, and the ability to maintain state for\n    complex components which move beyond the scope of the content of the Cradle. But there is an\n    important side effect.\n\n    Instantiated components which are removed from the real DOM (into the portal of the virtual DOM)\n    have their scroll positions, width, and height set to zero. Therefore if components rely on these\n    values for configuration, they must have a way of storing values in state (notably the\n    Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing isReparentingRef and scrollerPropertiesRef\n        - isReparentingRef.current provides an up-to-date boolean indicating whether the component is\n            currently being \'reparented\' into the real DOM. Set the value back to false once you\'ve\n            detected it. After reparenting (after the width and height are back to normal) is when\n            you should restore scrollPos (scrollTop or scrollLeft) to what it was.\n        - if your component does not scroll, there should be no issues.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\n\nvar globalItemID = 0; // global scroller data, organized by session scrollerID\n// the cache itself is maintained in the root infinitegridscroller component\n\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, setListsize, listsizeRef) {\n    var _this = this;\n\n    _classCallCheck(this, CacheHandler);\n\n    this.cacheProps = {\n      setListState: null,\n      modified: false,\n      metadataMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      portalMap: new Map(),\n      indexToItemIDMap: new Map(),\n      portalList: null,\n      scrollerID: null\n    }; //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n\n    this.changeListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      _this.setListsize(newlistsize); // match cache to newlistsize\n\n\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n\n    this.clearCache = function () {\n      // keep the setListState callback\n      _this.cacheProps.portalMap.clear();\n\n      _this.cacheProps.metadataMap.clear();\n\n      _this.cacheProps.indexToItemIDMap.clear();\n\n      _this.cacheProps.requestedSet.clear();\n\n      _this.cacheProps.portalList = null;\n      _this.cacheProps.modified = true;\n\n      _this.renderPortalList(); // trigger display update\n\n    }; // set state of the PortalList component of the scroller to trigger render\n\n\n    this.renderPortalList = function () {\n      if (_this.cacheProps.modified) {\n        _this.cacheProps.portalList = Array.from(_this.cacheProps.portalMap.values());\n        _this.cacheProps.modified = false;\n      }\n\n      _this.cacheProps.setListState(); // trigger display update\n\n    }; // ----------------------[ cache size limit enforceent ]------------------\n\n\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      var modelLength = cradleIndexList.length; // determine need for paring\n\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexList = _this.cacheProps.indexToItemIDMap,\n          requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexList.size + requestedSet.size <= max) return false; // sort the map keys\n\n      var mapkeyslist = Array.from(portalIndexList.keys()),\n          requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      }); // get number to pare\n\n      var mapLength = mapkeys.length,\n          parecount = mapLength - max; // distribute paring proportionally at front and back\n\n      var headindex = cradleIndexList[0],\n          tailindex = cradleIndexList[modelLength - 1],\n          headpos = mapkeys.indexOf(headindex),\n          tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos,\n          tailroom = mapLength - (tailpos + 1),\n          pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount),\n          tailparecount = parecount - headparecount; // collect indexes to pare\n\n      var headlist = mapkeys.slice(0, headparecount),\n          taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n\n      _this.deletePortal(delList, deleteListCallback);\n\n      return true;\n    };\n\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var _this$cacheProps = _this.cacheProps,\n          portalMap = _this$cacheProps.portalMap,\n          requestedSet = _this$cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n\n      if (portalMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    this.cacheProps.scrollerID = scrollerID;\n    this.setListsize = setListsize; // passed from infinitegridscroller setListsize(listsize)\n\n    this.listsizeRef = listsizeRef;\n  } // --------------------------------[ preload ]--------------------------------\n\n\n  _createClass(CacheHandler, [{\n    key: "preload",\n    value: function preload(finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n\n      var cradleParameters = this.cradleParameters;\n      var scrollerPropertiesRef = cradleParameters.scrollerPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n          stateHandler = _cradleParameters$han.stateHandler,\n          serviceHandler = _cradleParameters$han.serviceHandler,\n          cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n          cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n          cacheMax = cradleInheritedProperties.cacheMax,\n          listsize = cradleInternalProperties.listsize;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      }; // serviceHandler.callbacks.preloadIndexCallback\n\n\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n            preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n            itemExceptionsCallback = _serviceHandler$callb.itemExceptionsCallback;\n\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n\n          if (!indexToItemIDMap.has(index)) {\n            var promise = this.preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n\n          if (breakloop.current) break;\n        }\n      }\n\n      Promise.allSettled(promises).then(function () {\n        _this2.cacheProps.modified = true;\n\n        _this2.renderPortalList();\n\n        finalCallback();\n      });\n    } // =========================[ SNAPSHOTS ]=========================\n\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map(),\n          indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n\n      var _iterator = _createForOfIteratorHelper(cradleIndexList),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n\n      var _iterator2 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              value = _step2$value[1];\n\n          var index = value.index,\n              component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return cachelist;\n    } // ==========================[ SERVICE SUPPORT ]=========================\n    // move is coerced by servicehandler to be within current list bounds\n\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(toindex, fromindex, fromhighindex) {\n      var _this$cacheProps2 = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n          metadataMap = _this$cacheProps2.metadataMap; // ----------- define parameters ---------------\n\n      var rangeabsoluteincrement = fromhighindex - fromindex + 1,\n          movedirectionalincrement = toindex - fromindex,\n          tohighindex = toindex + (rangeabsoluteincrement - 1);\n      var shiftdirection = movedirectionalincrement > 0 ? // move up in list\n      -1 : // shift down, make room for shiftingindex above\n      1; // shift up, make room for shiftingindex below\n\n      var orderedindexlist = Array.from(indexToItemIDMap.keys());\n      orderedindexlist.sort(function (a, b) {\n        return a - b;\n      });\n      var toindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= toindex;\n      }),\n          tohighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= tohighindex;\n      }),\n          fromindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromindex;\n      }),\n          fromhighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromhighindex;\n      }); // ---------------- capture index data to move ----------------\n\n      var processtomoveList;\n\n      if (fromindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        processtomoveList = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        processtomoveList = orderedindexlist.slice(fromindexptr);\n      } else {\n        // scope is entirely in view\n        processtomoveList = orderedindexlist.slice(fromindexptr, fromhighindexptr + 1);\n      }\n\n      var processtomoveMap = new Map();\n\n      var capturemoveindex = function capturemoveindex(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n\n      processtomoveList.forEach(capturemoveindex); // ------------- get list of indexes to shift out of the way ---------------\n\n      var processtoshiftList;\n\n      if (shiftdirection == 1) {\n        // block is moving down, shift is up; toindex < fromindex\n        if (toindexptr == -1 && fromindexptr == -1) {\n          processtoshiftList = [];\n        } else if (fromindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(toindexptr);\n        } else {\n          processtoshiftList = orderedindexlist.slice(toindexptr, fromindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          processtoshiftList = [];\n        } else if (tohighindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n\n      if (shiftdirection == 1) processtoshiftList.reverse(); // -------------- move indexes out of the way --------------\n\n      var processedshiftList = [];\n\n      var processshiftindex = function processshiftindex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = shiftdirection == -1 ? index - rangeabsoluteincrement : index + rangeabsoluteincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedshiftList.push(newIndex);\n      };\n\n      processtoshiftList.forEach(processshiftindex); // ------------ replace shifted index space with moved indexes ----------\n\n      var processedmoveList = [];\n\n      var processmoveindex = function processmoveindex(itemID, index) {\n        var newIndex = index + movedirectionalincrement; // swap\n\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n\n      processtomoveMap.forEach(processmoveindex); // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n\n      var processedIndexes = [].concat(processedshiftList, processedmoveList);\n      return processedIndexes;\n    } // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      var _this$cacheProps3 = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps3.indexToItemIDMap,\n          metadataMap = _this$cacheProps3.metadataMap,\n          portalMap = _this$cacheProps3.portalMap; // ---------- define range parameters ---------------\n      // high range is the highest index number of the insert/remove operation\n\n      var highrangeindex = highrange !== null && highrange !== void 0 ? highrange : 0;\n      highrangeindex = highrangeindex > index ? highrangeindex : index;\n      var emptyreturn = [[], [], 0];\n\n      if (increment == -1) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) return emptyreturn;\n      } else {\n        // addition can at most start at the next index above the current list\n        if (index > listsize) return emptyreturn;\n      } // rangecount is the absolute number in the insert/remove range - contiguous\n\n\n      var rangecount = highrangeindex - index + 1; // range increment adds sign to rangecount to indicate add/remove\n\n      var rangeincrement = rangecount * increment; // highPtr, lowPtr, shrinktoPtr within orderedIndexList.\n\n      var orderedIndexList = Array.from(indexToItemIDMap.keys());\n      orderedIndexList.sort(function (a, b) {\n        return a - b;\n      }); // ---------- define boundaries within ordered cache index list ------------\n      // Ptr = index into array, as opposed to index of virtual list\n      // shrinkptr is the location of the bottom of the shrink range for removals\n\n      var shrinktoIndex = null;\n      var shrinktoPtr = -1;\n\n      if (increment == -1) {\n        shrinktoIndex = orderedIndexList.at(-1) + rangeincrement;\n        shrinktoIndex = Math.max(highrangeindex + rangeincrement, shrinktoIndex);\n        shrinktoIndex = Math.min(listsize - 1, shrinktoIndex);\n        shrinktoPtr = orderedIndexList.findIndex(function (value) {\n          return value >= shrinktoIndex;\n        });\n      } // lowPtr and highPtr must be within low and high range\n\n\n      var lowPtr = orderedIndexList.findIndex(function (value) {\n        return value >= index && value <= highrangeindex;\n      });\n      var reverseIndexList = Array.from(orderedIndexList);\n      reverseIndexList.reverse();\n      var highPtr = reverseIndexList.findIndex(function (value) {\n        return value <= highrangeindex;\n      });\n\n      if (highPtr != -1) {\n        highPtr = orderedIndexList.length - 1 - highPtr;\n        if (highPtr < lowPtr) highPtr = -1;\n      } // ----------- list indexes to process, replace, and remove, and items to remove --------\n\n\n      var indexesToProcessList,\n          // for either insert or remove\n      indexesToReplaceList = [],\n          // for insert the range being inserted\n      indexesToRemoveList = [],\n          // for remove - end of list; the list is shrinking\n      indexesOfItemsToRemoveList = [],\n          // for remove - within the range of indexes being removed\n      itemsToRemoveList = []; // for remove, derived from the previous\n      // get indexesToProcessList\n\n      if (lowPtr == -1 && highPtr == -1) {\n        // core scope is out of view\n        indexesToProcessList = [];\n      } else {\n        // core scope is partially or fully in view; lowPtr is available\n        if (increment == 1) {\n          indexesToProcessList = orderedIndexList.slice(lowPtr);\n        } else if (highPtr == -1) {\n          // increment == -1; lowPtr is available\n          indexesToProcessList = [];\n        } else {\n          // increment == -1; lowPtr and highPtr are available\n          indexesToProcessList = orderedIndexList.slice(highPtr + 1);\n        }\n      }\n\n      var portalHoldList = []; // hold portals for deletion until after after cradle synch\n\n      if (increment == 1) {\n        // get indexesToReplaceList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesToReplaceList = [];\n        } else if (highPtr == -1) {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n      } else {\n        // get indexesToRemoveList\n        if (shrinktoPtr == -1) {\n          // core scope is out of view\n          indexesToRemoveList = [];\n        } else {\n          indexesToRemoveList = orderedIndexList.slice(shrinktoPtr + 1);\n        } // get indexesOfItemsToRemoveList\n\n\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesOfItemsToRemoveList = [];\n        } else if (highPtr == -1) {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        } // get itemsToRemoveList\n\n\n        var _iterator3 = _createForOfIteratorHelper(indexesOfItemsToRemoveList),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _index = _step3.value;\n            itemsToRemoveList.push(indexToItemIDMap.get(_index));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } // ----------- conduct cache operations ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n\n\n      if (increment == 1) indexesToProcessList.reverse();\n      var indexesModifiedList = []; // modify index-to-itemid map, and metadata map\n\n      var processIndex = function processIndex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        indexesModifiedList.push(newIndex);\n      };\n\n      indexesToProcessList.forEach(processIndex); // delete remaining indexes and items now duplicates\n\n      if (increment == 1) {\n        var _iterator4 = _createForOfIteratorHelper(indexesToReplaceList),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index2 = _step4.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(indexesToRemoveList),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index3 = _step5.value;\n            indexToItemIDMap["delete"](_index3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        var _iterator6 = _createForOfIteratorHelper(itemsToRemoveList),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var itemID = _step6.value;\n            metadataMap["delete"](itemID);\n            portalHoldList.push(itemID);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n\n\n      return [indexesModifiedList, indexesToReplaceList, rangeincrement, portalHoldList];\n    } // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n\n  }, {\n    key: "registerRequestedPortal",\n    value: function registerRequestedPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: "removeRequestedPortal",\n    value: function removeRequestedPortal(index) {\n      this.cacheProps.requestedSet["delete"](index);\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return globalItemID++;\n    } // get new or existing itemID for contentfunctions.createCellFrame\n\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    } // create new portal\n\n  }, {\n    key: "createPortal",\n    value: function createPortal(component, index, itemID) {\n      var isPreload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.removeRequestedPortal(index);\n      var _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current,\n          layout = _this$cradleParameter.layout,\n          cellHeight = _this$cradleParameter.cellHeight,\n          cellWidth = _this$cradleParameter.cellWidth,\n          orientation = _this$cradleParameter.orientation;\n      var portalNode = createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth); // div wrapper to avoid memory leak\n\n      this.cacheProps.portalMap.set(itemID, react_1["default"].createElement("div", {\n        "data-type": \'portalwrapper\',\n        key: itemID,\n        "data-itemid": itemID,\n        "data-index": index\n      }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n        key: itemID,\n        node: portalNode\n      }, " ", component, " ")));\n      this.cacheProps.modified = true;\n      var portalMetadata = {\n        portalNode: portalNode,\n        isReparentingRef: {\n          current: false\n        },\n        index: index,\n        itemID: itemID,\n        component: component\n      };\n      this.cacheProps.metadataMap.set(itemID, portalMetadata);\n      this.cacheProps.indexToItemIDMap.set(index, itemID);\n      if (!isPreload) this.renderPortalList();\n      return portalMetadata;\n    } // used for preloading new item\n\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(index, getItem, scrollerPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties, portalData;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                itemID = this.getNewItemID();\n                _context.prev = 1;\n                _context.next = 4;\n                return getItem(index, itemID);\n\n              case 4:\n                usercontent = _context.sent;\n                if (usercontent === null) returnvalue = usercontent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context["catch"](1);\n                returnvalue = usercontent = undefined;\n                error = _context.t0;\n\n              case 12:\n                if (usercontent !== null && usercontent !== undefined) {\n                  if (!react_1["default"].isValidElement(usercontent)) {\n                    returnvalue = usercontent;\n                    usercontent = undefined;\n                    error = new Error(\'invalid React element\');\n                  }\n                }\n\n                if (usercontent !== null && usercontent !== undefined) {\n                  scrollerProperties = {\n                    isReparentingRef: null,\n                    scrollerPropertiesRef: scrollerPropertiesRef\n                  };\n\n                  if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                    content = react_1["default"].cloneElement(usercontent, {\n                      scrollerProperties: scrollerProperties\n                    });\n                  } else {\n                    content = usercontent;\n                  }\n\n                  portalData = this.createPortal(content, index, itemID, true); // true = isPreload\n                  // make available to user content\n\n                  scrollerProperties.isReparentingRef = portalData.isReparentingRef;\n                } else {\n                  if (usercontent === undefined) {\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, \'preload\', error);\n                  } else {\n                    // usercontent === null; last item in list\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                    maxListsizeInterrupt(index);\n                  }\n                }\n\n              case 14:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 8]]);\n      }));\n    } // delete a portal list item\n    // accepts an array of indexes\n\n  }, {\n    key: "deletePortal",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps4 = this.cacheProps,\n          metadataMap = _this$cacheProps4.metadataMap,\n          portalMap = _this$cacheProps4.portalMap,\n          indexToItemIDMap = _this$cacheProps4.indexToItemIDMap;\n      var deleteList = [];\n\n      var _iterator7 = _createForOfIteratorHelper(indexArray),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n          var itemID = indexToItemIDMap.get(i);\n          deleteList.push({\n            index: i,\n            itemID: itemID\n          });\n          metadataMap["delete"](itemID);\n          portalMap["delete"](itemID);\n          indexToItemIDMap["delete"](i);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this.cacheProps.modified = true;\n      deleteListCallback && deleteListCallback(deleteList);\n    } // query existence of a portal list item\n\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortal",\n    value: function getPortal(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n\n  return CacheHandler;\n}();\n\nexports.CacheHandler = CacheHandler; // ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n// see also some styles set in CellFrame\n\nvar createPortalNode = function createPortalNode(index, itemID, layout, orientation, cellHeight, cellWidth) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n}; // ========================[ Utility component ]==============================\n// portal list component for rapid relisting of updates, using external callback for set state\n\n\nvar PortalList = function PortalList(_ref) {\n  var cacheProps = _ref.cacheProps;\n\n  var _ref2 = (0, react_1.useState)(0),\n      _ref3 = _slicedToArray(_ref2, 2),\n      portalListCounter = _ref3[0],\n      setPortalListCounter = _ref3[1];\n\n  var counterRef = (0, react_1.useRef)(null);\n  counterRef.current = portalListCounter;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null); // const cachedivRef = useRef(null)\n\n  (0, react_1.useEffect)(function () {\n    cacheProps.setListState = function () {\n      portalArrayRef.current = cacheProps.portalList;\n      isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n    };\n\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return portalArrayRef.current;\n};\n\nexports.PortalList = PortalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NhY2hlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7OzsrQ0FEQSxvSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDQTs7QUFFQTs7QUFFQSxJQUFJQSxZQUFZLEdBQUcsQ0FBbkIsQyxDQUVBO0FBQ0E7O0lBQ2FDLFk7RUFFVCxzQkFBWUMsVUFBWixFQUF3QkMsV0FBeEIsRUFBcUNDLFdBQXJDLEVBQWdEO0lBQUE7O0lBQUE7O0lBTWhELGtCQUFhO01BQ1RDLFlBQVksRUFBQyxJQURKO01BRVRDLFFBQVEsRUFBQyxLQUZBO01BSVRDLFdBQVcsRUFBQyxJQUFJQyxHQUFKLEVBSkg7TUFLVDtNQUNBQyxZQUFZLEVBQUMsSUFBSUMsR0FBSixFQU5KO01BT1RDLFNBQVMsRUFBQyxJQUFJSCxHQUFKLEVBUEQ7TUFRVEksZ0JBQWdCLEVBQUMsSUFBSUosR0FBSixFQVJSO01BVVRLLFVBQVUsRUFBQyxJQVZGO01BWVRYLFVBQVUsRUFBQztJQVpGLENBQWIsQ0FOZ0QsQ0ErQmhEO0lBRUE7O0lBRUEsc0JBQWlCLFVBQUNZLFdBQUQsRUFBY0Msa0JBQWQsRUFBa0NDLHNCQUFsQyxFQUE0RDtNQUV6RSxLQUFJLENBQUNiLFdBQUwsQ0FBaUJXLFdBQWpCLEVBRnlFLENBSXpFOzs7TUFDQSxJQUFNRyxjQUFjLEdBQUcsS0FBSSxDQUFDQyxVQUFMLENBQWdCTixnQkFBdkM7TUFDQSxJQUFNTyxXQUFXLEdBQUdDLEtBQUssQ0FBQ0MsSUFBTixDQUFXSixjQUFjLENBQUNLLElBQWYsRUFBWCxDQUFwQjtNQUNBSCxXQUFXLENBQUNJLElBQVosQ0FBaUIsVUFBQ0MsQ0FBRCxFQUFHQyxDQUFIO1FBQUEsT0FB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bEIsR0FBeUIsaUJBQXpCO0VBQ0FMLFNBQVMsQ0FBQ0ksT0FBVixDQUFrQi9KLEtBQWxCLEdBQTBCQSxLQUExQjtFQUNBMkosU0FBUyxDQUFDSSxPQUFWLENBQWtCRSxXQUFsQixHQUFnQ2hFLE1BQWhDO0VBRUEsT0FBT2lDLFVBQVA7QUFFSCxDQWJELEMsQ0FlQTtBQUVBOzs7QUFDTyxJQUFNZ0MsVUFBVSxHQUFHLFNBQWJBLFVBQWEsT0FBbUI7RUFBQSxJQUFoQjlLLFVBQWdCLFFBQWhCQSxVQUFnQjs7RUFFekMsWUFBa0Qsc0JBQVMsQ0FBVCxDQUFsRDtFQUFBO0VBQUEsSUFBTytLLGlCQUFQO0VBQUEsSUFBMEJDLG9CQUExQjs7RUFFQSxJQUFNQyxVQUFVLEdBQUcsb0JBQU8sSUFBUCxDQUFuQjtFQUNBQSxVQUFVLENBQUN6SCxPQUFYLEdBQXFCdUgsaUJBQXJCO0VBRUEsSUFBTXhHLFlBQVksR0FBRyxvQkFBTyxJQUFQLENBQXJCO0VBQ0EsSUFBTTJHLGNBQWMsR0FBRyxvQkFBTyxJQUFQLENBQXZCLENBUnlDLENBU3pDOztFQUVBLHVCQUFVLFlBQUk7SUFFVmxMLFVBQVUsQ0FBQ2IsWUFBWCxHQUEwQixZQUFJO01BRTFCK0wsY0FBYyxDQUFDMUgsT0FBZixHQUF5QnhELFVBQVUsQ0FBQ0wsVUFBcEM7TUFFQTRFLFlBQVksQ0FBQ2YsT0FBYixJQUF3QndILG9CQUFvQixDQUFDLEVBQUVDLFVBQVUsQ0FBQ3pILE9BQWQsQ0FBNUMsQ0FKMEIsQ0FJeUM7SUFFdEUsQ0FORDs7SUFRQSxPQUFPLFlBQUs7TUFFUmUsWUFBWSxDQUFDZixPQUFiLEdBQXVCLEtBQXZCO0lBRUgsQ0FKRDtFQU1ILENBaEJELEVBZ0JFLEVBaEJGO0VBa0JBLE9BQU8wSCxjQUFjLENBQUMxSCxPQUF0QjtBQUVILENBL0JNOztBQUFNOEcsa0JBQUFBLEdBQVVRLFVBQVYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jYWNoZWhhbmRsZXIudHN4PzllOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FjaGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBtYW5hZ2VzIHRoZSBJbmZpbml0ZUdyaWRTY3JvbGxlciBsaW1pdGVkIChzcGFyc2UpIGNhY2hlLiBJdCBhbHNvIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFxuICAgIHNlcnZpY2VzIHdoaWNoIGFsbG93IHRoZSBob3N0IHRvIGFjdGl2ZWx5IG1hbmFnZSBtYW55IGFzcGVjdHMgb2YgdGhlIGNhY2hlLiBTZWUgZG9jdW1lbnRhdGlvblxuICAgIGFib3V0IHRoZSB1c2VyIGdldEZ1bmN0aW9ucyBjYWxsYmFjayBmb3IgZGV0YWlscy4gTm90ZSB0aGF0IG92ZXJseSBsYXJnZSBjYWNoZXMgb2YgY29tcGxleCBjb21wb25lbnRzXG4gICAgY2FuIGltcGFpciBwZXJmb3JtYW5jZS4gVGhpcyBjYW4gYmUgb3B0aW1pemVkIHdpdGggdGhlIGNhY2hlTWF4IHByb3BlcnR5LlxuXG4gICAgVGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIgc3RvcmVzIHVzZXIgY2VsbCBjb250ZW50IChjb21wb25lbnRzKSBpbiBhIGNlbnRyYWwgaGlkZGVuIHBvcnRhbCBjYWNoZSBcbiAgICBmb3IgZWFjaCBJbmZpbml0ZUdyaWRTY3JvbGxlciByb290LCBmcm9tIHdoZW5jZSB0aGUgY29tcG9uZW50cyBhcmUgcHVsbGVkIGludG8gdGhlIHJlbGV2YW50IENlbGxGcmFtZXMgXG4gICAgZm9yIGRpc3BsYXkuIFRoZSB1c2VyIGNvbXBvbmVudHMgYXJlIHN0b3JlZCBpbiBSZWFjdCBwb3J0YWxzLCB3aXRoIGVhY2ggcG9ydGFsIGluc3RhbnRpYXRlZCBpblxuICAgIGEgY29udGFpbmVyIGRpdiAoJ3BvcnRhbHdyYXBwZXInKS4gVGhlc2UgY29udGFpbmVyIGRpdnMgYXJlIGluY2x1ZGVkIGluIGEgc3RhbmRhcmQgUmVhY3QgY29tcG9uZW50IFxuICAgIGxpc3QgaW4gdGhlIHJlYWwgRE9NLiBUaGUgY29udGFpbmVkIHBvcnRhbHMgdGhlbXNlbHZlcyBhcmUgbm90IHBhcnQgb2YgdGhlIHJlYWwgRE9NLCBidXQgYXJlIHBhcnQgb2YgXG4gICAgUmVhY3QncyB2aXJ0dWFsIERPTS5cblxuICAgIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcG9ydGFscy5odG1sIGZvciBnZW5lcmFsIGluZm9ybWF0aW9uIGFib3V0IFJlYWN0IHBvcnRhbHMuXG4gICAgU2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LXJldmVyc2UtcG9ydGFsIGZvciB0aGUgdXRpbGl0eSB0aGF0IEluZmluaXRlR3JpZFNjcm9sbGVyXG4gICAgdXNlcyB0byBtYW5hZ2UgcG9ydGFscy5cblxuICAgIFRoaXMgY2FjaGluZyBoYXMgbWFueSBhZHZhbnRhZ2VzLCBub3RhYmx5IHRoZSBhYmlsaXR5IHRvIG1vdmUgY2VsbHMgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGVcbiAgICBoZWFkIGFuZCB0YWlsIGdyaWRzIG9mIHRoZSBDcmFkbGUgd2l0aG91dCBsb3Npbmcgc3RhdGUsIGFuZCB0aGUgYWJpbGl0eSB0byBtYWludGFpbiBzdGF0ZSBmb3IgXG4gICAgY29tcGxleCBjb21wb25lbnRzIHdoaWNoIG1vdmUgYmV5b25kIHRoZSBzY29wZSBvZiB0aGUgY29udGVudCBvZiB0aGUgQ3JhZGxlLiBCdXQgdGhlcmUgaXMgYW5cbiAgICBpbXBvcnRhbnQgc2lkZSBlZmZlY3QuXG5cbiAgICBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZWFsIERPTSAoaW50byB0aGUgcG9ydGFsIG9mIHRoZSB2aXJ0dWFsIERPTSlcbiAgICBoYXZlIHRoZWlyIHNjcm9sbCBwb3NpdGlvbnMsIHdpZHRoLCBhbmQgaGVpZ2h0IHNldCB0byB6ZXJvLiBUaGVyZWZvcmUgaWYgY29tcG9uZW50cyByZWx5IG9uIHRoZXNlIFxuICAgIHZhbHVlcyBmb3IgY29uZmlndXJhdGlvbiwgdGhleSBtdXN0IGhhdmUgYSB3YXkgb2Ygc3RvcmluZyB2YWx1ZXMgaW4gc3RhdGUgKG5vdGFibHkgdGhlIFxuICAgIFNjcm9sbCBQb3MgLSBzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCksIHJlY29nbml6aW5nIHdoZW4gdGhlIGNvbXBvbmVudCBjb21lcyBvdXQgb2YgdGhlIHBvcnRhbCBjYWNoZSBcbiAgICBpbnRvIHRoZSByZWFsIERPTSAod2lkdGggYW5kIGhlaWdodCBhcmUgdHlwaWNhbGx5IG5vIGxvbmdlciBib3RoIDApLCBhbmQgcmVzcG9uZGluZyB0byBjaGFuZ2UgaW4gXG4gICAgY2FjaGUgc3RhdGUgYXBwcm9wcmlhdGVseS5cblxuICAgIFRpcHM6XG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgaW4gY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgPSAwXG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgb3V0IG9mIGNhY2hlIHdoZW4gYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbFxuICAgICAgICAtIGlmIHlvdSBjcmVhdGUgYW4gZW1wdHkgJ3Njcm9sbGVyUHJvcGVydGllcycgcHJvcGVydHkgZm9yIHlvdXIgY29tcG9uZW50LCBDZWxsRnJhbWUgd2lsbFxuICAgICAgICAgICAgc2V0IGl0IHRvIGFuIG9iamVjdCBjb250YWluaW5nIGlzUmVwYXJlbnRpbmdSZWYgYW5kIHNjcm9sbGVyUHJvcGVydGllc1JlZlxuICAgICAgICAtIGlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCBwcm92aWRlcyBhbiB1cC10by1kYXRlIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgXG4gICAgICAgICAgICBjdXJyZW50bHkgYmVpbmcgJ3JlcGFyZW50ZWQnIGludG8gdGhlIHJlYWwgRE9NLiBTZXQgdGhlIHZhbHVlIGJhY2sgdG8gZmFsc2Ugb25jZSB5b3UndmUgXG4gICAgICAgICAgICBkZXRlY3RlZCBpdC4gQWZ0ZXIgcmVwYXJlbnRpbmcgKGFmdGVyIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbCkgaXMgd2hlblxuICAgICAgICAgICAgeW91IHNob3VsZCByZXN0b3JlIHNjcm9sbFBvcyAoc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpIHRvIHdoYXQgaXQgd2FzLlxuICAgICAgICAtIGlmIHlvdXIgY29tcG9uZW50IGRvZXMgbm90IHNjcm9sbCwgdGhlcmUgc2hvdWxkIGJlIG5vIGlzc3Vlcy5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IGNyZWF0ZUh0bWxQb3J0YWxOb2RlLCBJblBvcnRhbCB9IGZyb20gJ3JlYWN0LXJldmVyc2UtcG9ydGFsJ1xuXG5sZXQgZ2xvYmFsSXRlbUlEID0gMFxuXG4vLyBnbG9iYWwgc2Nyb2xsZXIgZGF0YSwgb3JnYW5pemVkIGJ5IHNlc3Npb24gc2Nyb2xsZXJJRFxuLy8gdGhlIGNhY2hlIGl0c2VsZiBpcyBtYWludGFpbmVkIGluIHRoZSByb290IGluZmluaXRlZ3JpZHNjcm9sbGVyIGNvbXBvbmVudFxuZXhwb3J0IGNsYXNzIENhY2hlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxlcklELCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYpIHtcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnNjcm9sbGVySUQgPSBzY3JvbGxlcklEXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUgPSBzZXRMaXN0c2l6ZSAvLyBwYXNzZWQgZnJvbSBpbmZpbml0ZWdyaWRzY3JvbGxlciBzZXRMaXN0c2l6ZShsaXN0c2l6ZSlcbiAgICAgICAgdGhpcy5saXN0c2l6ZVJlZiA9IGxpc3RzaXplUmVmXG4gICAgfVxuXG4gICAgY2FjaGVQcm9wcyA9IHtcbiAgICAgICAgc2V0TGlzdFN0YXRlOm51bGwsXG4gICAgICAgIG1vZGlmaWVkOmZhbHNlLFxuXG4gICAgICAgIG1ldGFkYXRhTWFwOm5ldyBNYXAoKSwgLy8gaXRlbSA9PiB7aW5kZXgsIGNvbXBvbmVudH1cbiAgICAgICAgLy8gc29tZSBwb3J0YWxzIG1heSBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ5IHJlcXVlc3RpZGxlY2FsbGJhY2ssIG5vdCB5ZXQgY3JlYXRlZFxuICAgICAgICByZXF1ZXN0ZWRTZXQ6bmV3IFNldCgpLCAvLyByZXF1ZXN0ZWRTZXQgb2YgaW5kZXhlc1xuICAgICAgICBwb3J0YWxNYXA6bmV3IE1hcCgpLCAvLyBpbmRleCA9PiBJblBvcnRhbFxuICAgICAgICBpbmRleFRvSXRlbUlETWFwOm5ldyBNYXAoKSxcblxuICAgICAgICBwb3J0YWxMaXN0Om51bGwsXG5cbiAgICAgICAgc2Nyb2xsZXJJRDpudWxsXG4gICAgfVxuXG4gICAgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcG9ydGFsSG9sZExpc3RcblxuICAgIGxpc3RzaXplUmVmXG5cbiAgICAvLyBzZXRMaXN0c2l6ZShsaXN0c2l6ZSkgY2F1c2VzIGFuIEluZmluaXRlR3JpZFNjcm9sbGVyIHVzZVN0YXRlIHVwZGF0ZVxuICAgIC8vIG9mIHRoZSBsaXN0c2l6ZSB0aHJvdWdob3V0XG4gICAgc2V0TGlzdHNpemUgXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVQT1NJVE9SWSBBTkQgTElTVCBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBiYXNpYyBvcGVyYXRpb25zIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhbmdlTGlzdHNpemUgPSAobmV3bGlzdHNpemUsIGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjaykgPT4ge1xuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgLy8gbWF0Y2ggY2FjaGUgdG8gbmV3bGlzdHNpemVcbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhNYXAgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcFxuICAgICAgICBjb25zdCBtYXBrZXlzTGlzdCA9IEFycmF5LmZyb20ocG9ydGFsSW5kZXhNYXAua2V5cygpKVxuICAgICAgICBtYXBrZXlzTGlzdC5zb3J0KChhLGIpID0+IGEgLSBiKVxuXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RpbmRleCA9IG1hcGtleXNMaXN0LmF0KC0xKVxuXG4gICAgICAgIGlmIChoaWdoZXN0aW5kZXggPiAobmV3bGlzdHNpemUgLTEpKSB7IC8vIHBhcmUgdGhlIGNhY2hlXG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVsaXN0ID0gbWFwa2V5c0xpc3QuZmlsdGVyKChpbmRleCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAobmV3bGlzdHNpemUgLTEpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChwYXJlbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrICYmIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sobmV3bGlzdHNpemUpXG5cbiAgICB9XG5cbiAgICBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIGtlZXAgdGhlIHNldExpc3RTdGF0ZSBjYWxsYmFja1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLmNsZWFyKCkgXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gbnVsbFxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KCkgLy8gdHJpZ2dlciBkaXNwbGF5IHVwZGF0ZVxuXG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlIG9mIHRoZSBQb3J0YWxMaXN0IGNvbXBvbmVudCBvZiB0aGUgc2Nyb2xsZXIgdG8gdHJpZ2dlciByZW5kZXJcbiAgICByZW5kZXJQb3J0YWxMaXN0ID0gKCkgPT4ge1xuXG4gICAgICAgIGlmICh0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5zZXRMaXN0U3RhdGUoKSAvLyB0cmlnZ2VyIGRpc3BsYXkgdXBkYXRlXG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWNoZSBzaXplIGxpbWl0IGVuZm9yY2VlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbWF0Y2hDYWNoZVRvQ3JhZGxlID0gKGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IEFycmF5LmZyb20odGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuXG4gICAgICAgIGNvbnN0IGRlbGtleXMgPSBtYXBrZXlzLmZpbHRlcihrZXkgPT4gIWNyYWRsZUluZGV4TGlzdC5pbmNsdWRlcyhrZXkpKVxuXG4gICAgICAgIGlmIChkZWxrZXlzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChkZWxrZXlzLCBkZWxldGVMaXN0Q2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHBhcmVDYWNoZVRvTWF4ID0gKGNhY2hlTWF4LCBjcmFkbGVJbmRleExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaywgc2Nyb2xsZXJJRCA9IHVuZGVmaW5lZCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsTGVuZ3RoID0gY3JhZGxlSW5kZXhMaXN0Lmxlbmd0aFxuXG4gICAgICAgIC8vIGRldGVybWluZSBuZWVkIGZvciBwYXJpbmdcbiAgICAgICAgaWYgKCghY2FjaGVNYXgpIHx8ICghbW9kZWxMZW5ndGgpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChtb2RlbExlbmd0aCwgY2FjaGVNYXgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhMaXN0ID0gdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAsXG4gICAgICAgICAgICByZXF1ZXN0ZWRTZXQgPSB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgaWYgKChwb3J0YWxJbmRleExpc3Quc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSBtYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIG1hcCBrZXlzXG4gICAgICAgIGNvbnN0IG1hcGtleXNsaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleExpc3Qua2V5cygpKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZGtleXMgPSBBcnJheS5mcm9tKHJlcXVlc3RlZFNldC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IFsuLi5tYXBrZXlzbGlzdCwuLi5yZXF1ZXN0ZWRrZXlzXVxuXG4gICAgICAgIG1hcGtleXMuc29ydCgoYSxiKSA9PiBhIC0gYilcblxuICAgICAgICAvLyBnZXQgbnVtYmVyIHRvIHBhcmVcbiAgICAgICAgY29uc3QgbWFwTGVuZ3RoID0gbWFwa2V5cy5sZW5ndGgsXG4gICAgICAgICAgICBwYXJlY291bnQgPSBtYXBMZW5ndGggLSBtYXhcblxuICAgICAgICAvLyBkaXN0cmlidXRlIHBhcmluZyBwcm9wb3J0aW9uYWxseSBhdCBmcm9udCBhbmQgYmFja1xuICAgICAgICBjb25zdCBoZWFkaW5kZXggPSBjcmFkbGVJbmRleExpc3RbMF0sXG4gICAgICAgICAgICB0YWlsaW5kZXggPSBjcmFkbGVJbmRleExpc3RbbW9kZWxMZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGhlYWRwb3MgPSBtYXBrZXlzLmluZGV4T2YoaGVhZGluZGV4KSxcbiAgICAgICAgICAgIHRhaWxwb3MgPSBtYXBrZXlzLmluZGV4T2YodGFpbGluZGV4KVxuXG4gICAgICAgIGNvbnN0IGhlYWRyb29tID0gaGVhZHBvcyxcbiAgICAgICAgICAgIHRhaWxyb29tID0gbWFwTGVuZ3RoIC0gKHRhaWxwb3MgKyAxKSxcbiAgICAgICAgICAgIHBhcmVyb29tID0gaGVhZHJvb20gKyB0YWlscm9vbVxuXG4gICAgICAgIGNvbnN0IGhlYWRwYXJlY291bnQgPSBNYXRoLmZsb29yKChoZWFkcm9vbS9wYXJlcm9vbSkqcGFyZWNvdW50KSxcbiAgICAgICAgICAgIHRhaWxwYXJlY291bnQgPSBwYXJlY291bnQgLSBoZWFkcGFyZWNvdW50XG5cbiAgICAgICAgLy8gY29sbGVjdCBpbmRleGVzIHRvIHBhcmVcbiAgICAgICAgY29uc3QgaGVhZGxpc3QgPSBtYXBrZXlzLnNsaWNlKDAsaGVhZHBhcmVjb3VudCksXG4gICAgICAgICAgICB0YWlsbGlzdCA9IG1hcGtleXMuc2xpY2UobWFwTGVuZ3RoIC0gdGFpbHBhcmVjb3VudClcblxuICAgICAgICBjb25zdCBkZWxMaXN0ID0gWy4uLmhlYWRsaXN0LC4uLnRhaWxsaXN0XVxuXG4gICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoY2FjaGVNYXgsIGNyYWRsZUxpc3RMZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTikgPT4ge1xuXG4gICAgICAgIGlmICghY2FjaGVNYXgpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHBvcnRhbE1hcCxcbiAgICAgICAgICAgIHJlcXVlc3RlZFNldCBcbiAgICAgICAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGNyYWRsZUxpc3RMZW5ndGgsIGNhY2hlTWF4KVxuXG4gICAgICAgIGlmICgocG9ydGFsTWFwLnNpemUgKyByZXF1ZXN0ZWRTZXQuc2l6ZSkgPD0gKChtYXgpICogTUFYX0NBQ0hFX09WRVJfUlVOKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcmVsb2FkIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHJlbG9hZChmaW5hbENhbGxiYWNrLCBudWxsSXRlbVNldE1heExpc3RzaXplLCBzY3JvbGxlcklEKSB7XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQYXJhbWV0ZXJzIH0gPSB0aGlzXG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlclByb3BlcnRpZXNSZWYgfSA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCB7IHN0YXRlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGdldEl0ZW0sIGNhY2hlTWF4IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgeyBsaXN0c2l6ZSB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuXG4gICAgICAgIGxldCBjYWNoZVNpemUgPSBjYWNoZU1heCA/PyAwXG5cbiAgICAgICAgY2FjaGVTaXplID0gTWF0aC5taW4oY2FjaGVTaXplLCBsaXN0c2l6ZSlcblxuICAgICAgICBjb25zdCBwcmVsb2Fkc2l6ZSA9IFxuICAgICAgICAgICAgY2FjaGVTaXplP1xuICAgICAgICAgICAgICAgIGNhY2hlU2l6ZTpcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZVxuXG4gICAgICAgIGNvbnN0IGJyZWFrbG9vcCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6ZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heExpc3RzaXplSW50ZXJydXB0ID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICBicmVha2xvb3AuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucHJlbG9hZEluZGV4Q2FsbGJhY2tcbiAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbmRleFRvSXRlbUlETWFwID0gdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXBcblxuICAgICAgICAgICAgY29uc3QgeyBwcmVsb2FkSW5kZXhDYWxsYmFjaywgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcmVsb2Fkc2l6ZTsgaW5kZXgrKykge1xuXG4gICAgICAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2sgJiYgcHJlbG9hZEluZGV4Q2FsbGJhY2soaW5kZXgpXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5wcmVsb2FkSXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChicmVha2xvb3AuY3VycmVudCkgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcykudGhlbihcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgZmluYWxDYWxsYmFjaygpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1bIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZ2V0Q2FjaGVJbmRleE1hcCgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IE1hcCh0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcClcblxuICAgIH1cblxuICAgIGdldENyYWRsZUluZGV4TWFwKGNyYWRsZUluZGV4TGlzdCkge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZU1hcCA9IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjcmFkbGVJbmRleExpc3QpIHtcblxuICAgICAgICAgICAgY3JhZGxlTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JhZGxlTWFwXG5cbiAgICB9XG5cbiAgICBnZXRDYWNoZUl0ZW1NYXAoKSB7XG5cbiAgICAgICAgY29uc3QgY2FjaGVsaXN0ID0gbmV3IE1hcCgpXG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSA9IHZhbHVlXG5cbiAgICAgICAgICAgIGNhY2hlbGlzdC5zZXQoa2V5LHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVsaXN0XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgU0VSVklDRSBTVVBQT1JUIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBtb3ZlIGlzIGNvZXJjZWQgYnkgc2VydmljZWhhbmRsZXIgdG8gYmUgd2l0aGluIGN1cnJlbnQgbGlzdCBib3VuZHNcbiAgICBtb3ZlSW5kZXgodG9pbmRleCwgZnJvbWluZGV4LCBmcm9taGlnaGluZGV4ICkge1xuXG4gICAgICAgIGNvbnN0IHtpbmRleFRvSXRlbUlETWFwLG1ldGFkYXRhTWFwfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGRlZmluZSBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHJhbmdlYWJzb2x1dGVpbmNyZW1lbnQgPSBmcm9taGlnaGluZGV4IC0gZnJvbWluZGV4ICsgMSxcbiAgICAgICAgICAgIG1vdmVkaXJlY3Rpb25hbGluY3JlbWVudCA9IHRvaW5kZXggLSBmcm9taW5kZXgsXG4gICAgICAgICAgICB0b2hpZ2hpbmRleCA9IHRvaW5kZXggKyAocmFuZ2VhYnNvbHV0ZWluY3JlbWVudCAtIDEpXG5cbiAgICAgICAgY29uc3Qgc2hpZnRkaXJlY3Rpb24gPSBcbiAgICAgICAgICAgIChtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgPiAwKT8gLy8gbW92ZSB1cCBpbiBsaXN0XG4gICAgICAgICAgICAgICAgLTE6IC8vIHNoaWZ0IGRvd24sIG1ha2Ugcm9vbSBmb3Igc2hpZnRpbmdpbmRleCBhYm92ZVxuICAgICAgICAgICAgICAgIDEgICAvLyBzaGlmdCB1cCwgbWFrZSByb29tIGZvciBzaGlmdGluZ2luZGV4IGJlbG93XG5cbiAgICAgICAgY29uc3Qgb3JkZXJlZGluZGV4bGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIG9yZGVyZWRpbmRleGxpc3Quc29ydCgoYSxiKT0+YS1iKVxuXG4gICAgICAgIGNvbnN0IHRvaW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSB0b2luZGV4KSxcbiAgICAgICAgICAgIHRvaGlnaGluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gdG9oaWdoaW5kZXgpLFxuICAgICAgICAgICAgZnJvbWluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gZnJvbWluZGV4KSxcbiAgICAgICAgICAgIGZyb21oaWdoaW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSBmcm9taGlnaGluZGV4KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gY2FwdHVyZSBpbmRleCBkYXRhIHRvIG1vdmUgLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBwcm9jZXNzdG9tb3ZlTGlzdFxuICAgICAgICBpZiAoKGZyb21pbmRleHB0ciA9PSAtMSkgJiYgKGZyb21oaWdoaW5kZXhwdHIgPT0gLTEpKSB7IC8vIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVMaXN0ID0gW11cblxuICAgICAgICB9IGVsc2UgaWYgKGZyb21oaWdoaW5kZXhwdHIgPT0gLTEpIHsgLy8gc2NvcGUgaXMgcGFydGlhbGx5IGluIHZpZXdcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21pbmRleHB0cilcblxuICAgICAgICB9IGVsc2UgeyAvLyBzY29wZSBpcyBlbnRpcmVseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taW5kZXhwdHIsIGZyb21oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9jZXNzdG9tb3ZlTWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGNvbnN0IGNhcHR1cmVtb3ZlaW5kZXggPSAoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5zZXQoaW5kZXgsIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZUxpc3QuZm9yRWFjaChjYXB0dXJlbW92ZWluZGV4KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gZ2V0IGxpc3Qgb2YgaW5kZXhlcyB0byBzaGlmdCBvdXQgb2YgdGhlIHdheSAtLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIGxldCBwcm9jZXNzdG9zaGlmdExpc3RcbiAgICAgICAgaWYgKHNoaWZ0ZGlyZWN0aW9uID09IDEpIHsgLy8gYmxvY2sgaXMgbW92aW5nIGRvd24sIHNoaWZ0IGlzIHVwOyB0b2luZGV4IDwgZnJvbWluZGV4XG5cbiAgICAgICAgICAgIGlmICgodG9pbmRleHB0ciA9PSAtMSkgJiYgKGZyb21pbmRleHB0ciA9PSAtMSkpIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbWluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKHRvaW5kZXhwdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKHRvaW5kZXhwdHIsIGZyb21pbmRleHB0cilcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHNoaWZ0ZGlyZWN0aW9uID09IC0xOyBibG9jayBpcyBtb3ZpbmcgdXAsIHNoaWZ0IGlzIGRvd247IGZyb21pbmRleCA8IHRvaW5kZXhcblxuICAgICAgICAgICAgaWYgKHRvaGlnaGluZGV4cHRyID09IC0xICYmIGZyb21oaWdoaW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IFtdXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9oaWdoaW5kZXhwdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWhpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21oaWdoaW5kZXhwdHIgKyAxLCB0b2hpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGlmdGRpcmVjdGlvbiA9PSAxKSBwcm9jZXNzdG9zaGlmdExpc3QucmV2ZXJzZSgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0gbW92ZSBpbmRleGVzIG91dCBvZiB0aGUgd2F5IC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2Vkc2hpZnRMaXN0ID0gW11cbiAgICAgICAgY29uc3QgcHJvY2Vzc3NoaWZ0aW5kZXggPSAoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gXG4gICAgICAgICAgICAgICAgKHNoaWZ0ZGlyZWN0aW9uID09IC0xKT9cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLSByYW5nZWFic29sdXRlaW5jcmVtZW50OlxuICAgICAgICAgICAgICAgICAgICBpbmRleCArIHJhbmdlYWJzb2x1dGVpbmNyZW1lbnRcblxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5zZXQobmV3SW5kZXgsaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2Vkc2hpZnRMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3N0b3NoaWZ0TGlzdC5mb3JFYWNoKHByb2Nlc3NzaGlmdGluZGV4KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSByZXBsYWNlIHNoaWZ0ZWQgaW5kZXggc3BhY2Ugd2l0aCBtb3ZlZCBpbmRleGVzIC0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRtb3ZlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IHByb2Nlc3Ntb3ZlaW5kZXggPSAoaXRlbUlELCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBpbmRleCArIG1vdmVkaXJlY3Rpb25hbGluY3JlbWVudCAvLyBzd2FwXG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKS5pbmRleCA9IG5ld0luZGV4XG4gICAgICAgICAgICBwcm9jZXNzZWRtb3ZlTGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9tb3ZlTWFwLmZvckVhY2gocHJvY2Vzc21vdmVpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLXJldHVybiBsaXN0IG9mIHByb2Nlc3NlZCBpbmRleGVzIHRvIGNhbGxlciAtLS0tLS0tLVxuICAgICAgICAvLyBmb3Igc3luY2hybml6YXRpb24gd2l0aCBjcmFkbGUgY2VsbEZyYW1lc1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEluZGV4ZXMgPSBbLi4ucHJvY2Vzc2Vkc2hpZnRMaXN0LC4uLnByb2Nlc3NlZG1vdmVMaXN0XVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRJbmRleGVzXG5cbiAgICB9XG5cbiAgICAvLyBpbnNlcnQgb3IgcmVtb3ZlIGluZGV4ZXM6IG11Y2ggb2YgdGhpcyBkZWFscyB3aXRoIHRoZSBmYWN0IHRoYXQgdGhlIGNhY2hlIGlzIHNwYXJzZS5cbiAgICBpbnNlcnRSZW1vdmVJbmRleChpbmRleCwgaGlnaHJhbmdlLCBpbmNyZW1lbnQsIGxpc3RzaXplKSB7IC8vIGluY3JlbWVudCBpcyArMSBvciAtMVxuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCwgbWV0YWRhdGFNYXAsIHBvcnRhbE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBkZWZpbmUgcmFuZ2UgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBoaWdoIHJhbmdlIGlzIHRoZSBoaWdoZXN0IGluZGV4IG51bWJlciBvZiB0aGUgaW5zZXJ0L3JlbW92ZSBvcGVyYXRpb25cbiAgICAgICAgbGV0IGhpZ2hyYW5nZWluZGV4ID0gaGlnaHJhbmdlID8/IDBcblxuICAgICAgICBoaWdocmFuZ2VpbmRleCA9IFxuICAgICAgICAgICAgKGhpZ2hyYW5nZWluZGV4ID4gaW5kZXgpP1xuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZWluZGV4OlxuICAgICAgICAgICAgICAgIGluZGV4XG5cbiAgICAgICAgY29uc3QgZW1wdHlyZXR1cm4gPSBbW10sW10sMF1cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmFsIG11c3QgYmUgZW50aXJlbHkgd2l0aGluIHNjb3BlIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoaGlnaHJhbmdlaW5kZXggPiAobGlzdHNpemUgLSAxKSkgcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gY2FuIGF0IG1vc3Qgc3RhcnQgYXQgdGhlIG5leHQgaW5kZXggYWJvdmUgdGhlIGN1cnJlbnQgbGlzdFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gbGlzdHNpemUpIHJldHVybiBlbXB0eXJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByYW5nZWNvdW50IGlzIHRoZSBhYnNvbHV0ZSBudW1iZXIgaW4gdGhlIGluc2VydC9yZW1vdmUgcmFuZ2UgLSBjb250aWd1b3VzXG4gICAgICAgIGNvbnN0IHJhbmdlY291bnQgPSBoaWdocmFuZ2VpbmRleCAtIGluZGV4ICsgMVxuXG4gICAgICAgIC8vIHJhbmdlIGluY3JlbWVudCBhZGRzIHNpZ24gdG8gcmFuZ2Vjb3VudCB0byBpbmRpY2F0ZSBhZGQvcmVtb3ZlXG4gICAgICAgIGNvbnN0IHJhbmdlaW5jcmVtZW50ID0gcmFuZ2Vjb3VudCAqIGluY3JlbWVudFxuXG4gICAgICAgIC8vIGhpZ2hQdHIsIGxvd1B0ciwgc2hyaW5rdG9QdHIgd2l0aGluIG9yZGVyZWRJbmRleExpc3QuXG4gICAgICAgIGNvbnN0IG9yZGVyZWRJbmRleExpc3QgPSBBcnJheS5mcm9tKGluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICBvcmRlcmVkSW5kZXhMaXN0LnNvcnQoKGEsYik9PmEtYilcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSBib3VuZGFyaWVzIHdpdGhpbiBvcmRlcmVkIGNhY2hlIGluZGV4IGxpc3QgLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFB0ciA9IGluZGV4IGludG8gYXJyYXksIGFzIG9wcG9zZWQgdG8gaW5kZXggb2YgdmlydHVhbCBsaXN0XG5cbiAgICAgICAgLy8gc2hyaW5rcHRyIGlzIHRoZSBsb2NhdGlvbiBvZiB0aGUgYm90dG9tIG9mIHRoZSBzaHJpbmsgcmFuZ2UgZm9yIHJlbW92YWxzXG4gICAgICAgIGxldCBzaHJpbmt0b0luZGV4ID0gbnVsbFxuICAgICAgICBsZXQgc2hyaW5rdG9QdHIgPSAtIDFcbiAgICAgICAgXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gLSAxKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNocmlua3RvSW5kZXggPSBvcmRlcmVkSW5kZXhMaXN0LmF0KC0xKSArIChyYW5nZWluY3JlbWVudClcblxuICAgICAgICAgICAgc2hyaW5rdG9JbmRleCA9IE1hdGgubWF4KGhpZ2hyYW5nZWluZGV4ICsgKHJhbmdlaW5jcmVtZW50KSwgc2hyaW5rdG9JbmRleClcblxuICAgICAgICAgICAgc2hyaW5rdG9JbmRleCA9IE1hdGgubWluKGxpc3RzaXplIC0gMSxzaHJpbmt0b0luZGV4KSBcblxuICAgICAgICAgICAgc2hyaW5rdG9QdHIgPSBvcmRlcmVkSW5kZXhMaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSBzaHJpbmt0b0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb3dQdHIgYW5kIGhpZ2hQdHIgbXVzdCBiZSB3aXRoaW4gbG93IGFuZCBoaWdoIHJhbmdlXG4gICAgICAgIGNvbnN0IGxvd1B0ciA9IG9yZGVyZWRJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSBpbmRleCkgJiYgKHZhbHVlIDw9IGhpZ2hyYW5nZWluZGV4KVxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgcmV2ZXJzZUluZGV4TGlzdCA9IEFycmF5LmZyb20ob3JkZXJlZEluZGV4TGlzdClcbiAgICAgICAgcmV2ZXJzZUluZGV4TGlzdC5yZXZlcnNlKClcbiAgICAgICAgbGV0IGhpZ2hQdHIgPSByZXZlcnNlSW5kZXhMaXN0LmZpbmRJbmRleCh2YWx1ZT0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IGhpZ2hyYW5nZWluZGV4XG5cbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGhpZ2hQdHIgIT0gLTEpIHtcbiAgICAgICAgICAgIGhpZ2hQdHIgPSAob3JkZXJlZEluZGV4TGlzdC5sZW5ndGggLSAxKSAtIGhpZ2hQdHJcbiAgICAgICAgICAgIGlmIChoaWdoUHRyIDwgbG93UHRyKSBoaWdoUHRyID0gLTFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGxpc3QgaW5kZXhlcyB0byBwcm9jZXNzLCByZXBsYWNlLCBhbmQgcmVtb3ZlLCBhbmQgaXRlbXMgdG8gcmVtb3ZlIC0tLS0tLS0tXG5cbiAgICAgICAgbGV0IGluZGV4ZXNUb1Byb2Nlc3NMaXN0LCAvLyBmb3IgZWl0aGVyIGluc2VydCBvciByZW1vdmVcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gW10sIC8vIGZvciBpbnNlcnQgdGhlIHJhbmdlIGJlaW5nIGluc2VydGVkXG4gICAgICAgICAgICBpbmRleGVzVG9SZW1vdmVMaXN0ID0gW10sIC8vIGZvciByZW1vdmUgLSBlbmQgb2YgbGlzdDsgdGhlIGxpc3QgaXMgc2hyaW5raW5nXG4gICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdD0gW10sIC8vIGZvciByZW1vdmUgLSB3aXRoaW4gdGhlIHJhbmdlIG9mIGluZGV4ZXMgYmVpbmcgcmVtb3ZlZFxuICAgICAgICAgICAgaXRlbXNUb1JlbW92ZUxpc3QgPSBbXSAvLyBmb3IgcmVtb3ZlLCBkZXJpdmVkIGZyb20gdGhlIHByZXZpb3VzXG5cbiAgICAgICAgLy8gZ2V0IGluZGV4ZXNUb1Byb2Nlc3NMaXN0XG4gICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IFtdXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gY29yZSBzY29wZSBpcyBwYXJ0aWFsbHkgb3IgZnVsbHkgaW4gdmlldzsgbG93UHRyIGlzIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaFB0ciA9PSAtMSkgeyAvLyBpbmNyZW1lbnQgPT0gLTE7IGxvd1B0ciBpcyBhdmFpbGFibGVcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW5jcmVtZW50ID09IC0xOyBsb3dQdHIgYW5kIGhpZ2hQdHIgYXJlIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGhpZ2hQdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEhvbGRMaXN0ID0gW10gLy8gaG9sZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBhZnRlciBjcmFkbGUgc3luY2hcblxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IDEpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGluZGV4ZXNUb1JlcGxhY2VMaXN0XG4gICAgICAgICAgICBpZiAoKGxvd1B0ciA9PSAtMSkgJiYgKGhpZ2hQdHIgPT0gLTEpKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaWdoUHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0ciwgaGlnaFB0ciArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGluZGV4ZXNUb1JlbW92ZUxpc3RcbiAgICAgICAgICAgIGlmIChzaHJpbmt0b1B0ciA9PSAtMSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmVMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKHNocmlua3RvUHRyICsgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBpZiAoKGxvd1B0ciA9PSAtMSkgJiYgKGhpZ2hQdHIgPT0gLTEpKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gW11cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaWdoUHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0ciwgaGlnaFB0ciArIDEpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IGl0ZW1zVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtc1RvUmVtb3ZlTGlzdC5wdXNoKGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBjb25kdWN0IGNhY2hlIG9wZXJhdGlvbnMgLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGluY3JlbWVudCBoaWdoZXIgZnJvbSB0b3Agb2YgbGlzdCB0byBwcmVzZXJ2ZSBsb3dlciB2YWx1ZXMgZm9yIHN1YnNlcXVlbnQgaW5jcmVtZW50XG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkgaW5kZXhlc1RvUHJvY2Vzc0xpc3QucmV2ZXJzZSgpIFxuXG4gICAgICAgIGNvbnN0IGluZGV4ZXNNb2RpZmllZExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1vZGlmeSBpbmRleC10by1pdGVtaWQgbWFwLCBhbmQgbWV0YWRhdGEgbWFwXG4gICAgICAgIGNvbnN0IHByb2Nlc3NJbmRleCA9IGluZGV4ID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgcmFuZ2VpbmNyZW1lbnRcblxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5zZXQobmV3SW5kZXgsIGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIGluZGV4ZXNNb2RpZmllZExpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QuZm9yRWFjaChwcm9jZXNzSW5kZXgpXG5cbiAgICAgICAgLy8gZGVsZXRlIHJlbWFpbmluZyBpbmRleGVzIGFuZCBpdGVtcyBub3cgZHVwbGljYXRlc1xuXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXNUb1JlcGxhY2VMaXN0KSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbUlEIG9mIGl0ZW1zVG9SZW1vdmVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgICAgIHBvcnRhbEhvbGRMaXN0LnB1c2goaXRlbUlEKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLSByZXR1cm5zIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZXMgZm9yIGNhbGxlciB0byBzZW5kIHRvIGNvbnRlbnRoYW5kbGVyIGZvciBjcmFkbGUgc3luY2hyb25pemF0aW9uXG4gICAgICAgIHJldHVybiBbaW5kZXhlc01vZGlmaWVkTGlzdCwgaW5kZXhlc1RvUmVwbGFjZUxpc3QsIHJhbmdlaW5jcmVtZW50LCBwb3J0YWxIb2xkTGlzdF1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBJTkRJVklEVUFMIFBPUlRBTCBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1c2VkIGZvciBzaXplIGNhbGN1bGF0aW9uIGluIHBhcmVDYWNoZVRvTWF4XG4gICAgLy8gcmVnaXN0ZXJzIGluZGV4ZXMgd2hlbiByZXF1ZXN0ZWQgYnV0IGJlZm9yZSByZXRyaWV2ZWQgYW5kIGVudGVyZWQgaW50byBjYWNoZVxuICAgIHJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsKGluZGV4KSB7XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldC5hZGQoaW5kZXgpXG5cbiAgICB9XG5cbiAgICByZW1vdmVSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmRlbGV0ZShpbmRleClcblxuICAgIH1cblxuICAgIGdldE5ld0l0ZW1JRCgpIHtcblxuICAgICAgICByZXR1cm4gZ2xvYmFsSXRlbUlEKytcblxuICAgIH1cblxuICAgIC8vIGdldCBuZXcgb3IgZXhpc3RpbmcgaXRlbUlEIGZvciBjb250ZW50ZnVuY3Rpb25zLmNyZWF0ZUNlbGxGcmFtZVxuICAgIGdldE5ld09yRXhpc3RpbmdJdGVtSUQoaW5kZXgpIHtcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IGl0ZW1JRCA9IFxuICAgICAgICAgICAgKGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSk/XG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpOlxuICAgICAgICAgICAgICAgICh0aGlzLmdldE5ld0l0ZW1JRCgpKVxuXG4gICAgICAgIHJldHVybiBpdGVtSURcblxuICAgIH1cblxuICAgICAvLyBjcmVhdGUgbmV3IHBvcnRhbFxuICAgIGNyZWF0ZVBvcnRhbChjb21wb25lbnQsIGluZGV4LCBpdGVtSUQsIGlzUHJlbG9hZCA9IGZhbHNlKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpXG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgb3JpZW50YXRpb24gfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlKFxuICAgICAgICAgICAgICAgIGluZGV4LCBpdGVtSUQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aClcblxuICAgICAgICAvLyBkaXYgd3JhcHBlciB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLnNldChpdGVtSUQsXG4gICAgICAgICAgICAgICAgPGRpdiBkYXRhLXR5cGUgPSAncG9ydGFsd3JhcHBlcicga2V5ID0ge2l0ZW1JRH0gZGF0YS1pdGVtaWQgPSB7aXRlbUlEfSBkYXRhLWluZGV4ID0ge2luZGV4fT5cbiAgICAgICAgICAgICAgICAgICAgPEluUG9ydGFsIGtleSA9IHtpdGVtSUR9IG5vZGUgPSB7cG9ydGFsTm9kZX0gPiB7IGNvbXBvbmVudCB9IDwvSW5Qb3J0YWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+KVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcblxuICAgICAgICBjb25zdCBwb3J0YWxNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHBvcnRhbE5vZGUsXG4gICAgICAgICAgICBpc1JlcGFyZW50aW5nUmVmOntcbiAgICAgICAgICAgICAgICBjdXJyZW50OmZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbUlELFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLnNldChpdGVtSUQsIHBvcnRhbE1ldGFkYXRhKVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5zZXQoaW5kZXgsIGl0ZW1JRClcblxuICAgICAgICBpZiAoIWlzUHJlbG9hZCkgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICByZXR1cm4gcG9ydGFsTWV0YWRhdGFcblxuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHByZWxvYWRpbmcgbmV3IGl0ZW1cbiAgICBwcml2YXRlIGFzeW5jIHByZWxvYWRJdGVtKFxuICAgICAgICBpbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrLFxuICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdCxcbiAgICAgICAgc2Nyb2xsZXJJRFxuICAgICkge1xuXG4gICAgICAgIGNvbnN0IGl0ZW1JRCA9IHRoaXMuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICBsZXQgcmV0dXJudmFsdWUsIHVzZXJjb250ZW50LCBlcnJvclxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIHVzZXJjb250ZW50ID0gYXdhaXQgZ2V0SXRlbShpbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSBudWxsKSByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBSZWFjdCBlbGVtZW50JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgIGxldCBjb250ZW50IFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIGlzUmVwYXJlbnRpbmdSZWY6bnVsbCxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQucHJvcHMuaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudCh1c2VyY29udGVudCwge3Njcm9sbGVyUHJvcGVydGllc30pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB1c2VyY29udGVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwb3J0YWxEYXRhID0gXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3J0YWwoY29udGVudCwgaW5kZXgsIGl0ZW1JRCwgdHJ1ZSkgLy8gdHJ1ZSA9IGlzUHJlbG9hZFxuICAgICAgICAgICAgLy8gbWFrZSBhdmFpbGFibGUgdG8gdXNlciBjb250ZW50XG4gICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZiA9IHBvcnRhbERhdGEuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAncHJlbG9hZCcsIGVycm9yKVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB1c2VyY29udGVudCA9PT0gbnVsbDsgbGFzdCBpdGVtIGluIGxpc3RcblxuICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2soaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdwcmVsb2FkJywgbmV3IEVycm9yKCdlbmQgb2YgbGlzdCcpKVxuXG4gICAgICAgICAgICAgICAgbWF4TGlzdHNpemVJbnRlcnJ1cHQoaW5kZXgpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBkZWxldGUgYSBwb3J0YWwgbGlzdCBpdGVtXG4gICAgLy8gYWNjZXB0cyBhbiBhcnJheSBvZiBpbmRleGVzXG4gICAgZGVsZXRlUG9ydGFsKGluZGV4LCBkZWxldGVMaXN0Q2FsbGJhY2spIHtcblxuICAgICAgICBjb25zdCBpbmRleEFycmF5ID0gXG4gICAgICAgICAgICAoIUFycmF5LmlzQXJyYXkoaW5kZXgpKT9cbiAgICAgICAgICAgICAgICBbaW5kZXhdOlxuICAgICAgICAgICAgICAgIGluZGV4XG5cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLFxuICAgICAgICAgICAgcG9ydGFsTWFwLFxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcCBcbiAgICAgICAgfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZUxpc3QgPSBbXVxuICAgICAgICBmb3IgKGxldCBpIG9mIGluZGV4QXJyYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaSlcblxuICAgICAgICAgICAgZGVsZXRlTGlzdC5wdXNoKHtpbmRleDppLGl0ZW1JRH0pXG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgcG9ydGFsTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpKVxuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcblxuICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2sgJiYgZGVsZXRlTGlzdENhbGxiYWNrKGRlbGV0ZUxpc3QpXG5cbiAgICB9XG5cbiAgICAvLyBxdWVyeSBleGlzdGVuY2Ugb2YgYSBwb3J0YWwgbGlzdCBpdGVtXG4gICAgaGFzUG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuaGFzKGl0ZW1JRClcblxuICAgIH1cblxuICAgIGdldFBvcnRhbChpdGVtSUQpIHtcblxuICAgICAgICBpZiAodGhpcy5oYXNQb3J0YWwoaXRlbUlEKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFV0aWxpdHkgZnVuY3Rpb24gXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gZ2V0IGEgcmVhY3QtcmV2ZXJzZS1wb3J0YWwgSW5Qb3J0YWwgY29tcG9uZW50LCB3aXRoIGl0cyBtZXRhZGF0YVxuLy8gd2l0aCB1c2VyIGNvbnRlbnQgYW5kIGNvbnRhaW5lclxuLy8gc2VlIGFsc28gc29tZSBzdHlsZXMgc2V0IGluIENlbGxGcmFtZVxuXG5jb25zdCBjcmVhdGVQb3J0YWxOb2RlID0gKGluZGV4LCBpdGVtSUQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCkgPT4ge1xuXG4gICAgbGV0IHBvcnRhbE5vZGUgPSBjcmVhdGVIdG1sUG9ydGFsTm9kZSgpXG5cbiAgICBsZXQgY29udGFpbmVyID0gcG9ydGFsTm9kZS5lbGVtZW50XG4gICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbidcblxuICAgIGNvbnRhaW5lci5kYXRhc2V0LnR5cGUgPSAnY29udGVudGVudmVsb3BlJ1xuICAgIGNvbnRhaW5lci5kYXRhc2V0LmluZGV4ID0gaW5kZXhcbiAgICBjb250YWluZXIuZGF0YXNldC5jYWNoZWl0ZW1pZCA9IGl0ZW1JRFxuXG4gICAgcmV0dXJuIHBvcnRhbE5vZGVcblxufSAgICAgXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBjb21wb25lbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBwb3J0YWwgbGlzdCBjb21wb25lbnQgZm9yIHJhcGlkIHJlbGlzdGluZyBvZiB1cGRhdGVzLCB1c2luZyBleHRlcm5hbCBjYWxsYmFjayBmb3Igc2V0IHN0YXRlXG5leHBvcnQgY29uc3QgUG9ydGFsTGlzdCA9ICh7IGNhY2hlUHJvcHMgfSkgPT4ge1xuXG4gICAgY29uc3QgW3BvcnRhbExpc3RDb3VudGVyLCBzZXRQb3J0YWxMaXN0Q291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuXG4gICAgY29uc3QgY291bnRlclJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvdW50ZXJSZWYuY3VycmVudCA9IHBvcnRhbExpc3RDb3VudGVyXG5cbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBwb3J0YWxBcnJheVJlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIGNvbnN0IGNhY2hlZGl2UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBjYWNoZVByb3BzLnNldExpc3RTdGF0ZSA9ICgpPT57XG5cbiAgICAgICAgICAgIHBvcnRhbEFycmF5UmVmLmN1cnJlbnQgPSBjYWNoZVByb3BzLnBvcnRhbExpc3RcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0UG9ydGFsTGlzdENvdW50ZXIoKytjb3VudGVyUmVmLmN1cnJlbnQpIC8vIGZvcmNlIHJlbmRlclxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSkgXG5cbiAgICByZXR1cm4gcG9ydGFsQXJyYXlSZWYuY3VycmVudFxuXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsSXRlbUlEIiwiQ2FjaGVIYW5kbGVyIiwic2Nyb2xsZXJJRCIsInNldExpc3RzaXplIiwibGlzdHNpemVSZWYiLCJzZXRMaXN0U3RhdGUiLCJtb2RpZmllZCIsIm1ldGFkYXRhTWFwIiwiTWFwIiwicmVxdWVzdGVkU2V0IiwiU2V0IiwicG9ydGFsTWFwIiwiaW5kZXhUb0l0ZW1JRE1hcCIsInBvcnRhbExpc3QiLCJuZXdsaXN0c2l6ZSIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJwb3J0YWxJbmRleE1hcCIsImNhY2hlUHJvcHMiLCJtYXBrZXlzTGlzdCIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJzb3J0IiwiYSIsImIiLCJoaWdoZXN0aW5kZXgiLCJhdCIsInBhcmVsaXN0IiwiZmlsdGVyIiwiaW5kZXgiLCJkZWxldGVQb3J0YWwiLCJjbGVhciIsInJlbmRlclBvcnRhbExpc3QiLCJ2YWx1ZXMiLCJjcmFkbGVJbmRleExpc3QiLCJtYXBrZXlzIiwiZGVsa2V5cyIsImluY2x1ZGVzIiwia2V5IiwibGVuZ3RoIiwiY2FjaGVNYXgiLCJ1bmRlZmluZWQiLCJtb2RlbExlbmd0aCIsIm1heCIsIk1hdGgiLCJwb3J0YWxJbmRleExpc3QiLCJzaXplIiwibWFwa2V5c2xpc3QiLCJyZXF1ZXN0ZWRrZXlzIiwibWFwTGVuZ3RoIiwicGFyZWNvdW50IiwiaGVhZGluZGV4IiwidGFpbGluZGV4IiwiaGVhZHBvcyIsImluZGV4T2YiLCJ0YWlscG9zIiwiaGVhZHJvb20iLCJ0YWlscm9vbSIsInBhcmVyb29tIiwiaGVhZHBhcmVjb3VudCIsImZsb29yIiwidGFpbHBhcmVjb3VudCIsImhlYWRsaXN0Iiwic2xpY2UiLCJ0YWlsbGlzdCIsImRlbExpc3QiLCJjcmFkbGVMaXN0TGVuZ3RoIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiZmluYWxDYWxsYmFjayIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJjcmFkbGVQYXJhbWV0ZXJzIiwic2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50Iiwic3RhdGVIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImdldEl0ZW0iLCJsaXN0c2l6ZSIsInByb21pc2VzIiwiY2FjaGVTaXplIiwibWluIiwicHJlbG9hZHNpemUiLCJicmVha2xvb3AiLCJtYXhMaXN0c2l6ZUludGVycnVwdCIsImlzTW91bnRlZFJlZiIsImNhbGxiYWNrcyIsInByZWxvYWRJbmRleENhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayIsImhhcyIsInByb21pc2UiLCJwcmVsb2FkSXRlbSIsInB1c2giLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInRoZW4iLCJjcmFkbGVNYXAiLCJzZXQiLCJnZXQiLCJjYWNoZWxpc3QiLCJ2YWx1ZSIsImNvbXBvbmVudCIsInRvaW5kZXgiLCJmcm9taW5kZXgiLCJmcm9taGlnaGluZGV4IiwicmFuZ2VhYnNvbHV0ZWluY3JlbWVudCIsIm1vdmVkaXJlY3Rpb25hbGluY3JlbWVudCIsInRvaGlnaGluZGV4Iiwic2hpZnRkaXJlY3Rpb24iLCJvcmRlcmVkaW5kZXhsaXN0IiwidG9pbmRleHB0ciIsImZpbmRJbmRleCIsInRvaGlnaGluZGV4cHRyIiwiZnJvbWluZGV4cHRyIiwiZnJvbWhpZ2hpbmRleHB0ciIsInByb2Nlc3N0b21vdmVMaXN0IiwicHJvY2Vzc3RvbW92ZU1hcCIsImNhcHR1cmVtb3ZlaW5kZXgiLCJmb3JFYWNoIiwicHJvY2Vzc3Rvc2hpZnRMaXN0IiwicmV2ZXJzZSIsInByb2Nlc3NlZHNoaWZ0TGlzdCIsInByb2Nlc3NzaGlmdGluZGV4IiwiaXRlbUlEIiwibmV3SW5kZXgiLCJwcm9jZXNzZWRtb3ZlTGlzdCIsInByb2Nlc3Ntb3ZlaW5kZXgiLCJwcm9jZXNzZWRJbmRleGVzIiwiaGlnaHJhbmdlIiwiaW5jcmVtZW50IiwiaGlnaHJhbmdlaW5kZXgiLCJlbXB0eXJldHVybiIsInJhbmdlY291bnQiLCJyYW5nZWluY3JlbWVudCIsIm9yZGVyZWRJbmRleExpc3QiLCJzaHJpbmt0b0luZGV4Iiwic2hyaW5rdG9QdHIiLCJsb3dQdHIiLCJyZXZlcnNlSW5kZXhMaXN0IiwiaGlnaFB0ciIsImluZGV4ZXNUb1Byb2Nlc3NMaXN0IiwiaW5kZXhlc1RvUmVwbGFjZUxpc3QiLCJpbmRleGVzVG9SZW1vdmVMaXN0IiwiaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QiLCJpdGVtc1RvUmVtb3ZlTGlzdCIsInBvcnRhbEhvbGRMaXN0IiwiaW5kZXhlc01vZGlmaWVkTGlzdCIsInByb2Nlc3NJbmRleCIsImFkZCIsImdldE5ld0l0ZW1JRCIsImlzUHJlbG9hZCIsInJlbW92ZVJlcXVlc3RlZFBvcnRhbCIsImxheW91dCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJvcmllbnRhdGlvbiIsInBvcnRhbE5vZGUiLCJjcmVhdGVQb3J0YWxOb2RlIiwicmVhY3RfMSIsInJlYWN0X3JldmVyc2VfcG9ydGFsXzEiLCJub2RlIiwicG9ydGFsTWV0YWRhdGEiLCJpc1JlcGFyZW50aW5nUmVmIiwidXNlcmNvbnRlbnQiLCJyZXR1cm52YWx1ZSIsImVycm9yIiwiaXNWYWxpZEVsZW1lbnQiLCJFcnJvciIsInNjcm9sbGVyUHJvcGVydGllcyIsInByb3BzIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwicG9ydGFsRGF0YSIsImNyZWF0ZVBvcnRhbCIsImluZGV4QXJyYXkiLCJpc0FycmF5IiwiZGVsZXRlTGlzdCIsImkiLCJoYXNQb3J0YWwiLCJleHBvcnRzIiwiY29udGFpbmVyIiwiZWxlbWVudCIsInN0eWxlIiwib3ZlcmZsb3ciLCJkYXRhc2V0IiwidHlwZSIsImNhY2hlaXRlbWlkIiwiUG9ydGFsTGlzdCIsInBvcnRhbExpc3RDb3VudGVyIiwic2V0UG9ydGFsTGlzdENvdW50ZXIiLCJjb3VudGVyUmVmIiwicG9ydGFsQXJyYXlSZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/cachehandler.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // contentfunctions.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calcContentShift = exports.getShiftInstruction = exports.getContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    getContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    getShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\")); // ======================[ for setCradleContent ]===========================\n\n\nvar getContentListRequirements = function getContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n      baseRowLength = _ref.baseRowLength,\n      targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n      cradleInheritedProperties = _ref.cradleInheritedProperties,\n      cradleInternalProperties = _ref.cradleInternalProperties;\n  var padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount,\n      listRowcount = cradleInternalProperties.listRowcount,\n      listsize = cradleInternalProperties.listsize,\n      viewportVisibleRowcount = cradleInternalProperties.viewportVisibleRowcount; // align axis reference to first row item\n\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount; // derive target row\n\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  var maxAxisRowOffset = Math.max(0, listRowcount - viewportVisibleRowcount);\n\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  } // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n\n\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount); // trailing edge\n\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount; // ---------------------[ calc cradle content count ]---------------------\n\n  var newCradleContentCount = cradleRowcount * crosscount;\n\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  } // --------------------[ calc css positioning ]-----------------------\n\n\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * baseRowLength + padding - targetAxisViewportPixelOffset; // ----------------------[ return required values ]---------------------\n\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\n\nexports.getContentListRequirements = getContentListRequirements; // ======================[ for updateCradleContent ]===========================\n\n/*\n\n    the two triggerlines must straddle the head of the viewport (top or left) so that\n    cradle motion can be detected. Motion is most often caused by scrolling, but\n    can also occur with change of size of cradle content rows.\n\n    getShiftInstruction determines whether the axis should be moved toward the head or tail\n        to restore the straddling position of the two trigger lines. Lots of relative motion.\n\n    'axisheadward' (scrolling down or right) means moving the axis up or left, adjacent items down\n         or right to the tail, dropping trailing tail items, and adding leading head items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'axistailward' (scrolling up or left) means moving the axis down or right, adjacent items up\n         or left to the head, dropping trailing head items, and adding leading tail items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'none' means no shift is required\n\n*/\n\nvar getShiftInstruction = function getShiftInstruction(_ref2) {\n  var orientation = _ref2.orientation,\n      triggerlineEntries = _ref2.triggerlineEntries,\n      triggerlineSpan = _ref2.triggerlineSpan,\n      scrollerID = _ref2.scrollerID,\n      isFirstRowTriggerConfig = _ref2.isFirstRowTriggerConfig;\n  var triggerData = {\n    headOffset: null,\n    tailOffset: null,\n    span: triggerlineSpan,\n    isFirstRowTriggerConfig: isFirstRowTriggerConfig\n  };\n  var entry = triggerlineEntries.at(-1); // most recent; either triggerline will do\n\n  var referencename = entry.target.dataset.type;\n  var span = triggerlineSpan;\n  var rootpos = orientation == 'vertical' ? entry.rootBounds.y : entry.rootBounds.x;\n  var entrypos = orientation == 'vertical' ? entry.boundingClientRect.y : entry.boundingClientRect.x;\n  var viewportTriggerOffset = entrypos - rootpos;\n\n  if (referencename == 'headtrigger') {\n    triggerData.headOffset = viewportTriggerOffset;\n    triggerData.tailOffset = viewportTriggerOffset + span;\n  } else {\n    // tailtrigger\n    triggerData.tailOffset = viewportTriggerOffset;\n    triggerData.headOffset = viewportTriggerOffset - span;\n  }\n\n  var shiftinstruction;\n\n  if (isFirstRowTriggerConfig) {\n    if (triggerData.headOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  } else {\n    if (triggerData.tailOffset <= 0) {\n      shiftinstruction = 'axistailward';\n    } else if (triggerData.headOffset >= 0) {\n      shiftinstruction = 'axisheadward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  }\n\n  return [shiftinstruction, triggerData];\n};\n\nexports.getShiftInstruction = getShiftInstruction;\n/*\n\n    The basic goal here is to determine the number and direction of rows to shift between\n    the head and tail grids (which dtermines the new location of the axis), and also to\n    calculate the rolling addition and deletion of cradle content to accommodate the changes.\n\n    The number of rows to shift is determined by the pixel shift required to restore the\n    triggerlines to their straddle configuration around the head (top or left) of the viewport.\n\n    Adjustments are made to accommodate special requirements at the start and end of the virtual list.\n\n    DOM measurements are used where available (to accommodate variable dimension rows), and standard\n    units (cellHeight, cellWidth) used where necessary.\n\n*/\n// rowshift is at least 1 by the time this function is reached\n// ie. a shiftinstruction of 'axisheadward' or 'axistailward'\n\nvar calcContentShift = function calcContentShift(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n      triggerData = _ref3.triggerData,\n      scrollPos = _ref3.scrollPos,\n      scrollblockElement = _ref3.scrollblockElement,\n      cradleInheritedProperties = _ref3.cradleInheritedProperties,\n      cradleInternalProperties = _ref3.cradleInternalProperties,\n      cradleContent = _ref3.cradleContent,\n      cradleElements = _ref3.cradleElements;\n\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n\n  var gap = cradleInheritedProperties.gap,\n      orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      layout = cradleInheritedProperties.layout;\n  var axisElement = cradleElements.axisRef.current,\n      headGridElement = cradleElements.headRef.current,\n      tailGridElement = cradleElements.tailRef.current;\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n      tailcontentlist = cradleContent.tailModelComponents;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      listsize = cradleInternalProperties.listsize,\n      listRowcount = cradleInternalProperties.listRowcount,\n      viewportRowcount = cradleInternalProperties.viewportRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var referenceGridElement = // moving axis (and triggers) toward the reference grid element\n  shiftinstruction == 'axistailward' ? // scrolling up or left\n  tailGridElement : headGridElement;\n  var gridRowLengths = getGridRowLengths(referenceGridElement, orientation, crosscount, gap);\n\n  if (shiftinstruction == 'axisheadward') {\n    // scrolling down or right; move triggerlines up or left\n    gridRowLengths.reverse(); // head row lengths listed from axis toward head\n  }\n\n  var gridRowSpans = getGridRowSpans(gridRowLengths);\n  var triggerViewportReferencePos = shiftinstruction == 'axistailward' ? // block scrolling up or left\n  triggerData.tailOffset : // needs to move down or right toward tail\n  triggerData.headOffset; // needs to move up or left toward head\n\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0,\n      previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0,\n      previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount); // ----------------------------[ 2. calculate base row shift ]--------------------------\n\n  var spanRowPtr;\n\n  if (shiftinstruction == 'axistailward') {\n    // scroll up\n    // tail trigger needs to move down or right until position relative to viewport top or left is positive\n    spanRowPtr = gridRowSpans.findIndex(function (movementspan) {\n      return triggerViewportReferencePos + movementspan >= 0;\n    });\n  } else {\n    // 'axisheadward', scrolldown\n    // head trigger needs to move up or left until position relative to viewport top or left is negative\n    spanRowPtr = gridRowSpans.findIndex(function (movementspan) {\n      return triggerViewportReferencePos - movementspan <= 0;\n    });\n  }\n\n  var spanAxisPixelShift; // in relation to viewport head boundary\n\n  if (spanRowPtr == -1) {\n    // overshoot of instantiated rows; continue with virtual rows\n    var notionalRowPtr;\n\n    if (gridRowSpans.length == 0) {\n      // must be list boundary\n      // notionalRowPtr = 0\n      notionalRowPtr = -1; // \"not found\"\n\n      spanAxisPixelShift = 0;\n    } else {\n      var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      notionalRowPtr = gridRowSpans.length - 1; // base: failed measured row ptr\n\n      var totalPixelShift = gridRowSpans[notionalRowPtr]; // set base of working overshoot\n\n      if (shiftinstruction == 'axistailward') {\n        // scrolling up\n        do {\n          totalPixelShift += baseRowLength;\n          notionalRowPtr++;\n        } while (triggerViewportReferencePos + totalPixelShift < 0);\n\n        spanAxisPixelShift = totalPixelShift;\n      } else {\n        // axisheadward; scrolling down\n        do {\n          totalPixelShift += baseRowLength;\n          notionalRowPtr++;\n\n          if (previousAxisRowOffset - (notionalRowPtr + 1) < 0) {\n            // stop cycling at head limit\n            // accommodate isFirstRowTriggerConfig\n            notionalRowPtr -= 1;\n            totalPixelShift -= baseRowLength;\n            break;\n          }\n        } while (triggerViewportReferencePos - totalPixelShift > 0);\n\n        spanAxisPixelShift = -totalPixelShift;\n      }\n    }\n\n    spanRowPtr = notionalRowPtr;\n  } else {\n    // final values found in instantiated rows\n    spanAxisPixelShift = shiftinstruction == 'axistailward' ? gridRowSpans[spanRowPtr] : // move axis toward tail from viewport boundary (positive)\n    -gridRowSpans[spanRowPtr]; // move axis toward head from viewport boundary (negative)\n  }\n\n  var spanRowShift = // pick up row shift with or without overshoot\n  shiftinstruction == 'axistailward' ? spanRowPtr + 1 : -(spanRowPtr + 1); // the following two values, and no other calcs, are carried forward in the function.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n\n  var axisReferenceRowShift = spanRowShift;\n  var axisPixelShift = spanAxisPixelShift; // -----------[ 3. calculate current viewport axis offset ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n\n  var scrollblockAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockOffset = // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft; // currentViewportAxisOffset will be negative (above viewport edge) for scroll block headward \n  //     and positive for scroll block tailward\n  // the pixel distance between the viewport frame and the axis, toward the head\n\n  var currentViewportAxisOffset = scrollblockAxisOffset + scrollblockOffset - scrollPos; // -------------[ 4. calculate new axis pixel position ]------------------\n\n  var newAxisViewportPixelOffset = currentViewportAxisOffset + axisPixelShift; // Note: sections 5, 6 and 7 deal entirely with row calculations; no pixels\n  // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n\n  var cradleReferenceRowshift = axisReferenceRowShift; // base values\n\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowShift; // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n\n  var listEndrowOffset = listRowcount - 1;\n\n  if (shiftinstruction == 'axistailward') {\n    // scrolling toward head\n    // a. if scrolling the block headward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling the block headward (revealing tail of list), as the cradle last row offset \n    // approaches max listrow, new cradle offset and cradle row shift have to be adjusted to prevent \n    // shortening of cradle content.\n    // --- start of list adjustment\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1); // extra row for visibility\n\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    } // --- end of list adjustment: case of being in bounds of trailing runway (end of list)\n\n\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n\n    if (tailrowdiff > 0) {\n      newCradleReferenceRowOffset -= tailrowdiff;\n      cradleReferenceRowshift -= tailrowdiff;\n      targetCradleEndrowOffset -= tailrowdiff;\n    }\n  } else {\n    // shiftinstruction == 'axisheadward'; scrolling toward tail \n    // c. if scrolling the block tailward (toward revealing head of list), as the cradlerowoffset \n    // hits 0, cradle changes have to be adjusted to prevent shortening of cradle content\n    // d. if scrolling headward near the end of the list, cradle changes have to be adjusted to \n    // accomodate the trailing runway\n    // --- start of list adjustment\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    } // --- end of list adjustment; case of in bounds of trailing runway\n\n\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n\n    var _targetCradleEndrowOffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n\n    var _tailrowdiff = Math.max(0, _targetCradleEndrowOffset - computedNextCradleEndrowOffset);\n\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset += _tailrowdiff;\n    }\n  } // ----------------------[ 7. map rows to item references ]----------------------\n\n\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowShift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  } // create head and tail change counts\n\n\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount; // ---------------------[ 8. return required values ]-------------------\n\n  return {\n    newCradleReferenceIndex: newCradleReferenceIndex,\n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisViewportPixelOffset: newAxisViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\n\nexports.calcContentShift = calcContentShift; // supports calcContentShift above\n\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n\n  return rowLengths;\n}; // supports calcContentShift above\n\n\nvar getGridRowSpans = function getGridRowSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n}; // =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\n\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n      cradleInternalProperties = _ref4.cradleInternalProperties,\n      cacheHandler = _ref4.cacheHandler,\n      cradleContentCount = _ref4.cradleContentCount,\n      cradleReferenceIndex = _ref4.cradleReferenceIndex,\n      listStartChangeCount = _ref4.listStartChangeCount,\n      listEndChangeCount = _ref4.listEndChangeCount,\n      contentlist = _ref4.workingContentList,\n      instanceIdCounterRef = _ref4.instanceIdCounterRef,\n      styles = _ref4.styles;\n\n  var localContentlist = _toConsumableArray(contentlist);\n\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n      tailContentlist = [];\n  var deletedtailitems = [],\n      deletedheaditems = [];\n\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    for (var newindex = cradleReferenceIndex - listStartChangeCount; newindex < cradleReferenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderContentStyles: styles.placeholdercontent\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    for (var _newindex = lastindexoffset + 1; _newindex < lastindexoffset + 1 + listEndChangeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderContentStyles: styles.placeholdercontent\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\n\nexports.getCellFrameComponentList = getCellFrameComponentList; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n      axisReferenceIndex = _ref5.axisReferenceIndex,\n      layoutHandler = _ref5.layoutHandler;\n\n  var _a;\n\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index,\n      highindex = offsetindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n\n  if (triggercellIndex !== undefined && offsetindex !== undefined) {\n    //&& \n    // (triggercellIndex != targetTriggercellIndex)) {\n    if (triggercellIndex >= offsetindex && triggercellIndex <= highindex) {\n      var _triggercellPtr = triggercellIndex - offsetindex;\n\n      var _triggercellComponent = contentlist[_triggercellPtr];\n\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n\n  var triggercellPtr = targetTriggercellIndex - offsetindex;\n  var triggercellComponent = contentlist[triggercellPtr]; // if !triggercellComponent, is temporarily out of scope; will recycle\n\n  if (triggercellComponent) {\n    // && ((triggercellIndex === undefined) || \n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    // defensive\n    console.log('FAILURE TO REGISTER TRIGGERCELL: \\n', 'triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent?.props.isTriggecell\\n', triggercellComponent, triggercellIndex, targetTriggercellIndex, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell);\n  }\n\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\n\nexports.allocateContentList = allocateContentList;\n\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\n\nexports.deletePortals = deletePortals; // =====================[ internal, acquire item ]======================\n\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n      cradleInheritedProperties = _ref6.cradleInheritedProperties,\n      cradleInternalProperties = _ref6.cradleInternalProperties,\n      instanceIdCounterRef = _ref6.instanceIdCounterRef,\n      cacheHandler = _ref6.cacheHandler,\n      placeholderFrameStyles = _ref6.placeholderFrameStyles,\n      placeholderContentStyles = _ref6.placeholderContentStyles;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      cellMinHeight = cradleInheritedProperties.cellMinHeight,\n      cellMinWidth = cradleInheritedProperties.cellMinWidth,\n      getItem = cradleInheritedProperties.getItem,\n      placeholder = cradleInheritedProperties.placeholder,\n      scrollerID = cradleInheritedProperties.scrollerID,\n      layout = cradleInheritedProperties.layout;\n  var listsize = cradleInternalProperties.listsize; // get new or existing itemID\n\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderContentStyles: placeholderContentStyles\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NvbnRlbnRmdW5jdGlvbnMudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBOztBQUVBLGtHLENBRUE7OztBQUVPLElBQU1BLDBCQUEwQixHQUFHLFNBQTdCQSwwQkFBNkIsT0FXakM7RUFBQSxJQVJEQyx3QkFRQyxRQVJEQSx3QkFRQztFQUFBLElBTkRDLGFBTUMsUUFOREEsYUFNQztFQUFBLElBTERDLDZCQUtDLFFBTERBLDZCQUtDO0VBQUEsSUFIREMseUJBR0MsUUFIREEseUJBR0M7RUFBQSxJQUZEQyx3QkFFQyxRQUZEQSx3QkFFQztFQUVMLElBQ0lDLE9BREosR0FFSUYseUJBRkosQ0FDSUUsT0FESjtFQUlBLElBRUlDLFVBRkosR0FTSUYsd0JBVEosQ0FFSUUsVUFGSjtFQUFBLElBR0lDLGNBSEosR0FTSUgsd0JBVEosQ0FHSUcsY0FISjtFQUFBLElBSUlDLGNBSkosR0FTSUosd0JBVEosQ0FJSUksY0FKSjtFQUFBLElBS0lDLFlBTEosR0FTSUwsd0JBVEosQ0FLSUssWUFMSjtFQUFBLElBTUlDLFFBTkosR0FTSU4sd0JBVEosQ0FNSU0sUUFOSjtFQUFBLElBT0lDLHVCQVBKLEdBU0lQLHdCQVRKLENBT0lPLHVCQVBKLENBTkssQ0FpQkw7O0VBQ0FYLHdCQUF3QixHQUFHWSxJQUFJLENBQUNDLEdBQUwsQ0FBU2Isd0JBQVQsRUFBa0NVLFFBQVEsR0FBRyxDQUE3QyxDQUEzQjtFQUNBVix3QkFBd0IsSUFBS0Esd0JBQXdCLEdBQUdNLFVBQXhELENBbkJLLENBcUJMOztFQUNBLElBQUlRLG1CQUFtQixHQUFHRixJQUFJLENBQUNHLElBQUwsQ0FBVWYsd0JBQXdCLEdBQUNNLFVBQW5DLENBQTFCO0VBRUEsSUFBTVUsZ0JBQWdCLEdBQUdKLElBQUksQ0FBQ0ssR0FBTCxDQUFTLENBQVQsRUFBV1IsWUFBWSxHQUFHRSx1QkFBMUIsQ0FBekI7O0VBQ0Es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TSxRQUFSLENBakJDLENBbUJEOztFQUNBLElBQU1xTCxNQUFNLEdBQUd2RCxZQUFZLENBQUN3RCxzQkFBYixDQUFvQzlHLEtBQXBDLENBQWY7RUFFQSxPQUFPd0YsaUNBQUN1QixzQkFBRCxFQUFVO0lBQ2JDLEdBQUcsRUFBS1IsVUFESztJQUViOUosV0FBVyxFQUFLQSxXQUZIO0lBR2I2QixVQUFVLEVBQUtBLFVBSEY7SUFJYkMsU0FBUyxFQUFLQSxTQUpEO0lBS2JpSSxhQUFhLEVBQUtBLGFBTEw7SUFNYkMsWUFBWSxFQUFLQSxZQU5KO0lBT2JqSSxNQUFNLEVBQUtBLE1BUEU7SUFRYnVCLEtBQUssRUFBS0EsS0FSRztJQVNiMkcsT0FBTyxFQUFLQSxPQVRDO0lBVWJuTCxRQUFRLEVBQUtBLFFBVkE7SUFXYm9MLFdBQVcsRUFBS0EsV0FYSDtJQVliQyxNQUFNLEVBQUtBLE1BWkU7SUFhYkwsVUFBVSxFQUFLQSxVQWJGO0lBY2IzSixVQUFVLEVBQUtBLFVBZEY7SUFlYjZJLGFBQWEsRUFBSyxLQWZMO0lBZ0JickIsc0JBQXNCLEVBQUtBLHNCQWhCZDtJQWlCYkUsd0JBQXdCLEVBQUtBO0VBakJoQixDQUFWLENBQVA7QUFvQkgsQ0FsREQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBjb250ZW50aGFuZGxlciBtb2R1bGUuIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgcGVyZm9ybVxuICAgIHRoZSBkZXRhaWxlZCBjYWxjdWxhdGlvbnMgYW5kIHByb2Nlc3NlcyByZXF1aXJlZCBieSB0aGUgY29udGVudGhhbmRsZXIuXG5cbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyBpcyBjYWxsZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyJ3Mgc2V0Q3JhZGxlQ29udGVudCBmdW5jdGlvbi5cblxuICAgIGdldFNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93TGVuZ3RoLFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcbiAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuICAgIFxuICAgIC8vIGFsaWduIGF4aXMgcmVmZXJlbmNlIHRvIGZpcnN0IHJvdyBpdGVtXG4gICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4odGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LGxpc3RzaXplIC0gMSlcbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggLT0gKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnQpXG5cbiAgICAvLyBkZXJpdmUgdGFyZ2V0IHJvd1xuICAgIGxldCB0YXJnZXRBeGlzUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuXG4gICAgY29uc3QgbWF4QXhpc1Jvd09mZnNldCA9IE1hdGgubWF4KDAsbGlzdFJvd2NvdW50IC0gdmlld3BvcnRWaXNpYmxlUm93Y291bnQpXG4gICAgaWYgKHRhcmdldEF4aXNSb3dPZmZzZXQgPiBtYXhBeGlzUm93T2Zmc2V0KSB7XG4gICAgICAgIHRhcmdldEF4aXNSb3dPZmZzZXQgPSBtYXhBeGlzUm93T2Zmc2V0XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IHRhcmdldEF4aXNSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3JhZGxlUmVmZXJlbmNlUm93ICYgSW5kZXggXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gbGVhZGluZyBlZGdlXG4gICAgbGV0IHRhcmdldENyYWRsZVJvd09mZnNldCA9IE1hdGgubWF4KDAsdGFyZ2V0QXhpc1Jvd09mZnNldCAtIHJ1bndheVJvd2NvdW50KVxuXG4gICAgLy8gdHJhaWxpbmcgZWRnZVxuICAgIGxldCB0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPSB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuXG4gICAgY29uc3QgbGlzdEVuZFJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuXG4gICAgaWYgKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA+IChsaXN0RW5kUm93T2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBkaWZmID0gKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCAtIGxpc3RFbmRSb3dPZmZzZXQpXG4gICAgICAgIHRhcmdldENyYWRsZVJvd09mZnNldCAtPSBkaWZmXG4gICAgICAgIHRhcmdldENyYWRsZUVuZFJvd09mZnNldCAtPSBkaWZmXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3JhZGxlIGNvbnRlbnQgY291bnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IG5ld0NyYWRsZUNvbnRlbnRDb3VudCA9IGNyYWRsZVJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgIGlmICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPT0gbGlzdEVuZFJvd09mZnNldCkge1xuICAgICAgICBjb25zdCBlbmRSb3dSZW1haW5kZXJDb3VudCA9IGxpc3RzaXplICUgY3Jvc3Njb3VudFxuICAgICAgICBpZiAoZW5kUm93UmVtYWluZGVyQ291bnQpIHtcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSAoY3Jvc3Njb3VudCAtIGVuZFJvd1JlbWFpbmRlckNvdW50KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3NzIHBvc2l0aW9uaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gXG4gICAgICAgICh0YXJnZXRBeGlzUm93T2Zmc2V0ICogYmFzZVJvd0xlbmd0aCkgKyBwYWRkaW5nIC0gdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHJldHVybiByZXF1aXJlZCB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgIHRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCwgXG4gICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCwgXG4gICAgfSBcblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3IgdXBkYXRlQ3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qXG5cbiAgICB0aGUgdHdvIHRyaWdnZXJsaW5lcyBtdXN0IHN0cmFkZGxlIHRoZSBoZWFkIG9mIHRoZSB2aWV3cG9ydCAodG9wIG9yIGxlZnQpIHNvIHRoYXRcbiAgICBjcmFkbGUgbW90aW9uIGNhbiBiZSBkZXRlY3RlZC4gTW90aW9uIGlzIG1vc3Qgb2Z0ZW4gY2F1c2VkIGJ5IHNjcm9sbGluZywgYnV0XG4gICAgY2FuIGFsc28gb2NjdXIgd2l0aCBjaGFuZ2Ugb2Ygc2l6ZSBvZiBjcmFkbGUgY29udGVudCByb3dzLlxuXG4gICAgZ2V0U2hpZnRJbnN0cnVjdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGF4aXMgc2hvdWxkIGJlIG1vdmVkIHRvd2FyZCB0aGUgaGVhZCBvciB0YWlsXG4gICAgICAgIHRvIHJlc3RvcmUgdGhlIHN0cmFkZGxpbmcgcG9zaXRpb24gb2YgdGhlIHR3byB0cmlnZ2VyIGxpbmVzLiBMb3RzIG9mIHJlbGF0aXZlIG1vdGlvbi5cblxuICAgICdheGlzaGVhZHdhcmQnIChzY3JvbGxpbmcgZG93biBvciByaWdodCkgbWVhbnMgbW92aW5nIHRoZSBheGlzIHVwIG9yIGxlZnQsIGFkamFjZW50IGl0ZW1zIGRvd25cbiAgICAgICAgIG9yIHJpZ2h0IHRvIHRoZSB0YWlsLCBkcm9wcGluZyB0cmFpbGluZyB0YWlsIGl0ZW1zLCBhbmQgYWRkaW5nIGxlYWRpbmcgaGVhZCBpdGVtcyBhcyBuZWNlc3NhcnlcbiAgICAgICAgIHRvIG1haW50YWluIG51bWJlciBvZiBjcmFkbGUgcm93cyBvZiBjb250ZW50IGNvbnN0YW50LlxuXG4gICAgJ2F4aXN0YWlsd2FyZCcgKHNjcm9sbGluZyB1cCBvciBsZWZ0KSBtZWFucyBtb3ZpbmcgdGhlIGF4aXMgZG93biBvciByaWdodCwgYWRqYWNlbnQgaXRlbXMgdXBcbiAgICAgICAgIG9yIGxlZnQgdG8gdGhlIGhlYWQsIGRyb3BwaW5nIHRyYWlsaW5nIGhlYWQgaXRlbXMsIGFuZCBhZGRpbmcgbGVhZGluZyB0YWlsIGl0ZW1zIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgdG8gbWFpbnRhaW4gbnVtYmVyIG9mIGNyYWRsZSByb3dzIG9mIGNvbnRlbnQgY29uc3RhbnQuXG5cbiAgICAnbm9uZScgbWVhbnMgbm8gc2hpZnQgaXMgcmVxdWlyZWRcblxuKi9cblxuZXhwb3J0IGNvbnN0IGdldFNoaWZ0SW5zdHJ1Y3Rpb24gPSAoe1xuXG4gICAgb3JpZW50YXRpb24sXG4gICAgdHJpZ2dlcmxpbmVFbnRyaWVzLFxuICAgIHRyaWdnZXJsaW5lU3BhbixcbiAgICBzY3JvbGxlcklELCAvLyBmb3IgZGVidWdcbiAgICBcbiAgICAvLyBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZyBpcyB0cnVlIGlmIHRoZSB0cmlnZ2VybGluZXMgYXJlIHdpdGggdGhlIGZpcnN0IHRhaWwgcm93IGluc3RlYWQgb2YgdGhlXG4gICAgLy8gbGFzdCBoZWFkcm93LiBUaGF0IGhhcHBlbnMgKHdvcmthcm91bmQpIHdoZW4gdGhlcmUgYXJlIG5vIGhlYWQgcm93c1xuICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnLCBcblxufSkgPT4ge1xuXG4gICAgY29uc3QgdHJpZ2dlckRhdGEgPSB7XG4gICAgICAgIGhlYWRPZmZzZXQ6bnVsbCxcbiAgICAgICAgdGFpbE9mZnNldDpudWxsLFxuICAgICAgICBzcGFuOnRyaWdnZXJsaW5lU3BhbixcbiAgICAgICAgaXNGaXJzdFJvd1RyaWdnZXJDb25maWdcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyeSA9IHRyaWdnZXJsaW5lRW50cmllcy5hdCgtMSkgLy8gbW9zdCByZWNlbnQ7IGVpdGhlciB0cmlnZ2VybGluZSB3aWxsIGRvXG4gICAgY29uc3QgcmVmZXJlbmNlbmFtZSA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGVcbiAgICBjb25zdCBzcGFuID0gdHJpZ2dlcmxpbmVTcGFuXG5cbiAgICBjb25zdCByb290cG9zID0gXG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIGVudHJ5LnJvb3RCb3VuZHMueTpcbiAgICAgICAgICAgIGVudHJ5LnJvb3RCb3VuZHMueFxuXG4gICAgY29uc3QgZW50cnlwb3MgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0Lnk6XG4gICAgICAgICAgICBlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3QueFxuXG4gICAgY29uc3Qgdmlld3BvcnRUcmlnZ2VyT2Zmc2V0ID0gZW50cnlwb3MgLSByb290cG9zXG5cbiAgICBpZiAocmVmZXJlbmNlbmFtZSA9PSAnaGVhZHRyaWdnZXInKSB7XG5cbiAgICAgICAgdHJpZ2dlckRhdGEuaGVhZE9mZnNldCA9IHZpZXdwb3J0VHJpZ2dlck9mZnNldFxuICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0ID0gdmlld3BvcnRUcmlnZ2VyT2Zmc2V0ICsgc3BhblxuXG4gICAgfSBlbHNlIHsgLy8gdGFpbHRyaWdnZXJcblxuICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0ID0gdmlld3BvcnRUcmlnZ2VyT2Zmc2V0XG4gICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgLSBzcGFuXG5cbiAgICB9XG5cbiAgICBsZXQgc2hpZnRpbnN0cnVjdGlvblxuICAgIFxuICAgIGlmIChpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZykge1xuXG4gICAgICAgIGlmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0IDw9IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdheGlzdGFpbHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPD0gMCkge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ2F4aXN0YWlsd2FyZCdcblxuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPj0gMCkge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ2F4aXNoZWFkd2FyZCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ25vbmUnXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFtzaGlmdGluc3RydWN0aW9uLCB0cmlnZ2VyRGF0YV1cblxufVxuXG4vKlxuXG4gICAgVGhlIGJhc2ljIGdvYWwgaGVyZSBpcyB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBhbmQgZGlyZWN0aW9uIG9mIHJvd3MgdG8gc2hpZnQgYmV0d2VlblxuICAgIHRoZSBoZWFkIGFuZCB0YWlsIGdyaWRzICh3aGljaCBkdGVybWluZXMgdGhlIG5ldyBsb2NhdGlvbiBvZiB0aGUgYXhpcyksIGFuZCBhbHNvIHRvXG4gICAgY2FsY3VsYXRlIHRoZSByb2xsaW5nIGFkZGl0aW9uIGFuZCBkZWxldGlvbiBvZiBjcmFkbGUgY29udGVudCB0byBhY2NvbW1vZGF0ZSB0aGUgY2hhbmdlcy5cblxuICAgIFRoZSBudW1iZXIgb2Ygcm93cyB0byBzaGlmdCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwaXhlbCBzaGlmdCByZXF1aXJlZCB0byByZXN0b3JlIHRoZSBcbiAgICB0cmlnZ2VybGluZXMgdG8gdGhlaXIgc3RyYWRkbGUgY29uZmlndXJhdGlvbiBhcm91bmQgdGhlIGhlYWQgKHRvcCBvciBsZWZ0KSBvZiB0aGUgdmlld3BvcnQuXG5cbiAgICBBZGp1c3RtZW50cyBhcmUgbWFkZSB0byBhY2NvbW1vZGF0ZSBzcGVjaWFsIHJlcXVpcmVtZW50cyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgdmlydHVhbCBsaXN0LlxuXG4gICAgRE9NIG1lYXN1cmVtZW50cyBhcmUgdXNlZCB3aGVyZSBhdmFpbGFibGUgKHRvIGFjY29tbW9kYXRlIHZhcmlhYmxlIGRpbWVuc2lvbiByb3dzKSwgYW5kIHN0YW5kYXJkXG4gICAgdW5pdHMgKGNlbGxIZWlnaHQsIGNlbGxXaWR0aCkgdXNlZCB3aGVyZSBuZWNlc3NhcnkuXG5cbiovXG5cbi8vIHJvd3NoaWZ0IGlzIGF0IGxlYXN0IDEgYnkgdGhlIHRpbWUgdGhpcyBmdW5jdGlvbiBpcyByZWFjaGVkXG4vLyBpZS4gYSBzaGlmdGluc3RydWN0aW9uIG9mICdheGlzaGVhZHdhcmQnIG9yICdheGlzdGFpbHdhcmQnXG5leHBvcnQgY29uc3QgY2FsY0NvbnRlbnRTaGlmdCA9ICh7XG5cbiAgICBzaGlmdGluc3RydWN0aW9uLFxuICAgIHRyaWdnZXJEYXRhLFxuICAgIHNjcm9sbFBvcyxcbiAgICBzY3JvbGxibG9ja0VsZW1lbnQsXG5cbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICBjcmFkbGVDb250ZW50LFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7IFxuXG4gICAgICAgIGdhcCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50LFxuICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudFxuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czpjcmFkbGVjb250ZW50bGlzdCwgXG4gICAgICAgIHRhaWxNb2RlbENvbXBvbmVudHM6dGFpbGNvbnRlbnRsaXN0LFxuXG4gICAgfSA9IGNyYWRsZUNvbnRlbnRcblxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgY29uc3QgcmVmZXJlbmNlR3JpZEVsZW1lbnQgPSAvLyBtb3ZpbmcgYXhpcyAoYW5kIHRyaWdnZXJzKSB0b3dhcmQgdGhlIHJlZmVyZW5jZSBncmlkIGVsZW1lbnRcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpPyAvLyBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICAgICAgdGFpbEdyaWRFbGVtZW50OlxuICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50XG5cbiAgICBjb25zdCBncmlkUm93TGVuZ3RocyA9IGdldEdyaWRSb3dMZW5ndGhzKHJlZmVyZW5jZUdyaWRFbGVtZW50LCBvcmllbnRhdGlvbiwgY3Jvc3Njb3VudCwgZ2FwKVxuXG4gICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXNoZWFkd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIGRvd24gb3IgcmlnaHQ7IG1vdmUgdHJpZ2dlcmxpbmVzIHVwIG9yIGxlZnRcblxuICAgICAgICBncmlkUm93TGVuZ3Rocy5yZXZlcnNlKCkgLy8gaGVhZCByb3cgbGVuZ3RocyBsaXN0ZWQgZnJvbSBheGlzIHRvd2FyZCBoZWFkXG5cbiAgICB9XG5cbiAgICBjb25zdCBncmlkUm93U3BhbnMgPSBnZXRHcmlkUm93U3BhbnMoZ3JpZFJvd0xlbmd0aHMpXG5cbiAgICBjb25zdCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgPSBcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpPyAvLyBibG9jayBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICB0cmlnZ2VyRGF0YS50YWlsT2Zmc2V0OiAvLyBuZWVkcyB0byBtb3ZlIGRvd24gb3IgcmlnaHQgdG93YXJkIHRhaWxcbiAgICAgICAgdHJpZ2dlckRhdGEuaGVhZE9mZnNldCAvLyBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdG93YXJkIGhlYWRcblxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAoY3JhZGxlY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0NyYWRsZVJvd09mZnNldCA9IE1hdGguY2VpbChwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCA9ICh0YWlsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApLFxuICAgICAgICBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGNhbGN1bGF0ZSBiYXNlIHJvdyBzaGlmdCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBzcGFuUm93UHRyXG4gICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsIHVwXG5cbiAgICAgICAgLy8gdGFpbCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBwb3NpdGl2ZVxuICAgICAgICBzcGFuUm93UHRyID0gZ3JpZFJvd1NwYW5zLmZpbmRJbmRleCgobW92ZW1lbnRzcGFuKSA9PiBcbiAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgKyBtb3ZlbWVudHNwYW4pID49IDAgKVxuICAgIFxuICAgIH0gZWxzZSB7IC8vICdheGlzaGVhZHdhcmQnLCBzY3JvbGxkb3duXG5cbiAgICAgICAgLy8gaGVhZCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgdXAgb3IgbGVmdCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBuZWdhdGl2ZVxuICAgICAgICBzcGFuUm93UHRyID0gZ3JpZFJvd1NwYW5zLmZpbmRJbmRleCgobW92ZW1lbnRzcGFuKSA9PiBcbiAgICAgICAgICAgICh0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MgLSBtb3ZlbWVudHNwYW4pIDw9IDAgKVxuXG4gICAgfVxuXG4gICAgbGV0IHNwYW5BeGlzUGl4ZWxTaGlmdCAvLyBpbiByZWxhdGlvbiB0byB2aWV3cG9ydCBoZWFkIGJvdW5kYXJ5XG4gICAgaWYgKHNwYW5Sb3dQdHIgPT0gLTEgKSB7IC8vIG92ZXJzaG9vdCBvZiBpbnN0YW50aWF0ZWQgcm93czsgY29udGludWUgd2l0aCB2aXJ0dWFsIHJvd3NcblxuICAgICAgICBsZXQgbm90aW9uYWxSb3dQdHJcbiAgICAgICAgaWYgKGdyaWRSb3dTcGFucy5sZW5ndGggPT0gMCkgeyAvLyBtdXN0IGJlIGxpc3QgYm91bmRhcnlcblxuICAgICAgICAgICAgLy8gbm90aW9uYWxSb3dQdHIgPSAwXG4gICAgICAgICAgICBub3Rpb25hbFJvd1B0ciA9IC0xIC8vIFwibm90IGZvdW5kXCJcbiAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IDBcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFzZVJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoKSBcbiAgICAgICAgICAgICAgICArIGdhcFxuXG4gICAgICAgICAgICBub3Rpb25hbFJvd1B0ciA9IGdyaWRSb3dTcGFucy5sZW5ndGggLSAxIC8vIGJhc2U6IGZhaWxlZCBtZWFzdXJlZCByb3cgcHRyXG4gICAgICAgICAgICBsZXQgdG90YWxQaXhlbFNoaWZ0ID0gZ3JpZFJvd1NwYW5zW25vdGlvbmFsUm93UHRyXSAvLyBzZXQgYmFzZSBvZiB3b3JraW5nIG92ZXJzaG9vdFxuXG4gICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGxpbmcgdXBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uYWxSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBvcyArIHRvdGFsUGl4ZWxTaGlmdCkgPCAwKSBcblxuICAgICAgICAgICAgICAgIHNwYW5BeGlzUGl4ZWxTaGlmdCA9IHRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBheGlzaGVhZHdhcmQ7IHNjcm9sbGluZyBkb3duXG5cbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ICs9IGJhc2VSb3dMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uYWxSb3dQdHIrK1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJldmlvdXNBeGlzUm93T2Zmc2V0IC0gKG5vdGlvbmFsUm93UHRyICsgMSkpIDwgMCkgeyAvLyBzdG9wIGN5Y2xpbmcgYXQgaGVhZCBsaW1pdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjb21tb2RhdGUgaXNGaXJzdFJvd1RyaWdnZXJDb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlvbmFsUm93UHRyIC09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCAtPSBiYXNlUm93TGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUG9zIC0gdG90YWxQaXhlbFNoaWZ0KSA+IDApXG5cbiAgICAgICAgICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSAtdG90YWxQaXhlbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgc3BhblJvd1B0ciA9IG5vdGlvbmFsUm93UHRyXG5cbiAgICB9IGVsc2UgeyAvLyBmaW5hbCB2YWx1ZXMgZm91bmQgaW4gaW5zdGFudGlhdGVkIHJvd3NcblxuICAgICAgICBzcGFuQXhpc1BpeGVsU2hpZnQgPSBcbiAgICAgICAgICAgIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzdGFpbHdhcmQnKT9cbiAgICAgICAgICAgICAgICBncmlkUm93U3BhbnNbc3BhblJvd1B0cl06IC8vIG1vdmUgYXhpcyB0b3dhcmQgdGFpbCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5IChwb3NpdGl2ZSlcbiAgICAgICAgICAgICAgICAtZ3JpZFJvd1NwYW5zW3NwYW5Sb3dQdHJdIC8vIG1vdmUgYXhpcyB0b3dhcmQgaGVhZCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5IChuZWdhdGl2ZSlcblxuICAgIH1cblxuICAgIGNvbnN0IHNwYW5Sb3dTaGlmdCA9IC8vIHBpY2sgdXAgcm93IHNoaWZ0IHdpdGggb3Igd2l0aG91dCBvdmVyc2hvb3RcbiAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ2F4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgc3BhblJvd1B0ciArIDE6XG4gICAgICAgICAgICAtKHNwYW5Sb3dQdHIgKyAxKVxuXG4gICAgLy8gdGhlIGZvbGxvd2luZyB0d28gdmFsdWVzLCBhbmQgbm8gb3RoZXIgY2FsY3MsIGFyZSBjYXJyaWVkIGZvcndhcmQgaW4gdGhlIGZ1bmN0aW9uLlxuICAgIC8vIGZvciBheGlzUmVmZXJlbmNlUm93c2hpZnQ6XG4gICAgLy8gbmVnYXRpdmUgZm9yIG1vdmluZyByb3dzIG91dCBvZiBoZWFkIGludG8gdGFpbDtcbiAgICAvLyBwb3NpdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIHRhaWwgaW50byBoZWFkXG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0ID0gc3BhblJvd1NoaWZ0XG4gICAgY29uc3QgYXhpc1BpeGVsU2hpZnQgPSBzcGFuQXhpc1BpeGVsU2hpZnQgXG5cbiAgICAvLyAtLS0tLS0tLS0tLVsgMy4gY2FsY3VsYXRlIGN1cnJlbnQgdmlld3BvcnQgYXhpcyBvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnYXBzIGJleW9uZCByZW5kZXJlZCByb3dzIGNhbiBiZSBjYXVzZWQgYnkgcmFwaWQgc2Nyb2xsaW5nXG5cbiAgICBjb25zdCBzY3JvbGxibG9ja0F4aXNPZmZzZXQgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgY29uc3Qgc2Nyb2xsYmxvY2tPZmZzZXQgPSAvLyB0byBjYXB0dXJlIGN1cnJlbnQgdG9wL2xlZnQgYWRqdXN0bWVudCB0byB2aWV3cG9ydCBmb3IgdmFyaWFibGUgbGF5b3V0XG4gICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgLy8gY3VycmVudFZpZXdwb3J0QXhpc09mZnNldCB3aWxsIGJlIG5lZ2F0aXZlIChhYm92ZSB2aWV3cG9ydCBlZGdlKSBmb3Igc2Nyb2xsIGJsb2NrIGhlYWR3YXJkIFxuICAgIC8vICAgICBhbmQgcG9zaXRpdmUgZm9yIHNjcm9sbCBibG9jayB0YWlsd2FyZFxuICAgIC8vIHRoZSBwaXhlbCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB2aWV3cG9ydCBmcmFtZSBhbmQgdGhlIGF4aXMsIHRvd2FyZCB0aGUgaGVhZFxuICAgIGNvbnN0IGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgPSBcbiAgICAgICAgc2Nyb2xsYmxvY2tBeGlzT2Zmc2V0ICsgc2Nyb2xsYmxvY2tPZmZzZXQgLSBzY3JvbGxQb3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS1bIDQuIGNhbGN1bGF0ZSBuZXcgYXhpcyBwaXhlbCBwb3NpdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgKyBheGlzUGl4ZWxTaGlmdFxuXG4gICAgLy8gTm90ZTogc2VjdGlvbnMgNSwgNiBhbmQgNyBkZWFsIGVudGlyZWx5IHdpdGggcm93IGNhbGN1bGF0aW9uczsgbm8gcGl4ZWxzXG5cbiAgICAvLyAtLS0tLS0tLS0tLS1bIDUuIGNhbGMgbmV3IGNyYWRsZSBhbmQgYXhpcyByZWZlcmVuY2Ugcm93IG9mZnNldHMgXS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJhc2UgdmFsdWUgZm9yIGNyYWRsZSByZWZlcmVuY2Ugc2hpZnQ7IG1heSBjaGFuZ2UgaWYgYmV5b25kIGxpc3QgYm91bmRzXG4gICAgbGV0IGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ID0gYXhpc1JlZmVyZW5jZVJvd1NoaWZ0XG5cbiAgICAvLyBiYXNlIHZhbHVlc1xuICAgIGxldCBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBwcmV2aW91c0NyYWRsZVJvd09mZnNldCArIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0XG4gICAgbGV0IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgPSBwcmV2aW91c0F4aXNSb3dPZmZzZXQgKyBheGlzUmVmZXJlbmNlUm93U2hpZnRcblxuICAgIC8vIC0tLS0tLS0tWyA2LiBhZGp1c3QgY3JhZGxlIGNvbnRlbnRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGxpc3QgXS0tLS0tLS1cbiAgICAvLyAuLi50byBtYWludGFpbiBjb25zdGFudCBudW1iZXIgb2YgY3JhZGxlIHJvd3NcblxuICAgIGNvbnN0IGxpc3RFbmRyb3dPZmZzZXQgPSAobGlzdFJvd2NvdW50IC0gMSlcblxuICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdheGlzdGFpbHdhcmQnKSB7IC8vIHNjcm9sbGluZyB0b3dhcmQgaGVhZFxuXG4gICAgICAgIC8vIGEuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgaGVhZHdhcmQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIG5ldyBjcmFkbGUgcm93IG9mZnNldCBhbmRcbiAgICAgICAgLy8gY3JhZGxlIHJvdyBzaGlmdCBjb3VudCBoYXMgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxlYWRpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gYi4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayBoZWFkd2FyZCAocmV2ZWFsaW5nIHRhaWwgb2YgbGlzdCksIGFzIHRoZSBjcmFkbGUgbGFzdCByb3cgb2Zmc2V0IFxuICAgICAgICAvLyBhcHByb2FjaGVzIG1heCBsaXN0cm93LCBuZXcgY3JhZGxlIG9mZnNldCBhbmQgY3JhZGxlIHJvdyBzaGlmdCBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgXG4gICAgICAgIC8vIHNob3J0ZW5pbmcgb2YgY3JhZGxlIGNvbnRlbnQuXG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0IC0gcnVud2F5Um93Y291bnQgLSAxKSkgLy8gZXh0cmEgcm93IGZvciB2aXNpYmlsaXR5XG5cbiAgICAgICAgY29uc3QgaGVhZHJvd0RpZmYgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgaWYgKGhlYWRyb3dEaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gaGVhZHJvd0RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IGhlYWRyb3dEaWZmXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OiBjYXNlIG9mIGJlaW5nIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXkgKGVuZCBvZiBsaXN0KVxuICAgICAgICBsZXQgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGxpc3RFbmRyb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBzaGlmdGluc3RydWN0aW9uID09ICdheGlzaGVhZHdhcmQnOyBzY3JvbGxpbmcgdG93YXJkIHRhaWwgXG5cbiAgICAgICAgLy8gYy4gaWYgc2Nyb2xsaW5nIHRoZSBibG9jayB0YWlsd2FyZCAodG93YXJkIHJldmVhbGluZyBoZWFkIG9mIGxpc3QpLCBhcyB0aGUgY3JhZGxlcm93b2Zmc2V0IFxuICAgICAgICAvLyBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmUgdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICAgICAgLy8gZC4gaWYgc2Nyb2xsaW5nIGhlYWR3YXJkIG5lYXIgdGhlIGVuZCBvZiB0aGUgbGlzdCwgY3JhZGxlIGNoYW5nZXMgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBcbiAgICAgICAgLy8gYWNjb21vZGF0ZSB0aGUgdHJhaWxpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IDBcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tIGVuZCBvZiBsaXN0IGFkanVzdG1lbnQ7IGNhc2Ugb2YgaW4gYm91bmRzIG9mIHRyYWlsaW5nIHJ1bndheVxuICAgICAgICBjb25zdCBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQgPSBcbiAgICAgICAgICAgIChwcmV2aW91c0NyYWRsZVJvd09mZnNldCArIChjcmFkbGVSb3djb3VudCAtMSkgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdClcblxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBNYXRoLm1pbihsaXN0RW5kcm93T2Zmc2V0LCBcbiAgICAgICAgICAgIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpKSlcblxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsIHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldClcblxuICAgICAgICBpZiAodGFpbHJvd2RpZmYgPiAwKSB7XG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICs9IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKz0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA3LiBtYXAgcm93cyB0byBpdGVtIHJlZmVyZW5jZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCAqIGNyb3NzY291bnQpXG4gICAgY29uc3QgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0ID0gKGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ICogY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IG5ld0F4aXNSZWZlcmVuY2VJbmRleCA9IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG4gICAgY29uc3QgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCA9IGF4aXNSZWZlcmVuY2VSb3dTaGlmdCAqIGNyb3NzY291bnRcblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnQgLy8gYmFzZSBjb3VudFxuICAgIGNvbnN0IGluY2x1ZGVzTGFzdFJvdyA9ICgobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICsgY3JhZGxlUm93Y291bnQpID49IGxpc3RSb3djb3VudClcbiAgICBpZiAoaW5jbHVkZXNMYXN0Um93KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxzcGFjZXMgPSBsaXN0c2l6ZSAlIGNyb3NzY291bnRcbiAgICAgICAgY29uc3QgaXRlbXNTaG9ydGZhbGwgPSBcbiAgICAgICAgICAgIChwYXJ0aWFsc3BhY2VzID09IDApP1xuICAgICAgICAgICAgICAgIDA6XG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCAtIHBhcnRpYWxzcGFjZXNcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IGl0ZW1zU2hvcnRmYWxsXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGhlYWQgYW5kIHRhaWwgY2hhbmdlIGNvdW50c1xuICAgIGNvbnN0IGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlY29udGVudGxpc3QubGVuZ3RoIC0gbmV3Q3JhZGxlQ29udGVudENvdW50XG5cbiAgICBjb25zdCBsaXN0U3RhcnRDaGFuZ2VDb3VudCA9IC0oY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0KVxuICAgIGNvbnN0IGxpc3RFbmRDaGFuZ2VDb3VudCA9IC1saXN0U3RhcnRDaGFuZ2VDb3VudCAtIGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDguIHJldHVybiByZXF1aXJlZCB2YWx1ZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQsIFxuICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBheGlzUmVmZXJlbmNlSXRlbVNoaWZ0LCBcblxuICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnRcbiAgICB9XG5cbn1cblxuLy8gc3VwcG9ydHMgY2FsY0NvbnRlbnRTaGlmdCBhYm92ZVxuY29uc3QgZ2V0R3JpZFJvd0xlbmd0aHMgPSAoZ3JpZCwgb3JpZW50YXRpb24sIGNyb3NzY291bnQsIGdhcCkgPT4ge1xuXG4gICAgY29uc3Qgcm93TGVuZ3RocyA9IFtdXG4gICAgY29uc3QgZWxlbWVudExpc3QgPSBncmlkLmNoaWxkTm9kZXNcblxuICAgIGxldCBlbGVtZW50UHRyID0gMFxuICAgIGxldCBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJvd2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoKSBcbiAgICAgICAgICAgICsgZ2FwXG4gICAgICAgIHJvd0xlbmd0aHMucHVzaChyb3dsZW5ndGgpXG4gICAgICAgIGVsZW1lbnRQdHIgKz0gY3Jvc3Njb3VudFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudExpc3RbZWxlbWVudFB0cl1cbiAgICB9XG5cbiAgICByZXR1cm4gcm93TGVuZ3Roc1xufVxuXG4vLyBzdXBwb3J0cyBjYWxjQ29udGVudFNoaWZ0IGFib3ZlXG5jb25zdCBnZXRHcmlkUm93U3BhbnMgPSAocm93TGVuZ3RocykgPT4ge1xuXG4gICAgY29uc3Qgcm93U3BhbnMgPSBbXVxuICAgIGxldCBzcGFuID0gMFxuICAgIHJvd0xlbmd0aHMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgc3BhbiArPSB2YWx1ZVxuICAgICAgICByb3dTcGFucy5wdXNoKHNwYW4pXG4gICAgfSlcblxuICAgIHJldHVybiByb3dTcGFuc1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIHNoYXJlZCBieSBib3RoIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHVwZGF0ZSBjb250ZW50XG4vLyBhZGRzIGl0ZW1zaGVsbHMgYXQgZW5kIG9mIGNvbnRlbnRsaXN0IGFjY29yZGluZyB0byBoZWFkaW5kZXhjb3VudCBhbmQgdGFpbGluZGVzY291bnQsXG4vLyBvciBpZiBpbmRleGNvdW50IHZhbHVlcyBhcmUgPDAgcmVtb3ZlcyB0aGVtLlxuZXhwb3J0IGNvbnN0IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3QgPSAoeyBcblxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LCBcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LCBcbiAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0OmNvbnRlbnRsaXN0LFxuICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgc3R5bGVzLFxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgY29uc3QgbGFzdGluZGV4b2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggKyBsb2NhbENvbnRlbnRsaXN0Lmxlbmd0aCAtIDFcblxuICAgIGNvbnN0IGhlYWRDb250ZW50bGlzdCA9IFtdLCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgbGV0IGRlbGV0ZWR0YWlsaXRlbXMgPSBbXSwgZGVsZXRlZGhlYWRpdGVtcyA9IFtdXG5cbiAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggLSBsaXN0U3RhcnRDaGFuZ2VDb3VudDsgbmV3aW5kZXggPCAoY3JhZGxlUmVmZXJlbmNlSW5kZXgpOyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyQ29udGVudFN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZGVsZXRlZGhlYWRpdGVtcyA9IGxvY2FsQ29udGVudGxpc3Quc3BsaWNlKCAwLCAtbGlzdFN0YXJ0Q2hhbmdlQ291bnQgKVxuXG4gICAgfVxuXG4gICAgaWYgKGxpc3RFbmRDaGFuZ2VDb3VudCA+PSAwKSB7IC8vIGFjcXVpcmUgbmV3IGl0ZW1zXG5cbiAgICAgICAgZm9yIChsZXQgbmV3aW5kZXggPSBsYXN0aW5kZXhvZmZzZXQgKyAxOyBuZXdpbmRleCA8IChsYXN0aW5kZXhvZmZzZXQgKyAxICsgbGlzdEVuZENoYW5nZUNvdW50KTsgbmV3aW5kZXgrKykge1xuXG4gICAgICAgICAgICB0YWlsQ29udGVudGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVDZWxsRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Om5ld2luZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNvbnRlbnRTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbGV0ZWR0YWlsaXRlbXMgPSBsb2NhbENvbnRlbnRsaXN0LnNwbGljZShsaXN0RW5kQ2hhbmdlQ291bnQsLWxpc3RFbmRDaGFuZ2VDb3VudClcblxuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtcyA9IFsuLi5kZWxldGVkaGVhZGl0ZW1zLC4uLmRlbGV0ZWR0YWlsaXRlbXNdXG5cbiAgICBjb25zdCBjb21wb25lbnRMaXN0ID0gWy4uLmhlYWRDb250ZW50bGlzdCwuLi5sb2NhbENvbnRlbnRsaXN0LC4uLnRhaWxDb250ZW50bGlzdF1cblxuICAgIHJldHVybiBbY29tcG9uZW50TGlzdCxkZWxldGVkSXRlbXNdXG5cbn1cblxuLy8gYnV0dGVyZmx5IG1vZGVsLiBMZWFkaW5nIChoZWFkKSBhbGwgb3IgcGFydGlhbGx5IGhpZGRlbjsgdGFpbCwgdmlzaWJsZSBwbHVzIGZvbGxvd2luZyBoaWRkZW5cbmV4cG9ydCBjb25zdCBhbGxvY2F0ZUNvbnRlbnRMaXN0ID0gKFxuICAgIHtcblxuICAgICAgICBjb250ZW50bGlzdCwgLy8gb2YgY3JhZGxlLCBpbiBpdGVtcyAoUmVhY3QgY29tcG9uZW50cylcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCAvLyBmaXJzdCB0YWlsIGl0ZW1cbiAgICAgICAgbGF5b3V0SGFuZGxlcixcblxuICAgIH1cbikgPT4ge1xuXG4gICAgY29uc3QgeyB0cmlnZ2VyY2VsbEluZGV4IH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICBjb25zdCBvZmZzZXRpbmRleCA9IGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCxcbiAgICAgICAgaGlnaGluZGV4ID0gb2Zmc2V0aW5kZXggKyBjb250ZW50bGlzdC5sZW5ndGhcblxuICAgIGNvbnN0IGhlYWRpdGVtY291bnQgPSAoYXhpc1JlZmVyZW5jZUluZGV4IC0gb2Zmc2V0aW5kZXgpXG5cbiAgICBjb25zdCB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4ID0gXG4gICAgICAgIChoZWFkaXRlbWNvdW50ID09IDApP1xuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4OlxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4IC0gMVxuXG4gICAgbGF5b3V0SGFuZGxlci50cmlnZ2VyY2VsbElzSW5UYWlsID0gXG4gICAgICAgIChoZWFkaXRlbWNvdW50ID09IDApP1xuICAgICAgICAgICAgdHJ1ZTpcbiAgICAgICAgICAgIGZhbHNlXG5cbiAgICBpZiAoKHRyaWdnZXJjZWxsSW5kZXggIT09IHVuZGVmaW5lZCkgJiYgKG9mZnNldGluZGV4ICE9PSB1bmRlZmluZWQpKSB7IC8vJiYgXG4gICAgICAgLy8gKHRyaWdnZXJjZWxsSW5kZXggIT0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCkpIHtcbiAgICAgICAgaWYgKCh0cmlnZ2VyY2VsbEluZGV4ID49IG9mZnNldGluZGV4KSAmJiAodHJpZ2dlcmNlbGxJbmRleCA8PSBoaWdoaW5kZXgpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbFB0ciA9IHRyaWdnZXJjZWxsSW5kZXggLSBvZmZzZXRpbmRleFxuICAgICAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGxDb21wb25lbnQgPSBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyY2VsbENvbXBvbmVudCkgeyAvLyBvdGhlcndpc2UgaGFzIGJlZW4gYXN5bmNocm9ub3VzbHkgY2xlYXJlZFxuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXSA9IFJlYWN0LmNsb25lRWxlbWVudCh0cmlnZ2VyY2VsbENvbXBvbmVudCwge2lzVHJpZ2dlcmNlbGw6ZmFsc2V9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxQdHIgPSB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4IC0gb2Zmc2V0aW5kZXhcbiAgICBjb25zdCB0cmlnZ2VyY2VsbENvbXBvbmVudCA9IGNvbnRlbnRsaXN0W3RyaWdnZXJjZWxsUHRyXVxuICAgIC8vIGlmICF0cmlnZ2VyY2VsbENvbXBvbmVudCwgaXMgdGVtcG9yYXJpbHkgb3V0IG9mIHNjb3BlOyB3aWxsIHJlY3ljbGVcbiAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQpIHsvLyAmJiAoKHRyaWdnZXJjZWxsSW5kZXggPT09IHVuZGVmaW5lZCkgfHwgXG5cbiAgICAgICAgY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXJjZWxsQ29tcG9uZW50LCB7aXNUcmlnZ2VyY2VsbDp0cnVlfSlcbiAgICAgICAgbGF5b3V0SGFuZGxlci50cmlnZ2VyY2VsbEluZGV4ID0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleFxuXG4gICAgfSBlbHNlIHsgLy8gZGVmZW5zaXZlXG5cbiAgICAgICAgY29uc29sZS5sb2coJ0ZBSUxVUkUgVE8gUkVHSVNURVIgVFJJR0dFUkNFTEw6IFxcbicsXG4gICAgICAgICAgICAndHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsSW5kZXgsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXgsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGxcXG4nLCBcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsQ29tcG9uZW50LCB0cmlnZ2VyY2VsbEluZGV4LCB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4LCB0cmlnZ2VyY2VsbENvbXBvbmVudD8ucHJvcHMuaXNUcmlnZ2VjZWxsKVxuXG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGxpc3QgPSBjb250ZW50bGlzdC5zbGljZSgwLGhlYWRpdGVtY291bnQpXG4gICAgY29uc3QgdGFpbGxpc3QgPSBjb250ZW50bGlzdC5zbGljZShoZWFkaXRlbWNvdW50KVxuXG4gICAgcmV0dXJuIFsgaGVhZGxpc3QsIHRhaWxsaXN0IF1cblxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUG9ydGFscyA9IChjYWNoZUhhbmRsZXIsIGRlbGV0ZUxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaykgPT4ge1xuXG4gICAgY29uc3QgZGxpc3QgPSBkZWxldGVMaXN0Lm1hcCgoaXRlbSk9PntcblxuICAgICAgICByZXR1cm4gaXRlbS5wcm9wcy5pbmRleFxuICAgICAgICBcbiAgICB9KVxuXG4gICAgY2FjaGVIYW5kbGVyLmRlbGV0ZVBvcnRhbChkbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT1bIGludGVybmFsLCBhY3F1aXJlIGl0ZW0gXT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY3JlYXRlQ2VsbEZyYW1lID0gKHtcbiAgICBpbmRleCwgXG4gICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgY2FjaGVIYW5kbGVyLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzLFxufSkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlSUQgPSBpbnN0YW5jZUlkQ291bnRlclJlZi5jdXJyZW50KytcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICBsYXlvdXQsIFxuXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgLy8gZ2V0IG5ldyBvciBleGlzdGluZyBpdGVtSURcbiAgICBjb25zdCBpdGVtSUQgPSBjYWNoZUhhbmRsZXIuZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRChpbmRleClcblxuICAgIHJldHVybiA8Q2VsbEZyYW1lIFxuICAgICAgICBrZXkgPSB7IGluc3RhbmNlSUQgfSBcbiAgICAgICAgb3JpZW50YXRpb24gPSB7IG9yaWVudGF0aW9uIH1cbiAgICAgICAgY2VsbEhlaWdodCA9IHsgY2VsbEhlaWdodCB9XG4gICAgICAgIGNlbGxXaWR0aCA9IHsgY2VsbFdpZHRoIH1cbiAgICAgICAgY2VsbE1pbkhlaWdodCA9IHsgY2VsbE1pbkhlaWdodCB9XG4gICAgICAgIGNlbGxNaW5XaWR0aCA9IHsgY2VsbE1pbldpZHRoIH1cbiAgICAgICAgbGF5b3V0ID0geyBsYXlvdXQgfVxuICAgICAgICBpbmRleCA9IHsgaW5kZXggfVxuICAgICAgICBnZXRJdGVtID0geyBnZXRJdGVtIH1cbiAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgcGxhY2Vob2xkZXIgPSB7IHBsYWNlaG9sZGVyIH1cbiAgICAgICAgaXRlbUlEID0geyBpdGVtSUQgfVxuICAgICAgICBpbnN0YW5jZUlEID0geyBpbnN0YW5jZUlEIH1cbiAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgIGlzVHJpZ2dlcmNlbGwgPSB7IGZhbHNlIH1cbiAgICAgICAgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyA9IHsgcGxhY2Vob2xkZXJGcmFtZVN0eWxlcyB9XG4gICAgICAgIHBsYWNlaG9sZGVyQ29udGVudFN0eWxlcyA9IHsgcGxhY2Vob2xkZXJDb250ZW50U3R5bGVzIH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJiYXNlUm93TGVuZ3RoIiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwicGFkZGluZyIsImNyb3NzY291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwibGlzdFJvd2NvdW50IiwibGlzdHNpemUiLCJ2aWV3cG9ydFZpc2libGVSb3djb3VudCIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRBeGlzUm93T2Zmc2V0IiwiY2VpbCIsIm1heEF4aXNSb3dPZmZzZXQiLCJtYXgiLCJ0YXJnZXRDcmFkbGVSb3dPZmZzZXQiLCJ0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQiLCJsaXN0RW5kUm93T2Zmc2V0IiwiZGlmZiIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwibmV3Q3JhZGxlQ29udGVudENvdW50IiwiZW5kUm93UmVtYWluZGVyQ291bnQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJleHBvcnRzIiwiZ2V0U2hpZnRJbnN0cnVjdGlvbiIsIm9yaWVudGF0aW9uIiwidHJpZ2dlcmxpbmVFbnRyaWVzIiwidHJpZ2dlcmxpbmVTcGFuIiwic2Nyb2xsZXJJRCIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidHJpZ2dlckRhdGEiLCJoZWFkT2Zmc2V0IiwidGFpbE9mZnNldCIsInNwYW4iLCJlbnRyeSIsImF0IiwicmVmZXJlbmNlbmFtZSIsInRhcmdldCIsImRhdGFzZXQiLCJ0eXBlIiwicm9vdHBvcyIsInJvb3RCb3VuZHMiLCJ5IiwieCIsImVudHJ5cG9zIiwiYm91bmRpbmdDbGllbnRSZWN0Iiwidmlld3BvcnRUcmlnZ2VyT2Zmc2V0Iiwic2hpZnRpbnN0cnVjdGlvbiIsImNhbGNDb250ZW50U2hpZnQiLCJzY3JvbGxQb3MiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJjcmFkbGVDb250ZW50IiwiY3JhZGxlRWxlbWVudHMiLCJnYXAiLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwibGF5b3V0IiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiY3VycmVudCIsImhlYWRHcmlkRWxlbWVudCIsImhlYWRSZWYiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwiY3JhZGxlY29udGVudGxpc3QiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJ0YWlsY29udGVudGxpc3QiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwidmlld3BvcnRSb3djb3VudCIsInJlZmVyZW5jZUdyaWRFbGVtZW50IiwiZ3JpZFJvd0xlbmd0aHMiLCJnZXRHcmlkUm93TGVuZ3RocyIsInJldmVyc2UiLCJncmlkUm93U3BhbnMiLCJnZXRHcmlkUm93U3BhbnMiLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQb3MiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2EiLCJwcm9wcyIsImluZGV4IiwicHJldmlvdXNDcmFkbGVSb3dPZmZzZXQiLCJwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCIsIl9iIiwicHJldmlvdXNBeGlzUm93T2Zmc2V0Iiwic3BhblJvd1B0ciIsImZpbmRJbmRleCIsIm1vdmVtZW50c3BhbiIsInNwYW5BeGlzUGl4ZWxTaGlmdCIsIm5vdGlvbmFsUm93UHRyIiwibGVuZ3RoIiwidG90YWxQaXhlbFNoaWZ0Iiwic3BhblJvd1NoaWZ0IiwiYXhpc1JlZmVyZW5jZVJvd1NoaWZ0IiwiYXhpc1BpeGVsU2hpZnQiLCJzY3JvbGxibG9ja0F4aXNPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzT2Zmc2V0IiwibmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCIsIm5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCIsIm5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQiLCJsaXN0RW5kcm93T2Zmc2V0IiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IiwiaGVhZHJvd0RpZmYiLCJ0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQiLCJ0YWlscm93ZGlmZiIsImNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldCIsIm5ld0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0IiwibmV3QXhpc1JlZmVyZW5jZUluZGV4IiwiYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCIsImluY2x1ZGVzTGFzdFJvdyIsInBhcnRpYWxzcGFjZXMiLCJpdGVtc1Nob3J0ZmFsbCIsImNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50IiwibGlzdFN0YXJ0Q2hhbmdlQ291bnQiLCJsaXN0RW5kQ2hhbmdlQ291bnQiLCJncmlkIiwicm93TGVuZ3RocyIsImVsZW1lbnRMaXN0IiwiY2hpbGROb2RlcyIsImVsZW1lbnRQdHIiLCJlbGVtZW50Iiwicm93bGVuZ3RoIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJwdXNoIiwicm93U3BhbnMiLCJmb3JFYWNoIiwidmFsdWUiLCJnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0IiwiY2FjaGVIYW5kbGVyIiwiY3JhZGxlQ29udGVudENvdW50IiwiY3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjb250ZW50bGlzdCIsIndvcmtpbmdDb250ZW50TGlzdCIsImluc3RhbmNlSWRDb3VudGVyUmVmIiwic3R5bGVzIiwibG9jYWxDb250ZW50bGlzdCIsImxhc3RpbmRleG9mZnNldCIsImhlYWRDb250ZW50bGlzdCIsInRhaWxDb250ZW50bGlzdCIsImRlbGV0ZWR0YWlsaXRlbXMiLCJkZWxldGVkaGVhZGl0ZW1zIiwibmV3aW5kZXgiLCJjcmVhdGVDZWxsRnJhbWUiLCJwbGFjZWhvbGRlckZyYW1lU3R5bGVzIiwicGxhY2Vob2xkZXJmcmFtZSIsInBsYWNlaG9sZGVyQ29udGVudFN0eWxlcyIsInBsYWNlaG9sZGVyY29udGVudCIsInNwbGljZSIsImRlbGV0ZWRJdGVtcyIsImNvbXBvbmVudExpc3QiLCJhbGxvY2F0ZUNvbnRlbnRMaXN0IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwibGF5b3V0SGFuZGxlciIsInRyaWdnZXJjZWxsSW5kZXgiLCJvZmZzZXRpbmRleCIsImhpZ2hpbmRleCIsImhlYWRpdGVtY291bnQiLCJ0YXJnZXRUcmlnZ2VyY2VsbEluZGV4IiwidHJpZ2dlcmNlbGxJc0luVGFpbCIsInVuZGVmaW5lZCIsInRyaWdnZXJjZWxsUHRyIiwidHJpZ2dlcmNlbGxDb21wb25lbnQiLCJyZWFjdF8xIiwiY2xvbmVFbGVtZW50IiwiaXNUcmlnZ2VyY2VsbCIsImNvbnNvbGUiLCJsb2ciLCJpc1RyaWdnZWNlbGwiLCJoZWFkbGlzdCIsInNsaWNlIiwidGFpbGxpc3QiLCJkZWxldGVQb3J0YWxzIiwiZGVsZXRlTGlzdCIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImRsaXN0IiwibWFwIiwiaXRlbSIsImRlbGV0ZVBvcnRhbCIsImluc3RhbmNlSUQiLCJjZWxsTWluSGVpZ2h0IiwiY2VsbE1pbldpZHRoIiwiZ2V0SXRlbSIsInBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRCIsIkNlbGxGcmFtZV8xIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(" // contenthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module supports the setup and rollover and positioning of content in the Cradle.\n\n    There are three key functions in this module: setCradleContent, updateCradleContent, and\n    adjustScrollblockForVariability.\n\n    There are also a few functions which support synchronization of Cradle content with cache\n    content (see internal and external services below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    tailward, content is removed from the Cradle head and added to the Cradle tail. When scrolling\n    headward, the reverse occurs.\n\n    adjustScrollblockForVariability reconfigures the scrollblock to accommodate variable sized grid rows.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n\n*/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ \"./src/cradle/contentfunctions.tsx\");\n\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n\n    _classCallCheck(this, ContentHandler);\n\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    }; // Two main public methods - setCradleContent and updateCradleContent\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n          cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n          cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n          cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n          layoutHandler = cradleHandlers.layoutHandler,\n          serviceHandler = cradleHandlers.serviceHandler,\n          interruptHandler = cradleHandlers.interruptHandler,\n          scrollHandler = cradleHandlers.scrollHandler; // the triggerlines and cradle grids will be moved, so disconnect them from their observers.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.cradleIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true;\n      interruptHandler.signals.pauseCradleIntersectionObserver = true;\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n          gap = cradleInheritedProperties.gap,\n          padding = cradleInheritedProperties.padding,\n          cellHeight = cradleInheritedProperties.cellHeight,\n          cellWidth = cradleInheritedProperties.cellWidth,\n          cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID,\n          styles = cradleInheritedProperties.styles,\n          layout = cradleInheritedProperties.layout;\n      var crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize,\n          listRowcount = cradleInternalProperties.listRowcount;\n      var workingRequestAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingRequestAxisReferenceIndex -= workingRequestAxisReferenceIndex % crosscount; // reposition at row boundary\n\n      if (['firstrender', 'firstrenderfromcache', 'finishreposition', 'reconfigure', 'scrollto'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingRequestAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content; // ----------------------[ 2. get content requirements ]----------------------\n\n      var baseRowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap; // note that targetAxisReferenceIndex replaces requestedAxisReferenceIndex here\n\n      var _ref = (0, contentfunctions_1.getContentListRequirements)({\n        // pixel\n        baseRowLength: baseRowLength,\n        targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n        // index\n        targetAxisReferenceIndex: workingRequestAxisReferenceIndex,\n        // resources\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties\n      }),\n          targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n          targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n          cradleContentCount = _ref.newCradleContentCount,\n          scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset; // reset scrollblock Offset and length\n\n\n      var scrollblockElement = viewportElement.firstChild;\n      var baselength = listRowcount * baseRowLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n\n      if (cradleState == 'pivot') {\n        if (orientation == 'vertical') {\n          scrollblockElement.style.left = null;\n        } else {\n          scrollblockElement.style.top = null;\n        }\n      }\n\n      if (orientation == 'vertical') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + 'px';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + 'px';\n      }\n\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // semantics\n      // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n        cacheHandler: cacheHandler,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContentCount: cradleContentCount,\n        cradleReferenceIndex: targetCradleReferenceIndex,\n        listStartChangeCount: 0,\n        listEndChangeCount: cradleContentCount,\n        workingContentList: workingContentList,\n        instanceIdCounterRef: _this.instanceIdCounterRef,\n        styles: styles\n      }),\n          _ref3 = _slicedToArray(_ref2, 2),\n          newcontentlist = _ref3[0],\n          deleteditems = _ref3[1];\n\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: newcontentlist,\n        axisReferenceIndex: targetAxisReferenceIndex,\n        layoutHandler: layoutHandler\n      }),\n          _ref5 = _slicedToArray(_ref4, 2),\n          headcontentlist = _ref5[0],\n          tailcontentlist = _ref5[1];\n\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, 'setCradleContent', cstate);\n      } //  ----------------------[ 4. set CSS ]-----------------------\n\n\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset; // - scrollblockOffset\n      // avoid bogus call to updateCradleContent\n\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset); // - scrollblockOffset) \n\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current,\n          headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n\n      if (orientation == 'vertical') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontentlist.length ? gap + 'px' : 0;\n      } else {\n        // orientation = 'horizontal'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = left + 'px';\n        headElement.style.paddingRight = headcontentlist.length ? gap + 'px' : 0;\n      }\n    }; // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element's scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler\n\n\n    this.updateCradleContent = function (triggerlineEntries) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'notifications';\n\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a, _b; // handler support\n\n\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n          cacheHandler = _this$cradleParameter.cacheHandler,\n          scrollHandler = _this$cradleParameter.scrollHandler,\n          layoutHandler = _this$cradleParameter.layoutHandler,\n          stateHandler = _this$cradleParameter.stateHandler,\n          interruptHandler = _this$cradleParameter.interruptHandler,\n          serviceHandler = _this$cradleParameter.serviceHandler; // scroll data\n\n      var scrollData = scrollHandler.scrollData;\n      var scrollPos = scrollData.currentupdate; // first abandon option/3; nothing to do\n\n      if (scrollPos < 0) {\n        // for Safari, FF elastic bounce at top of scroll\n        return;\n      } // cradle scaffold and user cells\n\n\n      var cradleElements = layoutHandler.elements;\n      var cradleContent = _this.content,\n          modelcontentlist = cradleContent.cradleModelComponents || [],\n          oldAxisReferenceIndex = ((_a = cradleContent.tailModelComponents[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      var oldCradleReferenceIndex = ((_b = modelcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n          cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n          cache = cradleInheritedProperties.cache,\n          styles = cradleInheritedProperties.styles;\n      var crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize; // --------------------[ 2. get shift instruction ]-----------------------\n\n      var _ref6 = (0, contentfunctions_1.getShiftInstruction)({\n        scrollerID: cradleInheritedProperties.scrollerID,\n        orientation: orientation,\n        triggerlineEntries: triggerlineEntries,\n        triggerlineSpan: layoutHandler.triggerlineSpan,\n        isFirstRowTriggerConfig: layoutHandler.triggercellIsInTail\n      }),\n          _ref7 = _slicedToArray(_ref6, 2),\n          shiftinstruction = _ref7[0],\n          triggerData = _ref7[1]; // second abandon option/3; nothing to do\n\n\n      if (shiftinstruction == 'none') {\n        // 0) {\n        return;\n      } // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      // const cradleInheritedProperties = this.cradleParameters.cradleInheritedPropertiesRef.current\n\n\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n\n      var _ref8 = (0, contentfunctions_1.calcContentShift)({\n        shiftinstruction: shiftinstruction,\n        triggerData: triggerData,\n        scrollPos: scrollPos,\n        scrollblockElement: viewportElement.firstChild,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContent: cradleContent,\n        cradleElements: cradleElements\n      }),\n          newCradleReferenceIndex = _ref8.newCradleReferenceIndex,\n          cradleItemShift = _ref8.cradleReferenceItemShift,\n          axisReferenceIndex = _ref8.newAxisReferenceIndex,\n          axisItemShift = _ref8.axisReferenceItemShift,\n          cradleContentCount = _ref8.newCradleContentCount,\n          listStartChangeCount = _ref8.listStartChangeCount,\n          listEndChangeCount = _ref8.listEndChangeCount,\n          axisViewportPixelOffset = _ref8.newAxisViewportPixelOffset; // third abandon option/3; nothing to do\n\n\n      if (axisItemShift == 0 && cradleItemShift == 0) {\n        // can happen first row\n        return;\n      } // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true; // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect modified content\n\n      var updatedContentList,\n          deletedContentItems = [];\n\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref9 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles\n        });\n\n        var _ref10 = _slicedToArray(_ref9, 2);\n\n        updatedContentList = _ref10[0];\n        deletedContentItems = _ref10[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n\n      if (deletedContentItems.length && cache == 'cradle') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cradle', deleteList);\n          };\n        }\n\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      } // ----------------------------------[ 5. allocate cradle content ]--------------------------\n\n\n      var _ref11 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: updatedContentList,\n        axisReferenceIndex: axisReferenceIndex,\n        layoutHandler: layoutHandler\n      }),\n          _ref12 = _slicedToArray(_ref11, 2),\n          headcontent = _ref12[0],\n          tailcontent = _ref12[1];\n\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, 'updateCradleContent', cstate);\n      } // -------------------------------[ 6. set css changes ]-------------------------\n\n\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n\n      if (cradleInheritedProperties.orientation == 'vertical') {\n        var topPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = topPos + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      } else {\n        // 'horizontal'\n        var leftPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = leftPos + 'px';\n        headElement.style.paddingRight = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      }\n\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      stateHandler.setCradleState('renderupdatedcontent');\n    }; // ===================[ RECONFIGURE THE SCROLLBLOCK FOR VARIABLE CONTENT ]=======================\n    // all DOM elements should have been rendered at this point\n    // sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n    // this to get closer to natural proportions to minimize janky scroll thumb\n\n\n    this.adjustScrollblockForVariability = function (source) {\n      // ----------------------[ setup base values and references ]------------------------\n      // resources...\n      var cradleParameters = _this.cradleParameters,\n          cradleHandlers = cradleParameters.handlersRef.current,\n          ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n          cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n          cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var layoutHandler = cradleHandlers.layoutHandler,\n          scrollHandler = cradleHandlers.scrollHandler,\n          cradleElements = layoutHandler.elements,\n          cradlePositionData = layoutHandler.cradlePositionData; // element references...\n\n      var viewportElement = ViewportContextProperties.elementRef.current,\n          scrollblockElement = viewportElement.firstChild,\n          headGridElement = cradleElements.headRef.current,\n          tailGridElement = cradleElements.tailRef.current,\n          axisElement = cradleElements.axisRef.current; // current configurations...\n\n      var axisReferenceIndex = cradlePositionData.targetAxisReferenceIndex,\n          axisViewportOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var blockScrollPos = cradlePositionData.blockScrollPos;\n      var orientation = cradleInheritedProperties.orientation,\n          gap = cradleInheritedProperties.gap,\n          padding = cradleInheritedProperties.padding,\n          cellHeight = cradleInheritedProperties.cellHeight,\n          cellWidth = cradleInheritedProperties.cellWidth;\n      var crosscount = cradleInternalProperties.crosscount,\n          listRowcount = cradleInternalProperties.listRowcount; // ------------------------[ precursor calculations ]------------------------\n      // rowcounts and row offsets for positioning\n      // listRowcount taken from internal properties above\n\n      var headRowCount = Math.ceil(headGridElement.childNodes.length / crosscount),\n          tailRowCount = Math.ceil(tailGridElement.childNodes.length / crosscount); // reference rows - cradle first/last; axis; list end\n\n      var axisReferenceRow = Math.ceil(axisReferenceIndex / crosscount),\n          cradleReferenceRow = axisReferenceRow - headRowCount,\n          cradleLastReferenceRow = axisReferenceRow + (tailRowCount - 1),\n          listLastReferenceRow = listRowcount - 1;\n      var preCradleRowCount = cradleReferenceRow,\n          postCradleRowCount = listLastReferenceRow - cradleLastReferenceRow; // base pixel values\n\n      var baseCellLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n      var baseHeadLength = headRowCount * baseCellLength + padding; // measured pixel cradle grid values\n\n      var measuredTailLength;\n\n      if (orientation == 'vertical') {\n        measuredTailLength = tailGridElement.offsetHeight;\n      } else {\n        measuredTailLength = tailGridElement.offsetWidth;\n      }\n\n      var preCradlePixelLength = preCradleRowCount * baseCellLength,\n          postCradlePixelLength = postCradleRowCount * baseCellLength;\n      var computedPostAxisPixelLength = postCradlePixelLength + measuredTailLength; // base figures used for preAxis #s for compatibility with repositioning, which uses base figures\n\n      var computedScrollblockLength = preCradlePixelLength + baseHeadLength + computedPostAxisPixelLength;\n      var basePreAxisPixelLength = (preCradleRowCount + headRowCount) * baseCellLength + padding; // ------------------------[ change calculations ]----------------------\n\n      var variableAdjustment = blockScrollPos + axisViewportOffset - basePreAxisPixelLength; // change blockScrollPos\n\n      var reposition = false;\n\n      if (source == 'afterscroll') {\n        blockScrollPos -= variableAdjustment;\n        reposition = true;\n      }\n\n      var newAxisScrollblockOffset = blockScrollPos + axisViewportOffset - variableAdjustment;\n      var resetscroll = false;\n\n      if (axisReferenceRow == 0) {\n        if (variableAdjustment > 0 || newAxisScrollblockOffset > padding) {\n          variableAdjustment = 0;\n          newAxisScrollblockOffset = padding;\n          resetscroll = true;\n        }\n      }\n\n      var newScrollblockLength = computedScrollblockLength + variableAdjustment; // -----------------------[ application ]-------------------------\n      // change scrollblockElement top and height, or left and width,\n      //    and axisElement top or left\n\n      if (orientation == 'vertical') {\n        // the scrollblock top is moved to compensate for the cumulative variability\n        scrollblockElement.style.top = !variableAdjustment ? null : variableAdjustment + 'px'; // the axis is moved in the opposite direction to maintain viewport position\n\n        axisElement.style.top = newAxisScrollblockOffset + 'px'; // the height is adjusted by both deltas, as it controls the scroll length\n\n        scrollblockElement.style.height = newScrollblockLength + 'px';\n      } else {\n        scrollblockElement.style.left = !variableAdjustment ? null : variableAdjustment + 'px'; // scrollblockElement.style.left = variableAdjustment + 'px'\n\n        axisElement.style.left = newAxisScrollblockOffset + 'px';\n        scrollblockElement.style.width = newScrollblockLength + 'px';\n      }\n\n      if (resetscroll) {\n        // top of list\n        viewportElement.scrollTo(0, 0);\n        viewportElement[cradlePositionData.blockScrollProperty] = 0;\n        scrollHandler.resetScrollData(0);\n      } // must be after length is updated\n\n\n      if (reposition) {\n        // reset blockScrollPos afterscroll\n        cradlePositionData.blockScrollPos = blockScrollPos;\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n        scrollHandler.resetScrollData(blockScrollPos);\n      }\n    }; // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n\n\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n          cacheMax = _this$cradleParameter2.cacheMax,\n          MAX_CACHE_OVER_RUN = _this$cradleParameter2.MAX_CACHE_OVER_RUN;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      var modelComponentList = _this.content.cradleModelComponents;\n\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID;\n\n      if (cache == 'keepload') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n            serviceHandler = cradleHandlers.serviceHandler;\n\n        var modelIndexList = _this.getModelIndexList();\n\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cacheMax', deleteList);\n          };\n        }\n\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.cacheProps.modified = true;\n          cacheHandler.renderPortalList();\n        }\n      }\n    }; // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n\n\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n\n    this.cradleParameters = cradleParameters;\n  } // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n\n\n  _createClass(ContentHandler, [{\n    key: \"getModelIndexList\",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    } // called from service handler's remapIndexes, as last step\n\n  }, {\n    key: \"reconcileCellFrames\",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n\n      function processComponent(component, i, array) {\n        var _component$props = component.props,\n            index = _component$props.index,\n            itemID = _component$props.itemID;\n\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n\n          if (newItemID != itemID) {\n            // defensive; shouldn't happen\n            array[i] = react_1[\"default\"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n\n      cradleModelComponents.forEach(processComponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports moveIndex and insertRemoveIndex\n\n  }, {\n    key: \"changeCradleItemIDs\",\n    value: function changeCradleItemIDs(changeList) {\n      if (changeList.length == 0) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var _cacheHandler$cachePr = cacheHandler.cacheProps,\n          indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap,\n          metadataMap = _cacheHandler$cachePr.metadataMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = changeList.indexOf(index);\n\n        if (ptr != -1) {\n          var itemID = indexToItemIDMap.get(index);\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: itemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports insertRemoveIndex\n\n  }, {\n    key: \"createNewItemIDs\",\n    value: function createNewItemIDs(newList) {\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = newList.indexOf(index);\n\n        if (ptr != -1) {\n          var newItemID = cacheHandler.getNewItemID();\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: newItemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n  }]);\n\n  return ContentHandler;\n}();\n\nexports[\"default\"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NvbnRlbnRoYW5kbGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7O0FBRUE7O0lBWXFCQSxjO0VBRWxCLHdCQUFZQyxnQkFBWixFQUE0QjtJQUFBOztJQUFBOztJQU1yQixlQUFVO01BRWRDLHFCQUFxQixFQUFFLElBRlQ7TUFHZEMsbUJBQW1CLEVBQUUsSUFIUDtNQUlkQyxtQkFBbUIsRUFBRSxJQUpQO01BS2Q7TUFDQUMscUJBQXFCLEVBQUUsRUFOVDtNQU9kQyxxQkFBcUIsRUFBRTtJQVBULENBQVY7SUFhRSw0QkFBdUI7TUFFNUJDLE9BQU8sRUFBQztJQUZvQixDQUF2QixDQW5CbUIsQ0F3QjNCO0lBRUE7SUFFQTtJQUNBOztJQUVPLHdCQUFtQixVQUFFQyxXQUFGLEVBQWtCO01BRXhDO01BRUEsSUFBUVAsZ0JBQVIsR0FBNkIsS0FBN0IsQ0FBUUEsZ0JBQVI7TUFFQSxJQUFNUSx5QkFBeUIsR0FBR1IsZ0JBQWdCLENBQUNTLDRCQUFqQixDQUE4Q0gsT0FBaEY7TUFBQSxJQUNJSSx5QkFBeUIsR0FBR1YsZ0JBQWdCLENBQUNXLDRCQUFqQixDQUE4Q0wsT0FEOUU7TUFBQSxJQUVJTSx3QkFBd0IsR0FBR1osZ0JBQWdCLENBQUNhLDJCQUFqQixDQUE2Q1AsT0FGNUU7TUFBQSxJQUdJUSxjQUFjLEdBQUdkLGdCQUFnQixDQUFDZSxXQUFqQixDQUE2QlQsT0FIbEQ7TUFLQSxJQUVJVSxZQUZKLEdBUUlGLGNBUkosQ0FFSUUsWUFGSjtNQUFBLElBR0lDLGFBSEosR0FRSUgsY0FSSixDQUdJRyxhQUhKO01BQUEsSUFJSUMsY0FKSixHQVFJSixjQVJKLENBSUlJLGNBSko7TUFBQSxJQUtJQyxnQkFMSixHQVFJTCxjQVJKLENBS0lLLGdCQUxKO01BQUEsSUFNSUMsYUFOSixHQVFJTixjQVJKLENBTUlNLGFBTkosQ0FY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LG1CQUFiLENBQWlDMEYsTUFBN0QsQ0FBbkM7SUFFSDs7Ozs7O0FBcjFCTHFHLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL2NvbnRlbnRoYW5kbGVyLnRzeD9hODlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBzdXBwb3J0cyB0aGUgc2V0dXAgYW5kIHJvbGxvdmVyIGFuZCBwb3NpdGlvbmluZyBvZiBjb250ZW50IGluIHRoZSBDcmFkbGUuIFxuXG4gICAgVGhlcmUgYXJlIHRocmVlIGtleSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGU6IHNldENyYWRsZUNvbnRlbnQsIHVwZGF0ZUNyYWRsZUNvbnRlbnQsIGFuZFxuICAgIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkuXG5cbiAgICBUaGVyZSBhcmUgYWxzbyBhIGZldyBmdW5jdGlvbnMgd2hpY2ggc3VwcG9ydCBzeW5jaHJvbml6YXRpb24gb2YgQ3JhZGxlIGNvbnRlbnQgd2l0aCBjYWNoZSBcbiAgICBjb250ZW50IChzZWUgaW50ZXJuYWwgYW5kIGV4dGVybmFsIHNlcnZpY2VzIGJlbG93KS5cblxuICAgIHNldENyYWRsZUNvbnRlbnQgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gQ3JhZGxlIChpbiB0aGUgc3RhdGUgbWFuYWdlciksIGFuZCBpbnN0YW50aWF0ZXMgbmV3IENyYWRsZVxuICAgIGNvbnRlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIHNjcm9sbGVyIHNldHVwLCBvciBjaGFuZ2VzIHRvIGl0cyBjb25maWd1cmF0aW9uLiBzZXRDcmFkbGVDb250ZW50XG4gICAgY3JlYXRlcyBhIGxpc3Qgb2YgQ3JhZGxlIGNvbnRlbnQgQ2VsbEZyYW1lcywgYW5kIGFsbG9jYXRlcyB0aG9zZSB0byB0aGUgdHdvIENyYWRsZSBncmlkcy4gVGhpcyBcbiAgICBwcm9jZXNzIG9jY3VycyBpbiByZXNwb25zZSB0byBtYW55IHN0YXRlIGNoYW5nZXMsIHN1Y2ggYXMgZmluaXNocmVwb3NpdGlvbiwgcGl2b3QsIGEgaG9zdCBzY3JvbGx0b1xuICAgIHJlcXVlc3QsIGFuZCBtb3JlLlxuXG4gICAgdXBkYXRlQ3JhZGxlQ29udGVudCByb2xscyBvdmVyIHRoZSBDcmFkbGUgY29udGVudCBpbiByZXNwb25zZSB0byB1c2VyIHNjcm9sbGluZy4gV2hlbiBzY3JvbGxpbmcgXG4gICAgdGFpbHdhcmQsIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBDcmFkbGUgaGVhZCBhbmQgYWRkZWQgdG8gdGhlIENyYWRsZSB0YWlsLiBXaGVuIHNjcm9sbGluZyBcbiAgICBoZWFkd2FyZCwgdGhlIHJldmVyc2Ugb2NjdXJzLlxuXG4gICAgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSByZWNvbmZpZ3VyZXMgdGhlIHNjcm9sbGJsb2NrIHRvIGFjY29tbW9kYXRlIHZhcmlhYmxlIHNpemVkIGdyaWQgcm93cy5cblxuICAgIFRoZSBDcmFkbGUgKHRocm91Z2ggdGhlIGNvbnRlbnRmdW5jdGlvbnMgbW9kdWxlKSBkZWxlZ2F0ZXMgZmV0Y2hpbmcgY29udGVudCBpdGVtcyB0byB0aGUgQ2VsbEZyYW1lLlxuXG4gICAgVGhpcyBtb2R1bGUgaXMgc3VwcG9ydGVkIHByaW1hcmlseSBieSB0aGUgY29udGVudGZ1bmN0aW9ucyBtb2R1bGUuXG5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgXG4gICAgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMsXG4gICAgZ2V0U2hpZnRJbnN0cnVjdGlvbixcbiAgICBjYWxjQ29udGVudFNoaWZ0LFxuICAgIGFsbG9jYXRlQ29udGVudExpc3QsXG4gICAgZGVsZXRlUG9ydGFscyxcbiAgICBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0LCBcbiAgICAvLyBnZXRHcmlkUm93TGVuZ3RocyxcbiAgICAvLyBnZXRHcmlkUm93U3BhbnMsXG5cbn0gZnJvbSAnLi9jb250ZW50ZnVuY3Rpb25zJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50SGFuZGxlciB7XG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICB9XG5cbiAgIHB1YmxpYyBjb250ZW50ID0ge1xuXG4gICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICBoZWFkTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgdGFpbE1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIG9ubHkgdXNlZCBpbiBjcmFkbGUgZm9yIHJlbmRlclxuICAgICAgaGVhZERpc3BsYXlDb21wb25lbnRzOiBbXSxcbiAgICAgIHRhaWxEaXNwbGF5Q29tcG9uZW50czogW10sXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHByaXZhdGUgaW5zdGFuY2VJZENvdW50ZXJSZWYgPSB7XG5cbiAgICAgICBjdXJyZW50OjBcblxuICAgIH1cbiAgICAvLyBUd28gbWFpbiBwdWJsaWMgbWV0aG9kcyAtIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnRcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBTRVQgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyByZXNldCB0aGUgY3JhZGxlIHdpdGggbmV3IGNvbnRlbnQsIGluY2x1ZGluZyBhbGxvY2F0aW9uIGJldHdlZW4gaGVhZCBhbmQgdGFpbCBwYXJ0cyBvZiB0aGUgY3JhZGxlXG4gICAgLy8gLSBjYWxsZWQgb25seSBmcm9tIHRoZSBDcmFkbGUgc3RhdGUgaGFuZGxlclxuXG4gICAgcHVibGljIHNldENyYWRsZUNvbnRlbnQgPSAoIGNyYWRsZVN0YXRlICkgPT4geyAvLyBjcmFkbGVTdGF0ZSBpbmZsdWVuY2VzIHNvbWUgYmVoYXZpb3VyXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSGFuZGxlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLFxuXG4gICAgICAgIH0gPSBjcmFkbGVIYW5kbGVyc1xuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgYW5kIGNyYWRsZSBncmlkcyB3aWxsIGJlIG1vdmVkLCBzbyBkaXNjb25uZWN0IHRoZW0gZnJvbSB0aGVpciBvYnNlcnZlcnMuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4ID0gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBsZXQgeyB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCB9ID0gY3JhZGxlUG9zaXRpb25EYXRhXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgZ2FwLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBjb25zdCB7Y3Jvc3Njb3VudCwgbGlzdHNpemUsIGxpc3RSb3djb3VudH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICBsZXQgd29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1pbihyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgsbGlzdHNpemUgLSAxKVxuICAgICAgICB3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCAtPSAod29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50KVxuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYXQgcm93IGJvdW5kYXJ5XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICAnZmlyc3RyZW5kZXInLCBcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcmZyb21jYWNoZScsXG4gICAgICAgICAgICAnZmluaXNocmVwb3NpdGlvbicsIFxuICAgICAgICAgICAgJ3JlY29uZmlndXJlJywgXG4gICAgICAgICAgICAnc2Nyb2xsdG8nLCBcbiAgICAgICAgXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICAod29ya2luZ1JlcXVlc3RBeGlzUmVmZXJlbmNlSW5kZXggPT0gMCk/XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6XG4gICAgICAgICAgICAgICAgICAgIGdhcCAvLyBkZWZhdWx0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtpbmdDb250ZW50TGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBnZXQgY29udGVudCByZXF1aXJlbWVudHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBiYXNlUm93TGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICAvLyBub3RlIHRoYXQgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IHJlcGxhY2VzIHJlcXVlc3RlZEF4aXNSZWZlcmVuY2VJbmRleCBoZXJlXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgLy8gYnkgaW5kZXhcbiAgICAgICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcblxuICAgICAgICAgICAgLy8gY291bnRzXG4gICAgICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQ6Y3JhZGxlQ29udGVudENvdW50LCBcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IHNjcm9sbFBvcyBieSBwaXhlbHNcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldDpzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICAgICAgfSA9IGdldENvbnRlbnRMaXN0UmVxdWlyZW1lbnRzKHtcblxuICAgICAgICAgICAgICAgIC8vIHBpeGVsXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OndvcmtpbmdSZXF1ZXN0QXhpc1JlZmVyZW5jZUluZGV4LFxuXG4gICAgICAgICAgICAgICAgLy8gcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVzZXQgc2Nyb2xsYmxvY2sgT2Zmc2V0IGFuZCBsZW5ndGhcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3RSb3djb3VudCAqIGJhc2VSb3dMZW5ndGgpIC0gZ2FwIC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3Bpdm90Jykge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBiYXNlbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUud2lkdGggPSBiYXNlbGVuZ3RoICsgJ3B4J1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCAvLyBzZW1hbnRpY3NcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAzLiBnZXQgYW5kIGNvbmZpZyBjb250ZW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICAvLyByZXR1cm5zIGNvbnRlbnQgY29uc3RyYWluZWQgYnkgY3JhZGxlUm93Y291bnRcbiAgICAgICAgY29uc3QgW25ld2NvbnRlbnRsaXN0LGRlbGV0ZWRpdGVtc10gPSBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0KHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLCAgICAgICAgICAgIFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZUluZGV4OnRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQ6MCxcbiAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudDpjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgICAgICB3b3JraW5nQ29udGVudExpc3QsXG4gICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZjp0aGlzLmluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgc3R5bGVzLFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpuZXdjb250ZW50bGlzdCxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDp0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgIFxuICAgICAgICB9KVxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzID0gbmV3Y29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gaGVhZGNvbnRlbnRsaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IHRhaWxjb250ZW50bGlzdFxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spIHtcblxuICAgICAgICAgICAgbGV0IGNzdGF0ZSA9IGNyYWRsZVN0YXRlXG5cbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKFxuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwnc2V0Q3JhZGxlQ29udGVudCcsIGNzdGF0ZSlcbiAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNC4gc2V0IENTUyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgLy8gLSBzY3JvbGxibG9ja09mZnNldFxuICAgICAgICAvLyBhdm9pZCBib2d1cyBjYWxsIHRvIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgc2Nyb2xsSGFuZGxlci5yZXNldFNjcm9sbERhdGEoc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0KSAvLyAtIHNjcm9sbGJsb2NrT2Zmc2V0KSBcblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID1cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyBcblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGhlYWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wID0gYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50bGlzdC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgZ2FwICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PVsgVVBEQVRFIENPTlRFTlQgdGhyb3VnaCBzY3JvbGwgXT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdXBkYXRlQ3JhZGxlQ29udGVudCBkb2VzIG5vdCB0b3VjaCB0aGUgdmlld3BvcnQgZWxlbWVudCdzIHNjcm9sbCBwb3NpdGlvbiBmb3IgdGhlIHNjcm9sbGJsb2NrXG4gICAgLy8gaW5zdGVhZCBpdCByZWNvbmZpZ3VyZXMgZWxlbWVudHMgd2l0aGluIHRoZSBjcmFkbGUuIEl0IGlzIGNhbGxlZCBzb2xlbHkgZnJvbVxuICAgIC8vIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrIG9mIGludGVycnVwdEhhbmRsZXJcblxuICAgIHB1YmxpYyB1cGRhdGVDcmFkbGVDb250ZW50ID0gKFxuXG4gICAgICAgIHRyaWdnZXJsaW5lRW50cmllcywgXG4gICAgICAgIHNvdXJjZSA9ICdub3RpZmljYXRpb25zJ1xuXG4gICAgKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhhbmRsZXIgc3VwcG9ydFxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlciwgXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLCBcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsIFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgICAgIFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBzY3JvbGwgZGF0YVxuICAgICAgICBjb25zdCB7IHNjcm9sbERhdGEgfSA9IHNjcm9sbEhhbmRsZXJcblxuICAgICAgICBjb25zdCBzY3JvbGxQb3MgPSBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGVcblxuICAgICAgICAvLyBmaXJzdCBhYmFuZG9uIG9wdGlvbi8zOyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICggc2Nyb2xsUG9zIDwgMCkgeyAvLyBmb3IgU2FmYXJpLCBGRiBlbGFzdGljIGJvdW5jZSBhdCB0b3Agb2Ygc2Nyb2xsXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmFkbGUgc2NhZmZvbGQgYW5kIHVzZXIgY2VsbHNcbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBsYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIG1vZGVsY29udGVudGxpc3QgPSBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyB8fCBbXSxcbiAgICAgICAgICAgIG9sZEF4aXNSZWZlcmVuY2VJbmRleCA9IChjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNbMF0/LnByb3BzLmluZGV4IHx8IDApXG5cbiAgICAgICAgY29uc3Qgb2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAobW9kZWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICAvLyB2aWV3cG9ydFZpc2libGVSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBnZXQgc2hpZnQgaW5zdHJ1Y3Rpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgW3NoaWZ0aW5zdHJ1Y3Rpb24sIHRyaWdnZXJEYXRhXSA9IGdldFNoaWZ0SW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgc2Nyb2xsZXJJRDogY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5zY3JvbGxlcklELFxuICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICB0cmlnZ2VybGluZUVudHJpZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZVNwYW46IGxheW91dEhhbmRsZXIudHJpZ2dlcmxpbmVTcGFuLFxuXG4gICAgICAgICAgICBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZzpsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwsXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBzZWNvbmQgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbm9uZScpIHsgLy8gMCkge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIENhbGN1bGF0ZSBzaGlmdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjcmFkbGUgcHJvcGVydGllc1xuICAgICAgICAvLyBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgLy8gYnkgaW5kZXhcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0OmNyYWRsZUl0ZW1TaGlmdCwgXG4gICAgICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXg6YXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQ6YXhpc0l0ZW1TaGlmdCwgXG5cbiAgICAgICAgICAgIC8vIGNvdW50c1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LFxuXG4gICAgICAgICAgICAvLyBwaXhlbHNcbiAgICAgICAgICAgIG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0OmF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcblxuICAgICAgICB9ID0gY2FsY0NvbnRlbnRTaGlmdCh7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICB0cmlnZ2VyRGF0YSxcbiAgICAgICAgICAgIHNjcm9sbFBvcyxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudDp2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZCxcblxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQsXG4gICAgICAgICAgICBjcmFkbGVFbGVtZW50cyxcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHRoaXJkIGFiYW5kb24gb3B0aW9uLzM7IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKChheGlzSXRlbVNoaWZ0ID09IDAgJiYgY3JhZGxlSXRlbVNoaWZ0ID09IDApKSB7IC8vIGNhbiBoYXBwZW4gZmlyc3Qgcm93XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgdHJpZ2dlcmxpbmVzIHdpbGwgYmUgbW92ZWQsIHNvIGRpc2Nvbm5lY3QgdGhlbSBmcm9tIHRoZWlyIG9ic2VydmVyLlxuICAgICAgICAvLyB0aGV5IGFyZSByZWNvbm5lY3RlZCB3aXRoICdyZW5kZXJ1cGRhdGVkY29udGVudCcgc3RhdGUgaW4gY3JhZGxlLnRzeFxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNC4gcmVjb25maWd1cmUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY29sbGVjdCBtb2RpZmllZCBjb250ZW50XG4gICAgICAgIGxldCB1cGRhdGVkQ29udGVudExpc3QsIGRlbGV0ZWRDb250ZW50SXRlbXMgPSBbXVxuXG4gICAgICAgIGlmIChsaXN0U3RhcnRDaGFuZ2VDb3VudCB8fCBsaXN0RW5kQ2hhbmdlQ291bnQpIHsgLy8gaWYgZWl0aGVyIGlzIG5vbi0wIHRoZW4gbW9kaWZ5IGNvbnRlbnRcblxuICAgICAgICAgICAgW3VwZGF0ZWRDb250ZW50TGlzdCxkZWxldGVkQ29udGVudEl0ZW1zXSA9IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3Qoe1xuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0Om1vZGVsY29udGVudGxpc3QsXG4gICAgICAgICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4gICAgICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LFxuICAgICAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZUluZGV4Om9sZENyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29udGVudExpc3QgPSBtb2RlbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxldGVkQ29udGVudEl0ZW1zLmxlbmd0aCAmJiAoY2FjaGUgPT0gJ2NyYWRsZScpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZVBvcnRhbHMoY2FjaGVIYW5kbGVyLCBkZWxldGVkQ29udGVudEl0ZW1zLCBkTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA1LiBhbGxvY2F0ZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBbaGVhZGNvbnRlbnQsIHRhaWxjb250ZW50XSA9IGFsbG9jYXRlQ29udGVudExpc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudGxpc3Q6dXBkYXRlZENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSB1cGRhdGVkQ29udGVudExpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gaGVhZGNvbnRlbnRcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRcblxuXG4gICAgICAgIGlmIChzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjaykge1xuXG4gICAgICAgICAgICBsZXQgY3N0YXRlID0gc3RhdGVIYW5kbGVyLmNyYWRsZVN0YXRlUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsJ3VwZGF0ZUNyYWRsZUNvbnRlbnQnLCBjc3RhdGUpXG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNi4gc2V0IGNzcyBjaGFuZ2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgaGVhZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvcFBvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5nYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQb3MgPSBzY3JvbGxQb3MgKyBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UG9zICsgJ3B4J1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuZ2FwICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlbmRlcnVwZGF0ZWRjb250ZW50JylcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT1bIFJFQ09ORklHVVJFIFRIRSBTQ1JPTExCTE9DSyBGT1IgVkFSSUFCTEUgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIGFsbCBET00gZWxlbWVudHMgc2hvdWxkIGhhdmUgYmVlbiByZW5kZXJlZCBhdCB0aGlzIHBvaW50XG4gICAgLy8gc2V0cyBDU1M6IHNjcm9sbGJsb2NrRWxlbWVudCB0b3AgYW5kIGhlaWdodCAob3IgbGVmdCBhbmQgd2lkdGgpLCBhbmQgYXhpc0VsZW1lbnQgdG9wIChvciBsZWZ0KVxuICAgIC8vIHRoaXMgdG8gZ2V0IGNsb3NlciB0byBuYXR1cmFsIHByb3BvcnRpb25zIHRvIG1pbmltaXplIGphbmt5IHNjcm9sbCB0aHVtYlxuICAgIHB1YmxpYyBhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5ID0gKHNvdXJjZSkgPT4ge1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIGJhc2UgdmFsdWVzIGFuZCByZWZlcmVuY2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXNvdXJjZXMuLi5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQYXJhbWV0ZXJzIH0gPSB0aGlzLFxuICAgICAgICAgICAgY3JhZGxlSGFuZGxlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXRIYW5kbGVyLCBzY3JvbGxIYW5kbGVyIH0gPSBjcmFkbGVIYW5kbGVycyxcbiAgICAgICAgICAgIHsgXG5cbiAgICAgICAgICAgICAgICBlbGVtZW50czogY3JhZGxlRWxlbWVudHMsIFxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YSBcblxuICAgICAgICAgICAgfSA9IGxheW91dEhhbmRsZXJcblxuICAgICAgICAvLyBlbGVtZW50IHJlZmVyZW5jZXMuLi5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQgPSB2aWV3cG9ydEVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIGhlYWRHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gY3VycmVudCBjb25maWd1cmF0aW9ucy4uLlxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6IGF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0OiBheGlzVmlld3BvcnRPZmZzZXQsXG5cbiAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG5cbiAgICAgICAgbGV0IHsgXG4gICAgICAgIFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgXG5cbiAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgZ2FwLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcblxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgbGlzdFJvd2NvdW50IFxuXG4gICAgICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHByZWN1cnNvciBjYWxjdWxhdGlvbnMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIHJvd2NvdW50cyBhbmQgcm93IG9mZnNldHMgZm9yIHBvc2l0aW9uaW5nXG4gICAgICAgIC8vIGxpc3RSb3djb3VudCB0YWtlbiBmcm9tIGludGVybmFsIHByb3BlcnRpZXMgYWJvdmVcbiAgICAgICAgY29uc3QgaGVhZFJvd0NvdW50ID0gTWF0aC5jZWlsKGhlYWRHcmlkRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aC9jcm9zc2NvdW50KSxcbiAgICAgICAgICAgIHRhaWxSb3dDb3VudCA9IE1hdGguY2VpbCh0YWlsR3JpZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgvY3Jvc3Njb3VudClcblxuICAgICAgICAvLyByZWZlcmVuY2Ugcm93cyAtIGNyYWRsZSBmaXJzdC9sYXN0OyBheGlzOyBsaXN0IGVuZFxuICAgICAgICBjb25zdCBheGlzUmVmZXJlbmNlUm93ID0gTWF0aC5jZWlsKGF4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KSxcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvdyA9IGF4aXNSZWZlcmVuY2VSb3cgLSBoZWFkUm93Q291bnQsXG4gICAgICAgICAgICBjcmFkbGVMYXN0UmVmZXJlbmNlUm93ID0gYXhpc1JlZmVyZW5jZVJvdyArICh0YWlsUm93Q291bnQgLSAxKSxcbiAgICAgICAgICAgIGxpc3RMYXN0UmVmZXJlbmNlUm93ID0gbGlzdFJvd2NvdW50IC0gMVxuXG4gICAgICAgIGNvbnN0IHByZUNyYWRsZVJvd0NvdW50ID0gY3JhZGxlUmVmZXJlbmNlUm93LFxuICAgICAgICAgICAgcG9zdENyYWRsZVJvd0NvdW50ID0gbGlzdExhc3RSZWZlcmVuY2VSb3cgLSBjcmFkbGVMYXN0UmVmZXJlbmNlUm93XG5cbiAgICAgICAgLy8gYmFzZSBwaXhlbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgYmFzZUNlbGxMZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGhcbiAgICAgICAgICAgICkgKyBnYXBcblxuICAgICAgICBjb25zdCBiYXNlSGVhZExlbmd0aCA9IChoZWFkUm93Q291bnQgKiBiYXNlQ2VsbExlbmd0aCkgKyBwYWRkaW5nXG5cbiAgICAgICAgLy8gbWVhc3VyZWQgcGl4ZWwgY3JhZGxlIGdyaWQgdmFsdWVzXG4gICAgICAgIGxldCBtZWFzdXJlZFRhaWxMZW5ndGhcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgbWVhc3VyZWRUYWlsTGVuZ3RoID0gdGFpbEdyaWRFbGVtZW50Lm9mZnNldEhlaWdodFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIG1lYXN1cmVkVGFpbExlbmd0aCA9IHRhaWxHcmlkRWxlbWVudC5vZmZzZXRXaWR0aFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmVDcmFkbGVQaXhlbExlbmd0aCA9IChwcmVDcmFkbGVSb3dDb3VudCAqIGJhc2VDZWxsTGVuZ3RoKSxcbiAgICAgICAgICAgIHBvc3RDcmFkbGVQaXhlbExlbmd0aCA9IHBvc3RDcmFkbGVSb3dDb3VudCAqIGJhc2VDZWxsTGVuZ3RoXG5cbiAgICAgICAgY29uc3QgY29tcHV0ZWRQb3N0QXhpc1BpeGVsTGVuZ3RoID0gcG9zdENyYWRsZVBpeGVsTGVuZ3RoICsgbWVhc3VyZWRUYWlsTGVuZ3RoXG5cbiAgICAgICAgLy8gYmFzZSBmaWd1cmVzIHVzZWQgZm9yIHByZUF4aXMgI3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCByZXBvc2l0aW9uaW5nLCB3aGljaCB1c2VzIGJhc2UgZmlndXJlc1xuICAgICAgICBjb25zdCBjb21wdXRlZFNjcm9sbGJsb2NrTGVuZ3RoID0gcHJlQ3JhZGxlUGl4ZWxMZW5ndGggKyBiYXNlSGVhZExlbmd0aCArIGNvbXB1dGVkUG9zdEF4aXNQaXhlbExlbmd0aFxuXG4gICAgICAgIGNvbnN0IGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGggPSAoKHByZUNyYWRsZVJvd0NvdW50ICsgaGVhZFJvd0NvdW50KSAqIGJhc2VDZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNoYW5nZSBjYWxjdWxhdGlvbnMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgdmFyaWFibGVBZGp1c3RtZW50ID0gYmxvY2tTY3JvbGxQb3MgKyBheGlzVmlld3BvcnRPZmZzZXQgLSBiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoXG5cbiAgICAgICAgLy8gY2hhbmdlIGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIGxldCByZXBvc2l0aW9uID0gZmFsc2VcbiAgICAgICAgaWYgKHNvdXJjZSA9PSAnYWZ0ZXJzY3JvbGwnKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUG9zIC09IHZhcmlhYmxlQWRqdXN0bWVudFxuXG4gICAgICAgICAgICByZXBvc2l0aW9uID0gdHJ1ZVxuIFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0F4aXNTY3JvbGxibG9ja09mZnNldCA9IGJsb2NrU2Nyb2xsUG9zICsgYXhpc1ZpZXdwb3J0T2Zmc2V0IC0gdmFyaWFibGVBZGp1c3RtZW50XG5cbiAgICAgICAgbGV0IHJlc2V0c2Nyb2xsID0gZmFsc2VcbiAgICAgICAgaWYgKGF4aXNSZWZlcmVuY2VSb3cgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlQWRqdXN0bWVudCA+IDAgfHwgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ID4gcGFkZGluZyApIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZUFkanVzdG1lbnQgPSAwXG4gICAgICAgICAgICAgICAgbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ID0gcGFkZGluZ1xuICAgICAgICAgICAgICAgIHJlc2V0c2Nyb2xsID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3U2Nyb2xsYmxvY2tMZW5ndGggPSBjb21wdXRlZFNjcm9sbGJsb2NrTGVuZ3RoICsgdmFyaWFibGVBZGp1c3RtZW50XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGFwcGxpY2F0aW9uIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY2hhbmdlIHNjcm9sbGJsb2NrRWxlbWVudCB0b3AgYW5kIGhlaWdodCwgb3IgbGVmdCBhbmQgd2lkdGgsXG4gICAgICAgIC8vICAgIGFuZCBheGlzRWxlbWVudCB0b3Agb3IgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAvLyB0aGUgc2Nyb2xsYmxvY2sgdG9wIGlzIG1vdmVkIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBjdW11bGF0aXZlIHZhcmlhYmlsaXR5XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gXG4gICAgICAgICAgICAgICAgIXZhcmlhYmxlQWRqdXN0bWVudD9cbiAgICAgICAgICAgICAgICAgICAgbnVsbDpcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVBZGp1c3RtZW50ICsgJ3B4J1xuICAgICAgICAgICAgLy8gdGhlIGF4aXMgaXMgbW92ZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byBtYWludGFpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gbmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBpcyBhZGp1c3RlZCBieSBib3RoIGRlbHRhcywgYXMgaXQgY29udHJvbHMgdGhlIHNjcm9sbCBsZW5ndGhcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBuZXdTY3JvbGxibG9ja0xlbmd0aCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IFxuICAgICAgICAgICAgICAgICF2YXJpYWJsZUFkanVzdG1lbnQ/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlQWRqdXN0bWVudCArICdweCdcbiAgICAgICAgICAgIC8vIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gdmFyaWFibGVBZGp1c3RtZW50ICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IG5ld0F4aXNTY3JvbGxibG9ja09mZnNldCArICdweCdcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld1Njcm9sbGJsb2NrTGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzZXRzY3JvbGwpIHsgLy8gdG9wIG9mIGxpc3RcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvKDAsMClcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSAwXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YSgwKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdXN0IGJlIGFmdGVyIGxlbmd0aCBpcyB1cGRhdGVkXG4gICAgICAgIGlmIChyZXBvc2l0aW9uKSB7IC8vIHJlc2V0IGJsb2NrU2Nyb2xsUG9zIGFmdGVyc2Nyb2xsXG5cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIucmVzZXRTY3JvbGxEYXRhKGJsb2NrU2Nyb2xsUG9zKVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gWyBJTlRFUk5BTCBDT05URU5UIE1BTkFHRU1FTlQgU0VSVklDRVMgXT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIGd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nID0gKCkgPT4geyBcblxuICAgICAgICBjb25zdCB7IGNhY2hlTWF4LCBNQVhfQ0FDSEVfT1ZFUl9SVU4gfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBtb2RlbENvbXBvbmVudExpc3QgPSB0aGlzLmNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzXG4gXG4gICAgICAgIGlmIChjYWNoZUhhbmRsZXIuZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcoY2FjaGVNYXgsIG1vZGVsQ29tcG9uZW50TGlzdC5sZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTiApKSB7XG5cbiAgICAgICAgICAgIHRoaXMucGFyZUNhY2hlVG9NYXgoKVxuXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcHVibGljIHBhcmVDYWNoZVRvTWF4ID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZSwgc2Nyb2xsZXJJRCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuICAgICAgICBcbiAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcblxuICAgICAgICAgICAgY29uc3QgY3JhZGxlSGFuZGxlcnMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVIYW5kbGVyc1xuXG4gICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IHRoaXMuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIucGFyZUNhY2hlVG9NYXgoXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5jYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2ssIHNjcm9sbGVySUQpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBFWFRFUk5BTCBTRVJWSUNFIFNVUFBPUlQgXT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdXBwb3J0cyBjbGVhckNhY2hlXG4gICAgcHVibGljIGNsZWFyQ3JhZGxlID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnRcbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSBbXVxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IFtdXG4gICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBzZXJ2aWNlSGFuZGxlciBnZXRDcmFkbGVJbmRleE1hcFxuICAgIC8vIGFsc28gc3VwcG9ydHMgcGFyZUNhY2hlVG9NYXgsIG1hdGNoQ2FjaGVUb0NyYWRsZVxuICAgIHB1YmxpYyBnZXRNb2RlbEluZGV4TGlzdCgpIHtcblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgaWYgKCFjcmFkbGVNb2RlbENvbXBvbmVudHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIFtdIFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBjcmFkbGVNb2RlbENvbXBvbmVudHMubWFwKChpdGVtKT0+aXRlbS5wcm9wcy5pbmRleClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBzZXJ2aWNlIGhhbmRsZXIncyByZW1hcEluZGV4ZXMsIGFzIGxhc3Qgc3RlcFxuICAgIHB1YmxpYyByZWNvbmNpbGVDZWxsRnJhbWVzKG1vZGlmaWVkSW5kZXhlc0xpc3QpIHtcblxuICAgICAgICBpZiAoIW1vZGlmaWVkSW5kZXhlc0xpc3QubGVuZ3RoKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGNvbXBvbmVudCwgaSwgYXJyYXkgKSB7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4LCBpdGVtSUQgfSA9IGNvbXBvbmVudC5wcm9wc1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkSW5kZXhlc0xpc3QuaW5jbHVkZXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtSUQgPSBcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmdldE5ld0l0ZW1JRCgpXG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbUlEICE9IGl0ZW1JRCkgeyAvLyBkZWZlbnNpdmU7IHNob3VsZG4ndCBoYXBwZW5cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUQ6bmV3SXRlbUlEfSlcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5mb3JFYWNoKHByb2Nlc3NDb21wb25lbnQpXG5cbiAgICAgICAgdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoMCx0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgIHRoaXMuY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG1vdmVJbmRleCBhbmQgaW5zZXJ0UmVtb3ZlSW5kZXhcbiAgICBwdWJsaWMgY2hhbmdlQ3JhZGxlSXRlbUlEcyhjaGFuZ2VMaXN0KSB7XG5cbiAgICAgICAgaWYgKGNoYW5nZUxpc3QubGVuZ3RoID09IDApIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAsIG1ldGFkYXRhTWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzY29tcG9uZW50KGNvbXBvbmVudCwgaSwgYXJyYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQucHJvcHMuaW5kZXhcblxuICAgICAgICAgICAgY29uc3QgcHRyID0gY2hhbmdlTGlzdC5pbmRleE9mKGluZGV4KVxuXG4gICAgICAgICAgICBpZiAocHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcblxuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5mb3JFYWNoKHByb2Nlc3Njb21wb25lbnQpXG5cbiAgICAgICAgdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoMCx0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgIHRoaXMuY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIGluc2VydFJlbW92ZUluZGV4XG4gICAgcHVibGljIGNyZWF0ZU5ld0l0ZW1JRHMobmV3TGlzdCkge1xuXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzY29tcG9uZW50KGNvbXBvbmVudCwgaSwgYXJyYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQucHJvcHMuaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHB0ciA9IG5ld0xpc3QuaW5kZXhPZihpbmRleClcblxuICAgICAgICAgICAgaWYgKHB0ciAhPSAtMSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld0l0ZW1JRCgpXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc2NvbXBvbmVudClcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG59Il0sIm5hbWVzIjpbIkNvbnRlbnRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImNyYWRsZU1vZGVsQ29tcG9uZW50cyIsImhlYWRNb2RlbENvbXBvbmVudHMiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwiaGVhZERpc3BsYXlDb21wb25lbnRzIiwidGFpbERpc3BsYXlDb21wb25lbnRzIiwiY3VycmVudCIsImNyYWRsZVN0YXRlIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImNyYWRsZUhhbmRsZXJzIiwiaGFuZGxlcnNSZWYiLCJjYWNoZUhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJpbnRlcnJ1cHRIYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyYWRsZUludGVyc2VjdCIsInNpZ25hbHMiLCJwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImNyYWRsZVBvc2l0aW9uRGF0YSIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjYWNoZSIsInNjcm9sbGVySUQiLCJzdHlsZXMiLCJsYXlvdXQiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJsaXN0Um93Y291bnQiLCJ3b3JraW5nUmVxdWVzdEF4aXNSZWZlcmVuY2VJbmRleCIsIk1hdGgiLCJtaW4iLCJpbmNsdWRlcyIsIndvcmtpbmdDb250ZW50TGlzdCIsImNyYWRsZUNvbnRlbnQiLCJjb250ZW50IiwiYmFzZVJvd0xlbmd0aCIsInRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4IiwiY3JhZGxlQ29udGVudENvdW50IiwibmV3Q3JhZGxlQ29udGVudENvdW50Iiwic2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0IiwidGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwic2Nyb2xsYmxvY2tFbGVtZW50IiwiZmlyc3RDaGlsZCIsImJhc2VsZW5ndGgiLCJzdHlsZSIsImxlZnQiLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsImF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiY3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsImluc3RhbmNlSWRDb3VudGVyUmVmIiwibmV3Y29udGVudGxpc3QiLCJkZWxldGVkaXRlbXMiLCJjb250ZW50bGlzdCIsImF4aXNSZWZlcmVuY2VJbmRleCIsImhlYWRjb250ZW50bGlzdCIsInRhaWxjb250ZW50bGlzdCIsImNhbGxiYWNrcyIsInJlZmVyZW5jZUluZGV4Q2FsbGJhY2siLCJjc3RhdGUiLCJibG9ja1Njcm9sbFBvcyIsInJlc2V0U2Nyb2xsRGF0YSIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiaGVhZEVsZW1lbnQiLCJoZWFkUmVmIiwiYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQiLCJwYWRkaW5nQm90dG9tIiwibGVuZ3RoIiwicGFkZGluZ1JpZ2h0IiwidHJpZ2dlcmxpbmVFbnRyaWVzIiwic291cmNlIiwic3RhdGVIYW5kbGVyIiwic2Nyb2xsRGF0YSIsInNjcm9sbFBvcyIsImN1cnJlbnR1cGRhdGUiLCJtb2RlbGNvbnRlbnRsaXN0Iiwib2xkQXhpc1JlZmVyZW5jZUluZGV4IiwiX2EiLCJwcm9wcyIsImluZGV4Iiwib2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJfYiIsInRyaWdnZXJsaW5lU3BhbiIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidHJpZ2dlcmNlbGxJc0luVGFpbCIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyRGF0YSIsIm5ld0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiY3JhZGxlSXRlbVNoaWZ0IiwiY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0IiwibmV3QXhpc1JlZmVyZW5jZUluZGV4IiwiYXhpc0l0ZW1TaGlmdCIsImF4aXNSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsInVwZGF0ZWRDb250ZW50TGlzdCIsImRlbGV0ZWRDb250ZW50SXRlbXMiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImhlYWRjb250ZW50IiwidGFpbGNvbnRlbnQiLCJjcmFkbGVTdGF0ZVJlZiIsInRvcFBvcyIsImxlZnRQb3MiLCJzZXRDcmFkbGVTdGF0ZSIsImhlYWRHcmlkRWxlbWVudCIsInRhaWxHcmlkRWxlbWVudCIsInRhaWxSZWYiLCJheGlzVmlld3BvcnRPZmZzZXQiLCJoZWFkUm93Q291bnQiLCJjZWlsIiwiY2hpbGROb2RlcyIsInRhaWxSb3dDb3VudCIsImF4aXNSZWZlcmVuY2VSb3ciLCJjcmFkbGVSZWZlcmVuY2VSb3ciLCJjcmFkbGVMYXN0UmVmZXJlbmNlUm93IiwibGlzdExhc3RSZWZlcmVuY2VSb3ciLCJwcmVDcmFkbGVSb3dDb3VudCIsInBvc3RDcmFkbGVSb3dDb3VudCIsImJhc2VDZWxsTGVuZ3RoIiwiYmFzZUhlYWRMZW5ndGgiLCJtZWFzdXJlZFRhaWxMZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInByZUNyYWRsZVBpeGVsTGVuZ3RoIiwicG9zdENyYWRsZVBpeGVsTGVuZ3RoIiwiY29tcHV0ZWRQb3N0QXhpc1BpeGVsTGVuZ3RoIiwiY29tcHV0ZWRTY3JvbGxibG9ja0xlbmd0aCIsImJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgiLCJ2YXJpYWJsZUFkanVzdG1lbnQiLCJyZXBvc2l0aW9uIiwibmV3QXhpc1Njcm9sbGJsb2NrT2Zmc2V0IiwicmVzZXRzY3JvbGwiLCJuZXdTY3JvbGxibG9ja0xlbmd0aCIsInNjcm9sbFRvIiwiY2FjaGVNYXgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJtb2RlbENvbXBvbmVudExpc3QiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInBhcmVDYWNoZVRvTWF4IiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXAiLCJpdGVtIiwibW9kaWZpZWRJbmRleGVzTGlzdCIsImluZGV4VG9JdGVtSURNYXAiLCJwcm9jZXNzQ29tcG9uZW50IiwiY29tcG9uZW50IiwiaSIsImFycmF5IiwiaXRlbUlEIiwibmV3SXRlbUlEIiwiaGFzIiwiZ2V0IiwiZ2V0TmV3SXRlbUlEIiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImZvckVhY2giLCJzbGljZSIsImNoYW5nZUxpc3QiLCJtZXRhZGF0YU1hcCIsInByb2Nlc3Njb21wb25lbnQiLCJwdHIiLCJpbmRleE9mIiwibmV3TGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n")},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(" // interrupthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleIntersectionObserverCallback // responds to move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback // responds to crossing of tailward and headward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing is handled by viewport\n    scrolling interrupts handled by scrollHandler\n*/\n\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, InterruptHandler);\n\n  this.isTailCradleInView = false;\n  this.isHeadCradleInView = false;\n\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n\n    var testrootbounds = entries[0].rootBounds;\n\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter.contentHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        scrollHandler = _this$cradleParameter.scrollHandler,\n        layoutHandler = _this$cradleParameter.layoutHandler;\n\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n      scrollData.previousupdate = scrollData.currentupdate;\n      scrollData.currentupdate = scrollData.current;\n      contentHandler.updateCradleContent(entries, 'triggerlinesObserver');\n    }\n  };\n\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var _a;\n\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter2.stateHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler,\n        scrollHandler = _this$cradleParameter2.scrollHandler,\n        layoutHandler = _this$cradleParameter2.layoutHandler;\n\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.type == 'head') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n\n    if (_this.signals.repositioningRequired) // start reposition if no other interrupts are underway\n      {\n        var cradleState = stateHandler.cradleStateRef.current;\n\n        if (!((_a = ViewportContextProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) && !(cradleState == 'repositioningRender') && !(cradleState == 'repositioningContinuation') && !(cradleState == 'finishreposition') && !(cradleState == 'renderupdatedcontent') && !(cradleState == 'finishupdatedcontent') && // !(cradleState == 'adjustupdateforvariability') &&\n        // !(cradleState == 'adjustupdateforvariabilityafterscroll') &&\n        !ViewportContextProperties.isResizing && !(cradleState == 'finishviewportresize')) {\n          var viewportElement = ViewportContextProperties.elementRef.current;\n          var _this$cradleParameter3 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n              scrollerID = _this$cradleParameter3.scrollerID,\n              orientation = _this$cradleParameter3.orientation,\n              padding = _this$cradleParameter3.padding,\n              gap = _this$cradleParameter3.gap,\n              cellHeight = _this$cradleParameter3.cellHeight,\n              cellWidth = _this$cradleParameter3.cellWidth,\n              layout = _this$cradleParameter3.layout;\n\n          if (!viewportElement) {\n            console.log('SYSTEM: viewport element not set in cradleIntersectionObserverCallback', scrollerID, ViewportContextProperties);\n            return;\n          }\n\n          var _this$cradleParameter4 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n              listRowcount = _this$cradleParameter4.listRowcount,\n              crosscount = _this$cradleParameter4.crosscount; // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n\n          var rect = viewportElement.getBoundingClientRect();\n          var top = rect.top,\n              right = rect.right,\n              bottom = rect.bottom,\n              left = rect.left;\n          var width = right - left,\n              height = bottom - top; // update for scrolltracker\n\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n\n          if (layout == 'variable') {\n            // restore base config to scrollblock\n            layoutHandler.restoreBaseScrollblockConfig();\n          }\n\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState('startreposition');\n        }\n      }\n  };\n\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n\n\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2ludGVycnVwdGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0lBV3FCQSxnQiw2QkFFakIsMEJBQVlDLGdCQUFaLEVBQTRCO0VBQUE7O0VBQUE7O0VBUXBCLDBCQUFxQixLQUFyQjtFQUNBLDBCQUFxQixLQUFyQjs7RUFFQSx3Q0FBbUMsVUFBQ0MsT0FBRCxFQUFZO0lBRW5ELElBQUksS0FBSSxDQUFDQyxPQUFMLENBQWFDLHlCQUFqQixFQUE0QztNQUV4QztJQUVIOztJQUVELElBQU1DLGNBQWMsR0FBR0gsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXSSxVQUFsQzs7SUFDQSxJQUFLRCxjQUFjLENBQUNFLEtBQWYsSUFBd0IsQ0FBekIsSUFBZ0NGLGNBQWMsQ0FBQ0csTUFBZixJQUF5QixDQUE3RCxFQUFpRTtNQUFFO01BRS9EO0lBRUg7O0lBRUQsNEJBS0ksS0FBSSxDQUFDUCxnQkFBTCxDQUFzQlEsV0FBdEIsQ0FBa0NDLE9BTHRDO0lBQUEsSUFDSUMsY0FESix5QkFDSUEsY0FESjtJQUFBLElBRUlDLFlBRkoseUJBRUlBLFlBRko7SUFBQSxJQUdJQyxhQUhKLHlCQUdJQSxhQUhKO0lBQUEsSUFJSUMsYUFKSix5QkFJSUEsYUFKSjs7SUFPQSxJQUFJRixZQUFZLENBQUNHLFlBQWIsQ0FBMEJMLE9BQTlCLEVBQXVDO01BQ25DLElBQVFNLFVBQVIsR0FBdUJILGFBQXZCLENBQVFHLFVBQVI7TUFFQUEsVUFBVSxDQUFDQyxjQUFYLEdBQTRCRCxVQUFVLENBQUNFLGFBQXZDO01BQ0FGLFVBQVUsQ0FBQ0UsYUFBWCxHQUEyQkYsVUFBVSxDQUFDTixPQUF0QztNQUVBQyxjQUFjLENBQUNRLG1CQUFmLENBQW1DakIsT0FBbkMsRUFBMkMsc0JBQTNDO0lBRUg7RUFDSixDQS9CTzs7RUFpQ0EsMENBQXFDLFVBQUNBLE9BQUQsRUFBWTs7O0lBRXJELElBQU1DLE9BQU8sR0FBRyxLQUFJ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QUFSLEdBQWdDLElBQWhDO0VBQ0gsQ0FOTTtFQU9QOzs7Ozs7O0VBS08seUJBQW9CLFlBQUs7SUFDNUIsSUFBUWpGLE9BQVIsR0FBb0IsS0FBcEIsQ0FBUUEsT0FBUjtJQUNBQSxPQUFPLENBQUNDLHlCQUFSLEdBQW9DLEtBQXBDO0lBQ0FELE9BQU8sQ0FBQ2tCLCtCQUFSLEdBQTBDLEtBQTFDO0lBQ0FsQixPQUFPLENBQUNnRix5QkFBUixHQUFvQyxLQUFwQztJQUNBaEYsT0FBTyxDQUFDaUYscUJBQVIsR0FBZ0MsS0FBaEM7RUFDSCxDQU5NOztFQXROSixLQUFLbkYsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUVGLEM7O0FBTkxvRixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBDcmFkbGUgc3RydWN0dXJlIGxpc3RlbmVyczpcbiAgICAtIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgLy8gcmVzcG9uZHMgdG8gbW92ZSBvZiBib3RoIGNyYWRsZSBncmlkcyBvdXRzaWRlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMgaW5pdGlhdGVzIHRoZSByZXBvc2l0aW9uaW5nIHByb3RvY29sXG4gICAgLSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayAvLyByZXNwb25kcyB0byBjcm9zc2luZyBvZiB0YWlsd2FyZCBhbmQgaGVhZHdhcmQgdHJpZ2dlcmxpbmVzXG4gICAgICAgIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydCwgYW5kIHRyaWdnZXJzIHJvbGxvdmVyIGFuZCByZS1hbGxvY2F0aW9uIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICB2aWV3cG9ydFJlc2l6aW5nIGlzIGhhbmRsZWQgYnkgdmlld3BvcnRcbiAgICBzY3JvbGxpbmcgaW50ZXJydXB0cyBoYW5kbGVkIGJ5IHNjcm9sbEhhbmRsZXJcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVycnVwdEhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwcml2YXRlIGlzVGFpbENyYWRsZUluVmlldyA9IGZhbHNlXG4gICAgcHJpdmF0ZSBpc0hlYWRDcmFkbGVJblZpZXcgPSBmYWxzZVxuXG4gICAgcHJpdmF0ZSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyKSB7IFxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdHJvb3Rib3VuZHMgPSBlbnRyaWVzWzBdLnJvb3RCb3VuZHNcbiAgICAgICAgaWYgKCh0ZXN0cm9vdGJvdW5kcy53aWR0aCA9PSAwKSAmJiAodGVzdHJvb3Rib3VuZHMuaGVpZ2h0ID09IDApKSB7IC8vIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbERhdGEgfSA9IHNjcm9sbEhhbmRsZXJcblxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZVxuICAgICAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50XG5cbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnVwZGF0ZUNyYWRsZUNvbnRlbnQoZW50cmllcywndHJpZ2dlcmxpbmVzT2JzZXJ2ZXInKVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNpZ25hbHMgPSB0aGlzLnNpZ25hbHNcbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLCBcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsIFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlciBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWRDcmFkbGVJblZpZXcgPSBcbiAgICAgICAgICAgICAgICAgICAgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUYWlsQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyAgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGVudHJ5LnJvb3RCb3VuZHMud2lkdGggPT0gMCkgJiYgKGVudHJ5LnJvb3RCb3VuZHMuaGVpZ2h0ID09IDApKSAvLyByZXBhcmVudGluZ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSAoIXRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ICYmICF0aGlzLmlzVGFpbENyYWRsZUluVmlldylcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkKSAvLyBzdGFydCByZXBvc2l0aW9uIGlmIG5vIG90aGVyIGludGVycnVwdHMgYXJlIHVuZGVyd2F5XG4gICAgICAgIHtcblxuICAgICAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZj8uY3VycmVudCAmJlxuXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpICYmIFxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSAmJlxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ2ZpbmlzaHJlcG9zaXRpb24nKSAmJiBcblxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ3JlbmRlcnVwZGF0ZWRjb250ZW50JykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAnZmluaXNodXBkYXRlZGNvbnRlbnQnKSAmJlxuXG4gICAgICAgICAgICAgICAgLy8gIShjcmFkbGVTdGF0ZSA9PSAnYWRqdXN0dXBkYXRlZm9ydmFyaWFiaWxpdHknKSAmJlxuICAgICAgICAgICAgICAgIC8vICEoY3JhZGxlU3RhdGUgPT0gJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5YWZ0ZXJzY3JvbGwnKSAmJlxuXG4gICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZyAmJlxuICAgICAgICAgICAgICAgICEoY3JhZGxlU3RhdGUgPT0gJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJylcblxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCwgXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgXG5cbiAgICAgICAgICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTWVNURU06IHZpZXdwb3J0IGVsZW1lbnQgbm90IHNldCBpbiBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySUQsVmlld3BvcnRDb250ZXh0UHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGlzdFJvd2NvdW50LCBjcm9zc2NvdW50IH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZGltZW5zaW9ucyB3aXRoIGNyYWRsZSBpbnRlcnNlY3Rpb24uIFNlZSBhbHNvIGRpbWVuc2lvbiB1cGRhdGUgaW4gdmlld3BvcnQudHN4IGZvciByZXNpemVcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gdmlld3BvcnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgY29uc3Qge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSByZWN0XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb3Igc2Nyb2xsdHJhY2tlclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zID0ge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0gXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayh0cnVlKVxuXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndmFyaWFibGUnKSB7IC8vIHJlc3RvcmUgYmFzZSBjb25maWcgdG8gc2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLnJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdzdGFydHJlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgcHVibGljIGNyYWRsZUludGVyc2VjdCA9IHsgICAgXG4gICAgICAgIG9ic2VydmVyOm51bGwsICAgIFxuICAgICAgICBjYWxsYmFjazp0aGlzLmNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2ssXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICB7cm9vdDpWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCwgdGhyZXNob2xkOjB9XG4gICAgICAgICAgICApICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgIHB1YmxpYyB0cmlnZ2VybGluZXNJbnRlcnNlY3QgPSB7XG4gICAgICAgIG9ic2VydmVyOm51bGwsXG4gICAgICAgIGNhbGxiYWNrOnRoaXMuYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2ssXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIGlmIChjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICB7cm9vdDpWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCwgdGhyZXNob2xkOjB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3Qub2JzZXJ2ZXJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzaWduYWxzID0ge1xuICAgICAgICByZXBvc2l0aW9uaW5nUmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyOiBmYWxzZSwgXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI6ZmFsc2UsXG4gICAgICAgIHBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgICAgICBwYXVzZVNjcm9sbGluZ0VmZmVjdHM6IGZhbHNlLFxuICAgIH1cblxuICAgIC8qXG4gICAgICAgIGludm9rZWQgZm9yIFxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gY2hhbmdlIGludG8gY2FjaGVcbiAgICAgICAgLSB0cmlnZ2VyIGNyYWRsZXJlc2l6aW5nXG4gICAgICAgIC0gdHJpZ2dlciByZWNvbmZpZ3VyYXRpb25cbiAgICAgICAgLSB0cmlnZ2VyIHBpdm90XG4gICAgICAgIHNlcnZpY2VoYW5kbGVyOlxuICAgICAgICAtIGNhbGwgcmVsb2FkXG4gICAgKi9cbiAgICBwdWJsaWMgcGF1c2VJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXNcbiAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSB0cnVlXG4gICAgfVxuICAgIC8qXG4gICAgICAgIGludm9rZWQgZm9yXG4gICAgICAgIGNyYWRsZTpcbiAgICAgICAgLSByZXN0b3JlaW50ZXJydXB0c1xuICAgICovXG4gICAgcHVibGljIHJlc3RvcmVJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXNcbiAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSBmYWxzZVxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbIkludGVycnVwdEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiZW50cmllcyIsInNpZ25hbHMiLCJwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyIiwidGVzdHJvb3Rib3VuZHMiLCJyb290Qm91bmRzIiwid2lkdGgiLCJoZWlnaHQiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJjb250ZW50SGFuZGxlciIsInN0YXRlSGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwiaXNNb3VudGVkUmVmIiwic2Nyb2xsRGF0YSIsInByZXZpb3VzdXBkYXRlIiwiY3VycmVudHVwZGF0ZSIsInVwZGF0ZUNyYWRsZUNvbnRlbnQiLCJzZXJ2aWNlSGFuZGxlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpIiwibGVuZ3RoIiwiZW50cnkiLCJ0YXJnZXQiLCJkYXRhc2V0IiwidHlwZSIsImlzSGVhZENyYWRsZUluVmlldyIsImlzSW50ZXJzZWN0aW5nIiwiaXNUYWlsQ3JhZGxlSW5WaWV3IiwicmVwb3NpdGlvbmluZ1JlcXVpcmVkIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaXNSZXBhcmVudGluZ1JlZiIsIl9hIiwiaXNSZXNpemluZyIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwic2Nyb2xsZXJJRCIsIm9yaWVudGF0aW9uIiwicGFkZGluZyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJjb25zb2xlIiwibG9nIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwibGlzdFJvd2NvdW50IiwiY3Jvc3Njb3VudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiY2FsbGJhY2tzIiwicmVzdG9yZUJhc2VTY3JvbGxibG9ja0NvbmZpZyIsInNldENyYWRsZVN0YXRlIiwib2JzZXJ2ZXIiLCJjYWxsYmFjayIsImNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2siLCJjb25uZWN0RWxlbWVudHMiLCJjcmFkbGVJbnRlcnNlY3QiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwib2JzZXJ2ZSIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiY3JlYXRlT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3QiLCJ0aHJlc2hvbGQiLCJheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYiLCJwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n")},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // layouthandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the head and tail triggerlines\n    The key control values are the blockScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferenceIndex (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\n\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    var _this = this;\n\n    _classCallCheck(this, LayoutHandler);\n\n    this.triggercellIsInTail = false; // cradlePositionData controls the relative positions of the scaffold elements\n\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToItem call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // into the viewport\n\n    }; // called by interruptHandler\n\n    this.restoreBaseScrollblockConfig = function () {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var scrollblockElement = viewportElement.firstChild;\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n          orientation = _this$cradleParameter.orientation,\n          padding = _this$cradleParameter.padding,\n          gap = _this$cradleParameter.gap,\n          cellHeight = _this$cradleParameter.cellHeight,\n          cellWidth = _this$cradleParameter.cellWidth;\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInternalPropertiesRef.current,\n          listRowcount = _this$cradleParameter2.listRowcount,\n          crosscount = _this$cradleParameter2.crosscount;\n      var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n          scrollHandler = _this$cradleParameter3.scrollHandler,\n          layoutHandler = _this$cradleParameter3.layoutHandler;\n      var cellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var baselength = listRowcount * cellLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var axisReference = cradlePositionData.targetAxisReferenceIndex;\n      var rowOffset = Math.ceil(axisReference / crosscount);\n      var calculatedBlockScrollPos = rowOffset * cellLength + padding;\n      viewportElement[cradlePositionData.blockScrollProperty] = calculatedBlockScrollPos;\n      cradlePositionData.blockScrollPos = calculatedBlockScrollPos;\n      scrollHandler.resetScrollData(calculatedBlockScrollPos);\n      scrollHandler.calcImpliedRepositioningData();\n    };\n\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n        axisRef = _cradleParameters$cra.axisRef,\n        headRef = _cradleParameters$cra.headRef,\n        tailRef = _cradleParameters$cra.tailRef,\n        triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n        triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // progression of references: implied->target\n\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      var span = orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop : // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n      return span;\n    }\n  }]);\n\n  return LayoutHandler;\n}();\n\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2xheW91dGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7SUFhcUJBLGE7RUFFakIsdUJBQVlDLGdCQUFaLEVBQTRCO0lBQUE7O0lBQUE7O0lBd0RyQiwyQkFBc0IsS0FBdEIsQ0F4RHFCLENBMEQ1Qjs7SUFDTywwQkFBcUI7TUFFeEI7Ozs7Ozs7O01BV0FDLGNBQWMsRUFBQyxJQWJTOztNQWV4Qjs7Ozs7TUFPQUMsbUJBQW1CLEVBQUMsSUF0Qkk7O01Bd0J4Qjs7Ozs7Ozs7Ozs7TUFZQUMsd0JBQXdCLEVBQUMsSUFwQ0Q7O01Bc0N4Qjs7Ozs7Ozs7Ozs7TUFhQUMsNkJBQTZCLEVBQUMsSUFuRE4sQ0FtRFk7O0lBbkRaLENBQXJCLENBM0RxQixDQWtINUI7O0lBQ08sb0NBQStCLFlBQUs7TUFFdkMsSUFBTUMseUJBQXlCLEdBQUcsS0FBSSxDQUFDTCxnQkFBTCxDQUFzQk0sNEJBQXRCLENBQW1EQyxPQUFyRjtNQUNBLElBQU1DLGVBQWUsR0FBR0gseUJBQXlCLENBQUNJLFVBQTFCLENBQXFDRixPQUE3RDtNQUNBLElBQU1HLGtCQUFrQixHQUFHRixlQUFlLENBQUNHLFVBQTNDO01BRUEsNEJBVUksS0FBSSxDQUFDWCxnQkFBTCxDQUFzQlksNEJBQXRCLENBQW1ETCxPQVZ2RDtNQUFBLElBR0lNLFdBSEoseUJBR0lBLFdBSEo7TUFBQSxJQUlJQyxPQUpKLHlCQUlJQSxPQUpKO01BQUEsSUFLSUMsR0FMSix5QkFLSUEsR0FMSjtNQUFBLElBTUlDLFVBTkoseUJBTUlBLFVBTko7TUFBQSxJQU9JQyxTQVBKLHlCQU9JQSxTQVBKO01BWUEsNkJBR0ksS0FBSSxDQUFDakIsZ0JBQUwsQ0FBc0JrQiwyQkFBdEIsQ0FBa0RYLE9BSHREO01BQUEsSUFDSVksWUFESiwwQkFDSUEsWUFESjtNQUFBLElBRUlDLFVBRkosMEJBRUlBLFVBRko7TUFLQSw2QkFPSSxLQUFJLENBQUNwQixnQkFB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LE9BQTVDLENBQW9EMkMsU0FBcEQsR0FDQSxLQUFLTCxRQUFMLENBQWNGLDZCQUFkLENBQTRDcEMsT0FBNUMsQ0FBb0QyQyxTQUYzQyxHQUdUO01BQ0EsS0FBS0wsUUFBTCxDQUFjRCw2QkFBZCxDQUE0Q3JDLE9BQTVDLENBQW9ENEMsVUFBcEQsR0FDQSxLQUFLTixRQUFMLENBQWNGLDZCQUFkLENBQTRDcEMsT0FBNUMsQ0FBb0Q0QyxVQUx4RDtNQU9BLE9BQU9GLElBQVA7SUFDSDs7Ozs7O0FBdkRMRyxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9sYXlvdXRoYW5kbGVyLnRzeD8wN2JmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxheW91dGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHJlZmVyZW5jZXMgdG8gXG4gICAgLSB0aGUgc3RydWN0dXJhbCBlbGVtZW50cyBvZiB0aGUgY3JhZGxlXG4gICAgLSB0aGUga2V5IGNvbnRyb2wgdmFsdWVzIG9mIHRoZSBjcmFkbGVcblxuICAgIFRoZSBzdHJ1Y3R1cmFsIGVsZW1lbnRzIGFyZSB0aGUgYXhpcywgaGVhZCAoZ3JpZCksIHRhaWwgKGdyaWQpLCBcbiAgICAgICAgYW5kIHRoZSBoZWFkIGFuZCB0YWlsIHRyaWdnZXJsaW5lc1xuICAgIFRoZSBrZXkgY29udHJvbCB2YWx1ZXMgYXJlIHRoZSBibG9ja1Njcm9sbFBvcyAoc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQpLCB0aGUgYmxvY2sgc2Nyb2xsXG4gICAgICAgIHByb3BlcnR5IChcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiKSwgdGhlIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAoZmlyc3QgaW5kZXggb2YgdGhlXG4gICAgICAgIHRhaWwgYmxvY2spLCBhbmQgdGhlIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IChwaXhlbHMgb2Zmc2V0IGZyb20gdGhlIGVkZ2Ugb2YgdGhlIFxuICAgICAgICB2aWV3cG9ydClcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheW91dEhhbmRsZXIgeyBcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYXhpc1JlZiwgXG4gICAgICAgICAgICBoZWFkUmVmLCBcbiAgICAgICAgICAgIHRhaWxSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLFxuICAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5jcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnRzID0ge1xuICAgICAgICAgICAgYXhpc1JlZixcbiAgICAgICAgICAgIGhlYWRSZWYsXG4gICAgICAgICAgICB0YWlsUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZixcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gcHJvZ3Jlc3Npb24gb2YgcmVmZXJlbmNlczogaW1wbGllZC0+dGFyZ2V0XG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IFxuICAgICAgICAgICAgKE1hdGgubWluKHN0YXJ0aW5nSW5kZXgsKGxpc3RzaXplIC0gMSkpIHx8IDApXG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gMFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0IHRyaWdnZXJsaW5lU3BhbigpIHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudC5vZmZzZXRUb3AgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0TGVmdCAtIFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50Lm9mZnNldExlZnRcblxuICAgICAgICByZXR1cm4gc3BhblxuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbEluZGV4XG4gICAgcHVibGljIHRyaWdnZXJjZWxsSXNJblRhaWwgPSBmYWxzZVxuXG4gICAgLy8gY3JhZGxlUG9zaXRpb25EYXRhIGNvbnRyb2xzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgdGhlIHNjYWZmb2xkIGVsZW1lbnRzXG4gICAgcHVibGljIGNyYWRsZVBvc2l0aW9uRGF0YSA9IHtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgXCJibG9ja1wiID0gY3JhZGxlYmxvY2ssIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRoYXQgaXMgc2Nyb2xsZWRcblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgc2V0IGJ5IHNjcm9sbEhhbmRsZXIgZHVyaW5nIGFuZCBhZnRlciBzY3JvbGxpbmcsXG4gICAgICAgICAgICBhbmQgYnkgc2V0Q3JhZGxlQ29udGVudCBpbiBjb250ZW50SGFuZGxlciwgd2hpY2ggcmVwb3NpdGlvbnMgdGhlIGNyYWRsZS5cblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gY3JhZGxlIGluaXRpYWxpemF0aW9uIGluIHJlc3BvbnNlIHRvIHJlcGFyZW50aW5nIGludGVycnVwdFxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuXG4gICAgICAgICovXG4gICAgICAgIGJsb2NrU2Nyb2xsUG9zOm51bGwsIC8vIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB2YWx1ZXMgY2FuIGJlIFwic2Nyb2xsVG9wXCIgb3IgXCJzY3JvbGxMZWZ0XCIgKG9mIHRoZSB2aWV3cG9ydCBlbGVtZW50KSBkZXBlbmRpbmcgb24gb3JpZW50YXRpb25cblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQcm9wZXJ0eSBpcyBzZXQgYnkgdGhlIG9yaWVudGF0aW9uIHJlY29uZmlndXJhdGlvbiBlZmZlY3QgaW4gY3JhZGxlIG1vZHVsZS5cblxuICAgICAgICAgICAgaXQgaXMgdXNlZCB3aGVyZSBibG9ja1Njcm9sbFBvcyBpcyB1c2VkIGFib3ZlLlxuICAgICAgICAqL1xuICAgICAgICBibG9ja1Njcm9sbFByb3BlcnR5Om51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCBpcyBzZXQgYnlcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIGxheW91dEhhbmRsZXIgKGluaXRpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsSGFuZGxlciAoZHVyaW5nIGFuZCBhZnRlciBzY3JvbGwpXG4gICAgICAgICAgICAgICAgLSBob3N0IHNjcm9sbFRvSXRlbSBjYWxsXG5cbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCBpcyB1c2VkIGJ5XG4gICAgICAgICAgICAgICAgLSBzY3JvbGxUcmFja2VyQXJncyBpbiBjcmFkbGUgbW9kdWxlXG4gICAgICAgICAgICAgICAgLSByZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXggaW4gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAqL1xuICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6bnVsbCxcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgaXMgc2V0IGJ5XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSB1cGRhdGVDcmFkbGVDb250ZW50XG4gICAgICAgICAgICAgICAgLSBsYXlvdXRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gcGl2b3QgZWZmZWN0IChjaGFuZ2Ugb2Ygb3JpZW50YXRpb24pIGluIGNyYWRsZSBtb2R1bGVcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gcHJldmlvdXNBeGlzT2Zmc2V0IGluIHBpdm90IGVmZmVjdFxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuXG4gICAgICAgICovXG4gICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Om51bGwsIC8vIGludG8gdGhlIHZpZXdwb3J0XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgYnkgaW50ZXJydXB0SGFuZGxlclxuICAgIHB1YmxpYyByZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgLy8gc2Nyb2xsZXJJRCwgXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAvLyBsYXlvdXQgXG5cbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgLy8gc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIC8vIHNlcnZpY2VIYW5kbGVyLCBcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsIFxuICAgICAgICAgICAgbGF5b3V0SGFuZGxlciBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjZWxsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3RSb3djb3VudCAqIGNlbGxMZW5ndGgpIC0gZ2FwIC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgKyAocGFkZGluZyAqIDIpIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBhZGRpbmdcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUudG9wID0gbnVsbFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmhlaWdodCA9IGJhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUud2lkdGggPSBiYXNlbGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuICAgICAgICBjb25zdCBheGlzUmVmZXJlbmNlID0gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjb25zdCByb3dPZmZzZXQgPSBNYXRoLmNlaWwoYXhpc1JlZmVyZW5jZS9jcm9zc2NvdW50KVxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MgPSBcbiAgICAgICAgICAgIChyb3dPZmZzZXQgKiBjZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gY2FsY3VsYXRlZEJsb2NrU2Nyb2xsUG9zXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvc1xuICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YShjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MpXG4gICAgICAgIFxuICAgICAgICBzY3JvbGxIYW5kbGVyLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEoKVxuXG4gICAgfVxuXG4gICAgcHVibGljIGVsZW1lbnRzXG5cbn0iXSwibmFtZXMiOlsiTGF5b3V0SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsIm9yaWVudGF0aW9uIiwicGFkZGluZyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJsaXN0Um93Y291bnQiLCJjcm9zc2NvdW50IiwiaGFuZGxlcnNSZWYiLCJzY3JvbGxIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsImNlbGxMZW5ndGgiLCJiYXNlbGVuZ3RoIiwic3R5bGUiLCJ0b3AiLCJoZWlnaHQiLCJsZWZ0Iiwid2lkdGgiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJheGlzUmVmZXJlbmNlIiwicm93T2Zmc2V0IiwiTWF0aCIsImNlaWwiLCJjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MiLCJyZXNldFNjcm9sbERhdGEiLCJjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhIiwiY3JhZGxlRWxlbWVudHNSZWYiLCJheGlzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmIiwiZWxlbWVudHMiLCJzdGFydGluZ0luZGV4IiwibGlzdHNpemUiLCJtaW4iLCJzcGFuIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(" // scrollhandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferenceIndex, and\n        targetAxisViewportPixelOffset\n*/\n\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ScrollHandler);\n\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        scrollerID = _this$cradleParameter.scrollerID,\n        SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _this$cradleParameter.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var scrollPositionCurrent = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData; // keep up to date in case of reparenting interrupt\n\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter2.contentHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler;\n\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        _this.calcImpliedRepositioningData();\n\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n    return false;\n  };\n\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter3.stateHandler,\n        contentHandler = _this$cradleParameter3.contentHandler,\n        serviceHandler = _this$cradleParameter3.serviceHandler;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n\n          break;\n        }\n    }\n\n    var cache = cradleInheritedProperties.cache,\n        layout = cradleInheritedProperties.layout;\n\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n\n    if (!['repositioningRender', 'repositioningContinuation'].includes(cradleState) && layout == 'variable') {\n      // TODO check reasoning for this\n      if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n        stateHandler.setCradleState('adjustupdateforvariabilityafterscroll');\n      }\n    }\n  }; // after scroll, but not after repositioning\n\n\n  this.updateReferenceData = function () {\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter4.stateHandler,\n        layoutHandler = _this$cradleParameter4.layoutHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current,\n        viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild;\n    var axisVisiblePixelOffset;\n\n    if (cradleProps.orientation == 'vertical') {\n      axisVisiblePixelOffset = axisElement.offsetTop + scrollblockElement.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisVisiblePixelOffset = axisElement.offsetLeft + scrollblockElement.offsetLeft - viewportElement.scrollLeft;\n    }\n\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisVisiblePixelOffset;\n\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  }; // called from finishreposition state change call above\n  // called from updateReferenceData\n\n\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n      }\n    }\n  };\n\n  this.calcImpliedRepositioningData = function () {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n        cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild;\n    var crosscount = cradleConfig.crosscount,\n        listsize = cradleConfig.listsize,\n        orientation = cradleProps.orientation;\n    var scrollPos, cellLength, scrollblockOffset;\n\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n\n    var axisPixelOffset = cellLength - (scrollPos + scrollblockOffset) % cellLength;\n\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n    var repositioningIndexCallback = _this.cradleParameters.handlersRef.current.serviceHandler.callbacks.repositioningIndexCallback;\n    repositioningIndexCallback && repositioningIndexCallback(axisReferenceIndex);\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3Njcm9sbGhhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztJQU1xQkEsYSw2QkFFakIsdUJBQVlDLGdCQUFaLEVBQTRCO0VBQUE7O0VBQUE7O0VBUXJCLGtCQUFhO0lBQUNDLEtBQUssRUFBQyxDQUFQO0lBQVVDLE9BQU8sRUFBQyxDQUFsQjtJQUFxQkMsUUFBUSxFQUFDLENBQTlCO0lBQWlDQyxjQUFjLEVBQUMsQ0FBaEQ7SUFBbURDLGFBQWEsRUFBQztFQUFqRSxDQUFiO0VBRUMsc0JBQWlCLElBQWpCO0VBRUEsbUJBQWMsS0FBZDs7RUFFRCx1QkFBa0IsVUFBQ0MsY0FBRCxFQUFtQjtJQUN4QyxJQUFRQyxVQUFSLEdBQXVCLEtBQXZCLENBQVFBLFVBQVI7SUFDQUEsVUFBVSxDQUFDTixLQUFYLEdBQ0FNLFVBQVUsQ0FBQ0wsT0FBWCxHQUNBSyxVQUFVLENBQUNKLFFBQVgsR0FDQUksVUFBVSxDQUFDSCxjQUFYLEdBQ0FHLFVBQVUsQ0FBQ0YsYUFBWCxHQUEyQkMsY0FKM0I7RUFLSCxDQVBNOztFQVNBLGdCQUFXLFVBQUNFLENBQUQsRUFBTTtJQUVwQiw0QkFBeUQsS0FBSSxDQUFDUixnQkFBTCxDQUFzQlMsNEJBQXRCLENBQW1EUCxPQUE1RztJQUFBLElBQVFRLFVBQVIseUJBQVFBLFVBQVI7SUFBQSxJQUFvQkMsZ0NBQXBCLHlCQUFvQkEsZ0NBQXBCO0lBRUEsSUFBTUMseUJBQXlCLEdBQUcsS0FBSSxDQUFDWixnQkFBTCxDQUFzQmEsNEJBQXRCLENBQW1EWCxPQUFyRjtJQUNBLElBQU1ZLGVBQWUsR0FBR0YseUJBQXlCLENBQUNHLFVBQTFCLENBQXFDYixPQUE3RDtJQUVBLElBQU1jLHFCQUFxQixHQUN0QixLQUFJLENBQUNoQixnQkFBTCxDQUFzQlMsNEJBQXRCLENBQW1EUCxPQUFuRCxDQUEyRGUsV0FBM0QsSUFBMEUsVUFBM0UsR0FDSUgsZUFBZSxDQUFDSSxTQURwQixHQUVJSixlQUFlLENBQUNLLFVBSHhCO0lBS0FDLFlBQVksQ0FBQyxLQUFJLENBQUNDLGNBQU4sQ0FBWjs7SUFFQSxJQUFLUCxlQUFlLENBQUNRLFdBQWhCLElBQStCLENBQS9CLElBQXFDUixlQUFlLENBQUNTLFlBQWhCLElBQWdDLENBQTFFLEVBQThFO01BQUM7TUFFM0U7SUFFSDs7SUFFRCxJQUFJUCxxQkFBcUIsR0FBRyxDQUE1QixFQUErQjtNQUFFO01BRTdCO0lBRUg7O0lBRUQsSUFBT1EsT0FBUCxHQUFrQixLQUFJLENBQUN4QixnQkFBTCxDQUFzQnlCLFdBQXRCLENBQWtDdkIsT0FBbEMsQ0FBMEN3QixnQkFBNUQsQ0FBT0YsT0FBUDs7SUFFQSxJQUFJQSxPQUFPLENBQUNHLHFCQUFaLEVBQW1DO01BRS9CO0lBRUg7O0lBRUQsSUFBSSxDQUFDLEtBQUksQ0FBQ0MsV0FBVixFQUF1QjtNQUVuQixLQUFJLENBQUNBLFdBQUwsR0FBbUIsSUFBbkI7TUFDQSxLQUFJLENBQUNyQixVQUFMLENBQWdCTixLQUFoQixHQUF3QmUscUJBQXhCO01BQ0EsS0FBSSxDQUFDVCxVQUFMLENBQWdCRixhQUFoQixHQUFnQ1cscUJBQWhDO0lBRUg7O0lBRUQsSUFBUWEsYUFBUixHQUEwQixLQUFJLENBQUM3QixnQkFBTCxDQUFzQnlCLFdBQXRCLENBQWtDdkIsT0FBNUQsQ0FBUTJCLGFBQVI7SUFDQSxJQUFRQyxrQkFBUixHQUErQkQsYUFBL0IsQ0FBUUMsa0JBQVIsQ0EzQ29CLENBNkNwQjs7SUFDQUEsa0JBQWtCLENBQUNDLGNBQW5CLEdBQW9DZixxQkFBcEM7SUFFQSxLQUFJLENBQUNULFVBQUwsQ0FBZ0JKLFFBQWhCLEdBQTJCLEtBQUksQ0FBQ0ksVUFBTCxDQUFnQkwsT0FBM0M7SUFDQSxLQUFJLENBQUNLLFVBQUwsQ0FBZ0JMLE9BQWhCLEdBQTBCYyxxQkFBMUI7SUFFQSxJQUFPZ0IsWUFBUCxHQUF1QixLQUFJLENBQUNoQyxnQkFBTCxDQUFzQnlCLFdBQXRCLENBQWtDdkIsT0FBekQsQ0FBTzhCLFlBQVA7SUFDQSxJQUFNQyxXQUFXLEdBQUdELFlBQVksQ0FBQ0UsY0FBYixDQUE0QmhDLE9BQWhEO0lBRUEsNkJBQTJDLEtBQUksQ0FBQ0YsZ0JBQUwsQ0FBc0J5QixXQUF0QixDQUFrQ3ZCLE9BQTdFO0lBQUEsSUFBUWlDLGNBQVIsMEJBQVFBLGNBQVI7SUFBQSxJQUF3QkMsY0FBeEIsMEJBQXdCQSxjQUF4Qjs7SUFFQSxJQUFJLENBQUN4Qix5QkFBeUIsQ0FBQ3lCLFVBQS9CLEVBQTJDO01BRXZDLElBQUtKLFdBQVcsSUFBSSxxQkFBaEIsSUFBMkNBLFdBQVcsSUFBSSwyQkFBOUQsRUFBNEY7UUFFeEYsS0FBSSxDQUFDSyw0QkFBTDs7UUFDQSxJQUFJTCxXQUFXLElBQUkscUJBQW5CLEVBQTBDRCxZQUFZLENBQUNPLGNBQWIsQ0FBNEIsMkJBQTVCO01BRTdDO0lBRUo7O0lBRUQsS0FBSSxDQUFDbEIsY0FBTCxHQUFzQm1CLFVBQVUsQ0FBQyxZQUFLO01BRWxDLEtBQUksQ0FBQ0MsYUFBTDtJQUVILENBSitCLEVBSTlCOUIsZ0NBSjhCLENBQWhDO0lBTUEsT0FBTyxLQUFQO0VBRUgsQ0EzRU07O0VBOEVDLHFCQUFnQixZQUFLO0lBRXpCLEtBQUksQ0FBQ2lCLFdBQUwsR0FBbUIsS0FBbkI7SUFFQSw2QkFDSSxLQUFJLENBQUM1QixnQkFBTCxDQUFzQnlCLFdBQXRCLENBQWtDdkIsT0FEdEM7SUFBQSxJQUFPOEIsWUFBUCwwQkFBT0EsWUFBUDtJQUFBLElBQXFCRyxjQUFyQiwwQkFBcUJBLGNBQXJCO0lBQUEsSUFBcUNDLGNBQXJDLDBCQUFxQ0EsY0FBckM7SUFHQSxJQUFNeEIseUJBQXlCLEdBQUcsS0FBSSxDQUFDWixnQkFBTCxDQUFzQmEsNEJBQXRCLENBQW1EWCxPQUFyRjtJQUFBLElBQ0l3Qyx5QkFBeUIsR0FBRyxLQUFJLENBQUMxQyxnQkFBTCxDQUFzQlMsNEJBQXRCLENBQW1EUCxPQURuRjtJQUdBLElBQU0rQixXQUFXLEdBQUdELFlBQVksQ0FBQ0UsY0FBYixDQUE0QmhDLE9BQWhEOztJQUVBLFFBQVErQixXQUFSO01BRUksS0FBSyxxQkFBTDtNQUNBLEtBQUssMkJBQUw7UUFDQTtVQUVJLEtBQUksQ0FBQ1Usb0JBQUw7O1VBRUEsSUFBUUMseUJBQVIsR0FBc0NSLGNBQWMsQ0FBQ1MsU0FBckQsQ0FBUUQseUJBQVI7VUFDQUEseUJBQXlCLElBQUlBLHlCQUF5QixDQUFDLEtBQUQsQ0FBdEQ7VUFDQVosWUFBWSxDQUFDTyxjQUFiLENBQTRCLGtCQUE1QjtVQUVBO1FBQ0g7O01BRUQ7UUFBUztVQUVMLElBQUssS0FBSSxDQUFDaEMsVUFBTCxDQUFnQk4sS0FBaEIsSUFBeUIsS0FBSSxDQUFDTSxVQUFMLENBQWdCTCxPQUExQyxJQUNDLEtBQUksQ0FBQ0ssVUFBTCxDQUFnQkwsT0FBaEIsSUFBMkIsS0FBSSxDQUFDSyxVQUFMLENBQWdCSixRQURoRCxFQUMyRDtZQUV2RCxJQUFJNkIsWUFBWSxDQUFDYyxZQUFiLENBQTBCNUMsT0FBOUIsRUFBdUM7Y0FFbkMsS0FBSSxDQUFDNkMsbUJBQUw7WUFFSDtVQUVKOztVQUVEO1FBQ0g7SUE3Qkw7O0lBaUNBLElBQVFDLEtBQVIsR0FBMEJOLHlCQUExQixDQUFRTSxLQUFSO0lBQUEsSUFBZUMsTUFBZixHQUEwQlAseUJBQTFCLENBQWVPLE1BQWY7O0lBRUEsSUFBSUQsS0FBSyxJQUFJLFVBQWIsRUFBeUI7TUFDckJiLGNBQWMsQ0FBQ2UsY0FBZjtJQUNIOztJQUVELElBQUksQ0FBQyxDQUFDLHFCQUFELEVBQXVCLDJCQUF2QixFQUFvREMsUUFBcEQsQ0FBNkRsQixXQUE3RCxDQUFELElBQ0NnQixNQUFNLElBQUksVUFEZixFQUM0QjtNQUV4QjtNQUNBLElBQUssS0FBSSxDQUFDMUMsVUFBTCxDQUFnQk4sS0FBaEIsSUFBeUIsS0FBSSxDQUFDTSxVQUFMLENBQWdCTCxPQUExQyxJQUNDLEtBQUksQ0FBQ0ssVUFBTCxDQUFnQkwsT0FBaEIsSUFBMkIsS0FBSSxDQUFDSyxVQUFMLENBQWdCSixRQURoRCxFQUMyRDtRQUV2RDZCLFlBQVksQ0FBQ08sY0FBYixDQUE0Qix1Q0FBNUI7TUFFSDtJQUNKO0VBRUosQ0EvRE8sQ0FyR29CLENBc0s1Qjs7O0VBQ1EsMkJBQXNCLFlBQUs7SUFFL0IsNkJBQ00sS0FBSSxDQUFDdkMsZ0JBQUwsQ0FBc0J5QixXQUF0QixDQUFrQ3ZCLE9BRHhDO0lBQUEsSUFBUThCLFlBQVIsMEJBQVFBLFlBQVI7SUFBQSxJQUFzQkgsYUFBdEIsMEJBQXNCQSxhQUF0QjtJQUdBLElBQU11QixXQUFXLEdBQUcsS0FBSSxDQUFDcEQsZ0JBQUwsQ0FBc0JTLDRCQUF0QixDQUFtRFAsT0FBdkU7SUFBQSxJQUNJVSx5QkFBeUIsR0FBRyxLQUFJLENBQUNaLGdCQUFMLENBQXNCYSw0QkFBdEIsQ0FBbURYLE9BRG5GO0lBR0EsSUFBSSxDQUFDOEIsWUFBWSxDQUFDYyxZQUFiLENBQTBCNUMsT0FBL0IsRUFBd0M7SUFFeEMsSUFBTW1ELGNBQWMsR0FBR3hCLGFBQWEsQ0FBQ3lCLFFBQXJDO0lBRUEsSUFBTUMsV0FBVyxHQUFHRixjQUFjLENBQUNHLE9BQWYsQ0FBdUJ0RCxPQUEzQztJQUFBLElBQ0lZLGVBQWUsR0FBR0YseUJBQXlCLENBQUNHLFVBQTFCLENBQXFDYixPQUQzRDtJQUFBLElBRUl1RCxrQkFBa0IsR0FBRzNDLGVBQWUsQ0FBQzRDLFVBRnpDO0lBSUEsSUFBSUMsc0JBQUo7O0lBQ0EsSUFBSVAsV0FBVyxDQUFDbkMsV0FBWixJQUEyQixVQUEvQixFQUEyQztNQUV2QzBDLHNCQUFzQixHQUNsQkosV0FBVyxDQUFDSyxTQUFaLEdBQXdCSCxrQkFBa0IsQ0FBQ0csU0FBM0MsR0FBdUQ5QyxlQUFlLENBQUNJLFNBRDNFO0lBR0gsQ0FMRCxNQUtPO01BRUh5QyxzQkFBc0IsR0FDbEJKLFdBQVcsQ0FBQ00sVUFBWixHQUF5Qkosa0JBQWtCLENBQUNJLFVBQTVDLEdBQXlEL0MsZUFBZSxDQUFDSyxVQUQ3RTtJQUdIOztJQUVELElBQVFXLGtCQUFSLEdBQStCRCxhQUEvQixDQUFRQyxrQkFBUjtJQUVBQSxrQkFBa0IsQ0FBQ2dDLDZCQUFuQixHQUFtREgsc0JBQW5EOztJQUVBLElBQUksQ0FBQy9DLHlCQUF5QixDQUFDeUIsVUFBL0IsRUFBMkM7TUFFdkMsS0FBSSxDQUFDTSxvQkFBTDtJQUVIO0VBRUosQ0F2Q08sQ0F2S29CLENBZ041QjtFQUNBOzs7RUFDUSw0QkFBdUIsWUFBSztJQUVoQyxJQUFNUyxXQUFXLEdBQUcsS0FBSSxDQUFDcEQsZ0JBQUwsQ0FBc0JTLDRCQUF0QixDQUFtRFAsT0FBdkU7SUFDQSxJQUFNVSx5QkFBeUIsR0FBRyxLQUFJLENBQUNaLGdCQUFMLENBQXNCYSw0QkFBdEIsQ0FBbURYLE9BQXJGO0lBQ0EsSUFBTzJCLGFBQVAsR0FBd0IsS0FBSSxDQUFDN0IsZ0JBQUwsQ0FBc0J5QixXQUF0QixDQUFrQ3ZCLE9BQTFELENBQU8yQixhQUFQO0lBQ0EsSUFBUUMsa0JBQVIsR0FBK0JELGFBQS9CLENBQVFDLGtCQUFSO0lBRUEsSUFBTWhCLGVBQWUsR0FBR0YseUJBQXlCLENBQUNHLFVBQTFCLENBQXFDYixPQUE3RDs7SUFFQSxJQUFJLEVBQUdZLGVBQWUsQ0FBQ1EsV0FBaEIsSUFBK0IsQ0FBaEMsSUFBd0NSLGVBQWUsQ0FBQ1MsWUFBaEIsSUFBZ0MsQ0FBMUUsQ0FBSixFQUFtRjtNQUFDO01BRWhGLElBQUk2QixXQUFXLENBQUNuQyxXQUFaLElBQTJCLFVBQS9CLEVBQTJDO1FBRXZDYSxrQkFBa0IsQ0FBQ0MsY0FBbkIsR0FBb0NqQixlQUFlLENBQUNJLFNBQXBEO01BRUgsQ0FKRCxNQUlPO1FBRUhZLGtCQUFrQixDQUFDQyxjQUFuQixHQUFvQ2pCLGVBQWUsQ0FBQ0ssVUFBcEQ7TUFDSDtJQUVKO0VBRUosQ0F0Qk87O0VBd0JELG9DQUErQixZQUFLO0lBRXZDLElBQU1QLHlCQUF5QixHQUFHLEtBQUksQ0FBQ1osZ0JBQUwsQ0FBc0JhLDRCQUF0QixDQUFtRFgsT0FBckY7SUFBQSxJQUNJa0QsV0FBVyxHQUFHLEtBQUksQ0FBQ3BELGdCQUFMLENBQXNCUyw0QkFBdEIsQ0FBbURQLE9BRHJFO0lBQUEsSUFFSTZELFlBQVksR0FBRyxLQUFJLENBQUMvRCxnQkFBTCxDQUFzQmdFLDJCQUF0QixDQUFrRDlELE9BRnJFO0lBSUEsSUFBTVksZUFBZSxHQUFHRix5QkFBeUIsQ0FBQ0csVUFBMUIsQ0FBcUNiLE9BQTdEO0lBQUEsSUFDSXVELGtCQUFrQixHQUFHM0MsZUFBZSxDQUFDNEMsVUFEekM7SUFHQSxJQUFRTyxVQUFSLEdBQWlDRixZQUFqQyxDQUFRRSxVQUFSO0lBQUEsSUFBb0JDLFFBQXBCLEdBQWlDSCxZQUFqQyxDQUFvQkcsUUFBcEI7SUFBQSxJQUNNakQsV0FETixHQUNzQm1DLFdBRHRCLENBQ01uQyxXQUROO0lBR0EsSUFBSWtELFNBQUosRUFBZUMsVUFBZixFQUEyQkMsaUJBQTNCOztJQUNBLElBQUlwRCxXQUFXLElBQUksVUFBbkIsRUFBK0I7TUFFM0JrRCxTQUFTLEdBQUdyRCxlQUFlLENBQUNJLFNBQTVCO01BQ0FrRCxVQUFVLEdBQUdoQixXQUFXLENBQUNrQixVQUFaLEdBQXlCbEIsV0FBVyxDQUFDbUIsR0FBbEQ7TUFDQUYsaUJBQWlCLEdBQUdaLGtCQUFrQixDQUFDRyxTQUF2QztJQUVILENBTkQsTUFNTztNQUVITyxTQUFTLEdBQUdyRCxlQUFlLENBQUNLLFVBQTVCO01BQ0FpRCxVQUFVLEdBQUdoQixXQUFXLENBQUNvQixTQUFaLEdBQXdCcEIsV0FBVyxDQUFDbUIsR0FBakQ7TUFDQUYsaUJBQWlCLEdBQUdaLGtCQUFrQixDQUFDSSxVQUF2QztJQUVIOztJQUVELElBQUlZLGVBQWUsR0FBR0wsVUFBVSxHQUFJLENBQUNELFNBQVMsR0FBR0UsaUJBQWIsSUFBa0NELFVBQXRFOztJQUNBLElBQUlLLGVBQWUsSUFBS0wsVUFBVSxHQUFHaEIsV0FBVyxDQUFDc0IsT0FBakQsRUFBMkQ7TUFDdkRELGVBQWUsR0FBRyxDQUFsQjtJQUNIOztJQUVELElBQU1FLFlBQVksR0FBR0MsSUFBSSxDQUFDQyxJQUFMLENBQVUsQ0FBQ1YsU0FBUyxHQUFHZixXQUFXLENBQUNzQixPQUF6QixJQUFrQ04sVUFBNUMsQ0FBckI7SUFFQSxJQUFJVSxrQkFBa0IsR0FBR0gsWUFBWSxHQUFHVixVQUF4QztJQUNBYSxrQkFBa0IsR0FBR0YsSUFBSSxDQUFDRyxHQUFMLENBQVNELGtCQUFULEVBQTRCWixRQUFRLEdBQUcsQ0FBdkMsQ0FBckI7SUFFQSxJQUFNYyxJQUFJLEdBQUdGLGtCQUFrQixHQUFHYixVQUFsQztJQUNBYSxrQkFBa0IsSUFBSUUsSUFBdEI7SUFFQSxJQUFJRixrQkFBa0IsSUFBSSxDQUExQixFQUE2QkwsZUFBZSxHQUFHLENBQWxCLENBeENVLENBd0NVOztJQUVqRCxJQUFRM0Msa0JBQVIsR0FBK0IsS0FBSSxDQUFDOUIsZ0JBQUwsQ0FBc0J5QixXQUF0QixDQUFrQ3ZCLE9BQWxDLENBQTBDMkIsYUFBekUsQ0FBUUMsa0JBQVI7SUFFQUEsa0JBQWtCLENBQUNtRCx3QkFBbkIsR0FBOENILGtCQUE5QztJQUNBaEQsa0JBQWtCLENBQUNnQyw2QkFBbkIsR0FBbURXLGVBQW5EO0lBRUEsSUFBUVMsMEJBQVIsR0FDSSxLQUFJLENBQUNsRixnQkFBTCxDQUFzQnlCLFdBQXRCLENBQWtDdkIsT0FBbEMsQ0FBMENrQyxjQUExQyxDQUF5RFMsU0FEN0QsQ0FBUXFDLDBCQUFSO0lBRUFBLDBCQUEwQixJQUFJQSwwQkFBMEIsQ0FBQ0osa0JBQUQsQ0FBeEQ7RUFFSCxDQW5ETTs7RUF4T0gsS0FBSzlFLGdCQUFMLEdBQXdCQSxnQkFBeEI7QUFFSCxDOztBQU5MbUYsa0JBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvc2Nyb2xsaGFuZGxlci50c3g/Y2VmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY3JvbGxoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBob2xkcyB0aGUgcmVzcG9uc2UgdG8gc2Nyb2xsaW5nLiBJdCBhbHNvIHRyaWdnZXJzIGFuIG9uQWZ0ZXJTY3JvbGwgZXZlbnQgKGFmdGVyIGEgdGltZW91dClcbiAgICBJdCdzIG1haW4gam9iIGlzIHRvIG1haW50YWluIHJlY29yZHMgb2Ygc2Nyb2xsUG9zLCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIGFuZCBcbiAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbEhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHVibGljIHNjcm9sbERhdGEgPSB7c3RhcnQ6MCwgY3VycmVudDowLCBwcmV2aW91czowLCBwcmV2aW91c3VwZGF0ZTowLCBjdXJyZW50dXBkYXRlOjB9XG5cbiAgICBwcml2YXRlIF9zY3JvbGx0aW1lcmlkID0gbnVsbFxuXG4gICAgcHJpdmF0ZSBpc1Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICBwdWJsaWMgcmVzZXRTY3JvbGxEYXRhID0gKHNjcm9sbFBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gdGhpc1xuICAgICAgICBzY3JvbGxEYXRhLnN0YXJ0ID0gXG4gICAgICAgIHNjcm9sbERhdGEuY3VycmVudCA9IFxuICAgICAgICBzY3JvbGxEYXRhLnByZXZpb3VzID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXN1cGRhdGUgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsUG9zaXRpb25cbiAgICB9XG5cbiAgICBwdWJsaWMgb25TY3JvbGwgPSAoZSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJJRCwgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uQ3VycmVudCA9IFxuICAgICAgICAgICAgKHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY3JvbGx0aW1lcmlkKVxuXG4gICAgICAgIGlmICgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDAgICYmIHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uQ3VycmVudCA8IDApIHsgLy8gZm9yIFNhZmFyaVxuXG4gICAgICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtzaWduYWxzfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmludGVycnVwdEhhbmRsZXJcblxuICAgICAgICBpZiAoc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1Njcm9sbGluZykge1xuXG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxEYXRhLnN0YXJ0ID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuY3VycmVudHVwZGF0ZSA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGxheW91dEhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgLy8ga2VlcCB1cCB0byBkYXRlIGluIGNhc2Ugb2YgcmVwYXJlbnRpbmcgaW50ZXJydXB0XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuXG4gICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5wcmV2aW91cyA9IHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50XG4gICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50ID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3N0YXRlSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjb250ZW50SGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKCFWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgaWYgKChjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpIHx8IChjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEoKVxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsdGltZXJpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJTY3JvbGwoKVxuXG4gICAgICAgIH0sU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICB9XG5cblxuICAgIHByaXZhdGUgb25BZnRlclNjcm9sbCA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgICAgICBjb25zdCB7c3RhdGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc2VydmljZUhhbmRsZXJ9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nUmVuZGVyJzogXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJzpcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQmxvY2tTY3JvbGxQb3MoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2soZmFsc2UpXG4gICAgICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdmaW5pc2hyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcblxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5zY3JvbGxEYXRhLnN0YXJ0ICE9IHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50KSB8fCBcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50ICE9IHRoaXMuc2Nyb2xsRGF0YS5wcmV2aW91cykpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVmZXJlbmNlRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZSwgbGF5b3V0IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghWydyZXBvc2l0aW9uaW5nUmVuZGVyJywncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbiddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSAmJlxuICAgICAgICAgICAgKGxheW91dCA9PSAndmFyaWFibGUnKSkge1xuXG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIHJlYXNvbmluZyBmb3IgdGhpc1xuICAgICAgICAgICAgaWYgKCh0aGlzLnNjcm9sbERhdGEuc3RhcnQgIT0gdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnQpIHx8IFxuICAgICAgICAgICAgICAgICh0aGlzLnNjcm9sbERhdGEuY3VycmVudCAhPSB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMpKSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5YWZ0ZXJzY3JvbGwnKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGFmdGVyIHNjcm9sbCwgYnV0IG5vdCBhZnRlciByZXBvc2l0aW9uaW5nXG4gICAgcHJpdmF0ZSB1cGRhdGVSZWZlcmVuY2VEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBsYXlvdXRIYW5kbGVyIH0gXG4gICAgICAgICAgICA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIXN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBsYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG5cbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgbGV0IGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXRcbiAgICAgICAgaWYgKGNyYWRsZVByb3BzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgYXhpc1Zpc2libGVQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgIGF4aXNFbGVtZW50Lm9mZnNldFRvcCArIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3AgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRMZWZ0ICsgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnQgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXRcblxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBmaW5pc2hyZXBvc2l0aW9uIHN0YXRlIGNoYW5nZSBjYWxsIGFib3ZlXG4gICAgLy8gY2FsbGVkIGZyb20gdXBkYXRlUmVmZXJlbmNlRGF0YVxuICAgIHByaXZhdGUgdXBkYXRlQmxvY2tTY3JvbGxQb3MgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHtsYXlvdXRIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoISgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDApICAmJiAodmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkpIHsvLyBpbiBjYWNoZVxuXG4gICAgICAgICAgICBpZiAoY3JhZGxlUHJvcHMub3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZVByb3BzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUNvbmZpZyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCB7IGNyb3NzY291bnQsIGxpc3RzaXplIH0gPSBjcmFkbGVDb25maWcsXG4gICAgICAgICAgICB7IG9yaWVudGF0aW9uIH0gPSBjcmFkbGVQcm9wc1xuXG4gICAgICAgIGxldCBzY3JvbGxQb3MsIGNlbGxMZW5ndGgsIHNjcm9sbGJsb2NrT2Zmc2V0XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0ICsgY3JhZGxlUHJvcHMuZ2FwXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3BcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgY2VsbExlbmd0aCA9IGNyYWRsZVByb3BzLmNlbGxXaWR0aCArIGNyYWRsZVByb3BzLmdhcFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tPZmZzZXQgPSBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0TGVmdFxuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXhpc1BpeGVsT2Zmc2V0ID0gY2VsbExlbmd0aCAtICgoc2Nyb2xsUG9zICsgc2Nyb2xsYmxvY2tPZmZzZXQpICUgY2VsbExlbmd0aClcbiAgICAgICAgaWYgKGF4aXNQaXhlbE9mZnNldCA9PSAoY2VsbExlbmd0aCArIGNyYWRsZVByb3BzLnBhZGRpbmcpKSB7XG4gICAgICAgICAgICBheGlzUGl4ZWxPZmZzZXQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzUm93SW5kZXggPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVByb3BzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG5cbiAgICAgICAgbGV0IGF4aXNSZWZlcmVuY2VJbmRleCA9IGF4aXNSb3dJbmRleCAqIGNyb3NzY291bnRcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4oYXhpc1JlZmVyZW5jZUluZGV4LGxpc3RzaXplIC0gMSlcblxuICAgICAgICBjb25zdCBkaWZmID0gYXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudFxuICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXggLT0gZGlmZlxuXG4gICAgICAgIGlmIChheGlzUmVmZXJlbmNlSW5kZXggPT0gMCkgYXhpc1BpeGVsT2Zmc2V0ID0gMCAvLyBkZWZlbnNpdmVcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQubGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1BpeGVsT2Zmc2V0XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LnNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayAmJiByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayhheGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJTY3JvbGxIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsInN0YXJ0IiwiY3VycmVudCIsInByZXZpb3VzIiwicHJldmlvdXN1cGRhdGUiLCJjdXJyZW50dXBkYXRlIiwic2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxEYXRhIiwiZSIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJzY3JvbGxlcklEIiwiU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxQb3NpdGlvbkN1cnJlbnQiLCJvcmllbnRhdGlvbiIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJjbGVhclRpbWVvdXQiLCJfc2Nyb2xsdGltZXJpZCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2lnbmFscyIsImhhbmRsZXJzUmVmIiwiaW50ZXJydXB0SGFuZGxlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsImlzU2Nyb2xsaW5nIiwibGF5b3V0SGFuZGxlciIsImNyYWRsZVBvc2l0aW9uRGF0YSIsImJsb2NrU2Nyb2xsUG9zIiwic3RhdGVIYW5kbGVyIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImNvbnRlbnRIYW5kbGVyIiwic2VydmljZUhhbmRsZXIiLCJpc1Jlc2l6aW5nIiwiY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSIsInNldENyYWRsZVN0YXRlIiwic2V0VGltZW91dCIsIm9uQWZ0ZXJTY3JvbGwiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwidXBkYXRlQmxvY2tTY3JvbGxQb3MiLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiY2FsbGJhY2tzIiwiaXNNb3VudGVkUmVmIiwidXBkYXRlUmVmZXJlbmNlRGF0YSIsImNhY2hlIiwibGF5b3V0IiwicGFyZUNhY2hlVG9NYXgiLCJpbmNsdWRlcyIsImNyYWRsZVByb3BzIiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsInNjcm9sbGJsb2NrRWxlbWVudCIsImZpcnN0Q2hpbGQiLCJheGlzVmlzaWJsZVBpeGVsT2Zmc2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiY3JhZGxlQ29uZmlnIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3Jvc3Njb3VudCIsImxpc3RzaXplIiwic2Nyb2xsUG9zIiwiY2VsbExlbmd0aCIsInNjcm9sbGJsb2NrT2Zmc2V0IiwiY2VsbEhlaWdodCIsImdhcCIsImNlbGxXaWR0aCIsImF4aXNQaXhlbE9mZnNldCIsInBhZGRpbmciLCJheGlzUm93SW5kZXgiLCJNYXRoIiwiY2VpbCIsImF4aXNSZWZlcmVuY2VJbmRleCIsIm1pbiIsImRpZmYiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJyZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // servicehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streas, see the constructor.\n\n    The function calls avaiable to the host are:\n        scrollToItem,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n        remapIndexes,\n        moveIndex,\n        insertIndex,\n        removeIndex,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions in cacheHandler and contentHandler. stateHandler is\n    often invoked to change state upon servicing requests.\n*/\n\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ServiceHandler);\n\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState(\'reload\');\n  };\n\n  this.scrollToItem = function (index) {\n    index = Math.max(0, index);\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        layoutHandler = _this$cradleParameter.layoutHandler,\n        stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState(\'scrollto\');\n  };\n\n  this.setListsize = function (newlistsize) {\n    newlistsize = Math.max(0, newlistsize);\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter2.cacheHandler,\n        stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n        deleteListCallback = _this$callbacks.deleteListCallback,\n        changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback(\'change list size intervention\', deleteList);\n      };\n    }\n\n    cacheHandler.changeListsize(newlistsize, dListCallback, changeListsizeCallback);\n\n    if (cache == \'preload\' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState(\'startpreload\');\n    }\n  }; // ======================[ GET SNAPSHOTS ]========================\n\n\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter3.cacheHandler,\n        contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  }; // =================[ CACHE MANAGEMENT REQUESTS ]==================\n\n\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState(\'clearcache\');\n    return true;\n  };\n\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter4.cacheHandler,\n        contentHandler = _this$cradleParameter4.contentHandler,\n        stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n        metadataMap = _cacheHandler$cachePr.metadataMap,\n        portalMap = _cacheHandler$cachePr.portalMap,\n        indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map(); // =====================[ PREPARE ]======================\n    // ------------ filter out inoperable indexes and itemIDs ------------\n\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == \'string\') {\n          errorEntriesMap.set(index, \'itemID is a string\');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, \'itemID is not an integer\');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, \'index not in cache\');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " has not changed"));\n        } else if (!metadataMap.has(itemID)) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " not in cache"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    }); // -------------- filter out duplicate itemIDs ------------\n\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, "target itemID ".concat(itemID, " has duplicates (").concat(count, ")"));\n        changeIndexToItemIDMap["delete"](index);\n      });\n    } // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n\n\n    var originalMap = new Map(); // index => itemID; before change\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    }); // ... and from the list of indexes to be deleted\n\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    }); // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID\'s will be orphaned, but could be remapped.\n    // orphans are resolved below\n\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap["delete"](index);\n      });\n    } // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n\n\n    var processedIndexList = []; // make changes\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n\n      processedIndexList.push(index);\n    }); // -------------- look for and delete item and index orphans --------------------\n    // if the original item\'s index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item\'s index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n\n    var deletedIndexToItemIDMap = new Map();\n    var portalHoldList = []; // hold deleted portals for deletion until after cradle synch\n\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        metadataMap["delete"](originalItemID);\n        portalHoldList.push(originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap["delete"](originalItemIDIndex);\n          }\n        }\n      }\n    }); // refresh the modified cache\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList(); // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys()); // for return information...\n\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    cacheHandler.portalHoldList = portalHoldList;\n    stateHandler.setCradleState(\'applycellframechanges\'); // ---------- returns for user information --------------------\n\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  }; // move must be entirely within list bounds\n  // returns list of processed indexes\n\n\n  this.moveIndex = function (toindex, fromindex) {\n    var highrange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------- define parameters ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // remove nulls\n\n    toindex = toindex !== null && toindex !== void 0 ? toindex : 0;\n    fromindex = fromindex !== null && fromindex !== void 0 ? fromindex : 0;\n    highrange = highrange !== null && highrange !== void 0 ? highrange : fromindex;\n    toindex = Math.max(0, toindex);\n    fromindex = Math.max(0, fromindex);\n    highrange = Math.max(0, highrange); // keep within current list size\n\n    var listbound = listsize - 1;\n    toindex = toindex > listbound ? listbound : toindex;\n    fromindex = fromindex > listbound ? listbound : fromindex;\n    highrange = highrange > listbound ? listbound : highrange; // highrange must be >= fromindex\n\n    highrange = highrange >= fromindex ? highrange : fromindex;\n    var rangeincrement = highrange - fromindex + 1;\n    var moveincrement = toindex - fromindex; // ---------- constrain parameters --------------\n\n    if (fromindex == toindex) return []; // nothing to do\n    // move must be in list bounds\n\n    if (moveincrement > 0) {\n      // move up\n      var targettop = toindex + (rangeincrement - 1);\n      if (targettop > listbound) return []; // out of bounds\n    } // ----------- perform cache and cradle operations -----------\n\n\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter5.cacheHandler,\n        contentHandler = _this$cradleParameter5.contentHandler,\n        stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList = cacheHandler.moveIndex(toindex, fromindex, highrange);\n\n    if (processedIndexList.length) {\n      cacheHandler.cacheProps.modified = true;\n      cacheHandler.renderPortalList();\n      contentHandler.changeCradleItemIDs(processedIndexList);\n      stateHandler.setCradleState(\'applycellframechanges\');\n    }\n\n    return processedIndexList;\n  };\n\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  }; // shared logic. Returns lists of items changed, and items replaced (new items for insert)\n  // this operation changes the listsize\n\n\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    index = index !== null && index !== void 0 ? index : 0;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter6.cacheHandler,\n        contentHandler = _this$cradleParameter6.contentHandler,\n        stateHandler = _this$cradleParameter6.stateHandler;\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n        _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 4),\n        changeList = _cacheHandler$insertR2[0],\n        replaceList = _cacheHandler$insertR2[1],\n        rangeincrement = _cacheHandler$insertR2[2],\n        portalHoldList = _cacheHandler$insertR2[3];\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList();\n    cacheHandler.portalHoldList = portalHoldList;\n    contentHandler.changeCradleItemIDs(changeList);\n    if (increment == +1) contentHandler.createNewItemIDs(replaceList);\n    var content = contentHandler.content;\n    stateHandler.setCradleState(\'applycellframechanges\');\n    var changecount = rangeincrement; // semantics\n\n    var newlistsize = listsize + changecount;\n\n    _this.setListsize(newlistsize);\n\n    return [changeList, replaceList];\n  };\n\n  this.cradleParameters = cradleParameters; // doing this explicitly here for documentation\n\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n      referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n      preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n      deleteListCallback = _cradleParameters$ext.deleteListCallback,\n      changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n      itemExceptionsCallback = _cradleParameters$ext.itemExceptionsCallback,\n      repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionsCallback: itemExceptionsCallback,\n    repositioningFlagCallback: repositioningFlagCallback\n  };\n  this.callbacks = callbacks;\n});\n\nexports["default"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LHNCQUxKO0VBQUEsSUFNSUMseUJBTkoseUJBTUlBLHlCQU5KO0VBVUEsSUFBTXhGLFNBQVMsR0FBRztJQUNkcUYsc0JBQXNCLEVBQXRCQSxzQkFEYztJQUVkQyxvQkFBb0IsRUFBcEJBLG9CQUZjO0lBR2RyRixrQkFBa0IsRUFBbEJBLGtCQUhjO0lBSWRDLHNCQUFzQixFQUF0QkEsc0JBSmM7SUFLZHFGLHNCQUFzQixFQUF0QkEsc0JBTGM7SUFNZEMseUJBQXlCLEVBQXpCQTtFQU5jLENBQWxCO0VBU0EsS0FBS3hGLFNBQUwsR0FBaUJBLFNBQWpCO0FBRUYsQzs7QUE1Qkx5RixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zZXJ2aWNlaGFuZGxlci50c3g/OWNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgZmllbGRzIHNlcnZpY2UgcmVxdWVzdHMgZnJvbSB0aGUgaG9zdC4gVGhlcmUgYXJlIHR3byBmb3Jtc1xuICAgIC0gc3RyZWFtaW5nIGZyb20gdGhlIHNjcm9sbGVyIHRvIHRoZSBob3N0XG4gICAgLSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSB1c2VyIHRvIHRoZSBzY3JvbGxlclxuXG4gICAgRm9yIHRoZSBsaXN0IG9mIGRhdGEgc3RyZWFzLCBzZWUgdGhlIGNvbnN0cnVjdG9yLlxuXG4gICAgVGhlIGZ1bmN0aW9uIGNhbGxzIGF2YWlhYmxlIHRvIHRoZSBob3N0IGFyZTpcbiAgICAgICAgc2Nyb2xsVG9JdGVtLCBcbiAgICAgICAgcmVsb2FkLCBcbiAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgIGdldENhY2hlSW5kZXhNYXAsIFxuICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgIHJlbW92ZUluZGV4LFxuICAgIFxuICAgIFRoZSBmdW5jdGlvbnMgbGlzdGVkIGFyZSBkZWZpbmVkIGluIHRoaXMgbW9kdWxlLlxuXG4gICAgVGhlcmUgYXJlIGltcG9ydGFudCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBpbiBjYWNoZUhhbmRsZXIgYW5kIGNvbnRlbnRIYW5kbGVyLiBzdGF0ZUhhbmRsZXIgaXNcbiAgICBvZnRlbiBpbnZva2VkIHRvIGNoYW5nZSBzdGF0ZSB1cG9uIHNlcnZpY2luZyByZXF1ZXN0cy5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcnZpY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIC8vIGRvaW5nIHRoaXMgZXhwbGljaXRseSBoZXJlIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICAgY29uc3Qge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgsIGxvY2F0aW9uLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIC8vIChpbmRleClcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLCAvLyAocmVhc29uLCBkZWxldGVMaXN0KVxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLCAvLyAobmV3bGlzdHNpemUpXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssIC8vIChpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgbG9jYXRpb24sIGVycm9yKVxuICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLCAvLyAoZmxhZykgLy8gYm9vbGVhblxuICAgICAgICAgICBcbiAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5leHRlcm5hbENhbGxiYWNrc1JlZi5jdXJyZW50XG5cbiAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgLy8gc2VlIGFib3ZlIGZvciBsaXN0XG4gICAgcHVibGljIGNhbGxiYWNrc1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBHRU5FUkFMIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgcmVsb2FkID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgaW50ZXJydXB0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNjcm9sbFRvSXRlbSA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCxpbmRleClcblxuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmludGVycnVwdEhhbmRsZXJcbiAgICAgICAgY29uc3QgeyBsYXlvdXRIYW5kbGVyLCBzdGF0ZUhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBpbmRleFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc2Nyb2xsdG8nKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldExpc3RzaXplID0gKG5ld2xpc3RzaXplKSA9PiB7XG5cbiAgICAgICAgbmV3bGlzdHNpemUgPSBNYXRoLm1heCgwLG5ld2xpc3RzaXplKVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgfSA9IHRoaXMuY2FsbGJhY2tzXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZTpjdXJyZW50bGlzdHNpemUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2NoYW5nZSBsaXN0IHNpemUgaW50ZXJ2ZW50aW9uJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlSGFuZGxlci5jaGFuZ2VMaXN0c2l6ZShuZXdsaXN0c2l6ZSwgXG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFja1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKChjYWNoZSA9PSAncHJlbG9hZCcpICYmIChuZXdsaXN0c2l6ZSA+IGN1cnJlbnRsaXN0c2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRwcmVsb2FkJylcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgR0VUIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSW5kZXhNYXAoKVxuXG4gICAgfVxuXG4gICAgcHVibGljIGdldENhY2hlSXRlbU1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSXRlbU1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlSW5kZXhNYXAgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENyYWRsZUluZGV4TWFwKG1vZGVsSW5kZXhMaXN0KVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09WyBDQUNIRSBNQU5BR0VNRU5UIFJFUVVFU1RTIF09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2xlYXJjYWNoZScpXG5cbiAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIH1cblxuICAgIHB1YmxpYyByZW1hcEluZGV4ZXMgPSAoY2hhbmdlTWFwKSA9PiB7IC8vIGluZGV4ID0+IGl0ZW1JRFxuXG4gICAgICAgIGlmIChjaGFuZ2VNYXAuc2l6ZSA9PSAwKSByZXR1cm4gW10gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc3RhdGVIYW5kbGVyIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsIC8vIGl0ZW1JRCB0byBjb21wb25lbnQgZGF0YSwgaW5jbHVkaW5nIGluZGV4XG4gICAgICAgICAgICBwb3J0YWxNYXAsIC8vIHR3aW5uZWQgd2l0aCBtZXRhZGF0YU1hcCBmb3IgcG9ydGFsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIC8vIGluZGV4IHRvIGl0ZW1JRFxuXG4gICAgICAgIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcyBcblxuICAgICAgICBjb25zdCBpbmRleGVzVG9EZWxldGVMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBlcnJvckVudHJpZXNNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFBSRVBBUkUgXT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gZmlsdGVyIG91dCBpbm9wZXJhYmxlIGluZGV4ZXMgYW5kIGl0ZW1JRHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY2hhbmdlTWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+e1xuXG4gICAgICAgICAgICBpZiAoKGl0ZW1JRCA9PT0gbnVsbCkgfHwgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvRGVsZXRlTGlzdC5wdXNoKGluZGV4KVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgaXRlbUlEKSA9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsJ2l0ZW1JRCBpcyBhIHN0cmluZycpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgbm90IGFuIGludGVnZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgJ2luZGV4IG5vdCBpbiBjYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSA9PSBpdGVtSUQpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCBgdGFyZ2V0IGl0ZW1JRCAke2l0ZW1JRH0gaGFzIG5vdCBjaGFuZ2VkYClcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1ldGFkYXRhTWFwLmhhcyhpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IG5vdCBpbiBjYWNoZWApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgZHVwbGljYXRlIGl0ZW1JRHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgbWFwc2l6ZSA9IGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2l6ZVxuXG4gICAgICAgIGNvbnN0IGl0ZW1JRFNldCA9IG5ldyBTZXQoY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC52YWx1ZXMoKSlcblxuICAgICAgICBjb25zdCBpdGVtc2V0c2l6ZSA9IGl0ZW1JRFNldC5zaXplXG5cbiAgICAgICAgaWYgKG1hcHNpemUgIT0gaXRlbXNldHNpemUpIHsgLy8gdGhlcmUgbXVzdCBiZSBkdXBsaWNhdGUgaXRlbUlEc1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSURDb3VudE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlEQ291bnRNYXAuaGFzKGl0ZW1JRCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCAxKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBpdGVtSURDb3VudE1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICBpdGVtSURDb3VudE1hcC5zZXQoaXRlbUlELCArK2NvdW50IClcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZUl0ZW1zTWFwID0gbmV3IE1hcCgpXG4gICAgICAgICAgICBpdGVtSURDb3VudE1hcC5mb3JFYWNoKChjb3VudCxpdGVtSUQpPT57XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlSXRlbXNNYXAuc2V0KGl0ZW1JRCwgY291bnQpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCA9IFtdXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJdGVtc01hcC5oYXMoaXRlbUlEKSkge1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LnB1c2goaW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0LmZvckVhY2goKGluZGV4KT0+e1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkdXBsaWNhdGVJdGVtc01hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBkdXBsaWNhdGVzICgke2NvdW50fSlgKVxuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gY2FwdHVyZSBtYXAgYmVmb3JlIGNoYW5nZXMgLS0tLS0tLS0tLVxuICAgICAgICAvLyAuLi4gdGhpcyBtYXAgaXMgdXNlZCBsYXRlciB0byBpZGVudGlmeSBvcnBoYW5lZCBpdGVtIGFuZCBpbmRleCBjYWNoZSByZWNvcmRzIGZvciBkZWxldGlvblxuXG4gICAgICAgIC8vIGZyb20gdGhlIGxpc3Qgb2YgY2hhbmdlc1xuICAgICAgICAvLyBib3RoIHNpZGVzIG9mIGNoYW5nZSBtYXAuLi5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBiZWZvcmUgY2hhbmdlXG4gICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCk9PntcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSkgLy8gaW5kZXggdG8gYmUgbWFwcGVkXG4gICAgICAgICAgICBvcmlnaW5hbE1hcC5zZXQobWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXgsaXRlbUlEKSAvLyB0YXJnZXQgaXRlbUlEXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAuLi4gYW5kIGZyb20gdGhlIGxpc3Qgb2YgaW5kZXhlcyB0byBiZSBkZWxldGVkXG4gICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBPUEVSQVRJT05TIF09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRlbGV0ZSBsaXN0ZWQgaW5kZXhlcyAtLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIGluZGV4ZXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgaXRlbUlEJ3Mgd2lsbCBiZSBvcnBoYW5lZCwgYnV0IGNvdWxkIGJlIHJlbWFwcGVkLlxuICAgICAgICAvLyBvcnBoYW5zIGFyZSByZXNvbHZlZCBiZWxvd1xuXG4gICAgICAgIGlmIChpbmRleGVzVG9EZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gYXBwbHkgZmlsdGVyZWQgY2hhbmdlcyB0byBjYWNoZSBpbmRleCBtYXAgYW5kIGl0ZW1JRCBtYXAgLS0tLS0tLS0tLVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGV2ZXJ5IHJlbWFpbmluZyBpbmRleCBsaXN0ZWQgd2lsbCBjaGFuZ2UgaXRzIG1hcHBpbmdcblxuICAgICAgICAvLyBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICBpdGVtZGF0YS5pbmRleCA9IGluZGV4IC8vIG1vZGlmaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDJcblxuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkTWFwLnNldChpbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBwcm9jZXNzZWRJbmRleExpc3QucHVzaChpbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGxvb2sgZm9yIGFuZCBkZWxldGUgaXRlbSBhbmQgaW5kZXggb3JwaGFucyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luYWwgaXRlbSdzIGluZGV4IGhhcyBub3QgY2hhbmdlZCwgdGhlbiBpdCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIFxuICAgICAgICAvLyAgICAgaXQgaXMgb3JwaGFuZWQsIGFuZCB0aGUgaXRlbSBpcyBkZWxldGVkXG4gICAgICAgIC8vIGlmIHRoZSBpdGVtJ3MgaW5kZXggaGFzIGNoYW5nZWQsIGJ1dCB0aGUgb3JpZ2luYWwgaXRlbSBpbmRleCBtYXAgc3RpbGwgcG9pbnRzIHRvIHRoZSBpdGVtLFxuICAgICAgICAvLyAgICAgdGhlbiB0aGUgaW5kZXggaXMgb3JwaGFuZWQgKGR1cGxpY2F0ZSksIGFuZCBkZWxldGVkXG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBvcnBoYW5lZCBpbmRleFxuICAgICAgICBjb25zdCBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEhvbGRMaXN0ID0gW10gLy8gaG9sZCBkZWxldGVkIHBvcnRhbHMgZm9yIGRlbGV0aW9uIHVudGlsIGFmdGVyIGNyYWRsZSBzeW5jaFxuXG4gICAgICAgIG9yaWdpbmFsTWFwLmZvckVhY2goKG9yaWdpbmFsSXRlbUlELCBvcmlnaW5hbEl0ZW1JREluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsSXRlbUlESW5kZXggPSBtZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpLmluZGV4XG5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEl0ZW1JREluZGV4ID09IGZpbmFsSXRlbUlESW5kZXgpIHsgLy8gbm90IHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLnNldChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleClcblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JRClcbiAgICAgICAgICAgICAgICBwb3J0YWxIb2xkTGlzdC5wdXNoKG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZW1hcHBlZCwgY2hlY2sgZm9yIG9ycGhhbmVkIGluZGV4XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0l0ZW1JRE1hcC5oYXMob3JpZ2luYWxJdGVtSURJbmRleCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSXRlbUlEID09IG9yaWdpbmFsSXRlbUlEKSB7IC8vIHRoZSBpbmRleCBoYXMgbm90IGJlZW4gcmVtYXBwZWQsIHRoZXJlZm9yZSBvcnBoYW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcC5zZXQob3JpZ2luYWxJdGVtSURJbmRleCwgb3JpZ2luYWxJdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyByZWZyZXNoIHRoZSBtb2RpZmllZCBjYWNoZVxuICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gYXBwbHkgY2hhbmdlcyB0byBleHRhbnQgY2VsbEZyYW1lcyAtLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyB0aGVzZSBhcmUgdXNlZCB0byByZWNvbmNpbGUgY3JhZGxlIGNlbGxGcmFtZXMsIGFuZCBhbHNvIGZvciByZXR1cm4gaW5mb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNYXAua2V5cygpKVxuICAgICAgICBjb25zdCBkZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSXRlbUlEVG9JbmRleE1hcC52YWx1ZXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIC8vIGZvciByZXR1cm4gaW5mb3JtYXRpb24uLi5cbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAua2V5cygpKSBcblxuICAgICAgICBsZXQgbW9kaWZpZWRJbmRleExpc3QgPSBbXG4gICAgICAgICAgICAuLi5wcm9jZXNzZWRJbmRleExpc3QsXG4gICAgICAgICAgICAuLi5pbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QsIFxuICAgICAgICAgICAgLi4uZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0XG4gICAgICAgIF1cblxuICAgICAgICBtb2RpZmllZEluZGV4TGlzdCA9IEFycmF5LmZyb20obmV3IFNldChtb2RpZmllZEluZGV4TGlzdC52YWx1ZXMoKSkpIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG5cbiAgICAgICAgY29udGVudEhhbmRsZXIucmVjb25jaWxlQ2VsbEZyYW1lcyhtb2RpZmllZEluZGV4TGlzdClcbiAgICAgICAgY2FjaGVIYW5kbGVyLnBvcnRhbEhvbGRMaXN0ID0gcG9ydGFsSG9sZExpc3RcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSByZXR1cm5zIGZvciB1c2VyIGluZm9ybWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgcmV0dXJuIFtcblxuICAgICAgICAgICAgbW9kaWZpZWRJbmRleExpc3QsIFxuICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QsIFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCwgXG4gICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJbmRleExpc3QsXG4gICAgICAgICAgICBlcnJvckVudHJpZXNNYXAsIFxuICAgICAgICAgICAgY2hhbmdlTWFwXG5cbiAgICAgICAgXVxuXG4gICAgfVxuXG4gICAgLy8gbW92ZSBtdXN0IGJlIGVudGlyZWx5IHdpdGhpbiBsaXN0IGJvdW5kc1xuICAgIC8vIHJldHVybnMgbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlc1xuICAgIHB1YmxpYyBtb3ZlSW5kZXggPSAodG9pbmRleCwgZnJvbWluZGV4LCBoaWdocmFuZ2UgPSBudWxsKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBkZWZpbmUgcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyByZW1vdmUgbnVsbHNcbiAgICAgICAgdG9pbmRleCA9IHRvaW5kZXggPz8gMFxuICAgICAgICBmcm9taW5kZXggPSBmcm9taW5kZXggPz8gMFxuICAgICAgICBoaWdocmFuZ2UgPSBoaWdocmFuZ2UgPz8gZnJvbWluZGV4XG5cbiAgICAgICAgdG9pbmRleCA9IE1hdGgubWF4KDAsdG9pbmRleClcbiAgICAgICAgZnJvbWluZGV4ID0gTWF0aC5tYXgoMCxmcm9taW5kZXgpXG4gICAgICAgIGhpZ2hyYW5nZSA9IE1hdGgubWF4KDAsaGlnaHJhbmdlKVxuXG4gICAgICAgIC8vIGtlZXAgd2l0aGluIGN1cnJlbnQgbGlzdCBzaXplXG4gICAgICAgIGNvbnN0IGxpc3Rib3VuZCA9IGxpc3RzaXplIC0gMVxuXG4gICAgICAgIHRvaW5kZXggPSBcbiAgICAgICAgICAgICh0b2luZGV4ID4gbGlzdGJvdW5kKT9cbiAgICAgICAgICAgICAgICBsaXN0Ym91bmQ6XG4gICAgICAgICAgICAgICAgdG9pbmRleFxuXG4gICAgICAgIGZyb21pbmRleCA9IFxuICAgICAgICAgICAgKGZyb21pbmRleCA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIGZyb21pbmRleFxuXG4gICAgICAgIGhpZ2hyYW5nZSA9IFxuICAgICAgICAgICAgKGhpZ2hyYW5nZSA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZVxuXG4gICAgICAgIC8vIGhpZ2hyYW5nZSBtdXN0IGJlID49IGZyb21pbmRleFxuICAgICAgICBoaWdocmFuZ2UgPSBcbiAgICAgICAgICAgIChoaWdocmFuZ2UgPj0gZnJvbWluZGV4KT9cbiAgICAgICAgICAgICAgICBoaWdocmFuZ2U6XG4gICAgICAgICAgICAgICAgZnJvbWluZGV4XG5cbiAgICAgICAgY29uc3QgcmFuZ2VpbmNyZW1lbnQgPSBoaWdocmFuZ2UgLSBmcm9taW5kZXggKyAxXG4gICAgICAgIGNvbnN0IG1vdmVpbmNyZW1lbnQgPSB0b2luZGV4IC0gZnJvbWluZGV4XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBjb25zdHJhaW4gcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChmcm9taW5kZXggPT0gdG9pbmRleCkgcmV0dXJuIFtdIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICAvLyBtb3ZlIG11c3QgYmUgaW4gbGlzdCBib3VuZHNcbiAgICAgICAgaWYgKG1vdmVpbmNyZW1lbnQgPiAwKSB7IC8vIG1vdmUgdXBcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldHRvcCA9IHRvaW5kZXggKyAocmFuZ2VpbmNyZW1lbnQgLSAxKVxuICAgICAgICAgICAgaWYgKHRhcmdldHRvcCA+IGxpc3Rib3VuZCkgcmV0dXJuIFtdIC8vIG91dCBvZiBib3VuZHNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIHBlcmZvcm0gY2FjaGUgYW5kIGNyYWRsZSBvcGVyYXRpb25zIC0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5tb3ZlSW5kZXgodG9pbmRleCwgZnJvbWluZGV4LCBoaWdocmFuZ2UpXG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZEluZGV4TGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLmNoYW5nZUNyYWRsZUl0ZW1JRHMocHJvY2Vzc2VkSW5kZXhMaXN0KVxuXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRJbmRleExpc3RcblxuICAgIH1cblxuICAgIHB1YmxpYyBpbnNlcnRJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCArMSlcblxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCAtMSlcblxuICAgIH1cblxuICAgIC8vIHNoYXJlZCBsb2dpYy4gUmV0dXJucyBsaXN0cyBvZiBpdGVtcyBjaGFuZ2VkLCBhbmQgaXRlbXMgcmVwbGFjZWQgKG5ldyBpdGVtcyBmb3IgaW5zZXJ0KVxuICAgIC8vIHRoaXMgb3BlcmF0aW9uIGNoYW5nZXMgdGhlIGxpc3RzaXplXG4gICAgcHJpdmF0ZSBpbnNlcnRSZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIGluY3JlbWVudCkgPT4ge1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggPz8gMFxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IHJhbmdlaGlnaGluZGV4ID8/IGluZGV4XG5cbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLGluZGV4KVxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IE1hdGgubWF4KHJhbmdlaGlnaGluZGV4LCBpbmRleClcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFtjaGFuZ2VMaXN0LCByZXBsYWNlTGlzdCwgcmFuZ2VpbmNyZW1lbnQsIHBvcnRhbEhvbGRMaXN0XSA9IFxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgaW5jcmVtZW50LCBsaXN0c2l6ZSlcblxuICAgICAgICBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcy5tb2RpZmllZCA9IHRydWVcbiAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICBjYWNoZUhhbmRsZXIucG9ydGFsSG9sZExpc3QgPSBwb3J0YWxIb2xkTGlzdFxuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLmNoYW5nZUNyYWRsZUl0ZW1JRHMoY2hhbmdlTGlzdClcblxuICAgICAgICBpZiAoaW5jcmVtZW50ID09ICsxKSBjb250ZW50SGFuZGxlci5jcmVhdGVOZXdJdGVtSURzKHJlcGxhY2VMaXN0KVxuXG4gICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gY29udGVudEhhbmRsZXJcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcycpXG5cbiAgICAgICAgY29uc3QgY2hhbmdlY291bnQgPSByYW5nZWluY3JlbWVudCAvLyBzZW1hbnRpY3NcbiAgICAgICAgY29uc3QgbmV3bGlzdHNpemUgPSBsaXN0c2l6ZSArIGNoYW5nZWNvdW50IFxuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgcmV0dXJuIFtjaGFuZ2VMaXN0LCByZXBsYWNlTGlzdF1cblxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbIlNlcnZpY2VIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsInN0YXRlSGFuZGxlciIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImludGVycnVwdEhhbmRsZXIiLCJwYXVzZUludGVycnVwdHMiLCJzZXRDcmFkbGVTdGF0ZSIsImluZGV4IiwiTWF0aCIsIm1heCIsInNpZ25hbHMiLCJsYXlvdXRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwibmV3bGlzdHNpemUiLCJjYWNoZUhhbmRsZXIiLCJjYWxsYmFja3MiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwiY3VycmVudGxpc3RzaXplIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwibGlzdHNpemUiLCJjYWNoZSIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImNoYW5nZUxpc3RzaXplIiwiZ2V0Q2FjaGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsImNvbnRlbnRIYW5kbGVyIiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsImdldENyYWRsZUluZGV4TWFwIiwiY2hhbmdlTWFwIiwic2l6ZSIsImNhY2hlUHJvcHMiLCJtZXRhZGF0YU1hcCIsInBvcnRhbE1hcCIsImluZGV4VG9JdGVtSURNYXAiLCJpbmRleGVzVG9EZWxldGVMaXN0IiwiY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCIsIk1hcCIsImVycm9yRW50cmllc01hcCIsImZvckVhY2giLCJpdGVtSUQiLCJ1bmRlZmluZWQiLCJwdXNoIiwic2V0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaGFzIiwiZ2V0IiwibWFwc2l6ZSIsIml0ZW1JRFNldCIsIlNldCIsInZhbHVlcyIsIml0ZW1zZXRzaXplIiwiaXRlbUlEQ291bnRNYXAiLCJjb3VudCIsImR1cGxpY2F0ZUl0ZW1zTWFwIiwiZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCIsIm9yaWdpbmFsTWFwIiwibGVuZ3RoIiwicHJvY2Vzc2VkSW5kZXhMaXN0IiwiaXRlbWRhdGEiLCJkZWxldGVkSXRlbUlEVG9JbmRleE1hcCIsImRlbGV0ZWRJbmRleFRvSXRlbUlETWFwIiwicG9ydGFsSG9sZExpc3QiLCJvcmlnaW5hbEl0ZW1JRCIsIm9yaWdpbmFsSXRlbUlESW5kZXgiLCJmaW5hbEl0ZW1JREluZGV4IiwiZmluYWxJdGVtSUQiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJkZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0IiwiQXJyYXkiLCJmcm9tIiwiZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0Iiwia2V5cyIsImRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QiLCJtb2RpZmllZEluZGV4TGlzdCIsInJlY29uY2lsZUNlbGxGcmFtZXMiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiaGlnaHJhbmdlIiwibGlzdGJvdW5kIiwicmFuZ2VpbmNyZW1lbnQiLCJtb3ZlaW5jcmVtZW50IiwidGFyZ2V0dG9wIiwibW92ZUluZGV4IiwiY2hhbmdlQ3JhZGxlSXRlbUlEcyIsInJhbmdlaGlnaGluZGV4IiwiaW5zZXJ0UmVtb3ZlSW5kZXgiLCJpbmNyZW1lbnQiLCJjaGFuZ2VMaXN0IiwicmVwbGFjZUxpc3QiLCJjcmVhdGVOZXdJdGVtSURzIiwiY29udGVudCIsImNoYW5nZWNvdW50Iiwic2V0TGlzdHNpemUiLCJleHRlcm5hbENhbGxiYWNrc1JlZiIsInJlZmVyZW5jZUluZGV4Q2FsbGJhY2siLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsIml0ZW1FeGNlcHRpb25zQ2FsbGJhY2siLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n')},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(' // statehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to the cradle state (cradleState) and the state setting\n   function (setCradleState) for other handlers.\n   It also provides access to the isMountedRef reference.\n*/\n\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\n\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0lBTXFCQSxZLDZCQUVqQixzQkFBWUMsZ0JBQVosRUFBNEI7RUFBQTs7RUFFekIsS0FBS0EsZ0JBQUwsR0FBd0JBLGdCQUF4QjtFQUVBLElBQU1DLGtCQUFrQixHQUFHRCxnQkFBZ0IsQ0FBQ0UsMkJBQWpCLENBQTZDQyxPQUF4RTtFQUVBLEtBQUtDLGNBQUwsR0FBc0JILGtCQUFrQixDQUFDRyxjQUF6QztFQUNBLEtBQUtDLGNBQUwsR0FBc0JKLGtCQUFrQixDQUFDSSxjQUF6QztFQUNBLEtBQUtDLFlBQUwsR0FBb0JMLGtCQUFrQixDQUFDSyxZQUF2QztBQUVGLEM7O0FBWkxDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3g/NjM5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZWhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMiBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBjcmFkbGUgc3RhdGUgKGNyYWRsZVN0YXRlKSBhbmQgdGhlIHN0YXRlIHNldHRpbmcgXG4gICBmdW5jdGlvbiAoc2V0Q3JhZGxlU3RhdGUpIGZvciBvdGhlciBoYW5kbGVycy5cbiAgIEl0IGFsc28gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBpc01vdW50ZWRSZWYgcmVmZXJlbmNlLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIGNvbnN0IGludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgIHRoaXMuc2V0Q3JhZGxlU3RhdGUgPSBpbnRlcm5hbFByb3BlcnRpZXMuc2V0Q3JhZGxlU3RhdGVcbiAgICAgICB0aGlzLmNyYWRsZVN0YXRlUmVmID0gaW50ZXJuYWxQcm9wZXJ0aWVzLmNyYWRsZVN0YXRlUmVmXG4gICAgICAgdGhpcy5pc01vdW50ZWRSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuaXNNb3VudGVkUmVmXG4gICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgY3JhZGxlU3RhdGVSZWZcbiAgICBwdWJsaWMgc2V0Q3JhZGxlU3RhdGVcbiAgICBwdWJsaWMgaXNNb3VudGVkUmVmXG5cbn1cbiJdLCJuYW1lcyI6WyJTdGF0ZUhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiaW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInNldENyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc01vdW50ZWRSZWYiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval(" // styleshandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        triggercelltriggerlineheadstyles,\n        triggercelltriggerlinetailstyles,\n        cradledividerstyles\n*/\n\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, StylesHandler);\n\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n        cellHeight = _ref.cellHeight,\n        cellWidth = _ref.cellWidth,\n        cellMinHeight = _ref.cellMinHeight,\n        cellMinWidth = _ref.cellMinWidth,\n        gap = _ref.gap,\n        padding = _ref.padding,\n        crosscount = _ref.crosscount,\n        viewportheight = _ref.viewportheight,\n        viewportwidth = _ref.viewportwidth,\n        userstyles = _ref.userstyles,\n        triggerlineOffset = _ref.triggerlineOffset,\n        layout = _ref.layout;\n\n    var headstyles = _this.getBaseHeadStyles(gap, padding, orientation, userstyles.cradle);\n\n    var tailstyles = _this.getBaseTailStyles(gap, padding, orientation, userstyles.cradle);\n\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation, userstyles.axis);\n\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gap = tailstyles.gap = gap + 'px';\n\n    if (orientation == 'vertical') {\n      // padding varies\n      headstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px 0 \").concat(padding, \"px\");\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\"); // the following are identical for head and tail\n\n      headstyles.width = tailstyles.width = '100%';\n      headstyles.height = tailstyles.height = 'auto';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = null;\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellWidth, \"px, 1fr))\");\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'row';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = layout == 'uniform' ? null : 'max-content';\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = null;\n    } else {\n      // orientation == 'horizontal'\n      headstyles.padding = \"\".concat(padding, \"px 0 \").concat(padding, \"px \").concat(padding, \"px\");\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      headstyles.width = tailstyles.width = 'auto';\n      headstyles.height = tailstyles.height = '100%';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\");\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = null;\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'column';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = null;\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = layout == 'uniform' ? null : 'max-content';\n    }\n\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  }; // the top, right, bottom, left setting determine the direction of expansion of the grid block\n\n\n  this.getBaseHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = null;\n      right = null;\n      top = null;\n    } else {\n      bottom = null;\n      left = null;\n      right = 0;\n      top = null;\n    }\n\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  }; // the top, right, bottom, left setting determine the direction of expansion of the grid block\n\n\n  this.getBaseTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = null;\n      left = null;\n      right = null;\n      top = 0;\n    } else {\n      bottom = null;\n      left = 0;\n      right = null;\n      top = null;\n    }\n\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n\n  this.getAxisStyles = function (gap, padding, orientation, useraxisstyles) {\n    var top, left, width, height; // for axis\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n      width = '100%';\n      height = 0;\n    } else {\n      top = 'auto';\n      left = padding + 'px';\n      width = 0;\n      height = '100%';\n    }\n\n    return Object.assign(Object.assign({}, useraxisstyles), {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, left;\n\n    if (orientation == 'vertical') {\n      height = 0;\n      width = '100%';\n      left = 'auto';\n      top = triggerlineOffset + 'px';\n    } else {\n      height = '100%';\n      width = 0;\n      left = triggerlineOffset + 'px';\n      top = 'auto';\n    }\n\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      left: left\n    };\n  };\n\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, bottom, right;\n\n    if (orientation == 'vertical') {\n      height = 0;\n      width = '100%';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      right = 'auto';\n    } else {\n      height = '100%';\n      width = 0;\n      bottom = 'auto';\n      right = -(triggerlineOffset + gap) + 'px';\n    }\n\n    return {\n      position: position,\n      width: width,\n      height: height,\n      bottom: bottom,\n      right: right\n    };\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxNQUFUO01BQ0FHLEtBQUssR0FBRyxFQUFFN0IsaUJBQWlCLEdBQUdOLEdBQXRCLElBQTZCLElBQXJDO0lBRUg7O0lBRUQsT0FBTztNQUVIc0IsUUFBUSxFQUFSQSxRQUZHO01BR0hDLEtBQUssRUFBTEEsS0FIRztNQUlIQyxNQUFNLEVBQU5BLE1BSkc7TUFLSFEsTUFBTSxFQUFOQSxNQUxHO01BTUhHLEtBQUssRUFBTEE7SUFORyxDQUFQO0VBU0gsQ0EvQk87O0VBN09OLEtBQUt6QyxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBRUQsQzs7QUFOTCtDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0eWxlc2hhbmRsZXIudHN4PzQ1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGVzaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIENyYWRsZSBjb21wb25lbnQgd2l0aCBvbmUga2V5IGZ1bmN0aW9uOiBnZXRDcmFkbGVTdHlsZXMuXG4gICAgSXQgcmV0dXJucyBhbiBhcnJheSBvZiBzdHlsZSBvYmplY3RzIGZvclxuICAgICAgICBoZWFkc3R5bGVzLFxuICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICBheGlzc3R5bGVzLFxuICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMsXG4gICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXNcbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlc0hhbmRsZXIgeyBcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBnZXRDcmFkbGVTdHlsZXMgPSAoe1xuXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgdXNlcnN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQsXG4gICAgICAgIGxheW91dCxcblxuICAgIH0pID0+IHtcblxuICAgICAgICBjb25zdCBoZWFkc3R5bGVzID0gdGhpcy5nZXRCYXNlSGVhZFN0eWxlcyhnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uLCB1c2Vyc3R5bGVzLmNyYWRsZSlcbiAgICAgICAgY29uc3QgdGFpbHN0eWxlcyA9IHRoaXMuZ2V0QmFzZVRhaWxTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IGF4aXNzdHlsZXMgPSB0aGlzLmdldEF4aXNTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5heGlzKVxuXG4gICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzID1cbiAgICAgICAgICAgIHRoaXMuZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZXMoXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5ldGFpbHN0eWxlcyA9IFxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyhcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApXG5cbiAgICAgICAgY29uc3QgY3JhZGxlZGl2aWRlcnN0eWxlcyA9IFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHpJbmRleDoxLCBcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHdpZHRoOicxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGJveFNoYWRvdzonMCAwIDVweCAzcHggcmVkJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGhlYWRzdHlsZXMuZ2FwID0gdGFpbHN0eWxlcy5nYXAgPSBnYXAgKyAncHgnXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgLy8gcGFkZGluZyB2YXJpZXNcbiAgICAgICAgICAgIGhlYWRzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4YFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGlkZW50aWNhbCBmb3IgaGVhZCBhbmQgdGFpbFxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9IHRhaWxzdHlsZXMud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuaGVpZ2h0ID0gdGFpbHN0eWxlcy5oZWlnaHQgPSAnYXV0bydcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFxuICAgICAgICAgICAgICAgICAgICBgcmVwZWF0KCR7Y3Jvc3Njb3VudH0sIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvUm93cyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b1Jvd3MgPVxuICAgICAgICAgICAgICAgIChsYXlvdXQgPT0gJ3VuaWZvcm0nKT9cbiAgICAgICAgICAgICAgICAgICAgbnVsbDpcbiAgICAgICAgICAgICAgICAgICAgJ21heC1jb250ZW50J1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9Db2x1bW5zID0gbnVsbFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwYFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLndpZHRoID0gdGFpbHN0eWxlcy53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSB0YWlsc3R5bGVzLmhlaWdodCA9ICcxMDAlJ1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgICAgICAgICBgcmVwZWF0KCR7Y3Jvc3Njb3VudH0sIG1pbm1heCgke2NlbGxIZWlnaHR9cHgsIDFmcikpYFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBudWxsXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAnY29sdW1uJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b1Jvd3MgPSB0YWlsc3R5bGVzLmdyaWRBdXRvUm93cyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9Db2x1bW5zID0gXG4gICAgICAgICAgICAgICAgKGxheW91dCA9PSAndW5pZm9ybScpP1xuICAgICAgICAgICAgICAgICAgICBudWxsOlxuICAgICAgICAgICAgICAgICAgICAnbWF4LWNvbnRlbnQnXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoZWFkc3R5bGVzLFxuICAgICAgICAgICAgdGFpbHN0eWxlcyxcbiAgICAgICAgICAgIGF4aXNzdHlsZXMsXG4gICAgICAgICAgICBjcmFkbGVkaXZpZGVyc3R5bGVzLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZWhlYWRzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5ldGFpbHN0eWxlcyxcbiAgICAgICAgXVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvLyB0aGUgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IHNldHRpbmcgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgZXhwYW5zaW9uIG9mIHRoZSBncmlkIGJsb2NrXG4gICAgcHJpdmF0ZSBnZXRCYXNlSGVhZFN0eWxlcyA9IFxuICAgICAgICAoZ2FwLHBhZGRpbmcsb3JpZW50YXRpb24sdXNlcmhlYWRzdHlsZXMpID0+IHtcblxuICAgICAgICBsZXQgYm90dG9tLCBsZWZ0LCB0b3AsIHJpZ2h0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSBudWxsXG4gICAgICAgICAgICByaWdodCA9IG51bGxcbiAgICAgICAgICAgIHRvcCA9IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IG51bGxcbiAgICAgICAgICAgIGxlZnQgPSBudWxsXG4gICAgICAgICAgICByaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi51c2VyaGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgc2V0dGluZyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiBleHBhbnNpb24gb2YgdGhlIGdyaWQgYmxvY2tcbiAgICBwcml2YXRlIGdldEJhc2VUYWlsU3R5bGVzID0gXG4gICAgICAgIChnYXAscGFkZGluZyxvcmllbnRhdGlvbix1c2VydGFpbHN0eWxlcykgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgdG9wID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnVzZXJ0YWlsc3R5bGVzLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICB9IFxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QXhpc1N0eWxlcyA9IFxuICAgICAgICAoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcmF4aXNzdHlsZXMpID0+IHtcblxuICAgICAgICBsZXQgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IC8vIGZvciBheGlzXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCdcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWlnaHQgPSAwXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBsZWZ0ID0gcGFkZGluZyArICdweCdcbiAgICAgICAgICAgIHdpZHRoID0gMFxuICAgICAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi51c2VyYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZXMgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApID0+IHtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICdhYnNvbHV0ZSdcblxuICAgICAgICBsZXQgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICB0b3AgPSB0cmlnZ2VybGluZU9mZnNldCArICdweCdcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHdpZHRoID0gMFxuICAgICAgICAgICAgbGVmdCA9IHRyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcblxuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZXMgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApID0+IHtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICdhYnNvbHV0ZSdcblxuICAgICAgICBsZXQgd2lkdGgsIGhlaWdodCwgYm90dG9tLCByaWdodFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWlnaHQgPSAwXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgYm90dG9tID0gLSh0cmlnZ2VybGluZU9mZnNldCArIGdhcCkgKyAncHgnXG4gICAgICAgICAgICByaWdodCA9ICdhdXRvJ1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBib3R0b20gPSAnYXV0bydcbiAgICAgICAgICAgIHJpZ2h0ID0gLSh0cmlnZ2VybGluZU9mZnNldCArIGdhcCkgKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJTdHlsZXNIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJnYXAiLCJwYWRkaW5nIiwiY3Jvc3Njb3VudCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVzZXJzdHlsZXMiLCJ0cmlnZ2VybGluZU9mZnNldCIsImxheW91dCIsImhlYWRzdHlsZXMiLCJnZXRCYXNlSGVhZFN0eWxlcyIsImNyYWRsZSIsInRhaWxzdHlsZXMiLCJnZXRCYXNlVGFpbFN0eWxlcyIsImF4aXNzdHlsZXMiLCJnZXRBeGlzU3R5bGVzIiwiYXhpcyIsInRyaWdnZXJjZWxsdHJpZ2dlcmxpbmVoZWFkc3R5bGVzIiwiZ2V0VHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5ldGFpbHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzIiwiY3JhZGxlZGl2aWRlcnN0eWxlcyIsInpJbmRleCIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJib3hTaGFkb3ciLCJncmlkVGVtcGxhdGVSb3dzIiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsImdyaWRBdXRvRmxvdyIsImdyaWRBdXRvUm93cyIsImdyaWRBdXRvQ29sdW1ucyIsInVzZXJoZWFkc3R5bGVzIiwiYm90dG9tIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiZGlzcGxheSIsImdyaWRHYXAiLCJib3hTaXppbmciLCJ1c2VydGFpbHN0eWxlcyIsInVzZXJheGlzc3R5bGVzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./src/infinitegridscroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(' // InfiniteGridScroller.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the Scrollblock, which is full size for listsize of given cell height/width.\n    Scrollblock in turn contains the Cradle - a component that contains CellFrames, which contain\n    displayed user content (items) or transitional placeholders.\n\n    Host content is instantiated in a cache of React portals (via cacheHandler). content is then\n    portal\'d to host CellFrames. The cache can be configured to hold many more items\n    than the Cradle (limited by device memory, and some eventual performance degradation), allowing\n    cached host content to maintain state.\n\n    Scrollblock by size represents the entirety of the list, and is the object that is scrolled.\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as\n    though it scrolls over a filled scrollblock, but in fact it is only slightly larger than\n    the viewport. Content is rotated in and out of the cradle (through the cache)\n    \n    Individual host items are framed by CellFrame, managed by Cradle\n\n    Overall the InfiniteGridScroller as a package manages the asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n\n    The Rigs liner is set with \'display:absolute\' and \'inset:0\', so the user containing block should\n    be styles accordingly.\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react")); // defensive\n\n\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ "./node_modules/react-error-boundary/dist/react-error-boundary.umd.js"); // www.npmjs.com/package/react-error-boundary\n// based on module template\n\n\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n      resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert"\n  }, react_1["default"].createElement("p", null, "Oops! Something went wrong inside react-infinite-grid-scroller."), react_1["default"].createElement("p", null, "Click to cancel the error and continue."), react_1["default"].createElement("button", {\n    onClick: resetErrorBoundary\n  }, "Cancel error"), react_1["default"].createElement("pre", null, error));\n} // scroller components\n\n\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\n\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\n\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx")); // loaded here to minimize redundant renders in Cradle\n\n\nvar cachehandler_1 = __webpack_require__(/*! ./cradle/cachehandler */ "./src/cradle/cachehandler.tsx"); // -------------------[ global session ID generator ]----------------\n\n\nvar globalScrollerID = 0; // ===================================[ INITIALIZE ]===========================\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      _props$estimatedListS = props.estimatedListSize,\n      estimatedListSize = _props$estimatedListS === void 0 ? 0 : _props$estimatedListS,\n      getItem = props.getItem,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n      _props$gap = props.gap,\n      gap = _props$gap === void 0 ? 0 : _props$gap,\n      _props$padding = props.padding,\n      padding = _props$padding === void 0 ? 0 : _props$padding,\n      _props$layout = props.layout,\n      layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n      _props$cellMinHeight = props.cellMinHeight,\n      cellMinHeight = _props$cellMinHeight === void 0 ? 0 : _props$cellMinHeight,\n      _props$cellMinWidth = props.cellMinWidth,\n      cellMinWidth = _props$cellMinWidth === void 0 ? 0 : _props$cellMinWidth,\n      _props$runwaySize = props.runwaySize,\n      runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n      _props$startingIndex = props.startingIndex,\n      startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n      placeholder = props.placeholder,\n      _props$styles = props.styles,\n      styles = _props$styles === void 0 ? {} : _props$styles,\n      _props$useScrollTrack = props.useScrollTracker,\n      useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n      _props$cache = props.cache,\n      cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n      _props$cacheMax = props.cacheMax,\n      cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n      _props$triggerlineOff = props.triggerlineOffset,\n      triggerlineOffset = _props$triggerlineOff === void 0 ? 10 : _props$triggerlineOff,\n      _props$callbacks = props.callbacks,\n      callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n      _props$advanced = props.advanced,\n      advanced = _props$advanced === void 0 ? {} : _props$advanced,\n      scrollerProperties = props.scrollerProperties;\n\n  if (!(cellWidth && cellHeight && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight and getItem are required\');\n    return null;\n  } // ---------------------[ Data setup ]----------------------\n  // avoid null/undefined\n\n\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  advanced = advanced !== null && advanced !== void 0 ? advanced : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  estimatedListSize = estimatedListSize !== null && estimatedListSize !== void 0 ? estimatedListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  cellMinHeight = cellMinHeight !== null && cellMinHeight !== void 0 ? cellMinHeight : 0;\n  cellMinWidth = cellMinWidth !== null && cellMinWidth !== void 0 ? cellMinWidth : 0;\n  cellMinHeight = Math.max(cellMinHeight, 25);\n  cellMinWidth = Math.max(cellMinWidth, 25);\n  cellMinHeight = Math.min(cellHeight, cellMinHeight);\n  cellMinWidth = Math.min(cellWidth, cellMinWidth); // prop constraints - non-negative values\n\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n\n  estimatedListSize = Math.max(0, estimatedListSize);\n  startingIndex = Math.max(0, startingIndex); // enums\n\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  } // package\n\n\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs); // state\n\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      scrollerState = _ref3[0],\n      setScrollerState = _ref3[1]; // setup, setlistsize, ready\n  // system\n\n\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var _advanced = advanced,\n      showAxis = _advanced.showAxis,\n      VIEWPORT_RESIZE_TIMEOUT = _advanced.VIEWPORT_RESIZE_TIMEOUT,\n      SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = _advanced.SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n      IDLECALLBACK_TIMEOUT = _advanced.IDLECALLBACK_TIMEOUT,\n      TIMEOUT_FOR_VARIABLE_MEASUREMENTS = _advanced.TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n      MAX_CACHE_OVER_RUN = _advanced.MAX_CACHE_OVER_RUN;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== null && SCROLL_TIMEOUT_FOR_ONAFTERSCROLL !== void 0 ? SCROLL_TIMEOUT_FOR_ONAFTERSCROLL : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 4000;\n  TIMEOUT_FOR_VARIABLE_MEASUREMENTS = TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== null && TIMEOUT_FOR_VARIABLE_MEASUREMENTS !== void 0 ? TIMEOUT_FOR_VARIABLE_MEASUREMENTS : 100;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true; // for mount version\n\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current; // for children\n\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(estimatedListSize);\n  var listsize = listsizeRef.current; // tests for React with Object.is for changed properties; avoid re-renders with no change\n\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  } // -------------------------[ Initialization ]-------------------------------\n\n\n  (0, react_1.useEffect)(function () {\n    scrollerSessionIDRef.current = globalScrollerID++;\n    cacheHandlerRef.current = new cachehandler_1.CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef);\n  }, []); // called when getItem returns null, or direct call from user (see serviceHandler)\n\n  var setListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize; // inform the user\n\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistsize\');\n  }, []); // ---------------------[ State handling ]------------------------\n\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n      case \'setlistsize\':\n        setScrollerState(\'ready\');\n    }\n  }, [scrollerState]); // --------------------[ Render ]---------------------\n  // component calls are deferred by scrollerState to give cacheHandler a chance to initialize\n\n  return react_1["default"].createElement(react_1["default"].StrictMode, null, react_1["default"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {// response tbd; there may not need to be one\n    },\n    onError: function onError(error, info) {\n      console.log(\'react-infinite-grid-scroller captured error\', error);\n    }\n  }, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    scrollerProperties: scrollerProperties,\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    cacheHandler: cacheHandlerRef.current,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    SCROLL_TIMEOUT_FOR_ONAFTERSCROLL: SCROLL_TIMEOUT_FOR_ONAFTERSCROLL,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    TIMEOUT_FOR_VARIABLE_MEASUREMENTS: TIMEOUT_FOR_VARIABLE_MEASUREMENTS,\n    scrollerID: scrollerID\n  }))), scrollerState != \'setup\' && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(cachehandler_1.PortalList, {\n    cacheProps: cacheHandlerRef.current.cacheProps\n  }))));\n};\n\nexports["default"] = InfiniteGridScroller; // ----------------------------[ Support ]------------------------------\n\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\n\nfunction compareProps(obj1, obj2) {\n  var keys = Object.keys(obj1);\n  var same;\n\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5maW5pdGVncmlkc2Nyb2xsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBLHNFLENBRUE7OztBQUNBLHFKLENBQXFEO0FBRXJEOzs7QUFDQSxTQUFTQSxhQUFULE9BQWtEO0VBQUEsSUFBMUJDLEtBQTBCLFFBQTFCQSxLQUEwQjtFQUFBLElBQW5CQyxrQkFBbUIsUUFBbkJBLGtCQUFtQjtFQUNoRCxPQUNFQztJQUFLQyxJQUFJLEVBQUM7RUFBVixHQUNFRCw4R0FERixFQUVFQSxzRkFGRixFQUdFQTtJQUFRRSxPQUFPLEVBQUdIO0VBQWxCLEdBQW9DLGNBQXBDLENBSEYsRUFJRUMsOENBQU1GLEtBQU4sQ0FKRixDQURGO0FBUUQsQyxDQUVEOzs7QUFDQTs7QUFDQTs7QUFDQSx3RixDQUVBOzs7QUFDQSx1RyxDQUVBOzs7QUFFQSxJQUFJSyxnQkFBZ0IsR0FBRyxDQUF2QixDLENBRUE7O0FBRUEsSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDQyxLQUFELEVBQVU7RUFFbkM7RUFFQSxJQUdJQyxVQUhKLEdBMENJRCxLQTFDSixDQUdJQyxVQUhKO0VBQUEsSUFLSUMsU0FMSixHQTBDSUYsS0ExQ0osQ0FLSUUsU0FMSjtFQUFBLDRCQTBDSUYsS0ExQ0osQ0FPSUcsaUJBUEo7RUFBQSxJQU9JQSxpQkFQSixzQ0FPd0IsQ0FQeEI7RUFBQSxJQVFJQyxPQVJKLEdBMENJSixLQTFDSixDQVFJSSxPQVJKO0VBQUEseUJBMENJSixLQTFDSixDQWFJSyxXQWJKO0VBQUEsSUFhSUEsV0FiSixtQ0Fha0IsVUFibEI7RUFBQSxpQkEwQ0lMLEtBMUNKLENBY0lNLEdBZEo7RUFBQSxJQWNJQSxHQWRKLDJCQWNVLENBZFY7RUFBQSxxQkEwQ0lOLEtBMUNKLENBZUlP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QyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELE9BQU8sSUFBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmZpbml0ZUdyaWRTY3JvbGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciA9IFJJR1NcblxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIFNjcm9sbGJsb2NrLCB3aGljaCBpcyBmdWxsIHNpemUgZm9yIGxpc3RzaXplIG9mIGdpdmVuIGNlbGwgaGVpZ2h0L3dpZHRoLlxuICAgIFNjcm9sbGJsb2NrIGluIHR1cm4gY29udGFpbnMgdGhlIENyYWRsZSAtIGEgY29tcG9uZW50IHRoYXQgY29udGFpbnMgQ2VsbEZyYW1lcywgd2hpY2ggY29udGFpbiBcbiAgICBkaXNwbGF5ZWQgdXNlciBjb250ZW50IChpdGVtcykgb3IgdHJhbnNpdGlvbmFsIHBsYWNlaG9sZGVycy4gXG5cbiAgICBIb3N0IGNvbnRlbnQgaXMgaW5zdGFudGlhdGVkIGluIGEgY2FjaGUgb2YgUmVhY3QgcG9ydGFscyAodmlhIGNhY2hlSGFuZGxlcikuIGNvbnRlbnQgaXMgdGhlbiBcbiAgICBwb3J0YWwnZCB0byBob3N0IENlbGxGcmFtZXMuIFRoZSBjYWNoZSBjYW4gYmUgY29uZmlndXJlZCB0byBob2xkIG1hbnkgbW9yZSBpdGVtc1xuICAgIHRoYW4gdGhlIENyYWRsZSAobGltaXRlZCBieSBkZXZpY2UgbWVtb3J5LCBhbmQgc29tZSBldmVudHVhbCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiksIGFsbG93aW5nIFxuICAgIGNhY2hlZCBob3N0IGNvbnRlbnQgdG8gbWFpbnRhaW4gc3RhdGUuXG5cbiAgICBTY3JvbGxibG9jayBieSBzaXplIHJlcHJlc2VudHMgdGhlIGVudGlyZXR5IG9mIHRoZSBsaXN0LCBhbmQgaXMgdGhlIG9iamVjdCB0aGF0IGlzIHNjcm9sbGVkLlxuXG4gICAgQ3JhZGxlIGNvbnRhaW5zIHRoZSBsaXN0IGl0ZW1zLCBhbmQgaXMgJ3ZpcnR1YWxpemVkJyAtLSBpdCBhcHBlYXJzIGFzXG4gICAgdGhvdWdoIGl0IHNjcm9sbHMgb3ZlciBhIGZpbGxlZCBzY3JvbGxibG9jaywgYnV0IGluIGZhY3QgaXQgaXMgb25seSBzbGlnaHRseSBsYXJnZXIgdGhhblxuICAgIHRoZSB2aWV3cG9ydC4gQ29udGVudCBpcyByb3RhdGVkIGluIGFuZCBvdXQgb2YgdGhlIGNyYWRsZSAodGhyb3VnaCB0aGUgY2FjaGUpXG4gICAgXG4gICAgSW5kaXZpZHVhbCBob3N0IGl0ZW1zIGFyZSBmcmFtZWQgYnkgQ2VsbEZyYW1lLCBtYW5hZ2VkIGJ5IENyYWRsZVxuXG4gICAgT3ZlcmFsbCB0aGUgSW5maW5pdGVHcmlkU2Nyb2xsZXIgYXMgYSBwYWNrYWdlIG1hbmFnZXMgdGhlIGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgb2YgdGhlIFxuICAgIGNvbXBvbmVudHMgb2YgdGhlIG1lY2hhbmlzbS4gTW9zdCBvZiB0aGUgd29yayBvY2N1cnMgaW4gdGhlIENyYWRsZSBjb21wb25lbnQuXG5cbiAgICBUaGUgUmlncyBsaW5lciBpcyBzZXQgd2l0aCAnZGlzcGxheTphYnNvbHV0ZScgYW5kICdpbnNldDowJywgc28gdGhlIHVzZXIgY29udGFpbmluZyBibG9jayBzaG91bGRcbiAgICBiZSBzdHlsZXMgYWNjb3JkaW5nbHkuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBkZWZlbnNpdmVcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICdyZWFjdC1lcnJvci1ib3VuZGFyeScgLy8gd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LWVycm9yLWJvdW5kYXJ5XG5cbi8vIGJhc2VkIG9uIG1vZHVsZSB0ZW1wbGF0ZVxuZnVuY3Rpb24gRXJyb3JGYWxsYmFjayh7ZXJyb3IsIHJlc2V0RXJyb3JCb3VuZGFyeX0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IHJvbGU9XCJhbGVydFwiPlxuICAgICAgPHA+T29wcyEgU29tZXRoaW5nIHdlbnQgd3JvbmcgaW5zaWRlIHJlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIuPC9wPlxuICAgICAgPHA+Q2xpY2sgdG8gY2FuY2VsIHRoZSBlcnJvciBhbmQgY29udGludWUuPC9wPlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsgcmVzZXRFcnJvckJvdW5kYXJ5IH0+Q2FuY2VsIGVycm9yPC9idXR0b24+XG4gICAgICA8cHJlPntlcnJvcn08L3ByZT5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG4vLyBzY3JvbGxlciBjb21wb25lbnRzXG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi9WaWV3cG9ydCdcbmltcG9ydCBTY3JvbGxibG9jayBmcm9tICcuL1Njcm9sbGJsb2NrJ1xuaW1wb3J0IENyYWRsZSBmcm9tICcuL0NyYWRsZSdcblxuLy8gbG9hZGVkIGhlcmUgdG8gbWluaW1pemUgcmVkdW5kYW50IHJlbmRlcnMgaW4gQ3JhZGxlXG5pbXBvcnQgeyBDYWNoZUhhbmRsZXIsIFBvcnRhbExpc3QgfSBmcm9tICcuL2NyYWRsZS9jYWNoZWhhbmRsZXInXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGdsb2JhbCBzZXNzaW9uIElEIGdlbmVyYXRvciBdLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgZ2xvYmFsU2Nyb2xsZXJJRCA9IDBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1bIElOSVRJQUxJWkUgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBJbmZpbml0ZUdyaWRTY3JvbGxlciA9IChwcm9wcykgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tWyBub3JtYWxpemUgcHJvcGVydGllcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCB7IFxuXG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIGNlbGxIZWlnaHQsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgaGVpZ2h0IC0gbGl0ZXJhbCBmb3IgdmVydGljYWw7IGFwcHJveGltYXRlIGZvciBob3Jpem9udGFsXG4gICAgICAgICAgICAvLyBiYXNlIGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgY2VsbFdpZHRoLCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIHdpZHRoIC0gbGl0ZXJhbCBmb3IgaG9yaXpvbnRhbDsgYXBwcm94aW1hdGUgZm9yIHZlcnRpY2FsXG4gICAgICAgICAgICAvLyBiYXNlIGZvciB2YXJpYWJsZSBsYXlvdXRcbiAgICAgICAgZXN0aW1hdGVkTGlzdFNpemUgPSAwLCAvLyB0aGUgZXN0aW1hdGVkIG51bWJlciBvZiB0aGUgaXRlbXMgaW4gdGhlIHZpcnR1YWwgbGlzdC4gY2FuIGJlIG1vZGlmaWVkXG4gICAgICAgIGdldEl0ZW0sIC8vIHJlcXVpcmVkLiBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0IC0gcGFyYW1ldGVycyBhcmUgaW5kZXggbnVtYmVyLCBzZXQgYnkgc3lzdGVtLFxuICAgICAgICAgICAgLy8gYW5kIHNlc3Npb24gaXRlbUlEIGZvciB0cmFja2luZyBhbmQgbWF0Y2hpbmc7IFxuICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGhvc3Qtc2VsZWN0ZWQgY29tcG9uZW50IG9yIHByb21pc2Ugb2YgYSBjb21wb25lbnQsIG9yIG51bGwgb3IgdW5kZWZpbmVkXG5cbiAgICAgICAgLy8gKiogZ3JpZCBzcGVjczpcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAvLyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsXG4gICAgICAgIGdhcCA9IDAsIC8vIHNwYWNlIGJldHdlZW4gZ3JpZCBjZWxscywgbm90IGluY2x1ZGluZyB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuICAgICAgICBwYWRkaW5nID0gMCwgLy8gdGhlIGJvcmRlciBzcGFjZSBiZXR3ZWVuIHRoZSBpdGVtcyBhbmQgdGhlIHZpZXdwb3J0LCBhcHBsaWVkIHRvIHRoZSBjcmFkbGVcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nLCAvLyB1bmlmb3JtLCB2YXJpYWJsZVxuICAgICAgICBjZWxsTWluSGVpZ2h0ID0gMCwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCdcbiAgICAgICAgY2VsbE1pbldpZHRoID0gMCwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJ1xuXG4gICAgICAgIC8vICoqIHNjcm9sbGVyIHNwZWNzOlxuICAgICAgICBydW53YXlTaXplID0gMywgLy8gdGhlIG51bWJlciBvZiByb3dzIG91dHNpZGUgdGhlIHZpZXcgb2YgZWFjaCBzaWRlIG9mIHRoZSB2aWV3cG9ydCBcbiAgICAgICAgICAgIC8vIC0tIGdpdmVzIHRpbWUgdG8gYXNzZW1ibGUgY2VsbEZyYW1lcyBiZWZvcmUgZGlzcGxheVxuICAgICAgICBzdGFydGluZ0luZGV4ID0gMCwgLy8gdGhlIDAtYmFzZWQgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGxpc3QsIHdoZW4gZmlyc3QgbG9hZGVkXG4gICAgICAgIHBsYWNlaG9sZGVyLCAvLyBvcHRpb25hbC4gYSBzcGFyc2UgY29tcG9uZW50IHRvIHN0YW5kIGluIGZvciBjb250ZW50IHVudGlsIHRoZSBjb250ZW50IGFycml2ZXM7IFxuICAgICAgICAgICAgLy8gcmVwbGFjZXMgZGVmYXVsdCBwbGFjZWhvbGRlciBpZiBwcmVzZW50XG4gICAgICAgIHN0eWxlcyA9IHt9LCAvLyBvcHRpb25hbC4gcGFzc2l2ZSBzdHlsZSBvdmVyLXJpZGVzIChlZy4gY29sb3IsIG9wYWNpdHkpOyBoYXMgXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHZpZXdwb3J0LCBzY3JvbGxibG9jaywgY3JhZGxlLCBzY3JvbGx0cmFja2VyLCBwbGFjZWhvbGRlcmZyYW1lLCBvclxuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXJjb250ZW50LiBEbyBub3QgbWFrZSBzdHJ1Y3R1cmFsIGNoYW5nZXMhXG5cbiAgICAgICAgLy8gKiogc3lzdGVtIHNwZWNzOlxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZSwgLy8gdGhlIGludGVybmFsIGNvbXBvbmVudCB0byBnaXZlIGZlZWRiYWNrIGZvciByZXBvc2l0aW9uaW5nXG4gICAgICAgIGNhY2hlID0gJ2NyYWRsZScsIC8vIFwicHJlbG9hZFwiLCBcImtlZXBsb2FkXCIgb3IgXCJjcmFkbGVcIlxuICAgICAgICBjYWNoZU1heCA9IG51bGwsIC8vIGFsd2F5cyBtaW5pbXVtIGNyYWRsZTsgbnVsbCBtZWFucyBsaW1pdGVkIGJ5IGxpc3RzaXplXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0gMTAsIC8vIGRpc3RhbmNlIGZyb20gY2VsbCBoZWFkIG9yIHRhaWwgZm9yIGNvbnRlbnQgc2hpZnRzIGFib3ZlL2JlbG93IGF4aXNcbiAgICAgICAgY2FsbGJhY2tzID0ge30sIC8vIG9wdGlvbmFsLiBjbG9zdXJlcyB0byBnZXQgZGlyZWN0IGluZm9ybWF0aW9uIHN0cmVhbXMgb2Ygc29tZSBjb21wb25lbnQgdXRpbGl0ZXNcbiAgICAgICAgICAgIC8vIGNhbiBjb250YWluIGdldEZ1bmN0aW9ucywgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGludGVybmFsIHNjcm9sbGVyIGZ1bmN0aW9ucyAobW9zdGx5IGNhY2hlIG1hbmFnZW1lbnQpXG4gICAgICAgIGFkdmFuY2VkID0ge30sIC8vIG9wdGlvbmFsLiB0ZWNobmljYWwgc2V0dGluZ3MgbGlrZSBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVFxuXG4gICAgICAgIC8vICoqIGluZm9ybWF0aW9uIGZvciBob3N0IGNlbGwgY29udGVudFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMsIC8vIHJlcXVpcmVkIGZvciBlbWJlZGRlZCBzY3JvbGxlcjsgc2hhcmVzIHNjcm9sbGVyIHNldHRpbmdzIHdpdGggY29udGVudFxuXG4gICAgfSA9IHByb3BzXG5cbiAgICBpZiAoIShjZWxsV2lkdGggJiYgY2VsbEhlaWdodCAmJiBnZXRJdGVtICkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JJR1M6IGNlbGxXaWR0aCwgY2VsbEhlaWdodCBhbmQgZ2V0SXRlbSBhcmUgcmVxdWlyZWQnKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgRGF0YSBzZXR1cCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gYXZvaWQgbnVsbC91bmRlZmluZWRcbiAgICBzdHlsZXMgPSBzdHlsZXMgPz8ge31cbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgPz8ge31cbiAgICBhZHZhbmNlZCA9IGFkdmFuY2VkID8/IHt9XG4gICAgc3RhcnRpbmdJbmRleCA9IHN0YXJ0aW5nSW5kZXggPz8gMFxuICAgIGVzdGltYXRlZExpc3RTaXplID0gZXN0aW1hdGVkTGlzdFNpemUgPz8gMFxuICAgIHJ1bndheVNpemUgPSBydW53YXlTaXplID8/IDNcbiAgICB1c2VTY3JvbGxUcmFja2VyID0gdXNlU2Nyb2xsVHJhY2tlciA/PyB0cnVlXG4gICAgY2VsbE1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgPz8gMFxuICAgIGNlbGxNaW5XaWR0aCA9IGNlbGxNaW5XaWR0aCA/PyAwXG5cbiAgICBjZWxsTWluSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbE1pbkhlaWdodCwgMjUpXG4gICAgY2VsbE1pbldpZHRoID0gTWF0aC5tYXgoY2VsbE1pbldpZHRoLCAyNSlcbiAgICBjZWxsTWluSGVpZ2h0ID0gTWF0aC5taW4oY2VsbEhlaWdodCwgY2VsbE1pbkhlaWdodClcbiAgICBjZWxsTWluV2lkdGggPSBNYXRoLm1pbihjZWxsV2lkdGgsIGNlbGxNaW5XaWR0aClcblxuICAgIC8vIHByb3AgY29uc3RyYWludHMgLSBub24tbmVnYXRpdmUgdmFsdWVzXG4gICAgcnVud2F5U2l6ZSA9IE1hdGgubWF4KDEscnVud2F5U2l6ZSkgLy8gcnVud2F5c2l6ZSBtdXN0IGJlIGF0IGxlYXN0IDFcbiAgICBlc3RpbWF0ZWRMaXN0U2l6ZSA9IE1hdGgubWF4KDAsZXN0aW1hdGVkTGlzdFNpemUpXG4gICAgc3RhcnRpbmdJbmRleCA9IE1hdGgubWF4KDAsc3RhcnRpbmdJbmRleClcblxuICAgIC8vIGVudW1zXG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkgeyBcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIGlmICghWydwcmVsb2FkJywna2VlcGxvYWQnLCdjcmFkbGUnXS5pbmNsdWRlcyhjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJ1xuICAgIH1cbiAgICBpZiAoIVsndW5pZm9ybScsICd2YXJpYWJsZSddLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nXG4gICAgfVxuXG4gICAgLy8gcGFja2FnZVxuICAgIGNvbnN0IGdyaWRTcGVjcyA9IHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGxheW91dCxcbiAgICB9XG5cbiAgICBjb25zdCBncmlkU3BlY3NSZWYgPSB1c2VSZWYoZ3JpZFNwZWNzKVxuXG4gICAgLy8gc3RhdGVcbiAgICBjb25zdCBbc2Nyb2xsZXJTdGF0ZSwgc2V0U2Nyb2xsZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKSAvLyBzZXR1cCwgc2V0bGlzdHNpemUsIHJlYWR5XG5cbiAgICAvLyBzeXN0ZW1cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoc3R5bGVzKVxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZihjYWxsYmFja3MpXG5cbiAgICBsZXQge1xuXG4gICAgICAgIHNob3dBeGlzLCAvLyBib29sZWFuOyBheGlzIGNhbiBiZSBtYWRlIHZpc2libGUgZm9yIGRlYnVnXG4gICAgICAgIC8vIHRpbWVvdXRzXG4gICAgICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VULFxuICAgICAgICBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgICAgIFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyxcbiAgICAgICAgLy8gcmF0aW9zOlxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sIC8vIG1heCBzdHJlYW1pbmcgb3Zlci1ydW4gYXMgcmF0aW8gdG8gY2FjaGVNYXhcblxuICAgIH0gPSBhZHZhbmNlZFxuXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPSBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCA/PyAyNTBcbiAgICBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCA9IFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMID8/IDEwMFxuICAgIElETEVDQUxMQkFDS19USU1FT1VUID0gSURMRUNBTExCQUNLX1RJTUVPVVQgPz8gNDAwMFxuICAgIFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyA9IFRJTUVPVVRfRk9SX1ZBUklBQkxFX01FQVNVUkVNRU5UUyA/PyAxMDBcbiAgICBcbiAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4gPSBNQVhfQ0FDSEVfT1ZFUl9SVU4gPz8gMS41XG5cbiAgICBpZiAodHlwZW9mIHNob3dBeGlzICE9ICdib29sZWFuJykgc2hvd0F4aXMgPSBmYWxzZVxuXG4gICAgaWYgKHR5cGVvZiB1c2VTY3JvbGxUcmFja2VyICE9ICdib29sZWFuJykgdXNlU2Nyb2xsVHJhY2tlciA9IHRydWVcblxuICAgIC8vIGZvciBtb3VudCB2ZXJzaW9uXG4gICAgY29uc3Qgc2Nyb2xsZXJTZXNzaW9uSURSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBzY3JvbGxlcklEID0gc2Nyb2xsZXJTZXNzaW9uSURSZWYuY3VycmVudFxuXG4gICAgLy8gZm9yIGNoaWxkcmVuXG4gICAgY29uc3QgY2FjaGVIYW5kbGVyUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBsaXN0c2l6ZVJlZiA9IHVzZVJlZihlc3RpbWF0ZWRMaXN0U2l6ZSlcblxuICAgIGNvbnN0IGxpc3RzaXplID0gbGlzdHNpemVSZWYuY3VycmVudFxuXG4gICAgLy8gdGVzdHMgZm9yIFJlYWN0IHdpdGggT2JqZWN0LmlzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXM7IGF2b2lkIHJlLXJlbmRlcnMgd2l0aCBubyBjaGFuZ2VcbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhncmlkU3BlY3MsIGdyaWRTcGVjc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBncmlkU3BlY3NSZWYuY3VycmVudCA9IGdyaWRTcGVjc1xuICAgIH1cblxuICAgIGlmICghY29tcGFyZVByb3BzKHN0eWxlcywgc3R5bGVzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIHN0eWxlc1JlZi5jdXJyZW50ID0gc3R5bGVzXG4gICAgfVxuICAgIGlmICghY29tcGFyZVByb3BzKGNhbGxiYWNrcywgY2FsbGJhY2tzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50ID0gY2FsbGJhY2tzXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgSW5pdGlhbGl6YXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHVzZUVmZmVjdCAoKCkgPT4ge1xuXG4gICAgICAgIHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQgPSBnbG9iYWxTY3JvbGxlcklEKytcbiAgICAgICAgY2FjaGVIYW5kbGVyUmVmLmN1cnJlbnQgPSBuZXcgQ2FjaGVIYW5kbGVyKHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQsIHNldExpc3RzaXplLCBsaXN0c2l6ZVJlZilcblxuICAgIH0sW10pXG5cbiAgICAvLyBjYWxsZWQgd2hlbiBnZXRJdGVtIHJldHVybnMgbnVsbCwgb3IgZGlyZWN0IGNhbGwgZnJvbSB1c2VyIChzZWUgc2VydmljZUhhbmRsZXIpXG4gICAgY29uc3Qgc2V0TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobGlzdHNpemUpID0+e1xuXG4gICAgICAgIGlmIChsaXN0c2l6ZSA9PSBsaXN0c2l6ZVJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBsaXN0c2l6ZVJlZi5jdXJyZW50ID0gbGlzdHNpemVcblxuICAgICAgICAvLyBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUgJiYgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUobGlzdHNpemUpXG5cbiAgICAgICAgc2V0U2Nyb2xsZXJTdGF0ZSgnc2V0bGlzdHNpemUnKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3RhdGUgaGFuZGxpbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHNjcm9sbGVyU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldGxpc3RzaXplJzpcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdyZWFkeScpXG4gICAgICAgIH1cblxuICAgIH0sW3Njcm9sbGVyU3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBjb21wb25lbnQgY2FsbHMgYXJlIGRlZmVycmVkIGJ5IHNjcm9sbGVyU3RhdGUgdG8gZ2l2ZSBjYWNoZUhhbmRsZXIgYSBjaGFuY2UgdG8gaW5pdGlhbGl6ZVxuICAgIHJldHVybiA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICAgICAgPEVycm9yQm91bmRhcnlcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQ9IHsgRXJyb3JGYWxsYmFjayB9XG4gICAgICAgIG9uUmVzZXQ9IHsgKCkgPT4ge1xuICAgICAgICAgIC8vIHJlc3BvbnNlIHRiZDsgdGhlcmUgbWF5IG5vdCBuZWVkIHRvIGJlIG9uZVxuICAgICAgICB9fVxuICAgICAgICBvbkVycm9yID0geyhlcnJvcjogRXJyb3IsIGluZm86IHtjb21wb25lbnRTdGFjazogc3RyaW5nfSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIgY2FwdHVyZWQgZXJyb3InLCBlcnJvcilcbiAgICAgICAgfX1cbiAgICA+XG5cbiAgICAgICAgeyhzY3JvbGxlclN0YXRlICE9ICdzZXR1cCcpICYmIDxWaWV3cG9ydFxuXG4gICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge3Njcm9sbGVyUHJvcGVydGllc31cbiAgICAgICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICAgICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPSB7IFZJRVdQT1JUX1JFU0laRV9USU1FT1VUIH1cblxuICAgICAgICA+XG4gICAgICAgIFxuICAgICAgICAgICAgPFNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxDcmFkbGUgXG5cbiAgICAgICAgICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHsgY2FjaGUgfVxuICAgICAgICAgICAgICAgICAgICBjYWNoZU1heCA9IHsgY2FjaGVNYXggfVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ2FsbGJhY2tzID0geyBjYWxsYmFja3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXggPSB7IHN0YXJ0aW5nSW5kZXggfVxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtID0geyBnZXRJdGVtIH1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB7IHBsYWNlaG9sZGVyIH1cbiAgICAgICAgICAgICAgICAgICAgcnVud2F5U2l6ZSA9IHsgcnVud2F5U2l6ZSB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0geyB0cmlnZ2VybGluZU9mZnNldCB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyID0ge2NhY2hlSGFuZGxlclJlZi5jdXJyZW50fVxuICAgICAgICAgICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0ge3VzZVNjcm9sbFRyYWNrZXJ9XG4gICAgICAgICAgICAgICAgICAgIHNob3dBeGlzID0geyBzaG93QXhpcyB9XG4gICAgICAgICAgICAgICAgICAgIFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMID0geyBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCB9XG4gICAgICAgICAgICAgICAgICAgIElETEVDQUxMQkFDS19USU1FT1VUID0geyBJRExFQ0FMTEJBQ0tfVElNRU9VVCB9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTiA9IHsgTUFYX0NBQ0hFX09WRVJfUlVOIH1cbiAgICAgICAgICAgICAgICAgICAgVElNRU9VVF9GT1JfVkFSSUFCTEVfTUVBU1VSRU1FTlRTID0geyBUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cblxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1Njcm9sbGJsb2NrPlxuICAgICAgICA8L1ZpZXdwb3J0Pn1cbiAgICAgICAgeyhzY3JvbGxlclN0YXRlICE9ICdzZXR1cCcpICYmIDxkaXYgZGF0YS10eXBlID0gJ2NhY2hlcm9vdCcgc3R5bGUgPSB7IGNhY2hlcm9vdHN0eWxlIH0+XG4gICAgICAgICAgICA8UG9ydGFsTGlzdCBjYWNoZVByb3BzID0geyBjYWNoZUhhbmRsZXJSZWYuY3VycmVudC5jYWNoZVByb3BzIH0vPlxuICAgICAgICA8L2Rpdj59XG4gICAgPC9FcnJvckJvdW5kYXJ5PlxuICAgIDwvUmVhY3QuU3RyaWN0TW9kZT5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5maW5pdGVHcmlkU2Nyb2xsZXJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU3VwcG9ydCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNhY2hlcm9vdHN0eWxlID0ge2Rpc3BsYXk6J25vbmUnfS8vIGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMgLy8gc3RhdGljLCBvdXQgb2YgdmlldyBcblxuLy8gdXRpbGl0eVxuZnVuY3Rpb24gY29tcGFyZVByb3BzIChvYmoxLG9iajIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqMSlcbiAgICBsZXQgc2FtZVxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG9iajFba2V5XSxvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIkVycm9yRmFsbGJhY2siLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInJlYWN0XzEiLCJyb2xlIiwib25DbGljayIsImdsb2JhbFNjcm9sbGVySUQiLCJJbmZpbml0ZUdyaWRTY3JvbGxlciIsInByb3BzIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImVzdGltYXRlZExpc3RTaXplIiwiZ2V0SXRlbSIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImxheW91dCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJydW53YXlTaXplIiwic3RhcnRpbmdJbmRleCIsInBsYWNlaG9sZGVyIiwic3R5bGVzIiwidXNlU2Nyb2xsVHJhY2tlciIsImNhY2hlIiwiY2FjaGVNYXgiLCJ0cmlnZ2VybGluZU9mZnNldCIsImNhbGxiYWNrcyIsImFkdmFuY2VkIiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwiY29uc29sZSIsImxvZyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJpbmNsdWRlcyIsImdyaWRTcGVjcyIsImdyaWRTcGVjc1JlZiIsInNjcm9sbGVyU3RhdGUiLCJzZXRTY3JvbGxlclN0YXRlIiwic3R5bGVzUmVmIiwiY2FsbGJhY2tzUmVmIiwic2hvd0F4aXMiLCJWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCIsIlNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJUSU1FT1VUX0ZPUl9WQVJJQUJMRV9NRUFTVVJFTUVOVFMiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJzY3JvbGxlclNlc3Npb25JRFJlZiIsInNjcm9sbGVySUQiLCJjdXJyZW50IiwiY2FjaGVIYW5kbGVyUmVmIiwibGlzdHNpemVSZWYiLCJsaXN0c2l6ZSIsImNvbXBhcmVQcm9wcyIsImNhY2hlaGFuZGxlcl8xIiwic2V0TGlzdHNpemUiLCJuZXdMaXN0c2l6ZSIsIlN0cmljdE1vZGUiLCJyZWFjdF9lcnJvcl9ib3VuZGFyeV8xIiwiRmFsbGJhY2tDb21wb25lbnQiLCJvblJlc2V0Iiwib25FcnJvciIsImluZm8iLCJWaWV3cG9ydF8xIiwiU2Nyb2xsYmxvY2tfMSIsIkNyYWRsZV8xIiwidXNlckNhbGxiYWNrcyIsImNhY2hlSGFuZGxlciIsInN0eWxlIiwiY2FjaGVyb290c3R5bGUiLCJjYWNoZVByb3BzIiwiZXhwb3J0cyIsImRpc3BsYXkiLCJvYmoxIiwib2JqMiIsImtleXMiLCJPYmplY3QiLCJzYW1lIiwia2V5IiwiaXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n')},"./node_modules/react-error-boundary/dist/react-error-boundary.umd.js":function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"react\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  var changedArray = function changedArray(a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error;\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React__namespace.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React__namespace.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React__namespace.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function Wrapped(props) {\n      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__namespace.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React__namespace.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError != null) throw givenError;\n    if (error != null) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/sort-type-union-intersection-members: \"off\",\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-error-boundary.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pHLEVBQUUsQ0FDaUk7QUFDbkksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVycm9yLWJvdW5kYXJ5L2Rpc3QvcmVhY3QtZXJyb3ItYm91bmRhcnkudW1kLmpzP2U4OTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdEVycm9yQm91bmRhcnkgPSB7fSwgZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuXG4gIHZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbiAgfShSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoQ29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICB2YXIgV3JhcHBlZCA9IGZ1bmN0aW9uIFdyYXBwZWQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIGVycm9yQm91bmRhcnlQcm9wcywgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTsgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG5cblxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIiArIG5hbWUgKyBcIilcIjtcbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihnaXZlbkVycm9yKSB7XG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobnVsbCksXG4gICAgICAgIGVycm9yID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRFcnJvciA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGlmIChnaXZlbkVycm9yICE9IG51bGwpIHRocm93IGdpdmVuRXJyb3I7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBzZXRFcnJvcjtcbiAgfVxuICAvKlxuICBlc2xpbnRcbiAgICBAdHlwZXNjcmlwdC1lc2xpbnQvc29ydC10eXBlLXVuaW9uLWludGVyc2VjdGlvbi1tZW1iZXJzOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nOiBcIm9mZlwiXG4gICovXG5cbiAgZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbiAgZXhwb3J0cy51c2VFcnJvckhhbmRsZXIgPSB1c2VFcnJvckhhbmRsZXI7XG4gIGV4cG9ydHMud2l0aEVycm9yQm91bmRhcnkgPSB3aXRoRXJyb3JCb3VuZGFyeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\n")},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InPortal": () => (/* binding */ InPortal),\n/* harmony export */   "OutPortal": () => (/* binding */ OutPortal),\n/* harmony export */   "createHtmlPortalNode": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   "createSvgPortalNode": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(e){var I=__webpack_module_cache__[e];if(void 0!==I)return I.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}__webpack_require__.n=e=>{var I=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(e,I)=>{for(var l in I)__webpack_require__.o(I,l)&&!__webpack_require__.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:I[l]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,I)=>Object.prototype.hasOwnProperty.call(e,I),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/infinitegridscroller.tsx");return __webpack_exports__})()));