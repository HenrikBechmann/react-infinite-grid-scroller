/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["react-infinite-grid-scroller"] = factory(require("react"), require("react-dom"));
	else
		root["react-infinite-grid-scroller"] = factory(root["react"], root["react-dom"]);
})(self, (__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOMRectReadOnly\": () => (/* binding */ DOMRectReadOnly)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvRE9NUmVjdFJlYWRPbmx5LmpzP2ZkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObservation.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObservation\": () => (/* binding */ ResizeObservation)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJGQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzPzQ0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":
/*!********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserver.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserver\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RkFBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsdUZBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHlGQUFrQztBQUMxQztBQUNBO0FBQ0EsUUFBUSwwRkFBbUM7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlci5qcz9kMDIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserverBoxOptions\": () => (/* binding */ ResizeObserverBoxOptions)\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLmpzP2U1NTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserverController\": () => (/* binding */ ResizeObserverController)\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ \"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ \"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdFQUFvQjtBQUNwRCwrQ0FBK0MsaUVBQWlCO0FBQ2hFLFlBQVksNkRBQVc7QUFDdkIsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQXNCLENBQUMsMkVBQXVCO0FBQzdFO0FBQ0EsWUFBWSw2REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9EQUFvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmpzP2YzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9IGZyb20gJy4vdXRpbHMvc2NoZWR1bGVyJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmF0aW9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZhdGlvbic7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlckRldGFpbCB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJEZXRhaWwnO1xuaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRPYnNlcnZhdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9ic2VydmF0aW9uVGFyZ2V0c1tpXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBuZXcgUmVzaXplT2JzZXJ2ZXJEZXRhaWwocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXJNYXAuc2V0KHJlc2l6ZU9ic2VydmVyLCBkZXRhaWwpO1xuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgIGZpcnN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnB1c2goZGV0YWlsKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMucHVzaChuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvcHRpb25zICYmIG9wdGlvbnMuYm94KSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgxKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIHZhciBpbmRleCA9IGdldE9ic2VydmF0aW9uSW5kZXgoZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIGxhc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAxO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGFzdE9ic2VydmF0aW9uICYmIHJlc2l6ZU9ic2VydmVycy5zcGxpY2UocmVzaXplT2JzZXJ2ZXJzLmluZGV4T2YoZGV0YWlsKSwgMSk7XG4gICAgICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCgtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAob3QpIHsgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTsgfSk7XG4gICAgICAgIGRldGFpbC5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCBkZXRhaWwuYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserverDetail\": () => (/* binding */ ResizeObserverDetail)\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanM/NzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserverEntry\": () => (/* binding */ ResizeObserverEntry)\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanM/NDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":
/*!************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserverSize\": () => (/* binding */ ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcz9jNjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"broadcastActiveObservations\": () => (/* binding */ broadcastActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLDhCQUE4Qiw2RUFBcUI7QUFDbkQ7QUFDQSxrQ0FBa0MsbUVBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzP2NhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckVudHJ5JztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJveFNpemUgfSBmcm9tICcuL2NhbGN1bGF0ZUJveFNpemUnO1xudmFyIGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hhbGxvd2VzdERlcHRoID0gSW5maW5pdHk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHJlc2l6ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NPYnNlcnZlcihybykge1xuICAgICAgICBpZiAocm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob3QudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZXB0aCA9IGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIG90Lmxhc3RSZXBvcnRlZFNpemUgPSBjYWxjdWxhdGVCb3hTaXplKG90LnRhcmdldCwgb3Qub2JzZXJ2ZWRCb3gpO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgc2hhbGxvd2VzdERlcHRoKSB7XG4gICAgICAgICAgICAgICAgc2hhbGxvd2VzdERlcHRoID0gdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgcm8uY2FsbGJhY2suY2FsbChyby5vYnNlcnZlciwgZW50cmllcywgcm8ub2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dlc3REZXB0aDtcbn07XG5leHBvcnQgeyBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateBoxSize\": () => (/* binding */ calculateBoxSize),\n/* harmony export */   \"calculateBoxSizes\": () => (/* binding */ calculateBoxSizes)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ \"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFnQixJQUFJLHFFQUEwQjtBQUM5RSx3Q0FBd0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxlQUFlLG1FQUFrQjtBQUNqQztBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEMsQ0FBQztBQUNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0dBQWlEO0FBQzlEO0FBQ0EsYUFBYSwwRkFBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcz8xMDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlclNpemUnO1xuaW1wb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH0gZnJvbSAnLi4vRE9NUmVjdFJlYWRPbmx5JztcbmltcG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiB9IGZyb20gJy4uL3V0aWxzL2VsZW1lbnQnO1xuaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi4vdXRpbHMvZnJlZXplJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbCc7XG52YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNjcm9sbFJlZ2V4cCA9IC9hdXRvfHNjcm9sbC87XG52YXIgdmVydGljYWxSZWdleHAgPSAvXnRifHZlcnRpY2FsLztcbnZhciBJRSA9ICgvbXNpZXx0cmlkZW50L2kpLnRlc3QoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgcGFyc2VEaW1lbnNpb24gPSBmdW5jdGlvbiAocGl4ZWwpIHsgcmV0dXJuIHBhcnNlRmxvYXQocGl4ZWwgfHwgJzAnKTsgfTtcbnZhciBzaXplID0gZnVuY3Rpb24gKGlubGluZVNpemUsIGJsb2NrU2l6ZSwgc3dpdGNoU2l6ZXMpIHtcbiAgICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7IGlubGluZVNpemUgPSAwOyB9XG4gICAgaWYgKGJsb2NrU2l6ZSA9PT0gdm9pZCAwKSB7IGJsb2NrU2l6ZSA9IDA7IH1cbiAgICBpZiAoc3dpdGNoU2l6ZXMgPT09IHZvaWQgMCkgeyBzd2l0Y2hTaXplcyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG59O1xudmFyIHplcm9Cb3hlcyA9IGZyZWV6ZSh7XG4gICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGJvcmRlckJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KDAsIDAsIDAsIDApXG59KTtcbnZhciBjYWxjdWxhdGVCb3hTaXplcyA9IGZ1bmN0aW9uICh0YXJnZXQsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIGlmIChmb3JjZVJlY2FsY3VsYXRpb24gPT09IHZvaWQgMCkgeyBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChjYWNoZS5oYXModGFyZ2V0KSAmJiAhZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGlzSGlkZGVuKHRhcmdldCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgemVyb0JveGVzKTtcbiAgICAgICAgcmV0dXJuIHplcm9Cb3hlcztcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcbiAgICB2YXIgcmVtb3ZlUGFkZGluZyA9ICFJRSAmJiBjcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgICB2YXIgc3dpdGNoU2l6ZXMgPSB2ZXJ0aWNhbFJlZ2V4cC50ZXN0KGNzLndyaXRpbmdNb2RlIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsVmVydGljYWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dZIHx8ICcnKTtcbiAgICB2YXIgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gIXN2ZyAmJiBzY3JvbGxSZWdleHAudGVzdChjcy5vdmVyZmxvd1ggfHwgJycpO1xuICAgIHZhciBwYWRkaW5nVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdUb3ApO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ1JpZ2h0KTtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nQm90dG9tKTtcbiAgICB2YXIgcGFkZGluZ0xlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0xlZnQpO1xuICAgIHZhciBib3JkZXJUb3AgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbEJvcmRlckFyZWEgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsQm9yZGVyQXJlYSA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxIb3Jpem9udGFsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldEhlaWdodCAtIHZlcnRpY2FsQm9yZGVyQXJlYSAtIHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzID0gIWNhblNjcm9sbFZlcnRpY2FsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpZHRoUmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlckFyZWEgOiAwO1xuICAgIHZhciBoZWlnaHRSZWR1Y3Rpb24gPSByZW1vdmVQYWRkaW5nID8gdmVydGljYWxQYWRkaW5nICsgdmVydGljYWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gc3ZnID8gc3ZnLndpZHRoIDogcGFyc2VEaW1lbnNpb24oY3Mud2lkdGgpIC0gd2lkdGhSZWR1Y3Rpb24gLSB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgY29udGVudEhlaWdodCA9IHN2ZyA/IHN2Zy5oZWlnaHQgOiBwYXJzZURpbWVuc2lvbihjcy5oZWlnaHQpIC0gaGVpZ2h0UmVkdWN0aW9uIC0gaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgICB2YXIgYm9yZGVyQm94V2lkdGggPSBjb250ZW50V2lkdGggKyBob3Jpem9udGFsUGFkZGluZyArIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzICsgaG9yaXpvbnRhbEJvcmRlckFyZWE7XG4gICAgdmFyIGJvcmRlckJveEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmcgKyBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzICsgdmVydGljYWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3hlcyA9IGZyZWV6ZSh7XG4gICAgICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoTWF0aC5yb3VuZChjb250ZW50V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSwgTWF0aC5yb3VuZChjb250ZW50SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpbyksIHN3aXRjaFNpemVzKSxcbiAgICAgICAgYm9yZGVyQm94U2l6ZTogc2l6ZShib3JkZXJCb3hXaWR0aCwgYm9yZGVyQm94SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGNvbnRlbnRCb3hTaXplOiBzaXplKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seShwYWRkaW5nTGVmdCwgcGFkZGluZ1RvcCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0KVxuICAgIH0pO1xuICAgIGNhY2hlLnNldCh0YXJnZXQsIGJveGVzKTtcbiAgICByZXR1cm4gYm94ZXM7XG59O1xudmFyIGNhbGN1bGF0ZUJveFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYnNlcnZlZEJveCwgZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgdmFyIF9hID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pLCBib3JkZXJCb3hTaXplID0gX2EuYm9yZGVyQm94U2l6ZSwgY29udGVudEJveFNpemUgPSBfYS5jb250ZW50Qm94U2l6ZSwgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IF9hLmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgc3dpdGNoIChvYnNlcnZlZEJveCkge1xuICAgICAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5ERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1g6XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQk9SREVSX0JPWDpcbiAgICAgICAgICAgIHJldHVybiBib3JkZXJCb3hTaXplO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3hTaXplO1xuICAgIH1cbn07XG5leHBvcnQgeyBjYWxjdWxhdGVCb3hTaXplLCBjYWxjdWxhdGVCb3hTaXplcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateDepthForNode\": () => (/* binding */ calculateDepthForNode)\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzP2M5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deliverResizeLoopError\": () => (/* binding */ deliverResizeLoopError)\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2RlbGl2ZXJSZXNpemVMb29wRXJyb3IuanM/YzJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"gatherActiveObservationsAtDepth\": () => (/* binding */ gatherActiveObservationsAtDepth)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksMkVBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQzJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9nYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoLmpzPzQ1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZURlcHRoRm9yTm9kZSB9IGZyb20gJy4vY2FsY3VsYXRlRGVwdGhGb3JOb2RlJztcbnZhciBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMuc3BsaWNlKDAsIHJvLnNraXBwZWRUYXJnZXRzLmxlbmd0aCk7XG4gICAgICAgIHJvLm9ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NUYXJnZXQob3QpIHtcbiAgICAgICAgICAgIGlmIChvdC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5wdXNoKG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasActiveObservations\": () => (/* binding */ hasActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyx3RUFBb0IsaUJBQWlCLHFDQUFxQztBQUNyRjtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzP2RkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplT2JzZXJ2ZXJzJztcbnZhciBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasSkippedObservations\": () => (/* binding */ hasSkippedObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsd0VBQW9CLGlCQUFpQixzQ0FBc0M7QUFDdEY7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc1NraXBwZWRPYnNlcnZhdGlvbnMuanM/YzEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc1NraXBwZWRPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoID4gMDsgfSk7XG59O1xuZXhwb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResizeObserver\": () => (/* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver),\n/* harmony export */   \"ResizeObserverEntry\": () => (/* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry),\n/* harmony export */   \"ResizeObserverSize\": () => (/* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9leHBvcnRzL3Jlc2l6ZS1vYnNlcnZlci5qcz8xZDFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/element.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isElement\": () => (/* binding */ isElement),\n/* harmony export */   \"isHidden\": () => (/* binding */ isHidden),\n/* harmony export */   \"isReplacedElement\": () => (/* binding */ isReplacedElement),\n/* harmony export */   \"isSVG\": () => (/* binding */ isSVG)\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9lbGVtZW50LmpzPzNjZDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/freeze.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"freeze\": () => (/* binding */ freeze)\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvZnJlZXplLmpzP2ZjZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/global.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/global.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"global\": () => (/* binding */ global)\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9nbG9iYWwuanM/Y2I3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/process.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/process.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"process\": () => (/* binding */ process)\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ \"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ \"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzP2Q0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queueMicroTask\": () => (/* binding */ queueMicroTask)\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVNaWNyb1Rhc2suanM/YTk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queueResizeObserver\": () => (/* binding */ queueResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ \"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVSZXNpemVPYnNlcnZlci5qcz9hMzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resizeObservers\": () => (/* binding */ resizeObservers)\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9yZXNpemVPYnNlcnZlcnMuanM/YThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n");

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/scheduler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduler\": () => (/* binding */ scheduler),\n/* harmony export */   \"updateCount\": () => (/* binding */ updateCount)\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDREQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDREQUF1QiwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sK0RBQTBCLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n");

/***/ }),

/***/ "./src/CellFrame.tsx":
/*!***************************!*\
  !*** ./src/CellFrame.tsx ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // cellframe.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ \"./node_modules/requestidlecallback/index.js\");\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ \"./node_modules/react-reverse-portal/dist/web/index.js\");\n\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ \"./src/cellframe/Placeholder.tsx\"));\n\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ \"./src/Cradle.tsx\");\n\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      getItem = _ref.getItem,\n      listsize = _ref.listsize,\n      placeholder = _ref.placeholder,\n      itemID = _ref.itemID,\n      index = _ref.index,\n      instanceID = _ref.instanceID,\n      scrollerID = _ref.scrollerID;\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheHandler = cradleContext.cacheHandler,\n      scrollerPassthroughPropertiesRef = cradleContext.scrollerPassthroughPropertiesRef,\n      nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n      itemExceptionsCallback = cradleContext.itemExceptionsCallback,\n      IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT;\n\n  var _ref2 = (0, react_1.useState)({\n    overflow: 'hidden'\n  }),\n      _ref3 = _slicedToArray(_ref2, 2),\n      styles = _ref3[0],\n      saveStyles = _ref3[1];\n\n  var _ref4 = (0, react_1.useState)('setup'),\n      _ref5 = _slicedToArray(_ref4, 2),\n      frameState = _ref5[0],\n      setFrameState = _ref5[1];\n\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState; // console.log('==> RUNNING CellFrame','-'+scrollerID+'-','['+itemID+']','_'+instanceID+'_',frameState)\n\n  var frameRef = (0, react_1.useRef)(null);\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalDataRef = (0, react_1.useRef)(null);\n  var placeholderRef = (0, react_1.useRef)(null);\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID;\n  var errorRef = (0, react_1.useRef)(false);\n  var messageRef = (0, react_1.useRef)(null); // for unmount\n\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController();\n    return function () {\n      isMountedRef.current = false;\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheHandler.removeRequestedPortal(index);\n      abortController.abort(); // defensive\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    if (isMountedRef.current) setFrameState('getusercontent');\n  }, [itemID]); // ----------------- [ placeholder definition ] -------------------------\n\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    return placeholder ? react_1[\"default\"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, errorRef.current]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    var placeholder = customplaceholder ? customplaceholder : react_1[\"default\"].createElement(Placeholder_1[\"default\"], {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current]); // ---------------- [ requestidlecallback config ] ------------------------\n\n  var requestidlecallback = window['requestIdleCallback'] ? window['requestIdleCallback'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback = window['cancelIdleCallback'] ? window['cancelIdleCallback'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null); // cradle invariant ondemand callback parameter value\n\n  var getElementData = (0, react_1.useCallback)(function () {\n    return [index, frameRef];\n  }, []); // set styles\n\n  (0, react_1.useEffect)(function () {\n    var newStyles = getFrameStyles(orientation, cellHeight, cellWidth, styles);\n\n    if (isMountedRef.current) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  var isReparentingRef = (0, react_1.useRef)(false);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case 'setup':\n        // no-op\n        break;\n\n      case 'inserting':\n        {\n          setFrameState('ready');\n          break;\n        }\n\n      case 'getusercontent':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheHandler.hasPortal(_itemID); // console.log('==> CellFrame getusercontent: scrollerID, itemID, instanceID, cached',\n          //     '-'+scrollerID+'-', '['+itemID+']','_'+instanceID+'_', cached)\n\n          if (cached) {\n            messageRef.current = '(retrieving from cache)'; // console.log(messageRef.current)\n            // setFrameState('waiting')\n            // setTimeout(()=>{\n\n            if (isMountedRef.current) {\n              var portalRecord = cacheHandler.getPortal(_itemID);\n              portalDataRef.current = portalRecord;\n              portalNodeRef.current = portalDataRef.current.portalNode;\n              portalDataRef.current.isReparentingRef.current = true;\n              setFrameState('inserting');\n            } // },1)\n\n          } else {\n            messageRef.current = '(loading...)'; // console.log(messageRef.current)\n\n            setFrameState('waiting');\n            cacheHandler.registerRequestedPortal(index);\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, returnvalue, usercontent, error, content, scrollerProperties;\n\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return getItem(index, _itemID);\n\n                      case 3:\n                        usercontent = _context.sent;\n                        if (usercontent === null) returnvalue = usercontent;\n\n                        if (usercontent === undefined) {\n                          error = new Error('host returned \"undefined\"');\n                        }\n\n                        _context.next = 12;\n                        break;\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context[\"catch\"](0);\n                        returnvalue = usercontent = undefined;\n                        error = _context.t0;\n\n                      case 12:\n                        if (usercontent !== null && usercontent !== undefined) {\n                          if (!react_1[\"default\"].isValidElement(usercontent)) {\n                            returnvalue = usercontent;\n                            usercontent = undefined;\n                            error = new Error('invalid React element');\n                          }\n                        }\n\n                        if (isMountedRef.current) {\n                          if (usercontent !== null && usercontent !== undefined) {\n                            // if usercontent is otherwise disallowed, let error handling deal with it.\n                            scrollerProperties = {\n                              isReparentingRef: null,\n                              scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef\n                            };\n\n                            if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('scrollerProperties')) {\n                              content = react_1[\"default\"].cloneElement(usercontent, {\n                                scrollerProperties: scrollerProperties\n                              });\n                            } else {\n                              content = usercontent;\n                            }\n\n                            portalDataRef.current = cacheHandler.createPortal(content, index, _itemID);\n                            portalNodeRef.current = portalDataRef.current.portalNode; // make available to user content\n\n                            scrollerProperties.isReparentingRef = portalDataRef.current.isReparentingRef;\n                            setFrameState('inserting');\n                          } else {\n                            // null or undefined\n                            if (usercontent === null) {\n                              // truncate listsize at this index\n                              // console.log('cellFrame calling nullItemSetMaxListsize with index', index)\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, 'cellFrame', new Error('end of list'));\n                              nullItemSetMaxListsize(index);\n                            } else {\n                              // usercontent === undefined, meaning an error has occurred\n                              // change placeholder message to error message\n                              // console.log('updating placeholder with error', error)\n                              errorRef.current = error;\n                              itemExceptionsCallback && itemExceptionsCallback(index, _itemID, returnvalue, 'cellFrame', error);\n                              setFrameState('error');\n                            }\n                          }\n                        }\n\n                      case 14:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n\n          break;\n        }\n\n      case 'waiting':\n        {\n          break;\n        }\n    }\n  }, [frameState]);\n  (0, react_1.useEffect)(function () {\n    switch (frameState) {\n      case 'ready':\n        {\n          // no-op\n          break;\n        }\n    }\n  }, [frameState]);\n  return react_1[\"default\"].createElement(\"div\", {\n    ref: frameRef,\n    \"data-type\": 'cellframe',\n    \"data-scrollerid\": scrollerID,\n    \"data-index\": index,\n    \"data-instanceid\": instanceID,\n    style: styles\n  }, frameState != 'ready' ? placeholderRef.current : react_1[\"default\"].createElement(react_reverse_portal_1.OutPortal, {\n    node: portalNodeRef.current\n  }));\n}; // CellFrame\n\n\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, styles) {\n  var styleset = Object.assign({\n    position: 'relative'\n  }, styles);\n\n  if (orientation == 'horizontal') {\n    styleset.width = cellWidth ? cellWidth + 'px' : 'auto';\n    styleset.height = 'auto';\n  } else if (orientation === 'vertical') {\n    styleset.width = 'auto';\n    styleset.height = cellHeight ? cellHeight + 'px' : 'auto';\n  }\n\n  return styleset;\n};\n\nexports[\"default\"] = CellFrame;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFdBQVcsSUFBSSxZQUFuQixFQUFpQztJQUM3QjJFLFFBQVEsQ0FBQ0ksS0FBVCxHQUNJN0UsU0FBUyxHQUNKQSxTQUFTLEdBQUcsSUFEUixHQUVMLE1BSFI7SUFJQXlFLFFBQVEsQ0FBQ0ssTUFBVCxHQUFrQixNQUFsQjtFQUVILENBUEQsTUFPTyxJQUFJaEYsV0FBVyxLQUFLLFVBQXBCLEVBQWdDO0lBRW5DMkUsUUFBUSxDQUFDSSxLQUFULEdBQWlCLE1BQWpCO0lBQ0FKLFFBQVEsQ0FBQ0ssTUFBVCxHQUNJL0UsVUFBVSxHQUNMQSxVQUFVLEdBQUcsSUFEUixHQUVOLE1BSFI7RUFLSDs7RUFFRCxPQUFPMEUsUUFBUDtBQUVILENBdkJEOztBQXlCQU0sa0JBQUFBLEdBQWVsRixTQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DZWxsRnJhbWUudHN4P2YxNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2VsbGZyYW1lLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7cmVxdWVzdElkbGVDYWxsYmFjaywgY2FuY2VsSWRsZUNhbGxiYWNrfSBmcm9tICdyZXF1ZXN0aWRsZWNhbGxiYWNrJ1xuXG5pbXBvcnQgeyBPdXRQb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCdcblxuaW1wb3J0IFBsYWNlaG9sZGVyIGZyb20gJy4vY2VsbGZyYW1lL1BsYWNlaG9sZGVyJ1xuXG5pbXBvcnQgeyBDcmFkbGVDb250ZXh0IH0gZnJvbSAnLi9DcmFkbGUnXG5cbmNvbnN0IENlbGxGcmFtZSA9ICh7XG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgZ2V0SXRlbSwgXG4gICAgbGlzdHNpemUsIFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGl0ZW1JRCwgXG4gICAgaW5kZXgsIFxuICAgIGluc3RhbmNlSUQsIFxuICAgIHNjcm9sbGVySUQsXG59KSA9PiB7XG5cbiAgICBjb25zdCBjcmFkbGVDb250ZXh0ID0gdXNlQ29udGV4dChDcmFkbGVDb250ZXh0KVxuXG4gICAgY29uc3QgeyBcbiAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplLCBcbiAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgfSA9IGNyYWRsZUNvbnRleHRcbiAgICBcbiAgICBjb25zdCBbc3R5bGVzLHNhdmVTdHlsZXNdID0gdXNlU3RhdGUoe1xuICAgICAgICBvdmVyZmxvdzonaGlkZGVuJyxcbiAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMpXG5cbiAgICBjb25zdCBbZnJhbWVTdGF0ZSwgc2V0RnJhbWVTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuICAgIGNvbnN0IGZyYW1lU3RhdGVSZWYgPSB1c2VSZWYobnVsbClcbiAgICBmcmFtZVN0YXRlUmVmLmN1cnJlbnQgPSBmcmFtZVN0YXRlXG5cbiAgICAvLyBjb25zb2xlLmxvZygnPT0+IFJVTk5JTkcgQ2VsbEZyYW1lJywnLScrc2Nyb2xsZXJJRCsnLScsJ1snK2l0ZW1JRCsnXScsJ18nK2luc3RhbmNlSUQrJ18nLGZyYW1lU3RhdGUpXG5cbiAgICBjb25zdCBmcmFtZVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICBjb25zdCBwb3J0YWxEYXRhUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgaXRlbUlEUmVmID0gdXNlUmVmKG51bGwpXG4gICAgaXRlbUlEUmVmLmN1cnJlbnQgPSBpdGVtSURcblxuICAgIGNvbnN0IGVycm9yUmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gICAgY29uc3QgbWVzc2FnZVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gZm9yIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCkgICAgICAgIFxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICAgICAgY2FuY2VsaWRsZWNhbGxiYWNrKHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZi5jdXJyZW50KVxuXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVtb3ZlUmVxdWVzdGVkUG9ydGFsKGluZGV4KVxuXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSAvLyBkZWZlbnNpdmVcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpXG5cbiAgICB9LFtpdGVtSURdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gWyBwbGFjZWhvbGRlciBkZWZpbml0aW9uIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3VzdG9tcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyP1xuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQocGxhY2Vob2xkZXIsIFxuICAgICAgICAgICAgICAgICAgICB7aW5kZXgsIGxpc3RzaXplLCBtZXNzYWdlOm1lc3NhZ2VSZWYuY3VycmVudCwgZXJyb3I6ZXJyb3JSZWYuY3VycmVudH0pOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIFxuICAgIH0sW2luZGV4LCBwbGFjZWhvbGRlcixsaXN0c2l6ZSwgZXJyb3JSZWYuY3VycmVudF0pXG5cbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gXG4gICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcj9cbiAgICAgICAgICAgICAgICBjdXN0b21wbGFjZWhvbGRlcjpcbiAgICAgICAgICAgICAgICA8UGxhY2Vob2xkZXIgXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0ge2luZGV4fSBcbiAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7bGlzdHNpemV9IFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0ge21lc3NhZ2VSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7ZXJyb3JSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICAvPlxuXG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlclxuXG4gICAgfSwgW2luZGV4LCBjdXN0b21wbGFjZWhvbGRlciwgbGlzdHNpemUsIG1lc3NhZ2VSZWYuY3VycmVudCwgZXJyb3JSZWYuY3VycmVudF0pO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBbIHJlcXVlc3RpZGxlY2FsbGJhY2sgY29uZmlnIF0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCByZXF1ZXN0aWRsZWNhbGxiYWNrID0gXG4gICAgICAgIHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddP1xuICAgICAgICAgICAgd2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ106XG4gICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrXG5cbiAgICBjb25zdCBjYW5jZWxpZGxlY2FsbGJhY2sgPSBcbiAgICAgICAgd2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXT9cbiAgICAgICAgICAgIHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ106XG4gICAgICAgICAgICBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICAgIGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gY3JhZGxlIGludmFyaWFudCBvbmRlbWFuZCBjYWxsYmFjayBwYXJhbWV0ZXIgdmFsdWVcbiAgICBjb25zdCBnZXRFbGVtZW50RGF0YSA9IHVzZUNhbGxiYWNrKCgpPT57XG5cbiAgICAgICAgcmV0dXJuIFtpbmRleCwgZnJhbWVSZWZdXG4gICAgICAgIFxuICAgIH0sW10pXG5cbiAgICAvLyBzZXQgc3R5bGVzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgbGV0IG5ld1N0eWxlcyA9IGdldEZyYW1lU3R5bGVzKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcylcbiAgICAgICAgXG4gICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgc2F2ZVN0eWxlcyhuZXdTdHlsZXMpXG4gICAgICAgIH1cblxuICAgIH0sW29yaWVudGF0aW9uLGNlbGxIZWlnaHQsY2VsbFdpZHRoXSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBpc1JlcGFyZW50aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKGZyYW1lU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ2luc2VydGluZyc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2dldHVzZXJjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaXRlbUlEUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZUhhbmRsZXIuaGFzUG9ydGFsKGl0ZW1JRClcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT4gQ2VsbEZyYW1lIGdldHVzZXJjb250ZW50OiBzY3JvbGxlcklELCBpdGVtSUQsIGluc3RhbmNlSUQsIGNhY2hlZCcsXG4gICAgICAgICAgICAgICAgLy8gICAgICctJytzY3JvbGxlcklEKyctJywgJ1snK2l0ZW1JRCsnXScsJ18nK2luc3RhbmNlSUQrJ18nLCBjYWNoZWQpXG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gJyhyZXRyaWV2aW5nIGZyb20gY2FjaGUpJ1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1lc3NhZ2VSZWYuY3VycmVudClcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRGcmFtZVN0YXRlKCd3YWl0aW5nJylcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0VGltZW91dCgoKT0+e1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3J0YWxSZWNvcmQgPSBjYWNoZUhhbmRsZXIuZ2V0UG9ydGFsKGl0ZW1JRClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsRGF0YVJlZi5jdXJyZW50ID0gcG9ydGFsUmVjb3JkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHBvcnRhbERhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbERhdGFSZWYuY3VycmVudC5pc1JlcGFyZW50aW5nUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIH0sMSlcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50ID0gJyhsb2FkaW5nLi4uKSdcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhtZXNzYWdlUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgnd2FpdGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZi5jdXJyZW50ID0gcmVxdWVzdGlkbGVjYWxsYmFjayhhc3luYyAoKT0+e1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJudmFsdWUsIHVzZXJjb250ZW50LCBlcnJvclxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2hvc3QgcmV0dXJuZWQgXCJ1bmRlZmluZWRcIicpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJjb250ZW50ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB1c2VyY29udGVudCBpcyBvdGhlcndpc2UgZGlzYWxsb3dlZCwgbGV0IGVycm9yIGhhbmRsaW5nIGRlYWwgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGVyUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVwYXJlbnRpbmdSZWY6bnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudC5wcm9wcz8uaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KHVzZXJjb250ZW50LCB7c2Nyb2xsZXJQcm9wZXJ0aWVzfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB1c2VyY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsRGF0YVJlZi5jdXJyZW50ID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY3JlYXRlUG9ydGFsKGNvbnRlbnQsIGluZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCAgPSBwb3J0YWxEYXRhUmVmLmN1cnJlbnQucG9ydGFsTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGF2YWlsYWJsZSB0byB1c2VyIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLmlzUmVwYXJlbnRpbmdSZWYgPSBwb3J0YWxEYXRhUmVmLmN1cnJlbnQuaXNSZXBhcmVudGluZ1JlZlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NlbGxGcmFtZSBjYWxsaW5nIG51bGxJdGVtU2V0TWF4TGlzdHNpemUgd2l0aCBpbmRleCcsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIG5ldyBFcnJvcignZW5kIG9mIGxpc3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQsIG1lYW5pbmcgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgcGxhY2Vob2xkZXIgbWVzc2FnZSB0byBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRpbmcgcGxhY2Vob2xkZXIgd2l0aCBlcnJvcicsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAnY2VsbEZyYW1lJywgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSx7dGltZW91dDpJRExFQ0FMTEJBQ0tfVElNRU9VVH0pXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd3YWl0aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbZnJhbWVTdGF0ZV0pXG5cblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIHN3aXRjaCAoZnJhbWVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6IHsgLy8gbm8tb3BcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtmcmFtZVN0YXRlXSlcblxuICAgIHJldHVybiA8ZGl2IFxuXG4gICAgICAgIHJlZiA9IHsgZnJhbWVSZWYgfSBcbiAgICAgICAgZGF0YS10eXBlID0gJ2NlbGxmcmFtZScgXG4gICAgICAgIGRhdGEtc2Nyb2xsZXJpZCA9IHsgc2Nyb2xsZXJJRCB9IFxuICAgICAgICBkYXRhLWluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICBkYXRhLWluc3RhbmNlaWQgPSB7IGluc3RhbmNlSUQgfSBcbiAgICAgICAgc3R5bGUgPSB7IHN0eWxlcyB9XG5cbiAgICA+XG5cbiAgICAgICAgeyBcbiAgICAgICAgICAgIChmcmFtZVN0YXRlICE9ICdyZWFkeScpP1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgPE91dFBvcnRhbCBub2RlID0geyBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgfS8+XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgPC9kaXY+XG5cbn0gLy8gQ2VsbEZyYW1lXG5cbmNvbnN0IGdldEZyYW1lU3R5bGVzID0gKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcykgPT4ge1xuXG4gICAgbGV0IHN0eWxlc2V0ID0gT2JqZWN0LmFzc2lnbih7cG9zaXRpb246J3JlbGF0aXZlJ30sc3R5bGVzKVxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgICBzdHlsZXNldC53aWR0aCA9IFxuICAgICAgICAgICAgY2VsbFdpZHRoP1xuICAgICAgICAgICAgICAgIChjZWxsV2lkdGggKyAncHgnKTpcbiAgICAgICAgICAgICAgICAnYXV0bydcbiAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gJ2F1dG8nXG5cbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSAnYXV0bydcbiAgICAgICAgc3R5bGVzZXQuaGVpZ2h0ID0gXG4gICAgICAgICAgICBjZWxsSGVpZ2h0P1xuICAgICAgICAgICAgICAgIChjZWxsSGVpZ2h0ICsgJ3B4Jyk6XG4gICAgICAgICAgICAgICAgJ2F1dG8nXG4gICAgICAgIFxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXNldFxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENlbGxGcmFtZVxuIl0sIm5hbWVzIjpbIkNlbGxGcmFtZSIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImdldEl0ZW0iLCJsaXN0c2l6ZSIsInBsYWNlaG9sZGVyIiwiaXRlbUlEIiwiaW5kZXgiLCJpbnN0YW5jZUlEIiwic2Nyb2xsZXJJRCIsImNyYWRsZUNvbnRleHQiLCJDcmFkbGVfMSIsImNhY2hlSGFuZGxlciIsInNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmIiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsIml0ZW1FeGNlcHRpb25zQ2FsbGJhY2siLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIm92ZXJmbG93Iiwic3R5bGVzIiwic2F2ZVN0eWxlcyIsImZyYW1lU3RhdGUiLCJzZXRGcmFtZVN0YXRlIiwiZnJhbWVTdGF0ZVJlZiIsImN1cnJlbnQiLCJmcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInBvcnRhbERhdGFSZWYiLCJwbGFjZWhvbGRlclJlZiIsIml0ZW1JRFJlZiIsImVycm9yUmVmIiwibWVzc2FnZVJlZiIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImNhbmNlbGlkbGVjYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZiIsInJlbW92ZVJlcXVlc3RlZFBvcnRhbCIsImFib3J0IiwiY3VzdG9tcGxhY2Vob2xkZXIiLCJyZWFjdF8xIiwiY3JlYXRlRWxlbWVudCIsIm1lc3NhZ2UiLCJlcnJvciIsIlBsYWNlaG9sZGVyXzEiLCJyZXF1ZXN0aWRsZWNhbGxiYWNrIiwid2luZG93IiwicmVxdWVzdGlkbGVjYWxsYmFja18xIiwiZ2V0RWxlbWVudERhdGEiLCJuZXdTdHlsZXMiLCJnZXRGcmFtZVN0eWxlcyIsInBvcnRhbE5vZGVSZWYiLCJpc1JlcGFyZW50aW5nUmVmIiwiY2FjaGVkIiwiaGFzUG9ydGFsIiwicG9ydGFsUmVjb3JkIiwiZ2V0UG9ydGFsIiwicG9ydGFsTm9kZSIsInJlZ2lzdGVyUmVxdWVzdGVkUG9ydGFsIiwiX19hd2FpdGVyIiwidXNlcmNvbnRlbnQiLCJyZXR1cm52YWx1ZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNWYWxpZEVsZW1lbnQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsIl9hIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlUG9ydGFsIiwidGltZW91dCIsInJlZiIsInN0eWxlIiwicmVhY3RfcmV2ZXJzZV9wb3J0YWxfMSIsIm5vZGUiLCJzdHlsZXNldCIsIk9iamVjdCIsImFzc2lnbiIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n");

/***/ }),

/***/ "./src/Cradle.tsx":
/*!************************!*\
  !*** ./src/Cradle.tsx ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // cradle.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    consider formalizing state conditions (certain useRefs), together with state actions (useState)\n\n    - rationalize pauseScrolling, and other signals\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\"); // popup position tracker for repositioning\n\n\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\")); // support code\n\n\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\n\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\n\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\n\nvar scaffoldhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scaffoldhandler */ \"./src/cradle/scaffoldhandler.tsx\"));\n\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\n\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\n\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\")); // for children\n\n\nexports.CradleContext = react_1[\"default\"].createContext(null); // component\n\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n      runwaySize = _ref.runwaySize,\n      listsize = _ref.listsize,\n      startingIndex = _ref.startingIndex,\n      getItem = _ref.getItem,\n      placeholder = _ref.placeholder,\n      userCallbacks = _ref.userCallbacks,\n      styles = _ref.styles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      cache = _ref.cache,\n      cacheMax = _ref.cacheMax,\n      scrollerID = _ref.scrollerID,\n      cacheHandler = _ref.cacheHandler,\n      useScrollTracker = _ref.useScrollTracker,\n      showAxis = _ref.showAxis,\n      IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n      MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN;\n\n  var _a, _b;\n\n  if (listsize == 0) return null; // nothing to do\n\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController();\n    return function () {\n      abortController.abort(); // defensive\n    };\n  }, []); // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout; // get viewport context\n\n  var viewportInterruptProperties = (0, react_1.useContext)(Viewport_1.ViewportInterrupt);\n  var viewportInterruptPropertiesRef = (0, react_1.useRef)(null);\n  viewportInterruptPropertiesRef.current = viewportInterruptProperties; // for closures\n\n  var viewportDimensions = viewportInterruptProperties.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width; // state\n\n  var _ref2 = (0, react_1.useState)('setup'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      cradleState = _ref3[0],\n      setCradleState = _ref3[1];\n\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n\n  cradleStateRef.current = cradleState; // console.log('==> RUNNING Cradle','-'+scrollerID+'-', cradleState)\n  // console.log('performance.memory',performance['memory'])\n  // flags\n\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var parentingTransitionRequiredRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false); // cradle scaffold element refs\n\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var headTriggerlineCradleElementRef = (0, react_1.useRef)(null);\n  var axisTriggerlineCradleElementRef = (0, react_1.useRef)(null);\n  var tailTriggerlineCradleElementRef = (0, react_1.useRef)(null); // scaffold bundle\n\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    headTriggerlineRef: headTriggerlineCradleElementRef,\n    axisTriggerlineRef: axisTriggerlineCradleElementRef,\n    tailTriggerlineRef: tailTriggerlineCradleElementRef\n  }); // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n\n  var crosscount = (0, react_1.useMemo)(function () {\n    var viewportsize = orientation == 'horizontal' ? viewportheight : viewportwidth;\n\n    if (viewportsize == 0) {\n      return 0;\n    }\n\n    var crossLength = orientation == 'horizontal' ? cellHeight : cellWidth;\n    var viewportlengthforcalc = viewportsize - padding * 2 + gap; // length of viewport\n\n    var tilelengthforcalc = crossLength + gap;\n    tilelengthforcalc = Math.min(tilelengthforcalc, viewportlengthforcalc); // result cannot be less than 1\n\n    var crosscount = Math.floor(viewportlengthforcalc / tilelengthforcalc);\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]); // various row counts\n\n  var _ref4 = (0, react_1.useMemo)(function () {\n    var viewportLength, rowLength;\n\n    if (orientation == 'vertical') {\n      viewportLength = viewportheight;\n      rowLength = cellHeight;\n    } else {\n      viewportLength = viewportwidth;\n      rowLength = cellWidth;\n    }\n\n    rowLength += gap;\n    var viewportRowcount = Math.ceil(viewportLength / rowLength);\n    var viewportVisibleRowcount = Math.floor(viewportLength / rowLength);\n    var listRowcount = Math.ceil(listsize / crosscount);\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n    var runwayRowcount;\n\n    if (calculatedCradleRowcount >= cradleRowcount) {\n      runwayRowcount = runwaySize;\n    } else {\n      var diff = cradleRowcount - calculatedCradleRowcount;\n      runwayRowcount -= Math.floor(diff / 2);\n      runwayRowcount = Math.max(0, runwayRowcount);\n    }\n\n    var itemcount = cradleRowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradleRowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradleRowcount, viewportRowcount, viewportVisibleRowcount, listRowcount, runwayRowcount];\n  }, [orientation, gap, // padding,\n  cellWidth, cellHeight, viewportheight, viewportwidth, listsize, runwaySize, crosscount]),\n      _ref5 = _slicedToArray(_ref4, 5),\n      cradleRowcount = _ref5[0],\n      viewportRowcount = _ref5[1],\n      viewportVisibleRowcount = _ref5[2],\n      // max number of rows completely visible at once\n  listRowcount = _ref5[3],\n      runwayRowcount = _ref5[4]; // ----------------------[ callbacks ]----------------------------\n  // host callbacks\n\n\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionsCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionsCallback\n  }); // -----------------[ bundle parameters for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    layout: layout,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheHandler: cacheHandler,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN\n  };\n  var scrollerPassthroughPropertiesRef = (0, react_1.useRef)(null); // passed to cellFrame content (user content) if requested\n\n  scrollerPassthroughPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    layout: layout,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    triggerlineOffset: triggerlineOffset\n  }; // configuration properties to share\n\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    crosscount: crosscount,\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    viewportVisibleRowcount: viewportVisibleRowcount,\n    listRowcount: listRowcount,\n    listsize: listsize,\n    runwayRowcount: runwayRowcount,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  }; // placeholder in cradleParameters to make available individual handlers\n\n  var handlersRef = (0, react_1.useRef)(null); // cradle parameters MASTER BUNDLE\n\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    viewportInterruptPropertiesRef: viewportInterruptPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters; // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  } // make handlers directly available to cradle code below\n\n\n  var _handlersRef$current = handlersRef.current,\n      interruptHandler = _handlersRef$current.interruptHandler,\n      scrollHandler = _handlersRef$current.scrollHandler,\n      stateHandler = _handlersRef$current.stateHandler,\n      contentHandler = _handlersRef$current.contentHandler,\n      scaffoldHandler = _handlersRef$current.scaffoldHandler,\n      serviceHandler = _handlersRef$current.serviceHandler,\n      stylesHandler = _handlersRef$current.stylesHandler; // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n  // intercept change in caching status\n  // when a portal is cached, including the transition of being moved from one cellFrame to another,\n  // (and the infinitegridscroller can be a component that is cached),\n  // the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is \n  // moved to a cellFrame, this code restores the scrollPos.\n  // The restore action must be the first priority to hide the scrollPos changes from the user\n  // console.log('in cradle viewportwidth, viewportheight','-'+scrollerID+'-',viewportwidth, viewportheight)\n\n  var isInPortal = viewportwidth == 0 && viewportheight == 0; // must be in portal (cache) state\n  // const isInPortal = ((vwidth == 0) && (vheight == 0)) // must be in portal (cache) state\n\n  var isCacheChange = isInPortal != isCachedRef.current;\n\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n\n  var isCachingUnderway = isCachedRef.current || wasCachedRef.current; // console.log(\n  //     '**>> -'+scrollerID+'-', cradleState,'\\n',\n  //     'isInPortal, viewportwidth, viewportheight, blockScrollPos, blockScrollPos\\n', \n  //     isInPortal, viewportwidth, viewportheight, scaffoldHandler.cradlePositionData.blockScrollPos)\n  // console.log('- isCacheChange, isCachingUnderway, isCachedRef.current, wasCachedRef.current\\n',\n  //     isCacheChange, isCachingUnderway, isCachedRef.current, wasCachedRef.current)\n  // console.log('- viewportInterruptProperties.isReparentingRef?.current, viewportInterruptProperties.isResizing, orientation\\n',\n  //     viewportInterruptProperties.isReparentingRef?.current, viewportInterruptProperties.isResizing, orientation)\n\n  if (isCacheChange || ((_a = viewportInterruptProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) || viewportInterruptProperties.isResizing && isCachingUnderway) {\n    // console.log(\n    //     '-'+scrollerID+'-',\n    //     'isInPortal', \n    //     isInPortal, \n    //     '\\nisCacheChange, isCachedRef.current, wasCachedRef.current\\n',\n    //     isCacheChange, \n    //     isCachedRef.current, \n    //     wasCachedRef.current, \n    //     '\\nisCachingUnderway, isReparentingRef.current, isResizing\\n',\n    //     isCachingUnderway, \n    //     viewportInterruptProperties.isReparentingRef?.current, \n    //     viewportInterruptProperties.isResizing\n    // )\n    if ((_b = viewportInterruptProperties.isReparentingRef) === null || _b === void 0 ? void 0 : _b.current) {\n      viewportInterruptProperties.isReparentingRef.current = false; // no longer needed\n\n      parentingTransitionRequiredRef.current = true;\n    }\n\n    if (viewportInterruptProperties.isResizing) {\n      // caching is underway, so cancel\n      viewportInterruptProperties.isResizing = false;\n    }\n\n    if (isCacheChange) {\n      // into or out of caching\n      if (isCachedRef.current && !wasCachedRef.current) {\n        // change into cache\n        interruptHandler.pauseInterrupts();\n      }\n    }\n  } // generate state for restoring scrollPos\n\n\n  (0, react_1.useEffect)(function () {\n    if (parentingTransitionRequiredRef.current && !isCachedRef.current) {\n      parentingTransitionRequiredRef.current = false;\n      setCradleState('parentingtransition');\n    }\n  }, [parentingTransitionRequiredRef.current]); // change state for entering or leaving cache\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached'); // replaces 'ready' as steady state\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n\n      if (parentingTransitionRequiredRef.current) {\n        parentingTransitionRequiredRef.current = false;\n        setCradleState('parentingtransition');\n      } else {\n        if (hasBeenRenderedRef.current) {\n          setCradleState('renderfromcache');\n        } else {\n          setCradleState('firstrenderfromcache');\n        }\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]); // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // this will always be less than current listsize\n\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.listsize; // console.log('cradle fielding setMaxlistsize with maxListsize, listsize',maxListsize, listsize)\n\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n          deleteListCallback = _serviceHandler$callb.deleteListCallback,\n          changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      } //\n\n\n      cacheHandler.changeListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []); // clear mounted flag on unmount\n\n  (0, react_1.useLayoutEffect)(function () {\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []); //send callback callbacks to host\n\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.getFunctions) return;\n    var scrollToItem = serviceHandler.scrollToItem,\n        reload = serviceHandler.reload,\n        setListsize = serviceHandler.setListsize,\n        clearCache = serviceHandler.clearCache,\n        getCacheIndexMap = serviceHandler.getCacheIndexMap,\n        getCacheItemMap = serviceHandler.getCacheItemMap,\n        getCradleIndexMap = serviceHandler.getCradleIndexMap,\n        remapIndexes = serviceHandler.remapIndexes,\n        moveIndex = serviceHandler.moveIndex,\n        insertIndex = serviceHandler.insertIndex,\n        removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToItem: scrollToItem,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.getFunctions(functions);\n  }, []); // initialize window scroll listener\n\n  (0, react_1.useEffect)(function () {\n    var viewportdata = viewportInterruptPropertiesRef.current;\n    viewportdata.elementRef.current.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportdata.elementRef.current && viewportdata.elementRef.current.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []); // observer support\n\n  /*\n      There are two interection observers, one for the cradle wings, and another for triggerlines;\n          both against the viewport.\n      There is also a resize observer for the cradle wings, to generate responses to size changes of\n          variable cells.\n  */\n\n  (0, react_1.useEffect)(function () {\n    // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the \"repositioningRender\" cradle state is triggered.\n    var cradleintersectobserver = interruptHandler.cradleIntersect.createObserver();\n    interruptHandler.cradleIntersect.connectElements(); // triggerobserver tiggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n\n    var triggerobserver = interruptHandler.triggerlinesIntersect.createObserver();\n    interruptHandler.triggerlinesIntersect.connectElements(); // resize observer generates compensation for changes in cell sizes for variable layout modes\n\n    var resizeobserver = interruptHandler.cradleResize.createObserver();\n    interruptHandler.cradleResize.connectElements();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n      resizeobserver.disconnect();\n    };\n  }, []); // =====================[ RECONFIGURATION effects ]======================\n  // change caching, resize (UI resize of the viewport), reconfigure, or pivot\n\n  (0, react_1.useEffect)(function () {\n    // console.log('cradle - handle cache and cacheMax change:', cache, cacheMax)\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n\n    if (cradleStateRef.current == 'setup') return;\n\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n\n          if (cacheHandler.pareCacheToMax(_cacheMax, modelIndexList, dListCallback, scrollerID)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('resetcache');\n          break;\n        }\n\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n\n          var _dListCallback;\n\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n\n          if (cacheHandler.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheHandler.cacheProps.modified = true;\n            cacheHandler.renderPortalList();\n          }\n\n          setCradleState('resetcache');\n          break;\n        }\n    }\n  }, [cache, cacheMax]); // trigger resizing based on viewport state\n\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // movement to and from cache is independent of ui resizing\n\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n\n    if (viewportInterruptPropertiesRef.current.isResizing) {\n      interruptHandler.pauseInterrupts(); // console.log('calling resizing from isResizing useEvent','-'+scrollerID+'-')\n\n      setCradleState('resizing');\n    } // complete resizing mode\n\n\n    if (!viewportInterruptPropertiesRef.current.isResizing && cradleStateRef.current == 'resizing') {\n      setCradleState('finishresize');\n    }\n  }, [viewportInterruptPropertiesRef.current.isResizing]); // reconfigure for changed size parameters\n\n  (0, react_1.useEffect)(function () {\n    // console.log('in reconfigure effect:cradleStateRef.current,isCachedRef.current','-'+scrollerID+'-')\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return; // const signals = interruptHandler.signals\n\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [listsize, cellHeight, cellWidth, gap, padding, triggerlineOffset]); // pivot triggered on change of orientation\n\n  (0, react_1.useEffect)(function () {\n    // console.log('in pivot effect: orientation, isCachedRef.current\\n','-'+scrollerID+'-',orientation, isCachedRef.current)\n    scaffoldHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n\n    if (cradleStateRef.current == 'setup') {\n      scaffoldHandler.cradlePositionData.blockScrollPos = 0;\n      return;\n    }\n\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n        cellWidth = _cradleInheritedPrope.cellWidth,\n        cellHeight = _cradleInheritedPrope.cellHeight,\n        gap = _cradleInheritedPrope.gap; // get previous ratio\n\n    var previousCellPixelLength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var previousAxisOffset = scaffoldHandler.cradlePositionData.targetAxisViewportPixelOffset;\n    var previousratio = previousAxisOffset / previousCellPixelLength;\n    var pivotCellPixelLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n    var pivotAxisOffset = previousratio * pivotCellPixelLength;\n    scaffoldHandler.cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]); // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n\n  var _ref6 = (0, react_1.useMemo)(function () {\n    return stylesHandler.setCradleStyles({\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth,\n      crosscount: crosscount,\n      userstyles: styles,\n      triggerlineOffset: triggerlineOffset\n    });\n  }, [orientation, cellHeight, cellWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset]),\n      _ref7 = _slicedToArray(_ref6, 7),\n      cradleHeadStyle = _ref7[0],\n      cradleTailStyle = _ref7[1],\n      cradleAxisStyle = _ref7[2],\n      triggerlineHeadStyle = _ref7[3],\n      triggerlineAxisStyle = _ref7[4],\n      triggerlineTailStyle = _ref7[5],\n      cradleDividerStyle = _ref7[6]; // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (19 states), using named states\n  // useLayoutEffect for suppressing flashes\n\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      case 'resizing':\n        {\n          // no-op\n          break;\n        }\n\n      case 'applycellframechanges':\n        {\n          // user intervention\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          var portalHoldList = cacheHandler.portalHoldList;\n          var portalMap = cacheHandler.cacheProps.portalMap;\n\n          if (portalHoldList && portalHoldList.length) {\n            var _iterator = _createForOfIteratorHelper(portalHoldList),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var itemID = _step.value;\n                portalMap[\"delete\"](itemID);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n\n          setCradleState('ready');\n          break;\n        }\n\n      case 'setup':\n        {\n          // cycle to allow for ref config\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n\n            if (cacheHandler.pareCacheToMax(cacheMax, modelIndexList, dListCallback, scrollerID)) {\n              cacheHandler.cacheProps.modified = true;\n              cacheHandler.renderPortalList();\n            }\n\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n\n          cacheHandler.preload(cradleParametersRef.current, finalCallback, nullItemSetMaxListsize, scrollerID);\n          break;\n        }\n\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('renderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          }\n\n          break;\n        }\n\n      case 'finishparenting':\n        {\n          interruptHandler.restoreInterrupts();\n\n          if (hasBeenRenderedRef.current) {\n            setCradleState('ready');\n          } else {\n            setCradleState('firstrenderfromcache');\n          }\n\n          break;\n        }\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          var _cache = cradleInternalPropertiesRef.current.cache;\n\n          if (_cache == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n\n          cacheHandler.renderPortalList(); // interruptHandler.triggerlinesIntersect.connectElements()\n          // interruptHandler.signals.pauseTriggerlinesObserver = false\n\n          setCradleState('ready');\n          break;\n        }\n\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true; // avoid recursive cradle intersection interrupts\n\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n\n          setCradleState('repositioningRender');\n          break;\n        }\n\n      /*\n          the following 11 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'normalizesignals'\n      */\n\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'renderfromcache':\n      case 'scrollto':\n      case 'resetcache':\n      case 'finishpreload':\n      case 'reposition':\n      case 'finishresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reload':\n        {\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = []; // register new array id for Object.is to trigger react re-processing\n\n          _cradleContent.headDisplayComponents = [];\n          _cradleContent.tailDisplayComponents = [];\n\n          if (cradleState == 'reload') {\n            cacheHandler.clearCache();\n          }\n\n          contentHandler.setCradleContent(cradleState);\n\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          }\n\n          var _cache2 = cradleInheritedPropertiesRef.current.cache;\n\n          if (_cache2 == 'cradle') {\n            // console.log('processing cradle content: cache', cache)\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n\n            if (cacheHandler.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheHandler.renderPortalList();\n            }\n          }\n\n          setCradleState('preparerender');\n          break;\n        }\n\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          var _cradleContent2 = contentHandler.content;\n          _cradleContent2.headDisplayComponents = _cradleContent2.headModelComponents;\n          _cradleContent2.tailDisplayComponents = _cradleContent2.tailModelComponents;\n          setCradleState('normalizesignals');\n          break;\n        }\n\n      case 'normalizesignals':\n        {\n          // normalize or resume cycling\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // user request\n\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheHandler.clearCache();\n          setCradleState('ready');\n          break;\n        }\n      // moving out of cache into visible DOM tree (cellFrame)\n      // resets scrollPos (scrollLeft/scrollTop) to last UI value\n\n      case 'parentingtransition':\n        {\n          var cradlePositionData = scaffoldHandler.cradlePositionData; // console.log('in state machine parentingtransition', '-'+scrollerID+'-' , cradlePositionData.blockScrollPos)\n          // reset scroll position to previous value\n\n          if (cradlePositionData.blockScrollPos !== null) {\n            var viewportElement = viewportInterruptPropertiesRef.current.elementRef.current;\n            viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n          }\n\n          setCradleState('finishparenting');\n          break;\n        }\n    }\n  }, [cradleState]); // standard rendering states (3 states)\n\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        break;\n\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n\n      case 'ready':\n        // no op\n        break;\n    }\n  }, [cradleState]); // ==========================[ RENDER ]===========================\n\n  var scrollAxisReferenceIndex = scaffoldHandler.cradlePositionData.targetAxisReferenceIndex;\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!useScrollTracker) return null;\n\n    if (!(cradleState == 'repositioningContinuation' || cradleState == 'repositioningRender')) {\n      return null;\n    }\n\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, listsize, styles]);\n  var cradleContent = contentHandler.content;\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef,\n    cacheHandler: cacheHandler,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionsCallback: serviceHandler.callbacks.itemExceptionsCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT\n  });\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation' ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'triggerline-head',\n    style: triggerlineHeadStyle,\n    ref: headTriggerlineCradleElementRef\n  }), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'triggerline-axis',\n    style: triggerlineAxisStyle,\n    ref: axisTriggerlineCradleElementRef\n  }), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'triggerline-tail',\n    style: triggerlineTailStyle,\n    ref: tailTriggerlineCradleElementRef\n  }), showAxis ? react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\n// utility\n\n\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n\n  var cacheHandler = cradleParameters.cradleInheritedPropertiesRef.current.cacheHandler;\n  return {\n    cacheHandler: cacheHandler,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    scaffoldHandler: createHandler(scaffoldhandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};\n\nexports[\"default\"] = Cradle;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWFILENBbkJEOztBQXFCQWxOLGtCQUFBQSxHQUFlRyxNQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9DcmFkbGUudHN4PzcxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY3JhZGxlLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBjb25zaWRlciBmb3JtYWxpemluZyBzdGF0ZSBjb25kaXRpb25zIChjZXJ0YWluIHVzZVJlZnMpLCB0b2dldGhlciB3aXRoIHN0YXRlIGFjdGlvbnMgKHVzZVN0YXRlKVxuXG4gICAgLSByYXRpb25hbGl6ZSBwYXVzZVNjcm9sbGluZywgYW5kIG90aGVyIHNpZ25hbHNcbiovXG5cbmltcG9ydCBSZWFjdCwgeyBcbiAgICB1c2VTdGF0ZSwgXG4gICAgdXNlUmVmLCBcbiAgICB1c2VDb250ZXh0LCBcbiAgICB1c2VFZmZlY3QsIFxuICAgIHVzZUxheW91dEVmZmVjdCwgXG4gICAgdXNlTWVtbyxcbiAgICB1c2VDYWxsYmFjaywgXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydEludGVycnVwdCB9IGZyb20gJy4vVmlld3BvcnQnXG5cbi8vIHBvcHVwIHBvc2l0aW9uIHRyYWNrZXIgZm9yIHJlcG9zaXRpb25pbmdcbmltcG9ydCBTY3JvbGxUcmFja2VyIGZyb20gJy4vY3JhZGxlL1Njcm9sbFRyYWNrZXInXG5cbi8vIHN1cHBvcnQgY29kZVxuaW1wb3J0IFNjcm9sbEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc2Nyb2xsaGFuZGxlcidcbmltcG9ydCBTdGF0ZUhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc3RhdGVoYW5kbGVyJ1xuaW1wb3J0IENvbnRlbnRIYW5kbGVyIGZyb20gJy4vY3JhZGxlL2NvbnRlbnRoYW5kbGVyJ1xuaW1wb3J0IFNjYWZmb2xkSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zY2FmZm9sZGhhbmRsZXInXG5pbXBvcnQgSW50ZXJydXB0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyJ1xuaW1wb3J0IFNlcnZpY2VIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3NlcnZpY2VoYW5kbGVyJ1xuaW1wb3J0IFN0eWxlc0hhbmRsZXIgZnJvbSAnLi9jcmFkbGUvc3R5bGVzaGFuZGxlcidcblxuLy8gZm9yIGNoaWxkcmVuXG5leHBvcnQgY29uc3QgQ3JhZGxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuLy8gY29tcG9uZW50XG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ3JpZFNwZWNzLFxuXG4gICAgICAgIHJ1bndheVNpemUsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIFxuICAgICAgICB1c2VyQ2FsbGJhY2tzLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgLy8gZm9yIGhhbmRsZXIgbGlzdFxuICAgICAgICBjYWNoZUhhbmRsZXIsXG4gICAgICAgIHVzZVNjcm9sbFRyYWNrZXIsXG4gICAgICAgIHNob3dBeGlzLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLFxuICAgIH0pID0+IHtcblxuICAgIGlmIChsaXN0c2l6ZSA9PSAwKSByZXR1cm4gbnVsbC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCkgIC8vIGRlZmVuc2l2ZVxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBEQVRBIFNFVFVQIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVucGFjayBncmlkU3BlY3NcbiAgICBjb25zdCB7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIC8vIGdldCB2aWV3cG9ydCBjb250ZXh0XG4gICAgY29uc3Qgdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydEludGVycnVwdClcblxuICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzIC8vIGZvciBjbG9zdXJlc1xuXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1xuICAgIGNvbnN0IHsgaGVpZ2h0OnZpZXdwb3J0aGVpZ2h0LHdpZHRoOnZpZXdwb3J0d2lkdGggfSA9IHZpZXdwb3J0RGltZW5zaW9uc1xuXG4gICAgLy8gc3RhdGVcbiAgICBjb25zdCBbY3JhZGxlU3RhdGUsIHNldENyYWRsZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgY3JhZGxlU3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzXG4gICAgY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9IGNyYWRsZVN0YXRlXG5cbiAgICAvLyBjb25zb2xlLmxvZygnPT0+IFJVTk5JTkcgQ3JhZGxlJywnLScrc2Nyb2xsZXJJRCsnLScsIGNyYWRsZVN0YXRlKVxuICAgIC8vIGNvbnNvbGUubG9nKCdwZXJmb3JtYW5jZS5tZW1vcnknLHBlcmZvcm1hbmNlWydtZW1vcnknXSlcblxuICAgIC8vIGZsYWdzXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG4gICAgY29uc3QgaXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3Qgd2FzQ2FjaGVkUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCBoYXNCZWVuUmVuZGVyZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgICAvLyBjcmFkbGUgc2NhZmZvbGQgZWxlbWVudCByZWZzXG4gICAgY29uc3QgaGVhZENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGF4aXNDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgaGVhZFRyaWdnZXJsaW5lQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGF4aXNUcmlnZ2VybGluZUNyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBzY2FmZm9sZCBidW5kbGVcbiAgICBjb25zdCBjcmFkbGVFbGVtZW50c1JlZiA9IHVzZVJlZihcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZFJlZjpoZWFkQ3JhZGxlRWxlbWVudFJlZiwgXG4gICAgICAgICAgICB0YWlsUmVmOnRhaWxDcmFkbGVFbGVtZW50UmVmLCBcbiAgICAgICAgICAgIGF4aXNSZWY6YXhpc0NyYWRsZUVsZW1lbnRSZWYsXG4gICAgICAgICAgICBoZWFkVHJpZ2dlcmxpbmVSZWY6aGVhZFRyaWdnZXJsaW5lQ3JhZGxlRWxlbWVudFJlZixcbiAgICAgICAgICAgIGF4aXNUcmlnZ2VybGluZVJlZjpheGlzVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmLFxuICAgICAgICAgICAgdGFpbFRyaWdnZXJsaW5lUmVmOnRhaWxUcmlnZ2VybGluZUNyYWRsZUVsZW1lbnRSZWZcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbmZpZ3VyYXRpb24gY2FsY3VsYXRpb25zXG4gICAgY29uc3QgY3Jvc3Njb3VudCA9IHVzZU1lbW8oKCkgPT4geyAvLyB0aGUgbnVtYmVyIG9mIGNlbGxzIGNyb3NzaW5nIG9yaWVudGF0aW9uXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRzaXplID0gKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/dmlld3BvcnRoZWlnaHQ6dmlld3BvcnR3aWR0aFxuXG4gICAgICAgIGlmICh2aWV3cG9ydHNpemUgPT0gMCkge1xuXG4gICAgICAgICAgICByZXR1cm4gMFxuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3Jvc3NMZW5ndGggPSAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKT9jZWxsSGVpZ2h0OmNlbGxXaWR0aFxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0bGVuZ3RoZm9yY2FsYyA9IHZpZXdwb3J0c2l6ZSAtIChwYWRkaW5nICogMikgKyBnYXAgLy8gbGVuZ3RoIG9mIHZpZXdwb3J0XG4gICAgICAgIGxldCB0aWxlbGVuZ3RoZm9yY2FsYyA9IGNyb3NzTGVuZ3RoICsgZ2FwXG4gICAgICAgIHRpbGVsZW5ndGhmb3JjYWxjID0gTWF0aC5taW4odGlsZWxlbmd0aGZvcmNhbGMsdmlld3BvcnRsZW5ndGhmb3JjYWxjKSAvLyByZXN1bHQgY2Fubm90IGJlIGxlc3MgdGhhbiAxXG5cbiAgICAgICAgY29uc3QgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3Iodmlld3BvcnRsZW5ndGhmb3JjYWxjL3RpbGVsZW5ndGhmb3JjYWxjKVxuXG4gICAgICAgIHJldHVybiBjcm9zc2NvdW50XG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICBdKVxuXG4gICAgLy8gdmFyaW91cyByb3cgY291bnRzXG4gICAgY29uc3QgW1xuICAgICAgICBjcmFkbGVSb3djb3VudCwgXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsIFxuICAgICAgICB2aWV3cG9ydFZpc2libGVSb3djb3VudCwgLy8gbWF4IG51bWJlciBvZiByb3dzIGNvbXBsZXRlbHkgdmlzaWJsZSBhdCBvbmNlXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVuZ3RoLCByb3dMZW5ndGhcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0TGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcbiAgICAgICAgICAgIHJvd0xlbmd0aCA9IGNlbGxIZWlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdwb3J0TGVuZ3RoID0gdmlld3BvcnR3aWR0aFxuICAgICAgICAgICAgcm93TGVuZ3RoID0gY2VsbFdpZHRoXG4gICAgICAgIH1cblxuICAgICAgICByb3dMZW5ndGggKz0gZ2FwXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRSb3djb3VudCA9IE1hdGguY2VpbCh2aWV3cG9ydExlbmd0aC9yb3dMZW5ndGgpXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRWaXNpYmxlUm93Y291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0TGVuZ3RoL3Jvd0xlbmd0aClcblxuICAgICAgICBjb25zdCBsaXN0Um93Y291bnQgPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgPSB2aWV3cG9ydFJvd2NvdW50ICsgKHJ1bndheVNpemUgKiAyKVxuXG4gICAgICAgIGxldCBjcmFkbGVSb3djb3VudCA9IE1hdGgubWluKGxpc3RSb3djb3VudCwgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50KVxuXG4gICAgICAgIGxldCBydW53YXlSb3djb3VudFxuICAgICAgICBpZiAoY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50ID49IGNyYWRsZVJvd2NvdW50KSB7XG4gICAgICAgICAgICBydW53YXlSb3djb3VudCA9IHJ1bndheVNpemVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAoY3JhZGxlUm93Y291bnQgLSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCAtPSBNYXRoLmZsb29yKGRpZmYvMilcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50ID0gTWF0aC5tYXgoMCxydW53YXlSb3djb3VudClcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXRlbWNvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgICAgIGlmIChpdGVtY291bnQgPiBsaXN0c2l6ZSkge1xuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNyYWRsZVJvd2NvdW50LCBcbiAgICAgICAgICAgIHZpZXdwb3J0Um93Y291bnQsIFxuICAgICAgICAgICAgdmlld3BvcnRWaXNpYmxlUm93Y291bnQsXG4gICAgICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgXVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgLy8gcGFkZGluZyxcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcblxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICBdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsbGJhY2tzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBob3N0IGNhbGxiYWNrc1xuICAgIGNvbnN0IGV4dGVybmFsQ2FsbGJhY2tzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgICAgICBwcmVsb2FkSW5kZXhDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5wcmVsb2FkSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5kZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrOnVzZXJDYWxsYmFja3M/LmNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrOnVzZXJDYWxsYmFja3M/Lml0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVsgYnVuZGxlIHBhcmFtZXRlcnMgZm9yIGhhbmRsZXJzIF0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBidW5kbGUgYWxsIGNyYWRsZSBwcm9wcyB0byBwYXNzIHRvIGhhbmRsZXJzIC0gdWx0aW1hdGVseSBjcmFkbGVQYXJhbWV0ZXJzUmVmXG4gICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXMgYW5kIHN1cHBvcnQgY2FsbGJhY2tzXG4gICAgLy8gdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIC8vIGdyaWRTcGVjc1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvLyAuLi5yZXN0XG4gICAgICAgIGNhY2hlLFxuICAgICAgICBjYWNoZU1heCxcbiAgICAgICAgc3RhcnRpbmdJbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIHVzZXJDYWxsYmFja3MsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG5cbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gcGFzc2VkIHRvIGNlbGxGcmFtZSBjb250ZW50ICh1c2VyIGNvbnRlbnQpIGlmIHJlcXVlc3RlZFxuICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2FjaGVNYXgsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gc2hhcmVcbiAgICBjb25zdCBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgLy8gdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG5cbiAgICAgICAgLy8gZm9yIHN0YXRlSGFuZGxlclxuICAgICAgICBjcmFkbGVTdGF0ZVJlZixcbiAgICAgICAgc2V0Q3JhZGxlU3RhdGUsXG4gICAgfVxuXG4gICAgLy8gcGxhY2Vob2xkZXIgaW4gY3JhZGxlUGFyYW1ldGVycyB0byBtYWtlIGF2YWlsYWJsZSBpbmRpdmlkdWFsIGhhbmRsZXJzXG4gICAgY29uc3QgaGFuZGxlcnNSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGNyYWRsZSBwYXJhbWV0ZXJzIE1BU1RFUiBCVU5ETEVcbiAgICBjb25zdCBjcmFkbGVQYXJhbWV0ZXJzID0ge1xuICAgICAgICBoYW5kbGVyc1JlZixcbiAgICAgICAgdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLFxuICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGV4dGVybmFsQ2FsbGJhY2tzUmVmLFxuICAgIH1cblxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVQYXJhbWV0ZXJzUmVmLmN1cnJlbnQgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBvbmdvaW5nIHNvdXJjZSBvZiBoYW5kbGVycyAtIG5vdGUgYWxsIEhhbmRsZXJzIGFyZSBnaXZlbiBhbGwgcGFyYW1ldGVycyAoY3JhZGxlUGFyYW1ldGVycylcbiAgICBpZiAoIWhhbmRsZXJzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaGFuZGxlcnNSZWYuY3VycmVudCA9IGdldENyYWRsZUhhbmRsZXJzKGNyYWRsZVBhcmFtZXRlcnMpXG4gICAgfVxuXG4gICAgLy8gbWFrZSBoYW5kbGVycyBkaXJlY3RseSBhdmFpbGFibGUgdG8gY3JhZGxlIGNvZGUgYmVsb3dcbiAgICBjb25zdCB7IC8vIGNhY2hlSGFuZGxlciBhbHJlYWR5IGF2YWlsYWJsZVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICBzY3JvbGxIYW5kbGVyLFxuICAgICAgICBzdGF0ZUhhbmRsZXIsXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICBzY2FmZm9sZEhhbmRsZXIsXG4gICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICBzdHlsZXNIYW5kbGVyLFxuICAgIH0gPSBoYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVsgSU5URVJDRVBUIENBQ0hJTkcgU1RBVEUgQ0hBTkdFIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBpbnRlcmNlcHQgY2hhbmdlIGluIGNhY2hpbmcgc3RhdHVzXG4gICAgLy8gd2hlbiBhIHBvcnRhbCBpcyBjYWNoZWQsIGluY2x1ZGluZyB0aGUgdHJhbnNpdGlvbiBvZiBiZWluZyBtb3ZlZCBmcm9tIG9uZSBjZWxsRnJhbWUgdG8gYW5vdGhlcixcbiAgICAvLyAoYW5kIHRoZSBpbmZpbml0ZWdyaWRzY3JvbGxlciBjYW4gYmUgYSBjb21wb25lbnQgdGhhdCBpcyBjYWNoZWQpLFxuICAgIC8vIHRoZSBzY3JvbGxQb3MgKHNjcm9sbExlZnQgb3Igc2Nyb2xsVG9wKSBpcyByZXNldCB0byAwICh6ZXJvKS4gV2hlbiB0aGUgc2Nyb2xsZXIgaXMgXG4gICAgLy8gbW92ZWQgdG8gYSBjZWxsRnJhbWUsIHRoaXMgY29kZSByZXN0b3JlcyB0aGUgc2Nyb2xsUG9zLlxuICAgIC8vIFRoZSByZXN0b3JlIGFjdGlvbiBtdXN0IGJlIHRoZSBmaXJzdCBwcmlvcml0eSB0byBoaWRlIHRoZSBzY3JvbGxQb3MgY2hhbmdlcyBmcm9tIHRoZSB1c2VyXG5cbiAgICAvLyBjb25zb2xlLmxvZygnaW4gY3JhZGxlIHZpZXdwb3J0d2lkdGgsIHZpZXdwb3J0aGVpZ2h0JywnLScrc2Nyb2xsZXJJRCsnLScsdmlld3BvcnR3aWR0aCwgdmlld3BvcnRoZWlnaHQpXG4gICAgXG4gICAgY29uc3QgaXNJblBvcnRhbCA9ICgodmlld3BvcnR3aWR0aCA9PSAwKSAmJiAodmlld3BvcnRoZWlnaHQgPT0gMCkpIC8vIG11c3QgYmUgaW4gcG9ydGFsIChjYWNoZSkgc3RhdGVcbiAgICAvLyBjb25zdCBpc0luUG9ydGFsID0gKCh2d2lkdGggPT0gMCkgJiYgKHZoZWlnaHQgPT0gMCkpIC8vIG11c3QgYmUgaW4gcG9ydGFsIChjYWNoZSkgc3RhdGVcblxuICAgIGNvbnN0IGlzQ2FjaGVDaGFuZ2UgPSAoaXNJblBvcnRhbCAhPSBpc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UpIHtcbiAgICAgICAgd2FzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0NhY2hlZFJlZi5jdXJyZW50XG4gICAgICAgIGlzQ2FjaGVkUmVmLmN1cnJlbnQgPSBpc0luUG9ydGFsXG4gICAgfVxuXG4gICAgY29uc3QgaXNDYWNoaW5nVW5kZXJ3YXkgPSAoaXNDYWNoZWRSZWYuY3VycmVudCB8fCB3YXNDYWNoZWRSZWYuY3VycmVudClcblxuICAgIC8vIGNvbnNvbGUubG9nKFxuICAgIC8vICAgICAnKio+PiAtJytzY3JvbGxlcklEKyctJywgY3JhZGxlU3RhdGUsJ1xcbicsXG4gICAgLy8gICAgICdpc0luUG9ydGFsLCB2aWV3cG9ydHdpZHRoLCB2aWV3cG9ydGhlaWdodCwgYmxvY2tTY3JvbGxQb3MsIGJsb2NrU2Nyb2xsUG9zXFxuJywgXG4gICAgLy8gICAgIGlzSW5Qb3J0YWwsIHZpZXdwb3J0d2lkdGgsIHZpZXdwb3J0aGVpZ2h0LCBzY2FmZm9sZEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zKVxuXG4gICAgLy8gY29uc29sZS5sb2coJy0gaXNDYWNoZUNoYW5nZSwgaXNDYWNoaW5nVW5kZXJ3YXksIGlzQ2FjaGVkUmVmLmN1cnJlbnQsIHdhc0NhY2hlZFJlZi5jdXJyZW50XFxuJyxcbiAgICAvLyAgICAgaXNDYWNoZUNoYW5nZSwgaXNDYWNoaW5nVW5kZXJ3YXksIGlzQ2FjaGVkUmVmLmN1cnJlbnQsIHdhc0NhY2hlZFJlZi5jdXJyZW50KVxuXG4gICAgLy8gY29uc29sZS5sb2coJy0gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmlzUmVwYXJlbnRpbmdSZWY/LmN1cnJlbnQsIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1Jlc2l6aW5nLCBvcmllbnRhdGlvblxcbicsXG4gICAgLy8gICAgIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50LCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuaXNSZXNpemluZywgb3JpZW50YXRpb24pXG5cbiAgICBpZiAoXG4gICAgICAgIGlzQ2FjaGVDaGFuZ2UgfHwgXG4gICAgICAgIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50IHx8XG4gICAgICAgICh2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuaXNSZXNpemluZyAmJiBpc0NhY2hpbmdVbmRlcndheSkgXG4gICAgKSB7IFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFxuICAgICAgICAvLyAgICAgJy0nK3Njcm9sbGVySUQrJy0nLFxuICAgICAgICAvLyAgICAgJ2lzSW5Qb3J0YWwnLCBcbiAgICAgICAgLy8gICAgIGlzSW5Qb3J0YWwsIFxuICAgICAgICAvLyAgICAgJ1xcbmlzQ2FjaGVDaGFuZ2UsIGlzQ2FjaGVkUmVmLmN1cnJlbnQsIHdhc0NhY2hlZFJlZi5jdXJyZW50XFxuJyxcbiAgICAgICAgLy8gICAgIGlzQ2FjaGVDaGFuZ2UsIFxuICAgICAgICAvLyAgICAgaXNDYWNoZWRSZWYuY3VycmVudCwgXG4gICAgICAgIC8vICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCwgXG4gICAgICAgIC8vICAgICAnXFxuaXNDYWNoaW5nVW5kZXJ3YXksIGlzUmVwYXJlbnRpbmdSZWYuY3VycmVudCwgaXNSZXNpemluZ1xcbicsXG4gICAgICAgIC8vICAgICBpc0NhY2hpbmdVbmRlcndheSwgXG4gICAgICAgIC8vICAgICB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuaXNSZXBhcmVudGluZ1JlZj8uY3VycmVudCwgXG4gICAgICAgIC8vICAgICB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuaXNSZXNpemluZ1xuICAgICAgICAvLyApXG5cbiAgICAgICAgaWYgKHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmPy5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmLmN1cnJlbnQgPSBmYWxzZSAvLyBubyBsb25nZXIgbmVlZGVkXG5cbiAgICAgICAgICAgIHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5pc1Jlc2l6aW5nKSB7IC8vIGNhY2hpbmcgaXMgdW5kZXJ3YXksIHNvIGNhbmNlbFxuXG4gICAgICAgICAgICB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuaXNSZXNpemluZyA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhY2hlQ2hhbmdlKSB7IC8vIGludG8gb3Igb3V0IG9mIGNhY2hpbmdcblxuICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIXdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgc3RhdGUgZm9yIHJlc3RvcmluZyBzY3JvbGxQb3NcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAocGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcGFyZW50aW5nVHJhbnNpdGlvblJlcXVpcmVkUmVmLmN1cnJlbnQgPSBmYWxzZSAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuICAgICAgICB9XG5cbiAgICB9LFtwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyBjaGFuZ2Ugc3RhdGUgZm9yIGVudGVyaW5nIG9yIGxlYXZpbmcgY2FjaGVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm4gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50ICYmICF3YXNDYWNoZWRSZWYuY3VycmVudCkgeyAvLyBpbnRvIGNhY2hlXG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKSAvLyByZXBsYWNlcyAncmVhZHknIGFzIHN0ZWFkeSBzdGF0ZVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHsgLy8gb3V0IG9mIGNhY2hlXG5cbiAgICAgICAgICAgIHdhc0NhY2hlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRpbmdUcmFuc2l0aW9uUmVxdWlyZWRSZWYuY3VycmVudCA9IGZhbHNlICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3BhcmVudGluZ3RyYW5zaXRpb24nKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbaXNDYWNoZWRSZWYuY3VycmVudCwgd2FzQ2FjaGVkUmVmLmN1cnJlbnRdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVsgSU5JVElBTElaQVRJT04gZWZmZWN0cyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgYXJlIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcblxuICAgIC8vIHRoaXMgd2lsbCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnJlbnQgbGlzdHNpemVcbiAgICBjb25zdCBudWxsSXRlbVNldE1heExpc3RzaXplID0gdXNlQ2FsbGJhY2soKG1heExpc3RzaXplKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RzaXplID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQubGlzdHNpemVcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NyYWRsZSBmaWVsZGluZyBzZXRNYXhsaXN0c2l6ZSB3aXRoIG1heExpc3RzaXplLCBsaXN0c2l6ZScsbWF4TGlzdHNpemUsIGxpc3RzaXplKVxuICAgICAgICBpZiAobWF4TGlzdHNpemUgPCBsaXN0c2l6ZSkge1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdnZXRJdGVtIHJldHVybmVkIG51bGwnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2hhbmdlTGlzdHNpemUobWF4TGlzdHNpemUsIFxuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjaylcblxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIGNsZWFyIG1vdW50ZWQgZmxhZyBvbiB1bm1vdW50XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vc2VuZCBjYWxsYmFjayBjYWxsYmFja3MgdG8gaG9zdFxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICghdXNlckNhbGxiYWNrcy5nZXRGdW5jdGlvbnMpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgc2Nyb2xsVG9JdGVtLCBcbiAgICAgICAgICAgIHJlbG9hZCwgXG4gICAgICAgICAgICBzZXRMaXN0c2l6ZSxcbiAgICAgICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgICAgICBnZXRDYWNoZUluZGV4TWFwLCBcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgICAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICByZW1vdmVJbmRleCxcblxuICAgICAgICB9ID0gc2VydmljZUhhbmRsZXJcblxuICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSB7XG5cbiAgICAgICAgICAgIHNjcm9sbFRvSXRlbSxcbiAgICAgICAgICAgIHJlbG9hZCxcbiAgICAgICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICAgICAgY2xlYXJDYWNoZSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Q2FjaGVJbmRleE1hcCxcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcCxcbiAgICAgICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuICAgICAgICAgICAgcmVtYXBJbmRleGVzLFxuICAgICAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0SW5kZXgsXG4gICAgICAgICAgICByZW1vdmVJbmRleCxcblxuICAgICAgICB9XG5cbiAgICAgICAgdXNlckNhbGxiYWNrcy5nZXRGdW5jdGlvbnMoZnVuY3Rpb25zKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGluaXRpYWxpemUgd2luZG93IHNjcm9sbCBsaXN0ZW5lclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRkYXRhID0gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgdmlld3BvcnRkYXRhLmVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIub25TY3JvbGwpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgdmlld3BvcnRkYXRhLmVsZW1lbnRSZWYuY3VycmVudCAmJiB2aWV3cG9ydGRhdGEuZWxlbWVudFJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5vblNjcm9sbClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gb2JzZXJ2ZXIgc3VwcG9ydFxuXG4gICAgLypcbiAgICAgICAgVGhlcmUgYXJlIHR3byBpbnRlcmVjdGlvbiBvYnNlcnZlcnMsIG9uZSBmb3IgdGhlIGNyYWRsZSB3aW5ncywgYW5kIGFub3RoZXIgZm9yIHRyaWdnZXJsaW5lczsgXG4gICAgICAgICAgICBib3RoIGFnYWluc3QgdGhlIHZpZXdwb3J0LlxuICAgICAgICBUaGVyZSBpcyBhbHNvIGEgcmVzaXplIG9ic2VydmVyIGZvciB0aGUgY3JhZGxlIHdpbmdzLCB0byBnZW5lcmF0ZSByZXNwb25zZXMgdG8gc2l6ZSBjaGFuZ2VzIG9mIFxuICAgICAgICAgICAgdmFyaWFibGUgY2VsbHMuXG4gICAgKi8gICAgXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIG9ic2VydmVyIGZvciBjcmFkbGUgYm9keVxuICAgICAgICAvLyB0aGlzIHNldHMgdXAgYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgb2YgdGhlIGNyYWRsZSBhZ2FpbnN0IHRoZSB2aWV3cG9ydC4gV2hlbiB0aGVcbiAgICAgICAgLy8gY3JhZGxlIGdvZXMgb3V0IG9mIHRoZSBvYnNlcnZlciBzY29wZSwgdGhlIFwicmVwb3NpdGlvbmluZ1JlbmRlclwiIGNyYWRsZSBzdGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGNvbnN0IGNyYWRsZWludGVyc2VjdG9ic2VydmVyID0gaW50ZXJydXB0SGFuZGxlci5jcmFkbGVJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIC8vIHRyaWdnZXJvYnNlcnZlciB0aWdnZXJzIGNyYWRsZSBjb250ZW50IHVwZGF0ZXMgXG4gICAgICAgIC8vICAgICB3aGVuIHRyaWdnZXJsaW5lcyBwYXNzIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICBjb25zdCB0cmlnZ2Vyb2JzZXJ2ZXIgPSBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jcmVhdGVPYnNlcnZlcigpXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG5cbiAgICAgICAgLy8gcmVzaXplIG9ic2VydmVyIGdlbmVyYXRlcyBjb21wZW5zYXRpb24gZm9yIGNoYW5nZXMgaW4gY2VsbCBzaXplcyBmb3IgdmFyaWFibGUgbGF5b3V0IG1vZGVzXG4gICAgICAgIGNvbnN0IHJlc2l6ZW9ic2VydmVyID0gaW50ZXJydXB0SGFuZGxlci5jcmFkbGVSZXNpemUuY3JlYXRlT2JzZXJ2ZXIoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZVJlc2l6ZS5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNyYWRsZWludGVyc2VjdG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdHJpZ2dlcm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgcmVzaXplb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgUkVDT05GSUdVUkFUSU9OIGVmZmVjdHMgXT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBjaGFuZ2UgY2FjaGluZywgcmVzaXplIChVSSByZXNpemUgb2YgdGhlIHZpZXdwb3J0KSwgcmVjb25maWd1cmUsIG9yIHBpdm90XG5cbiAgICB1c2VFZmZlY3QoKCk9PiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NyYWRsZSAtIGhhbmRsZSBjYWNoZSBhbmQgY2FjaGVNYXggY2hhbmdlOicsIGNhY2hlLCBjYWNoZU1heClcblxuICAgICAgICBpZiAoY2FjaGUgPT0gJ3ByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdzdGFydHByZWxvYWQnKVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgc3dpdGNoIChjYWNoZSkge1xuXG4gICAgICAgICAgICBjYXNlICdrZWVwbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ3BhcmUgY2FjaGUgdG8gY2FjaGVNYXgnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNYXggPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZU1heFxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5wYXJlQ2FjaGVUb01heChjYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2ssIHNjcm9sbGVySUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3Jlc2V0Y2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3JhZGxlJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVzZXRjYWNoZScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW2NhY2hlLCBjYWNoZU1heF0pXG5cbiAgICAvLyB0cmlnZ2VyIHJlc2l6aW5nIGJhc2VkIG9uIHZpZXdwb3J0IHN0YXRlXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgLy8gbW92ZW1lbnQgdG8gYW5kIGZyb20gY2FjaGUgaXMgaW5kZXBlbmRlbnQgb2YgdWkgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQgfHwgd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nKSB7XG5cbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcbiBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsaW5nIHJlc2l6aW5nIGZyb20gaXNSZXNpemluZyB1c2VFdmVudCcsJy0nK3Njcm9sbGVySUQrJy0nKVxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3Jlc2l6aW5nJylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcGxldGUgcmVzaXppbmcgbW9kZVxuICAgICAgICBpZiAoIXZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcgJiYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3Jlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHJlc2l6ZScpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZ10pXG5cbiAgICAvLyByZWNvbmZpZ3VyZSBmb3IgY2hhbmdlZCBzaXplIHBhcmFtZXRlcnNcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW4gcmVjb25maWd1cmUgZWZmZWN0OmNyYWRsZVN0YXRlUmVmLmN1cnJlbnQsaXNDYWNoZWRSZWYuY3VycmVudCcsJy0nK3Njcm9sbGVySUQrJy0nKVxuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICAvLyBjb25zdCBzaWduYWxzID0gaW50ZXJydXB0SGFuZGxlci5zaWduYWxzXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWNvbmZpZ3VyZScpXG5cbiAgICB9LFtcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldFxuICAgIF0pXG5cbiAgICAvLyBwaXZvdCB0cmlnZ2VyZWQgb24gY2hhbmdlIG9mIG9yaWVudGF0aW9uXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbiBwaXZvdCBlZmZlY3Q6IG9yaWVudGF0aW9uLCBpc0NhY2hlZFJlZi5jdXJyZW50XFxuJywnLScrc2Nyb2xsZXJJRCsnLScsb3JpZW50YXRpb24sIGlzQ2FjaGVkUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgc2NhZmZvbGRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKT9cInNjcm9sbFRvcFwiOlwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgc2NhZmZvbGRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IDBcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGdldCBwcmV2aW91cyByYXRpb1xuICAgICAgICBjb25zdCBwcmV2aW91c0NlbGxQaXhlbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGg6XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodClcbiAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNBeGlzT2Zmc2V0ID0gc2NhZmZvbGRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzcmF0aW8gPSBwcmV2aW91c0F4aXNPZmZzZXQvcHJldmlvdXNDZWxsUGl4ZWxMZW5ndGhcblxuICAgICAgICBjb25zdCBwaXZvdENlbGxQaXhlbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aClcbiAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgY29uc3QgcGl2b3RBeGlzT2Zmc2V0ID0gcHJldmlvdXNyYXRpbyAqIHBpdm90Q2VsbFBpeGVsTGVuZ3RoXG4gICAgICAgIFxuICAgICAgICBzY2FmZm9sZEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gTWF0aC5yb3VuZChwaXZvdEF4aXNPZmZzZXQpXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLCBcbiAgICAgICAgY3JhZGxlVGFpbFN0eWxlLCBcbiAgICAgICAgY3JhZGxlQXhpc1N0eWxlLCBcbiAgICAgICAgdHJpZ2dlcmxpbmVIZWFkU3R5bGUsIFxuICAgICAgICB0cmlnZ2VybGluZUF4aXNTdHlsZSxcbiAgICAgICAgdHJpZ2dlcmxpbmVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZURpdmlkZXJTdHlsZVxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLnNldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICB1c2Vyc3R5bGVzOnN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuXG4gICAgICAgIH0pXG5cbiAgICB9LFtcblxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuXG4gICAgICBdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09WyBTVEFURSBNQU5BR0VNRU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBzdGF0ZSBlbmdpbmUgKDE5IHN0YXRlcyksIHVzaW5nIG5hbWVkIHN0YXRlc1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBmb3Igc3VwcHJlc3NpbmcgZmxhc2hlc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlU3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVzaXppbmcnOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5Y2VsbGZyYW1lY2hhbmdlcyc6IHsgLy8gdXNlciBpbnRlcnZlbnRpb25cblxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsSG9sZExpc3QgfSA9IGNhY2hlSGFuZGxlclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydGFsTWFwIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wc1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRhbEhvbGRMaXN0ICYmIHBvcnRhbEhvbGRMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbUlEIG9mIHBvcnRhbEhvbGRMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBjb25maWdcblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuY2FjaGUgIT0gJ3ByZWxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2FjaGVkJylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcicpIC8vIGxvYWQgZ3JpZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cHJlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUhhbmRsZXIucGFyZUNhY2hlVG9NYXgoY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHByZWxvYWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5wcmVsb2FkKGNyYWRsZVBhcmFtZXRlcnNSZWYuY3VycmVudCwgZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRClcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2NhY2hlZCc6IHtcblxuICAgICAgICAgICAgICAgIGlmICghd2FzQ2FjaGVkUmVmLmN1cnJlbnQgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2hwYXJlbnRpbmcnOntcblxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIucmVzdG9yZUludGVycnVwdHMoKVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbmRlcnVwZGF0ZWRjb250ZW50IGlzIGNhbGxlZCBmcm9tIHVwZGF0ZUNyYWRsZUNvbnRlbnQuIFxuICAgICAgICAgICAgLy8gaXQgaXMgcmVxdWlyZWQgdG8gaW50ZWdyYXRlIGNoYW5nZWQgRE9NIGNvbmZpZ3VyYXRpb25zIGJlZm9yZSAncmVhZHknIGlzIGRpc3BsYXllZFxuICAgICAgICAgICAgY2FzZSAncmVuZGVydXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5ndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZygpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgICAgICAgICAvLyBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICAgICAgICAgIC8vIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRyZXBvc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgY3JhZGxlIGludGVyc2VjdGlvbiBpbnRlcnJ1cHRzXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2UgLy8gYmVjYXVzZSBub3cgdW5kZXJ3YXlcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZXBvc2l0aW9uaW5nUmVuZGVyJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0aGUgZm9sbG93aW5nIDExIGNyYWRsZSBzdGF0ZXMgYWxsIHJlc29sdmUgd2l0aFxuICAgICAgICAgICAgICAgIGEgY2hhaW4gc3RhcnRpbmcgd2l0aCBzZXRDcmFkbGVDb250ZW50LCBcbiAgICAgICAgICAgICAgICBjb250aW51aW5nIHdpdGggJ3ByZXBhcmVyZW5kZXInLCBhbmQgZW5kaW5nIHdpdGhcbiAgICAgICAgICAgICAgICAnbm9ybWFsaXplc2lnbmFscydcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdmaXJzdHJlbmRlcmZyb21jYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdyZW5kZXJmcm9tY2FjaGUnOlxuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsdG8nOlxuICAgICAgICAgICAgY2FzZSAncmVzZXRjYWNoZSc6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2hwcmVsb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcG9zaXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocmVzaXplJzpcbiAgICAgICAgICAgIGNhc2UgJ3Bpdm90JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSBjb250ZW50SGFuZGxlci5jb250ZW50XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBuZXcgYXJyYXkgaWQgZm9yIE9iamVjdC5pcyB0byB0cmlnZ2VyIHJlYWN0IHJlLXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5zZXRDcmFkbGVDb250ZW50KCBjcmFkbGVTdGF0ZSApXG5cbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgIT0gJ2ZpbmlzaHByZWxvYWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PSAnY3JhZGxlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncHJvY2Vzc2luZyBjcmFkbGUgY29udGVudDogY2FjaGUnLCBjYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdtYXRjaCBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlSGFuZGxlci5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncHJlcGFyZXJlbmRlcic6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSBjb250ZW50SGFuZGxlci5jb250ZW50XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnbm9ybWFsaXplc2lnbmFscycpIFxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsaXplc2lnbmFscyc6IHsgLy8gbm9ybWFsaXplIG9yIHJlc3VtZSBjeWNsaW5nXG5cbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnJlc3RvcmVJbnRlcnJ1cHRzKClcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVhayBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1c2VyIHJlcXVlc3RcbiAgICAgICAgICAgIGNhc2UgJ2NsZWFyY2FjaGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5jbGVhckNyYWRsZSgpXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmluZyBvdXQgb2YgY2FjaGUgaW50byB2aXNpYmxlIERPTSB0cmVlIChjZWxsRnJhbWUpXG4gICAgICAgICAgICAvLyByZXNldHMgc2Nyb2xsUG9zIChzY3JvbGxMZWZ0L3Njcm9sbFRvcCkgdG8gbGFzdCBVSSB2YWx1ZVxuICAgICAgICAgICAgY2FzZSAncGFyZW50aW5ndHJhbnNpdGlvbic6IHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gc2NhZmZvbGRIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbiBzdGF0ZSBtYWNoaW5lIHBhcmVudGluZ3RyYW5zaXRpb24nLCAnLScrc2Nyb2xsZXJJRCsnLScgLCBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgc2Nyb2xsIHBvc2l0aW9uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3NcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHBhcmVudGluZycpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbY3JhZGxlU3RhdGVdKVxuXG4gICAgLy8gc3RhbmRhcmQgcmVuZGVyaW5nIHN0YXRlcyAoMyBzdGF0ZXMpXG4gICAgdXNlRWZmZWN0KCgpPT4geyBcblxuICAgICAgICBzd2l0Y2ggKGNyYWRsZVN0YXRlKSB7XG5cbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmdSZW5kZXIgYW5kIHJlcG9zaXRpb25pbmdDb250aW51YXRpb24gYXJlIHRvZ2dsZWQgdG8gZ2VuZXJhdGUgY29udGludW91cyBcbiAgICAgICAgICAgIC8vIHJlcG9zaXRpb25pbmcgcmVuZGVyc1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6IC8vIHNldCBmcm9tIG9uU2Nyb2xsXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdSZW5kZXInKVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgJ3JlYWR5JzogLy8gbm8gb3BcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZVN0YXRlXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBSRU5ERVIgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgY29uc3Qgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4ID0gc2NhZmZvbGRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcbiAgICBjb25zdCBzY3JvbGxUcmFja2VyQXJncyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXVzZVNjcm9sbFRyYWNrZXIpIHJldHVybiBudWxsXG4gICAgICAgIGlmICghKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJyB8fCBjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ1JlbmRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrZXJhcmdzID0ge1xuICAgICAgICAgICAgdG9wOnZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyAzLFxuICAgICAgICAgICAgbGVmdDp2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIDMsXG4gICAgICAgICAgICBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2tlcmFyZ3NcbiAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgICBjcmFkbGVTdGF0ZSwgXG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnMsIFxuICAgICAgICAgICAgc2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgIGNvbnN0IGNvbnRleHR2YWx1ZVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmLCBcbiAgICAgICAgY2FjaGVIYW5kbGVyLCBcbiAgICAgICAgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSxcbiAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjazpzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MuaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgfSlcblxuICAgIHJldHVybiA8Q3JhZGxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZSA9IHtjb250ZXh0dmFsdWVSZWYuY3VycmVudH0+XG5cbiAgICAgICAgeygoKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgfHwgXG4gICAgICAgICAgICAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSkpP1xuICAgICAgICAgICAgdXNlU2Nyb2xsVHJhY2tlcj88U2Nyb2xsVHJhY2tlciBcbiAgICAgICAgICAgICAgICB0b3AgPSB7c2Nyb2xsVHJhY2tlckFyZ3MudG9wfSBcbiAgICAgICAgICAgICAgICBsZWZ0ID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxlZnR9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHtzY3JvbGxUcmFja2VyQXJncy5zY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXh9IFxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHtzY3JvbGxUcmFja2VyQXJncy5zdHlsZXN9XG4gICAgICAgICAgICAvPjpudWxsOlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWF4aXMnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlQXhpc1N0eWxlfSBcbiAgICAgICAgICAgICAgICByZWYgPSB7YXhpc0NyYWRsZUVsZW1lbnRSZWZ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAndHJpZ2dlcmxpbmUtaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7dHJpZ2dlcmxpbmVIZWFkU3R5bGV9XG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHtoZWFkVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd0cmlnZ2VybGluZS1heGlzJ1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHt0cmlnZ2VybGluZUF4aXNTdHlsZX1cbiAgICAgICAgICAgICAgICAgICAgcmVmID0ge2F4aXNUcmlnZ2VybGluZUNyYWRsZUVsZW1lbnRSZWZ9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RyaWdnZXJsaW5lLXRhaWwnXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJsaW5lVGFpbFN0eWxlfVxuICAgICAgICAgICAgICAgICAgICByZWYgPSB7dGFpbFRyaWdnZXJsaW5lQ3JhZGxlRWxlbWVudFJlZn1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICB7c2hvd0F4aXM/XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWRpdmlkZXInIFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlRGl2aWRlclN0eWxlfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0ge2hlYWRDcmFkbGVFbGVtZW50UmVmfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlSGVhZFN0eWxlfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHt0YWlsQ3JhZGxlRWxlbWVudFJlZn0gXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge2NyYWRsZVRhaWxTdHlsZX1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsoY3JhZGxlU3RhdGUgIT0gJ3NldHVwJyk/XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIH1cblxuICAgIDwvQ3JhZGxlQ29udGV4dC5Qcm92aWRlcj5cblxufSAvLyBDcmFkbGVcblxuLy8gdXRpbGl0eVxuXG5jb25zdCBnZXRDcmFkbGVIYW5kbGVycyA9IChjcmFkbGVQYXJhbWV0ZXJzKSA9PiB7XG5cbiAgICBjb25zdCBjcmVhdGVIYW5kbGVyID0gaGFuZGxlciA9PiBuZXcgaGFuZGxlcihjcmFkbGVQYXJhbWV0ZXJzKVxuXG4gICAgY29uc3QgeyBjYWNoZUhhbmRsZXIgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlcjpjcmVhdGVIYW5kbGVyKEludGVycnVwdEhhbmRsZXIpLFxuICAgICAgICBzY3JvbGxIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoU2Nyb2xsSGFuZGxlciksXG4gICAgICAgIHN0YXRlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0YXRlSGFuZGxlciksXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyOmNyZWF0ZUhhbmRsZXIoQ29udGVudEhhbmRsZXIpLFxuICAgICAgICBzY2FmZm9sZEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTY2FmZm9sZEhhbmRsZXIpLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNlcnZpY2VIYW5kbGVyKSxcbiAgICAgICAgc3R5bGVzSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0eWxlc0hhbmRsZXIpLFxuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENyYWRsZSJdLCJuYW1lcyI6WyJleHBvcnRzIiwicmVhY3RfMSIsImNyZWF0ZUNvbnRleHQiLCJDcmFkbGUiLCJncmlkU3BlY3MiLCJydW53YXlTaXplIiwibGlzdHNpemUiLCJzdGFydGluZ0luZGV4IiwiZ2V0SXRlbSIsInBsYWNlaG9sZGVyIiwidXNlckNhbGxiYWNrcyIsInN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiY2FjaGUiLCJjYWNoZU1heCIsInNjcm9sbGVySUQiLCJjYWNoZUhhbmRsZXIiLCJ1c2VTY3JvbGxUcmFja2VyIiwic2hvd0F4aXMiLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0Iiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsInZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJ2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYiLCJjdXJyZW50Iiwidmlld3BvcnREaW1lbnNpb25zIiwidmlld3BvcnRoZWlnaHQiLCJoZWlnaHQiLCJ2aWV3cG9ydHdpZHRoIiwid2lkdGgiLCJjcmFkbGVTdGF0ZSIsInNldENyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc01vdW50ZWRSZWYiLCJpc0NhY2hlZFJlZiIsIndhc0NhY2hlZFJlZiIsInBhcmVudGluZ1RyYW5zaXRpb25SZXF1aXJlZFJlZiIsImhhc0JlZW5SZW5kZXJlZFJlZiIsImhlYWRDcmFkbGVFbGVtZW50UmVmIiwidGFpbENyYWRsZUVsZW1lbnRSZWYiLCJheGlzQ3JhZGxlRWxlbWVudFJlZiIsImhlYWRUcmlnZ2VybGluZUNyYWRsZUVsZW1lbnRSZWYiLCJheGlzVHJpZ2dlcmxpbmVDcmFkbGVFbGVtZW50UmVmIiwidGFpbFRyaWdnZXJsaW5lQ3JhZGxlRWxlbWVudFJlZiIsImNyYWRsZUVsZW1lbnRzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJheGlzUmVmIiwiaGVhZFRyaWdnZXJsaW5lUmVmIiwiYXhpc1RyaWdnZXJsaW5lUmVmIiwidGFpbFRyaWdnZXJsaW5lUmVmIiwiY3Jvc3Njb3VudCIsInZpZXdwb3J0c2l6ZSIsImNyb3NzTGVuZ3RoIiwidmlld3BvcnRsZW5ndGhmb3JjYWxjIiwidGlsZWxlbmd0aGZvcmNhbGMiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJ2aWV3cG9ydExlbmd0aCIsInJvd0xlbmd0aCIsInZpZXdwb3J0Um93Y291bnQiLCJjZWlsIiwidmlld3BvcnRWaXNpYmxlUm93Y291bnQiLCJsaXN0Um93Y291bnQiLCJjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQiLCJjcmFkbGVSb3djb3VudCIsInJ1bndheVJvd2NvdW50IiwiZGlmZiIsIm1heCIsIml0ZW1jb3VudCIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uc0NhbGxiYWNrIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInNjcm9sbGVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiaGFuZGxlcnNSZWYiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlUGFyYW1ldGVyc1JlZiIsImdldENyYWRsZUhhbmRsZXJzIiwiaW50ZXJydXB0SGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiLCJjb250ZW50SGFuZGxlciIsInNjYWZmb2xkSGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwic3R5bGVzSGFuZGxlciIsImlzSW5Qb3J0YWwiLCJpc0NhY2hlQ2hhbmdlIiwiaXNDYWNoaW5nVW5kZXJ3YXkiLCJpc1JlcGFyZW50aW5nUmVmIiwiX2EiLCJpc1Jlc2l6aW5nIiwiX2IiLCJwYXVzZUludGVycnVwdHMiLCJudWxsSXRlbVNldE1heExpc3RzaXplIiwibWF4TGlzdHNpemUiLCJjYWxsYmFja3MiLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImNoYW5nZUxpc3RzaXplIiwiZ2V0RnVuY3Rpb25zIiwic2Nyb2xsVG9JdGVtIiwicmVsb2FkIiwic2V0TGlzdHNpemUiLCJjbGVhckNhY2hlIiwiZ2V0Q2FjaGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsImdldENyYWRsZUluZGV4TWFwIiwicmVtYXBJbmRleGVzIiwibW92ZUluZGV4IiwiaW5zZXJ0SW5kZXgiLCJyZW1vdmVJbmRleCIsImZ1bmN0aW9ucyIsInZpZXdwb3J0ZGF0YSIsImVsZW1lbnRSZWYiLCJhZGRFdmVudExpc3RlbmVyIiwib25TY3JvbGwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIiLCJjcmFkbGVJbnRlcnNlY3QiLCJjcmVhdGVPYnNlcnZlciIsImNvbm5lY3RFbGVtZW50cyIsInRyaWdnZXJvYnNlcnZlciIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsInJlc2l6ZW9ic2VydmVyIiwiY3JhZGxlUmVzaXplIiwiZGlzY29ubmVjdCIsIm1vZGVsSW5kZXhMaXN0IiwiZ2V0TW9kZWxJbmRleExpc3QiLCJwYXJlQ2FjaGVUb01heCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXRjaENhY2hlVG9DcmFkbGUiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1Njcm9sbFByb3BlcnR5IiwiYmxvY2tTY3JvbGxQb3MiLCJwcmV2aW91c0NlbGxQaXhlbExlbmd0aCIsInByZXZpb3VzQXhpc09mZnNldCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwicHJldmlvdXNyYXRpbyIsInBpdm90Q2VsbFBpeGVsTGVuZ3RoIiwicGl2b3RBeGlzT2Zmc2V0Iiwicm91bmQiLCJzZXRDcmFkbGVTdHlsZXMiLCJ1c2Vyc3R5bGVzIiwiY3JhZGxlSGVhZFN0eWxlIiwiY3JhZGxlVGFpbFN0eWxlIiwiY3JhZGxlQXhpc1N0eWxlIiwidHJpZ2dlcmxpbmVIZWFkU3R5bGUiLCJ0cmlnZ2VybGluZUF4aXNTdHlsZSIsInRyaWdnZXJsaW5lVGFpbFN0eWxlIiwiY3JhZGxlRGl2aWRlclN0eWxlIiwiY3JhZGxlQ29udGVudCIsImhlYWREaXNwbGF5Q29tcG9uZW50cyIsImhlYWRNb2RlbENvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwicG9ydGFsSG9sZExpc3QiLCJwb3J0YWxNYXAiLCJsZW5ndGgiLCJpdGVtSUQiLCJmaW5hbENhbGxiYWNrIiwicHJlbG9hZCIsInJlc3RvcmVJbnRlcnJ1cHRzIiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyZXBvc2l0aW9uaW5nUmVxdWlyZWQiLCJjb250ZW50Iiwic2V0Q3JhZGxlQ29udGVudCIsImNsZWFyQ3JhZGxlIiwidmlld3BvcnRFbGVtZW50Iiwic2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Iiwic2Nyb2xsVHJhY2tlckFyZ3MiLCJ0cmFja2VyYXJncyIsInRvcCIsImxlZnQiLCJjb250ZXh0dmFsdWVSZWYiLCJQcm92aWRlciIsInZhbHVlIiwiU2Nyb2xsVHJhY2tlcl8xIiwib2Zmc2V0Iiwic3R5bGUiLCJyZWYiLCJjcmVhdGVIYW5kbGVyIiwiaGFuZGxlciIsImludGVycnVwdGhhbmRsZXJfMSIsInNjcm9sbGhhbmRsZXJfMSIsInN0YXRlaGFuZGxlcl8xIiwiY29udGVudGhhbmRsZXJfMSIsInNjYWZmb2xkaGFuZGxlcl8xIiwic2VydmljZWhhbmRsZXJfMSIsInN0eWxlc2hhbmRsZXJfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n");

/***/ }),

/***/ "./src/Scrollblock.tsx":
/*!*****************************!*\
  !*** ./src/Scrollblock.tsx ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // scrollblock.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    \n    TODO update length for cradle adjustments based on variable length changes in cell frames.\n\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\");\n\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n      listsize = _ref.listsize,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID;\n  // console.log('==> RUNNING Scrollblock','-'+scrollerID+'-')\n  // console.log('performance.memory',performance['memory'])\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout; // -------------------------[ context and state ]-------------------------\n\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController();\n    return function () {\n      abortController.abort(); // defensive\n    };\n  }, []);\n  var viewportInterruptProperties = (0, react_1.useContext)(Viewport_1.ViewportInterrupt); // -----------------------------------[ data heap ]-------------------------\n\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null); // just for init\n\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign({\n      backgroundColor: 'white',\n      position: 'relative'\n    }, styles.cradle);\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n      _ref3 = _slicedToArray(_ref2, 2),\n      divlinerstyle = _ref3[0],\n      saveDivlinerstyle = _ref3[1]; // to trigger render\n\n\n  var _viewportInterruptPro = viewportInterruptProperties.viewportDimensions,\n      width = _viewportInterruptPro.width,\n      height = _viewportInterruptPro.height; // reconfigure\n\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'scrollblock',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\n// all the parameters can affect the length\n\n\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n      viewportheight = _ref4.viewportheight,\n      viewportwidth = _ref4.viewportwidth,\n      listsize = _ref4.listsize,\n      cellHeight = _ref4.cellHeight,\n      cellWidth = _ref4.cellWidth,\n      gap = _ref4.gap,\n      padding = _ref4.padding;\n  // dependents of orientation\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == 'vertical') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // 'horizontal'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap;\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  var listlength = Math.ceil(listsize / crosscount);\n  var straightlength = listlength * cellLength - (listlength > 0 ? gap : 0) + padding * 2;\n  return straightlength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current);\n  var height;\n  var width;\n\n  if (orientation == 'horizontal') {\n    height = '100%';\n    width = baseScrollblocklengthRef.current + 'px';\n  } else if (orientation == 'vertical') {\n    height = baseScrollblocklengthRef.current + 'px';\n    width = '100%';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};\n\nexports[\"default\"] = Scrollblock;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN6RSxJQUFJRyxVQUFVLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXSCxtQkFBbUIsR0FBQ0YsV0FBL0IsQ0FBakI7RUFFQSxJQUFJTSxVQUFVLEdBQUdGLElBQUksQ0FBQ0csSUFBTCxDQUFVN0MsUUFBUSxHQUFDeUMsVUFBbkIsQ0FBakI7RUFFQSxJQUFJSyxjQUFjLEdBQUlGLFVBQVUsR0FBR0wsVUFBZCxJQUNmSyxVQUFVLEdBQUcsQ0FBZCxHQUNHdkMsR0FESCxHQUVHLENBSGEsSUFJZEMsT0FBTyxHQUFHLENBSmpCO0VBTUEsT0FBT3dDLGNBQVA7QUFFSCxDQTdDRDs7QUErQ0EsSUFBTWQsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQixDQUFDNUIsV0FBRCxFQUFhMkMsU0FBYixFQUF1QkMsd0JBQXZCLEVBQW1EO0VBRS9FLElBQUlDLFdBQVcsR0FBR2hDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBaUI2QixTQUFTLENBQUN4QixPQUEzQixDQUFsQjtFQUNBLElBQUlLLE1BQUo7RUFDQSxJQUFJRCxLQUFKOztFQUNBLElBQUl2QixXQUFXLElBQUksWUFBbkIsRUFBaUM7SUFDN0J3QixNQUFNLEdBQUcsTUFBVDtJQUNBRCxLQUFLLEdBQUdxQix3QkFBd0IsQ0FBQ3pCLE9BQXpCLEdBQW1DLElBQTNDO0VBQ0gsQ0FIRCxNQUdPLElBQUluQixXQUFXLElBQUksVUFBbkIsRUFBK0I7SUFDbEN3QixNQUFNLEdBQUdvQix3QkFBd0IsQ0FBQ3pCLE9BQXpCLEdBQW1DLElBQTVDO0lBQ0FJLEtBQUssR0FBRyxNQUFSO0VBQ0g7O0VBQ0RzQixXQUFXLENBQUNyQixNQUFaLEdBQXFCQSxNQUFyQjtFQUNBcUIsV0FBVyxDQUFDdEIsS0FBWixHQUFvQkEsS0FBcEI7RUFFQSxPQUFPc0IsV0FBUDtBQUNILENBaEJEOztBQWtCQUMsa0JBQUFBLEdBQWVwRCxXQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9TY3JvbGxibG9jay50c3g/M2I2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY3JvbGxibG9jay50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgXG4gICAgVE9ETyB1cGRhdGUgbGVuZ3RoIGZvciBjcmFkbGUgYWRqdXN0bWVudHMgYmFzZWQgb24gdmFyaWFibGUgbGVuZ3RoIGNoYW5nZXMgaW4gY2VsbCBmcmFtZXMuXG5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtb30gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0SW50ZXJydXB0IH0gZnJvbSAnLi9WaWV3cG9ydCdcblxuY29uc3QgU2Nyb2xsYmxvY2sgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIGxpc3RzaXplLFxuICAgIGdyaWRTcGVjcywgXG4gICAgc3R5bGVzLFxuICAgIHNjcm9sbGVySUQsXG59KSA9PiB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnPT0+IFJVTk5JTkcgU2Nyb2xsYmxvY2snLCctJytzY3JvbGxlcklEKyctJylcbiAgICAvLyBjb25zb2xlLmxvZygncGVyZm9ybWFuY2UubWVtb3J5JyxwZXJmb3JtYW5jZVsnbWVtb3J5J10pXG5cbiAgICBjb25zdCB7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCkgLy8gZGVmZW5zaXZlXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0SW50ZXJydXB0KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGRhdGEgaGVhcCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBqdXN0IGZvciBpbml0XG4gICAgY29uc3QgbGluZXJTdHlsZSA9IHVzZU1lbW8oKCkgPT57XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgICAgIFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsIHN0eWxlcy5jcmFkbGUpXG5cblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgZGl2bGluZXJzdHlsZVJlZiA9IHVzZVJlZihsaW5lclN0eWxlKVxuXG4gICAgY29uc3QgW2RpdmxpbmVyc3R5bGUsc2F2ZURpdmxpbmVyc3R5bGVdID0gdXNlU3RhdGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KSAvLyB0byB0cmlnZ2VyIHJlbmRlclxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zXG4gICAgXG4gICAgLy8gcmVjb25maWd1cmVcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHVwZGF0ZUJhc2VCbG9ja0xlbmd0aChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydHdpZHRoOndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGRpdmxpbmVyc3R5bGVSZWYsXG4gICAgICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmXG4gICAgICAgICAgICApXG4gICAgICAgIHNhdmVEaXZsaW5lcnN0eWxlKGRpdmxpbmVyc3R5bGVSZWYuY3VycmVudClcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIF0pXG5cbiAgICBjb25zdCB1cGRhdGVCYXNlQmxvY2tMZW5ndGggPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGxheW91dHNwZWNzKSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzY3JvbGxibG9ja2xlbmd0aCA9IGNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgobGF5b3V0c3BlY3MpXG5cbiAgICAgICAgICAgIGJhc2VTY3JvbGxCbG9ja0xlbmd0aFJlZi5jdXJyZW50ID0gYmFzZXNjcm9sbGJsb2NrbGVuZ3RoXG5cbiAgICAgICAgfSxbXVxuICAgIClcblxuICAgIHJldHVybiA8ZGl2IGRhdGEtdHlwZSA9ICdzY3JvbGxibG9jaycgc3R5bGU9e2RpdmxpbmVyc3R5bGVSZWYuY3VycmVudH0+e2NoaWxkcmVufTwvZGl2PlxuXG59IC8vIFNjcm9sbGJsb2NrXG5cbi8vIGFsbCB0aGUgcGFyYW1ldGVycyBjYW4gYWZmZWN0IHRoZSBsZW5ndGhcbmNvbnN0IGNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGggPSAoe1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICB9KSA9PiB7XG5cbiAgICAvLyBkZXBlbmRlbnRzIG9mIG9yaWVudGF0aW9uXG4gICAgbGV0IGNyb3NzbGVuZ3RoXG4gICAgbGV0IGNlbGxMZW5ndGhcbiAgICBsZXQgdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgY3Jvc3NsZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgdmlld3BvcnRjcm9zc2xlbmd0aCA9IHZpZXdwb3J0d2lkdGggXG5cbiAgICB9IGVsc2UgeyAvLyAnaG9yaXpvbnRhbCdcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcblxuICAgIH1cbiAgICAvLyBhZGp1c3RtZW50cyB0byB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCAtPSAocGFkZGluZyAqIDIpXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCArPSBnYXBcblxuICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoIDwgY3Jvc3NsZW5ndGgpIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBjcm9zc2xlbmd0aCAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZVxuICAgIGxldCBjcm9zc2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydGNyb3NzbGVuZ3RoL2Nyb3NzbGVuZ3RoKVxuXG4gICAgbGV0IGxpc3RsZW5ndGggPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIGxldCBzdHJhaWdodGxlbmd0aCA9IChsaXN0bGVuZ3RoICogY2VsbExlbmd0aCkgLSBcbiAgICAgICAgKChsaXN0bGVuZ3RoID4gMCk/XG4gICAgICAgICAgICBnYXA6XG4gICAgICAgICAgICAwKSBcbiAgICAgICAgKyAocGFkZGluZyAqIDIpXG5cbiAgICByZXR1cm4gc3RyYWlnaHRsZW5ndGhcblxufVxuXG5jb25zdCB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyA9IChvcmllbnRhdGlvbixzdHlsZXNSZWYsYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmKSA9PiB7XG5cbiAgICBsZXQgbG9jYWxzdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LHN0eWxlc1JlZi5jdXJyZW50KSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgbGV0IGhlaWdodCBcbiAgICBsZXQgd2lkdGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBoZWlnaHQgPSBiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbGJsb2NrXG4iXSwibmFtZXMiOlsiU2Nyb2xsYmxvY2siLCJjaGlsZHJlbiIsImxpc3RzaXplIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJsYXlvdXQiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydCIsInZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyIsIlZpZXdwb3J0XzEiLCJiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYiLCJsaW5lclN0eWxlIiwiT2JqZWN0IiwiYXNzaWduIiwiYmFja2dyb3VuZENvbG9yIiwicG9zaXRpb24iLCJjcmFkbGUiLCJkaXZsaW5lcnN0eWxlUmVmIiwiY3VycmVudCIsImRpdmxpbmVyc3R5bGUiLCJzYXZlRGl2bGluZXJzdHlsZSIsInZpZXdwb3J0RGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwidXBkYXRlQmFzZUJsb2NrTGVuZ3RoIiwidmlld3BvcnRoZWlnaHQiLCJ2aWV3cG9ydHdpZHRoIiwidXBkYXRlU2Nyb2xsYmxvY2tTdHlsZXMiLCJsYXlvdXRzcGVjcyIsImJhc2VzY3JvbGxibG9ja2xlbmd0aCIsImNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgiLCJyZWFjdF8xIiwic3R5bGUiLCJjcm9zc2xlbmd0aCIsImNlbGxMZW5ndGgiLCJ2aWV3cG9ydGNyb3NzbGVuZ3RoIiwiY3Jvc3Njb3VudCIsIk1hdGgiLCJmbG9vciIsImxpc3RsZW5ndGgiLCJjZWlsIiwic3RyYWlnaHRsZW5ndGgiLCJzdHlsZXNSZWYiLCJiYXNlU2Nyb2xsYmxvY2tsZW5ndGhSZWYiLCJsb2NhbHN0eWxlcyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n");

/***/ }),

/***/ "./src/Viewport.tsx":
/*!**************************!*\
  !*** ./src/Viewport.tsx ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // viewport.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ViewportInterrupt = void 0;\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible screen portal of the list being shown\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nexports.ViewportInterrupt = react_1[\"default\"].createContext(null); // for children\n\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ \"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n\nvar ResizeObserver = window['ResizeObserver'] || resize_observer_1.ResizeObserver;\n\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n      gridSpecs = _ref.gridSpecs,\n      styles = _ref.styles,\n      scrollerID = _ref.scrollerID,\n      scrollerProperties = _ref.scrollerProperties,\n      VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation,\n      gap = gridSpecs.gap,\n      padding = gridSpecs.padding,\n      cellHeight = gridSpecs.cellHeight,\n      cellWidth = gridSpecs.cellWidth,\n      layout = gridSpecs.layout;\n\n  var _ref2 = (0, react_1.useState)('setup'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      viewportState = _ref3[0],\n      setViewportState = _ref3[1]; // setup, resizing, resized, ready\n  // console.log('==> RUNNING Viewport','-'+scrollerID+'-', viewportState)\n  // console.log('performance.memory',performance['memory'])\n\n\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true); // monitor for unmounted\n\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController(); // unmount\n\n    return function () {\n      isMountedRef.current = false;\n      abortController.abort(); // defensive\n    };\n  }, []);\n  var viewportElementRef = (0, react_1.useRef)(null); // viewportInterruptPropertiesRef is passed as a resizing interrupt (through context) to children\n  // initialize\n\n  var viewportInterruptPropertiesRef = (0, react_1.useRef)({\n    isReparentingRef: scrollerProperties === null || scrollerProperties === void 0 ? void 0 : scrollerProperties.isReparentingRef,\n    isResizing: false,\n    // index:null,\n    viewportDimensions: null,\n    elementRef: null\n  }); // --------------------[ resizer setup ]-----------------------\n\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null); // set up resizeObserver\n\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current); // unmount\n\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []); // used by resizeObserver; generates interrupt\n\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (!isMountedRef.current || !viewportElementRef.current) return;\n    if (viewportStateRef.current == 'setup') return;\n    var target = entries[0].target;\n\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = 'true'; // embedded lists need resizing event for init with up to date viewport dimensions\n\n      if (!scrollerProperties) {\n        return;\n      }\n    } // generate interrupt response, if initiating resize\n\n\n    if (!isResizingRef.current) {\n      viewportInterruptPropertiesRef.current.isResizing = isResizingRef.current = true; // new object creation triggers a realtime interrupt message to cradle through context\n\n      viewportInterruptPropertiesRef.current = Object.assign({}, viewportInterruptPropertiesRef.current);\n      if (isMountedRef.current) setViewportState('resizing');\n    }\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n\n      if (isMountedRef.current) {\n        setViewportState('resized');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []); // ----------------------------------[ calculate config values ]--------------------------------\n\n  var divlinerstyleRef = (0, react_1.useRef)(null); // initialize with inherited styles\n\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign({\n      position: 'absolute',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      overflow: 'auto',\n      backgroundColor: 'red'\n    }, styles.viewport);\n  }, [styles.viewport]); // update with config values\n\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    // TODO: gap\n    var mincrosslength = calcMinViewportCrossLength(orientation, cellWidth, cellHeight, gap, padding);\n    var styles = Object.assign({}, divlinerstyleRef.current); // avoid readonly\n\n    if (orientation == 'vertical') {\n      styles.minWidth = mincrosslength + 'px';\n      styles.minHeight = 'auto';\n    } else {\n      styles.minWidth = 'auto';\n      styles.minHeight = mincrosslength + 'px';\n    }\n\n    return styles;\n  }, [orientation, cellWidth, cellHeight, gap, padding]); // update viewportInterruptPropertiesRef; add viewport dimensions\n\n  viewportInterruptPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == 'setup') return viewportInterruptPropertiesRef.current;\n\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n        top = _viewportElementRef$c.top,\n        right = _viewportElementRef$c.right,\n        bottom = _viewportElementRef$c.bottom,\n        left = _viewportElementRef$c.left;\n\n    var width = right - left;\n    var height = bottom - top; // TODO this is a duplicate setting procedure with interrupthandler.tsx cradleIntersectionObserverCallback\n\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    }; // console.log('viewport new localViewportData', '-'+scrollerID+'-',localViewportData)\n    // trigger context change with new object\n\n    var viewportdataobject = Object.assign({}, viewportInterruptPropertiesRef.current, localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]); // --------------------[ state processing ]---------------------------\n\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case 'resized':\n      case 'setup':\n        {\n          setViewportState('ready');\n          break;\n        }\n    }\n  }, [viewportState]); // ----------------------[ render ]--------------------------------\n\n  return react_1[\"default\"].createElement(exports.ViewportInterrupt.Provider, {\n    value: viewportInterruptPropertiesRef.current\n  }, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'viewport',\n    \"data-scrollerid\": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != 'setup' && children));\n}; // Viewport\n// establish minimum width/height for the viewport -- approximately one item\n// gap only applies with multi-width items, therefore not used in calculations\n\n\nvar calcMinViewportCrossLength = function calcMinViewportCrossLength(orientation, cellWidth, cellHeight, gap, padding) {\n  var crosslength, cellLength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellWidth;\n  } else {\n    cellLength = cellHeight;\n  }\n\n  crosslength = cellLength + padding * 2;\n  return crosslength;\n};\n\nexports[\"default\"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dEJ1QyxDQUF6QyxDQTNKQyxDQW1MRDs7RUFFQSw2QkFBZ0IsWUFBSTtJQUNoQixRQUFRQSxhQUFSO01BRUksS0FBSyxTQUFMO01BQ0EsS0FBSyxPQUFMO1FBQWM7VUFDVkMsZ0JBQWdCLENBQUMsT0FBRCxDQUFoQjtVQUNBO1FBQ0g7SUFOTDtFQVNILENBVkQsRUFVRSxDQUFDRCxhQUFELENBVkYsRUFyTEMsQ0FpTUQ7O0VBRUEsT0FBT2xCLGlDQUFDRCwwQkFBa0JpRSxRQUFuQixFQUEyQjtJQUFDQyxLQUFLLEVBQUt0Qyw4QkFBOEIsQ0FBQ047RUFBMUMsQ0FBM0IsRUFDSHJCO0lBQUEsYUFDZ0IsVUFEaEI7SUFDMEIsbUJBQ0hTLFVBRnZCO0lBR0l5RCxLQUFLLEVBQUlwQixnQkFBZ0IsQ0FBQ3pCLE9BSDlCO0lBSUk4QyxHQUFHLEVBQUl6QztFQUpYLEdBTU9SLGFBQWEsSUFBSSxPQUFsQixJQUE4QlosUUFOcEMsQ0FERyxDQUFQO0FBV0gsQ0FyTkQsQyxDQXFORTtBQUVGO0FBQ0E7OztBQUNBLElBQU1rRCwwQkFBMEIsR0FBRyxTQUE3QkEsMEJBQTZCLENBQUM1QyxXQUFELEVBQWNJLFNBQWQsRUFBeUJELFVBQXpCLEVBQXFDRixHQUFyQyxFQUEwQ0MsT0FBMUMsRUFBcUQ7RUFFcEYsSUFBSXNELFdBQUosRUFBaUJDLFVBQWpCOztFQUVBLElBQUl6RCxXQUFXLElBQUksVUFBbkIsRUFBK0I7SUFDM0J5RCxVQUFVLEdBQUdyRCxTQUFiO0VBQ0gsQ0FGRCxNQUVPO0lBQ0hxRCxVQUFVLEdBQUd0RCxVQUFiO0VBQ0g7O0VBQ0RxRCxXQUFXLEdBQUdDLFVBQVUsR0FBSXZELE9BQU8sR0FBRyxDQUF0QztFQUVBLE9BQU9zRCxXQUFQO0FBRUgsQ0FiRDs7QUFlQXJFLGtCQUFBQSxHQUFlTSxRQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9WaWV3cG9ydC50c3g/YzgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3cG9ydC50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIyIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2Ygdmlld3BvcnQgaXMgdG8gcHJvdmlkZSBkYXRhIHRvIGl0cyBjaGlsZHJlbiAoc2Nyb2xsYmxvY2sgYW5kIGNyYWRsZSksXG4gICAgYW5kIGFjdCBhcyB0aGUgdmlzaWJsZSBzY3JlZW4gcG9ydGFsIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHR9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgVmlld3BvcnRJbnRlcnJ1cHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpIC8vIGZvciBjaGlsZHJlblxuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciBhcyBSZXNpemVPYnNlcnZlclBvbGx5ZmlsbCB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJ1xuXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHdpbmRvd1snUmVzaXplT2JzZXJ2ZXInXSB8fCBSZXNpemVPYnNlcnZlclBvbGx5ZmlsbFxuXG5jb25zdCBWaWV3cG9ydCA9ICh7XG4gICAgY2hpbGRyZW4sIFxuICAgIGdyaWRTcGVjcyxcbiAgICBzdHlsZXMsXG4gICAgc2Nyb2xsZXJJRCxcbiAgICBzY3JvbGxlclByb3BlcnRpZXMsXG4gICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH0gPSBncmlkU3BlY3NcblxuICAgIGNvbnN0IFt2aWV3cG9ydFN0YXRlLHNldFZpZXdwb3J0U3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJykgLy8gc2V0dXAsIHJlc2l6aW5nLCByZXNpemVkLCByZWFkeVxuXG4gICAgLy8gY29uc29sZS5sb2coJz09PiBSVU5OSU5HIFZpZXdwb3J0JywnLScrc2Nyb2xsZXJJRCsnLScsIHZpZXdwb3J0U3RhdGUpXG4gICAgLy8gY29uc29sZS5sb2coJ3BlcmZvcm1hbmNlLm1lbW9yeScscGVyZm9ybWFuY2VbJ21lbW9yeSddKVxuXG4gICAgY29uc3Qgdmlld3BvcnRTdGF0ZVJlZiA9IHVzZVJlZihudWxsKSAvLyBmb3IgdXNlQ2FsbGJhY2sgLT4gcmVzaXplQ2FsbGJhY2sgc2NvcGVcbiAgICB2aWV3cG9ydFN0YXRlUmVmLmN1cnJlbnQgPSB2aWV3cG9ydFN0YXRlXG5cbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSkgLy8gbW9uaXRvciBmb3IgdW5tb3VudGVkXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgICAvLyB1bm1vdW50XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpICAvLyBkZWZlbnNpdmVcbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmIGlzIHBhc3NlZCBhcyBhIHJlc2l6aW5nIGludGVycnVwdCAodGhyb3VnaCBjb250ZXh0KSB0byBjaGlsZHJlblxuICAgIC8vIGluaXRpYWxpemVcbiAgICBjb25zdCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzUmVwYXJlbnRpbmdSZWY6c2Nyb2xsZXJQcm9wZXJ0aWVzPy5pc1JlcGFyZW50aW5nUmVmLCBcbiAgICAgICAgICAgIGlzUmVzaXppbmc6ZmFsc2UsIFxuICAgICAgICAgICAgLy8gaW5kZXg6bnVsbCxcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9uczpudWxsLFxuICAgICAgICAgICAgZWxlbWVudFJlZjpudWxsXG4gICAgICAgIH1cbiAgICApXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVzaXplciBzZXR1cCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHJlc2l6ZVRpbWVyaWRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBpc1Jlc2l6aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gICAgLy8gc2V0IHVwIHJlc2l6ZU9ic2VydmVyXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUNhbGxiYWNrKVxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICAvLyB1c2VkIGJ5IHJlc2l6ZU9ic2VydmVyOyBnZW5lcmF0ZXMgaW50ZXJydXB0XG4gICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygoZW50cmllcyk9PntcblxuICAgICAgICBpZiAoKCFpc01vdW50ZWRSZWYuY3VycmVudCkgfHwgKCF2aWV3cG9ydEVsZW1lbnRSZWYuY3VycmVudCkpIHJldHVyblxuXG4gICAgICAgIGlmICh2aWV3cG9ydFN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZW50cmllc1swXS50YXJnZXRcblxuICAgICAgICBpZiAoIXRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkKSB7XG5cbiAgICAgICAgICAgIHRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkID0gJ3RydWUnXG5cbiAgICAgICAgICAgIC8vIGVtYmVkZGVkIGxpc3RzIG5lZWQgcmVzaXppbmcgZXZlbnQgZm9yIGluaXQgd2l0aCB1cCB0byBkYXRlIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGlmICghc2Nyb2xsZXJQcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdlbmVyYXRlIGludGVycnVwdCByZXNwb25zZSwgaWYgaW5pdGlhdGluZyByZXNpemVcbiAgICAgICAgaWYgKCFpc1Jlc2l6aW5nUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZyA9IGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWUgXG4gICAgICAgICAgICAvLyBuZXcgb2JqZWN0IGNyZWF0aW9uIHRyaWdnZXJzIGEgcmVhbHRpbWUgaW50ZXJydXB0IG1lc3NhZ2UgdG8gY3JhZGxlIHRocm91Z2ggY29udGV4dFxuICAgICAgICAgICAgdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZi5jdXJyZW50KSBcblxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRWaWV3cG9ydFN0YXRlKCdyZXNpemluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQpXG4gICAgICAgIHJlc2l6ZVRpbWVyaWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRTdGF0ZSgncmVzaXplZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxWSUVXUE9SVF9SRVNJWkVfVElNRU9VVClcblxuICAgIH0sW10pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgY29uZmlnIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGluaXRpYWxpemUgd2l0aCBpbmhlcml0ZWQgc3R5bGVzXG4gICAgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6MCxcbiAgICAgICAgICAgIHJpZ2h0OjAsXG4gICAgICAgICAgICBib3R0b206MCxcbiAgICAgICAgICAgIGxlZnQ6MCxcbiAgICAgICAgICAgIG92ZXJmbG93OidhdXRvJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoncmVkJyxcbiAgICAgICAgfSwgc3R5bGVzLnZpZXdwb3J0KVxuXG4gICAgfSxbc3R5bGVzLnZpZXdwb3J0XSlcblxuICAgIC8vIHVwZGF0ZSB3aXRoIGNvbmZpZyB2YWx1ZXNcbiAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICAvLyBUT0RPOiBnYXBcbiAgICAgICAgbGV0IG1pbmNyb3NzbGVuZ3RoID0gY2FsY01pblZpZXdwb3J0Q3Jvc3NMZW5ndGgob3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgZ2FwLCBwYWRkaW5nKVxuICAgICAgICBsZXQgc3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSxkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpIC8vIGF2b2lkIHJlYWRvbmx5XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHN0eWxlcy5taW5XaWR0aCA9IG1pbmNyb3NzbGVuZ3RoICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9ICdhdXRvJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLm1pbldpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBzdHlsZXMubWluSGVpZ2h0ID0gbWluY3Jvc3NsZW5ndGggKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVzXG5cbiAgICB9LFtvcmllbnRhdGlvbiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBnYXAsIHBhZGRpbmddKVxuXG4gICAgLy8gdXBkYXRlIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZjsgYWRkIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGlmICh2aWV3cG9ydFN0YXRlID09ICdzZXR1cCcpIHJldHVybiB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gdmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgY29uc3Qgd2lkdGggPSAocmlnaHQgLSBsZWZ0KVxuICAgICAgICBjb25zdCBoZWlnaHQgPSAoYm90dG9tIC0gdG9wKVxuXG4gICAgICAgIC8vIFRPRE8gdGhpcyBpcyBhIGR1cGxpY2F0ZSBzZXR0aW5nIHByb2NlZHVyZSB3aXRoIGludGVycnVwdGhhbmRsZXIudHN4IGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2tcbiAgICAgICAgY29uc3QgbG9jYWxWaWV3cG9ydERhdGEgPSB7XG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6e3RvcCxyaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6dmlld3BvcnRFbGVtZW50UmVmLFxuICAgICAgICAgICAgaXNSZXNpemluZzppc1Jlc2l6aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndmlld3BvcnQgbmV3IGxvY2FsVmlld3BvcnREYXRhJywgJy0nK3Njcm9sbGVySUQrJy0nLGxvY2FsVmlld3BvcnREYXRhKVxuXG4gICAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBjaGFuZ2Ugd2l0aCBuZXcgb2JqZWN0XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ZGF0YW9iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsIGxvY2FsVmlld3BvcnREYXRhKSBcblxuICAgICAgICByZXR1cm4gIHZpZXdwb3J0ZGF0YW9iamVjdFxuXG4gICAgfSxbb3JpZW50YXRpb24sIGlzUmVzaXppbmdSZWYuY3VycmVudCwgdmlld3BvcnRTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgc3RhdGUgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHN3aXRjaCAodmlld3BvcnRTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZXNpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzoge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LFt2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiA8Vmlld3BvcnRJbnRlcnJ1cHQuUHJvdmlkZXIgdmFsdWUgPSB7IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZi5jdXJyZW50IH0+XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICBkYXRhLXR5cGUgPSAndmlld3BvcnQnXG4gICAgICAgICAgICBkYXRhLXNjcm9sbGVyaWQgPSB7c2Nyb2xsZXJJRH1cbiAgICAgICAgICAgIHN0eWxlID0ge2RpdmxpbmVyc3R5bGVSZWYuY3VycmVudH1cbiAgICAgICAgICAgIHJlZiA9IHt2aWV3cG9ydEVsZW1lbnRSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsgKHZpZXdwb3J0U3RhdGUgIT0gJ3NldHVwJykgJiYgY2hpbGRyZW4gfVxuICAgICAgICA8L2Rpdj5cbiAgICA8L1ZpZXdwb3J0SW50ZXJydXB0LlByb3ZpZGVyPlxuICAgIFxufSAvLyBWaWV3cG9ydFxuXG4vLyBlc3RhYmxpc2ggbWluaW11bSB3aWR0aC9oZWlnaHQgZm9yIHRoZSB2aWV3cG9ydCAtLSBhcHByb3hpbWF0ZWx5IG9uZSBpdGVtXG4vLyBnYXAgb25seSBhcHBsaWVzIHdpdGggbXVsdGktd2lkdGggaXRlbXMsIHRoZXJlZm9yZSBub3QgdXNlZCBpbiBjYWxjdWxhdGlvbnNcbmNvbnN0IGNhbGNNaW5WaWV3cG9ydENyb3NzTGVuZ3RoID0gKG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGdhcCwgcGFkZGluZykgPT4ge1xuXG4gICAgbGV0IGNyb3NzbGVuZ3RoLCBjZWxsTGVuZ3RoXG4gICAgXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aCBcbiAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodFxuICAgIH1cbiAgICBjcm9zc2xlbmd0aCA9IGNlbGxMZW5ndGggKyAocGFkZGluZyAqIDIpXG5cbiAgICByZXR1cm4gY3Jvc3NsZW5ndGhcblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydFxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJyZWFjdF8xIiwiY3JlYXRlQ29udGV4dCIsIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwicmVzaXplX29ic2VydmVyXzEiLCJWaWV3cG9ydCIsImNoaWxkcmVuIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsInNjcm9sbGVyUHJvcGVydGllcyIsIlZJRVdQT1JUX1JFU0laRV9USU1FT1VUIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsInZpZXdwb3J0U3RhdGUiLCJzZXRWaWV3cG9ydFN0YXRlIiwidmlld3BvcnRTdGF0ZVJlZiIsImN1cnJlbnQiLCJpc01vdW50ZWRSZWYiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydCIsInZpZXdwb3J0RWxlbWVudFJlZiIsInZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZiIsImlzUmVwYXJlbnRpbmdSZWYiLCJpc1Jlc2l6aW5nIiwidmlld3BvcnREaW1lbnNpb25zIiwiZWxlbWVudFJlZiIsInJlc2l6ZVRpbWVyaWRSZWYiLCJpc1Jlc2l6aW5nUmVmIiwicmVzaXplT2JzZXJ2ZXJSZWYiLCJyZXNpemVDYWxsYmFjayIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsInRhcmdldCIsImRhdGFzZXQiLCJpbml0aWFsaXplZCIsIk9iamVjdCIsImFzc2lnbiIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJkaXZsaW5lcnN0eWxlUmVmIiwicG9zaXRpb24iLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJvdmVyZmxvdyIsImJhY2tncm91bmRDb2xvciIsInZpZXdwb3J0IiwibWluY3Jvc3NsZW5ndGgiLCJjYWxjTWluVmlld3BvcnRDcm9zc0xlbmd0aCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJsb2NhbFZpZXdwb3J0RGF0YSIsInZpZXdwb3J0ZGF0YW9iamVjdCIsIlByb3ZpZGVyIiwidmFsdWUiLCJzdHlsZSIsInJlZiIsImNyb3NzbGVuZ3RoIiwiY2VsbExlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n");

/***/ }),

/***/ "./src/cellframe/Placeholder.tsx":
/*!***************************************!*\
  !*** ./src/cellframe/Placeholder.tsx ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // placeholder.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n      listsize = _ref.listsize,\n      message = _ref.message,\n      error = _ref.error;\n  var stylesRef = (0, react_1.useRef)({\n    position: 'relative',\n    boxSizing: 'border-box',\n    backgroundColor: 'cyan',\n    border: '2px solid black',\n    height: '100%',\n    width: '100%'\n  });\n  var itemStylesRef = (0, react_1.useRef)({\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    padding: '3px',\n    opacity: .5,\n    borderRadius: '8px',\n    backgroundColor: 'white',\n    margin: '3px',\n    fontSize: 'smaller'\n  }); // console.log('placeholder index, error value',index, error.message)\n\n  message = message !== null && message !== void 0 ? message : '(loading...)';\n  return react_1[\"default\"].createElement(\"div\", {\n    style: stylesRef.current\n  }, !error ? react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, index + 1, \"/\", listsize, \" \", message) : react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, \"item is not available (\", error.message, \")\"));\n};\n\nexports[\"default\"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUEsSUFBTUEsV0FBVyxHQUFHLFNBQWRBLFdBQWMsT0FBc0M7RUFBQSxJQUFwQ0MsS0FBb0MsUUFBcENBLEtBQW9DO0VBQUEsSUFBN0JDLFFBQTZCLFFBQTdCQSxRQUE2QjtFQUFBLElBQW5CQyxPQUFtQixRQUFuQkEsT0FBbUI7RUFBQSxJQUFWQyxLQUFVLFFBQVZBLEtBQVU7RUFFdEQsSUFBTUMsU0FBUyxHQUFHLG9CQUFPO0lBQ3JCQyxRQUFRLEVBQUMsVUFEWTtJQUVyQkMsU0FBUyxFQUFDLFlBRlc7SUFHckJDLGVBQWUsRUFBQyxNQUhLO0lBSXJCQyxNQUFNLEVBQUMsaUJBSmM7SUFLckJDLE1BQU0sRUFBQyxNQUxjO0lBTXJCQyxLQUFLLEVBQUM7RUFOZSxDQUFQLENBQWxCO0VBUUEsSUFBTUMsYUFBYSxHQUFHLG9CQUNsQjtJQUNJTixRQUFRLEVBQUMsVUFEYjtJQUVJTyxHQUFHLEVBQUMsQ0FGUjtJQUdJQyxJQUFJLEVBQUMsQ0FIVDtJQUlJQyxPQUFPLEVBQUMsS0FKWjtJQUtJQyxPQUFPLEVBQUMsRUFMWjtJQU1JQyxZQUFZLEVBQUMsS0FOakI7SUFPSVQsZUFBZSxFQUFDLE9BUHBCO0lBUUlVLE1BQU0sRUFBQyxLQVJYO0lBU0lDLFFBQVEsRUFBQztFQVRiLENBRGtCLENBQXRCLENBVnNELENBd0J0RDs7RUFFQWhCLE9BQU8sR0FBR0EsT0FBTyxTQUFQLFdBQU8sV0FBUCxhQUFXLGNBQXJCO0VBRUEsT0FBT2lCO0lBQUtDLEtBQUssRUFBSWhCLFNBQVMsQ0FBQ2lCO0VBQXhCLEdBQ0QsQ0FBQ2xCLEtBQUQsR0FDRWdCO0lBQUtDLEtBQUssRUFBSVQsYUFBYSxDQUFDVTtFQUE1QixHQUFzQ3JCLEtBQUssR0FBRyxDQUE5QyxPQUFrREMsUUFBbEQsT0FBNkRDLE9BQTdELENBREYsR0FFRWlCO0lBQUtDLEtBQUssRUFBSVQsYUFBYSxDQUFDVTtFQUE1Qiw4QkFBNkRsQixLQUFLLENBQUNELE9BQW5FLE1BSEQsQ0FBUDtBQU9ILENBbkNEOztBQXFDQW9CLGtCQUFBQSxHQUFldkIsV0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBQbGFjZWhvbGRlciA9ICh7aW5kZXgsIGxpc3RzaXplLCBtZXNzYWdlLCBlcnJvcn0pID0+IHtcblxuICAgIGNvbnN0IHN0eWxlc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZScsXG4gICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgIGJvcmRlcjonMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgaGVpZ2h0OicxMDAlJyxcbiAgICAgICAgd2lkdGg6JzEwMCUnXG4gICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzKVxuICAgIGNvbnN0IGl0ZW1TdHlsZXNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6MCxcbiAgICAgICAgICAgIGxlZnQ6MCxcbiAgICAgICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgICAgICBvcGFjaXR5Oi41LFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOic4cHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsIFxuICAgICAgICAgICAgbWFyZ2luOiczcHgnLFxuICAgICAgICAgICAgZm9udFNpemU6J3NtYWxsZXInLFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICApXG5cbiAgICAvLyBjb25zb2xlLmxvZygncGxhY2Vob2xkZXIgaW5kZXgsIGVycm9yIHZhbHVlJyxpbmRleCwgZXJyb3IubWVzc2FnZSlcblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlID8/ICcobG9hZGluZy4uLiknXG5cbiAgICByZXR1cm4gPGRpdiBzdHlsZSA9IHtzdHlsZXNSZWYuY3VycmVudH0+XG4gICAgICAgIHsgIWVycm9yP1xuICAgICAgICAgICAgPGRpdiBzdHlsZSA9IHtpdGVtU3R5bGVzUmVmLmN1cnJlbnR9PntpbmRleCArIDF9L3tsaXN0c2l6ZX0ge21lc3NhZ2V9PC9kaXY+OlxuICAgICAgICAgICAgPGRpdiBzdHlsZSA9IHtpdGVtU3R5bGVzUmVmLmN1cnJlbnR9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSAoe2Vycm9yLm1lc3NhZ2V9KTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJuYW1lcyI6WyJQbGFjZWhvbGRlciIsImluZGV4IiwibGlzdHNpemUiLCJtZXNzYWdlIiwiZXJyb3IiLCJzdHlsZXNSZWYiLCJwb3NpdGlvbiIsImJveFNpemluZyIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImhlaWdodCIsIndpZHRoIiwiaXRlbVN0eWxlc1JlZiIsInRvcCIsImxlZnQiLCJwYWRkaW5nIiwib3BhY2l0eSIsImJvcmRlclJhZGl1cyIsIm1hcmdpbiIsImZvbnRTaXplIiwicmVhY3RfMSIsInN0eWxlIiwiY3VycmVudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n");

/***/ }),

/***/ "./src/cradle/ScrollTracker.tsx":
/*!**************************************!*\
  !*** ./src/cradle/ScrollTracker.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // scrolltracker.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      offset = _ref.offset,\n      listsize = _ref.listsize,\n      styles = _ref.styles;\n  var trackdata = \"\".concat(offset + 1, \"/\").concat(listsize);\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + 'px',\n    left: left + 'px',\n    position: 'fixed',\n    zIndex: 3,\n    backgroundColor: 'white',\n    border: '1px solid gray',\n    borderRadius: '10px',\n    fontSize: 'smaller',\n    padding: '3px'\n  }, styles.scrolltracker));\n  return react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'scrolltracker',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports[\"default\"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQSxJQUFNQSxhQUFhLEdBQUcsU0FBaEJBLGFBQWdCLE9BQTRDO0VBQUEsSUFBekNDLEdBQXlDLFFBQXpDQSxHQUF5QztFQUFBLElBQXBDQyxJQUFvQyxRQUFwQ0EsSUFBb0M7RUFBQSxJQUE5QkMsTUFBOEIsUUFBOUJBLE1BQThCO0VBQUEsSUFBdEJDLFFBQXNCLFFBQXRCQSxRQUFzQjtFQUFBLElBQVpDLE1BQVksUUFBWkEsTUFBWTtFQUU5RCxJQUFJQyxTQUFTLGFBQU1ILE1BQU0sR0FBRyxDQUFmLGNBQW9CQyxRQUFwQixDQUFiO0VBRUEsSUFBSUcsUUFBUSxHQUFHLG9CQUFPQyxNQUFNLENBQUNDLE1BQVAsQ0FBYztJQUNoQ1IsR0FBRyxFQUFFQSxHQUFHLEdBQUcsSUFEcUI7SUFFaENDLElBQUksRUFBRUEsSUFBSSxHQUFHLElBRm1CO0lBR2hDUSxRQUFRLEVBQUMsT0FIdUI7SUFJaENDLE1BQU0sRUFBQyxDQUp5QjtJQUtoQ0MsZUFBZSxFQUFDLE9BTGdCO0lBTWhDQyxNQUFNLEVBQUUsZ0JBTndCO0lBT2hDQyxZQUFZLEVBQUMsTUFQbUI7SUFRaENDLFFBQVEsRUFBQyxTQVJ1QjtJQVNoQ0MsT0FBTyxFQUFDO0VBVHdCLENBQWQsRUFVR1gsTUFBTSxDQUFDWSxhQVZWLENBQVAsQ0FBZjtFQVlBLE9BQU9DO0lBQUEsYUFBaUIsZUFBakI7SUFBaUNDLEtBQUssRUFBSVosUUFBUSxDQUFDYTtFQUFuRCxHQUE4RGQsU0FBOUQsQ0FBUDtBQUNILENBakJEOztBQW1CQWUsa0JBQUFBLEdBQWVyQixhQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvU2Nyb2xsVHJhY2tlci50c3g/MGIzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY3JvbGx0cmFja2VyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFNjcm9sbFRyYWNrZXIgPSAoeyB0b3AsIGxlZnQsIG9mZnNldCwgbGlzdHNpemUsIHN0eWxlcyB9KSA9PiB7XG5cbiAgICBsZXQgdHJhY2tkYXRhID0gYCR7b2Zmc2V0ICsgMX0vJHtsaXN0c2l6ZX1gXG5cbiAgICBsZXQgc3R5bGVSZWYgPSB1c2VSZWYoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgbGVmdDogbGVmdCArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOidmaXhlZCcsXG4gICAgICAgIHpJbmRleDozLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J3doaXRlJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGdyYXknLFxuICAgICAgICBib3JkZXJSYWRpdXM6JzEwcHgnLFxuICAgICAgICBmb250U2l6ZTonc21hbGxlcicsXG4gICAgICAgIHBhZGRpbmc6JzNweCdcbiAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsc3R5bGVzLnNjcm9sbHRyYWNrZXIpKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS1uYW1lID0gJ3Njcm9sbHRyYWNrZXInIHN0eWxlID0ge3N0eWxlUmVmLmN1cnJlbnR9ID57dHJhY2tkYXRhfTwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxUcmFja2VyIl0sIm5hbWVzIjpbIlNjcm9sbFRyYWNrZXIiLCJ0b3AiLCJsZWZ0Iiwib2Zmc2V0IiwibGlzdHNpemUiLCJzdHlsZXMiLCJ0cmFja2RhdGEiLCJzdHlsZVJlZiIsIk9iamVjdCIsImFzc2lnbiIsInBvc2l0aW9uIiwiekluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiZm9udFNpemUiLCJwYWRkaW5nIiwic2Nyb2xsdHJhY2tlciIsInJlYWN0XzEiLCJzdHlsZSIsImN1cnJlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n");

/***/ }),

/***/ "./src/cradle/cachehandler.tsx":
/*!*************************************!*\
  !*** ./src/cradle/cachehandler.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // cachehandler.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PortalList = exports.CacheHandler = void 0;\n/*\n    The infinite list scroller stores user cell data in a central hidden portal cache for each\n    infinitegridscroller root, from whence the data is pulled into the relevant CellFrame for display\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ \"./node_modules/react-reverse-portal/dist/web/index.js\"); //  const MAX_CACHE_OVER_RUN = 1.5\n\n\nvar globalItemID = 0; // global scroller data, organized by session scrollerID\n// the cache itself is maintained in the root infinitegridscroller component\n\nvar CacheHandler = /*#__PURE__*/function () {\n  function CacheHandler(scrollerID, setListsize, listsizeRef) {\n    var _this = this;\n\n    _classCallCheck(this, CacheHandler);\n\n    this.cacheProps = {\n      setListState: null,\n      modified: false,\n      metadataMap: new Map(),\n      // some portals may have been requested by requestidlecallback, not yet created\n      requestedSet: new Set(),\n      portalMap: new Map(),\n      indexToItemIDMap: new Map(),\n      portalList: null,\n      scrollerID: null\n    }; //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n\n    this.changeListsize = function (newlistsize, deleteListCallback, changeListsizeCallback) {\n      _this.setListsize(newlistsize); // match cache to newlistsize\n\n\n      var portalIndexMap = _this.cacheProps.indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n\n        _this.deletePortal(parelist, deleteListCallback);\n      }\n\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n\n    this.clearCache = function () {\n      // keep the setListState callback\n      _this.cacheProps.portalMap.clear();\n\n      _this.cacheProps.metadataMap.clear();\n\n      _this.cacheProps.indexToItemIDMap.clear();\n\n      _this.cacheProps.requestedSet.clear();\n\n      _this.cacheProps.portalList = null;\n      _this.cacheProps.modified = true;\n\n      _this.renderPortalList(); // trigger display update\n\n    }; // set state of the PortalList component of the scroller to trigger render\n\n\n    this.renderPortalList = function () {\n      if (_this.cacheProps.modified) {\n        _this.cacheProps.portalList = Array.from(_this.cacheProps.portalMap.values());\n        _this.cacheProps.modified = false;\n      }\n\n      _this.cacheProps.setListState(); // trigger display update\n\n    };\n\n    this.matchCacheToCradle = function (cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.cacheProps.indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n\n      if (delkeys.length) {\n        _this.deletePortal(delkeys, deleteListCallback);\n\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.pareCacheToMax = function (cacheMax, cradleIndexList, deleteListCallback) {\n      var scrollerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      // console.log('pareCacheToMax: cacheMax, cradleIndexList','-'+scrollerID+'-',cacheMax, cradleIndexList)\n      var modelLength = cradleIndexList.length; // determine need for paring\n\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexList = _this.cacheProps.indexToItemIDMap;\n      var requestedSet = _this.cacheProps.requestedSet;\n      if (portalIndexList.size + requestedSet.size <= max) return false; // sort the map keys\n\n      var mapkeyslist = Array.from(portalIndexList.keys());\n      var requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = mapkeyslist.concat(requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      }); // get number to pare\n\n      var mapLength = mapkeys.length;\n      var parecount = mapLength - max; // distribute paring proportionally at front and back\n\n      var headindex = cradleIndexList[0];\n      var tailindex = cradleIndexList[modelLength - 1];\n      var headpos = mapkeys.indexOf(headindex);\n      var tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos;\n      var tailroom = mapLength - (tailpos + 1);\n      var pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount);\n      var tailparecount = parecount - headparecount; // collect indexes to pare\n\n      var headlist = mapkeys.slice(0, headparecount);\n      var taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = headlist.concat(taillist);\n\n      _this.deletePortal(delList, deleteListCallback);\n\n      return true;\n    };\n\n    this.guardAgainstRunawayCaching = function (cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var portalMap = _this.cacheProps.portalMap;\n      var requestedSet = _this.cacheProps.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n\n      if (portalMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    this.cacheProps.scrollerID = scrollerID;\n    this.setListsize = setListsize; // passed from infinitegridscroller setListsize(listsize)\n\n    this.listsizeRef = listsizeRef;\n  }\n\n  _createClass(CacheHandler, [{\n    key: \"preload\",\n    value: function preload(cradleParameters, finalCallback, nullItemSetMaxListsize, scrollerID) {\n      var _this2 = this;\n\n      var scrollerPassthroughPropertiesRef = cradleParameters.scrollerPassthroughPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n          stateHandler = _cradleParameters$han.stateHandler,\n          serviceHandler = _cradleParameters$han.serviceHandler;\n      var cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n          cacheMax = cradleInheritedProperties.cacheMax;\n      var listsize = cradleInternalProperties.listsize;\n      var promises = []; // console.log('cacheMax', cacheMax)\n\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      }; // serviceHandler.callbacks.preloadIndexCallback\n\n\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n            preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n            itemExceptionsCallback = _serviceHandler$callb.itemExceptionsCallback;\n\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n\n          if (!indexToItemIDMap.has(index)) {\n            // console.log('preload processing', index)\n            var promise = this.preloadItem(index, getItem, scrollerPassthroughPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID);\n            promises.push(promise);\n          }\n\n          if (breakloop.current) break;\n        }\n      }\n\n      Promise.allSettled(promises).then(function () {\n        _this2.cacheProps.modified = true;\n\n        _this2.renderPortalList();\n\n        finalCallback();\n      });\n    } // =========================[ SNAPSHOTS ]=========================\n\n  }, {\n    key: \"getCacheIndexMap\",\n    value: function getCacheIndexMap() {\n      return new Map(this.cacheProps.indexToItemIDMap);\n    }\n  }, {\n    key: \"getCradleIndexMap\",\n    value: function getCradleIndexMap(cradleIndexList) {\n      var cradleMap = new Map();\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n\n      var _iterator = _createForOfIteratorHelper(cradleIndexList),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return cradleMap;\n    }\n  }, {\n    key: \"getCacheItemMap\",\n    value: function getCacheItemMap() {\n      var cachelist = new Map();\n\n      var _iterator2 = _createForOfIteratorHelper(this.cacheProps.metadataMap),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              value = _step2$value[1];\n\n          var index = value.index,\n              component = value.component;\n          cachelist.set(key, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return cachelist;\n    } // ==========================[ SERVICE SUPPORT ]=========================\n    // move is coerced by servicehandler to be within current list bounds\n\n  }, {\n    key: \"moveIndex\",\n    value: function moveIndex(toindex, fromindex, fromhighindex) {\n      var _this$cacheProps = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps.indexToItemIDMap,\n          metadataMap = _this$cacheProps.metadataMap; // ----------- define parameters ---------------\n\n      var rangeabsoluteincrement = fromhighindex - fromindex + 1;\n      var movedirectionalincrement = toindex - fromindex;\n      var tohighindex = toindex + (rangeabsoluteincrement - 1);\n      var shiftdirection = movedirectionalincrement > 0 ? // move up in list\n      -1 : // shift down, make room for shiftingindex above\n      1; // shift up, make room for shiftingindex below\n\n      var orderedindexlist = Array.from(indexToItemIDMap.keys());\n      orderedindexlist.sort(function (a, b) {\n        return a - b;\n      });\n      var toindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= toindex;\n      });\n      var tohighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= tohighindex;\n      });\n      var fromindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromindex;\n      });\n      var fromhighindexptr = orderedindexlist.findIndex(function (value) {\n        return value >= fromhighindex;\n      }); // ---------------- capture index data to move ----------------\n\n      var processtomoveList;\n\n      if (fromindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        processtomoveList = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        processtomoveList = orderedindexlist.slice(fromindexptr);\n      } else {\n        // scope is entirely in view\n        processtomoveList = orderedindexlist.slice(fromindexptr, fromhighindexptr + 1);\n      }\n\n      var processtomoveMap = new Map();\n\n      var capturemoveindex = function capturemoveindex(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n\n      processtomoveList.forEach(capturemoveindex); // ------------- get list of indexes to shift out of the way ---------------\n\n      var processtoshiftList;\n\n      if (shiftdirection == 1) {\n        // block is moving down, shift is up; toindex < fromindex\n        if (toindexptr == -1 && fromindexptr == -1) {\n          processtoshiftList = [];\n        } else if (fromindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(toindexptr);\n        } else {\n          processtoshiftList = orderedindexlist.slice(toindexptr, fromindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          processtoshiftList = [];\n        } else if (tohighindexptr == -1) {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          processtoshiftList = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n\n      if (shiftdirection == 1) processtoshiftList.reverse(); // -------------- move indexes out of the way --------------\n\n      var processedshiftList = [];\n\n      var processshiftindex = function processshiftindex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = shiftdirection == -1 ? index - rangeabsoluteincrement : index + rangeabsoluteincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedshiftList.push(newIndex);\n      };\n\n      processtoshiftList.forEach(processshiftindex); // ------------ replace shifted index space with moved indexes ----------\n\n      var processedmoveList = [];\n\n      var processmoveindex = function processmoveindex(itemID, index) {\n        var newIndex = index + movedirectionalincrement; // swap\n\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n\n      processtomoveMap.forEach(processmoveindex); // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n\n      var processedIndexes = processedshiftList.concat(processedmoveList);\n      return processedIndexes;\n    } // much of this deals with the fact that the cache is sparse.\n\n  }, {\n    key: \"insertRemoveIndex\",\n    value: function insertRemoveIndex(index, highrange, increment, listsize) {\n      var _this$cacheProps2 = this.cacheProps,\n          indexToItemIDMap = _this$cacheProps2.indexToItemIDMap,\n          metadataMap = _this$cacheProps2.metadataMap,\n          portalMap = _this$cacheProps2.portalMap; // ---------- define range parameters ---------------\n      // high range is the highest index number of the insert/remove operation\n\n      var highrangeindex = highrange !== null && highrange !== void 0 ? highrange : 0;\n      highrangeindex = highrangeindex > index ? highrangeindex : index;\n      var emptyreturn = [[], [], 0];\n\n      if (increment == -1) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) return emptyreturn;\n      } else {\n        // addition can at most start at the next index above the current list\n        if (index > listsize) return emptyreturn;\n      } // rangecount is the absolute number in the insert/remove range - contiguous\n\n\n      var rangecount = highrangeindex - index + 1; // range increment adds sign to rangecount to indicate add/remove\n\n      var rangeincrement = rangecount * increment; // highPtr, lowPtr, shrinktoPtr within orderedIndexList.\n\n      var orderedIndexList = Array.from(indexToItemIDMap.keys());\n      orderedIndexList.sort(function (a, b) {\n        return a - b;\n      }); // ---------- define boundaries within ordered cache index list ------------\n      // Ptr = index into array, as opposed to index of virtual list\n      // shrinkptr is the location of the bottom of the shrink range for removals\n\n      var shrinktoIndex = null;\n      var shrinktoPtr = -1;\n\n      if (increment == -1) {\n        shrinktoIndex = orderedIndexList.at(-1) + rangeincrement;\n        shrinktoIndex = Math.max(highrangeindex + rangeincrement, shrinktoIndex);\n        shrinktoIndex = Math.min(listsize - 1, shrinktoIndex);\n        shrinktoPtr = orderedIndexList.findIndex(function (value) {\n          return value >= shrinktoIndex;\n        });\n      } // lowPtr and highPtr must be within low and high range\n\n\n      var lowPtr = orderedIndexList.findIndex(function (value) {\n        return value >= index && value <= highrangeindex;\n      });\n      var reverseIndexList = Array.from(orderedIndexList);\n      reverseIndexList.reverse();\n      var highPtr = reverseIndexList.findIndex(function (value) {\n        return value <= highrangeindex;\n      });\n\n      if (highPtr != -1) {\n        highPtr = orderedIndexList.length - 1 - highPtr;\n        if (highPtr < lowPtr) highPtr = -1;\n      } // ----------- list indexes to process, replace, and remove, and items to remove --------\n\n\n      var indexesToProcessList,\n          // for either insert or remove\n      indexesToReplaceList = [],\n          // for insert the range being inserted\n      indexesToRemoveList = [],\n          // for remove - end of list; the list is shrinking\n      indexesOfItemsToRemoveList = [],\n          // for remove - within the range of indexes being removed\n      itemsToRemoveList = []; // for remove, derived from the previous\n      // get indexesToProcessList\n\n      if (lowPtr == -1 && highPtr == -1) {\n        // core scope is out of view\n        indexesToProcessList = [];\n      } else {\n        // core scope is partially or fully in view; lowPtr is available\n        if (increment == 1) {\n          indexesToProcessList = orderedIndexList.slice(lowPtr);\n        } else if (highPtr == -1) {\n          // increment == -1; lowPtr is available\n          indexesToProcessList = [];\n        } else {\n          // increment == -1; lowPtr and highPtr are available\n          indexesToProcessList = orderedIndexList.slice(highPtr + 1);\n        }\n      }\n\n      var portalHoldList = []; // hold portals for deletion until after after cradle synch\n\n      if (increment == 1) {\n        // get indexesToReplaceList\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesToReplaceList = [];\n        } else if (highPtr == -1) {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesToReplaceList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        }\n      } else {\n        // get indexesToRemoveList\n        if (shrinktoPtr == -1) {\n          // core scope is out of view\n          indexesToRemoveList = [];\n        } else {\n          indexesToRemoveList = orderedIndexList.slice(shrinktoPtr + 1);\n        } // get indexesOfItemsToRemoveList\n\n\n        if (lowPtr == -1 && highPtr == -1) {\n          // core scope is out of view\n          indexesOfItemsToRemoveList = [];\n        } else if (highPtr == -1) {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr);\n        } else {\n          indexesOfItemsToRemoveList = orderedIndexList.slice(lowPtr, highPtr + 1);\n        } // get itemsToRemoveList\n\n\n        var _iterator3 = _createForOfIteratorHelper(indexesOfItemsToRemoveList),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _index = _step3.value;\n            itemsToRemoveList.push(indexToItemIDMap.get(_index));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } // ----------- conduct cache operations ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n\n\n      if (increment == 1) indexesToProcessList.reverse();\n      var indexesModifiedList = []; // modify index-to-itemid map, and metadata map\n\n      var processIndex = function processIndex(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        indexToItemIDMap.set(newIndex, itemID);\n        metadataMap.get(itemID).index = newIndex;\n        indexesModifiedList.push(newIndex);\n      };\n\n      indexesToProcessList.forEach(processIndex); // delete remaining indexes and items now duplicates\n\n      if (increment == 1) {\n        var _iterator4 = _createForOfIteratorHelper(indexesToReplaceList),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _index2 = _step4.value;\n            indexToItemIDMap[\"delete\"](_index2);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(indexesToRemoveList),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index3 = _step5.value;\n            indexToItemIDMap[\"delete\"](_index3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        var _iterator6 = _createForOfIteratorHelper(itemsToRemoveList),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var itemID = _step6.value;\n            metadataMap[\"delete\"](itemID);\n            portalHoldList.push(itemID);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n\n\n      return [indexesModifiedList, indexesToReplaceList, rangeincrement, portalHoldList];\n    } // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n\n  }, {\n    key: \"registerRequestedPortal\",\n    value: function registerRequestedPortal(index) {\n      this.cacheProps.requestedSet.add(index);\n    }\n  }, {\n    key: \"removeRequestedPortal\",\n    value: function removeRequestedPortal(index) {\n      this.cacheProps.requestedSet[\"delete\"](index);\n    }\n  }, {\n    key: \"getNewItemID\",\n    value: function getNewItemID() {\n      return globalItemID++;\n    } // get new or existing itemID for contentfunctions.createCell\n\n  }, {\n    key: \"getNewOrExistingItemID\",\n    value: function getNewOrExistingItemID(index) {\n      var indexToItemIDMap = this.cacheProps.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    }\n  }, {\n    key: \"createPortal\",\n    value: function createPortal(component, index, itemID) {\n      var isPreload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.removeRequestedPortal(index);\n      var portalNode = createPortalNode(index, itemID); // div wrapper to avoid memory leak\n\n      this.cacheProps.portalMap.set(itemID, react_1[\"default\"].createElement(\"div\", {\n        \"data-type\": 'portalwrapper',\n        key: itemID,\n        \"data-itemid\": itemID,\n        \"data-index\": index\n      }, react_1[\"default\"].createElement(react_reverse_portal_1.InPortal, {\n        key: itemID,\n        node: portalNode\n      }, \" \", component, \" \")));\n      this.cacheProps.modified = true;\n      var portalMetadata = {\n        portalNode: portalNode,\n        isReparentingRef: {\n          current: false\n        },\n        index: index,\n        itemID: itemID,\n        component: component\n      };\n      this.cacheProps.metadataMap.set(itemID, portalMetadata);\n      this.cacheProps.indexToItemIDMap.set(index, itemID);\n      if (!isPreload) this.renderPortalList();\n      return portalMetadata;\n    } // always for new item\n\n  }, {\n    key: \"preloadItem\",\n    value: function preloadItem(index, getItem, scrollerPassthroughPropertiesRef, itemExceptionsCallback, maxListsizeInterrupt, scrollerID) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties, portalData;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                itemID = this.getNewItemID();\n                _context.prev = 1;\n                _context.next = 4;\n                return getItem(index, itemID);\n\n              case 4:\n                usercontent = _context.sent;\n                if (usercontent === null) returnvalue = usercontent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](1);\n                returnvalue = usercontent = undefined;\n                error = _context.t0;\n\n              case 12:\n                if (usercontent !== null && usercontent !== undefined) {\n                  if (!react_1[\"default\"].isValidElement(usercontent)) {\n                    returnvalue = usercontent;\n                    usercontent = undefined;\n                    error = new Error('invalid React element');\n                  }\n                }\n\n                if (usercontent !== null && usercontent !== undefined) {\n                  scrollerProperties = {\n                    isReparentingRef: null,\n                    scrollerPassthroughPropertiesRef: scrollerPassthroughPropertiesRef\n                  };\n\n                  if (usercontent.props.hasOwnProperty('scrollerProperties')) {\n                    content = react_1[\"default\"].cloneElement(usercontent, {\n                      scrollerProperties: scrollerProperties\n                    });\n                  } else {\n                    content = usercontent;\n                  }\n\n                  portalData = this.createPortal(content, index, itemID, true); // true = isPreload\n                  // make available to user content\n\n                  scrollerProperties.isReparentingRef = portalData.isReparentingRef;\n                } else {\n                  if (usercontent === undefined) {\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, 'preload', error);\n                  } else {\n                    // usercontent === null; last item in list\n                    itemExceptionsCallback && itemExceptionsCallback(index, itemID, returnvalue, 'preload', new Error('end of list'));\n                    maxListsizeInterrupt(index);\n                  }\n                }\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 8]]);\n      }));\n    } // delete a portal list item\n    // accepts an array of indexes\n\n  }, {\n    key: \"deletePortal\",\n    value: function deletePortal(index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$cacheProps3 = this.cacheProps,\n          metadataMap = _this$cacheProps3.metadataMap,\n          portalMap = _this$cacheProps3.portalMap,\n          indexToItemIDMap = _this$cacheProps3.indexToItemIDMap;\n      var deleteList = [];\n\n      var _iterator7 = _createForOfIteratorHelper(indexArray),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n          var itemID = indexToItemIDMap.get(i);\n          deleteList.push({\n            index: i,\n            itemID: itemID\n          });\n          metadataMap[\"delete\"](itemID);\n          portalMap[\"delete\"](itemID);\n          indexToItemIDMap[\"delete\"](i);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this.cacheProps.modified = true;\n      deleteListCallback && deleteListCallback(deleteList);\n    } // query existence of a portal list item\n\n  }, {\n    key: \"hasPortal\",\n    value: function hasPortal(itemID) {\n      return this.cacheProps.metadataMap.has(itemID);\n    }\n  }, {\n    key: \"getPortal\",\n    value: function getPortal(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.cacheProps.metadataMap.get(itemID);\n      }\n    }\n  }]);\n\n  return CacheHandler;\n}();\n\nexports.CacheHandler = CacheHandler; // ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n\nvar createPortalNode = function createPortalNode(index, itemID) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.inset = '0px';\n  container.style.position = 'absolute';\n  container.dataset.type = 'contentenvelope';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n}; // ========================[ Utility component ]==============================\n\n\nvar counter = 0; // portal list component for rapid relisting of updates, using external callback for set state\n\nvar PortalList = function PortalList(_ref) {\n  var cacheProps = _ref.cacheProps;\n\n  // console.log('running PORTALLIST', '-'+cacheProps.scrollerID+'-')\n  var _ref2 = (0, react_1.useState)(null),\n      _ref3 = _slicedToArray(_ref2, 2),\n      portalList = _ref3[0],\n      setPortalList = _ref3[1];\n\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null); // const cachedivRef = useRef(null)\n\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController();\n\n    cacheProps.setListState = function () {\n      portalArrayRef.current = cacheProps.portalList;\n      isMountedRef.current && setPortalList(counter++); // light contents\n    };\n\n    return function () {\n      isMountedRef.current = false;\n      abortController.abort(); // defensive\n    };\n  }, []);\n  return portalArrayRef.current;\n};\n\nexports.PortalList = PortalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NhY2hlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7OzsrQ0FEQSxvSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7QUFLQTs7QUFFQSxzSSxDQUVBOzs7QUFFQSxJQUFJQSxZQUFZLEdBQUcsQ0FBbkIsQyxDQUVBO0FBQ0E7O0lBQ2FDLFk7RUFFVCxzQkFBWUMsVUFBWixFQUF3QkMsV0FBeEIsRUFBcUNDLFdBQXJDLEVBQWdEO0lBQUE7O0lBQUE7O0lBTWhELGtCQUFhO01BQ1RDLFlBQVksRUFBQyxJQURKO01BRVRDLFFBQVEsRUFBQyxLQUZBO01BSVRDLFdBQVcsRUFBQyxJQUFJQyxHQUFKLEVBSkg7TUFLVDtNQUNBQyxZQUFZLEVBQUMsSUFBSUMsR0FBSixFQU5KO01BT1RDLFNBQVMsRUFBQyxJQUFJSCxHQUFKLEVBUEQ7TUFRVEksZ0JBQWdCLEVBQUMsSUFBSUosR0FBSixFQVJSO01BVVRLLFVBQVUsRUFBQyxJQVZGO01BWVRYLFVBQVUsRUFBQztJQVpGLENBQWIsQ0FOZ0QsQ0EyQmhEOztJQUVBLHNCQUFpQixVQUFDWSxXQUFELEVBQWNDLGtCQUFkLEVBQWtDQyxzQkFBbEMsRUFBNEQ7TUFFekUsS0FBSSxDQUFDYixXQUFMLENBQWlCVyxXQUFqQixFQUZ5RSxDQUl6RTs7O01BQ0EsSUFBTUcsY0FBYyxHQUFHLEtBQUksQ0FBQ0MsVUFBTCxDQUFnQk4sZ0JBQXZDO01BQ0EsSUFBTU8sV0FBVyxHQUFHQyxLQUFLLENBQUNDLElBQU4sQ0FBV0osY0FBYyxDQUFDSyxJQUFmLEVBQVgsQ0FBcEI7TUFDQUgsV0FBVyxDQUFDSSxJQUFaLENBQWlCLFVBQUNDLENBQUQsRUFBR0MsQ0FBSDtRQUFBLE9BQVNELENBQUMsR0FBR0MsQ0FBYjtNQUFBLENBQWpCO01BRUEsSUFBTUMs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QWhCQSxVQUFnQjs7RUFFekM7RUFFQSxZQUFvQyxzQkFBUyxJQUFULENBQXBDO0VBQUE7RUFBQSxJQUFPTCxVQUFQO0VBQUEsSUFBbUJtTCxhQUFuQjs7RUFDQSxJQUFNdEcsWUFBWSxHQUFHLG9CQUFPLElBQVAsQ0FBckI7RUFDQSxJQUFNdUcsY0FBYyxHQUFHLG9CQUFPLElBQVAsQ0FBdkIsQ0FOeUMsQ0FPekM7O0VBRUEsdUJBQVUsWUFBSTtJQUVWLElBQU1DLGVBQWUsR0FBRyxJQUFJQyxlQUFKLEVBQXhCOztJQUVBakwsVUFBVSxDQUFDYixZQUFYLEdBQTBCLFlBQUk7TUFFMUI0TCxjQUFjLENBQUN0SCxPQUFmLEdBQXlCekQsVUFBVSxDQUFDTCxVQUFwQztNQUVBNkUsWUFBWSxDQUFDZixPQUFiLElBQXdCcUgsYUFBYSxDQUFDRixPQUFPLEVBQVIsQ0FBckMsQ0FKMEIsQ0FJdUI7SUFFcEQsQ0FORDs7SUFRQSxPQUFPLFlBQUs7TUFFUnBHLFlBQVksQ0FBQ2YsT0FBYixHQUF1QixLQUF2QjtNQUVBdUgsZUFBZSxDQUFDRSxLQUFoQixHQUpRLENBSWdCO0lBRTNCLENBTkQ7RUFRSCxDQXBCRCxFQW9CRSxFQXBCRjtFQXNCQSxPQUFPSCxjQUFjLENBQUN0SCxPQUF0QjtBQUVILENBakNNOztBQUFNMEcsa0JBQUFBLEdBQVVVLFVBQVYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jYWNoZWhhbmRsZXIudHN4PzllOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FjaGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgaW5maW5pdGUgbGlzdCBzY3JvbGxlciBzdG9yZXMgdXNlciBjZWxsIGRhdGEgaW4gYSBjZW50cmFsIGhpZGRlbiBwb3J0YWwgY2FjaGUgZm9yIGVhY2hcbiAgICBpbmZpbml0ZWdyaWRzY3JvbGxlciByb290LCBmcm9tIHdoZW5jZSB0aGUgZGF0YSBpcyBwdWxsZWQgaW50byB0aGUgcmVsZXZhbnQgQ2VsbEZyYW1lIGZvciBkaXNwbGF5XG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWZ9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgSW5Qb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCdcblxuLy8gIGNvbnN0IE1BWF9DQUNIRV9PVkVSX1JVTiA9IDEuNVxuXG5sZXQgZ2xvYmFsSXRlbUlEID0gMFxuXG4vLyBnbG9iYWwgc2Nyb2xsZXIgZGF0YSwgb3JnYW5pemVkIGJ5IHNlc3Npb24gc2Nyb2xsZXJJRFxuLy8gdGhlIGNhY2hlIGl0c2VsZiBpcyBtYWludGFpbmVkIGluIHRoZSByb290IGluZmluaXRlZ3JpZHNjcm9sbGVyIGNvbXBvbmVudFxuZXhwb3J0IGNsYXNzIENhY2hlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxlcklELCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYpIHtcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnNjcm9sbGVySUQgPSBzY3JvbGxlcklEXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUgPSBzZXRMaXN0c2l6ZSAvLyBwYXNzZWQgZnJvbSBpbmZpbml0ZWdyaWRzY3JvbGxlciBzZXRMaXN0c2l6ZShsaXN0c2l6ZSlcbiAgICAgICAgdGhpcy5saXN0c2l6ZVJlZiA9IGxpc3RzaXplUmVmXG4gICAgfVxuXG4gICAgY2FjaGVQcm9wcyA9IHtcbiAgICAgICAgc2V0TGlzdFN0YXRlOm51bGwsXG4gICAgICAgIG1vZGlmaWVkOmZhbHNlLFxuXG4gICAgICAgIG1ldGFkYXRhTWFwOm5ldyBNYXAoKSwgLy8gaXRlbSA9PiB7aW5kZXgsIGNvbXBvbmVudH1cbiAgICAgICAgLy8gc29tZSBwb3J0YWxzIG1heSBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ5IHJlcXVlc3RpZGxlY2FsbGJhY2ssIG5vdCB5ZXQgY3JlYXRlZFxuICAgICAgICByZXF1ZXN0ZWRTZXQ6bmV3IFNldCgpLCAvLyBpbmRleCA9PiBpdGVtIFRPRE8gcy9iIHJlcXVlc3RlZFNldCBvZiBpbmRleGVzXG4gICAgICAgIHBvcnRhbE1hcDpuZXcgTWFwKCksIC8vIGluZGV4ID0+IEluUG9ydGFsXG4gICAgICAgIGluZGV4VG9JdGVtSURNYXA6bmV3IE1hcCgpLFxuXG4gICAgICAgIHBvcnRhbExpc3Q6bnVsbCxcblxuICAgICAgICBzY3JvbGxlcklEOm51bGxcbiAgICB9XG5cbiAgICBwb3J0YWxIb2xkTGlzdFxuXG4gICAgbGlzdHNpemVSZWZcblxuICAgIHNldExpc3RzaXplIC8vIHNldExpc3RzaXplKGxpc3RzaXplKSBnZW5lcmF0ZXMgaW5maW5pdGVzY3JvbGxlciB1c2VTdGF0ZSB1cGRhdGUgbGlzdHNpemUgdGhyb3VnaG91dFxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT1bIFJFUE9TSVRPUlkgQU5EIExJU1QgTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgY2hhbmdlTGlzdHNpemUgPSAobmV3bGlzdHNpemUsIGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjaykgPT4ge1xuXG4gICAgICAgIHRoaXMuc2V0TGlzdHNpemUobmV3bGlzdHNpemUpXG5cbiAgICAgICAgLy8gbWF0Y2ggY2FjaGUgdG8gbmV3bGlzdHNpemVcbiAgICAgICAgY29uc3QgcG9ydGFsSW5kZXhNYXAgPSB0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcFxuICAgICAgICBjb25zdCBtYXBrZXlzTGlzdCA9IEFycmF5LmZyb20ocG9ydGFsSW5kZXhNYXAua2V5cygpKVxuICAgICAgICBtYXBrZXlzTGlzdC5zb3J0KChhLGIpID0+IGEgLSBiKVxuXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RpbmRleCA9IG1hcGtleXNMaXN0LmF0KC0xKVxuXG4gICAgICAgIGlmIChoaWdoZXN0aW5kZXggPiAobmV3bGlzdHNpemUgLTEpKSB7IC8vIHBhcmUgdGhlIGNhY2hlXG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVsaXN0ID0gbWFwa2V5c0xpc3QuZmlsdGVyKChpbmRleCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAobmV3bGlzdHNpemUgLTEpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbChwYXJlbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrICYmIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sobmV3bGlzdHNpemUpXG5cbiAgICB9XG5cbiAgICBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIGtlZXAgdGhlIHNldExpc3RTdGF0ZSBjYWxsYmFja1xuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLmNsZWFyKCkgXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwLmNsZWFyKClcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLnJlcXVlc3RlZFNldC5jbGVhcigpXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gbnVsbFxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KCkgLy8gdHJpZ2dlciBkaXNwbGF5IHVwZGF0ZVxuXG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlIG9mIHRoZSBQb3J0YWxMaXN0IGNvbXBvbmVudCBvZiB0aGUgc2Nyb2xsZXIgdG8gdHJpZ2dlciByZW5kZXJcbiAgICByZW5kZXJQb3J0YWxMaXN0ID0gKCkgPT4ge1xuXG4gICAgICAgIGlmICh0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxMaXN0ID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMucG9ydGFsTWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLm1vZGlmaWVkID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5zZXRMaXN0U3RhdGUoKSAvLyB0cmlnZ2VyIGRpc3BsYXkgdXBkYXRlXG5cbiAgICB9XG5cbiAgICBtYXRjaENhY2hlVG9DcmFkbGUgPSAoY3JhZGxlSW5kZXhMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgICAgICBjb25zdCBtYXBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlUHJvcHMuaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgZGVsa2V5cyA9IG1hcGtleXMuZmlsdGVyKGtleSA9PiAhY3JhZGxlSW5kZXhMaXN0LmluY2x1ZGVzKGtleSkpXG5cbiAgICAgICAgaWYgKGRlbGtleXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsKGRlbGtleXMsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcGFyZUNhY2hlVG9NYXggPSAoY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEID0gdW5kZWZpbmVkKSA9PiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcmVDYWNoZVRvTWF4OiBjYWNoZU1heCwgY3JhZGxlSW5kZXhMaXN0JywnLScrc2Nyb2xsZXJJRCsnLScsY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdClcblxuICAgICAgICBjb25zdCBtb2RlbExlbmd0aCA9IGNyYWRsZUluZGV4TGlzdC5sZW5ndGhcblxuICAgICAgICAvLyBkZXRlcm1pbmUgbmVlZCBmb3IgcGFyaW5nXG4gICAgICAgIGlmICgoIWNhY2hlTWF4KSB8fCAoIW1vZGVsTGVuZ3RoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgobW9kZWxMZW5ndGgsIGNhY2hlTWF4KVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbEluZGV4TGlzdCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZFNldCA9IHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXRcblxuICAgICAgICBpZiAoKHBvcnRhbEluZGV4TGlzdC5zaXplICsgcmVxdWVzdGVkU2V0LnNpemUpIDw9IG1heCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgLy8gc29ydCB0aGUgbWFwIGtleXNcbiAgICAgICAgY29uc3QgbWFwa2V5c2xpc3QgPSBBcnJheS5mcm9tKHBvcnRhbEluZGV4TGlzdC5rZXlzKCkpXG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZGtleXMgPSBBcnJheS5mcm9tKHJlcXVlc3RlZFNldC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgbWFwa2V5cyA9IG1hcGtleXNsaXN0LmNvbmNhdChyZXF1ZXN0ZWRrZXlzKVxuXG4gICAgICAgIG1hcGtleXMuc29ydCgoYSxiKSA9PiBhIC0gYilcblxuICAgICAgICAvLyBnZXQgbnVtYmVyIHRvIHBhcmVcbiAgICAgICAgY29uc3QgbWFwTGVuZ3RoID0gbWFwa2V5cy5sZW5ndGhcbiAgICAgICAgY29uc3QgcGFyZWNvdW50ID0gbWFwTGVuZ3RoIC0gbWF4XG5cbiAgICAgICAgLy8gZGlzdHJpYnV0ZSBwYXJpbmcgcHJvcG9ydGlvbmFsbHkgYXQgZnJvbnQgYW5kIGJhY2tcbiAgICAgICAgY29uc3QgaGVhZGluZGV4ID0gY3JhZGxlSW5kZXhMaXN0WzBdXG4gICAgICAgIGNvbnN0IHRhaWxpbmRleCA9IGNyYWRsZUluZGV4TGlzdFttb2RlbExlbmd0aCAtIDFdXG4gICAgICAgIGNvbnN0IGhlYWRwb3MgPSBtYXBrZXlzLmluZGV4T2YoaGVhZGluZGV4KVxuICAgICAgICBjb25zdCB0YWlscG9zID0gbWFwa2V5cy5pbmRleE9mKHRhaWxpbmRleClcblxuICAgICAgICBjb25zdCBoZWFkcm9vbSA9IGhlYWRwb3NcbiAgICAgICAgY29uc3QgdGFpbHJvb20gPSBtYXBMZW5ndGggLSAodGFpbHBvcyArIDEpXG4gICAgICAgIGNvbnN0IHBhcmVyb29tID0gaGVhZHJvb20gKyB0YWlscm9vbVxuXG4gICAgICAgIGNvbnN0IGhlYWRwYXJlY291bnQgPSBNYXRoLmZsb29yKChoZWFkcm9vbS9wYXJlcm9vbSkqcGFyZWNvdW50KVxuICAgICAgICBjb25zdCB0YWlscGFyZWNvdW50ID0gcGFyZWNvdW50IC0gaGVhZHBhcmVjb3VudFxuXG4gICAgICAgIC8vIGNvbGxlY3QgaW5kZXhlcyB0byBwYXJlXG4gICAgICAgIGNvbnN0IGhlYWRsaXN0ID0gbWFwa2V5cy5zbGljZSgwLGhlYWRwYXJlY291bnQpXG4gICAgICAgIGNvbnN0IHRhaWxsaXN0ID0gbWFwa2V5cy5zbGljZShtYXBMZW5ndGggLSB0YWlscGFyZWNvdW50KVxuXG4gICAgICAgIGNvbnN0IGRlbExpc3QgPSBoZWFkbGlzdC5jb25jYXQodGFpbGxpc3QpXG5cbiAgICAgICAgdGhpcy5kZWxldGVQb3J0YWwoZGVsTGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICB9XG5cbiAgICBndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyA9IChjYWNoZU1heCwgY3JhZGxlTGlzdExlbmd0aCwgTUFYX0NBQ0hFX09WRVJfUlVOKSA9PiB7XG5cbiAgICAgICAgaWYgKCFjYWNoZU1heCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgY29uc3QgcG9ydGFsTWFwID0gdGhpcy5jYWNoZVByb3BzLnBvcnRhbE1hcFxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRTZXQgPSB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoY3JhZGxlTGlzdExlbmd0aCwgY2FjaGVNYXgpXG5cbiAgICAgICAgaWYgKChwb3J0YWxNYXAuc2l6ZSArIHJlcXVlc3RlZFNldC5zaXplKSA8PSAoKG1heCkgKiBNQVhfQ0FDSEVfT1ZFUl9SVU4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByZWxvYWQoY3JhZGxlUGFyYW1ldGVycywgZmluYWxDYWxsYmFjaywgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSwgc2Nyb2xsZXJJRCkge1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYgfSA9IGNyYWRsZVBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGdldEl0ZW0sIGNhY2hlTWF4IH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHsgbGlzdHNpemUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW11cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY2FjaGVNYXgnLCBjYWNoZU1heClcblxuICAgICAgICBsZXQgY2FjaGVTaXplID0gY2FjaGVNYXggPz8gMFxuXG4gICAgICAgIGNhY2hlU2l6ZSA9IE1hdGgubWluKGNhY2hlU2l6ZSwgbGlzdHNpemUpXG5cbiAgICAgICAgY29uc3QgcHJlbG9hZHNpemUgPSBcbiAgICAgICAgICAgIGNhY2hlU2l6ZT9cbiAgICAgICAgICAgICAgICBjYWNoZVNpemU6XG4gICAgICAgICAgICAgICAgbGlzdHNpemVcblxuICAgICAgICBjb25zdCBicmVha2xvb3AgPSB7XG4gICAgICAgICAgICBjdXJyZW50OmZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhMaXN0c2l6ZUludGVycnVwdCA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgYnJlYWtsb29wLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnByZWxvYWRJbmRleENhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5kZXhUb0l0ZW1JRE1hcCA9IHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwXG5cbiAgICAgICAgICAgIGNvbnN0IHsgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJlbG9hZHNpemU7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrICYmIHByZWxvYWRJbmRleENhbGxiYWNrKGluZGV4KVxuICAgICAgICAgICAgICAgIGlmICghaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ByZWxvYWQgcHJvY2Vzc2luZycsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5wcmVsb2FkSXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGlzdHNpemVJbnRlcnJ1cHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJyZWFrbG9vcC5jdXJyZW50KSBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKS50aGVuKFxuICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgICAgICAgICBmaW5hbENhbGxiYWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVsgU05BUFNIT1RTIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBnZXRDYWNoZUluZGV4TWFwKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTWFwKHRoaXMuY2FjaGVQcm9wcy5pbmRleFRvSXRlbUlETWFwKVxuXG4gICAgfVxuXG4gICAgZ2V0Q3JhZGxlSW5kZXhNYXAoY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlTWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjcmFkbGVJbmRleExpc3QpIHtcblxuICAgICAgICAgICAgY3JhZGxlTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JhZGxlTWFwXG5cbiAgICB9XG5cbiAgICBnZXRDYWNoZUl0ZW1NYXAoKSB7XG5cbiAgICAgICAgY29uc3QgY2FjaGVsaXN0ID0gbmV3IE1hcCgpXG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSA9IHZhbHVlXG5cbiAgICAgICAgICAgIGNhY2hlbGlzdC5zZXQoa2V5LHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVsaXN0XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgU0VSVklDRSBTVVBQT1JUIF09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBtb3ZlIGlzIGNvZXJjZWQgYnkgc2VydmljZWhhbmRsZXIgdG8gYmUgd2l0aGluIGN1cnJlbnQgbGlzdCBib3VuZHNcbiAgICBtb3ZlSW5kZXgodG9pbmRleCwgZnJvbWluZGV4LCBmcm9taGlnaGluZGV4ICkge1xuXG4gICAgICAgIGNvbnN0IHtpbmRleFRvSXRlbUlETWFwLG1ldGFkYXRhTWFwfSA9IHRoaXMuY2FjaGVQcm9wc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGRlZmluZSBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHJhbmdlYWJzb2x1dGVpbmNyZW1lbnQgPSBmcm9taGlnaGluZGV4IC0gZnJvbWluZGV4ICsgMVxuICAgICAgICBjb25zdCBtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgPSB0b2luZGV4IC0gZnJvbWluZGV4XG5cbiAgICAgICAgY29uc3QgdG9oaWdoaW5kZXggPSB0b2luZGV4ICsgKHJhbmdlYWJzb2x1dGVpbmNyZW1lbnQgLSAxKVxuXG4gICAgICAgIGNvbnN0IHNoaWZ0ZGlyZWN0aW9uID0gXG4gICAgICAgICAgICAobW92ZWRpcmVjdGlvbmFsaW5jcmVtZW50ID4gMCk/IC8vIG1vdmUgdXAgaW4gbGlzdFxuICAgICAgICAgICAgICAgIC0xOiAvLyBzaGlmdCBkb3duLCBtYWtlIHJvb20gZm9yIHNoaWZ0aW5naW5kZXggYWJvdmVcbiAgICAgICAgICAgICAgICAxICAgLy8gc2hpZnQgdXAsIG1ha2Ugcm9vbSBmb3Igc2hpZnRpbmdpbmRleCBiZWxvd1xuXG4gICAgICAgIGNvbnN0IG9yZGVyZWRpbmRleGxpc3QgPSBBcnJheS5mcm9tKGluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICBvcmRlcmVkaW5kZXhsaXN0LnNvcnQoKGEsYik9PmEtYilcblxuICAgICAgICBjb25zdCB0b2luZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gdG9pbmRleClcbiAgICAgICAgY29uc3QgdG9oaWdoaW5kZXhwdHIgPSBvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA+PSB0b2hpZ2hpbmRleClcbiAgICAgICAgY29uc3QgZnJvbWluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gZnJvbWluZGV4KVxuICAgICAgICBjb25zdCBmcm9taGlnaGluZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gZnJvbWhpZ2hpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIGNhcHR1cmUgaW5kZXggZGF0YSB0byBtb3ZlIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgcHJvY2Vzc3RvbW92ZUxpc3RcbiAgICAgICAgaWYgKChmcm9taW5kZXhwdHIgPT0gLTEpICYmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSkgeyAvLyBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IFtdXG5cbiAgICAgICAgfSBlbHNlIGlmIChmcm9taGlnaGluZGV4cHRyID09IC0xKSB7IC8vIHNjb3BlIGlzIHBhcnRpYWxseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taW5kZXhwdHIpXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc2NvcGUgaXMgZW50aXJlbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBwcm9jZXNzdG9tb3ZlTGlzdCA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWluZGV4cHRyLCBmcm9taGlnaGluZGV4cHRyICsgMSlcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc3RvbW92ZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBjYXB0dXJlbW92ZWluZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3N0b21vdmVMaXN0LmZvckVhY2goY2FwdHVyZW1vdmVpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGdldCBsaXN0IG9mIGluZGV4ZXMgdG8gc2hpZnQgb3V0IG9mIHRoZSB3YXkgLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICBsZXQgcHJvY2Vzc3Rvc2hpZnRMaXN0XG4gICAgICAgIGlmIChzaGlmdGRpcmVjdGlvbiA9PSAxKSB7IC8vIGJsb2NrIGlzIG1vdmluZyBkb3duLCBzaGlmdCBpcyB1cDsgdG9pbmRleCA8IGZyb21pbmRleFxuXG4gICAgICAgICAgICBpZiAoKHRvaW5kZXhwdHIgPT0gLTEpICYmIChmcm9taW5kZXhwdHIgPT0gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21pbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2luZGV4cHRyKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2luZGV4cHRyLCBmcm9taW5kZXhwdHIpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBzaGlmdGRpcmVjdGlvbiA9PSAtMTsgYmxvY2sgaXMgbW92aW5nIHVwLCBzaGlmdCBpcyBkb3duOyBmcm9taW5kZXggPCB0b2luZGV4XG5cbiAgICAgICAgICAgIGlmICh0b2hpZ2hpbmRleHB0ciA9PSAtMSAmJiBmcm9taGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvaGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc3Rvc2hpZnRMaXN0ID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taGlnaGluZGV4cHRyICsgMSwgdG9oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hpZnRkaXJlY3Rpb24gPT0gMSkgcHJvY2Vzc3Rvc2hpZnRMaXN0LnJldmVyc2UoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIG1vdmUgaW5kZXhlcyBvdXQgb2YgdGhlIHdheSAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZHNoaWZ0TGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IHByb2Nlc3NzaGlmdGluZGV4ID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IFxuICAgICAgICAgICAgICAgIChzaGlmdGRpcmVjdGlvbiA9PSAtMSk/XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC0gcmFuZ2VhYnNvbHV0ZWluY3JlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKyByYW5nZWFic29sdXRlaW5jcmVtZW50XG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LGl0ZW1JRClcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIHByb2Nlc3NlZHNoaWZ0TGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzdG9zaGlmdExpc3QuZm9yRWFjaChwcm9jZXNzc2hpZnRpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0gcmVwbGFjZSBzaGlmdGVkIGluZGV4IHNwYWNlIHdpdGggbW92ZWQgaW5kZXhlcyAtLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkbW92ZUxpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzbW92ZWluZGV4ID0gKGl0ZW1JRCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyBtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQgLy8gc3dhcFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkbW92ZUxpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5mb3JFYWNoKHByb2Nlc3Ntb3ZlaW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS1yZXR1cm4gbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlcyB0byBjYWxsZXIgLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIHN5bmNocm5pemF0aW9uIHdpdGggY3JhZGxlIGNlbGxGcmFtZXNcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleGVzID0gcHJvY2Vzc2Vkc2hpZnRMaXN0LmNvbmNhdChwcm9jZXNzZWRtb3ZlTGlzdClcblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhlc1xuXG4gICAgfVxuXG4gICAgLy8gbXVjaCBvZiB0aGlzIGRlYWxzIHdpdGggdGhlIGZhY3QgdGhhdCB0aGUgY2FjaGUgaXMgc3BhcnNlLlxuICAgIGluc2VydFJlbW92ZUluZGV4KGluZGV4LCBoaWdocmFuZ2UsIGluY3JlbWVudCwgbGlzdHNpemUpIHsgLy8gaW5jcmVtZW50IGlzICsxIG9yIC0xXG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwLCBtZXRhZGF0YU1hcCwgcG9ydGFsTWFwIH0gPSB0aGlzLmNhY2hlUHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSByYW5nZSBwYXJhbWV0ZXJzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhpZ2ggcmFuZ2UgaXMgdGhlIGhpZ2hlc3QgaW5kZXggbnVtYmVyIG9mIHRoZSBpbnNlcnQvcmVtb3ZlIG9wZXJhdGlvblxuICAgICAgICBsZXQgaGlnaHJhbmdlaW5kZXggPSBoaWdocmFuZ2UgPz8gMFxuXG4gICAgICAgIGhpZ2hyYW5nZWluZGV4ID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlaW5kZXggPiBpbmRleCk/XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXg6XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCBlbXB0eXJldHVybiA9IFtbXSxbXSwwXVxuICAgICAgICBpZiAoaW5jcmVtZW50ID09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92YWwgbXVzdCBiZSBlbnRpcmVseSB3aXRoaW4gc2NvcGUgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmIChoaWdocmFuZ2VpbmRleCA+IChsaXN0c2l6ZSAtIDEpKSByZXR1cm4gZW1wdHlyZXR1cm5cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBhZGRpdGlvbiBjYW4gYXQgbW9zdCBzdGFydCBhdCB0aGUgbmV4dCBpbmRleCBhYm92ZSB0aGUgY3VycmVudCBsaXN0XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBsaXN0c2l6ZSkgcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhbmdlY291bnQgaXMgdGhlIGFic29sdXRlIG51bWJlciBpbiB0aGUgaW5zZXJ0L3JlbW92ZSByYW5nZSAtIGNvbnRpZ3VvdXNcbiAgICAgICAgY29uc3QgcmFuZ2Vjb3VudCA9IGhpZ2hyYW5nZWluZGV4IC0gaW5kZXggKyAxXG5cbiAgICAgICAgLy8gcmFuZ2UgaW5jcmVtZW50IGFkZHMgc2lnbiB0byByYW5nZWNvdW50IHRvIGluZGljYXRlIGFkZC9yZW1vdmVcbiAgICAgICAgY29uc3QgcmFuZ2VpbmNyZW1lbnQgPSByYW5nZWNvdW50ICogaW5jcmVtZW50XG5cbiAgICAgICAgLy8gaGlnaFB0ciwgbG93UHRyLCBzaHJpbmt0b1B0ciB3aXRoaW4gb3JkZXJlZEluZGV4TGlzdC5cbiAgICAgICAgY29uc3Qgb3JkZXJlZEluZGV4TGlzdCA9IEFycmF5LmZyb20oaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIG9yZGVyZWRJbmRleExpc3Quc29ydCgoYSxiKT0+YS1iKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gZGVmaW5lIGJvdW5kYXJpZXMgd2l0aGluIG9yZGVyZWQgY2FjaGUgaW5kZXggbGlzdCAtLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUHRyID0gaW5kZXggaW50byBhcnJheSwgYXMgb3Bwb3NlZCB0byBpbmRleCBvZiB2aXJ0dWFsIGxpc3RcblxuICAgICAgICAvLyBzaHJpbmtwdHIgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBib3R0b20gb2YgdGhlIHNocmluayByYW5nZSBmb3IgcmVtb3ZhbHNcbiAgICAgICAgbGV0IHNocmlua3RvSW5kZXggPSBudWxsXG4gICAgICAgIGxldCBzaHJpbmt0b1B0ciA9IC0gMVxuICAgICAgICBcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAtIDEpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2hyaW5rdG9JbmRleCA9IG9yZGVyZWRJbmRleExpc3QuYXQoLTEpICsgKHJhbmdlaW5jcmVtZW50KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5tYXgoaGlnaHJhbmdlaW5kZXggKyAocmFuZ2VpbmNyZW1lbnQpLCBzaHJpbmt0b0luZGV4KVxuXG4gICAgICAgICAgICBzaHJpbmt0b0luZGV4ID0gTWF0aC5taW4obGlzdHNpemUgLSAxLHNocmlua3RvSW5kZXgpIFxuXG4gICAgICAgICAgICBzaHJpbmt0b1B0ciA9IG9yZGVyZWRJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHNocmlua3RvSW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvd1B0ciBhbmQgaGlnaFB0ciBtdXN0IGJlIHdpdGhpbiBsb3cgYW5kIGhpZ2ggcmFuZ2VcbiAgICAgICAgY29uc3QgbG93UHRyID0gb3JkZXJlZEluZGV4TGlzdC5maW5kSW5kZXgodmFsdWUgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlID49IGluZGV4KSAmJiAodmFsdWUgPD0gaGlnaHJhbmdlaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCByZXZlcnNlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShvcmRlcmVkSW5kZXhMaXN0KVxuICAgICAgICByZXZlcnNlSW5kZXhMaXN0LnJldmVyc2UoKVxuICAgICAgICBsZXQgaGlnaFB0ciA9IHJldmVyc2VJbmRleExpc3QuZmluZEluZGV4KHZhbHVlPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPD0gaGlnaHJhbmdlaW5kZXhcblxuICAgICAgICB9KVxuICAgICAgICBpZiAoaGlnaFB0ciAhPSAtMSkge1xuICAgICAgICAgICAgaGlnaFB0ciA9IChvcmRlcmVkSW5kZXhMaXN0Lmxlbmd0aCAtIDEpIC0gaGlnaFB0clxuICAgICAgICAgICAgaWYgKGhpZ2hQdHIgPCBsb3dQdHIpIGhpZ2hQdHIgPSAtMVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gbGlzdCBpbmRleGVzIHRvIHByb2Nlc3MsIHJlcGxhY2UsIGFuZCByZW1vdmUsIGFuZCBpdGVtcyB0byByZW1vdmUgLS0tLS0tLS1cblxuICAgICAgICBsZXQgaW5kZXhlc1RvUHJvY2Vzc0xpc3QsIC8vIGZvciBlaXRoZXIgaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBbXSwgLy8gZm9yIGluc2VydCB0aGUgcmFuZ2UgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBbXSwgLy8gZm9yIHJlbW92ZSAtIGVuZCBvZiBsaXN0OyB0aGUgbGlzdCBpcyBzaHJpbmtpbmdcbiAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0PSBbXSwgLy8gZm9yIHJlbW92ZSAtIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgaW5kZXhlcyBiZWluZyByZW1vdmVkXG4gICAgICAgICAgICBpdGVtc1RvUmVtb3ZlTGlzdCA9IFtdIC8vIGZvciByZW1vdmUsIGRlcml2ZWQgZnJvbSB0aGUgcHJldmlvdXNcblxuICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUHJvY2Vzc0xpc3RcbiAgICAgICAgaWYgKChsb3dQdHIgPT0gLTEpICYmIChoaWdoUHRyID09IC0xKSkgeyAvLyBjb3JlIHNjb3BlIGlzIG91dCBvZiB2aWV3XG5cbiAgICAgICAgICAgIGluZGV4ZXNUb1Byb2Nlc3NMaXN0ID0gW11cblxuICAgICAgICB9IGVsc2UgeyAvLyBjb3JlIHNjb3BlIGlzIHBhcnRpYWxseSBvciBmdWxseSBpbiB2aWV3OyBsb3dQdHIgaXMgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBvcmRlcmVkSW5kZXhMaXN0LnNsaWNlKGxvd1B0cilcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaWdoUHRyID09IC0xKSB7IC8vIGluY3JlbWVudCA9PSAtMTsgbG93UHRyIGlzIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUHJvY2Vzc0xpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbmNyZW1lbnQgPT0gLTE7IGxvd1B0ciBhbmQgaGlnaFB0ciBhcmUgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UoaGlnaFB0ciArIDEpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9ydGFsSG9sZExpc3QgPSBbXSAvLyBob2xkIHBvcnRhbHMgZm9yIGRlbGV0aW9uIHVudGlsIGFmdGVyIGFmdGVyIGNyYWRsZSBzeW5jaFxuXG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT0gMSkge1xuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUmVwbGFjZUxpc3RcbiAgICAgICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9SZXBsYWNlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyLCBoaWdoUHRyICsgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc1RvUmVtb3ZlTGlzdFxuICAgICAgICAgICAgaWYgKHNocmlua3RvUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2Uoc2hyaW5rdG9QdHIgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3RcbiAgICAgICAgICAgIGlmICgobG93UHRyID09IC0xKSAmJiAoaGlnaFB0ciA9PSAtMSkpIHsgLy8gY29yZSBzY29wZSBpcyBvdXQgb2Ygdmlld1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0ID0gb3JkZXJlZEluZGV4TGlzdC5zbGljZShsb3dQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzT2ZJdGVtc1RvUmVtb3ZlTGlzdCA9IG9yZGVyZWRJbmRleExpc3Quc2xpY2UobG93UHRyLCBoaWdoUHRyICsgMSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgaXRlbXNUb1JlbW92ZUxpc3RcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc09mSXRlbXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIGl0ZW1zVG9SZW1vdmVMaXN0LnB1c2goaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGNvbmR1Y3QgY2FjaGUgb3BlcmF0aW9ucyAtLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGhpZ2hlciBmcm9tIHRvcCBvZiBsaXN0IHRvIHByZXNlcnZlIGxvd2VyIHZhbHVlcyBmb3Igc3Vic2VxdWVudCBpbmNyZW1lbnRcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSBpbmRleGVzVG9Qcm9jZXNzTGlzdC5yZXZlcnNlKCkgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc01vZGlmaWVkTGlzdCA9IFtdXG5cbiAgICAgICAgLy8gbW9kaWZ5IGluZGV4LXRvLWl0ZW1pZCBtYXAsIGFuZCBtZXRhZGF0YSBtYXBcbiAgICAgICAgY29uc3QgcHJvY2Vzc0luZGV4ID0gaW5kZXggPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyByYW5nZWluY3JlbWVudFxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgaW5kZXhlc01vZGlmaWVkTGlzdC5wdXNoKG5ld0luZGV4KVxuXG4gICAgICAgIH1cblxuICAgICAgICBpbmRleGVzVG9Qcm9jZXNzTGlzdC5mb3JFYWNoKHByb2Nlc3NJbmRleClcblxuICAgICAgICAvLyBkZWxldGUgcmVtYWluaW5nIGluZGV4ZXMgYW5kIGl0ZW1zIG5vdyBkdXBsaWNhdGVzXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSAxKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc1RvUmVwbGFjZUxpc3QpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtSUQgb2YgaXRlbXNUb1JlbW92ZUxpc3QpIHtcblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsSG9sZExpc3QucHVzaChpdGVtSUQpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlcyBmb3IgY2FsbGVyIHRvIHNlbmQgdG8gY29udGVudGhhbmRsZXIgZm9yIGNyYWRsZSBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgcmV0dXJuIFtpbmRleGVzTW9kaWZpZWRMaXN0LCBpbmRleGVzVG9SZXBsYWNlTGlzdCwgcmFuZ2VpbmNyZW1lbnQsIHBvcnRhbEhvbGRMaXN0XVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIElORElWSURVQUwgUE9SVEFMIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVzZWQgZm9yIHNpemUgY2FsY3VsYXRpb24gaW4gcGFyZUNhY2hlVG9NYXhcbiAgICAvLyByZWdpc3RlcnMgaW5kZXhlcyB3aGVuIHJlcXVlc3RlZCBidXQgYmVmb3JlIHJldHJpZXZlZCBhbmQgZW50ZXJlZCBpbnRvIGNhY2hlXG4gICAgcmVnaXN0ZXJSZXF1ZXN0ZWRQb3J0YWwoaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMucmVxdWVzdGVkU2V0LmFkZChpbmRleClcblxuICAgIH1cblxuICAgIHJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5yZXF1ZXN0ZWRTZXQuZGVsZXRlKGluZGV4KVxuXG4gICAgfVxuXG4gICAgZ2V0TmV3SXRlbUlEKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsSXRlbUlEKytcbiAgICB9XG5cbiAgICAvLyBnZXQgbmV3IG9yIGV4aXN0aW5nIGl0ZW1JRCBmb3IgY29udGVudGZ1bmN0aW9ucy5jcmVhdGVDZWxsXG4gICAgZ2V0TmV3T3JFeGlzdGluZ0l0ZW1JRChpbmRleCkge1xuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gXG4gICAgICAgICAgICAoaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKT9cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCk6XG4gICAgICAgICAgICAgICAgKHRoaXMuZ2V0TmV3SXRlbUlEKCkpXG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JRFxuXG4gICAgfVxuXG4gICAgY3JlYXRlUG9ydGFsKGNvbXBvbmVudCwgaW5kZXgsIGl0ZW1JRCwgaXNQcmVsb2FkID0gZmFsc2UpIHsgLy8gY3JlYXRlIG5ldyBwb3J0YWxcblxuICAgICAgICB0aGlzLnJlbW92ZVJlcXVlc3RlZFBvcnRhbChpbmRleClcblxuICAgICAgICBjb25zdCBwb3J0YWxOb2RlID0gY3JlYXRlUG9ydGFsTm9kZShpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgIC8vIGRpdiB3cmFwcGVyIHRvIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5wb3J0YWxNYXAuc2V0KGl0ZW1JRCxcbiAgICAgICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9IHsncG9ydGFsd3JhcHBlcid9IGtleSA9IHtpdGVtSUR9IGRhdGEtaXRlbWlkID0ge2l0ZW1JRH0gZGF0YS1pbmRleCA9IHtpbmRleH0+XG4gICAgICAgICAgICAgICAgICAgIDxJblBvcnRhbCBrZXkgPSB7aXRlbUlEfSBub2RlID0ge3BvcnRhbE5vZGV9ID4geyBjb21wb25lbnQgfSA8L0luUG9ydGFsPlxuICAgICAgICAgICAgICAgIDwvZGl2PilcblxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgY29uc3QgcG9ydGFsTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBwb3J0YWxOb2RlLFxuICAgICAgICAgICAgaXNSZXBhcmVudGluZ1JlZjp7XG4gICAgICAgICAgICAgICAgY3VycmVudDpmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGl0ZW1JRCxcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcy5tZXRhZGF0YU1hcC5zZXQoaXRlbUlELCBwb3J0YWxNZXRhZGF0YSlcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzLmluZGV4VG9JdGVtSURNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgaWYgKCFpc1ByZWxvYWQpIHRoaXMucmVuZGVyUG9ydGFsTGlzdCgpXG5cbiAgICAgICAgcmV0dXJuIHBvcnRhbE1ldGFkYXRhXG5cbiAgICB9XG5cbiAgICAvLyBhbHdheXMgZm9yIG5ldyBpdGVtXG4gICAgcHJpdmF0ZSBhc3luYyBwcmVsb2FkSXRlbShcbiAgICAgICAgaW5kZXgsIFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgc2Nyb2xsZXJQYXNzdGhyb3VnaFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBpdGVtRXhjZXB0aW9uc0NhbGxiYWNrLFxuICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdCxcbiAgICAgICAgc2Nyb2xsZXJJRFxuICAgICkge1xuXG4gICAgICAgIGNvbnN0IGl0ZW1JRCA9IHRoaXMuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICBsZXQgcmV0dXJudmFsdWUsIHVzZXJjb250ZW50LCBlcnJvclxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIHVzZXJjb250ZW50ID0gYXdhaXQgZ2V0SXRlbShpbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSBudWxsKSByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVycm9yID0gZVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudCh1c2VyY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm52YWx1ZSA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBSZWFjdCBlbGVtZW50JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgIGxldCBjb250ZW50IFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsZXJQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIGlzUmVwYXJlbnRpbmdSZWY6bnVsbCxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyY29udGVudC5wcm9wcy5oYXNPd25Qcm9wZXJ0eSgnc2Nyb2xsZXJQcm9wZXJ0aWVzJykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KHVzZXJjb250ZW50LCB7c2Nyb2xsZXJQcm9wZXJ0aWVzfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHVzZXJjb250ZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBvcnRhbERhdGEgPSBcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcnRhbChjb250ZW50LCBpbmRleCwgaXRlbUlELCB0cnVlKSAvLyB0cnVlID0gaXNQcmVsb2FkXG4gICAgICAgICAgICAvLyBtYWtlIGF2YWlsYWJsZSB0byB1c2VyIGNvbnRlbnRcbiAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllcy5pc1JlcGFyZW50aW5nUmVmID0gcG9ydGFsRGF0YS5pc1JlcGFyZW50aW5nUmVmXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2soaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdwcmVsb2FkJywgZXJyb3IpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZXJjb250ZW50ID09PSBudWxsOyBsYXN0IGl0ZW0gaW4gbGlzdFxuXG4gICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayhpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ3ByZWxvYWQnLCBuZXcgRXJyb3IoJ2VuZCBvZiBsaXN0JykpXG5cbiAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdChpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBhIHBvcnRhbCBsaXN0IGl0ZW1cbiAgICAvLyBhY2NlcHRzIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICBkZWxldGVQb3J0YWwoaW5kZXgsIGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuXG4gICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBcbiAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShpbmRleCkpP1xuICAgICAgICAgICAgICAgIFtpbmRleF06XG4gICAgICAgICAgICAgICAgaW5kZXhcblxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsXG4gICAgICAgICAgICBwb3J0YWxNYXAsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIFxuICAgICAgICB9ID0gdGhpcy5jYWNoZVByb3BzXG5cbiAgICAgICAgY29uc3QgZGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgb2YgaW5kZXhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaSlcbiAgICAgICAgICAgIGRlbGV0ZUxpc3QucHVzaCh7aW5kZXg6aSxpdGVtSUR9KVxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuZGVsZXRlKGl0ZW1JRClcbiAgICAgICAgICAgIHBvcnRhbE1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG5cbiAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrICYmIGRlbGV0ZUxpc3RDYWxsYmFjayhkZWxldGVMaXN0KVxuXG4gICAgfVxuXG4gICAgLy8gcXVlcnkgZXhpc3RlbmNlIG9mIGEgcG9ydGFsIGxpc3QgaXRlbVxuICAgIGhhc1BvcnRhbChpdGVtSUQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVByb3BzLm1ldGFkYXRhTWFwLmhhcyhpdGVtSUQpXG5cbiAgICB9XG5cbiAgICBnZXRQb3J0YWwoaXRlbUlEKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUG9ydGFsKGl0ZW1JRCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUHJvcHMubWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBVdGlsaXR5IGZ1bmN0aW9uIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIGdldCBhIHJlYWN0LXJldmVyc2UtcG9ydGFsIEluUG9ydGFsIGNvbXBvbmVudCwgd2l0aCBpdHMgbWV0YWRhdGFcbi8vIHdpdGggdXNlciBjb250ZW50IGFuZCBjb250YWluZXJcbmNvbnN0IGNyZWF0ZVBvcnRhbE5vZGUgPSAoaW5kZXgsIGl0ZW1JRCkgPT4ge1xuXG4gICAgbGV0IHBvcnRhbE5vZGUgPSBjcmVhdGVIdG1sUG9ydGFsTm9kZSgpXG5cbiAgICBsZXQgY29udGFpbmVyID0gcG9ydGFsTm9kZS5lbGVtZW50XG4gICAgY29udGFpbmVyLnN0eWxlLmluc2V0ID0gJzBweCcgXG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGNvbnRhaW5lci5kYXRhc2V0LnR5cGUgPSAnY29udGVudGVudmVsb3BlJ1xuICAgIGNvbnRhaW5lci5kYXRhc2V0LmluZGV4ID0gaW5kZXhcbiAgICBjb250YWluZXIuZGF0YXNldC5jYWNoZWl0ZW1pZCA9IGl0ZW1JRFxuXG4gICAgcmV0dXJuIHBvcnRhbE5vZGVcblxufSAgICAgXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBjb21wb25lbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5sZXQgY291bnRlciA9IDBcbi8vIHBvcnRhbCBsaXN0IGNvbXBvbmVudCBmb3IgcmFwaWQgcmVsaXN0aW5nIG9mIHVwZGF0ZXMsIHVzaW5nIGV4dGVybmFsIGNhbGxiYWNrIGZvciBzZXQgc3RhdGVcbmV4cG9ydCBjb25zdCBQb3J0YWxMaXN0ID0gKHsgY2FjaGVQcm9wcyB9KSA9PiB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygncnVubmluZyBQT1JUQUxMSVNUJywgJy0nK2NhY2hlUHJvcHMuc2Nyb2xsZXJJRCsnLScpXG5cbiAgICBjb25zdCBbcG9ydGFsTGlzdCwgc2V0UG9ydGFsTGlzdF0gPSB1c2VTdGF0ZShudWxsKVxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuICAgIGNvbnN0IHBvcnRhbEFycmF5UmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gY29uc3QgY2FjaGVkaXZSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgICAgIGNhY2hlUHJvcHMuc2V0TGlzdFN0YXRlID0gKCk9PntcblxuICAgICAgICAgICAgcG9ydGFsQXJyYXlSZWYuY3VycmVudCA9IGNhY2hlUHJvcHMucG9ydGFsTGlzdFxuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRQb3J0YWxMaXN0KGNvdW50ZXIrKykgLy8gbGlnaHQgY29udGVudHNcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSAvLyBkZWZlbnNpdmVcblxuICAgICAgICB9XG5cbiAgICB9LFtdKSBcblxuICAgIHJldHVybiBwb3J0YWxBcnJheVJlZi5jdXJyZW50XG5cbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxJdGVtSUQiLCJDYWNoZUhhbmRsZXIiLCJzY3JvbGxlcklEIiwic2V0TGlzdHNpemUiLCJsaXN0c2l6ZVJlZiIsInNldExpc3RTdGF0ZSIsIm1vZGlmaWVkIiwibWV0YWRhdGFNYXAiLCJNYXAiLCJyZXF1ZXN0ZWRTZXQiLCJTZXQiLCJwb3J0YWxNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwicG9ydGFsTGlzdCIsIm5ld2xpc3RzaXplIiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiY2hhbmdlTGlzdHNpemVDYWxsYmFjayIsInBvcnRhbEluZGV4TWFwIiwiY2FjaGVQcm9wcyIsIm1hcGtleXNMaXN0IiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJhIiwiYiIsImhpZ2hlc3RpbmRleCIsImF0IiwicGFyZWxpc3QiLCJmaWx0ZXIiLCJpbmRleCIsImRlbGV0ZVBvcnRhbCIsImNsZWFyIiwicmVuZGVyUG9ydGFsTGlzdCIsInZhbHVlcyIsImNyYWRsZUluZGV4TGlzdCIsIm1hcGtleXMiLCJkZWxrZXlzIiwiaW5jbHVkZXMiLCJrZXkiLCJsZW5ndGgiLCJjYWNoZU1heCIsInVuZGVmaW5lZCIsIm1vZGVsTGVuZ3RoIiwibWF4IiwiTWF0aCIsInBvcnRhbEluZGV4TGlzdCIsInNpemUiLCJtYXBrZXlzbGlzdCIsInJlcXVlc3RlZGtleXMiLCJjb25jYXQiLCJtYXBMZW5ndGgiLCJwYXJlY291bnQiLCJoZWFkaW5kZXgiLCJ0YWlsaW5kZXgiLCJoZWFkcG9zIiwiaW5kZXhPZiIsInRhaWxwb3MiLCJoZWFkcm9vbSIsInRhaWxyb29tIiwicGFyZXJvb20iLCJoZWFkcGFyZWNvdW50IiwiZmxvb3IiLCJ0YWlscGFyZWNvdW50IiwiaGVhZGxpc3QiLCJzbGljZSIsInRhaWxsaXN0IiwiZGVsTGlzdCIsImNyYWRsZUxpc3RMZW5ndGgiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJjcmFkbGVQYXJhbWV0ZXJzIiwiZmluYWxDYWxsYmFjayIsIm51bGxJdGVtU2V0TWF4TGlzdHNpemUiLCJzY3JvbGxlclBhc3N0aHJvdWdoUHJvcGVydGllc1JlZiIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsInN0YXRlSGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJnZXRJdGVtIiwibGlzdHNpemUiLCJwcm9taXNlcyIsImNhY2hlU2l6ZSIsIm1pbiIsInByZWxvYWRzaXplIiwiYnJlYWtsb29wIiwibWF4TGlzdHNpemVJbnRlcnJ1cHQiLCJpc01vdW50ZWRSZWYiLCJjYWxsYmFja3MiLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsIml0ZW1FeGNlcHRpb25zQ2FsbGJhY2siLCJoYXMiLCJwcm9taXNlIiwicHJlbG9hZEl0ZW0iLCJwdXNoIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJ0aGVuIiwiY3JhZGxlTWFwIiwic2V0IiwiZ2V0IiwiY2FjaGVsaXN0IiwidmFsdWUiLCJjb21wb25lbnQiLCJ0b2luZGV4IiwiZnJvbWluZGV4IiwiZnJvbWhpZ2hpbmRleCIsInJhbmdlYWJzb2x1dGVpbmNyZW1lbnQiLCJtb3ZlZGlyZWN0aW9uYWxpbmNyZW1lbnQiLCJ0b2hpZ2hpbmRleCIsInNoaWZ0ZGlyZWN0aW9uIiwib3JkZXJlZGluZGV4bGlzdCIsInRvaW5kZXhwdHIiLCJmaW5kSW5kZXgiLCJ0b2hpZ2hpbmRleHB0ciIsImZyb21pbmRleHB0ciIsImZyb21oaWdoaW5kZXhwdHIiLCJwcm9jZXNzdG9tb3ZlTGlzdCIsInByb2Nlc3N0b21vdmVNYXAiLCJjYXB0dXJlbW92ZWluZGV4IiwiZm9yRWFjaCIsInByb2Nlc3N0b3NoaWZ0TGlzdCIsInJldmVyc2UiLCJwcm9jZXNzZWRzaGlmdExpc3QiLCJwcm9jZXNzc2hpZnRpbmRleCIsIml0ZW1JRCIsIm5ld0luZGV4IiwicHJvY2Vzc2VkbW92ZUxpc3QiLCJwcm9jZXNzbW92ZWluZGV4IiwicHJvY2Vzc2VkSW5kZXhlcyIsImhpZ2hyYW5nZSIsImluY3JlbWVudCIsImhpZ2hyYW5nZWluZGV4IiwiZW1wdHlyZXR1cm4iLCJyYW5nZWNvdW50IiwicmFuZ2VpbmNyZW1lbnQiLCJvcmRlcmVkSW5kZXhMaXN0Iiwic2hyaW5rdG9JbmRleCIsInNocmlua3RvUHRyIiwibG93UHRyIiwicmV2ZXJzZUluZGV4TGlzdCIsImhpZ2hQdHIiLCJpbmRleGVzVG9Qcm9jZXNzTGlzdCIsImluZGV4ZXNUb1JlcGxhY2VMaXN0IiwiaW5kZXhlc1RvUmVtb3ZlTGlzdCIsImluZGV4ZXNPZkl0ZW1zVG9SZW1vdmVMaXN0IiwiaXRlbXNUb1JlbW92ZUxpc3QiLCJwb3J0YWxIb2xkTGlzdCIsImluZGV4ZXNNb2RpZmllZExpc3QiLCJwcm9jZXNzSW5kZXgiLCJhZGQiLCJnZXROZXdJdGVtSUQiLCJpc1ByZWxvYWQiLCJyZW1vdmVSZXF1ZXN0ZWRQb3J0YWwiLCJwb3J0YWxOb2RlIiwiY3JlYXRlUG9ydGFsTm9kZSIsInJlYWN0XzEiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwibm9kZSIsInBvcnRhbE1ldGFkYXRhIiwiaXNSZXBhcmVudGluZ1JlZiIsInVzZXJjb250ZW50IiwicmV0dXJudmFsdWUiLCJlcnJvciIsImlzVmFsaWRFbGVtZW50IiwiRXJyb3IiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwcm9wcyIsImhhc093blByb3BlcnR5IiwiY29udGVudCIsImNsb25lRWxlbWVudCIsInBvcnRhbERhdGEiLCJjcmVhdGVQb3J0YWwiLCJpbmRleEFycmF5IiwiaXNBcnJheSIsImRlbGV0ZUxpc3QiLCJpIiwiaGFzUG9ydGFsIiwiZXhwb3J0cyIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzdHlsZSIsImluc2V0IiwicG9zaXRpb24iLCJkYXRhc2V0IiwidHlwZSIsImNhY2hlaXRlbWlkIiwiY291bnRlciIsIlBvcnRhbExpc3QiLCJzZXRQb3J0YWxMaXN0IiwicG9ydGFsQXJyYXlSZWYiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/cachehandler.tsx\n");

/***/ }),

/***/ "./src/cradle/contentfunctions.tsx":
/*!*****************************************!*\
  !*** ./src/cradle/contentfunctions.tsx ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // contentfunctions.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calcContentShift = exports.getShiftInstruction = exports.getContentListRequirements = void 0;\n/******************************************************************************************\n ------------------------------------[ SUPPORTING FUNCTIONS ]------------------------------\n*******************************************************************************************/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\")); // ======================[ for setCradleContent ]===========================\n\n\nvar getContentListRequirements = function getContentListRequirements(_ref) {\n  var rowLength = _ref.rowLength,\n      cradleInheritedProperties = _ref.cradleInheritedProperties,\n      cradleInternalProperties = _ref.cradleInternalProperties,\n      targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n      targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset;\n  var orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      gap = cradleInheritedProperties.gap,\n      padding = cradleInheritedProperties.padding;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount,\n      listRowcount = cradleInternalProperties.listRowcount,\n      listsize = cradleInternalProperties.listsize,\n      viewportVisibleRowcount = cradleInternalProperties.viewportVisibleRowcount; // align axis reference to first row item\n  // const origrefindex = targetAxisReferenceIndex\n\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listsize - 1);\n  targetAxisReferenceIndex -= targetAxisReferenceIndex % crosscount; // derive target row\n\n  var targetAxisRowOffset = Math.ceil(targetAxisReferenceIndex / crosscount);\n  var maxAxisRowOffset = Math.max(0, listRowcount - viewportVisibleRowcount);\n\n  if (targetAxisRowOffset > maxAxisRowOffset) {\n    targetAxisRowOffset = maxAxisRowOffset;\n    targetAxisReferenceIndex = targetAxisRowOffset * crosscount;\n  } // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n  // let targetCradleReferenceIndex = Math.max(0,targetAxisReferenceIndex - leadingrunwayitemcount)\n\n\n  var targetCradleRowOffset = Math.max(0, targetAxisRowOffset - runwayRowcount); // trailing edge\n\n  var targetCradleEndRowOffset = targetCradleRowOffset + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1;\n\n  if (targetCradleEndRowOffset > listEndRowOffset) {\n    var diff = targetCradleEndRowOffset - listEndRowOffset;\n    targetCradleRowOffset -= diff;\n    targetCradleEndRowOffset -= diff;\n  }\n\n  var targetCradleReferenceIndex = targetCradleRowOffset * crosscount; // ---------------------[ calc cradle content count ]---------------------\n\n  var newCradleContentCount = cradleRowcount * crosscount;\n\n  if (targetCradleEndRowOffset == listEndRowOffset) {\n    var endRowRemainderCount = listsize % crosscount;\n\n    if (endRowRemainderCount) {\n      newCradleContentCount -= crosscount - endRowRemainderCount;\n    }\n  } // --------------------[ calc css positioning ]-----------------------\n\n\n  var targetScrollblockViewportPixelOffset = targetAxisRowOffset * rowLength + padding - targetAxisViewportPixelOffset; // ----------------------[ return required values ]---------------------\n\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetAxisRowOffset: targetAxisRowOffset,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\n\nexports.getContentListRequirements = getContentListRequirements; // ======================[ for updateCradleContent ]===========================\n\n/*\n    - If the top of the cell row moves beyond the viewport boundary, then the\n        content should push the cell boundary up\n    - If the top of the cell row moves into the viewport boundary, then the\n        content should push the cell boundary down\n*/\n// -1 = shift row to head. 1 = shift row to tail. 0 = do not shift a row.\n\nvar getShiftInstruction = function getShiftInstruction(_ref2) {\n  var isViewportScrollingForward = _ref2.isViewportScrollingForward,\n      orientation = _ref2.orientation,\n      triggerlineEntries = _ref2.triggerlineEntries,\n      triggerlineSpan = _ref2.triggerlineSpan,\n      scrollerID = _ref2.scrollerID;\n  var driver = isViewportScrollingForward ? 'triggerline-axis' : 'triggerline-head';\n  var entries = triggerlineEntries.filter(function (entry) {\n    // const isIntersecting = entry.isIntersecting\n    var triggerlinename = entry.target.dataset.type;\n    entry.triggerlinename = triggerlinename; // memo for processing and console\n\n    entry.scrollingforward = isViewportScrollingForward; // memo for console\n\n    var rootpos = orientation == 'vertical' ? entry.rootBounds.y : entry.rootBounds.x;\n    var entrypos = orientation == 'vertical' ? entry.boundingClientRect.y : entry.boundingClientRect.x;\n    var viewportoffsethead = entrypos - rootpos;\n    entry.viewportoffsethead = viewportoffsethead;\n\n    if (triggerlinename == 'triggerline-tail') {\n      var rootpostail = orientation == 'vertical' ? entry.rootBounds.y + entry.rootBounds.height : entry.rootBounds.x + entry.rootBounds.width;\n      var viewportoffsettail = rootpostail - entrypos;\n      entry.viewportoffsettail = viewportoffsettail;\n    } // axis needs to be moved if:\n\n\n    return (// - axis triggerline goes out of scope, or...\n      driver == 'triggerline-axis' && viewportoffsethead <= 0 || // - head triggerline comes into scope\n      driver == 'triggerline-head' && viewportoffsethead >= 0\n    );\n  });\n  var retval; // the triggerline might have passed through the viewport completely without the\n  // change being triggered, eg. not intersecting, passing through viewport, then\n  //    not intersecting again before being intercepted\n  // in this case we rely on the counter entry to provide information\n\n  if (entries.length == 0) {\n    // short-circuit the evaluation\n    var counterdriver = !isViewportScrollingForward ? 'triggerline-axis' : 'triggerline-head';\n    var counterentries = triggerlineEntries.filter(function (entry) {\n      return entry.triggerlinename == counterdriver;\n    });\n\n    if (counterentries.length == 0) {\n      retval = 0;\n      var backupdriver = 'triggerline-tail';\n      var backupentries = triggerlineEntries.filter(function (entry) {\n        return entry.triggerlinename == backupdriver;\n      });\n\n      if (backupentries.length != 0) {\n        var entry = backupentries.pop();\n      }\n    } else {\n      // check for implied trigger - trigger can be bypassed with heavy components\n      var counterentry = counterentries.pop();\n      var countertriggerlinename = counterentry.triggerlinename;\n      var impliedoffsethead;\n\n      if (countertriggerlinename == 'triggerline-head') {\n        impliedoffsethead = counterentry.viewportoffsethead + triggerlineSpan;\n\n        if (impliedoffsethead <= 0) {\n          retval = -1;\n        }\n      } else {\n        // countertriggerlinename == 'triggerline-axis'\n        impliedoffsethead = counterentry.viewportoffsethead - triggerlineSpan;\n\n        if (impliedoffsethead >= 0) {\n          retval = 1;\n        }\n      }\n    }\n\n    retval = 0;\n  } else {\n    // complete the evaluation\n    var _entry = entries[0]; // assume one record gets filtered; only paired above on reconnect\n    // if (!isViewportScrollingForward) {\n\n    if (driver == 'triggerline-head') {\n      retval = 1; // shift row to tail\n    } else {\n      retval = -1; // shift row to head\n    }\n  }\n\n  console.log('==> getShiftInstruction: isViewportScrollingForward, driver, instruction, triggerlineEntries, filteredEntries', '-' + scrollerID + '-', '\\n', isViewportScrollingForward, driver, retval, '\\n', triggerlineEntries, entries);\n  return retval;\n};\n\nexports.getShiftInstruction = getShiftInstruction; // A negative shift instruction is into the head, a positive shift is into the tail.\n// called only from updateCradleContent\n\nvar calcContentShift = function calcContentShift(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n      cradleInheritedProperties = _ref3.cradleInheritedProperties,\n      cradleInternalProperties = _ref3.cradleInternalProperties,\n      cradleContent = _ref3.cradleContent,\n      cradleElements = _ref3.cradleElements,\n      scrollPos = _ref3.scrollPos;\n\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n\n  var isScrollingViewportForward = shiftinstruction < 0;\n  var gap = cradleInheritedProperties.gap,\n      orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      triggerlineOffset = cradleInheritedProperties.triggerlineOffset;\n  var axisElement = cradleElements.axisRef.current;\n  var cradlecontentlist = cradleContent.cradleModelComponents,\n      tailcontentlist = cradleContent.tailModelComponents;\n  var crosscount = cradleInternalProperties.crosscount,\n      cradleRowcount = cradleInternalProperties.cradleRowcount,\n      listsize = cradleInternalProperties.listsize,\n      listRowcount = cradleInternalProperties.listRowcount,\n      viewportRowcount = cradleInternalProperties.viewportRowcount,\n      runwayRowcount = cradleInternalProperties.runwayRowcount;\n  var rowLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap; // -----------[ 2. calculate axis reference row shift ]-------------------\n  // extra gaps can be caused by rapid scrolling\n\n  var cradleAxisOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft; // viewportAxisOffset will be negative for scroll forward and positive for scroll backward\n\n  var viewportAxisOffset = // the pixel distance between the viewport frame and the axis, toward the head\n  cradleAxisOffset - scrollPos;\n  var triggerAxisOffset = isScrollingViewportForward ? // scroll forward engages the tail triggerline which is below the axis\n  // the tail triggerline must be placed to intersect to re-trigger\n  viewportAxisOffset + triggerlineOffset : // scrollbackward engages the head triggerline which is above the axis\n  // the head triggerline muse be placed not to intersect to retrigger\n  viewportAxisOffset - (rowLength - triggerlineOffset); // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n  // +/- 1 gurantees boundary location results in move\n\n  var triggerRowShift = isScrollingViewportForward ? Math.floor((triggerAxisOffset ? triggerAxisOffset : -1) / rowLength) : Math.ceil((triggerAxisOffset ? triggerAxisOffset : 1) / rowLength);\n  var axisReferenceRowshift = -triggerRowShift; // ------------[ 5. calc new cradle and axis reference row offset ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n\n  var cradleReferenceRowshift = axisReferenceRowshift;\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n  var previousCradleRowOffset = Math.ceil(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n  var previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount); // base values\n\n  var newCradleReferenceRowOffset = previousCradleRowOffset + cradleReferenceRowshift;\n  var newAxisReferenceRowOffset = previousAxisRowOffset + axisReferenceRowshift; // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n\n  var listEndrowOffset = listRowcount - 1;\n\n  if (isScrollingViewportForward) {\n    // a. if scrolling forward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling forward (toward tail of list), as the cradle last row offset approaches \n    // listrow new cradle offset and cradle row shift have to be adjusted to prevent shortening \n    // of cradle content.\n    var targetCradleReferenceRowOffset = Math.max(0, newAxisReferenceRowOffset - runwayRowcount - 1 // runwayRowcount + \n    // (runwayRowcount?-1:0) // one row is visible, not runway\n    ); // console.log('calcContentShift: targetCradleReferenceRowOffset, newAxisReferenceRowOffset, runwayRowcount',\n    //     targetCradleReferenceRowOffset, newAxisReferenceRowOffset, runwayRowcount)\n\n    var headrowDiff = newCradleReferenceRowOffset - targetCradleReferenceRowOffset;\n\n    if (headrowDiff > 0) {\n      newCradleReferenceRowOffset -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    } // case of being in bounds of trailing runway (end of list)\n\n\n    var targetCradleEndrowOffset = newCradleReferenceRowOffset + (cradleRowcount - 1);\n    var tailrowdiff = Math.max(0, targetCradleEndrowOffset - listEndrowOffset);\n\n    if (tailrowdiff > 0) {\n      newCradleReferenceRowOffset -= tailrowdiff;\n      cradleReferenceRowshift -= tailrowdiff;\n    }\n  } else {\n    // !isScrollingViewportForward = scroll backward\n    // c. if scrolling backward (toward head of list), as the cradlerowoffset hits 0, cradle changes have\n    // to be adjusted to prevent shortening of cradle content\n    // d. if scrolling backward near the end of the list, cradle changes has to be adjusted to accomodate\n    // the trailing runway\n    if (newCradleReferenceRowOffset < 0) {\n      cradleReferenceRowshift -= newCradleReferenceRowOffset;\n      newCradleReferenceRowOffset = 0;\n    } // case of in bounds of trailing runway (end of list)\n\n\n    var computedNextCradleEndrowOffset = previousCradleRowOffset + (cradleRowcount - 1) + cradleReferenceRowshift;\n    var targetcradleEndrowoffset = Math.min(listEndrowOffset, newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1));\n\n    var _tailrowdiff = Math.max(0, targetcradleEndrowoffset - computedNextCradleEndrowOffset);\n\n    if (_tailrowdiff > 0) {\n      cradleReferenceRowshift += _tailrowdiff;\n      newCradleReferenceRowOffset += _tailrowdiff;\n    }\n  } // ----------------------[ 7. map rows to item references ]----------------------\n\n\n  var newCradleReferenceIndex = newCradleReferenceRowOffset * crosscount;\n  var cradleReferenceItemShift = cradleReferenceRowshift * crosscount;\n  var newAxisReferenceIndex = newAxisReferenceRowOffset * crosscount;\n  var axisReferenceItemShift = axisReferenceRowshift * crosscount;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n\n  var includesLastRow = newCradleReferenceRowOffset + cradleRowcount >= listRowcount;\n\n  if (includesLastRow) {\n    var partialspaces = listsize % crosscount;\n    var itemsShortfall = partialspaces == 0 ? 0 : crosscount - partialspaces;\n    newCradleContentCount -= itemsShortfall;\n  } // create head and tail change counts\n\n\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount; // -------------[ 8. calculate new axis pixel position ]------------------\n\n  var newAxisPixelOffset = viewportAxisOffset + axisReferenceRowshift * rowLength; // ---------------------[ 9. return required values ]-------------------\n  //     console.log('calcContentShift',\n  // `\n  //         newCradleReferenceIndex, \n  //         cradleReferenceItemShift, \n  //         newAxisReferenceIndex, \n  //         axisReferenceItemShift, \n  //         newAxisPixelOffset, \n  //         newCradleContentCount,\n  //         listStartChangeCount,\n  //         listEndChangeCount\n  // `,\n  //         newCradleReferenceIndex, \n  //         cradleReferenceItemShift, \n  //         newAxisReferenceIndex, \n  //         axisReferenceItemShift, \n  //         newAxisPixelOffset, \n  //         newCradleContentCount,\n  //         listStartChangeCount,\n  //         listEndChangeCount\n  // )\n\n  return {\n    newCradleReferenceIndex: newCradleReferenceIndex,\n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisPixelOffset: newAxisPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\n\nexports.calcContentShift = calcContentShift; // =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n      cradleInternalProperties = _ref4.cradleInternalProperties,\n      cacheHandler = _ref4.cacheHandler,\n      cradleContentCount = _ref4.cradleContentCount,\n      cradleReferenceIndex = _ref4.cradleReferenceIndex,\n      listStartChangeCount = _ref4.listStartChangeCount,\n      listEndChangeCount = _ref4.listEndChangeCount,\n      contentlist = _ref4.workingContentList,\n      instanceIdCounterRef = _ref4.instanceIdCounterRef;\n\n  var localContentlist = _toConsumableArray(contentlist);\n\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n      tailContentlist = [];\n  var deletedtailitems = [],\n      deletedheaditems = [];\n\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    for (var newindex = cradleReferenceIndex - listStartChangeCount; newindex < cradleReferenceIndex; newindex++) {\n      headContentlist.push(createCell({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    for (var _newindex = lastindexoffset + 1; _newindex < lastindexoffset + 1 + listEndChangeCount; _newindex++) {\n      tailContentlist.push(createCell({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheHandler: cacheHandler\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n\n  var deletedItems = deletedheaditems.concat(deletedtailitems);\n  var componentList = headContentlist.concat(localContentlist, tailContentlist);\n  return [componentList, deletedItems];\n};\n\nexports.getCellFrameComponentList = getCellFrameComponentList; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n      axisReferenceIndex = _ref5.axisReferenceIndex;\n\n  var _a;\n\n  var offsetindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index; // TODO: Cannot read property 'props' of undefined\n\n  var headitemcount = axisReferenceIndex - offsetindex;\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\n\nexports.allocateContentList = allocateContentList;\n\nvar deletePortals = function deletePortals(cacheHandler, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheHandler.deletePortal(dlist, deleteListCallback);\n};\n\nexports.deletePortals = deletePortals; // =====================[ acquire item ]======================\n\nvar createCell = function createCell(_ref6) {\n  var index = _ref6.index,\n      cradleInheritedProperties = _ref6.cradleInheritedProperties,\n      cradleInternalProperties = _ref6.cradleInternalProperties,\n      instanceIdCounterRef = _ref6.instanceIdCounterRef,\n      cacheHandler = _ref6.cacheHandler;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n      cellHeight = cradleInheritedProperties.cellHeight,\n      cellWidth = cradleInheritedProperties.cellWidth,\n      getItem = cradleInheritedProperties.getItem,\n      placeholder = cradleInheritedProperties.placeholder,\n      scrollerID = cradleInheritedProperties.scrollerID;\n  var listsize = cradleInternalProperties.listsize; // get new or existing itemID\n\n  var itemID = cacheHandler.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL2NvbnRlbnRmdW5jdGlvbnMudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBSUE7O0FBRUEsa0csQ0FFQTs7O0FBRU8sSUFBTUEsMEJBQTBCLEdBQUcsU0FBN0JBLDBCQUE2QixPQVFqQztFQUFBLElBTkRDLFNBTUMsUUFOREEsU0FNQztFQUFBLElBTERDLHlCQUtDLFFBTERBLHlCQUtDO0VBQUEsSUFKREMsd0JBSUMsUUFKREEsd0JBSUM7RUFBQSxJQUhEQyx3QkFHQyxRQUhEQSx3QkFHQztFQUFBLElBRkRDLDZCQUVDLFFBRkRBLDZCQUVDO0VBRUwsSUFDSUMsV0FESixHQU1JSix5QkFOSixDQUNJSSxXQURKO0VBQUEsSUFFSUMsVUFGSixHQU1JTCx5QkFOSixDQUVJSyxVQUZKO0VBQUEsSUFHSUMsU0FISixHQU1JTix5QkFOSixDQUdJTSxTQUhKO0VBQUEsSUFJSUMsR0FKSixHQU1JUCx5QkFOSixDQUlJTyxHQUpKO0VBQUEsSUFLSUMsT0FMSixHQU1JUix5QkFOSixDQUtJUSxPQUxKO0VBUUEsSUFFSUMsVUFGSixHQVNJUix3QkFUSixDQUVJUSxVQUZKO0VBQUEsSUFHSUMsY0FISixHQVNJVCx3QkFUSixDQUdJUyxjQUhKO0VBQUEsSUFJSUMsY0FKSixHQVNJVix3QkFUSixDQUlJVSxjQUpKO0VBQUEsSUFLSUMsWUFMSixHQVNJWCx3QkFUSixDQUtJVyxZQUxKO0VBQUEsSUFNSUMsUUFOSixHQVNJWix3QkFUSixDQU1JWSxRQU5KO0VBQUEsSUFPSUMsdUJBUEosR0FTSWIsd0JBVEosQ0FPSWEsdUJBUEosQ0FWSyxDQXFCTDtFQUNBOztFQUNBWix3QkFBd0IsR0FBR2EsSUFBSSxDQUFDQyxHQUFMLENBQVNkLHdCQUFULEVBQWtDVyxRQUFRLEdBQUcsQ0FBN0MsQ0FBM0I7RUFDQVgsd0JBQXdCLElBQUtBLHdCQUF3QixHQUFHTyxVQUF4RCxDQXhCSyxDQTBCTDs7RUFDQSxJ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O0VBQUEsSUFJSUMsU0FKSixHQVNJTix5QkFUSixDQUlJTSxTQUpKO0VBQUEsSUFLSW9KLE9BTEosR0FTSTFKLHlCQVRKLENBS0kwSixPQUxKO0VBQUEsSUFNSUMsV0FOSixHQVNJM0oseUJBVEosQ0FNSTJKLFdBTko7RUFBQSxJQU9JekgsVUFQSixHQVNJbEMseUJBVEosQ0FPSWtDLFVBUEo7RUFXQSxJQUFRckIsUUFBUixHQUFxQlosd0JBQXJCLENBQVFZLFFBQVIsQ0FkQyxDQWdCRDs7RUFDQSxJQUFNK0ksTUFBTSxHQUFHcEMsWUFBWSxDQUFDcUMsc0JBQWIsQ0FBb0MvRCxLQUFwQyxDQUFmO0VBRUEsT0FBT2dFLGlDQUFDQyxzQkFBRCxFQUFVO0lBQ2JDLEdBQUcsRUFBS1AsVUFESztJQUVickosV0FBVyxFQUFLQSxXQUZIO0lBR2JDLFVBQVUsRUFBS0EsVUFIRjtJQUliQyxTQUFTLEVBQUtBLFNBSkQ7SUFLYndGLEtBQUssRUFBS0EsS0FMRztJQU1iNEQsT0FBTyxFQUFLQSxPQU5DO0lBT2I3SSxRQUFRLEVBQUtBLFFBUEE7SUFRYjhJLFdBQVcsRUFBS0EsV0FSSDtJQVNiQyxNQUFNLEVBQUtBLE1BVEU7SUFVYkgsVUFBVSxFQUFLQSxVQVZGO0lBV2J2SCxVQUFVLEVBQUtBO0VBWEYsQ0FBVixDQUFQO0FBY0gsQ0F4Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50ZnVuY3Rpb25zLnRzeD9kMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnRlbnRmdW5jdGlvbnMudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgU1VQUE9SVElORyBGVU5DVElPTlMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgQ2VsbEZyYW1lIGZyb20gJy4uL0NlbGxGcmFtZSdcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PVsgZm9yIHNldENyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMgPSAoeyAvLyBjYWxsZWQgZnJvbSBzZXRDcmFkbGVDb250ZW50IG9ubHlcblxuICAgICAgICByb3dMZW5ndGgsXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCAvLyBmcm9tIHVzZXIsIG9yIGZyb20gcGl2b3RcbiAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICB9KSA9PiB7XG5cbiAgICBjb25zdCB7IFxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuICAgIFxuICAgIC8vIGFsaWduIGF4aXMgcmVmZXJlbmNlIHRvIGZpcnN0IHJvdyBpdGVtXG4gICAgLy8gY29uc3Qgb3JpZ3JlZmluZGV4ID0gdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4odGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LGxpc3RzaXplIC0gMSlcbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggLT0gKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnQpXG5cbiAgICAvLyBkZXJpdmUgdGFyZ2V0IHJvd1xuICAgIGxldCB0YXJnZXRBeGlzUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuICAgIGNvbnN0IG1heEF4aXNSb3dPZmZzZXQgPSBNYXRoLm1heCgwLGxpc3RSb3djb3VudCAtIHZpZXdwb3J0VmlzaWJsZVJvd2NvdW50KVxuICAgIGlmICh0YXJnZXRBeGlzUm93T2Zmc2V0ID4gbWF4QXhpc1Jvd09mZnNldCkge1xuICAgICAgICB0YXJnZXRBeGlzUm93T2Zmc2V0ID0gbWF4QXhpc1Jvd09mZnNldFxuICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRBeGlzUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZVJlZmVyZW5jZVJvdyAmIEluZGV4IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBsZWFkaW5nIGVkZ2VcbiAgICAvLyBsZXQgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1heCgwLHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtIGxlYWRpbmdydW53YXlpdGVtY291bnQpXG4gICAgbGV0IHRhcmdldENyYWRsZVJvd09mZnNldCA9IE1hdGgubWF4KDAsdGFyZ2V0QXhpc1Jvd09mZnNldCAtIHJ1bndheVJvd2NvdW50KVxuXG4gICAgLy8gdHJhaWxpbmcgZWRnZVxuICAgIGxldCB0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPSB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuXG4gICAgY29uc3QgbGlzdEVuZFJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuXG4gICAgaWYgKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCA+IChsaXN0RW5kUm93T2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBkaWZmID0gKHRhcmdldENyYWRsZUVuZFJvd09mZnNldCAtIGxpc3RFbmRSb3dPZmZzZXQpXG4gICAgICAgIHRhcmdldENyYWRsZVJvd09mZnNldCAtPSBkaWZmXG4gICAgICAgIHRhcmdldENyYWRsZUVuZFJvd09mZnNldCAtPSBkaWZmXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXggPSB0YXJnZXRDcmFkbGVSb3dPZmZzZXQgKiBjcm9zc2NvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3JhZGxlIGNvbnRlbnQgY291bnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IG5ld0NyYWRsZUNvbnRlbnRDb3VudCA9IGNyYWRsZVJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgIGlmICh0YXJnZXRDcmFkbGVFbmRSb3dPZmZzZXQgPT0gbGlzdEVuZFJvd09mZnNldCkge1xuICAgICAgICBjb25zdCBlbmRSb3dSZW1haW5kZXJDb3VudCA9IGxpc3RzaXplICUgY3Jvc3Njb3VudFxuICAgICAgICBpZiAoZW5kUm93UmVtYWluZGVyQ291bnQpIHtcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSAoY3Jvc3Njb3VudCAtIGVuZFJvd1JlbWFpbmRlckNvdW50KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3NzIHBvc2l0aW9uaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gXG4gICAgICAgICh0YXJnZXRBeGlzUm93T2Zmc2V0ICogcm93TGVuZ3RoKSArIHBhZGRpbmcgLSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmV0dXJuIHJlcXVpcmVkIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgdGFyZ2V0QXhpc1Jvd09mZnNldCxcbiAgICAgICAgdGFyZ2V0U2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCBcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LCBcbiAgICB9IFxuXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT1bIGZvciB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLypcbiAgICAtIElmIHRoZSB0b3Agb2YgdGhlIGNlbGwgcm93IG1vdmVzIGJleW9uZCB0aGUgdmlld3BvcnQgYm91bmRhcnksIHRoZW4gdGhlIFxuICAgICAgICBjb250ZW50IHNob3VsZCBwdXNoIHRoZSBjZWxsIGJvdW5kYXJ5IHVwXG4gICAgLSBJZiB0aGUgdG9wIG9mIHRoZSBjZWxsIHJvdyBtb3ZlcyBpbnRvIHRoZSB2aWV3cG9ydCBib3VuZGFyeSwgdGhlbiB0aGVcbiAgICAgICAgY29udGVudCBzaG91bGQgcHVzaCB0aGUgY2VsbCBib3VuZGFyeSBkb3duXG4qL1xuLy8gLTEgPSBzaGlmdCByb3cgdG8gaGVhZC4gMSA9IHNoaWZ0IHJvdyB0byB0YWlsLiAwID0gZG8gbm90IHNoaWZ0IGEgcm93LlxuZXhwb3J0IGNvbnN0IGdldFNoaWZ0SW5zdHJ1Y3Rpb24gPSAoe1xuICAgIGlzVmlld3BvcnRTY3JvbGxpbmdGb3J3YXJkLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIHRyaWdnZXJsaW5lRW50cmllcyxcbiAgICB0cmlnZ2VybGluZVNwYW4sXG4gICAgc2Nyb2xsZXJJRCwgLy8gZm9yIGRlYnVnXG5cbn0pID0+IHtcblxuICAgIGNvbnN0IGRyaXZlciA9IFxuICAgICAgICBpc1ZpZXdwb3J0U2Nyb2xsaW5nRm9yd2FyZD9cbiAgICAgICAgICAgICd0cmlnZ2VybGluZS1heGlzJzpcbiAgICAgICAgICAgICd0cmlnZ2VybGluZS1oZWFkJ1xuXG4gICAgY29uc3QgZW50cmllcyA9IHRyaWdnZXJsaW5lRW50cmllcy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgICAvLyBjb25zdCBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgICAgIGNvbnN0IHRyaWdnZXJsaW5lbmFtZSA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGVcbiAgICAgICAgZW50cnkudHJpZ2dlcmxpbmVuYW1lID0gdHJpZ2dlcmxpbmVuYW1lIC8vIG1lbW8gZm9yIHByb2Nlc3NpbmcgYW5kIGNvbnNvbGVcbiAgICAgICAgZW50cnkuc2Nyb2xsaW5nZm9yd2FyZCA9IGlzVmlld3BvcnRTY3JvbGxpbmdGb3J3YXJkIC8vIG1lbW8gZm9yIGNvbnNvbGVcblxuICAgICAgICBjb25zdCByb290cG9zID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZW50cnkucm9vdEJvdW5kcy55OlxuICAgICAgICAgICAgICAgIGVudHJ5LnJvb3RCb3VuZHMueFxuXG4gICAgICAgIGNvbnN0IGVudHJ5cG9zID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0Lnk6XG4gICAgICAgICAgICAgICAgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnhcblxuICAgICAgICBjb25zdCB2aWV3cG9ydG9mZnNldGhlYWQgPSBlbnRyeXBvcyAtIHJvb3Rwb3NcbiAgICAgICAgZW50cnkudmlld3BvcnRvZmZzZXRoZWFkID0gdmlld3BvcnRvZmZzZXRoZWFkXG5cbiAgICAgICAgaWYgKHRyaWdnZXJsaW5lbmFtZSA9PSAndHJpZ2dlcmxpbmUtdGFpbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3Rwb3N0YWlsID0gXG4gICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5yb290Qm91bmRzLnkgKyBlbnRyeS5yb290Qm91bmRzLmhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucm9vdEJvdW5kcy54ICsgZW50cnkucm9vdEJvdW5kcy53aWR0aFxuXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydG9mZnNldHRhaWwgPSByb290cG9zdGFpbCAtIGVudHJ5cG9zXG4gICAgICAgICAgICBlbnRyeS52aWV3cG9ydG9mZnNldHRhaWwgPSB2aWV3cG9ydG9mZnNldHRhaWxcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXhpcyBuZWVkcyB0byBiZSBtb3ZlZCBpZjpcbiAgICAgICAgcmV0dXJuIChcblxuICAgICAgICAgICAgLy8gLSBheGlzIHRyaWdnZXJsaW5lIGdvZXMgb3V0IG9mIHNjb3BlLCBvci4uLlxuICAgICAgICAgICAgZHJpdmVyID09ICd0cmlnZ2VybGluZS1heGlzJyAmJlxuICAgICAgICAgICAgdmlld3BvcnRvZmZzZXRoZWFkIDw9IDBcblxuICAgICAgICApIHx8IChcblxuICAgICAgICAgICAgLy8gLSBoZWFkIHRyaWdnZXJsaW5lIGNvbWVzIGludG8gc2NvcGVcbiAgICAgICAgICAgIGRyaXZlciA9PSAndHJpZ2dlcmxpbmUtaGVhZCcgJiZcbiAgICAgICAgICAgIHZpZXdwb3J0b2Zmc2V0aGVhZCA+PSAwXG5cbiAgICAgICAgKVxuXG4gICAgfSlcblxuICAgIGxldCByZXR2YWxcblxuICAgIC8vIHRoZSB0cmlnZ2VybGluZSBtaWdodCBoYXZlIHBhc3NlZCB0aHJvdWdoIHRoZSB2aWV3cG9ydCBjb21wbGV0ZWx5IHdpdGhvdXQgdGhlXG4gICAgLy8gY2hhbmdlIGJlaW5nIHRyaWdnZXJlZCwgZWcuIG5vdCBpbnRlcnNlY3RpbmcsIHBhc3NpbmcgdGhyb3VnaCB2aWV3cG9ydCwgdGhlblxuICAgIC8vICAgIG5vdCBpbnRlcnNlY3RpbmcgYWdhaW4gYmVmb3JlIGJlaW5nIGludGVyY2VwdGVkXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHJlbHkgb24gdGhlIGNvdW50ZXIgZW50cnkgdG8gcHJvdmlkZSBpbmZvcm1hdGlvblxuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PSAwKSB7IC8vIHNob3J0LWNpcmN1aXQgdGhlIGV2YWx1YXRpb25cblxuICAgICAgICBjb25zdCBjb3VudGVyZHJpdmVyID0gXG4gICAgICAgICghaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQpP1xuICAgICAgICAgICAgJ3RyaWdnZXJsaW5lLWF4aXMnOlxuICAgICAgICAgICAgJ3RyaWdnZXJsaW5lLWhlYWQnICAgICAgICBcblxuICAgICAgICBjb25zdCBjb3VudGVyZW50cmllcyA9IHRyaWdnZXJsaW5lRW50cmllcy5maWx0ZXIoZW50cnkgPT4gZW50cnkudHJpZ2dlcmxpbmVuYW1lID09IGNvdW50ZXJkcml2ZXIpXG5cbiAgICAgICAgaWYgKGNvdW50ZXJlbnRyaWVzLmxlbmd0aCA9PSAwKSB7XG5cbiAgICAgICAgICAgIHJldHZhbCA9IDBcblxuICAgICAgICAgICAgY29uc3QgYmFja3VwZHJpdmVyID0gJ3RyaWdnZXJsaW5lLXRhaWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGJhY2t1cGVudHJpZXMgPSB0cmlnZ2VybGluZUVudHJpZXMuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnRyaWdnZXJsaW5lbmFtZSA9PSBiYWNrdXBkcml2ZXIpXG5cbiAgICAgICAgICAgIGlmIChiYWNrdXBlbnRyaWVzLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBiYWNrdXBlbnRyaWVzLnBvcCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGltcGxpZWQgdHJpZ2dlciAtIHRyaWdnZXIgY2FuIGJlIGJ5cGFzc2VkIHdpdGggaGVhdnkgY29tcG9uZW50c1xuICAgICAgICAgICAgY29uc3QgY291bnRlcmVudHJ5ID0gIGNvdW50ZXJlbnRyaWVzLnBvcCgpXG4gICAgICAgICAgICBjb25zdCBjb3VudGVydHJpZ2dlcmxpbmVuYW1lID0gY291bnRlcmVudHJ5LnRyaWdnZXJsaW5lbmFtZVxuXG4gICAgICAgICAgICBsZXQgaW1wbGllZG9mZnNldGhlYWRcbiAgICAgICAgICAgIGlmIChjb3VudGVydHJpZ2dlcmxpbmVuYW1lID09ICd0cmlnZ2VybGluZS1oZWFkJykge1xuXG4gICAgICAgICAgICAgICAgaW1wbGllZG9mZnNldGhlYWQgPSBjb3VudGVyZW50cnkudmlld3BvcnRvZmZzZXRoZWFkICsgdHJpZ2dlcmxpbmVTcGFuXG5cbiAgICAgICAgICAgICAgICBpZiAoaW1wbGllZG9mZnNldGhlYWQgPD0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IC0xXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNvdW50ZXJ0cmlnZ2VybGluZW5hbWUgPT0gJ3RyaWdnZXJsaW5lLWF4aXMnXG5cbiAgICAgICAgICAgICAgICBpbXBsaWVkb2Zmc2V0aGVhZCA9IGNvdW50ZXJlbnRyeS52aWV3cG9ydG9mZnNldGhlYWQgLSB0cmlnZ2VybGluZVNwYW5cblxuICAgICAgICAgICAgICAgIGlmIChpbXBsaWVkb2Zmc2V0aGVhZCA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gMVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHZhbCA9IDBcblxuICAgIH0gZWxzZSB7IC8vIGNvbXBsZXRlIHRoZSBldmFsdWF0aW9uXG5cbiAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdIC8vIGFzc3VtZSBvbmUgcmVjb3JkIGdldHMgZmlsdGVyZWQ7IG9ubHkgcGFpcmVkIGFib3ZlIG9uIHJlY29ubmVjdFxuXG4gICAgICAgIC8vIGlmICghaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQpIHtcbiAgICAgICAgaWYgKGRyaXZlciA9PSAndHJpZ2dlcmxpbmUtaGVhZCcpIHtcblxuICAgICAgICAgICAgcmV0dmFsID0gMSAvLyBzaGlmdCByb3cgdG8gdGFpbFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHZhbCA9IC0xIC8vIHNoaWZ0IHJvdyB0byBoZWFkXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJz09PiBnZXRTaGlmdEluc3RydWN0aW9uOiBpc1ZpZXdwb3J0U2Nyb2xsaW5nRm9yd2FyZCwgZHJpdmVyLCBpbnN0cnVjdGlvbiwgdHJpZ2dlcmxpbmVFbnRyaWVzLCBmaWx0ZXJlZEVudHJpZXMnLCctJytzY3JvbGxlcklEKyctJyxcbiAgICAgICAgJ1xcbicsaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQsIGRyaXZlciwgcmV0dmFsLCdcXG4nICwgdHJpZ2dlcmxpbmVFbnRyaWVzLCBlbnRyaWVzKVxuXG4gICAgcmV0dXJuIHJldHZhbFxufVxuXG4vLyBBIG5lZ2F0aXZlIHNoaWZ0IGluc3RydWN0aW9uIGlzIGludG8gdGhlIGhlYWQsIGEgcG9zaXRpdmUgc2hpZnQgaXMgaW50byB0aGUgdGFpbC5cbi8vIGNhbGxlZCBvbmx5IGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudFxuZXhwb3J0IGNvbnN0IGNhbGNDb250ZW50U2hpZnQgPSAoe1xuXG4gICAgc2hpZnRpbnN0cnVjdGlvbixcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICBjcmFkbGVDb250ZW50LFxuICAgIGNyYWRsZUVsZW1lbnRzLFxuICAgIHNjcm9sbFBvcywgLy8gb2YgY3JhZGxlIGFnYWluc3Qgdmlld3BvcnQ7IHdoZXJlIHRoZSBjcmFkbGUgbW90aW9uIGludGVyc2VjdHMgdGhlIHZpZXdwb3J0XG4gICAgLy8gdmlld3BvcnRFbGVtZW50LFxuXG59KSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBpc1Njcm9sbGluZ1ZpZXdwb3J0Rm9yd2FyZCA9IChzaGlmdGluc3RydWN0aW9uIDwgMClcblxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgZ2FwLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcblxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czpjcmFkbGVjb250ZW50bGlzdCwgXG4gICAgICAgIHRhaWxNb2RlbENvbXBvbmVudHM6dGFpbGNvbnRlbnRsaXN0LFxuXG4gICAgfSA9IGNyYWRsZUNvbnRlbnRcblxuICAgIGNvbnN0IHsgXG5cbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgY29uc3Qgcm93TGVuZ3RoID0gXG4gICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgY2VsbFdpZHRoKSBcbiAgICAgICAgKyBnYXBcblxuICAgIC8vIC0tLS0tLS0tLS0tWyAyLiBjYWxjdWxhdGUgYXhpcyByZWZlcmVuY2Ugcm93IHNoaWZ0IF0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZXh0cmEgZ2FwcyBjYW4gYmUgY2F1c2VkIGJ5IHJhcGlkIHNjcm9sbGluZ1xuXG4gICAgY29uc3QgY3JhZGxlQXhpc09mZnNldCA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAvLyB2aWV3cG9ydEF4aXNPZmZzZXQgd2lsbCBiZSBuZWdhdGl2ZSBmb3Igc2Nyb2xsIGZvcndhcmQgYW5kIHBvc2l0aXZlIGZvciBzY3JvbGwgYmFja3dhcmRcbiAgICBjb25zdCB2aWV3cG9ydEF4aXNPZmZzZXQgPSAvLyB0aGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgZnJhbWUgYW5kIHRoZSBheGlzLCB0b3dhcmQgdGhlIGhlYWRcbiAgICAgICAgY3JhZGxlQXhpc09mZnNldCAtIHNjcm9sbFBvc1xuXG4gICAgY29uc3QgdHJpZ2dlckF4aXNPZmZzZXQgPSBcbiAgICAgICAgKGlzU2Nyb2xsaW5nVmlld3BvcnRGb3J3YXJkKT9cbiAgICAgICAgICAgIC8vIHNjcm9sbCBmb3J3YXJkIGVuZ2FnZXMgdGhlIHRhaWwgdHJpZ2dlcmxpbmUgd2hpY2ggaXMgYmVsb3cgdGhlIGF4aXNcbiAgICAgICAgICAgIC8vIHRoZSB0YWlsIHRyaWdnZXJsaW5lIG11c3QgYmUgcGxhY2VkIHRvIGludGVyc2VjdCB0byByZS10cmlnZ2VyXG4gICAgICAgICAgICB2aWV3cG9ydEF4aXNPZmZzZXQgKyB0cmlnZ2VybGluZU9mZnNldDpcbiAgICAgICAgICAgIC8vIHNjcm9sbGJhY2t3YXJkIGVuZ2FnZXMgdGhlIGhlYWQgdHJpZ2dlcmxpbmUgd2hpY2ggaXMgYWJvdmUgdGhlIGF4aXNcbiAgICAgICAgICAgIC8vIHRoZSBoZWFkIHRyaWdnZXJsaW5lIG11c2UgYmUgcGxhY2VkIG5vdCB0byBpbnRlcnNlY3QgdG8gcmV0cmlnZ2VyXG4gICAgICAgICAgICB2aWV3cG9ydEF4aXNPZmZzZXQgLSAocm93TGVuZ3RoIC0gdHJpZ2dlcmxpbmVPZmZzZXQpXG5cbiAgICAvLyBuZWdhdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIGhlYWQgaW50byB0YWlsO1xuICAgIC8vIHBvc2l0aXZlIGZvciBtb3Zpbmcgcm93cyBvdXQgb2YgdGFpbCBpbnRvIGhlYWRcbiAgICAvLyArLy0gMSBndXJhbnRlZXMgYm91bmRhcnkgbG9jYXRpb24gcmVzdWx0cyBpbiBtb3ZlXG4gICAgY29uc3QgdHJpZ2dlclJvd1NoaWZ0ID0gXG4gICAgICAgIChpc1Njcm9sbGluZ1ZpZXdwb3J0Rm9yd2FyZCk/XG4gICAgICAgICAgICBNYXRoLmZsb29yKCh0cmlnZ2VyQXhpc09mZnNldD90cmlnZ2VyQXhpc09mZnNldDogLTEpL3Jvd0xlbmd0aCk6XG4gICAgICAgICAgICBNYXRoLmNlaWwoKHRyaWdnZXJBeGlzT2Zmc2V0P3RyaWdnZXJBeGlzT2Zmc2V0OiAxKS9yb3dMZW5ndGgpXG5cbiAgICBsZXQgYXhpc1JlZmVyZW5jZVJvd3NoaWZ0ID0gLXRyaWdnZXJSb3dTaGlmdFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tWyA1LiBjYWxjIG5ldyBjcmFkbGUgYW5kIGF4aXMgcmVmZXJlbmNlIHJvdyBvZmZzZXQgXS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJhc2UgdmFsdWUgZm9yIGNyYWRsZSByZWZlcmVuY2Ugc2hpZnQ7IG1heSBjaGFuZ2UgaWYgYmV5b25kIGxpc3QgYm91bmRzXG4gICAgbGV0IGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0ID0gYXhpc1JlZmVyZW5jZVJvd3NoaWZ0XG5cbiAgICBjb25zdCBwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKGNyYWRsZWNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCB8fCAwKVxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ID0gTWF0aC5jZWlsKHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4ID0gKHRhaWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcbiAgICBjb25zdCBwcmV2aW91c0F4aXNSb3dPZmZzZXQgPSBNYXRoLmNlaWwocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIC8vIGJhc2UgdmFsdWVzXG4gICAgbGV0IG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnRcbiAgICBsZXQgbmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCA9IHByZXZpb3VzQXhpc1Jvd09mZnNldCArIGF4aXNSZWZlcmVuY2VSb3dzaGlmdFxuXG4gICAgLy8gLS0tLS0tLS1bIDYuIGFkanVzdCBjcmFkbGUgY29udGVudHMgZm9yIHN0YXJ0IGFuZCBlbmQgb2YgbGlzdCBdLS0tLS0tLVxuICAgIC8vIC4uLnRvIG1haW50YWluIGNvbnN0YW50IG51bWJlciBvZiBjcmFkbGUgcm93c1xuXG4gICAgY29uc3QgbGlzdEVuZHJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKVxuXG4gICAgaWYgKGlzU2Nyb2xsaW5nVmlld3BvcnRGb3J3YXJkKSB7XG5cbiAgICAgICAgLy8gYS4gaWYgc2Nyb2xsaW5nIGZvcndhcmQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIG5ldyBjcmFkbGUgcm93IG9mZnNldCBhbmRcbiAgICAgICAgLy8gY3JhZGxlIHJvdyBzaGlmdCBjb3VudCBoYXMgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxlYWRpbmcgcnVud2F5XG4gICAgICAgIC8vIGIuIGlmIHNjcm9sbGluZyBmb3J3YXJkICh0b3dhcmQgdGFpbCBvZiBsaXN0KSwgYXMgdGhlIGNyYWRsZSBsYXN0IHJvdyBvZmZzZXQgYXBwcm9hY2hlcyBcbiAgICAgICAgLy8gbGlzdHJvdyBuZXcgY3JhZGxlIG9mZnNldCBhbmQgY3JhZGxlIHJvdyBzaGlmdCBoYXZlIHRvIGJlIGFkanVzdGVkIHRvIHByZXZlbnQgc2hvcnRlbmluZyBcbiAgICAgICAgLy8gb2YgY3JhZGxlIGNvbnRlbnQuXG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ID0gXG4gICAgICAgICAgICBNYXRoLm1heCgwLCBcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgLSBydW53YXlSb3djb3VudCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bndheVJvd2NvdW50ICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAocnVud2F5Um93Y291bnQ/LTE6MCkgLy8gb25lIHJvdyBpcyB2aXNpYmxlLCBub3QgcnVud2F5XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWxjQ29udGVudFNoaWZ0OiB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQsIG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQsIHJ1bndheVJvd2NvdW50JyxcbiAgICAgICAgLy8gICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZVJvd09mZnNldCwgbmV3QXhpc1JlZmVyZW5jZVJvd09mZnNldCwgcnVud2F5Um93Y291bnQpXG5cbiAgICAgICAgY29uc3QgaGVhZHJvd0RpZmYgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgaWYgKGhlYWRyb3dEaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gaGVhZHJvd0RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IGhlYWRyb3dEaWZmXG5cbiAgICAgICAgfVxuICAgICAgICAvLyBjYXNlIG9mIGJlaW5nIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXkgKGVuZCBvZiBsaXN0KVxuICAgICAgICBjb25zdCB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXQgPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuICAgICAgICBjb25zdCB0YWlscm93ZGlmZiA9IE1hdGgubWF4KDAsdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0IC0gbGlzdEVuZHJvd09mZnNldClcbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgLT0gdGFpbHJvd2RpZmZcbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gIWlzU2Nyb2xsaW5nVmlld3BvcnRGb3J3YXJkID0gc2Nyb2xsIGJhY2t3YXJkXG5cbiAgICAgICAgLy8gYy4gaWYgc2Nyb2xsaW5nIGJhY2t3YXJkICh0b3dhcmQgaGVhZCBvZiBsaXN0KSwgYXMgdGhlIGNyYWRsZXJvd29mZnNldCBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmVcbiAgICAgICAgLy8gdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG4gICAgICAgIC8vIGQuIGlmIHNjcm9sbGluZyBiYWNrd2FyZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGxpc3QsIGNyYWRsZSBjaGFuZ2VzIGhhcyB0byBiZSBhZGp1c3RlZCB0byBhY2NvbW9kYXRlXG4gICAgICAgIC8vIHRoZSB0cmFpbGluZyBydW53YXlcblxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXRcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCA9IDBcblxuICAgICAgICB9XG4gICAgICAgIC8vIGNhc2Ugb2YgaW4gYm91bmRzIG9mIHRyYWlsaW5nIHJ1bndheSAoZW5kIG9mIGxpc3QpXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldCA9IFxuICAgICAgICAgICAgKHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0xKSArIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0KVxuICAgICAgICBjb25zdCB0YXJnZXRjcmFkbGVFbmRyb3dvZmZzZXQgPSBNYXRoLm1pbihsaXN0RW5kcm93T2Zmc2V0LCBcbiAgICAgICAgICAgIChuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpKSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCgwLCB0YXJnZXRjcmFkbGVFbmRyb3dvZmZzZXQgLSBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKHRhaWxyb3dkaWZmID4gMCkge1xuXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCArPSB0YWlscm93ZGlmZlxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0ICs9IHRhaWxyb3dkaWZmXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNy4gbWFwIHJvd3MgdG8gaXRlbSByZWZlcmVuY2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCA9IChuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgKiBjcm9zc2NvdW50KVxuICAgIGNvbnN0IGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCA9IChjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAqIGNyb3NzY291bnQpXG5cbiAgICBjb25zdCBuZXdBeGlzUmVmZXJlbmNlSW5kZXggPSBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0ICogY3Jvc3Njb3VudFxuICAgIGNvbnN0IGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQgPSBheGlzUmVmZXJlbmNlUm93c2hpZnQgKiBjcm9zc2NvdW50XG5cbiAgICBsZXQgbmV3Q3JhZGxlQ29udGVudENvdW50ID0gY3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50IC8vIGJhc2UgY291bnRcbiAgICBjb25zdCBpbmNsdWRlc0xhc3RSb3cgPSAoKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCArIGNyYWRsZVJvd2NvdW50KSA+PSBsaXN0Um93Y291bnQpXG4gICAgaWYgKGluY2x1ZGVzTGFzdFJvdykge1xuICAgICAgICBjb25zdCBwYXJ0aWFsc3BhY2VzID0gbGlzdHNpemUgJSBjcm9zc2NvdW50XG4gICAgICAgIGNvbnN0IGl0ZW1zU2hvcnRmYWxsID0gXG4gICAgICAgICAgICAocGFydGlhbHNwYWNlcyA9PSAwKT9cbiAgICAgICAgICAgICAgICAwOlxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQgLSBwYXJ0aWFsc3BhY2VzXG4gICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSBpdGVtc1Nob3J0ZmFsbFxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBoZWFkIGFuZCB0YWlsIGNoYW5nZSBjb3VudHNcbiAgICBjb25zdCBjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudCA9IGNyYWRsZWNvbnRlbnRsaXN0Lmxlbmd0aCAtIG5ld0NyYWRsZUNvbnRlbnRDb3VudFxuXG4gICAgY29uc3QgbGlzdFN0YXJ0Q2hhbmdlQ291bnQgPSAtKGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdClcbiAgICBjb25zdCBsaXN0RW5kQ2hhbmdlQ291bnQgPSAtbGlzdFN0YXJ0Q2hhbmdlQ291bnQgLSAoY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tWyA4LiBjYWxjdWxhdGUgbmV3IGF4aXMgcGl4ZWwgcG9zaXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgbmV3QXhpc1BpeGVsT2Zmc2V0ID0gdmlld3BvcnRBeGlzT2Zmc2V0ICsgKGF4aXNSZWZlcmVuY2VSb3dzaGlmdCAqIHJvd0xlbmd0aClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgOS4gcmV0dXJuIHJlcXVpcmVkIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAgICAgY29uc29sZS5sb2coJ2NhbGNDb250ZW50U2hpZnQnLFxuLy8gYFxuLy8gICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4vLyAgICAgICAgIGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCwgXG4vLyAgICAgICAgIG5ld0F4aXNSZWZlcmVuY2VJbmRleCwgXG4vLyAgICAgICAgIGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQsIFxuLy8gICAgICAgICBuZXdBeGlzUGl4ZWxPZmZzZXQsIFxuLy8gICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsXG4vLyAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuLy8gICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnRcbi8vIGAsXG4vLyAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LCBcbi8vICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0LCBcbi8vICAgICAgICAgbmV3QXhpc1JlZmVyZW5jZUluZGV4LCBcbi8vICAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCwgXG4vLyAgICAgICAgIG5ld0F4aXNQaXhlbE9mZnNldCwgXG4vLyAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCxcbi8vICAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsXG4vLyAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudFxuLy8gKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQsIFxuICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICBheGlzUmVmZXJlbmNlSXRlbVNoaWZ0LCBcbiAgICAgICAgbmV3QXhpc1BpeGVsT2Zmc2V0LCBcbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50XG4gICAgfVxuXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PVsgc2hhcmVkIGJ5IGJvdGggc2V0Q3JhZGxlQ29udGVudCBhbmQgdXBkYXRlQ3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT1cblxuLy8gdXBkYXRlIGNvbnRlbnRcbi8vIGFkZHMgaXRlbXNoZWxscyBhdCBlbmQgb2YgY29udGVudGxpc3QgYWNjb3JkaW5nIHRvIGhlYWRpbmRleGNvdW50IGFuZCB0YWlsaW5kZXNjb3VudCxcbi8vIG9yIGlmIGluZGV4Y291bnQgdmFsdWVzIGFyZSA8MCByZW1vdmVzIHRoZW0uXG5leHBvcnQgY29uc3QgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCA9ICh7IFxuXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICBjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgIGNyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsIFxuICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsIFxuICAgICAgICB3b3JraW5nQ29udGVudExpc3Q6Y29udGVudGxpc3QsXG4gICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgY29uc3QgbGFzdGluZGV4b2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggKyBsb2NhbENvbnRlbnRsaXN0Lmxlbmd0aCAtIDFcblxuICAgIGNvbnN0IGhlYWRDb250ZW50bGlzdCA9IFtdLCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgbGV0IGRlbGV0ZWR0YWlsaXRlbXMgPSBbXSwgZGVsZXRlZGhlYWRpdGVtcyA9IFtdXG5cbiAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggLSBsaXN0U3RhcnRDaGFuZ2VDb3VudDsgbmV3aW5kZXggPCAoY3JhZGxlUmVmZXJlbmNlSW5kZXgpOyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGwoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Om5ld2luZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbGV0ZWRoZWFkaXRlbXMgPSBsb2NhbENvbnRlbnRsaXN0LnNwbGljZSggMCwgLWxpc3RTdGFydENoYW5nZUNvdW50IClcblxuICAgIH1cblxuICAgIGlmIChsaXN0RW5kQ2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuXG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gbGFzdGluZGV4b2Zmc2V0ICsgMTsgbmV3aW5kZXggPCAobGFzdGluZGV4b2Zmc2V0ICsgMSArIGxpc3RFbmRDaGFuZ2VDb3VudCk7IG5ld2luZGV4KyspIHtcblxuICAgICAgICAgICAgdGFpbENvbnRlbnRsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2VsbChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZGVsZXRlZHRhaWxpdGVtcyA9IGxvY2FsQ29udGVudGxpc3Quc3BsaWNlKGxpc3RFbmRDaGFuZ2VDb3VudCwtbGlzdEVuZENoYW5nZUNvdW50KVxuXG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlZEl0ZW1zID0gZGVsZXRlZGhlYWRpdGVtcy5jb25jYXQoZGVsZXRlZHRhaWxpdGVtcylcblxuICAgIGNvbnN0IGNvbXBvbmVudExpc3QgPSBoZWFkQ29udGVudGxpc3QuY29uY2F0KGxvY2FsQ29udGVudGxpc3QsdGFpbENvbnRlbnRsaXN0KVxuXG4gICAgcmV0dXJuIFtjb21wb25lbnRMaXN0LGRlbGV0ZWRJdGVtc11cblxufVxuXG4vLyBidXR0ZXJmbHkgbW9kZWwuIExlYWRpbmcgKGhlYWQpIGFsbCBvciBwYXJ0aWFsbHkgaGlkZGVuOyB0YWlsLCB2aXNpYmxlIHBsdXMgZm9sbG93aW5nIGhpZGRlblxuZXhwb3J0IGNvbnN0IGFsbG9jYXRlQ29udGVudExpc3QgPSAoXG4gICAge1xuXG4gICAgICAgIGNvbnRlbnRsaXN0LCAvLyBvZiBjcmFkbGUsIGluIGl0ZW1zIChSZWFjdCBjb21wb25lbnRzKVxuICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsIC8vIGZpcnN0IHRhaWwgaXRlbVxuXG4gICAgfVxuKSA9PiB7XG5cbiAgICBjb25zdCBvZmZzZXRpbmRleCA9IGNvbnRlbnRsaXN0WzBdPy5wcm9wcy5pbmRleCAvLyBUT0RPOiBDYW5ub3QgcmVhZCBwcm9wZXJ0eSAncHJvcHMnIG9mIHVuZGVmaW5lZFxuXG4gICAgY29uc3QgaGVhZGl0ZW1jb3VudCA9IChheGlzUmVmZXJlbmNlSW5kZXggLSBvZmZzZXRpbmRleClcblxuICAgIGNvbnN0IGhlYWRsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoMCxoZWFkaXRlbWNvdW50KVxuICAgIGNvbnN0IHRhaWxsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoaGVhZGl0ZW1jb3VudClcblxuICAgIHJldHVybiBbaGVhZGxpc3QsdGFpbGxpc3RdXG5cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVBvcnRhbHMgPSAoY2FjaGVIYW5kbGVyLCBkZWxldGVMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgIGNvbnN0IGRsaXN0ID0gZGVsZXRlTGlzdC5tYXAoKGl0ZW0pPT57XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcHMuaW5kZXhcbiAgICAgICAgXG4gICAgfSlcblxuICAgIGNhY2hlSGFuZGxlci5kZWxldGVQb3J0YWwoZGxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBhY3F1aXJlIGl0ZW0gXT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY3JlYXRlQ2VsbCA9ICh7XG4gICAgaW5kZXgsIFxuICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgIGNhY2hlSGFuZGxlcixcblxufSkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlSUQgPSBpbnN0YW5jZUlkQ291bnRlclJlZi5jdXJyZW50KytcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnZXRJdGVtLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgc2Nyb2xsZXJJRCBcblxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCB7IGxpc3RzaXplIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcblxuICAgIC8vIGdldCBuZXcgb3IgZXhpc3RpbmcgaXRlbUlEXG4gICAgY29uc3QgaXRlbUlEID0gY2FjaGVIYW5kbGVyLmdldE5ld09yRXhpc3RpbmdJdGVtSUQoaW5kZXgpXG5cbiAgICByZXR1cm4gPENlbGxGcmFtZSBcbiAgICAgICAga2V5ID0geyBpbnN0YW5jZUlEIH0gXG4gICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9XG4gICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgIGluZGV4ID0geyBpbmRleCB9XG4gICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICBpdGVtSUQgPSB7IGl0ZW1JRCB9XG4gICAgICAgIGluc3RhbmNlSUQgPSB7IGluc3RhbmNlSUQgfVxuICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMiLCJyb3dMZW5ndGgiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwidGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJvcmllbnRhdGlvbiIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJnYXAiLCJwYWRkaW5nIiwiY3Jvc3Njb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJsaXN0Um93Y291bnQiLCJsaXN0c2l6ZSIsInZpZXdwb3J0VmlzaWJsZVJvd2NvdW50IiwiTWF0aCIsIm1pbiIsInRhcmdldEF4aXNSb3dPZmZzZXQiLCJjZWlsIiwibWF4QXhpc1Jvd09mZnNldCIsIm1heCIsInRhcmdldENyYWRsZVJvd09mZnNldCIsInRhcmdldENyYWRsZUVuZFJvd09mZnNldCIsImxpc3RFbmRSb3dPZmZzZXQiLCJkaWZmIiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJuZXdDcmFkbGVDb250ZW50Q291bnQiLCJlbmRSb3dSZW1haW5kZXJDb3VudCIsInRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsImV4cG9ydHMiLCJnZXRTaGlmdEluc3RydWN0aW9uIiwiaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQiLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJ0cmlnZ2VybGluZVNwYW4iLCJzY3JvbGxlcklEIiwiZHJpdmVyIiwiZW50cmllcyIsImZpbHRlciIsInRyaWdnZXJsaW5lbmFtZSIsImVudHJ5IiwidGFyZ2V0IiwiZGF0YXNldCIsInR5cGUiLCJzY3JvbGxpbmdmb3J3YXJkIiwicm9vdHBvcyIsInJvb3RCb3VuZHMiLCJ5IiwieCIsImVudHJ5cG9zIiwiYm91bmRpbmdDbGllbnRSZWN0Iiwidmlld3BvcnRvZmZzZXRoZWFkIiwicm9vdHBvc3RhaWwiLCJoZWlnaHQiLCJ3aWR0aCIsInZpZXdwb3J0b2Zmc2V0dGFpbCIsInJldHZhbCIsImxlbmd0aCIsImNvdW50ZXJkcml2ZXIiLCJjb3VudGVyZW50cmllcyIsImJhY2t1cGRyaXZlciIsImJhY2t1cGVudHJpZXMiLCJwb3AiLCJjb3VudGVyZW50cnkiLCJjb3VudGVydHJpZ2dlcmxpbmVuYW1lIiwiaW1wbGllZG9mZnNldGhlYWQiLCJjb25zb2xlIiwibG9nIiwiY2FsY0NvbnRlbnRTaGlmdCIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJjcmFkbGVDb250ZW50IiwiY3JhZGxlRWxlbWVudHMiLCJzY3JvbGxQb3MiLCJpc1Njcm9sbGluZ1ZpZXdwb3J0Rm9yd2FyZCIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiY3VycmVudCIsImNyYWRsZWNvbnRlbnRsaXN0IiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwidGFpbGNvbnRlbnRsaXN0IiwidGFpbE1vZGVsQ29tcG9uZW50cyIsInZpZXdwb3J0Um93Y291bnQiLCJjcmFkbGVBeGlzT2Zmc2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInZpZXdwb3J0QXhpc09mZnNldCIsInRyaWdnZXJBeGlzT2Zmc2V0IiwidHJpZ2dlclJvd1NoaWZ0IiwiZmxvb3IiLCJheGlzUmVmZXJlbmNlUm93c2hpZnQiLCJjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCIsInByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJfYSIsInByb3BzIiwiaW5kZXgiLCJwcmV2aW91c0NyYWRsZVJvd09mZnNldCIsInByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4IiwiX2IiLCJwcmV2aW91c0F4aXNSb3dPZmZzZXQiLCJuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQiLCJuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0IiwibGlzdEVuZHJvd09mZnNldCIsInRhcmdldENyYWRsZVJlZmVyZW5jZVJvd09mZnNldCIsImhlYWRyb3dEaWZmIiwidGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0IiwidGFpbHJvd2RpZmYiLCJjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQiLCJ0YXJnZXRjcmFkbGVFbmRyb3dvZmZzZXQiLCJuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCIsImNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCIsIm5ld0F4aXNSZWZlcmVuY2VJbmRleCIsImF4aXNSZWZlcmVuY2VJdGVtU2hpZnQiLCJpbmNsdWRlc0xhc3RSb3ciLCJwYXJ0aWFsc3BhY2VzIiwiaXRlbXNTaG9ydGZhbGwiLCJjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudCIsImxpc3RTdGFydENoYW5nZUNvdW50IiwibGlzdEVuZENoYW5nZUNvdW50IiwibmV3QXhpc1BpeGVsT2Zmc2V0IiwiZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCIsImNhY2hlSGFuZGxlciIsImNyYWRsZUNvbnRlbnRDb3VudCIsImNyYWRsZVJlZmVyZW5jZUluZGV4IiwiY29udGVudGxpc3QiLCJ3b3JraW5nQ29udGVudExpc3QiLCJpbnN0YW5jZUlkQ291bnRlclJlZiIsImxvY2FsQ29udGVudGxpc3QiLCJsYXN0aW5kZXhvZmZzZXQiLCJoZWFkQ29udGVudGxpc3QiLCJ0YWlsQ29udGVudGxpc3QiLCJkZWxldGVkdGFpbGl0ZW1zIiwiZGVsZXRlZGhlYWRpdGVtcyIsIm5ld2luZGV4IiwicHVzaCIsImNyZWF0ZUNlbGwiLCJzcGxpY2UiLCJkZWxldGVkSXRlbXMiLCJjb25jYXQiLCJjb21wb25lbnRMaXN0IiwiYWxsb2NhdGVDb250ZW50TGlzdCIsImF4aXNSZWZlcmVuY2VJbmRleCIsIm9mZnNldGluZGV4IiwiaGVhZGl0ZW1jb3VudCIsImhlYWRsaXN0Iiwic2xpY2UiLCJ0YWlsbGlzdCIsImRlbGV0ZVBvcnRhbHMiLCJkZWxldGVMaXN0IiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiZGxpc3QiLCJtYXAiLCJpdGVtIiwiZGVsZXRlUG9ydGFsIiwiaW5zdGFuY2VJRCIsImdldEl0ZW0iLCJwbGFjZWhvbGRlciIsIml0ZW1JRCIsImdldE5ld09yRXhpc3RpbmdJdGVtSUQiLCJyZWFjdF8xIiwiQ2VsbEZyYW1lXzEiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n");

/***/ }),

/***/ "./src/cradle/contenthandler.tsx":
/*!***************************************!*\
  !*** ./src/cradle/contenthandler.tsx ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // contenthandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ \"./src/cradle/contentfunctions.tsx\");\n\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n\n    _classCallCheck(this, ContentHandler);\n\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    }; // private instanceIdMap = new Map()\n    // Two public methods - setCradleContent and updateCradleContent\n    // reset cradle, including allocation between head and tail parts of the cradle\n    // called only from cradle state handler\n    // ==========================[ SET CONTENT ]===========================\n    //initially (dosetup), after reposition (reposition), or with finishresize, pivot, \n    // or user size param reconfigure or reload\n    // setCradleContent sets the scrollblock's scroll position, as well as config and content\n\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var cradleHandlers = _this.cradleParameters.handlersRef.current;\n      var cacheHandler = cradleHandlers.cacheHandler,\n          scaffoldHandler = cradleHandlers.scaffoldHandler,\n          serviceHandler = cradleHandlers.serviceHandler,\n          interruptHandler = cradleHandlers.interruptHandler; // the triggerlines and cradle wings will be moved, so disconnect them from their observers.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.cradleIntersect.observer.disconnect();\n      var cradlePositionData = scaffoldHandler.cradlePositionData;\n      var viewportElement = viewportInterruptProperties.elementRef.current;\n      var requestedAxisReferenceIndex = cradlePositionData.targetAxisReferenceIndex;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      var orientation = cradleInheritedProperties.orientation,\n          gap = cradleInheritedProperties.gap,\n          padding = cradleInheritedProperties.padding,\n          cellHeight = cradleInheritedProperties.cellHeight,\n          cellWidth = cradleInheritedProperties.cellWidth,\n          cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID;\n      var crosscount = cradleInternalProperties.crosscount,\n          listsize = cradleInternalProperties.listsize;\n      var workingAxisReferenceIndex = Math.min(requestedAxisReferenceIndex, listsize - 1);\n      workingAxisReferenceIndex -= workingAxisReferenceIndex % crosscount; // reposition at row boundary\n\n      if (['firstrender', 'firstrenderfromcache', 'reposition', 'reconfigure', 'scrollto'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      var cradleContent = _this.content; // ----------------------[ 2. get content requirements ]----------------------\n\n      var rowLength = orientation == 'vertical' ? cellHeight + gap : cellWidth + gap;\n\n      var _ref = (0, contentfunctions_1.getContentListRequirements)({\n        rowLength: rowLength,\n        targetAxisReferenceIndex: requestedAxisReferenceIndex,\n        targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties\n      }),\n          targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n          targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n          targetAxisRowOffset = _ref.targetAxisRowOffset,\n          cradleContentCount = _ref.newCradleContentCount,\n          scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset; // console.log('setCradleContent: cradleState, scrollblockViewportPixelOffset, targetAxisReferenceIndex',\n      //     '-'+scrollerID+'-', cradleState, scrollblockViewportPixelOffset, targetAxisReferenceIndex)\n\n\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // ----------------------[ 3. get and config content ]----------------------\n      // returns content constrained by cradleRowcount\n\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n        cacheHandler: cacheHandler,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContentCount: cradleContentCount,\n        cradleReferenceIndex: targetCradleReferenceIndex,\n        listStartChangeCount: 0,\n        listEndChangeCount: cradleContentCount,\n        workingContentList: workingContentList,\n        instanceIdCounterRef: _this.instanceIdCounterRef\n      }),\n          _ref3 = _slicedToArray(_ref2, 2),\n          newcontentlist = _ref3[0],\n          deleteditems = _ref3[1];\n\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: newcontentlist,\n        axisReferenceIndex: targetAxisReferenceIndex\n      }),\n          _ref5 = _slicedToArray(_ref4, 2),\n          headcontentlist = _ref5[0],\n          tailcontentlist = _ref5[1];\n\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferenceIndex = targetAxisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferenceIndex, 'setCradleContent', cstate);\n      } //  ----------------------[ 4. set CSS ]-----------------------\n\n\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset;\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = scaffoldHandler.elements; //cradleElementsRef.current\n\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      var AxisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n\n      if (orientation == 'vertical') {\n        var top = AxisScrollblockPixelOffset;\n        axisElement.style.top = top + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontentlist.length ? gap + 'px' : 0;\n      } else {\n        // orientation = 'horizontal'\n        var left = AxisScrollblockPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = left + 'px';\n        headElement.style.paddingRight = headcontentlist.length ? gap + 'px' : 0;\n      } //  ----------------------[ 5. reset interrupts ]-----------------------\n\n\n      interruptHandler.triggerlinesIntersect.connectElements();\n      interruptHandler.cradleIntersect.connectElements();\n      interruptHandler.signals.pauseTriggerlinesObserver = false;\n    }; // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element's scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle\n\n\n    this.updateCradleContent = function (isViewportScrollingForward, triggerlineEntries) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'notifications';\n\n      // ----------------------[ 1. initialize ]-------------------------\n      var _a; // handler support\n\n\n      var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n          cacheHandler = _this$cradleParameter.cacheHandler,\n          scrollHandler = _this$cradleParameter.scrollHandler,\n          scaffoldHandler = _this$cradleParameter.scaffoldHandler,\n          stateHandler = _this$cradleParameter.stateHandler,\n          interruptHandler = _this$cradleParameter.interruptHandler,\n          serviceHandler = _this$cradleParameter.serviceHandler; // scroll data\n\n      var scrollData = scrollHandler.scrollData;\n      var scrollPos = scrollData.currentupdate; // first abandon option/3; nothing to do\n\n      if (scrollPos < 0) {\n        // for Safari, FF elastic bounce at top of scroll\n        return;\n      } // cradle scaffold and user cells\n\n\n      var cradleElements = scaffoldHandler.elements;\n      var cradleContent = _this.content;\n      var modelcontentlist = cradleContent.cradleModelComponents || [];\n      var oldCradleReferenceIndex = ((_a = modelcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0; // --------------------[ 2. get shift instruction ]-----------------------\n\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation,\n          cache = cradleInheritedProperties.cache; // -1 is move a row up to the head, +1 is move a row down to the tail, 0 is no shift\n\n      var shiftinstruction = (0, contentfunctions_1.getShiftInstruction)({\n        scrollerID: cradleInheritedProperties.scrollerID,\n        isViewportScrollingForward: isViewportScrollingForward,\n        orientation: orientation,\n        triggerlineEntries: triggerlineEntries,\n        triggerlineSpan: scaffoldHandler.triggerlineSpan\n      }); // second abandon option/3; nothing to do\n\n      if (shiftinstruction == 0) {\n        return;\n      } // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      // const cradleInheritedProperties = this.cradleParameters.cradleInheritedPropertiesRef.current\n      // const viewportElement = this.cradleParameters.viewportInterruptPropertiesRef.current.elementRef.current\n\n\n      var _ref6 = (0, contentfunctions_1.calcContentShift)({\n        shiftinstruction: shiftinstruction,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        cradleContent: cradleContent,\n        cradleElements: cradleElements,\n        scrollPos: scrollPos\n      }),\n          newCradleReferenceIndex = _ref6.newCradleReferenceIndex,\n          cradleItemShift = _ref6.cradleReferenceItemShift,\n          axisReferenceIndex = _ref6.newAxisReferenceIndex,\n          axisItemShift = _ref6.axisReferenceItemShift,\n          axisPixelOffset = _ref6.newAxisPixelOffset,\n          cradleContentCount = _ref6.newCradleContentCount,\n          listStartChangeCount = _ref6.listStartChangeCount,\n          listEndChangeCount = _ref6.listEndChangeCount; // third abandon option/3; nothing to do\n\n\n      if (axisItemShift == 0 && cradleItemShift == 0) {\n        // TODO: is this possible?\n        return;\n      } // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with 'renderupdatedcontent' state in cradle.tsx\n\n\n      interruptHandler.triggerlinesIntersect.observer.disconnect();\n      interruptHandler.signals.pauseTriggerlinesObserver = true; // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect modified content\n\n      var updatedContentList,\n          deletedContentItems = [];\n\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        var _ref7 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheHandler: cacheHandler,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: oldCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef\n        });\n\n        var _ref8 = _slicedToArray(_ref7, 2);\n\n        updatedContentList = _ref8[0];\n        deletedContentItems = _ref8[1];\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n\n      if (deletedContentItems.length && cache == 'cradle') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cradle', deleteList);\n          };\n        }\n\n        (0, contentfunctions_1.deletePortals)(cacheHandler, deletedContentItems, dListCallback);\n      } // ----------------------------------[ 5. allocate cradle content ]--------------------------\n\n\n      var _ref9 = (0, contentfunctions_1.allocateContentList)({\n        contentlist: updatedContentList,\n        axisReferenceIndex: axisReferenceIndex\n      }),\n          _ref10 = _slicedToArray(_ref9, 2),\n          headcontent = _ref10[0],\n          tailcontent = _ref10[1];\n\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, 'updateCradleContent', cstate);\n      } // -------------------------------[ 6. set css changes ]-------------------------\n\n\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n\n      if (cradleInheritedProperties.orientation == 'vertical') {\n        var topPos = scrollPos + axisPixelOffset;\n        axisElement.style.top = topPos + 'px';\n        axisElement.style.left = 'auto';\n        headElement.style.paddingBottom = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      } else {\n        // 'horizontal'\n        var leftPos = scrollPos + axisPixelOffset;\n        axisElement.style.top = 'auto';\n        axisElement.style.left = leftPos + 'px';\n        headElement.style.paddingRight = headcontent.length ? cradleInheritedProperties.gap + 'px' : 0;\n      }\n\n      var cradlePositionData = scaffoldHandler.cradlePositionData;\n      cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n      interruptHandler.triggerlinesIntersect.connectElements();\n      interruptHandler.signals.pauseTriggerlinesObserver = false;\n      stateHandler.setCradleState('renderupdatedcontent');\n    }; // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n\n\n    this.guardAgainstRunawayCaching = function () {\n      var cacheMax = _this.cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n      var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n          contentHandler = _this$cradleParameter2.contentHandler,\n          cacheHandler = _this$cradleParameter2.cacheHandler;\n      var modelComponentList = contentHandler.content.cradleModelComponents;\n      var MAX_CACHE_OVER_RUN = _this.cradleParameters.cradleInheritedPropertiesRef.current.MAX_CACHE_OVER_RUN;\n\n      if (cacheHandler.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n          scrollerID = cradleInheritedProperties.scrollerID;\n\n      if (cache == 'keepload') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheHandler = cradleHandlers.cacheHandler,\n            serviceHandler = cradleHandlers.serviceHandler;\n\n        var modelIndexList = _this.getModelIndexList();\n\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback('pare cache to cacheMax', deleteList);\n          };\n        }\n\n        if (cacheHandler.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback, scrollerID)) {\n          cacheHandler.cacheProps.modified = true;\n          cacheHandler.renderPortalList();\n        }\n      }\n    }; // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n\n\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n\n    this.cradleParameters = cradleParameters;\n  } // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n\n\n  _createClass(ContentHandler, [{\n    key: \"getModelIndexList\",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    } // called from service handler's remapIndexes, as last step\n\n  }, {\n    key: \"reconcileCellFrames\",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var indexToItemIDMap = cacheHandler.cacheProps.indexToItemIDMap;\n\n      function processComponent(component, i, array) {\n        var _component$props = component.props,\n            index = _component$props.index,\n            itemID = _component$props.itemID;\n\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheHandler.getNewItemID();\n\n          if (newItemID != itemID) {\n            // defensive; shouldn't happen\n            array[i] = react_1[\"default\"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n\n      cradleModelComponents.forEach(processComponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports moveIndex and insertRemoveIndex\n\n  }, {\n    key: \"changeCradleItemIDs\",\n    value: function changeCradleItemIDs(changeList) {\n      if (changeList.length == 0) return;\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var _cacheHandler$cachePr = cacheHandler.cacheProps,\n          indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap,\n          metadataMap = _cacheHandler$cachePr.metadataMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = changeList.indexOf(index);\n\n        if (ptr != -1) {\n          var itemID = indexToItemIDMap.get(index);\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: itemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    } // supports insertRemoveIndex\n\n  }, {\n    key: \"createNewItemIDs\",\n    value: function createNewItemIDs(newList) {\n      var cacheHandler = this.cradleParameters.handlersRef.current.cacheHandler;\n      var cradleModelComponents = this.content.cradleModelComponents;\n\n      function processcomponent(component, i, array) {\n        var index = component.props.index;\n        var ptr = newList.indexOf(index);\n\n        if (ptr != -1) {\n          var newItemID = cacheHandler.getNewItemID();\n          array[i] = react_1[\"default\"].cloneElement(component, {\n            itemID: newItemID\n          });\n        }\n      }\n\n      cradleModelComponents.forEach(processcomponent);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n  }]);\n\n  return ContentHandler;\n}();\n\nexports[\"default\"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxJQUFJcUQsR0FBRyxJQUFJLENBQUMsQ0FBWixFQUFlO1VBRVgsSUFBTVgsU0FBUyxHQUFHM0gsWUFBWSxDQUFDOEgsWUFBYixFQUFsQjtVQUNBTCxLQUFLLENBQUNELENBQUQsQ0FBTCxHQUFXTyxtQkFBTUMsWUFBTixDQUFtQlQsU0FBbkIsRUFBOEI7WUFBQ0csTUFBTSxFQUFDQztVQUFSLENBQTlCLENBQVg7UUFFSDtNQUVKOztNQUVEMUkscUJBQXFCLENBQUNnSixPQUF0QixDQUE4QkksZ0JBQTlCO01BRUEsS0FBS3hHLE9BQUwsQ0FBYTNDLG1CQUFiLEdBQW1DRCxxQkFBcUIsQ0FBQ2lKLEtBQXRCLENBQTRCLENBQTVCLEVBQThCLEtBQUtyRyxPQUFMLENBQWEzQyxtQkFBYixDQUFpQzhFLE1BQS9ELENBQW5DO01BQ0EsS0FBS25DLE9BQUwsQ0FBYTFDLG1CQUFiLEdBQW1DRixxQkFBcUIsQ0FBQ2lKLEtBQXRCLENBQTRCLEtBQUtyRyxPQUFMLENBQWEzQyxtQkFBYixDQUFpQzhFLE1BQTdELENBQW5DO0lBRUg7Ozs7OztBQW5tQkx5RSxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9jb250ZW50aGFuZGxlci50c3g/YTg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb250ZW50aGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMSBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFxuICAgIGdldENlbGxGcmFtZUNvbXBvbmVudExpc3QsIFxuICAgIGNhbGNDb250ZW50U2hpZnQsXG4gICAgZ2V0Q29udGVudExpc3RSZXF1aXJlbWVudHMsXG4gICAgZ2V0U2hpZnRJbnN0cnVjdGlvbixcbiAgICBhbGxvY2F0ZUNvbnRlbnRMaXN0LFxuICAgIGRlbGV0ZVBvcnRhbHMsXG5cbn0gZnJvbSAnLi9jb250ZW50ZnVuY3Rpb25zJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50SGFuZGxlciB7XG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICB9XG5cbiAgIHB1YmxpYyBjb250ZW50ID0ge1xuXG4gICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICBoZWFkTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgdGFpbE1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIG9ubHkgdXNlZCBpbiBjcmFkbGUgZm9yIHJlbmRlclxuICAgICAgaGVhZERpc3BsYXlDb21wb25lbnRzOiBbXSxcbiAgICAgIHRhaWxEaXNwbGF5Q29tcG9uZW50czogW10sXG5cbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgaXRlbUVsZW1lbnRzID0gbmV3IE1hcCgpXG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHByaXZhdGUgaW5zdGFuY2VJZENvdW50ZXJSZWYgPSB7XG4gICAgICAgY3VycmVudDowXG4gICAgfVxuICAgIC8vIHByaXZhdGUgaW5zdGFuY2VJZE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgLy8gVHdvIHB1YmxpYyBtZXRob2RzIC0gc2V0Q3JhZGxlQ29udGVudCBhbmQgdXBkYXRlQ3JhZGxlQ29udGVudFxuXG4gICAgLy8gcmVzZXQgY3JhZGxlLCBpbmNsdWRpbmcgYWxsb2NhdGlvbiBiZXR3ZWVuIGhlYWQgYW5kIHRhaWwgcGFydHMgb2YgdGhlIGNyYWRsZVxuICAgIC8vIGNhbGxlZCBvbmx5IGZyb20gY3JhZGxlIHN0YXRlIGhhbmRsZXJcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09WyBTRVQgQ09OVEVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgLy9pbml0aWFsbHkgKGRvc2V0dXApLCBhZnRlciByZXBvc2l0aW9uIChyZXBvc2l0aW9uKSwgb3Igd2l0aCBmaW5pc2hyZXNpemUsIHBpdm90LCBcbiAgICAgLy8gb3IgdXNlciBzaXplIHBhcmFtIHJlY29uZmlndXJlIG9yIHJlbG9hZFxuICAgICAvLyBzZXRDcmFkbGVDb250ZW50IHNldHMgdGhlIHNjcm9sbGJsb2NrJ3Mgc2Nyb2xsIHBvc2l0aW9uLCBhcyB3ZWxsIGFzIGNvbmZpZyBhbmQgY29udGVudFxuXG4gICAgcHVibGljIHNldENyYWRsZUNvbnRlbnQgPSAoIGNyYWRsZVN0YXRlICkgPT4geyBcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlSGFuZGxlcnMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcblxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgc2NhZmZvbGRIYW5kbGVyLFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuXG4gICAgICAgIH0gPSBjcmFkbGVIYW5kbGVyc1xuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgYW5kIGNyYWRsZSB3aW5ncyB3aWxsIGJlIG1vdmVkLCBzbyBkaXNjb25uZWN0IHRoZW0gZnJvbSB0aGVpciBvYnNlcnZlcnMuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlci5kaXNjb25uZWN0KClcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gc2NhZmZvbGRIYW5kbGVyXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXggPSBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgIGxldCB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgY29uc3Qge2Nyb3NzY291bnQsIGxpc3RzaXplfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgICAgIGxldCB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5taW4ocmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4LGxpc3RzaXplIC0gMSlcbiAgICAgICAgd29ya2luZ0F4aXNSZWZlcmVuY2VJbmRleCAtPSAod29ya2luZ0F4aXNSZWZlcmVuY2VJbmRleCAlIGNyb3NzY291bnQpXG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBhdCByb3cgYm91bmRhcnlcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcicsIFxuICAgICAgICAgICAgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJyxcbiAgICAgICAgICAgICdyZXBvc2l0aW9uJywgXG4gICAgICAgICAgICAncmVjb25maWd1cmUnLCBcbiAgICAgICAgICAgICdzY3JvbGx0bycsIFxuICAgICAgICBdLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgICh3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ID09IDApP1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOlxuICAgICAgICAgICAgICAgICAgICBnYXAgLy8gZGVmYXVsdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3b3JraW5nQ29udGVudExpc3QgPSBbXVxuICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMi4gZ2V0IGNvbnRlbnQgcmVxdWlyZW1lbnRzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3Qgcm93TGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgKGNlbGxIZWlnaHQgKyBnYXApOlxuICAgICAgICAgICAgICAgIChjZWxsV2lkdGggKyBnYXApXG5cbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB0YXJnZXRBeGlzUm93T2Zmc2V0LFxuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50OmNyYWRsZUNvbnRlbnRDb3VudCwgXG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6c2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuXG4gICAgICAgIH0gPSBcbiAgICAgICAgICAgIGdldENvbnRlbnRMaXN0UmVxdWlyZW1lbnRzKHtcblxuICAgICAgICAgICAgICAgIHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXg6cmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBjcmFkbGVTdGF0ZSwgc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgnLFxuICAgICAgICAvLyAgICAgJy0nK3Njcm9sbGVySUQrJy0nLCBjcmFkbGVTdGF0ZSwgc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICAgICAgY29uc3QgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIGdldCBhbmQgY29uZmlnIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIC8vIHJldHVybnMgY29udGVudCBjb25zdHJhaW5lZCBieSBjcmFkbGVSb3djb3VudFxuICAgICAgICBjb25zdCBbbmV3Y29udGVudGxpc3QsZGVsZXRlZGl0ZW1zXSA9IGdldENlbGxGcmFtZUNvbXBvbmVudExpc3Qoe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsICAgICAgICAgICAgXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6dGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudDowLFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpuZXdjb250ZW50bGlzdCxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDp0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgXG4gICAgICAgIH0pXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSBuZXdjb250ZW50bGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmIChzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjaykge1xuXG4gICAgICAgICAgICBsZXQgY3N0YXRlID0gY3JhZGxlU3RhdGVcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCdzZXRDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiBzZXQgQ1NTIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPVxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zXG5cbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBzY2FmZm9sZEhhbmRsZXIuZWxlbWVudHMgLy9jcmFkbGVFbGVtZW50c1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgQXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wID0gQXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50bGlzdC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gQXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgZ2FwICsgJ3B4JzpcbiAgICAgICAgICAgICAgICAgICAgMFxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNS4gcmVzZXQgaW50ZXJydXB0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT1bIFVQREFURSBDT05URU5UIHRocm91Z2ggc2Nyb2xsIF09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHVwZGF0ZUNyYWRsZUNvbnRlbnQgZG9lcyBub3QgdG91Y2ggdGhlIHZpZXdwb3J0IGVsZW1lbnQncyBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBzY3JvbGxibG9ja1xuICAgIC8vIGluc3RlYWQgaXQgcmVjb25maWd1cmVzIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3JhZGxlXG5cbiAgICBwdWJsaWMgdXBkYXRlQ3JhZGxlQ29udGVudCA9IChcbiAgICAgICAgaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQsIHRyaWdnZXJsaW5lRW50cmllcywgc291cmNlID0gJ25vdGlmaWNhdGlvbnMnKSA9PiB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMS4gaW5pdGlhbGl6ZSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhhbmRsZXIgc3VwcG9ydFxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBzY2FmZm9sZEhhbmRsZXIsIFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLCBcbiAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIsXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gc2Nyb2xsIGRhdGFcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSBzY3JvbGxIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlXG5cbiAgICAgICAgLy8gZmlyc3QgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoIHNjcm9sbFBvcyA8IDApIHsgLy8gZm9yIFNhZmFyaSwgRkYgZWxhc3RpYyBib3VuY2UgYXQgdG9wIG9mIHNjcm9sbFxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JhZGxlIHNjYWZmb2xkIGFuZCB1c2VyIGNlbGxzXG4gICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gc2NhZmZvbGRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgIGNvbnN0IGNyYWRsZUNvbnRlbnQgPSB0aGlzLmNvbnRlbnRcbiAgICAgICAgY29uc3QgbW9kZWxjb250ZW50bGlzdCA9IGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzIHx8IFtdXG4gICAgICAgIGNvbnN0IG9sZENyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG1vZGVsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDIuIGdldCBzaGlmdCBpbnN0cnVjdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIC8vIC0xIGlzIG1vdmUgYSByb3cgdXAgdG8gdGhlIGhlYWQsICsxIGlzIG1vdmUgYSByb3cgZG93biB0byB0aGUgdGFpbCwgMCBpcyBubyBzaGlmdFxuICAgICAgICBjb25zdCBzaGlmdGluc3RydWN0aW9uID0gZ2V0U2hpZnRJbnN0cnVjdGlvbih7XG4gICAgICAgICAgICBzY3JvbGxlcklEOiBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLnNjcm9sbGVySUQsXG4gICAgICAgICAgICBpc1ZpZXdwb3J0U2Nyb2xsaW5nRm9yd2FyZCxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgdHJpZ2dlcmxpbmVFbnRyaWVzLFxuICAgICAgICAgICAgdHJpZ2dlcmxpbmVTcGFuOiBzY2FmZm9sZEhhbmRsZXIudHJpZ2dlcmxpbmVTcGFuLFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHNlY29uZCBhYmFuZG9uIG9wdGlvbi8zOyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09IDApIHtcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMy4gQ2FsY3VsYXRlIHNoaWZ0cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGNyYWRsZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIC8vIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0OmNyYWRsZUl0ZW1TaGlmdCwgXG4gICAgICAgICAgICBuZXdBeGlzUmVmZXJlbmNlSW5kZXg6YXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJdGVtU2hpZnQ6YXhpc0l0ZW1TaGlmdCwgXG4gICAgICAgICAgICBuZXdBeGlzUGl4ZWxPZmZzZXQ6YXhpc1BpeGVsT2Zmc2V0LCBcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudDpjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCxcblxuICAgICAgICB9ID0gY2FsY0NvbnRlbnRTaGlmdCh7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudCxcbiAgICAgICAgICAgIGNyYWRsZUVsZW1lbnRzLFxuICAgICAgICAgICAgc2Nyb2xsUG9zLFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdGhpcmQgYWJhbmRvbiBvcHRpb24vMzsgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoKGF4aXNJdGVtU2hpZnQgPT0gMCAmJiBjcmFkbGVJdGVtU2hpZnQgPT0gMCkpIHsgLy8gVE9ETzogaXMgdGhpcyBwb3NzaWJsZT9cblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSB0cmlnZ2VybGluZXMgd2lsbCBiZSBtb3ZlZCwgc28gZGlzY29ubmVjdCB0aGVtIGZyb20gdGhlaXIgb2JzZXJ2ZXIuXG4gICAgICAgIC8vIHRoZXkgYXJlIHJlY29ubmVjdGVkIHdpdGggJ3JlbmRlcnVwZGF0ZWRjb250ZW50JyBzdGF0ZSBpbiBjcmFkbGUudHN4XG4gICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA0LiByZWNvbmZpZ3VyZSBjcmFkbGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb2xsZWN0IG1vZGlmaWVkIGNvbnRlbnRcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50TGlzdCwgZGVsZXRlZENvbnRlbnRJdGVtcyA9IFtdXG5cbiAgICAgICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50IHx8IGxpc3RFbmRDaGFuZ2VDb3VudCkgeyAvLyBpZiBlaXRoZXIgaXMgbm9uLTAgdGhlbiBtb2RpZnkgY29udGVudFxuXG4gICAgICAgICAgICBbdXBkYXRlZENvbnRlbnRMaXN0LGRlbGV0ZWRDb250ZW50SXRlbXNdID0gZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCh7XG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgICAgICB3b3JraW5nQ29udGVudExpc3Q6bW9kZWxjb250ZW50bGlzdCxcbiAgICAgICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBsaXN0RW5kQ2hhbmdlQ291bnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6b2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWY6dGhpcy5pbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdXBkYXRlZENvbnRlbnRMaXN0ID0gbW9kZWxjb250ZW50bGlzdFxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsZXRlZENvbnRlbnRJdGVtcy5sZW5ndGggJiYgKGNhY2hlID09ICdjcmFkbGUnKSkge1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNyYWRsZScsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGVQb3J0YWxzKGNhY2hlSGFuZGxlciwgZGVsZXRlZENvbnRlbnRJdGVtcywgZExpc3RDYWxsYmFjaylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNS4gYWxsb2NhdGUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50LCB0YWlsY29udGVudF0gPSBhbGxvY2F0ZUNvbnRlbnRMaXN0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0OnVwZGF0ZWRDb250ZW50TGlzdCxcbiAgICAgICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBjcmFkbGVDb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cyA9IHVwZGF0ZWRDb250ZW50TGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudFxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSB0YWlsY29udGVudFxuXG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGxldCBjc3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MucmVmZXJlbmNlSW5kZXhDYWxsYmFjayhcblxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwndXBkYXRlQ3JhZGxlQ29udGVudCcsIGNzdGF0ZSlcbiAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA2LiBzZXQgY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBoZWFkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmhlYWRSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29uc3QgdG9wUG9zID0gc2Nyb2xsUG9zICsgYXhpc1BpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArICdweCdcbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcy5nYXAgKyAncHgnOlxuICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQb3MgPSBzY3JvbGxQb3MgKyBheGlzUGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBvcyArICdweCdcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnQubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmdhcCArICdweCc6XG4gICAgICAgICAgICAgICAgICAgIDBcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IHNjYWZmb2xkSGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1BpeGVsT2Zmc2V0XG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSBmYWxzZVxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVuZGVydXBkYXRlZGNvbnRlbnQnKVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBbIElOVEVSTkFMIENPTlRFTlQgTUFOQUdFTUVOVCBTRVJWSUNFUyBdPT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcgPSAoKSA9PiB7IFxuICAgICAgICBjb25zdCB7IGNhY2hlTWF4IH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY29udGVudEhhbmRsZXIsIGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgbW9kZWxDb21wb25lbnRMaXN0ID0gY29udGVudEhhbmRsZXIuY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHNcbiBcbiAgICAgICAgY29uc3QgeyBNQVhfQ0FDSEVfT1ZFUl9SVU4gfSA9ICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGlmIChjYWNoZUhhbmRsZXIuZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcoY2FjaGVNYXgsIG1vZGVsQ29tcG9uZW50TGlzdC5sZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTiApKSB7XG5cbiAgICAgICAgICAgIHRoaXMucGFyZUNhY2hlVG9NYXgoKVxuXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcHVibGljIHBhcmVDYWNoZVRvTWF4ID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZSwgc2Nyb2xsZXJJRCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVIYW5kbGVycyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IGNyYWRsZUhhbmRsZXJzXG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gdGhpcy5nZXRNb2RlbEluZGV4TGlzdCgpXG5cblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjYWNoZU1heCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FjaGVIYW5kbGVyLnBhcmVDYWNoZVRvTWF4KFxuICAgICAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMuY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrLCBzY3JvbGxlcklEKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgRVhURVJOQUwgU0VSVklDRSBTVVBQT1JUIF09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gc3VwcG9ydHMgY2xlYXJDYWNoZVxuICAgIHB1YmxpYyBjbGVhckNyYWRsZSA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gdGhpcy5jb250ZW50XG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBbXVxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBbXVxuXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gc2VydmljZUhhbmRsZXIgZ2V0Q3JhZGxlSW5kZXhNYXBcbiAgICAvLyBhbHNvIHN1cHBvcnRzIHBhcmVDYWNoZVRvTWF4LCBtYXRjaENhY2hlVG9DcmFkbGVcbiAgICBwdWJsaWMgZ2V0TW9kZWxJbmRleExpc3QoKSB7XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGlmICghY3JhZGxlTW9kZWxDb21wb25lbnRzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbXSBcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gY3JhZGxlTW9kZWxDb21wb25lbnRzLm1hcCgoaXRlbSk9Pml0ZW0ucHJvcHMuaW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gc2VydmljZSBoYW5kbGVyJ3MgcmVtYXBJbmRleGVzLCBhcyBsYXN0IHN0ZXBcbiAgICBwdWJsaWMgcmVjb25jaWxlQ2VsbEZyYW1lcyhtb2RpZmllZEluZGV4ZXNMaXN0KSB7XG5cbiAgICAgICAgaWYgKCFtb2RpZmllZEluZGV4ZXNMaXN0Lmxlbmd0aCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHNcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChjb21wb25lbnQsIGksIGFycmF5ICkge1xuICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgaXRlbUlEIH0gPSBjb21wb25lbnQucHJvcHNcbiAgICAgICAgICAgIGlmIChtb2RpZmllZEluZGV4ZXNMaXN0LmluY2x1ZGVzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gXG4gICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSGFuZGxlci5nZXROZXdJdGVtSUQoKVxuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1JRCAhPSBpdGVtSUQpIHsgLy8gZGVmZW5zaXZlOyBzaG91bGRuJ3QgaGFwcGVuXG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzQ29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBtb3ZlSW5kZXggYW5kIGluc2VydFJlbW92ZUluZGV4XG4gICAgcHVibGljIGNoYW5nZUNyYWRsZUl0ZW1JRHMoY2hhbmdlTGlzdCkge1xuXG4gICAgICAgIGlmIChjaGFuZ2VMaXN0Lmxlbmd0aCA9PSAwKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwLCBtZXRhZGF0YU1hcCB9ID0gY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHNcblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc2NvbXBvbmVudChjb21wb25lbnQsIGksIGFycmF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LnByb3BzLmluZGV4XG5cbiAgICAgICAgICAgIGNvbnN0IHB0ciA9IGNoYW5nZUxpc3QuaW5kZXhPZihpbmRleClcblxuICAgICAgICAgICAgaWYgKHB0ciAhPSAtMSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG5cbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUR9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHMuZm9yRWFjaChwcm9jZXNzY29tcG9uZW50KVxuXG4gICAgICAgIHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICB0aGlzLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSh0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG5cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBpbnNlcnRSZW1vdmVJbmRleFxuICAgIHB1YmxpYyBjcmVhdGVOZXdJdGVtSURzKG5ld0xpc3QpIHtcblxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc2NvbXBvbmVudChjb21wb25lbnQsIGksIGFycmF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LnByb3BzLmluZGV4XG4gICAgICAgICAgICBjb25zdCBwdHIgPSBuZXdMaXN0LmluZGV4T2YoaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChwdHIgIT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IGNhY2hlSGFuZGxlci5nZXROZXdJdGVtSUQoKVxuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5mb3JFYWNoKHByb2Nlc3Njb21wb25lbnQpXG5cbiAgICAgICAgdGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoMCx0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgIHRoaXMuY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgIH1cblxufSJdLCJuYW1lcyI6WyJDb250ZW50SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJoZWFkTW9kZWxDb21wb25lbnRzIiwidGFpbE1vZGVsQ29tcG9uZW50cyIsImhlYWREaXNwbGF5Q29tcG9uZW50cyIsInRhaWxEaXNwbGF5Q29tcG9uZW50cyIsImN1cnJlbnQiLCJjcmFkbGVTdGF0ZSIsInZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyIsInZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSGFuZGxlcnMiLCJoYW5kbGVyc1JlZiIsImNhY2hlSGFuZGxlciIsInNjYWZmb2xkSGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwiaW50ZXJydXB0SGFuZGxlciIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyYWRsZUludGVyc2VjdCIsImNyYWRsZVBvc2l0aW9uRGF0YSIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsIm9yaWVudGF0aW9uIiwiZ2FwIiwicGFkZGluZyIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJjYWNoZSIsInNjcm9sbGVySUQiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJ3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4IiwiTWF0aCIsIm1pbiIsImluY2x1ZGVzIiwid29ya2luZ0NvbnRlbnRMaXN0IiwiY3JhZGxlQ29udGVudCIsImNvbnRlbnQiLCJyb3dMZW5ndGgiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNSb3dPZmZzZXQiLCJjcmFkbGVDb250ZW50Q291bnQiLCJuZXdDcmFkbGVDb250ZW50Q291bnQiLCJzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJ0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJheGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZVJlZmVyZW5jZUluZGV4IiwibGlzdFN0YXJ0Q2hhbmdlQ291bnQiLCJsaXN0RW5kQ2hhbmdlQ291bnQiLCJpbnN0YW5jZUlkQ291bnRlclJlZiIsIm5ld2NvbnRlbnRsaXN0IiwiZGVsZXRlZGl0ZW1zIiwiY29udGVudGxpc3QiLCJheGlzUmVmZXJlbmNlSW5kZXgiLCJoZWFkY29udGVudGxpc3QiLCJ0YWlsY29udGVudGxpc3QiLCJjYWxsYmFja3MiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwiY3N0YXRlIiwiYmxvY2tTY3JvbGxQb3MiLCJibG9ja1Njcm9sbFByb3BlcnR5IiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsImhlYWRFbGVtZW50IiwiaGVhZFJlZiIsIkF4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0IiwidG9wIiwic3R5bGUiLCJsZWZ0IiwicGFkZGluZ0JvdHRvbSIsImxlbmd0aCIsInBhZGRpbmdSaWdodCIsImNvbm5lY3RFbGVtZW50cyIsInNpZ25hbHMiLCJwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyIiwiaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQiLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJzb3VyY2UiLCJzY3JvbGxIYW5kbGVyIiwic3RhdGVIYW5kbGVyIiwic2Nyb2xsRGF0YSIsInNjcm9sbFBvcyIsImN1cnJlbnR1cGRhdGUiLCJtb2RlbGNvbnRlbnRsaXN0Iiwib2xkQ3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJfYSIsInByb3BzIiwiaW5kZXgiLCJzaGlmdGluc3RydWN0aW9uIiwidHJpZ2dlcmxpbmVTcGFuIiwibmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjcmFkbGVJdGVtU2hpZnQiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzSXRlbVNoaWZ0IiwiYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCIsImF4aXNQaXhlbE9mZnNldCIsIm5ld0F4aXNQaXhlbE9mZnNldCIsInVwZGF0ZWRDb250ZW50TGlzdCIsImRlbGV0ZWRDb250ZW50SXRlbXMiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsImhlYWRjb250ZW50IiwidGFpbGNvbnRlbnQiLCJjcmFkbGVTdGF0ZVJlZiIsInRvcFBvcyIsImxlZnRQb3MiLCJzZXRDcmFkbGVTdGF0ZSIsImNhY2hlTWF4IiwiY29udGVudEhhbmRsZXIiLCJtb2RlbENvbXBvbmVudExpc3QiLCJNQVhfQ0FDSEVfT1ZFUl9SVU4iLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInBhcmVDYWNoZVRvTWF4IiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsImNhY2hlUHJvcHMiLCJtb2RpZmllZCIsInJlbmRlclBvcnRhbExpc3QiLCJtYXAiLCJpdGVtIiwibW9kaWZpZWRJbmRleGVzTGlzdCIsImluZGV4VG9JdGVtSURNYXAiLCJwcm9jZXNzQ29tcG9uZW50IiwiY29tcG9uZW50IiwiaSIsImFycmF5IiwiaXRlbUlEIiwibmV3SXRlbUlEIiwiaGFzIiwiZ2V0IiwiZ2V0TmV3SXRlbUlEIiwicmVhY3RfMSIsImNsb25lRWxlbWVudCIsImZvckVhY2giLCJzbGljZSIsImNoYW5nZUxpc3QiLCJtZXRhZGF0YU1hcCIsInByb2Nlc3Njb21wb25lbnQiLCJwdHIiLCJpbmRleE9mIiwibmV3TGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n");

/***/ }),

/***/ "./src/cradle/interrupthandler.tsx":
/*!*****************************************!*\
  !*** ./src/cradle/interrupthandler.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(" // interruptshandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar resize_observer_1 = __webpack_require__(/*! @juggle/resize-observer */ \"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n\nvar ResizeObserver = window['ResizeObserver'] || resize_observer_1.ResizeObserver;\n\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, InterruptHandler);\n\n  this.isTailCradleInView = false;\n  this.isHeadCradleInView = false; // TODO: stub\n\n  this.cradleresizeobservercallback = function (entries) {\n    if (_this.signals.pauseCradleResizeObserver) return;\n  };\n\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    if (_this.signals.pauseTriggerlinesObserver) {\n      // console.log('returning from axisTriggerlinesObserverCallback with pause!')\n      return;\n    }\n\n    var testrootbounds = entries[0].rootBounds;\n\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter.contentHandler,\n        stateHandler = _this$cradleParameter.stateHandler,\n        scrollHandler = _this$cradleParameter.scrollHandler,\n        scaffoldHandler = _this$cradleParameter.scaffoldHandler;\n\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n\n      if (scrollData.start != scrollData.current || scrollData.current != scrollData.previous) {\n        scrollData.previousupdate = scrollData.currentupdate;\n        scrollData.currentupdate = scrollData.current;\n        var isViewportScrollingForward;\n\n        if (scrollData.previousupdate == scrollData.currentupdate) {\n          isViewportScrollingForward = scrollData.previous < scrollData.current;\n        } else {\n          isViewportScrollingForward = scrollData.previousupdate < scrollData.currentupdate;\n        }\n\n        var scrollerID = _this.cradleParameters.cradleInheritedPropertiesRef.current.scrollerID;\n        contentHandler.updateCradleContent(isViewportScrollingForward, entries, 'triggerlinesObserver');\n      }\n    }\n  };\n\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var _a;\n\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter2.stateHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler;\n\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.type == 'head') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n\n    if (_this.signals.repositioningRequired) // start reposition if no other interrupts are underway\n      {\n        var cradleState = stateHandler.cradleStateRef.current;\n\n        if (!viewportInterruptProperties.isResizing && !((_a = viewportInterruptProperties.isReparentingRef) === null || _a === void 0 ? void 0 : _a.current) && !(cradleState == 'repositioningRender') && !(cradleState == 'repositioningContinuation') && !(cradleState == 'renderupdatedcontent') && // TODO: *TEST*\n        !(cradleState == 'finishupdatedcontent') && !(cradleState == 'finishresize') && !(cradleState == 'reposition') && !(cradleState == 'pivot')) {\n          var element = viewportInterruptProperties.elementRef.current;\n          var scrollerID = _this.cradleParameters.cradleInheritedPropertiesRef.current.scrollerID;\n\n          if (!element) {\n            console.log('SYSTEM: viewport element not set in cradleIntersectionObserverCallback', scrollerID, viewportInterruptProperties);\n            return;\n          } // TODO this is a duplicate setting procedure with viewport.tsx\n\n\n          var rect = element.getBoundingClientRect();\n          var top = rect.top,\n              right = rect.right,\n              bottom = rect.bottom,\n              left = rect.left;\n          var width = right - left,\n              height = bottom - top;\n          viewportInterruptProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          }; // update for scrolltracker\n          // console.log('calling startreposition from cradleIntersectionObserverCallback:scrollerID, entries',\n          //  '-' + scrollerID + '-', entries)\n\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          stateHandler.setCradleState('startreposition');\n        }\n      }\n  }; // for adjusting to content re-sizing\n\n\n  this.cradleResize = {\n    observer: null,\n    callback: this.cradleresizeobservercallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleResize.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.scaffoldHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      _this.cradleResize.observer = new ResizeObserver(_this.cradleResize.callback);\n      return _this.cradleResize.observer;\n    }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.scaffoldHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n    },\n    createObserver: function createObserver() {\n      var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: viewportInterruptProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    connectElements: function connectElements() {\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.scaffoldHandler.elements;\n      observer.observe(cradleElements.headTriggerlineRef.current);\n      observer.observe(cradleElements.axisTriggerlineRef.current);\n      observer.observe(cradleElements.tailTriggerlineRef.current);\n    },\n    createObserver: function createObserver() {\n      var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: viewportInterruptProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger resizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - normalizesignals\n  */\n\n\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBaEM7RUFDSCxDQU5NOztFQTdOSixLQUFLL0UsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUVGLEM7O0FBTkxnRixrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdHNoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIxIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyIGFzIFJlc2l6ZU9ic2VydmVyUG9seWZpbGx9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJ1xuXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHdpbmRvd1snUmVzaXplT2JzZXJ2ZXInXSB8fCBSZXNpemVPYnNlcnZlclBvbHlmaWxsXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVycnVwdEhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwcml2YXRlIGlzVGFpbENyYWRsZUluVmlldyA9IGZhbHNlXG4gICAgcHJpdmF0ZSBpc0hlYWRDcmFkbGVJblZpZXcgPSBmYWxzZVxuXG4gICAgLy8gVE9ETzogc3R1YlxuICAgIHByaXZhdGUgY3JhZGxlcmVzaXplb2JzZXJ2ZXJjYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICBpZiAodGhpcy5zaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIpIHJldHVyblxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyKSB7IFxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmV0dXJuaW5nIGZyb20gYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2sgd2l0aCBwYXVzZSEnKVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdHJvb3Rib3VuZHMgPSBlbnRyaWVzWzBdLnJvb3RCb3VuZHNcbiAgICAgICAgaWYgKCh0ZXN0cm9vdGJvdW5kcy53aWR0aCA9PSAwKSAmJiAodGVzdHJvb3Rib3VuZHMuaGVpZ2h0ID09IDApKSB7IC8vIHJlcGFyZW50aW5nXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlcixcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlcixcbiAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG4gICAgICAgICAgICBzY2FmZm9sZEhhbmRsZXIsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gc2Nyb2xsSGFuZGxlclxuICAgICAgICAgICAgaWYgKChzY3JvbGxEYXRhLnN0YXJ0ICE9IHNjcm9sbERhdGEuY3VycmVudCkgfHxcbiAgICAgICAgICAgICAgICAoc2Nyb2xsRGF0YS5jdXJyZW50ICE9IHNjcm9sbERhdGEucHJldmlvdXMpKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxEYXRhLnByZXZpb3VzdXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlXG4gICAgICAgICAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICBsZXQgaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmRcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9PSBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQgPSBzY3JvbGxEYXRhLnByZXZpb3VzIDwgc2Nyb2xsRGF0YS5jdXJyZW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQgPSAoc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA8IHNjcm9sbERhdGEuY3VycmVudHVwZGF0ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbGVySUQgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnVwZGF0ZUNyYWRsZUNvbnRlbnQoaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQsIGVudHJpZXMsJ3RyaWdnZXJsaW5lc09ic2VydmVyJylcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcblxuICAgICAgICBjb25zdCBzaWduYWxzID0gdGhpcy5zaWduYWxzXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWRDcmFkbGVJblZpZXcgPSBcbiAgICAgICAgICAgICAgICAgICAgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUYWlsQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyAgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGVudHJ5LnJvb3RCb3VuZHMud2lkdGggPT0gMCkgJiYgKGVudHJ5LnJvb3RCb3VuZHMuaGVpZ2h0ID09IDApKSAvLyByZXBhcmVudGluZ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSAoIXRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ICYmICF0aGlzLmlzVGFpbENyYWRsZUluVmlldylcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMudmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnJlcG9zaXRpb25pbmdSZXF1aXJlZCkgLy8gc3RhcnQgcmVwb3NpdGlvbiBpZiBubyBvdGhlciBpbnRlcnJ1cHRzIGFyZSB1bmRlcndheVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcgJiZcbiAgICAgICAgICAgICAgICAhdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmlzUmVwYXJlbnRpbmdSZWY/LmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicpICYmXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVuZGVydXBkYXRlZGNvbnRlbnQnKSAmJiAvLyBUT0RPOiAqVEVTVCpcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdmaW5pc2h1cGRhdGVkY29udGVudCcpICYmXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAnZmluaXNocmVzaXplJykgJiZcbiAgICAgICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uJykgJiYgXG4gICAgICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncGl2b3QnKVxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJJRCB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU1lTVEVNOiB2aWV3cG9ydCBlbGVtZW50IG5vdCBzZXQgaW4gY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyBhIGR1cGxpY2F0ZSBzZXR0aW5nIHByb2NlZHVyZSB3aXRoIHZpZXdwb3J0LnRzeFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgY29uc3Qge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSByZWN0XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy52aWV3cG9ydERpbWVuc2lvbnMgPSB7dG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSAvLyB1cGRhdGUgZm9yIHNjcm9sbHRyYWNrZXJcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsaW5nIHN0YXJ0cmVwb3NpdGlvbiBmcm9tIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2s6c2Nyb2xsZXJJRCwgZW50cmllcycsXG4gICAgICAgICAgICAgICAgLy8gICctJyArIHNjcm9sbGVySUQgKyAnLScsIGVudHJpZXMpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayh0cnVlKVxuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgIC8vIGZvciBhZGp1c3RpbmcgdG8gY29udGVudCByZS1zaXppbmdcbiAgIHB1YmxpYyBjcmFkbGVSZXNpemUgPSB7XG4gICAgICBvYnNlcnZlcjpudWxsLFxuICAgICAgY2FsbGJhY2s6dGhpcy5jcmFkbGVyZXNpemVvYnNlcnZlcmNhbGxiYWNrLFxuICAgICAgICBjb25uZWN0RWxlbWVudHM6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLmNyYWRsZVJlc2l6ZS5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5zY2FmZm9sZEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgIH0sXG4gICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVSZXNpemUub2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5jcmFkbGVSZXNpemUuY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB0aGlzLmNyYWRsZVJlc2l6ZS5vYnNlcnZlclxuXG4gICAgICB9XG4gICB9XG5cbiAgIHB1YmxpYyBjcmFkbGVJbnRlcnNlY3QgPSB7ICAgIFxuICAgICAgICBvYnNlcnZlcjpudWxsLCAgICBcbiAgICAgICAgY2FsbGJhY2s6dGhpcy5jcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBjb25uZWN0RWxlbWVudHM6KCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5zY2FmZm9sZEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9ic2VydmVyOigpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6dmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCwgdGhyZXNob2xkOjB9XG4gICAgICAgICAgICApICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgIHB1YmxpYyB0cmlnZ2VybGluZXNJbnRlcnNlY3QgPSB7XG4gICAgICAgIG9ic2VydmVyOm51bGwsXG4gICAgICAgIGNhbGxiYWNrOnRoaXMuYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2ssXG4gICAgICAgIGNvbm5lY3RFbGVtZW50czooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LnNjYWZmb2xkSGFuZGxlci5lbGVtZW50c1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy5oZWFkVHJpZ2dlcmxpbmVSZWYuY3VycmVudClcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuYXhpc1RyaWdnZXJsaW5lUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRhaWxUcmlnZ2VybGluZVJlZi5jdXJyZW50KVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMudmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHtyb290OnZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2lnbmFscyA9IHtcbiAgICAgICAgcmVwb3NpdGlvbmluZ1JlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlcjogZmFsc2UsIFxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyOmZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvciBcbiAgICAgICAgY3JhZGxlOlxuICAgICAgICAtIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgIC0gdHJpZ2dlciByZXNpemluZ1xuICAgICAgICAtIHRyaWdnZXIgcmVjb25maWd1cmF0aW9uXG4gICAgICAgIC0gdHJpZ2dlciBwaXZvdFxuICAgICAgICBzZXJ2aWNlaGFuZGxlcjpcbiAgICAgICAgLSBjYWxsIHJlbG9hZFxuICAgICovXG4gICAgcHVibGljIHBhdXNlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuICAgIH1cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvclxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gbm9ybWFsaXplc2lnbmFsc1xuICAgICovXG4gICAgcHVibGljIHJlc3RvcmVJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXNcbiAgICAgICAgc2lnbmFscy5wYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyID0gZmFsc2VcbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSBmYWxzZVxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwicmVzaXplX29ic2VydmVyXzEiLCJJbnRlcnJ1cHRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImVudHJpZXMiLCJzaWduYWxzIiwicGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciIsInBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIiLCJ0ZXN0cm9vdGJvdW5kcyIsInJvb3RCb3VuZHMiLCJ3aWR0aCIsImhlaWdodCIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImNvbnRlbnRIYW5kbGVyIiwic3RhdGVIYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsInNjYWZmb2xkSGFuZGxlciIsImlzTW91bnRlZFJlZiIsInNjcm9sbERhdGEiLCJzdGFydCIsInByZXZpb3VzIiwicHJldmlvdXN1cGRhdGUiLCJjdXJyZW50dXBkYXRlIiwiaXNWaWV3cG9ydFNjcm9sbGluZ0ZvcndhcmQiLCJzY3JvbGxlcklEIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsInVwZGF0ZUNyYWRsZUNvbnRlbnQiLCJzZXJ2aWNlSGFuZGxlciIsInBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpIiwibGVuZ3RoIiwiZW50cnkiLCJ0YXJnZXQiLCJkYXRhc2V0IiwidHlwZSIsImlzSGVhZENyYWRsZUluVmlldyIsImlzSW50ZXJzZWN0aW5nIiwiaXNUYWlsQ3JhZGxlSW5WaWV3IiwicmVwb3NpdGlvbmluZ1JlcXVpcmVkIiwidmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzIiwidmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImlzUmVzaXppbmciLCJpc1JlcGFyZW50aW5nUmVmIiwiX2EiLCJlbGVtZW50IiwiZWxlbWVudFJlZiIsImNvbnNvbGUiLCJsb2ciLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwidmlld3BvcnREaW1lbnNpb25zIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsImNhbGxiYWNrcyIsInNldENyYWRsZVN0YXRlIiwib2JzZXJ2ZXIiLCJjYWxsYmFjayIsImNyYWRsZXJlc2l6ZW9ic2VydmVyY2FsbGJhY2siLCJjb25uZWN0RWxlbWVudHMiLCJjcmFkbGVSZXNpemUiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwib2JzZXJ2ZSIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiY3JlYXRlT2JzZXJ2ZXIiLCJjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrIiwiY3JhZGxlSW50ZXJzZWN0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290IiwidGhyZXNob2xkIiwiYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2siLCJ0cmlnZ2VybGluZXNJbnRlcnNlY3QiLCJoZWFkVHJpZ2dlcmxpbmVSZWYiLCJheGlzVHJpZ2dlcmxpbmVSZWYiLCJ0YWlsVHJpZ2dlcmxpbmVSZWYiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n");

/***/ }),

/***/ "./src/cradle/scaffoldhandler.tsx":
/*!****************************************!*\
  !*** ./src/cradle/scaffoldhandler.tsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval(" // cradlehandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar ScaffoldHandler = /*#__PURE__*/function () {\n  function ScaffoldHandler(cradleParameters) {\n    _classCallCheck(this, ScaffoldHandler);\n\n    // cradlePositionData controls the relative positions of the scaffold elements\n    this.cradlePositionData = {\n      /*\n          \"block\" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n\n      /*\n          values can be \"scrollTop\" or \"scrollLeft\" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n\n      /*\n          targetAxisReferenceIndex is set by\n              - setCradleContent\n              - updateCradleContent\n              - scaffoldHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToItem call\n               targetAxisReferenceIndex is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferenceIndex: null,\n\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - scaffoldHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // into the viewport\n\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n        axisRef = _cradleParameters$cra.axisRef,\n        headRef = _cradleParameters$cra.headRef,\n        tailRef = _cradleParameters$cra.tailRef,\n        headTriggerlineRef = _cradleParameters$cra.headTriggerlineRef,\n        axisTriggerlineRef = _cradleParameters$cra.axisTriggerlineRef,\n        tailTriggerlineRef = _cradleParameters$cra.tailTriggerlineRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      headTriggerlineRef: headTriggerlineRef,\n      axisTriggerlineRef: axisTriggerlineRef,\n      tailTriggerlineRef: tailTriggerlineRef\n    };\n    var _this$cradleParameter = this.cradleParameters.cradleInheritedPropertiesRef.current,\n        startingIndex = _this$cradleParameter.startingIndex,\n        padding = _this$cradleParameter.padding;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // progression of references: implied->target\n\n    this.cradlePositionData.targetAxisReferenceIndex = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n\n  _createClass(ScaffoldHandler, [{\n    key: \"getViewportDimensions\",\n    value: function getViewportDimensions() {\n      var viewportElement = this.cradleParameters.viewportInterruptPropertiesRef.current.elementRef.current;\n      return {\n        width: viewportElement.clientWidth,\n        height: viewportElement.clientHeight\n      };\n    }\n  }, {\n    key: \"getViewportScrollPos\",\n    value: function getViewportScrollPos() {\n      var viewportElement = this.cradleParameters.viewportInterruptPropertiesRef.current.elementRef.current;\n      var top = viewportElement.scrollTop;\n      var left = viewportElement.scrollLeft;\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }]);\n\n  return ScaffoldHandler;\n}();\n\nexports[\"default\"] = ScaffoldHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3NjYWZmb2xkaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxlO0VBRWpCLHlCQUFZQyxnQkFBWixFQUE0QjtJQUFBOztJQTBDNUI7SUFDTywwQkFBcUI7TUFFeEI7Ozs7Ozs7O01BV0FDLGNBQWMsRUFBQyxJQWJTOztNQWV4Qjs7Ozs7TUFPQUMsbUJBQW1CLEVBQUMsSUF0Qkk7O01Bd0J4Qjs7Ozs7Ozs7Ozs7TUFZQUMsd0JBQXdCLEVBQUMsSUFwQ0Q7O01Bc0N4Qjs7Ozs7Ozs7Ozs7TUFhQUMsNkJBQTZCLEVBQUMsSUFuRE4sQ0FtRFk7O0lBbkRaLENBQXJCO0lBekNILEtBQUtKLGdCQUFMLEdBQXdCQSxnQkFBeEI7SUFFQSw0QkFPSUEsZ0JBQWdCLENBQUNLLDJCQUFqQixDQUE2Q0MsT0FBN0MsQ0FBcURDLGlCQUFyRCxDQUF1RUQsT0FQM0U7SUFBQSxJQUNJRSxPQURKLHlCQUNJQSxPQURKO0lBQUEsSUFFSUMsT0FGSix5QkFFSUEsT0FGSjtJQUFBLElBR0lDLE9BSEoseUJBR0lBLE9BSEo7SUFBQSxJQUlJQyxrQkFKSix5QkFJSUEsa0JBSko7SUFBQSxJQUtJQyxrQkFMSix5QkFLSUEsa0JBTEo7SUFBQSxJQU1JQyxrQkFOSix5QkFNSUEsa0JBTko7SUFTQSxLQUFLQyxRQUFMLEdBQWdCO01BQ1pOLE9BQU8sRUFBUEEsT0FEWTtNQUVaQyxPQUFPLEVBQVBBLE9BRlk7TUFHWkMsT0FBTyxFQUFQQSxPQUhZO01BSVpDLGtCQUFrQixFQUFsQkEsa0JBSlk7TUFLWkMsa0JBQWtCLEVBQWxCQSxrQkFMWTtNQU1aQyxrQkFBa0IsRUFBbEJBO0lBTlksQ0FBaEI7SUFTQSw0QkFHSSxLQUFLYixnQkFBTCxDQUFzQmUsNEJBQXRCLENBQW1EVCxPQUh2RDtJQUFBLElBQ0lVLGFBREoseUJBQ0lBLGFBREo7SUFBQSxJQUVJQyxPQUZKLHlCQUVJQSxPQUZKO0lBS0EsSUFDSUMsUUFESixHQUVJLEtBQUtsQixnQkFBTCxDQUFzQkssMkJBQXRCLENBQWtEQyxPQUZ0RCxDQUNJWSxRQURKLENBM0J3QixDQStCeEI7O0lBQ0EsS0FBS0Msa0JBQUwsQ0FBd0JoQix3QkFBeEIsR0FDS2lCLElBQUksQ0FBQ0MsR0FBTCxDQUFTTCxhQUFULEVBQXdCRSxRQUFRLEdBQUcsQ0FBbkMsS0FBMEMsQ0FEL0M7SUFFQSxLQUFLQyxrQkFBTCxDQUF3QmYsNkJBQXhCLEdBQXdELENBQXhEO0VBRUg7Ozs7V0FnRU0saUNBQXFCO01BQ3hCLElBQU1rQixlQUFlLEdBQUcsS0FBS3RCLGdCQUFMLENBQXNCdUIsOEJBQXRCLENBQXFEakIsT0FBckQsQ0FBNkRrQixVQUE3RCxDQUF3RWxCLE9BQWhHO01BQ0EsT0FBTztRQUFDbUIsS0FBSyxFQUFDSCxlQUFlLENBQUNJLFdBQXZCO1FBQW9DQyxNQUFNLEVBQUVMLGVBQWUsQ0FBQ007TUFBNUQsQ0FBUDtJQUNIOzs7V0FFTSxnQ0FBb0I7TUFDdkIsSUFBTU4sZUFBZSxHQUFHLEtBQUt0QixnQkFBTCxDQUFzQnVCLDhCQUF0QixDQUFxRGpCLE9BQXJELENBQTZEa0IsVUFBN0QsQ0FBd0VsQixPQUFoRztNQUNBLElBQU11QixHQUFHLEdBQUdQLGVBQWUsQ0FBQ1EsU0FBNUI7TUFDQSxJQUFNQyxJQUFJLEdBQUdULGVBQWUsQ0FBQ1UsVUFBN0I7TUFDQSxPQUFPO1FBQUNILEdBQUcsRUFBSEEsR0FBRDtRQUFLRSxJQUFJLEVBQUpBO01BQUwsQ0FBUDtJQUNIOzs7Ozs7QUFoSExFLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3NjYWZmb2xkaGFuZGxlci50c3g/ZmMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjcmFkbGVoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIxIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYWZmb2xkSGFuZGxlciB7IFxuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBheGlzUmVmLCBcbiAgICAgICAgICAgIGhlYWRSZWYsIFxuICAgICAgICAgICAgdGFpbFJlZixcbiAgICAgICAgICAgIGhlYWRUcmlnZ2VybGluZVJlZixcbiAgICAgICAgICAgIGF4aXNUcmlnZ2VybGluZVJlZixcbiAgICAgICAgICAgIHRhaWxUcmlnZ2VybGluZVJlZixcbiAgICAgICAgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHtcbiAgICAgICAgICAgIGF4aXNSZWYsXG4gICAgICAgICAgICBoZWFkUmVmLFxuICAgICAgICAgICAgdGFpbFJlZixcbiAgICAgICAgICAgIGhlYWRUcmlnZ2VybGluZVJlZixcbiAgICAgICAgICAgIGF4aXNUcmlnZ2VybGluZVJlZixcbiAgICAgICAgICAgIHRhaWxUcmlnZ2VybGluZVJlZixcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gcHJvZ3Jlc3Npb24gb2YgcmVmZXJlbmNlczogaW1wbGllZC0+dGFyZ2V0XG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IFxuICAgICAgICAgICAgKE1hdGgubWluKHN0YXJ0aW5nSW5kZXgsKGxpc3RzaXplIC0gMSkpIHx8IDApXG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gMFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgdHJpZ2dlcmxpbmVTcGFuXG5cbiAgICAvLyBjcmFkbGVQb3NpdGlvbkRhdGEgY29udHJvbHMgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiB0aGUgc2NhZmZvbGQgZWxlbWVudHNcbiAgICBwdWJsaWMgY3JhZGxlUG9zaXRpb25EYXRhID0ge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBcImJsb2NrXCIgPSBjcmFkbGVibG9jaywgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxlZFxuXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyBpcyBzZXQgYnkgc2Nyb2xsSGFuZGxlciBkdXJpbmcgYW5kIGFmdGVyIHNjcm9sbGluZyxcbiAgICAgICAgICAgIGFuZCBieSBzZXRDcmFkbGVDb250ZW50IGluIGNvbnRlbnRIYW5kbGVyLCB3aGljaCByZXBvc2l0aW9ucyB0aGUgY3JhZGxlLlxuXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyBpcyB1c2VkIGJ5XG4gICAgICAgICAgICAgICAgLSBjcmFkbGUgaW5pdGlhbGl6YXRpb24gaW4gcmVzcG9uc2UgdG8gcmVwYXJlbnRpbmcgaW50ZXJydXB0XG4gICAgICAgICAgICAgICAgLSBzZXRDcmFkbGVDb250ZW50XG5cbiAgICAgICAgKi9cbiAgICAgICAgYmxvY2tTY3JvbGxQb3M6bnVsbCwgLy8gdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHZhbHVlcyBjYW4gYmUgXCJzY3JvbGxUb3BcIiBvciBcInNjcm9sbExlZnRcIiAob2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQpIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvblxuXG4gICAgICAgICAgICBibG9ja1Njcm9sbFByb3BlcnR5IGlzIHNldCBieSB0aGUgb3JpZW50YXRpb24gcmVjb25maWd1cmF0aW9uIGVmZmVjdCBpbiBjcmFkbGUgbW9kdWxlLlxuXG4gICAgICAgICAgICBpdCBpcyB1c2VkIHdoZXJlIGJsb2NrU2Nyb2xsUG9zIGlzIHVzZWQgYWJvdmUuXG4gICAgICAgICovXG4gICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHk6bnVsbCxcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4IGlzIHNldCBieVxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gc2NhZmZvbGRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gaG9zdCBzY3JvbGxUb0l0ZW0gY2FsbFxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsVHJhY2tlckFyZ3MgaW4gY3JhZGxlIG1vZHVsZVxuICAgICAgICAgICAgICAgIC0gcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGluIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4Om51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHNldCBieVxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gc2NhZmZvbGRIYW5kbGVyIChpbml0aWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICAtIHNjcm9sbEhhbmRsZXIgKGR1cmluZyBhbmQgYWZ0ZXIgc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC0gcGl2b3QgZWZmZWN0IChjaGFuZ2Ugb2Ygb3JpZW50YXRpb24pIGluIGNyYWRsZSBtb2R1bGVcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gcHJldmlvdXNBeGlzT2Zmc2V0IGluIHBpdm90IGVmZmVjdFxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuXG4gICAgICAgICovXG4gICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Om51bGwsIC8vIGludG8gdGhlIHZpZXdwb3J0XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZWxlbWVudHNcblxuICAgIHB1YmxpYyBnZXRWaWV3cG9ydERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgcmV0dXJuIHt3aWR0aDp2aWV3cG9ydEVsZW1lbnQuY2xpZW50V2lkdGgsIGhlaWdodDogdmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Vmlld3BvcnRTY3JvbGxQb3MoKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgdG9wID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICBjb25zdCBsZWZ0ID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgcmV0dXJuIHt0b3AsbGVmdH1cbiAgICB9XG5cbn0iXSwibmFtZXMiOlsiU2NhZmZvbGRIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImJsb2NrU2Nyb2xsUG9zIiwiYmxvY2tTY3JvbGxQcm9wZXJ0eSIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsImNyYWRsZUVsZW1lbnRzUmVmIiwiYXhpc1JlZiIsImhlYWRSZWYiLCJ0YWlsUmVmIiwiaGVhZFRyaWdnZXJsaW5lUmVmIiwiYXhpc1RyaWdnZXJsaW5lUmVmIiwidGFpbFRyaWdnZXJsaW5lUmVmIiwiZWxlbWVudHMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwic3RhcnRpbmdJbmRleCIsInBhZGRpbmciLCJsaXN0c2l6ZSIsImNyYWRsZVBvc2l0aW9uRGF0YSIsIk1hdGgiLCJtaW4iLCJ2aWV3cG9ydEVsZW1lbnQiLCJ2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYiLCJlbGVtZW50UmVmIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInRvcCIsInNjcm9sbFRvcCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/scaffoldhandler.tsx\n");

/***/ }),

/***/ "./src/cradle/scrollhandler.tsx":
/*!**************************************!*\
  !*** ./src/cradle/scrollhandler.tsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval(" // scrollhandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = 500;\n\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ScrollHandler);\n\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n\n  this.onScroll = function (e) {\n    var scrollerID = _this.cradleParameters.cradleInheritedPropertiesRef.current.scrollerID;\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n    var viewportElement = viewportInterruptProperties.elementRef.current;\n    var scrollPositionCurrent = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft; // console.log('scrollPositionCurrent in onScroll','-'+scrollerID+'-', scrollPositionCurrent)\n\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      clearTimeout(_this._scrolltimerid);\n      return;\n    } // const scrollPositionCurrent = \n    //     (this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical')?\n    //         viewportElement.scrollTop:\n    //         viewportElement.scrollLeft\n\n\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n\n    clearTimeout(_this._scrolltimerid);\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n\n    if (!_this.isScrolling) {\n      // console.log('scrolling started','-'+scrollerID+'-')\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n\n    var scaffoldHandler = _this.cradleParameters.handlersRef.current.scaffoldHandler;\n    var cradlePositionData = scaffoldHandler.cradlePositionData; // keep up to date in case of reparenting interrupt\n\n    cradlePositionData.blockScrollPos = scrollPositionCurrent; // console.log('onScroll updated blockScrollPos','-'+scrollerID+'-',cradlePositionData.blockScrollPos)\n\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        contentHandler = _this$cradleParameter.contentHandler,\n        serviceHandler = _this$cradleParameter.serviceHandler;\n\n    if (!viewportInterruptProperties.isResizing) {\n      if (cradleState == 'ready' || cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        if (cradleState == 'ready') {\n          // const itemindex = cradlePositionData.targetAxisReferenceIndex\n          var axisVisiblePixelOffset;\n          var cradleElements = scaffoldHandler.elements;\n          var axisElement = cradleElements.axisRef.current;\n          var _viewportElement = _this.cradleParameters.viewportInterruptPropertiesRef.current.elementRef.current;\n\n          if (_this.cradleParameters.cradleInheritedPropertiesRef.current.orientation == 'vertical') {\n            axisVisiblePixelOffset = axisElement.offsetTop - _viewportElement.scrollTop;\n          } else {\n            axisVisiblePixelOffset = axisElement.offsetLeft - _viewportElement.scrollLeft;\n          } // cradlePositionData.targetAxisReferenceIndex = itemindex\n\n\n          cradlePositionData.targetAxisViewportPixelOffset = axisVisiblePixelOffset;\n        }\n\n        if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n          _this.calcImpliedRepositioningData();\n\n          if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n        }\n      }\n    }\n\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n    return false;\n  };\n\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter2.stateHandler,\n        contentHandler = _this$cradleParameter2.contentHandler,\n        serviceHandler = _this$cradleParameter2.serviceHandler;\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('reposition');\n          break;\n        }\n\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n        }\n    } // const {scaffoldHandler} = this.cradleParameters.handlersRef.current\n    // const { cradlePositionData } = scaffoldHandler\n\n\n    var cache = cradleInheritedProperties.cache;\n\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n  }; // after scroll, but not after repositioning\n\n\n  this.updateReferenceData = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        stateHandler = _this$cradleParameter3.stateHandler,\n        scaffoldHandler = _this$cradleParameter3.scaffoldHandler;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var axisVisiblePixelOffset;\n    var cradleElements = scaffoldHandler.elements;\n    var viewportElement = viewportInterruptProperties.elementRef.current;\n\n    if (cradleProps.orientation == 'vertical') {\n      // console.log('scrollTop in updateReferenceData',viewportElement.scrollTop)\n      axisVisiblePixelOffset = cradleElements.axisRef.current.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisVisiblePixelOffset = cradleElements.axisRef.current.offsetLeft - viewportElement.scrollLeft;\n    }\n\n    var cradlePositionData = scaffoldHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisVisiblePixelOffset;\n\n    if (!viewportInterruptProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  }; // called from finishreposition state change call above\n  // called from updateReferenceData\n\n\n  this.updateBlockScrollPos = function () {\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n    var scaffoldHandler = _this.cradleParameters.handlersRef.current.scaffoldHandler;\n    var cradlePositionData = scaffoldHandler.cradlePositionData;\n    var viewportElement = viewportInterruptProperties.elementRef.current;\n\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleProps.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n      }\n\n      var scrollerID = _this.cradleParameters.cradleInheritedPropertiesRef.current.scrollerID; // console.log('scrollHandler.upateBlockScrollPos updated blockScrollPos','-'+scrollerID+'-',cradlePositionData.blockScrollPos)\n    }\n  };\n\n  this.calcImpliedRepositioningData = function () {\n    var viewportInterruptProperties = _this.cradleParameters.viewportInterruptPropertiesRef.current;\n    var cradleProps = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleConfig = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var crosscount = cradleConfig.crosscount,\n        listsize = cradleConfig.listsize;\n    var viewportElement = viewportInterruptProperties.elementRef.current;\n    var orientation = cradleProps.orientation;\n    var scrollPos, cellLength;\n\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleProps.cellHeight + cradleProps.gap; // console.log('scrollPos in calcImpliedRepositioningData', scrollPos)\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleProps.cellWidth + cradleProps.gap;\n    }\n\n    var axisPixelOffset = cellLength - scrollPos % cellLength;\n\n    if (axisPixelOffset == cellLength + cradleProps.padding) {\n      axisPixelOffset = 0;\n    }\n\n    var axisRowIndex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n    var axisReferenceIndex = axisRowIndex * crosscount;\n    axisReferenceIndex = Math.min(axisReferenceIndex, listsize - 1);\n    var diff = axisReferenceIndex % crosscount;\n    axisReferenceIndex -= diff;\n    if (axisReferenceIndex == 0) axisPixelOffset = 0; // defensive\n\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.scaffoldHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferenceIndex = axisReferenceIndex;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n    var repositioningIndexCallback = _this.cradleParameters.handlersRef.current.serviceHandler.callbacks.repositioningIndexCallback; // console.log('scrollHandler: repositioningIndexCallback',repositioningIndexCallback)\n\n    repositioningIndexCallback && repositioningIndexCallback(axisReferenceIndex);\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekIsSUFBa0NMLFVBQTVDLENBQXJCO0lBQ0EsSUFBSVMsa0JBQWtCLEdBQUdILFlBQVksR0FBR1QsVUFBeEM7SUFDQVksa0JBQWtCLEdBQUdGLElBQUksQ0FBQ0csR0FBTCxDQUFTRCxrQkFBVCxFQUE0QlgsUUFBUSxHQUFHLENBQXZDLENBQXJCO0lBQ0EsSUFBTWEsSUFBSSxHQUFHRixrQkFBa0IsR0FBR1osVUFBbEM7SUFDQVksa0JBQWtCLElBQUlFLElBQXRCO0lBRUEsSUFBSUYsa0JBQWtCLElBQUksQ0FBMUIsRUFBNkJMLGVBQWUsR0FBRyxDQUFsQixDQWxDVyxDQWtDUzs7SUFFakQsSUFBUXRDLGtCQUFSLEdBQStCLEtBQUksQ0FBQzVCLGdCQUFMLENBQXNCc0IsV0FBdEIsQ0FBa0NwQixPQUFsQyxDQUEwQ3lCLGVBQXpFLENBQVFDLGtCQUFSO0lBQ0FBLGtCQUFrQixDQUFDOEMsd0JBQW5CLEdBQThDSCxrQkFBOUM7SUFDQTNDLGtCQUFrQixDQUFDZSw2QkFBbkIsR0FBbUR1QixlQUFuRDtJQUNBLElBQVFTLDBCQUFSLEdBQ0ksS0FBSSxDQUFDM0UsZ0JBQUwsQ0FBc0JzQixXQUF0QixDQUFrQ3BCLE9BQWxDLENBQTBDZ0MsY0FBMUMsQ0FBeURpQixTQUQ3RCxDQUFRd0IsMEJBQVIsQ0F2Q3dDLENBeUN4Qzs7SUFDQUEsMEJBQTBCLElBQUlBLDBCQUEwQixDQUFDSixrQkFBRCxDQUF4RDtFQUVILENBNUNPOztFQS9PSixLQUFLdkUsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUVILEM7O0FBTkw0RSxrQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjEgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuY29uc3QgU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwgPSA1MDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxlcklEIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb25DdXJyZW50ID0gXG4gICAgICAgICAgICAodGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzY3JvbGxQb3NpdGlvbkN1cnJlbnQgaW4gb25TY3JvbGwnLCctJytzY3JvbGxlcklEKyctJywgc2Nyb2xsUG9zaXRpb25DdXJyZW50KVxuXG4gICAgICAgIGlmICgodmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoID09IDAgICYmIHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpIHsvLyBpbiBjYWNoZVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Njcm9sbHRpbWVyaWQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zdCBzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBcbiAgICAgICAgLy8gICAgICh0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAvLyAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgIC8vICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICBpZiAoc2Nyb2xsUG9zaXRpb25DdXJyZW50IDwgMCkgeyAvLyBmb3IgU2FmYXJpXG5cbiAgICAgICAgICAgIHJldHVybiBcblxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Njcm9sbHRpbWVyaWQpXG5cbiAgICAgICAgY29uc3Qge3NpZ25hbHN9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cykge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2Nyb2xsaW5nIHN0YXJ0ZWQnLCctJytzY3JvbGxlcklEKyctJylcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERhdGEuc3RhcnQgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7c2NhZmZvbGRIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBzY2FmZm9sZEhhbmRsZXJcblxuICAgICAgICAvLyBrZWVwIHVwIHRvIGRhdGUgaW4gY2FzZSBvZiByZXBhcmVudGluZyBpbnRlcnJ1cHRcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvblNjcm9sbCB1cGRhdGVkIGJsb2NrU2Nyb2xsUG9zJywnLScrc2Nyb2xsZXJJRCsnLScsY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUG9zKVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5wcmV2aW91cyA9IHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50XG4gICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50ID0gc2Nyb2xsUG9zaXRpb25DdXJyZW50XG5cbiAgICAgICAgY29uc3Qge3N0YXRlSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge2NvbnRlbnRIYW5kbGVyLCBzZXJ2aWNlSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgaWYgKChjcmFkbGVTdGF0ZSA9PSAncmVhZHknKSB8fCAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSB8fCAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWFkeScpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpdGVtaW5kZXggPSBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XG4gICAgICAgICAgICAgICAgICAgIGxldCBheGlzVmlzaWJsZVBpeGVsT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyYWRsZUVsZW1lbnRzID0gc2NhZmZvbGRIYW5kbGVyLmVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQgPSBheGlzRWxlbWVudC5vZmZzZXRUb3AgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQgPSBheGlzRWxlbWVudC5vZmZzZXRMZWZ0IC0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IGl0ZW1pbmRleFxuICAgICAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlzaWJsZVBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nUmVuZGVyJykgfHwgKGNyYWRsZVN0YXRlID09ICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJykpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5vbkFmdGVyU2Nyb2xsKClcblxuICAgICAgICB9LFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMKVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgfVxuXG5cbiAgICBwcml2YXRlIG9uQWZ0ZXJTY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3Qge3N0YXRlSGFuZGxlciwgY29udGVudEhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLnZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlU3RhdGUpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ1JlbmRlcic6IFxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbic6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrU2Nyb2xsUG9zKClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayAmJiByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrKGZhbHNlKVxuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc2Nyb2xsRGF0YS5zdGFydCAhPSB0aGlzLnNjcm9sbERhdGEuY3VycmVudCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNjcm9sbERhdGEuY3VycmVudCAhPSB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3Qge3NjYWZmb2xkSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICAvLyBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gc2NhZmZvbGRIYW5kbGVyXG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgICAgICBpZiAoY2FjaGUgPT0gJ2tlZXBsb2FkJykge1xuICAgICAgICAgICAgY29udGVudEhhbmRsZXIucGFyZUNhY2hlVG9NYXgoKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBhZnRlciBzY3JvbGwsIGJ1dCBub3QgYWZ0ZXIgcmVwb3NpdGlvbmluZ1xuICAgIHByaXZhdGUgdXBkYXRlUmVmZXJlbmNlRGF0YSA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0YXRlSGFuZGxlciwgc2NhZmZvbGRIYW5kbGVyIH0gXG4gICAgICAgICAgICA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlUHJvcHMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBsZXQgYXhpc1Zpc2libGVQaXhlbE9mZnNldFxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHNjYWZmb2xkSGFuZGxlci5lbGVtZW50c1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgaWYgKGNyYWRsZVByb3BzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzY3JvbGxUb3AgaW4gdXBkYXRlUmVmZXJlbmNlRGF0YScsdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAgIGF4aXNWaXNpYmxlUGl4ZWxPZmZzZXQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQub2Zmc2V0VG9wIC0gXG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBheGlzVmlzaWJsZVBpeGVsT2Zmc2V0ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50Lm9mZnNldExlZnQgLSBcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gc2NhZmZvbGRIYW5kbGVyXG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1Zpc2libGVQaXhlbE9mZnNldFxuXG4gICAgICAgIGlmICghdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Njcm9sbFBvcygpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gZmluaXNocmVwb3NpdGlvbiBzdGF0ZSBjaGFuZ2UgY2FsbCBhYm92ZVxuICAgIC8vIGNhbGxlZCBmcm9tIHVwZGF0ZVJlZmVyZW5jZURhdGFcbiAgICBwcml2YXRlIHVwZGF0ZUJsb2NrU2Nyb2xsUG9zID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZVByb3BzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMudmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qge3NjYWZmb2xkSGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gc2NhZmZvbGRIYW5kbGVyXG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghKCh2aWV3cG9ydEVsZW1lbnQuY2xpZW50V2lkdGggPT0gMCkgICYmICh2aWV3cG9ydEVsZW1lbnQuY2xpZW50SGVpZ2h0ID09IDApKSkgey8vIGluIGNhY2hlXG5cbiAgICAgICAgICAgIGlmIChjcmFkbGVQcm9wcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxlcklEIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2Nyb2xsSGFuZGxlci51cGF0ZUJsb2NrU2Nyb2xsUG9zIHVwZGF0ZWQgYmxvY2tTY3JvbGxQb3MnLCctJytzY3JvbGxlcklEKyctJyxjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW50ZXJydXB0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy52aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBjcmFkbGVQcm9wcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlQ29uZmlnID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qge2Nyb3NzY291bnQsIGxpc3RzaXplfSA9IGNyYWRsZUNvbmZpZ1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydEludGVycnVwdFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHtvcmllbnRhdGlvbn0gPSBjcmFkbGVQcm9wc1xuICAgICAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0ICsgY3JhZGxlUHJvcHMuZ2FwXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2Nyb2xsUG9zIGluIGNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEnLCBzY3JvbGxQb3MpXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF4aXNQaXhlbE9mZnNldCA9IGNlbGxMZW5ndGggLSAoc2Nyb2xsUG9zICUgY2VsbExlbmd0aClcbiAgICAgICAgaWYgKGF4aXNQaXhlbE9mZnNldCA9PSAoY2VsbExlbmd0aCArIGNyYWRsZVByb3BzLnBhZGRpbmcpKSB7XG4gICAgICAgICAgICBheGlzUGl4ZWxPZmZzZXQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzUm93SW5kZXggPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVByb3BzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG4gICAgICAgIGxldCBheGlzUmVmZXJlbmNlSW5kZXggPSBheGlzUm93SW5kZXggKiBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKGF4aXNSZWZlcmVuY2VJbmRleCxsaXN0c2l6ZSAtIDEpXG4gICAgICAgIGNvbnN0IGRpZmYgPSBheGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50XG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCAtPSBkaWZmXG5cbiAgICAgICAgaWYgKGF4aXNSZWZlcmVuY2VJbmRleCA9PSAwKSBheGlzUGl4ZWxPZmZzZXQgPSAwIC8vIGRlZmVuc2l2ZVxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5zY2FmZm9sZEhhbmRsZXJcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IGF4aXNSZWZlcmVuY2VJbmRleFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzUGl4ZWxPZmZzZXRcbiAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5zZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Njcm9sbEhhbmRsZXI6IHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrJyxyZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjaylcbiAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2sgJiYgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2soYXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiU0NST0xMX1RJTUVPVVRfRk9SX09OQUZURVJTQ1JPTEwiLCJTY3JvbGxIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsInN0YXJ0IiwiY3VycmVudCIsInByZXZpb3VzIiwicHJldmlvdXN1cGRhdGUiLCJjdXJyZW50dXBkYXRlIiwiZSIsInNjcm9sbGVySUQiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwidmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzIiwidmlld3BvcnRJbnRlcnJ1cHRQcm9wZXJ0aWVzUmVmIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsInNjcm9sbFBvc2l0aW9uQ3VycmVudCIsIm9yaWVudGF0aW9uIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY2xlYXJUaW1lb3V0IiwiX3Njcm9sbHRpbWVyaWQiLCJzaWduYWxzIiwiaGFuZGxlcnNSZWYiLCJpbnRlcnJ1cHRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiaXNTY3JvbGxpbmciLCJzY3JvbGxEYXRhIiwic2NhZmZvbGRIYW5kbGVyIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwiYmxvY2tTY3JvbGxQb3MiLCJzdGF0ZUhhbmRsZXIiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiY29udGVudEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImlzUmVzaXppbmciLCJheGlzVmlzaWJsZVBpeGVsT2Zmc2V0IiwiY3JhZGxlRWxlbWVudHMiLCJlbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJ0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEiLCJzZXRDcmFkbGVTdGF0ZSIsInNldFRpbWVvdXQiLCJvbkFmdGVyU2Nyb2xsIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyIsInVwZGF0ZUJsb2NrU2Nyb2xsUG9zIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsImNhbGxiYWNrcyIsImlzTW91bnRlZFJlZiIsInVwZGF0ZVJlZmVyZW5jZURhdGEiLCJjYWNoZSIsInBhcmVDYWNoZVRvTWF4IiwiY3JhZGxlUHJvcHMiLCJjcmFkbGVDb25maWciLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJzY3JvbGxQb3MiLCJjZWxsTGVuZ3RoIiwiY2VsbEhlaWdodCIsImdhcCIsImNlbGxXaWR0aCIsImF4aXNQaXhlbE9mZnNldCIsInBhZGRpbmciLCJheGlzUm93SW5kZXgiLCJNYXRoIiwiY2VpbCIsImF4aXNSZWZlcmVuY2VJbmRleCIsIm1pbiIsImRpZmYiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJyZXBvc2l0aW9uaW5nSW5kZXhDYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n");

/***/ }),

/***/ "./src/cradle/servicehandler.tsx":
/*!***************************************!*\
  !*** ./src/cradle/servicehandler.tsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval(" // servicehandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n})); // ServiceHandler handles client service requests\n\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, ServiceHandler);\n\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState('reload');\n  };\n\n  this.scrollToItem = function (index) {\n    index = Math.max(0, index);\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n        scaffoldHandler = _this$cradleParameter.scaffoldHandler,\n        stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    scaffoldHandler.cradlePositionData.targetAxisReferenceIndex = index;\n    stateHandler.setCradleState('scrollto');\n  };\n\n  this.setListsize = function (newlistsize) {\n    newlistsize = Math.max(0, newlistsize);\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter2.cacheHandler,\n        stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n        deleteListCallback = _this$callbacks.deleteListCallback,\n        changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback('change list size intervention', deleteList);\n      };\n    }\n\n    cacheHandler.changeListsize(newlistsize, dListCallback, changeListsizeCallback);\n\n    if (cache == 'preload' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState('startpreload');\n    }\n  }; // ======================[ GET SNAPSHOTS ]========================\n\n\n  this.getCacheIndexMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheIndexMap();\n  };\n\n  this.getCacheItemMap = function () {\n    var cacheHandler = _this.cradleParameters.handlersRef.current.cacheHandler;\n    return cacheHandler.getCacheItemMap();\n  };\n\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter3.cacheHandler,\n        contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheHandler.getCradleIndexMap(modelIndexList);\n  }; // =================[ CACHE MANAGEMENT REQUESTS ]==================\n\n\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState('clearcache');\n    return true;\n  };\n\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter4.cacheHandler,\n        contentHandler = _this$cradleParameter4.contentHandler,\n        stateHandler = _this$cradleParameter4.stateHandler;\n    var _cacheHandler$cachePr = cacheHandler.cacheProps,\n        metadataMap = _cacheHandler$cachePr.metadataMap,\n        portalMap = _cacheHandler$cachePr.portalMap,\n        indexToItemIDMap = _cacheHandler$cachePr.indexToItemIDMap;\n    var indexesToDeleteList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map(); // =====================[ PREPARATION ]======================\n    // ------------ filter out inoperable indexes and itemIDs ------------\n\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == 'string') {\n          errorEntriesMap.set(index, 'itemID is a string');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, 'itemID is not an integer');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, 'index not in cache');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" has not changed\"));\n        } else if (!metadataMap.has(itemID)) {\n          errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" not in cache\"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    }); // -------------- filter out duplicate itemIDs ------------\n\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, \"target itemID \".concat(itemID, \" has duplicates (\").concat(count, \")\"));\n        changeIndexToItemIDMap[\"delete\"](index);\n      });\n    } // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n\n\n    var originalMap = new Map(); // index => itemID; before change\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n\n      originalMap.set(metadataMap.get(itemID).index, itemID); // target itemID\n    }); // ... and from the list of indexes to be deleted\n\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    }); // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID's will be orphaned, but could be remapped.\n    // orphans are resolved below\n\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap[\"delete\"](index);\n      });\n    } // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // TODO just need an index list here: processedIndexList = []\n\n\n    var processedMap = new Map(); // index => itemID; change has been applied\n    // make changes\n\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n\n      var itemdata = metadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n\n      processedMap.set(index, itemID);\n    }); // -------------- look for and delete item and index orphans --------------------\n    // if the original item's index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item's index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n\n    var deletedIndexToItemIDMap = new Map();\n    var portalHoldList = []; // hold deleted portals for deletion until after cradle synch\n\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = metadataMap.get(originalItemID).index;\n\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        metadataMap[\"delete\"](originalItemID);\n        portalHoldList.push(originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap[\"delete\"](originalItemIDIndex);\n          }\n        }\n      }\n    }); // refresh the modified cache\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList(); // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n\n    var processedIndexList = Array.from(processedMap.keys());\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys()); // for return information...\n\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = processedIndexList.concat(indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    cacheHandler.portalHoldList = portalHoldList;\n    stateHandler.setCradleState('applycellframechanges'); // ---------- returns for user information --------------------\n\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  }; // move must be entirely within list bounds\n  // returns list of processed indexes\n\n\n  this.moveIndex = function (toindex, fromindex) {\n    var highrange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------- define parameters ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize; // remove nulls\n\n    toindex = toindex !== null && toindex !== void 0 ? toindex : 0;\n    fromindex = fromindex !== null && fromindex !== void 0 ? fromindex : 0;\n    highrange = highrange !== null && highrange !== void 0 ? highrange : fromindex;\n    toindex = Math.max(0, toindex);\n    fromindex = Math.max(0, fromindex);\n    highrange = Math.max(0, highrange); // keep within current list size\n\n    var listbound = listsize - 1;\n    toindex = toindex > listbound ? listbound : toindex;\n    fromindex = fromindex > listbound ? listbound : fromindex;\n    highrange = highrange > listbound ? listbound : highrange; // highrange must be >= fromindex\n\n    highrange = highrange >= fromindex ? highrange : fromindex;\n    var rangeincrement = highrange - fromindex + 1;\n    var moveincrement = toindex - fromindex; // ---------- constrain parameters --------------\n\n    if (fromindex == toindex) return []; // nothing to do\n    // move must be in list bounds\n\n    if (moveincrement > 0) {\n      // move up\n      var targettop = toindex + (rangeincrement - 1);\n      if (targettop > listbound) return []; // out of bounds\n    } // ----------- perform cache and cradle operations -----------\n\n\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter5.cacheHandler,\n        contentHandler = _this$cradleParameter5.contentHandler,\n        stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList = cacheHandler.moveIndex(toindex, fromindex, highrange);\n\n    if (processedIndexList.length) {\n      cacheHandler.cacheProps.modified = true;\n      cacheHandler.renderPortalList();\n      contentHandler.changeCradleItemIDs(processedIndexList);\n      stateHandler.setCradleState('applycellframechanges');\n    }\n\n    return processedIndexList;\n  };\n\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  }; // shared logic. Returns lists of items changed, and items replaced (new items for insert)\n  // this operation changes the listsize\n\n\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    index = index !== null && index !== void 0 ? index : 0;\n    rangehighindex = rangehighindex !== null && rangehighindex !== void 0 ? rangehighindex : index;\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n        cacheHandler = _this$cradleParameter6.cacheHandler,\n        contentHandler = _this$cradleParameter6.contentHandler,\n        stateHandler = _this$cradleParameter6.stateHandler;\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.listsize;\n\n    var _cacheHandler$insertR = cacheHandler.insertRemoveIndex(index, rangehighindex, increment, listsize),\n        _cacheHandler$insertR2 = _slicedToArray(_cacheHandler$insertR, 4),\n        changeList = _cacheHandler$insertR2[0],\n        replaceList = _cacheHandler$insertR2[1],\n        rangeincrement = _cacheHandler$insertR2[2],\n        portalHoldList = _cacheHandler$insertR2[3];\n\n    cacheHandler.cacheProps.modified = true;\n    cacheHandler.renderPortalList();\n    cacheHandler.portalHoldList = portalHoldList;\n    contentHandler.changeCradleItemIDs(changeList);\n    if (increment == +1) contentHandler.createNewItemIDs(replaceList);\n    var content = contentHandler.content;\n    stateHandler.setCradleState('applycellframechanges');\n    var changecount = rangeincrement; // semantics\n\n    var newlistsize = listsize + changecount;\n\n    _this.setListsize(newlistsize);\n\n    return [changeList, replaceList];\n  };\n\n  this.cradleParameters = cradleParameters; // doing this explicitly here for documentation\n\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n      referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n      preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n      deleteListCallback = _cradleParameters$ext.deleteListCallback,\n      changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n      itemExceptionsCallback = _cradleParameters$ext.itemExceptionsCallback,\n      repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionsCallback: itemExceptionsCallback,\n    repositioningFlagCallback: repositioningFlagCallback\n  };\n  this.callbacks = callbacks;\n});\n\nexports[\"default\"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUhKLHlCQUdJQSxrQkFISjtFQUFBLElBSUlDLHNCQUpKLHlCQUlJQSxzQkFKSjtFQUFBLElBS0l1RixzQkFMSix5QkFLSUEsc0JBTEo7RUFBQSxJQU1JQyx5QkFOSix5QkFNSUEseUJBTko7RUFVQSxJQUFNMUYsU0FBUyxHQUFHO0lBQ2R1RixzQkFBc0IsRUFBdEJBLHNCQURjO0lBRWRDLG9CQUFvQixFQUFwQkEsb0JBRmM7SUFHZHZGLGtCQUFrQixFQUFsQkEsa0JBSGM7SUFJZEMsc0JBQXNCLEVBQXRCQSxzQkFKYztJQUtkdUYsc0JBQXNCLEVBQXRCQSxzQkFMYztJQU1kQyx5QkFBeUIsRUFBekJBO0VBTmMsQ0FBbEI7RUFTQSxLQUFLMUYsU0FBTCxHQUFpQkEsU0FBakI7QUFFRixDOztBQTVCTDJGLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3NlcnZpY2VoYW5kbGVyLnRzeD85Y2IwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZpY2VoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIxIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8vIFNlcnZpY2VIYW5kbGVyIGhhbmRsZXMgY2xpZW50IHNlcnZpY2UgcmVxdWVzdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcnZpY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIC8vIGRvaW5nIHRoaXMgZXhwbGljaXRseSBoZXJlIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICAgY29uc3Qge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgsIGxvY2F0aW9uLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIC8vIChpbmRleClcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLCAvLyAocmVhc29uLCBkZWxldGVMaXN0KVxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLCAvLyAobmV3bGlzdHNpemUpXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssIC8vIChpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgbG9jYXRpb24sIGVycm9yKVxuICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrLCAvLyAoZmxhZykgLy8gYm9vbGVhblxuICAgICAgICAgICBcbiAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5leHRlcm5hbENhbGxiYWNrc1JlZi5jdXJyZW50XG5cbiAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25zQ2FsbGJhY2ssXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssXG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgLy8gc2VlIGFib3ZlIGZvciBsaXN0XG4gICAgcHVibGljIGNhbGxiYWNrc1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09WyBHRU5FUkFMIF09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgcmVsb2FkID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgaW50ZXJydXB0SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc2Nyb2xsVG9JdGVtID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLGluZGV4KVxuXG4gICAgICAgIGNvbnN0IHsgc2lnbmFscyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQuaW50ZXJydXB0SGFuZGxlclxuICAgICAgICBjb25zdCB7IHNjYWZmb2xkSGFuZGxlciwgc3RhdGVIYW5kbGVyfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgc2lnbmFscy5wYXVzZVNjcm9sbGluZ0VmZmVjdHMgPSB0cnVlXG5cbiAgICAgICAgc2NhZmZvbGRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBpbmRleFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc2Nyb2xsdG8nKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldExpc3RzaXplID0gKG5ld2xpc3RzaXplKSA9PiB7XG5cbiAgICAgICAgbmV3bGlzdHNpemUgPSBNYXRoLm1heCgwLG5ld2xpc3RzaXplKVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgfSA9IHRoaXMuY2FsbGJhY2tzXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZTpjdXJyZW50bGlzdHNpemUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2NoYW5nZSBsaXN0IHNpemUgaW50ZXJ2ZW50aW9uJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlSGFuZGxlci5jaGFuZ2VMaXN0c2l6ZShuZXdsaXN0c2l6ZSwgXG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFja1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKChjYWNoZSA9PSAncHJlbG9hZCcpICYmIChuZXdsaXN0c2l6ZSA+IGN1cnJlbnRsaXN0c2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRwcmVsb2FkJylcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgR0VUIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSW5kZXhNYXAoKVxuXG4gICAgfVxuXG4gICAgcHVibGljIGdldENhY2hlSXRlbU1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlSGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENhY2hlSXRlbU1hcCgpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlSW5kZXhNYXAgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsSW5kZXhMaXN0ID0gY29udGVudEhhbmRsZXIuZ2V0TW9kZWxJbmRleExpc3QoKVxuICAgICAgICByZXR1cm4gY2FjaGVIYW5kbGVyLmdldENyYWRsZUluZGV4TWFwKG1vZGVsSW5kZXhMaXN0KVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09WyBDQUNIRSBNQU5BR0VNRU5UIFJFUVVFU1RTIF09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2xlYXJjYWNoZScpXG5cbiAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIH1cblxuICAgIHB1YmxpYyByZW1hcEluZGV4ZXMgPSAoY2hhbmdlTWFwKSA9PiB7IC8vIGluZGV4ID0+IGl0ZW1JRFxuXG4gICAgICAgIGlmIChjaGFuZ2VNYXAuc2l6ZSA9PSAwKSByZXR1cm4gW10gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc3RhdGVIYW5kbGVyIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgbWV0YWRhdGFNYXAsIC8vIGl0ZW1JRCB0byBjb21wb25lbnQgZGF0YSwgaW5jbHVkaW5nIGluZGV4XG4gICAgICAgICAgICBwb3J0YWxNYXAsIC8vIHR3aW5uZWQgd2l0aCBtZXRhZGF0YU1hcCBmb3IgcG9ydGFsXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwIC8vIGluZGV4IHRvIGl0ZW1JRFxuXG4gICAgICAgIH0gPSBjYWNoZUhhbmRsZXIuY2FjaGVQcm9wcyBcblxuICAgICAgICBjb25zdCBpbmRleGVzVG9EZWxldGVMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBlcnJvckVudHJpZXNNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFBSRVBBUkFUSU9OIF09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgaW5vcGVyYWJsZSBpbmRleGVzIGFuZCBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNoYW5nZU1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PntcblxuICAgICAgICAgICAgaWYgKChpdGVtSUQgPT09IG51bGwpIHx8IChpdGVtSUQgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QucHVzaChpbmRleClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGl0ZW1JRCkgPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCdpdGVtSUQgaXMgYSBzdHJpbmcnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwnaXRlbUlEIGlzIG5vdCBhbiBpbnRlZ2VyJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsICdpbmRleCBub3QgaW4gY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkgPT0gaXRlbUlEKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IGhhcyBub3QgY2hhbmdlZGApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFtZXRhZGF0YU1hcC5oYXMoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBub3QgaW4gY2FjaGVgKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBmaWx0ZXIgb3V0IGR1cGxpY2F0ZSBpdGVtSURzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IG1hcHNpemUgPSBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLnNpemVcblxuICAgICAgICBjb25zdCBpdGVtSURTZXQgPSBuZXcgU2V0KGNoYW5nZUluZGV4VG9JdGVtSURNYXAudmFsdWVzKCkpXG5cbiAgICAgICAgY29uc3QgaXRlbXNldHNpemUgPSBpdGVtSURTZXQuc2l6ZVxuXG4gICAgICAgIGlmIChtYXBzaXplICE9IGl0ZW1zZXRzaXplKSB7IC8vIHRoZXJlIG11c3QgYmUgZHVwbGljYXRlIGl0ZW1JRHNcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEQ291bnRNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1JRENvdW50TWFwLmhhcyhpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuc2V0KGl0ZW1JRCwgMSlcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gaXRlbUlEQ291bnRNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuc2V0KGl0ZW1JRCwgKytjb3VudCApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVJdGVtc01hcCA9IG5ldyBNYXAoKVxuICAgICAgICAgICAgaXRlbUlEQ291bnRNYXAuZm9yRWFjaCgoY291bnQsaXRlbUlEKT0+e1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUl0ZW1zTWFwLnNldChpdGVtSUQsIGNvdW50KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QgPSBbXVxuICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlSXRlbXNNYXAuaGFzKGl0ZW1JRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdC5wdXNoKGluZGV4KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZHVwbGljYXRlc1RvUmVtb3ZlTGlzdC5mb3JFYWNoKChpbmRleCk9PntcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZHVwbGljYXRlSXRlbXNNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBoYXMgZHVwbGljYXRlcyAoJHtjb3VudH0pYClcbiAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tIGNhcHR1cmUgbWFwIGJlZm9yZSBjaGFuZ2VzIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gLi4uIHRoaXMgbWFwIGlzIHVzZWQgbGF0ZXIgdG8gaWRlbnRpZnkgb3JwaGFuZWQgaXRlbSBhbmQgaW5kZXggY2FjaGUgcmVjb3JkcyBmb3IgZGVsZXRpb25cblxuICAgICAgICAvLyBmcm9tIHRoZSBsaXN0IG9mIGNoYW5nZXNcbiAgICAgICAgLy8gYm90aCBzaWRlcyBvZiBjaGFuZ2UgbWFwLi4uXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgYmVmb3JlIGNoYW5nZVxuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCwgaW5kZXgpPT57XG5cbiAgICAgICAgICAgIG9yaWdpbmFsTWFwLnNldChpbmRleCxpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpIC8vIGluZGV4IHRvIGJlIG1hcHBlZFxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KG1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4LGl0ZW1JRCkgLy8gdGFyZ2V0IGl0ZW1JRFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gLi4uIGFuZCBmcm9tIHRoZSBsaXN0IG9mIGluZGV4ZXMgdG8gYmUgZGVsZXRlZFxuICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIG9yaWdpbmFsTWFwLnNldChpbmRleCwgaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKVxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgQ0FDSEUgT1BFUkFUSU9OUyBdPT09PT09PT09PT09PT09PVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLSBkZWxldGUgbGlzdGVkIGluZGV4ZXMgLS0tLS0tLS0tXG4gICAgICAgIC8vIGZvciBpbmRleGVzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAvLyBhc3NvY2lhdGVkIGl0ZW1JRCdzIHdpbGwgYmUgb3JwaGFuZWQsIGJ1dCBjb3VsZCBiZSByZW1hcHBlZC5cbiAgICAgICAgLy8gb3JwaGFucyBhcmUgcmVzb2x2ZWQgYmVsb3dcblxuICAgICAgICBpZiAoaW5kZXhlc1RvRGVsZXRlTGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaW5kZXhlc1RvRGVsZXRlTGlzdC5mb3JFYWNoKChpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGFwcGx5IGZpbHRlcmVkIGNoYW5nZXMgdG8gY2FjaGUgaW5kZXggbWFwIGFuZCBpdGVtSUQgbWFwIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBldmVyeSByZW1haW5pbmcgaW5kZXggbGlzdGVkIHdpbGwgY2hhbmdlIGl0cyBtYXBwaW5nXG5cbiAgICAgICAgLy8gVE9ETyBqdXN0IG5lZWQgYW4gaW5kZXggbGlzdCBoZXJlOiBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuICAgICAgICBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBtZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuXG4gICAgICAgICAgICBpdGVtZGF0YS5pbmRleCA9IGluZGV4IC8vIG1vZGlmaWNhdGlvbiBhcHBsaWVkLCBwYXJ0IDJcblxuICAgICAgICAgICAgcHJvY2Vzc2VkTWFwLnNldChpbmRleCxpdGVtSUQpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBsb29rIGZvciBhbmQgZGVsZXRlIGl0ZW0gYW5kIGluZGV4IG9ycGhhbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbmFsIGl0ZW0ncyBpbmRleCBoYXMgbm90IGNoYW5nZWQsIHRoZW4gaXQgaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCBcbiAgICAgICAgLy8gICAgIGl0IGlzIG9ycGhhbmVkLCBhbmQgdGhlIGl0ZW0gaXMgZGVsZXRlZFxuICAgICAgICAvLyBpZiB0aGUgaXRlbSdzIGluZGV4IGhhcyBjaGFuZ2VkLCBidXQgdGhlIG9yaWdpbmFsIGl0ZW0gaW5kZXggbWFwIHN0aWxsIHBvaW50cyB0byB0aGUgaXRlbSxcbiAgICAgICAgLy8gICAgIHRoZW4gdGhlIGluZGV4IGlzIG9ycGhhbmVkIChkdXBsaWNhdGUpLCBhbmQgZGVsZXRlZFxuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgb3JwaGFuZWQgaW5kZXhcbiAgICAgICAgY29uc3QgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBjb25zdCBwb3J0YWxIb2xkTGlzdCA9IFtdIC8vIGhvbGQgZGVsZXRlZCBwb3J0YWxzIGZvciBkZWxldGlvbiB1bnRpbCBhZnRlciBjcmFkbGUgc3luY2hcblxuICAgICAgICBvcmlnaW5hbE1hcC5mb3JFYWNoKChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBmaW5hbEl0ZW1JREluZGV4ID0gbWV0YWRhdGFNYXAuZ2V0KG9yaWdpbmFsSXRlbUlEKS5pbmRleFxuXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJdGVtSURJbmRleCA9PSBmaW5hbEl0ZW1JREluZGV4KSB7IC8vIG5vdCByZW1hcHBlZCwgdGhlcmVmb3JlIG9ycGhhbmVkXG5cbiAgICAgICAgICAgICAgICBkZWxldGVkSXRlbUlEVG9JbmRleE1hcC5zZXQob3JpZ2luYWxJdGVtSUQsIG9yaWdpbmFsSXRlbUlESW5kZXgpXG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcC5kZWxldGUob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsSG9sZExpc3QucHVzaChvcmlnaW5hbEl0ZW1JRClcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVtYXBwZWQsIGNoZWNrIGZvciBvcnBoYW5lZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKG9yaWdpbmFsSXRlbUlESW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxJdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEl0ZW1JRCA9PSBvcmlnaW5hbEl0ZW1JRCkgeyAvLyB0aGUgaW5kZXggaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAuc2V0KG9yaWdpbmFsSXRlbUlESW5kZXgsIG9yaWdpbmFsSXRlbUlEKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShvcmlnaW5hbEl0ZW1JREluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgbW9kaWZpZWQgY2FjaGVcbiAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGFwcGx5IGNoYW5nZXMgdG8gZXh0YW50IGNlbGxGcmFtZXMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHVzZWQgdG8gcmVjb25jaWxlIGNyYWRsZSBjZWxsRnJhbWVzLCBhbmQgYWxzbyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEluZGV4TGlzdCA9IEFycmF5LmZyb20ocHJvY2Vzc2VkTWFwLmtleXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAudmFsdWVzKCkpXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEluZGV4VG9JdGVtSURNYXAua2V5cygpKVxuICAgICAgICAvLyBmb3IgcmV0dXJuIGluZm9ybWF0aW9uLi4uXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QgPSBBcnJheS5mcm9tKGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLmtleXMoKSkgXG5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kZXhMaXN0ID0gXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1RvRGVsZXRlTGlzdCwgXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QsIFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJbmRleExpc3RcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgbW9kaWZpZWRJbmRleExpc3QgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kaWZpZWRJbmRleExpc3QudmFsdWVzKCkpKSAvLyByZW1vdmUgZHVwbGljYXRlc1xuXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLnJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleExpc3QpXG4gICAgICAgIGNhY2hlSGFuZGxlci5wb3J0YWxIb2xkTGlzdCA9IHBvcnRhbEhvbGRMaXN0XG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gcmV0dXJucyBmb3IgdXNlciBpbmZvcm1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBbXG5cbiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIHByb2Nlc3NlZEluZGV4TGlzdCwgXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIGRlbGV0ZWRPcnBoYW5lZEl0ZW1JRExpc3QsIFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0LFxuICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLCBcbiAgICAgICAgICAgIGNoYW5nZU1hcFxuXG4gICAgICAgIF1cblxuICAgIH1cblxuICAgIC8vIG1vdmUgbXVzdCBiZSBlbnRpcmVseSB3aXRoaW4gbGlzdCBib3VuZHNcbiAgICAvLyByZXR1cm5zIGxpc3Qgb2YgcHJvY2Vzc2VkIGluZGV4ZXNcbiAgICBwdWJsaWMgbW92ZUluZGV4ID0gKHRvaW5kZXgsIGZyb21pbmRleCwgaGlnaHJhbmdlID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gZGVmaW5lIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBsaXN0c2l6ZSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgLy8gcmVtb3ZlIG51bGxzXG4gICAgICAgIHRvaW5kZXggPSB0b2luZGV4ID8/IDBcbiAgICAgICAgZnJvbWluZGV4ID0gZnJvbWluZGV4ID8/IDBcbiAgICAgICAgaGlnaHJhbmdlID0gaGlnaHJhbmdlID8/IGZyb21pbmRleFxuXG4gICAgICAgIHRvaW5kZXggPSBNYXRoLm1heCgwLHRvaW5kZXgpXG4gICAgICAgIGZyb21pbmRleCA9IE1hdGgubWF4KDAsZnJvbWluZGV4KVxuICAgICAgICBoaWdocmFuZ2UgPSBNYXRoLm1heCgwLGhpZ2hyYW5nZSlcblxuICAgICAgICAvLyBrZWVwIHdpdGhpbiBjdXJyZW50IGxpc3Qgc2l6ZVxuICAgICAgICBjb25zdCBsaXN0Ym91bmQgPSBsaXN0c2l6ZSAtIDFcblxuICAgICAgICB0b2luZGV4ID0gXG4gICAgICAgICAgICAodG9pbmRleCA+IGxpc3Rib3VuZCk/XG4gICAgICAgICAgICAgICAgbGlzdGJvdW5kOlxuICAgICAgICAgICAgICAgIHRvaW5kZXhcblxuICAgICAgICBmcm9taW5kZXggPSBcbiAgICAgICAgICAgIChmcm9taW5kZXggPiBsaXN0Ym91bmQpP1xuICAgICAgICAgICAgICAgIGxpc3Rib3VuZDpcbiAgICAgICAgICAgICAgICBmcm9taW5kZXhcblxuICAgICAgICBoaWdocmFuZ2UgPSBcbiAgICAgICAgICAgIChoaWdocmFuZ2UgPiBsaXN0Ym91bmQpP1xuICAgICAgICAgICAgICAgIGxpc3Rib3VuZDpcbiAgICAgICAgICAgICAgICBoaWdocmFuZ2VcblxuICAgICAgICAvLyBoaWdocmFuZ2UgbXVzdCBiZSA+PSBmcm9taW5kZXhcbiAgICAgICAgaGlnaHJhbmdlID0gXG4gICAgICAgICAgICAoaGlnaHJhbmdlID49IGZyb21pbmRleCk/XG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlOlxuICAgICAgICAgICAgICAgIGZyb21pbmRleFxuXG4gICAgICAgIGNvbnN0IHJhbmdlaW5jcmVtZW50ID0gaGlnaHJhbmdlIC0gZnJvbWluZGV4ICsgMVxuICAgICAgICBjb25zdCBtb3ZlaW5jcmVtZW50ID0gdG9pbmRleCAtIGZyb21pbmRleFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gY29uc3RyYWluIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpZiAoZnJvbWluZGV4ID09IHRvaW5kZXgpIHJldHVybiBbXSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgLy8gbW92ZSBtdXN0IGJlIGluIGxpc3QgYm91bmRzXG4gICAgICAgIGlmIChtb3ZlaW5jcmVtZW50ID4gMCkgeyAvLyBtb3ZlIHVwXG4gICAgICAgICAgICBjb25zdCB0YXJnZXR0b3AgPSB0b2luZGV4ICsgKHJhbmdlaW5jcmVtZW50IC0gMSlcbiAgICAgICAgICAgIGlmICh0YXJnZXR0b3AgPiBsaXN0Ym91bmQpIHJldHVybiBbXSAvLyBvdXQgb2YgYm91bmRzXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBwZXJmb3JtIGNhY2hlIGFuZCBjcmFkbGUgb3BlcmF0aW9ucyAtLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc3RhdGVIYW5kbGVyIH0gPSBcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gXG4gICAgICAgICAgICBjYWNoZUhhbmRsZXIubW92ZUluZGV4KHRvaW5kZXgsIGZyb21pbmRleCwgaGlnaHJhbmdlKVxuXG4gICAgICAgIGlmIChwcm9jZXNzZWRJbmRleExpc3QubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5jYWNoZVByb3BzLm1vZGlmaWVkID0gdHJ1ZVxuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnJlbmRlclBvcnRhbExpc3QoKVxuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5jaGFuZ2VDcmFkbGVJdGVtSURzKHByb2Nlc3NlZEluZGV4TGlzdClcblxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhMaXN0XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgaW5zZXJ0SW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgKzEpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgLTEpXG5cbiAgICB9XG5cbiAgICAvLyBzaGFyZWQgbG9naWMuIFJldHVybnMgbGlzdHMgb2YgaXRlbXMgY2hhbmdlZCwgYW5kIGl0ZW1zIHJlcGxhY2VkIChuZXcgaXRlbXMgZm9yIGluc2VydClcbiAgICAvLyB0aGlzIG9wZXJhdGlvbiBjaGFuZ2VzIHRoZSBsaXN0c2l6ZVxuICAgIHByaXZhdGUgaW5zZXJ0UmVtb3ZlSW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCBpbmNyZW1lbnQpID0+IHtcblxuICAgICAgICBpbmRleCA9IGluZGV4ID8/IDBcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSByYW5nZWhpZ2hpbmRleCA/PyBpbmRleFxuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCxpbmRleClcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSBNYXRoLm1heChyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUhhbmRsZXIsIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGxpc3RzaXplIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBbY2hhbmdlTGlzdCwgcmVwbGFjZUxpc3QsIHJhbmdlaW5jcmVtZW50LCBwb3J0YWxIb2xkTGlzdF0gPSBcbiAgICAgICAgICAgIGNhY2hlSGFuZGxlci5pbnNlcnRSZW1vdmVJbmRleChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIGluY3JlbWVudCwgbGlzdHNpemUpXG5cbiAgICAgICAgY2FjaGVIYW5kbGVyLmNhY2hlUHJvcHMubW9kaWZpZWQgPSB0cnVlXG4gICAgICAgIGNhY2hlSGFuZGxlci5yZW5kZXJQb3J0YWxMaXN0KClcbiAgICAgICAgY2FjaGVIYW5kbGVyLnBvcnRhbEhvbGRMaXN0ID0gcG9ydGFsSG9sZExpc3RcblxuICAgICAgICBjb250ZW50SGFuZGxlci5jaGFuZ2VDcmFkbGVJdGVtSURzKGNoYW5nZUxpc3QpXG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSArMSkgY29udGVudEhhbmRsZXIuY3JlYXRlTmV3SXRlbUlEcyhyZXBsYWNlTGlzdClcblxuICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGNvbnRlbnRIYW5kbGVyXG5cbiAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdhcHBseWNlbGxmcmFtZWNoYW5nZXMnKVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWNvdW50ID0gcmFuZ2VpbmNyZW1lbnQgLy8gc2VtYW50aWNzXG4gICAgICAgIGNvbnN0IG5ld2xpc3RzaXplID0gbGlzdHNpemUgKyBjaGFuZ2Vjb3VudCBcblxuICAgICAgICB0aGlzLnNldExpc3RzaXplKG5ld2xpc3RzaXplKVxuXG4gICAgICAgIHJldHVybiBbY2hhbmdlTGlzdCwgcmVwbGFjZUxpc3RdXG5cbiAgICB9XG5cbn1cblxuIl0sIm5hbWVzIjpbIlNlcnZpY2VIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsInN0YXRlSGFuZGxlciIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImludGVycnVwdEhhbmRsZXIiLCJwYXVzZUludGVycnVwdHMiLCJzZXRDcmFkbGVTdGF0ZSIsImluZGV4IiwiTWF0aCIsIm1heCIsInNpZ25hbHMiLCJzY2FmZm9sZEhhbmRsZXIiLCJwYXVzZVNjcm9sbGluZ0VmZmVjdHMiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJuZXdsaXN0c2l6ZSIsImNhY2hlSGFuZGxlciIsImNhbGxiYWNrcyIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJjdXJyZW50bGlzdHNpemUiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJsaXN0c2l6ZSIsImNhY2hlIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwiY2hhbmdlTGlzdHNpemUiLCJnZXRDYWNoZUluZGV4TWFwIiwiZ2V0Q2FjaGVJdGVtTWFwIiwiY29udGVudEhhbmRsZXIiLCJtb2RlbEluZGV4TGlzdCIsImdldE1vZGVsSW5kZXhMaXN0IiwiZ2V0Q3JhZGxlSW5kZXhNYXAiLCJjaGFuZ2VNYXAiLCJzaXplIiwiY2FjaGVQcm9wcyIsIm1ldGFkYXRhTWFwIiwicG9ydGFsTWFwIiwiaW5kZXhUb0l0ZW1JRE1hcCIsImluZGV4ZXNUb0RlbGV0ZUxpc3QiLCJjaGFuZ2VJbmRleFRvSXRlbUlETWFwIiwiTWFwIiwiZXJyb3JFbnRyaWVzTWFwIiwiZm9yRWFjaCIsIml0ZW1JRCIsInVuZGVmaW5lZCIsInB1c2giLCJzZXQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXMiLCJnZXQiLCJtYXBzaXplIiwiaXRlbUlEU2V0IiwiU2V0IiwidmFsdWVzIiwiaXRlbXNldHNpemUiLCJpdGVtSURDb3VudE1hcCIsImNvdW50IiwiZHVwbGljYXRlSXRlbXNNYXAiLCJkdXBsaWNhdGVzVG9SZW1vdmVMaXN0Iiwib3JpZ2luYWxNYXAiLCJsZW5ndGgiLCJwcm9jZXNzZWRNYXAiLCJpdGVtZGF0YSIsImRlbGV0ZWRJdGVtSURUb0luZGV4TWFwIiwiZGVsZXRlZEluZGV4VG9JdGVtSURNYXAiLCJwb3J0YWxIb2xkTGlzdCIsIm9yaWdpbmFsSXRlbUlEIiwib3JpZ2luYWxJdGVtSURJbmRleCIsImZpbmFsSXRlbUlESW5kZXgiLCJmaW5hbEl0ZW1JRCIsIm1vZGlmaWVkIiwicmVuZGVyUG9ydGFsTGlzdCIsInByb2Nlc3NlZEluZGV4TGlzdCIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJkZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0IiwiZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0IiwiZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCIsIm1vZGlmaWVkSW5kZXhMaXN0IiwiY29uY2F0IiwicmVjb25jaWxlQ2VsbEZyYW1lcyIsInRvaW5kZXgiLCJmcm9taW5kZXgiLCJoaWdocmFuZ2UiLCJsaXN0Ym91bmQiLCJyYW5nZWluY3JlbWVudCIsIm1vdmVpbmNyZW1lbnQiLCJ0YXJnZXR0b3AiLCJtb3ZlSW5kZXgiLCJjaGFuZ2VDcmFkbGVJdGVtSURzIiwicmFuZ2VoaWdoaW5kZXgiLCJpbnNlcnRSZW1vdmVJbmRleCIsImluY3JlbWVudCIsImNoYW5nZUxpc3QiLCJyZXBsYWNlTGlzdCIsImNyZWF0ZU5ld0l0ZW1JRHMiLCJjb250ZW50IiwiY2hhbmdlY291bnQiLCJzZXRMaXN0c2l6ZSIsImV4dGVybmFsQ2FsbGJhY2tzUmVmIiwicmVmZXJlbmNlSW5kZXhDYWxsYmFjayIsInByZWxvYWRJbmRleENhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbnNDYWxsYmFjayIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n");

/***/ }),

/***/ "./src/cradle/statehandler.tsx":
/*!*************************************!*\
  !*** ./src/cradle/statehandler.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval(" // statehandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\n\nexports[\"default\"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxZLDZCQUVqQixzQkFBWUMsZ0JBQVosRUFBNEI7RUFBQTs7RUFFekIsS0FBS0EsZ0JBQUwsR0FBd0JBLGdCQUF4QjtFQUVBLElBQU1DLGtCQUFrQixHQUFHRCxnQkFBZ0IsQ0FBQ0UsMkJBQWpCLENBQTZDQyxPQUF4RTtFQUVBLEtBQUtDLGNBQUwsR0FBc0JILGtCQUFrQixDQUFDRyxjQUF6QztFQUNBLEtBQUtDLGNBQUwsR0FBc0JKLGtCQUFrQixDQUFDSSxjQUF6QztFQUNBLEtBQUtDLFlBQUwsR0FBb0JMLGtCQUFrQixDQUFDSyxZQUF2QztBQUVGLEM7O0FBWkxDLGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3g/NjM5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZWhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjEgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIGNvbnN0IGludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgIHRoaXMuc2V0Q3JhZGxlU3RhdGUgPSBpbnRlcm5hbFByb3BlcnRpZXMuc2V0Q3JhZGxlU3RhdGVcbiAgICAgICB0aGlzLmNyYWRsZVN0YXRlUmVmID0gaW50ZXJuYWxQcm9wZXJ0aWVzLmNyYWRsZVN0YXRlUmVmXG4gICAgICAgdGhpcy5pc01vdW50ZWRSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuaXNNb3VudGVkUmVmXG4gICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgY3JhZGxlU3RhdGVSZWZcbiAgICBwdWJsaWMgc2V0Q3JhZGxlU3RhdGVcbiAgICBwdWJsaWMgaXNNb3VudGVkUmVmXG5cbn1cbiJdLCJuYW1lcyI6WyJTdGF0ZUhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiaW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInNldENyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc01vdW50ZWRSZWYiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n");

/***/ }),

/***/ "./src/cradle/styleshandler.tsx":
/*!**************************************!*\
  !*** ./src/cradle/styleshandler.tsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval(" // styleshandler.tsx\n// copyright (c) 2021 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n\n  _classCallCheck(this, StylesHandler);\n\n  this.setCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n        cellHeight = _ref.cellHeight,\n        cellWidth = _ref.cellWidth,\n        gap = _ref.gap,\n        padding = _ref.padding,\n        crosscount = _ref.crosscount,\n        viewportheight = _ref.viewportheight,\n        viewportwidth = _ref.viewportwidth,\n        userstyles = _ref.userstyles,\n        triggerlineOffset = _ref.triggerlineOffset;\n\n    // TODO: change 'cradle' to 'head' and 'tail' for more granularity\n    // TODO: triggerline offset for head styles experimentally set to negative\n    //    to assure a breakline is always available for notification\n    var headstyles = _this.getHeadStyles(gap, padding, orientation, userstyles.cradle);\n\n    var tailstyles = _this.getTailStyles(gap, padding, orientation, userstyles.cradle);\n\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation, userstyles.axis);\n\n    var scaffoldHandler = _this.cradleParameters.handlersRef.current.scaffoldHandler;\n\n    var triggerlineheadstyles = _this.getTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    var triggerlineaxisstyles = _this.getTriggerlineAxisStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    var triggerlinetailstyles = _this.getTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n\n    scaffoldHandler.triggerlineSpan = _this.tailTriggerlineOffset - _this.headTriggerlineOffset;\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gridGap = gap + 'px';\n    tailstyles.gridGap = gap + 'px';\n\n    if (orientation == 'horizontal') {\n      headstyles.padding = \"\".concat(padding, \"px 0 \").concat(padding, \"px \").concat(padding, \"px\");\n      headstyles.width = 'auto';\n      headstyles.height = '100%';\n      headstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n      //     sets length of horiz cradle items in one line (row), not multi-row config\n\n      headstyles.gridTemplateRows = cellHeight ? \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\") : 'auto';\n      headstyles.gridTemplateColumns = 'none';\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      tailstyles.width = 'auto';\n      tailstyles.height = '100%';\n      tailstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n      //     sets length of horiz cradle items in one line (row), not multi-row config\n\n      tailstyles.gridTemplateRows = cellHeight ? \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\") : 'auto';\n      tailstyles.gridTemplateColumns = 'none';\n    } else if (orientation == 'vertical') {\n      headstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px 0 \").concat(padding, \"px\");\n      headstyles.width = '100%';\n      headstyles.height = 'auto';\n      headstyles.gridAutoFlow = 'row';\n      headstyles.gridTemplateRows = 'none';\n      headstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fill, minmax(\".concat(cellWidth, \"px, 1fr))\") : 'auto';\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      tailstyles.width = '100%';\n      tailstyles.height = 'auto';\n      tailstyles.gridAutoFlow = 'row';\n      tailstyles.gridTemplateRows = 'none';\n      tailstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fill, minmax(\".concat(cellWidth, \"px, 1fr))\") : 'auto';\n    }\n\n    return [headstyles, tailstyles, axisstyles, triggerlineheadstyles, triggerlineaxisstyles, triggerlinetailstyles, cradledividerstyles];\n  };\n\n  this.getHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = 0;\n      right = 0;\n      top = 'auto';\n    } else {\n      bottom = 0;\n      left = 'auto';\n      right = 0;\n      top = 0;\n    }\n\n    return Object.assign(Object.assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    }), userheadstyles);\n  };\n\n  this.getTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 'auto';\n      left = 0;\n      right = 0;\n      top = 0;\n    } else {\n      bottom = 0;\n      left = 0;\n      right = 'auto';\n      top = 0;\n    }\n\n    return Object.assign(Object.assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    }), usertailstyles);\n  };\n\n  this.getAxisStyles = function (gap, padding, orientation, useraxisstyles) {\n    var top, left, width, height; // for axis\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n      width = '100%';\n      height = 'auto';\n    } else {\n      top = 'auto';\n      left = padding + 'px';\n      width = 0;\n      height = '100%';\n    }\n\n    return Object.assign(Object.assign({}, {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    }), useraxisstyles);\n  };\n\n  this.getTriggerlineAxisStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var transform; // for position relative to axis\n\n    var position = 'absolute',\n        width = '100%',\n        height = '100%';\n    _this.axisTriggerlineOffset = triggerlineOffset;\n\n    if (orientation == 'horizontal') {\n      transform = \"translateX(\".concat(triggerlineOffset + 'px', \")\");\n    } else {\n      transform = \"translateY(\".concat(triggerlineOffset + 'px', \")\");\n    }\n\n    return Object.assign({}, {\n      position: position,\n      width: width,\n      height: height,\n      transform: transform\n    });\n  };\n\n  this.getTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var transform; // for position relative to axis\n\n    var position = 'absolute',\n        width = '100%',\n        height = '100%';\n\n    if (orientation == 'horizontal') {\n      _this.headTriggerlineOffset = -(cellWidth + gap - triggerlineOffset);\n      transform = \"translateX(\".concat(_this.headTriggerlineOffset + 'px', \")\");\n    } else {\n      _this.headTriggerlineOffset = -(cellHeight + gap - triggerlineOffset);\n      transform = \"translateY(\".concat(_this.headTriggerlineOffset + 'px', \")\");\n    }\n\n    return Object.assign({}, {\n      position: position,\n      width: width,\n      height: height,\n      transform: transform\n    });\n  };\n\n  this.getTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var transform; // for position relative to axis\n\n    var position = 'absolute',\n        width = '100%',\n        height = '100%';\n\n    if (orientation == 'horizontal') {\n      _this.tailTriggerlineOffset = cellWidth + gap - triggerlineOffset;\n      transform = \"translateX(\".concat(_this.tailTriggerlineOffset + 'px', \")\");\n    } else {\n      _this.tailTriggerlineOffset = cellHeight + gap - triggerlineOffset;\n      transform = \"translateY(\".concat(_this.tailTriggerlineOffset + 'px', \")\");\n    }\n\n    return Object.assign({}, {\n      position: position,\n      width: width,\n      height: height,\n      transform: transform\n    });\n  };\n\n  this.cradleParameters = cradleParameters;\n});\n\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0eWxlc2hhbmRsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7OztJQUVxQkEsYSw2QkFFbEIsdUJBQVlDLGdCQUFaLEVBQTRCO0VBQUE7O0VBQUE7O0VBWXBCLHVCQUFrQixnQkFhcEI7SUFBQSxJQVhEQyxXQVdDLFFBWERBLFdBV0M7SUFBQSxJQVZEQyxVQVVDLFFBVkRBLFVBVUM7SUFBQSxJQVREQyxTQVNDLFFBVERBLFNBU0M7SUFBQSxJQVJEQyxHQVFDLFFBUkRBLEdBUUM7SUFBQSxJQVBEQyxPQU9DLFFBUERBLE9BT0M7SUFBQSxJQU5EQyxVQU1DLFFBTkRBLFVBTUM7SUFBQSxJQUxEQyxjQUtDLFFBTERBLGNBS0M7SUFBQSxJQUpEQyxhQUlDLFFBSkRBLGFBSUM7SUFBQSxJQUhEQyxVQUdDLFFBSERBLFVBR0M7SUFBQSxJQUZEQyxpQkFFQyxRQUZEQSxpQkFFQzs7SUFFRDtJQUNBO0lBQ0E7SUFDQSxJQUFNQyxVQUFVLEdBQXVCLEtBQUksQ0FBQ0MsYUFBTCxDQUFtQlIsR0FBbkIsRUFBd0JDLE9BQXhCLEVBQWlDSixXQUFqQyxFQUE4Q1EsVUFBVSxDQUFDSSxNQUF6RCxDQUF2Qzs7SUFDQSxJQUFNQyxVQUFVLEdBQXVCLEtBQUksQ0FBQ0MsYUFBTCxDQUFtQlgsR0FBbkIsRUFBd0JDLE9BQXhCLEVBQWlDSixXQUFqQyxFQUE4Q1EsVUFBVSxDQUFDSSxNQUF6RCxDQUF2Qzs7SUFDQSxJQUFNRyxVQUFVLEdBQXVCLEtBQUksQ0FBQ0MsYUFBTCxDQUFtQmIsR0FBbkIsRUFBd0JDLE9BQXhCLEVBQWlDSixXQUFqQyxFQUE4Q1EsVUFBVSxDQUFDUyxJQUF6RCxDQUF2Qzs7SUFFQSxJQUFRQyxlQUFSLEdBQTRCLEtBQUksQ0FBQ25CLGdCQUFMLENBQXNCb0IsV0FBdEIsQ0FBa0NDLE9BQTlELENBQVFGLGVBQVI7O0lBQ0EsSUFBTUcscUJBQXFCLEdBQ3ZCLEtBQUksQ0FBQ0Msd0JBQUwsQ0FBOEJ0QixXQUE5QixFQUEwQ0MsVUFBMUMsRUFBc0RDLFNBQXRELEVBQWlFTyxpQkFBakUsRUFBb0ZOLEdBQXBGLENBREo7O0lBRUEsSUFBTW9CLHFCQUFxQixHQUN2QixLQUFJLENBQUNDLHdCQUFMLENBQThCeEIsV0FBOUIsRUFBMENDLFVBQTFDLEVBQXNEQyxTQUF0RCxFQUFpRU8saUJBQWpFLEVBQW9GTixHQUFwRixDQURKOztJQUVBLElBQU1zQixxQkFBcUIsR0FDdkIsS0FBSSxDQUFDQyx3QkFBTCxDQUE4QjFCLFdBQTlCLEVBQTBDQyxVQUExQyxFQUFzREMsU0FBdEQsRUFBaUVPLGlCQUFqRSxFQUFvRk4sR0FBcEYsQ0FESjs7SUFFQWUsZUFBZSxDQUFDUyxlQUFoQixHQUFrQyxLQUFJLENBQUNDLHFCQUFMLEdBQTZCLEtBQUksQ0FBQ0MscUJBQXBFO0lBRUEsSUFBTUMsbUJBQW1CLEdBQ3JCO01BQ0lDLE1BQU0sRUFBQyxDQURYO01BRUlDLFFBQVEsRUFBQyxVQUZiO01BR0lDLEtBQUssRUFBQyxNQUhWO01BSUlDLE1BQU0sRUFBQyxNQUpYO01BS0lDLFNBQVMsRUFBQztJQUxkLENBREo7SUFTQXpCLFVBQVUsQ0FBQzBCLE9BQVgsR0FBcUJqQyxHQUFHLEdBQUcsSUFBM0I7SUFFQVUsVUFBVSxDQUFDdUIsT0FBWCxHQUFxQmpDLEdBQUcsR0FBRyxJQUEzQjs7SUFFQSxJQUFJSCxXQUFXLElBQUksWUFBbkIsRUFBaUM7TUFFN0JVLFVBQVUsQ0FBQ04sT0FBWCxhQUF3QkEsT0FBeEIsa0JBQXVDQSxPQUF2QyxnQkFBb0RBLE9BQXBEO01BRUFNLFVBQVUsQ0FBQ3VCLEtBQVgsR0FBbUIsTUFBbkI7TUFDQXZCLFVBQVUsQ0FBQ3dCLE1BQVgsR0FBb0IsTUFBcEI7TUFDQXhCLFVBQVUsQ0FBQzJCLFlBQVgsR0FBMEIsUUFBMUIsQ0FONkIsQ0FPN0I7TUFDQTs7TUFDQTNCLFVBQVUsQ0FBQzRCLGdCQUFYLEdBQ0lyQyxVQUFVLG9CQUNJSSxVQURKLHNCQUMwQkosVUFEMUIsaUJBRU4sTUFIUjtNQUlBUyxVQUFVLENBQUM2QixtQkFBWCxHQUFpQyxNQUFqQztNQUVBMUIsVUFBVSxDQUFDVCxPQUFYLGFBQXdCQSxPQUF4QixnQkFBcUNBLE9BQXJDLGdCQUFrREEsT0FBbEQ7TUFFQVMsVUFBVSxDQUFDb0IsS0FBWCxHQUFtQixNQUFuQjtNQUNBcEIsVUFBVSxDQUFDcUIsTUFBWCxHQUFvQixNQUFwQjtNQUNBckIsVUFBVSxDQUFDd0IsWUFBWCxHQUEwQixRQUExQixDQW5CNkIsQ0FvQjdCO01BQ0E7O01BQ0F4QixVQUFVLENBQUN5QixnQkFBWCxHQUNJckMsVUFBVSxvQkFDSUksVUFESixzQkFDMEJKLFVBRDFCLGlCQUVOLE1BSFI7TUFJQVksVUFBVSxDQUFDMEIsbUJBQVgsR0FBaUMsTUFBakM7SUFFSCxDQTVCRCxNQTRCTyxJQUFJdkMsV0FBVyxJQUFJLFVBQW5CLEVBQStCO01BRWxDVSxVQUFVLENBQUNOLE9BQVgsYUFBd0JBLE9BQXhCLGdCQUFxQ0EsT0FBckMsa0JBQW9EQSxPQUFwRDtNQUVBTSxVQUFVLENBQUN1QixLQUFYLEdBQW1CLE1BQW5CO01BQ0F2QixVQUFVLENBQUN3QixNQUFYLEdBQW9CLE1BQXBCO01BQ0F4QixVQUFVLENBQUMyQixZQUFYLEdBQTBCLEtBQTFCO01BRUEzQixVQUFVLENBQUM0QixnQkFBWCxHQUE4QixNQUE5QjtNQUNBNUIsVUFBVSxDQUFDNkIsbUJBQVgsR0FDSXJDLFNBQVMsc0NBQ3VCQSxTQUR2QixpQkFFTCxNQUhSO01BS0FXLFVBQVUsQ0FBQ1QsT0FBWCxlQUEwQkEsT0FBMUIsZ0JBQXVDQSxPQUF2QyxnQkFBb0RBLE9BQXBEO01BRUFTLFVBQVUsQ0FBQ29CLEtBQVgsR0FBbUIsTUFBbkI7TUFDQXBCLFVBQVUsQ0FBQ3FCLE1BQVgsR0FBb0IsTUFBcEI7TUFDQXJCLFVBQVUsQ0FBQ3dCLFlBQVgsR0FBMEIsS0FBMUI7TUFFQXhCLFVBQVUsQ0FBQ3lCLGdCQUFYLEdBQThCLE1BQTlCO01BQ0F6QixVQUFVLENBQUMwQixtQkFBWCxHQUNJckMsU0FBUyxzQ0FDdUJBLFNBRHZCLGlCQUVMLE1BSFI7SUFLSDs7SUFFRCxPQUFPLENBQ0hRLFVBREcsRUFFSEcsVUFGRyxFQUdIRSxVQUhHLEVBSUhNLHFCQUpHLEVBS0hFLHFCQUxHLEVBTUhFLHFCQU5HLEVBT0hLLG1CQVBHLENBQVA7RUFVSCxDQTlHTTs7RUFnSEMscUJBQWdCLFVBQUMzQixHQUFELEVBQUtDLE9BQUwsRUFBYUosV0FBYixFQUF5QndDLGNBQXpCLEVBQTJDO0lBRS9ELElBQUlDLE1BQUosRUFBWUMsSUFBWixFQUFrQkMsR0FBbEIsRUFBdUJDLEtBQXZCOztJQUVBLElBQUk1QyxXQUFXLElBQUksVUFBbkIsRUFBK0I7TUFDM0J5QyxNQUFNLEdBQUcsQ0FBVDtNQUNBQyxJQUFJLEdBQUcsQ0FBUDtNQUNBRSxLQUFLLEdBQUcsQ0FBUjtNQUNBRCxHQUFHLEdBQUcsTUFBTjtJQUNILENBTEQsTUFLTztNQUNIRixNQUFNLEdBQUcsQ0FBVDtNQUNBQyxJQUFJLEdBQUcsTUFBUDtNQUNBRSxLQUFLLEdBQUcsQ0FBUjtNQUNBRCxHQUFHLEdBQUcsQ0FBTjtJQUNIOztJQUVELHVDQUFXO01BRVBYLFFBQVEsRUFBRSxVQUZIO01BR1BhLGVBQWUsRUFBRSxNQUhWO01BSVBDLE9BQU8sRUFBRSxNQUpGO01BS1BWLE9BQU8sRUFBRWpDLEdBQUcsR0FBRyxJQUxSO01BTVBDLE9BQU8sRUFBRUEsT0FBTyxHQUFHLElBTlo7TUFPUDJDLGNBQWMsRUFBQyxPQVBSO01BUVBDLFlBQVksRUFBQyxPQVJOO01BU1BDLFNBQVMsRUFBQyxZQVRIO01BVVBSLE1BQU0sRUFBTkEsTUFWTztNQVdQQyxJQUFJLEVBQUpBLElBWE87TUFZUEUsS0FBSyxFQUFMQSxLQVpPO01BYVBELEdBQUcsRUFBSEE7SUFiTyxDQUFYLEdBZTRCSCxjQWY1QjtFQWlCSCxDQWpDTzs7RUFtQ0EscUJBQWdCLFVBQUNyQyxHQUFELEVBQUtDLE9BQUwsRUFBYUosV0FBYixFQUF5QmtELGNBQXpCLEVBQTJDO0lBRS9ELElBQUlULE1BQUosRUFBWUMsSUFBWixFQUFrQkMsR0FBbEIsRUFBdUJDLEtBQXZCOztJQUVBLElBQUk1QyxXQUFXLElBQUksVUFBbkIsRUFBK0I7TUFDM0J5QyxNQUFNLEdBQUcsTUFBVDtNQUNBQyxJQUFJLEdBQUcsQ0FBUDtNQUNBRSxLQUFLLEdBQUcsQ0FBUjtNQUNBRCxHQUFHLEdBQUcsQ0FBTjtJQUNILENBTEQsTUFLTztNQUNIRixNQUFNLEdBQUcsQ0FBVDtNQUNBQyxJQUFJLEdBQUcsQ0FBUDtNQUNBRSxLQUFLLEdBQUcsTUFBUjtNQUNBRCxHQUFHLEdBQUcsQ0FBTjtJQUNIOztJQUVELHVDQUFXO01BRVBYLFFBQVEsRUFBRSxVQUZIO01BR1BhLGVBQWUsRUFBRSxNQUhWO01BSVBDLE9BQU8sRUFBRSxNQUpGO01BS1BWLE9BQU8sRUFBRWpDLEdBQUcsR0FBRyxJQUxSO01BTVBDLE9BQU8sRUFBRUEsT0FBTyxHQUFHLElBTlo7TUFPUDJDLGNBQWMsRUFBQyxPQVBSO01BUVBDLFlBQVksRUFBQyxPQVJOO01BU1BDLFNBQVMsRUFBQyxZQVRIO01BVVBOLEdBQUcsRUFBSEEsR0FWTztNQVdQRCxJQUFJLEVBQUpBLElBWE87TUFZUEUsS0FBSyxFQUFMQSxLQVpPO01BYVBILE1BQU0sRUFBTkE7SUFiTyxDQUFYLEdBZTRCUyxjQWY1QjtFQWlCSCxDQWpDTzs7RUFtQ0EscUJBQWdCLFVBQUMvQyxHQUFELEVBQU1DLE9BQU4sRUFBZUosV0FBZixFQUE0Qm1ELGNBQTVCLEVBQThDO0lBQ2xFLElBQUlSLEdBQUosRUFBU0QsSUFBVCxFQUFlVCxLQUFmLEVBQXNCQyxNQUF0QixDQURrRSxDQUNyQzs7SUFFN0IsSUFBSWxDLFdBQVcsSUFBSSxVQUFuQixFQUErQjtNQUMzQjJDLEdBQUcsR0FBR3ZDLE9BQU8sR0FBRyxJQUFoQjtNQUNBc0MsSUFBSSxHQUFHLE1BQVA7TUFDQVQsS0FBSyxHQUFHLE1BQVI7TUFDQUMsTUFBTSxHQUFHLE1BQVQ7SUFDSCxDQUxELE1BS087TUFDSFMsR0FBRyxHQUFHLE1BQU47TUFDQUQsSUFBSSxHQUFHdEMsT0FBTyxHQUFHLElBQWpCO01BQ0E2QixLQUFLLEdBQUcsQ0FBUjtNQUNBQyxNQUFNLEdBQUcsTUFBVDtJQUNIOztJQUVELHVDQUFZO01BQ1JGLFFBQVEsRUFBRSxVQURGO01BRVJXLEdBQUcsRUFBSEEsR0FGUTtNQUdSRCxJQUFJLEVBQUpBLElBSFE7TUFJUlQsS0FBSyxFQUFMQSxLQUpRO01BS1JDLE1BQU0sRUFBTkE7SUFMUSxDQUFaLEdBTzRCaUIsY0FQNUI7RUFTSCxDQXhCTzs7RUEwQkEsZ0NBQTJCLFVBQUNuRCxXQUFELEVBQWNDLFVBQWQsRUFBMEJDLFNBQTFCLEVBQXFDTyxpQkFBckMsRUFBd0ROLEdBQXhELEVBQStEO0lBQzlGLElBQUlpRCxTQUFKLENBRDhGLENBQ2hGOztJQUNkLElBQU1wQixRQUFRLEdBQUcsVUFBakI7SUFBQSxJQUNJQyxLQUFLLEdBQUcsTUFEWjtJQUFBLElBRUlDLE1BQU0sR0FBRyxNQUZiO0lBSUEsS0FBSSxDQUFDbUIscUJBQUwsR0FBNkI1QyxpQkFBN0I7O0lBRUEsSUFBSVQsV0FBVyxJQUFJLFlBQW5CLEVBQWlDO01BQzdCb0QsU0FBUyx3QkFBaUIzQyxpQkFBaUIsR0FBRyxJQUFyQyxNQUFUO0lBQ0gsQ0FGRCxNQUVPO01BQ0gyQyxTQUFTLHdCQUFpQjNDLGlCQUFpQixHQUFHLElBQXJDLE1BQVQ7SUFDSDs7SUFDRCx5QkFBWTtNQUNSdUIsUUFBUSxFQUFSQSxRQURRO01BRVJDLEtBQUssRUFBTEEsS0FGUTtNQUdSQyxNQUFNLEVBQU5BLE1BSFE7TUFJUmtCLFNBQVMsRUFBVEE7SUFKUSxDQUFaO0VBTUgsQ0FuQk87O0VBc0JBLGdDQUEyQixVQUFDcEQsV0FBRCxFQUFjQyxVQUFkLEVBQTBCQyxTQUExQixFQUFxQ08saUJBQXJDLEVBQXdETixHQUF4RCxFQUErRDtJQUM5RixJQUFJaUQsU0FBSixDQUQ4RixDQUNoRjs7SUFFZCxJQUFJcEIsUUFBUSxHQUFHLFVBQWY7SUFBQSxJQUNJQyxLQUFLLEdBQUcsTUFEWjtJQUFBLElBRUlDLE1BQU0sR0FBRyxNQUZiOztJQUdBLElBQUlsQyxXQUFXLElBQUksWUFBbkIsRUFBaUM7TUFDN0IsS0FBSSxDQUFDNkIscUJBQUwsR0FBNkIsRUFBRTNCLFNBQVMsR0FBR0MsR0FBWixHQUFpQk0saUJBQW5CLENBQTdCO01BQ0EyQyxTQUFTLHdCQUFpQixLQUFJLENBQUN2QixxQkFBTCxHQUE2QixJQUE5QyxNQUFUO0lBQ0gsQ0FIRCxNQUdPO01BQ0gsS0FBSSxDQUFDQSxxQkFBTCxHQUE2QixFQUFFNUIsVUFBVSxHQUFHRSxHQUFiLEdBQWtCTSxpQkFBcEIsQ0FBN0I7TUFDQTJDLFNBQVMsd0JBQWlCLEtBQUksQ0FBQ3ZCLHFCQUFMLEdBQTZCLElBQTlDLE1BQVQ7SUFDSDs7SUFDRCx5QkFBWTtNQUNSRyxRQUFRLEVBQVJBLFFBRFE7TUFFUkMsS0FBSyxFQUFMQSxLQUZRO01BR1JDLE1BQU0sRUFBTkEsTUFIUTtNQUlSa0IsU0FBUyxFQUFUQTtJQUpRLENBQVo7RUFNSCxDQW5CTzs7RUFzQkEsZ0NBQTJCLFVBQUNwRCxXQUFELEVBQWNDLFVBQWQsRUFBMEJDLFNBQTFCLEVBQXFDTyxpQkFBckMsRUFBd0ROLEdBQXhELEVBQStEO0lBQzlGLElBQUlpRCxTQUFKLENBRDhGLENBQ2hGOztJQUVkLElBQUlwQixRQUFRLEdBQUcsVUFBZjtJQUFBLElBQ0lDLEtBQUssR0FBRyxNQURaO0lBQUEsSUFFSUMsTUFBTSxHQUFHLE1BRmI7O0lBR0EsSUFBSWxDLFdBQVcsSUFBSSxZQUFuQixFQUFpQztNQUM3QixLQUFJLENBQUM0QixxQkFBTCxHQUE4QjFCLFNBQVMsR0FBR0MsR0FBWixHQUFpQk0saUJBQS9DO01BQ0EyQyxTQUFTLHdCQUFpQixLQUFJLENBQUN4QixxQkFBTCxHQUE2QixJQUE5QyxNQUFUO0lBQ0gsQ0FIRCxNQUdPO01BQ0gsS0FBSSxDQUFDQSxxQkFBTCxHQUE4QjNCLFVBQVUsR0FBR0UsR0FBYixHQUFrQk0saUJBQWhEO01BQ0EyQyxTQUFTLHdCQUFpQixLQUFJLENBQUN4QixxQkFBTCxHQUE2QixJQUE5QyxNQUFUO0lBQ0g7O0lBQ0QseUJBQVk7TUFDUkksUUFBUSxFQUFSQSxRQURRO01BRVJDLEtBQUssRUFBTEEsS0FGUTtNQUdSQyxNQUFNLEVBQU5BLE1BSFE7TUFJUmtCLFNBQVMsRUFBVEE7SUFKUSxDQUFaO0VBTUgsQ0FuQk87O0VBdFFOLEtBQUtyRCxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBRUQsQzs7QUFOTHVELGtCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3N0eWxlc2hhbmRsZXIudHN4PzQ1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGVzaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMSBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZXNIYW5kbGVyIHsgXG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwcml2YXRlIGhlYWRUcmlnZ2VybGluZU9mZnNldFxuICAgIHByaXZhdGUgYXhpc1RyaWdnZXJsaW5lT2Zmc2V0XG4gICAgcHJpdmF0ZSB0YWlsVHJpZ2dlcmxpbmVPZmZzZXRcblxuICAgIHB1YmxpYyBzZXRDcmFkbGVTdHlsZXMgPSAoe1xuXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHVzZXJzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuXG4gICAgfSkgPT4ge1xuXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSAnY3JhZGxlJyB0byAnaGVhZCcgYW5kICd0YWlsJyBmb3IgbW9yZSBncmFudWxhcml0eVxuICAgICAgICAvLyBUT0RPOiB0cmlnZ2VybGluZSBvZmZzZXQgZm9yIGhlYWQgc3R5bGVzIGV4cGVyaW1lbnRhbGx5IHNldCB0byBuZWdhdGl2ZVxuICAgICAgICAvLyAgICB0byBhc3N1cmUgYSBicmVha2xpbmUgaXMgYWx3YXlzIGF2YWlsYWJsZSBmb3Igbm90aWZpY2F0aW9uXG4gICAgICAgIGNvbnN0IGhlYWRzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IHRoaXMuZ2V0SGVhZFN0eWxlcyhnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uLCB1c2Vyc3R5bGVzLmNyYWRsZSlcbiAgICAgICAgY29uc3QgdGFpbHN0eWxlczpSZWFjdC5DU1NQcm9wZXJ0aWVzID0gdGhpcy5nZXRUYWlsU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24sIHVzZXJzdHlsZXMuY3JhZGxlKVxuICAgICAgICBjb25zdCBheGlzc3R5bGVzOlJlYWN0LkNTU1Byb3BlcnRpZXMgPSB0aGlzLmdldEF4aXNTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5heGlzKVxuXG4gICAgICAgIGNvbnN0IHsgc2NhZmZvbGRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB0cmlnZ2VybGluZWhlYWRzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IFxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VybGluZUhlYWRTdHlsZXMob3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuICAgICAgICBjb25zdCB0cmlnZ2VybGluZWF4aXNzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IFxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VybGluZUF4aXNTdHlsZXMob3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuICAgICAgICBjb25zdCB0cmlnZ2VybGluZXRhaWxzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IFxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VybGluZVRhaWxTdHlsZXMob3JpZW50YXRpb24sY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKVxuICAgICAgICBzY2FmZm9sZEhhbmRsZXIudHJpZ2dlcmxpbmVTcGFuID0gdGhpcy50YWlsVHJpZ2dlcmxpbmVPZmZzZXQgLSB0aGlzLmhlYWRUcmlnZ2VybGluZU9mZnNldFxuXG4gICAgICAgIGNvbnN0IGNyYWRsZWRpdmlkZXJzdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHpJbmRleDoxLCBcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHdpZHRoOicxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGJveFNoYWRvdzonMCAwIDVweCAzcHggcmVkJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGhlYWRzdHlsZXMuZ3JpZEdhcCA9IGdhcCArICdweCdcblxuICAgICAgICB0YWlsc3R5bGVzLmdyaWRHYXAgPSBnYXAgKyAncHgnXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykge1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4IDAgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ2NvbHVtbidcbiAgICAgICAgICAgIC8vIGV4cGxpY3QgY3Jvc3Njb3VudCBuZXh0IGxpbmUgYXMgd29ya2Fyb3VuZCBmb3IgRkYgcHJvYmxlbSAtIFxuICAgICAgICAgICAgLy8gICAgIHNldHMgbGVuZ3RoIG9mIGhvcml6IGNyYWRsZSBpdGVtcyBpbiBvbmUgbGluZSAocm93KSwgbm90IG11bHRpLXJvdyBjb25maWdcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ/XG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9ICdub25lJ1xuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMGBcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ2NvbHVtbidcbiAgICAgICAgICAgIC8vIGV4cGxpY3QgY3Jvc3Njb3VudCBuZXh0IGxpbmUgYXMgd29ya2Fyb3VuZCBmb3IgRkYgcHJvYmxlbSAtIFxuICAgICAgICAgICAgLy8gICAgIHNldHMgbGVuZ3RoIG9mIGhvcml6IGNyYWRsZSBpdGVtcyBpbiBvbmUgbGluZSAocm93KSwgbm90IG11bHRpLXJvdyBjb25maWdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ/XG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0bydcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9ICdub25lJ1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSAnYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ3JvdydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gJ25vbmUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGg/XG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoYXV0by1maWxsLCBtaW5tYXgoJHtjZWxsV2lkdGh9cHgsIDFmcikpYDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAwICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSAnbm9uZSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aD9cbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdChhdXRvLWZpbGwsIG1pbm1heCgke2NlbGxXaWR0aH1weCwgMWZyKSlgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0bydcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhlYWRzdHlsZXMsXG4gICAgICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5lYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJsaW5ldGFpbHN0eWxlcyxcbiAgICAgICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXNcbiAgICAgICAgXVxuICAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEhlYWRTdHlsZXMgPSAoZ2FwLHBhZGRpbmcsb3JpZW50YXRpb24sdXNlcmhlYWRzdHlsZXMpID0+IHtcblxuICAgICAgICBsZXQgYm90dG9tLCBsZWZ0LCB0b3AsIHJpZ2h0XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9ICdhdXRvJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gMFxuICAgICAgICAgICAgbGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgcmlnaHQgPSAwXG4gICAgICAgICAgICB0b3AgPSAwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gey4uLntcblxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdibHVlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBhbGlnbkNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB0b3AsXG5cbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLC4uLnVzZXJoZWFkc3R5bGVzfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUYWlsU3R5bGVzID0gKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJ0YWlsc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgdG9wID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi57XG5cbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYWxpZ25Db250ZW50OidzdGFydCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tLFxuXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcywuLi51c2VydGFpbHN0eWxlc31cblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QXhpc1N0eWxlcyA9IChnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uLCB1c2VyYXhpc3N0eWxlcykgPT4ge1xuICAgICAgICBsZXQgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IC8vIGZvciBheGlzXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRvcCA9IHBhZGRpbmcgKyAncHgnXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nICsgJ3B4J1xuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IC4uLntcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcywuLi51c2VyYXhpc3N0eWxlc31cblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VHJpZ2dlcmxpbmVBeGlzU3R5bGVzID0gKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApID0+IHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybSAvLyBmb3IgcG9zaXRpb24gcmVsYXRpdmUgdG8gYXhpc1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB3aWR0aCA9ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuXG4gICAgICAgIHRoaXMuYXhpc1RyaWdnZXJsaW5lT2Zmc2V0ID0gdHJpZ2dlcmxpbmVPZmZzZXRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3RyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J30pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHt0cmlnZ2VybGluZU9mZnNldCArICdweCd9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi57XG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXN9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdldFRyaWdnZXJsaW5lSGVhZFN0eWxlcyA9IChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKSA9PiB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gLy8gZm9yIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGF4aXNcblxuICAgICAgICBsZXQgcG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5oZWFkVHJpZ2dlcmxpbmVPZmZzZXQgPSAtKGNlbGxXaWR0aCArIGdhcCAtdHJpZ2dlcmxpbmVPZmZzZXQpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3RoaXMuaGVhZFRyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J30pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkVHJpZ2dlcmxpbmVPZmZzZXQgPSAtKGNlbGxIZWlnaHQgKyBnYXAgLXRyaWdnZXJsaW5lT2Zmc2V0KVxuICAgICAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHt0aGlzLmhlYWRUcmlnZ2VybGluZU9mZnNldCArICdweCd9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi57XG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXN9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdldFRyaWdnZXJsaW5lVGFpbFN0eWxlcyA9IChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCB0cmlnZ2VybGluZU9mZnNldCwgZ2FwKSA9PiB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gLy8gZm9yIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGF4aXNcblxuICAgICAgICBsZXQgcG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy50YWlsVHJpZ2dlcmxpbmVPZmZzZXQgPSAoY2VsbFdpZHRoICsgZ2FwIC10cmlnZ2VybGluZU9mZnNldClcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7dGhpcy50YWlsVHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnfSlgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWxUcmlnZ2VybGluZU9mZnNldCA9IChjZWxsSGVpZ2h0ICsgZ2FwIC10cmlnZ2VybGluZU9mZnNldClcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7dGhpcy50YWlsVHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnfSlgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ue1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJTdHlsZXNIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImdhcCIsInBhZGRpbmciLCJjcm9zc2NvdW50Iiwidmlld3BvcnRoZWlnaHQiLCJ2aWV3cG9ydHdpZHRoIiwidXNlcnN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiaGVhZHN0eWxlcyIsImdldEhlYWRTdHlsZXMiLCJjcmFkbGUiLCJ0YWlsc3R5bGVzIiwiZ2V0VGFpbFN0eWxlcyIsImF4aXNzdHlsZXMiLCJnZXRBeGlzU3R5bGVzIiwiYXhpcyIsInNjYWZmb2xkSGFuZGxlciIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsInRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJsaW5lSGVhZFN0eWxlcyIsInRyaWdnZXJsaW5lYXhpc3N0eWxlcyIsImdldFRyaWdnZXJsaW5lQXhpc1N0eWxlcyIsInRyaWdnZXJsaW5ldGFpbHN0eWxlcyIsImdldFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsInRyaWdnZXJsaW5lU3BhbiIsInRhaWxUcmlnZ2VybGluZU9mZnNldCIsImhlYWRUcmlnZ2VybGluZU9mZnNldCIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiZ3JpZEdhcCIsImdyaWRBdXRvRmxvdyIsImdyaWRUZW1wbGF0ZVJvd3MiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwidXNlcmhlYWRzdHlsZXMiLCJib3R0b20iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkNvbnRlbnQiLCJib3hTaXppbmciLCJ1c2VydGFpbHN0eWxlcyIsInVzZXJheGlzc3R5bGVzIiwidHJhbnNmb3JtIiwiYXhpc1RyaWdnZXJsaW5lT2Zmc2V0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n");

/***/ }),

/***/ "./src/infinitegridscroller.tsx":
/*!**************************************!*\
  !*** ./src/infinitegridscroller.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(" // infinitegridscroller.tsx\n// copyright (c) 2019-2022 Henrik Bechmann, Toronto, Licence: MIT\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    react-infinite-grid-scroller = RIGS\n\n    ROADMAP:\n\n        review all code\n\n        layout: uniform, variable, dense\n\n        cross-browser testing; smartphone testing\n\n        release to npm\n\n        create demo site - github pages\n\n    BUGS:\n    \n        - first row sometimes doesn't move axis to first position\n        - cellheight greater than viewport height causes problems\n        - cell width/height less than breakline offset causes problems\n\n    TODO:\n\n        - test changing all gridscroller parameters\n            test config size edge cases - over and under sized cells\n\n        - clear out TODO notes\n\n        - replace top/left with transformx/y\n\n        ----------------\n        (after layout...)\n        \n        - prioritize fetch cells for visible cells\n\n        - create random loading delays in test ui\n        - provide way to attempt reload of a single cell (change instanceID)\n        - test for two root portals\n        - calc minwidth by form factor\n        - review scroller-frame for appropriate dimensions - s/b inset:0;position:absolute\n        - add grid-template-rows: max-content to parent for safari issue grid-auto-flow: column not filling column\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar react_error_boundary_1 = __webpack_require__(/*! react-error-boundary */ \"./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\");\n\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n      resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1[\"default\"].createElement(\"div\", {\n    role: \"alert\"\n  }, react_1[\"default\"].createElement(\"p\", null, \"Oops! Something went wrong inside react-infinite-grid-scroller.\"), react_1[\"default\"].createElement(\"p\", null, \"Click to cancel the error and continue.\"), react_1[\"default\"].createElement(\"button\", {\n    onClick: resetErrorBoundary\n  }, \"Cancel error\"), react_1[\"default\"].createElement(\"pre\", null, error));\n}\n\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\"));\n\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ \"./src/Scrollblock.tsx\"));\n\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ \"./src/Cradle.tsx\"));\n\nvar cachehandler_1 = __webpack_require__(/*! ./cradle/cachehandler */ \"./src/cradle/cachehandler.tsx\"); // -------------------[ global session ID generator ]----------------\n\n\nvar globalScrollerID = 0; // ===================================[ INITIALIZE ]===========================\n\n/*\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the scrollblock, fullsize for adjusted cell height/width, which in turn contains the cradle\n        - a component that contains CellFrames (which contain displayed items or transitional placeholders).\n    The CellFrames are skeletons which contain the host content components.\n\n    Host content is created in a portal cache (via PortalAgent) and then portal'd to its host CellFrame\n\n    Scrollblock virtually represents the entirety of the list, and is the scroller\n\n    Cradle contains the list items, and is 'virtualized' -- it appears as\n      though it is the full scrollblock, but in fact it is only slightly larger than\n      the viewport.\n    - individual items are framed by CellFrame, managed by Cradle\n\n    Overall the infinitegridscroller manages the (often asynchronous) interactions of the\n    components of the mechanism\n*/\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // ------------------[ normalize properties ]--------------------\n  // console.log('InfiniteGridScroller props', props)\n  var _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? 'vertical' : _props$orientation,\n      _props$gap = props.gap,\n      gap = _props$gap === void 0 ? 0 : _props$gap,\n      _props$padding = props.padding,\n      padding = _props$padding === void 0 ? 0 : _props$padding,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      _props$layout = props.layout,\n      layout = _props$layout === void 0 ? 'uniform' : _props$layout,\n      _props$estimatedListS = props.estimatedListSize,\n      estimatedListSize = _props$estimatedListS === void 0 ? 0 : _props$estimatedListS,\n      _props$runwaySize = props.runwaySize,\n      runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n      _props$startingIndex = props.startingIndex,\n      startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n      getItem = props.getItem,\n      placeholder = props.placeholder,\n      _props$styles = props.styles,\n      styles = _props$styles === void 0 ? {} : _props$styles,\n      _props$useScrollTrack = props.useScrollTracker,\n      useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n      _props$cache = props.cache,\n      cache = _props$cache === void 0 ? 'cradle' : _props$cache,\n      _props$cacheMax = props.cacheMax,\n      cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n      _props$triggerlineOff = props.triggerlineOffset,\n      triggerlineOffset = _props$triggerlineOff === void 0 ? 10 : _props$triggerlineOff,\n      _props$callbacks = props.callbacks,\n      callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n      scrollerProperties = props.scrollerProperties,\n      _props$advanced = props.advanced,\n      advanced = _props$advanced === void 0 ? {} : _props$advanced; // avoid null\n\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  advanced = advanced !== null && advanced !== void 0 ? advanced : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  estimatedListSize = estimatedListSize !== null && estimatedListSize !== void 0 ? estimatedListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true; // prop constraints - non-negative values\n\n  runwaySize = Math.max(0, runwaySize);\n  estimatedListSize = Math.max(0, estimatedListSize);\n  startingIndex = Math.max(0, startingIndex); // enums\n\n  if (!['horizontal', 'vertical'].includes(orientation)) {\n    orientation = 'vertical';\n  }\n\n  if (!['preload', 'keepload', 'cradle'].includes(cache)) {\n    cache = 'cradle';\n  }\n\n  if (!['uniform', 'variable', 'dense'].includes(layout)) {\n    layout = 'uniform';\n  }\n\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs);\n\n  var _ref2 = (0, react_1.useState)('setup'),\n      _ref3 = _slicedToArray(_ref2, 2),\n      scrollerState = _ref3[0],\n      setScrollerState = _ref3[1];\n\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var _advanced = advanced,\n      showAxis = _advanced.showAxis,\n      VIEWPORT_RESIZE_TIMEOUT = _advanced.VIEWPORT_RESIZE_TIMEOUT,\n      IDLECALLBACK_TIMEOUT = _advanced.IDLECALLBACK_TIMEOUT,\n      MAX_CACHE_OVER_RUN = _advanced.MAX_CACHE_OVER_RUN;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 4000;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n\n  if (typeof showAxis != 'boolean') {\n    showAxis = true;\n  }\n\n  if (typeof useScrollTracker != 'boolean') {\n    useScrollTracker = true;\n  } // for mount\n\n\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current; // console.log('==> RUNNING RIGS','-'+scrollerID+'-', scrollerState)\n  // satisfy React Object.is for attributes\n\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  }\n\n  var cacheHandlerRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    var abortController = new AbortController();\n    scrollerSessionIDRef.current = globalScrollerID++;\n    cacheHandlerRef.current = new cachehandler_1.CacheHandler(scrollerSessionIDRef.current, setListsize, listsizeRef);\n    return function () {\n      abortController.abort(); // defensive\n    };\n  }, []);\n  var listsizeRef = (0, react_1.useRef)(estimatedListSize);\n  var listsize = listsizeRef.current;\n  var setListsize = (0, react_1.useCallback)(function (listsize) {\n    if (listsize == listsizeRef.current) return;\n    listsizeRef.current = listsize; // inform the user\n\n    callbacksRef.current.newListsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState('setlistsize');\n  }, []); // --------------------[ render ]---------------------\n\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case 'setup':\n      case 'setlistsize':\n        setScrollerState('ready');\n    }\n  }, [scrollerState]); // component calls are deferred to give cacheHanle a chance to initialize\n\n  return react_1[\"default\"].createElement(react_1[\"default\"].StrictMode, null, react_1[\"default\"].createElement(react_error_boundary_1.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: function onReset() {// reset the state of your app so the error doesn't happen again\n    },\n    onError: function onError(error, info) {\n      console.log('react-infinite-grid-scroller captured error', error);\n    }\n  }, scrollerState != 'setup' && react_1[\"default\"].createElement(Viewport_1[\"default\"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    scrollerProperties: scrollerProperties,\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1[\"default\"].createElement(Scrollblock_1[\"default\"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    scrollerID: scrollerID\n  }, react_1[\"default\"].createElement(Cradle_1[\"default\"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    listsize: listsize,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    cacheHandler: cacheHandlerRef.current,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    scrollerID: scrollerID\n  }))), scrollerState != 'setup' && react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cacheroot',\n    style: cacherootstyle\n  }, react_1[\"default\"].createElement(cachehandler_1.PortalList, {\n    cacheProps: cacheHandlerRef.current.cacheProps\n  }))));\n};\n\nvar cacherootstyle = {\n  display: 'none'\n}; // static, out of view \n\nexports[\"default\"] = InfiniteGridScroller; // utilities\n\nfunction compareProps(obj1, obj2) {\n  var keys = Object.keys(obj1);\n  var same;\n\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5maW5pdGVncmlkc2Nyb2xsZXIudHN4LmpzIiwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBOztBQUVBOztBQUVBLFNBQVNBLGFBQVQsT0FBa0Q7RUFBQSxJQUExQkMsS0FBMEIsUUFBMUJBLEtBQTBCO0VBQUEsSUFBbkJDLGtCQUFtQixRQUFuQkEsa0JBQW1CO0VBQ2hELE9BQ0VDO0lBQUtDLElBQUksRUFBQztFQUFWLEdBQ0VELDhHQURGLEVBRUVBLHNGQUZGLEVBR0VBO0lBQVFFLE9BQU8sRUFBRUg7RUFBakIsR0FBbUMsY0FBbkMsQ0FIRixFQUlFQyw4Q0FBTUYsS0FBTixDQUpGLENBREY7QUFRRDs7QUFFRDs7QUFDQTs7QUFDQTs7QUFFQSx1RyxDQUVBOzs7QUFFQSxJQUFJSyxnQkFBZ0IsR0FBRyxDQUF2QixDLENBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDQyxLQUFELEVBQVU7RUFFbkM7RUFFQTtFQUVBLHlCQThCSUEsS0E5QkosQ0FHSUMsV0FISjtFQUFBLElBR0lBLFdBSEosbUNBR2tCLFVBSGxCO0VBQUEsaUJBOEJJRCxLQTlCSixDQUlJRSxHQUpKO0VBQUEsSUFJSUEsR0FKSiwyQkFJVSxDQUpWO0VBQUEscUJBOEJJRixLQTlCSixDQUtJRyxPQUxKO0VBQUEsSUFLSUEsT0FMSiwrQkFLYyxDQUxkO0VBQUEsSUFNSUMsVUFOSixHQThCSUosS0E5QkosQ0FNSUksVUFOSjtFQUFBLElBT0lDLFNBUEosR0E4QklMLEtBOUJKLENBT0lLLFNBUEo7RUFBQSxvQkE4QklMLEtBOUJKLENBUUlNLE1BUko7RUFBQSxJQVFJQSxNQVJKLDhCQVFhLFNBUmI7RUFBQSw0QkE4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QUFMLEVBQXFDO01BQ2pDLE9BQU8sS0FBUDtJQUNIO0VBQ0o7O0VBQ0QsT0FBTyxJQUFQO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2luZmluaXRlZ3JpZHNjcm9sbGVyLnRzeD82M2UwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGluZmluaXRlZ3JpZHNjcm9sbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjIgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICByZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyID0gUklHU1xuXG4gICAgUk9BRE1BUDpcblxuICAgICAgICByZXZpZXcgYWxsIGNvZGVcblxuICAgICAgICBsYXlvdXQ6IHVuaWZvcm0sIHZhcmlhYmxlLCBkZW5zZVxuXG4gICAgICAgIGNyb3NzLWJyb3dzZXIgdGVzdGluZzsgc21hcnRwaG9uZSB0ZXN0aW5nXG5cbiAgICAgICAgcmVsZWFzZSB0byBucG1cblxuICAgICAgICBjcmVhdGUgZGVtbyBzaXRlIC0gZ2l0aHViIHBhZ2VzXG5cbiAgICBCVUdTOiBcbiAgICBcbiAgICAgICAgLSBmaXJzdCByb3cgc29tZXRpbWVzIGRvZXNuJ3QgbW92ZSBheGlzIHRvIGZpcnN0IHBvc2l0aW9uXG4gICAgICAgIC0gY2VsbGhlaWdodCBncmVhdGVyIHRoYW4gdmlld3BvcnQgaGVpZ2h0IGNhdXNlcyBwcm9ibGVtc1xuICAgICAgICAtIGNlbGwgd2lkdGgvaGVpZ2h0IGxlc3MgdGhhbiBicmVha2xpbmUgb2Zmc2V0IGNhdXNlcyBwcm9ibGVtc1xuXG4gICAgVE9ETzpcblxuICAgICAgICAtIHRlc3QgY2hhbmdpbmcgYWxsIGdyaWRzY3JvbGxlciBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB0ZXN0IGNvbmZpZyBzaXplIGVkZ2UgY2FzZXMgLSBvdmVyIGFuZCB1bmRlciBzaXplZCBjZWxsc1xuXG4gICAgICAgIC0gY2xlYXIgb3V0IFRPRE8gbm90ZXNcblxuICAgICAgICAtIHJlcGxhY2UgdG9wL2xlZnQgd2l0aCB0cmFuc2Zvcm14L3lcblxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIChhZnRlciBsYXlvdXQuLi4pXG4gICAgICAgIFxuICAgICAgICAtIHByaW9yaXRpemUgZmV0Y2ggY2VsbHMgZm9yIHZpc2libGUgY2VsbHNcblxuICAgICAgICAtIGNyZWF0ZSByYW5kb20gbG9hZGluZyBkZWxheXMgaW4gdGVzdCB1aVxuICAgICAgICAtIHByb3ZpZGUgd2F5IHRvIGF0dGVtcHQgcmVsb2FkIG9mIGEgc2luZ2xlIGNlbGwgKGNoYW5nZSBpbnN0YW5jZUlEKVxuICAgICAgICAtIHRlc3QgZm9yIHR3byByb290IHBvcnRhbHNcbiAgICAgICAgLSBjYWxjIG1pbndpZHRoIGJ5IGZvcm0gZmFjdG9yXG4gICAgICAgIC0gcmV2aWV3IHNjcm9sbGVyLWZyYW1lIGZvciBhcHByb3ByaWF0ZSBkaW1lbnNpb25zIC0gcy9iIGluc2V0OjA7cG9zaXRpb246YWJzb2x1dGVcbiAgICAgICAgLSBhZGQgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBtYXgtY29udGVudCB0byBwYXJlbnQgZm9yIHNhZmFyaSBpc3N1ZSBncmlkLWF1dG8tZmxvdzogY29sdW1uIG5vdCBmaWxsaW5nIGNvbHVtblxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZn0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7RXJyb3JCb3VuZGFyeX0gZnJvbSAncmVhY3QtZXJyb3ItYm91bmRhcnknXG5cbmZ1bmN0aW9uIEVycm9yRmFsbGJhY2soe2Vycm9yLCByZXNldEVycm9yQm91bmRhcnl9KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiByb2xlPVwiYWxlcnRcIj5cbiAgICAgIDxwPk9vcHMhIFNvbWV0aGluZyB3ZW50IHdyb25nIGluc2lkZSByZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLjwvcD5cbiAgICAgIDxwPkNsaWNrIHRvIGNhbmNlbCB0aGUgZXJyb3IgYW5kIGNvbnRpbnVlLjwvcD5cbiAgICAgIDxidXR0b24gb25DbGljaz17cmVzZXRFcnJvckJvdW5kYXJ5fT5DYW5jZWwgZXJyb3I8L2J1dHRvbj5cbiAgICAgIDxwcmU+e2Vycm9yfTwvcHJlPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL1ZpZXdwb3J0J1xuaW1wb3J0IFNjcm9sbGJsb2NrIGZyb20gJy4vU2Nyb2xsYmxvY2snXG5pbXBvcnQgQ3JhZGxlIGZyb20gJy4vQ3JhZGxlJ1xuXG5pbXBvcnQgeyBDYWNoZUhhbmRsZXIsIFBvcnRhbExpc3QgfSBmcm9tICcuL2NyYWRsZS9jYWNoZWhhbmRsZXInXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGdsb2JhbCBzZXNzaW9uIElEIGdlbmVyYXRvciBdLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgZ2xvYmFsU2Nyb2xsZXJJRCA9IDBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1bIElOSVRJQUxJWkUgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKlxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIHNjcm9sbGJsb2NrLCBmdWxsc2l6ZSBmb3IgYWRqdXN0ZWQgY2VsbCBoZWlnaHQvd2lkdGgsIHdoaWNoIGluIHR1cm4gY29udGFpbnMgdGhlIGNyYWRsZSBcbiAgICAgICAgLSBhIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIENlbGxGcmFtZXMgKHdoaWNoIGNvbnRhaW4gZGlzcGxheWVkIGl0ZW1zIG9yIHRyYW5zaXRpb25hbCBwbGFjZWhvbGRlcnMpLiBcbiAgICBUaGUgQ2VsbEZyYW1lcyBhcmUgc2tlbGV0b25zIHdoaWNoIGNvbnRhaW4gdGhlIGhvc3QgY29udGVudCBjb21wb25lbnRzLlxuXG4gICAgSG9zdCBjb250ZW50IGlzIGNyZWF0ZWQgaW4gYSBwb3J0YWwgY2FjaGUgKHZpYSBQb3J0YWxBZ2VudCkgYW5kIHRoZW4gcG9ydGFsJ2QgdG8gaXRzIGhvc3QgQ2VsbEZyYW1lXG5cbiAgICBTY3JvbGxibG9jayB2aXJ0dWFsbHkgcmVwcmVzZW50cyB0aGUgZW50aXJldHkgb2YgdGhlIGxpc3QsIGFuZCBpcyB0aGUgc2Nyb2xsZXJcblxuICAgIENyYWRsZSBjb250YWlucyB0aGUgbGlzdCBpdGVtcywgYW5kIGlzICd2aXJ0dWFsaXplZCcgLS0gaXQgYXBwZWFycyBhc1xuICAgICAgdGhvdWdoIGl0IGlzIHRoZSBmdWxsIHNjcm9sbGJsb2NrLCBidXQgaW4gZmFjdCBpdCBpcyBvbmx5IHNsaWdodGx5IGxhcmdlciB0aGFuXG4gICAgICB0aGUgdmlld3BvcnQuXG4gICAgLSBpbmRpdmlkdWFsIGl0ZW1zIGFyZSBmcmFtZWQgYnkgQ2VsbEZyYW1lLCBtYW5hZ2VkIGJ5IENyYWRsZVxuXG4gICAgT3ZlcmFsbCB0aGUgaW5maW5pdGVncmlkc2Nyb2xsZXIgbWFuYWdlcyB0aGUgKG9mdGVuIGFzeW5jaHJvbm91cykgaW50ZXJhY3Rpb25zIG9mIHRoZSBcbiAgICBjb21wb25lbnRzIG9mIHRoZSBtZWNoYW5pc21cbiovXG5cbmNvbnN0IEluZmluaXRlR3JpZFNjcm9sbGVyID0gKHByb3BzKSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1bIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0luZmluaXRlR3JpZFNjcm9sbGVyIHByb3BzJywgcHJvcHMpXG5cbiAgICBsZXQgeyBcblxuICAgICAgICAvLyBncmlkIHNwZWNzOlxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwID0gMCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBlZGdlc1xuICAgICAgICBwYWRkaW5nID0gMCwgLy8gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBjZWxsSGVpZ2h0LCAvLyByZXF1aXJlZC4gdGhlIG91dGVyIHBpeGVsIGhlaWdodCAtIGxpdGVyYWwgZm9yIHZlcnRpY2FsOyBhcHByb3hpbWF0ZSBmb3IgaG9yaXpvbnRhbFxuICAgICAgICBjZWxsV2lkdGgsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgd2lkdGggLSBsaXRlcmFsIGZvciBob3Jpem9udGFsOyBhcHByb3hpbWF0ZSBmb3IgdmVydGljYWxcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nLCAvLyB1bmlmb3JtLCB2YXJpYWJsZSAodXNlcyBheGlzKSwgZGVuc2VcblxuICAgICAgICAvLyBzY3JvbGxlciBzcGVjczpcbiAgICAgICAgZXN0aW1hdGVkTGlzdFNpemUgPSAwLCAvLyB0aGUgZXhhY3QgbnVtYmVyIG9mIHRoZSBzaXplIG9mIHRoZSB2aXJ0dWFsIGxpc3RcbiAgICAgICAgcnVud2F5U2l6ZSA9IDMsIC8vIHRoZSBudW1iZXIgb2YgaXRlbXMgb3V0c2lkZSB0aGUgdmlldyBvZiBlYWNoIHNpZGUgb2YgdGhlIHZpZXdwb3J0IFxuICAgICAgICAgICAgLy8gLS0gZ2l2ZXMgdGltZSB0byBhc3NlbWJsZSBiZWZvcmUgZGlzcGxheVxuICAgICAgICBzdGFydGluZ0luZGV4ID0gMCwgLy8gdGhlIDAtYmFzZWQgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGxpc3QsIHdoZW4gZmlyc3QgbG9hZGVkXG4gICAgICAgIGdldEl0ZW0sIC8vIHJlcXVpcmVkLiBmdW5jdGlvbiBwcm92aWRlZCBieSBob3N0IC0gcGFyYW1ldGVyIGlzIGluZGV4IG51bWJlciwgc2V0IGJ5IHN5c3RlbTsgXG4gICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudCwgb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsLiBhIHNwYXJzZSBjb21wb25lbnQgdG8gc3RhbmQgaW4gZm9yIGNvbnRlbnQgdW50aWwgdGhlIGNvbnRlbnQgYXJyaXZlczsgXG4gICAgICAgICAgICAvLyBvcHRpb25hbCwgcmVwbGFjZXMgZGVmYXVsdCBwbGFjZWhvbGRlclxuICAgICAgICBzdHlsZXMgPSB7fSwgLy8gb3B0aW9uYWwuIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KTsgaGFzIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB2aWV3cG9ydCwgc2Nyb2xsYmxvY2ssIGNyYWRsZSwgb3Igc2Nyb2xsdHJhY2tlclxuXG4gICAgICAgIC8vIHN5c3RlbSBzcGVjczpcbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlciA9IHRydWUsXG4gICAgICAgIGNhY2hlID0gJ2NyYWRsZScsIC8vIFwicHJlbG9hZFwiLCBcImtlZXBsb2FkXCIgb3IgXCJjcmFkbGVcIlxuICAgICAgICBjYWNoZU1heCA9IG51bGwsIC8vIGFsd2F5cyBtaW5pbXVtIGNyYWRsZSBudWxsIG1lYW5zIGxpbWl0ZWQgYnkgbGlzdHNpemVcbiAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQgPSAxMCwgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGhlYWQgb3IgdGFpbCBmb3IgY29udGVudCBzaGlmdHMgYWJvdmUvYmVsb3cgYXhpc1xuICAgICAgICBjYWxsYmFja3MgPSB7fSwgLy8gb3B0aW9uYWwuIGNsb3N1cmVzIHRvIGdldCBkaXJlY3QgYWNjZXNzIHRvIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcywgLy8gcmVxdWlyZWQgZm9yIGVtYmVkZGVkIHNjcm9sbGVyOyBzaGFyZXMgc2Nyb2xsZXIgc2V0dGluZ3Mgd2l0aCBjb250ZW50XG4gICAgICAgIGFkdmFuY2VkID0ge30sIC8vIG9wdGlvbmFsLiB0ZWNobmljYWwgc2V0dGluZ3MgbGlrZSB1c2VSZXF1ZXN0SWRsZUNhbGxiYWNrLCBhbmQgUmVxdWVzdElkbGVDYWxsYmFja1RpbWVvdXRcbiAgICB9ID0gcHJvcHNcblxuICAgIC8vIGF2b2lkIG51bGxcbiAgICBzdHlsZXMgPSBzdHlsZXMgPz8ge31cbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgPz8ge31cbiAgICBhZHZhbmNlZCA9IGFkdmFuY2VkID8/IHt9XG4gICAgc3RhcnRpbmdJbmRleCA9IHN0YXJ0aW5nSW5kZXggPz8gMFxuICAgIGVzdGltYXRlZExpc3RTaXplID0gZXN0aW1hdGVkTGlzdFNpemUgPz8gMFxuICAgIHJ1bndheVNpemUgPSBydW53YXlTaXplID8/IDNcbiAgICB1c2VTY3JvbGxUcmFja2VyID0gdXNlU2Nyb2xsVHJhY2tlciA/PyB0cnVlXG5cblxuICAgIC8vIHByb3AgY29uc3RyYWludHMgLSBub24tbmVnYXRpdmUgdmFsdWVzXG4gICAgcnVud2F5U2l6ZSA9IE1hdGgubWF4KDAscnVud2F5U2l6ZSlcbiAgICBlc3RpbWF0ZWRMaXN0U2l6ZSA9IE1hdGgubWF4KDAsZXN0aW1hdGVkTGlzdFNpemUpXG4gICAgc3RhcnRpbmdJbmRleCA9IE1hdGgubWF4KDAsc3RhcnRpbmdJbmRleClcblxuICAgIC8vIGVudW1zXG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkgeyBcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIGlmICghWydwcmVsb2FkJywna2VlcGxvYWQnLCdjcmFkbGUnXS5pbmNsdWRlcyhjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJ1xuICAgIH1cbiAgICBpZiAoIVsndW5pZm9ybScsICd2YXJpYWJsZScsICdkZW5zZSddLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nXG4gICAgfVxuXG4gICAgY29uc3QgZ3JpZFNwZWNzID0geyAvLyBwYWNrYWdlXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICBjb25zdCBbc2Nyb2xsZXJTdGF0ZSwgc2V0U2Nyb2xsZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3Qgc3R5bGVzUmVmID0gdXNlUmVmKHN0eWxlcylcbiAgICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoY2FsbGJhY2tzKVxuXG4gICAgbGV0IHtcblxuICAgICAgICBzaG93QXhpcyxcbiAgICAgICAgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQsXG4gICAgICAgIElETEVDQUxMQkFDS19USU1FT1VULFxuICAgICAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4sXG5cbiAgICB9ID0gYWR2YW5jZWRcblxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0gVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPz8gMjUwXG4gICAgSURMRUNBTExCQUNLX1RJTUVPVVQgPSBJRExFQ0FMTEJBQ0tfVElNRU9VVCA/PyA0MDAwXG4gICAgTUFYX0NBQ0hFX09WRVJfUlVOID0gTUFYX0NBQ0hFX09WRVJfUlVOID8/IDEuNVxuXG4gICAgaWYgKHR5cGVvZiBzaG93QXhpcyAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgc2hvd0F4aXMgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB1c2VTY3JvbGxUcmFja2VyICE9ICdib29sZWFuJykge1xuICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGZvciBtb3VudFxuICAgIGNvbnN0IHNjcm9sbGVyU2Vzc2lvbklEUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gICAgY29uc3Qgc2Nyb2xsZXJJRCA9IHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnRcblxuICAgIC8vIGNvbnNvbGUubG9nKCc9PT4gUlVOTklORyBSSUdTJywnLScrc2Nyb2xsZXJJRCsnLScsIHNjcm9sbGVyU3RhdGUpXG5cbiAgICAvLyBzYXRpc2Z5IFJlYWN0IE9iamVjdC5pcyBmb3IgYXR0cmlidXRlc1xuICAgIGlmICghY29tcGFyZVByb3BzKGdyaWRTcGVjcywgZ3JpZFNwZWNzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGdyaWRTcGVjc1JlZi5jdXJyZW50ID0gZ3JpZFNwZWNzXG4gICAgfVxuXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoc3R5bGVzLCBzdHlsZXNSZWYuY3VycmVudCkpIHtcbiAgICAgICAgc3R5bGVzUmVmLmN1cnJlbnQgPSBzdHlsZXNcbiAgICB9XG4gICAgaWYgKCFjb21wYXJlUHJvcHMoY2FsbGJhY2tzLCBjYWxsYmFja3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQgPSBjYWxsYmFja3NcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUhhbmRsZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCAoKCkgPT4ge1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50ID0gZ2xvYmFsU2Nyb2xsZXJJRCsrXG4gICAgICAgIGNhY2hlSGFuZGxlclJlZi5jdXJyZW50ID0gbmV3IENhY2hlSGFuZGxlcihzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50LCBzZXRMaXN0c2l6ZSwgbGlzdHNpemVSZWYpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCkgLy8gZGVmZW5zaXZlXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0sW10pXG5cbiAgICBjb25zdCBsaXN0c2l6ZVJlZiA9IHVzZVJlZihlc3RpbWF0ZWRMaXN0U2l6ZSlcblxuICAgIGNvbnN0IGxpc3RzaXplID0gbGlzdHNpemVSZWYuY3VycmVudFxuXG4gICAgY29uc3Qgc2V0TGlzdHNpemUgPSB1c2VDYWxsYmFjaygobGlzdHNpemUpID0+e1xuXG4gICAgICAgIGlmIChsaXN0c2l6ZSA9PSBsaXN0c2l6ZVJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBsaXN0c2l6ZVJlZi5jdXJyZW50ID0gbGlzdHNpemVcblxuICAgICAgICAvLyBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUgJiYgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUobGlzdHNpemUpXG5cbiAgICAgICAgc2V0U2Nyb2xsZXJTdGF0ZSgnc2V0bGlzdHNpemUnKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZW5kZXIgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHNjcm9sbGVyU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldGxpc3RzaXplJzpcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdyZWFkeScpXG4gICAgICAgIH1cblxuICAgIH0sW3Njcm9sbGVyU3RhdGVdKVxuXG4gICAgLy8gY29tcG9uZW50IGNhbGxzIGFyZSBkZWZlcnJlZCB0byBnaXZlIGNhY2hlSGFubGUgYSBjaGFuY2UgdG8gaW5pdGlhbGl6ZVxuICAgIHJldHVybiA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICAgICAgPEVycm9yQm91bmRhcnlcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQ9e0Vycm9yRmFsbGJhY2t9XG4gICAgICAgIG9uUmVzZXQ9eygpID0+IHtcbiAgICAgICAgICAvLyByZXNldCB0aGUgc3RhdGUgb2YgeW91ciBhcHAgc28gdGhlIGVycm9yIGRvZXNuJ3QgaGFwcGVuIGFnYWluXG4gICAgICAgIH19XG4gICAgICAgIG9uRXJyb3IgPSB7KGVycm9yOiBFcnJvciwgaW5mbzoge2NvbXBvbmVudFN0YWNrOiBzdHJpbmd9KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlciBjYXB0dXJlZCBlcnJvcicsIGVycm9yKVxuICAgICAgICB9fVxuICAgID5cblxuICAgICAgICB7KHNjcm9sbGVyU3RhdGUgIT0gJ3NldHVwJykgJiYgPFZpZXdwb3J0XG5cbiAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXMgPSB7c2Nyb2xsZXJQcm9wZXJ0aWVzfVxuICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCA9IHsgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgfVxuXG4gICAgICAgID5cbiAgICAgICAgXG4gICAgICAgICAgICA8U2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgICAgIGdyaWRTcGVjcyA9IHsgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPENyYWRsZSBcblxuICAgICAgICAgICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXNSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RzaXplID0geyBsaXN0c2l6ZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0geyBjYWNoZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlTWF4ID0geyBjYWNoZU1heCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDYWxsYmFja3MgPSB7IGNhbGxiYWNrc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleCA9IHsgc3RhcnRpbmdJbmRleCB9XG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICBydW53YXlTaXplID0geyBydW53YXlTaXplIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQgPSB7IHRyaWdnZXJsaW5lT2Zmc2V0IH1cblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhbmRsZXIgPSB7Y2FjaGVIYW5kbGVyUmVmLmN1cnJlbnR9XG4gICAgICAgICAgICAgICAgICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB7dXNlU2Nyb2xsVHJhY2tlcn1cbiAgICAgICAgICAgICAgICAgICAgc2hvd0F4aXMgPSB7IHNob3dBeGlzIH1cbiAgICAgICAgICAgICAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQgPSB7IElETEVDQUxMQkFDS19USU1FT1VUIH1cbiAgICAgICAgICAgICAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOID0geyBNQVhfQ0FDSEVfT1ZFUl9SVU4gfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cblxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1Njcm9sbGJsb2NrPlxuICAgICAgICA8L1ZpZXdwb3J0Pn1cbiAgICAgICAgeyhzY3JvbGxlclN0YXRlICE9ICdzZXR1cCcpICYmIDxkaXYgZGF0YS10eXBlID0gJ2NhY2hlcm9vdCcgc3R5bGUgPSB7IGNhY2hlcm9vdHN0eWxlIH0+XG4gICAgICAgICAgICA8UG9ydGFsTGlzdCBjYWNoZVByb3BzID0ge2NhY2hlSGFuZGxlclJlZi5jdXJyZW50LmNhY2hlUHJvcHN9Lz5cbiAgICAgICAgPC9kaXY+fVxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgICA8L1JlYWN0LlN0cmljdE1vZGU+XG59XG5cbmNvbnN0IGNhY2hlcm9vdHN0eWxlID0ge2Rpc3BsYXk6J25vbmUnfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzIC8vIHN0YXRpYywgb3V0IG9mIHZpZXcgXG5cbmV4cG9ydCBkZWZhdWx0IEluZmluaXRlR3JpZFNjcm9sbGVyXG5cbi8vIHV0aWxpdGllc1xuZnVuY3Rpb24gY29tcGFyZVByb3BzIChvYmoxLG9iajIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqMSlcbiAgICBsZXQgc2FtZVxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG9iajFba2V5XSxvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIkVycm9yRmFsbGJhY2siLCJlcnJvciIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInJlYWN0XzEiLCJyb2xlIiwib25DbGljayIsImdsb2JhbFNjcm9sbGVySUQiLCJJbmZpbml0ZUdyaWRTY3JvbGxlciIsInByb3BzIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsImVzdGltYXRlZExpc3RTaXplIiwicnVud2F5U2l6ZSIsInN0YXJ0aW5nSW5kZXgiLCJnZXRJdGVtIiwicGxhY2Vob2xkZXIiLCJzdHlsZXMiLCJ1c2VTY3JvbGxUcmFja2VyIiwiY2FjaGUiLCJjYWNoZU1heCIsInRyaWdnZXJsaW5lT2Zmc2V0IiwiY2FsbGJhY2tzIiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwiYWR2YW5jZWQiLCJNYXRoIiwibWF4IiwiaW5jbHVkZXMiLCJncmlkU3BlY3MiLCJncmlkU3BlY3NSZWYiLCJzY3JvbGxlclN0YXRlIiwic2V0U2Nyb2xsZXJTdGF0ZSIsInN0eWxlc1JlZiIsImNhbGxiYWNrc1JlZiIsInNob3dBeGlzIiwiVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQiLCJJRExFQ0FMTEJBQ0tfVElNRU9VVCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsInNjcm9sbGVyU2Vzc2lvbklEUmVmIiwic2Nyb2xsZXJJRCIsImN1cnJlbnQiLCJjb21wYXJlUHJvcHMiLCJjYWNoZUhhbmRsZXJSZWYiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJjYWNoZWhhbmRsZXJfMSIsInNldExpc3RzaXplIiwibGlzdHNpemVSZWYiLCJhYm9ydCIsImxpc3RzaXplIiwibmV3TGlzdHNpemUiLCJTdHJpY3RNb2RlIiwicmVhY3RfZXJyb3JfYm91bmRhcnlfMSIsIkZhbGxiYWNrQ29tcG9uZW50Iiwib25SZXNldCIsIm9uRXJyb3IiLCJpbmZvIiwiY29uc29sZSIsImxvZyIsIlZpZXdwb3J0XzEiLCJTY3JvbGxibG9ja18xIiwiQ3JhZGxlXzEiLCJ1c2VyQ2FsbGJhY2tzIiwiY2FjaGVIYW5kbGVyIiwic3R5bGUiLCJjYWNoZXJvb3RzdHlsZSIsImNhY2hlUHJvcHMiLCJkaXNwbGF5IiwiZXhwb3J0cyIsIm9iajEiLCJvYmoyIiwia2V5cyIsIk9iamVjdCIsInNhbWUiLCJrZXkiLCJpcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n");

/***/ }),

/***/ "./node_modules/react-error-boundary/dist/react-error-boundary.umd.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-error-boundary/dist/react-error-boundary.umd.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"react\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  var changedArray = function changedArray(a, b) {\n    if (a === void 0) {\n      a = [];\n    }\n\n    if (b === void 0) {\n      b = [];\n    }\n\n    return a.length !== b.length || a.some(function (item, index) {\n      return !Object.is(item, b[index]);\n    });\n  };\n\n  var initialState = {\n    error: null\n  };\n\n  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(ErrorBoundary, _React$Component);\n\n    function ErrorBoundary() {\n      var _this;\n\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n      _this.state = initialState;\n\n      _this.resetErrorBoundary = function () {\n        var _this$props;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n        _this.reset();\n      };\n\n      return _this;\n    }\n\n    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    };\n\n    var _proto = ErrorBoundary.prototype;\n\n    _proto.reset = function reset() {\n      this.setState(initialState);\n    };\n\n    _proto.componentDidCatch = function componentDidCatch(error, info) {\n      var _this$props$onError, _this$props2;\n\n      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      var error = this.state.error;\n      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n      // happens to *also* be in the resetKeys array, we'd end up resetting\n      // the error boundary immediately. This would likely trigger a second\n      // error to be thrown.\n      // So we make sure that we don't check the resetKeys on the first call\n      // of cDU after the error is set\n\n      if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n        var _this$props$onResetKe, _this$props3;\n\n        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n        this.reset();\n      }\n    };\n\n    _proto.render = function render() {\n      var error = this.state.error;\n      var _this$props4 = this.props,\n          fallbackRender = _this$props4.fallbackRender,\n          FallbackComponent = _this$props4.FallbackComponent,\n          fallback = _this$props4.fallback;\n\n      if (error !== null) {\n        var _props = {\n          error: error,\n          resetErrorBoundary: this.resetErrorBoundary\n        };\n\n        if ( /*#__PURE__*/React__namespace.isValidElement(fallback)) {\n          return fallback;\n        } else if (typeof fallbackRender === 'function') {\n          return fallbackRender(_props);\n        } else if (FallbackComponent) {\n          return /*#__PURE__*/React__namespace.createElement(FallbackComponent, _props);\n        } else {\n          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n        }\n      }\n\n      return this.props.children;\n    };\n\n    return ErrorBoundary;\n  }(React__namespace.Component);\n\n  function withErrorBoundary(Component, errorBoundaryProps) {\n    var Wrapped = function Wrapped(props) {\n      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__namespace.createElement(Component, props));\n    }; // Format for display in DevTools\n\n\n    var name = Component.displayName || Component.name || 'Unknown';\n    Wrapped.displayName = \"withErrorBoundary(\" + name + \")\";\n    return Wrapped;\n  }\n\n  function useErrorHandler(givenError) {\n    var _React$useState = React__namespace.useState(null),\n        error = _React$useState[0],\n        setError = _React$useState[1];\n\n    if (givenError != null) throw givenError;\n    if (error != null) throw error;\n    return setError;\n  }\n  /*\n  eslint\n    @typescript-eslint/sort-type-union-intersection-members: \"off\",\n    @typescript-eslint/no-throw-literal: \"off\",\n    @typescript-eslint/prefer-nullish-coalescing: \"off\"\n  */\n\n  exports.ErrorBoundary = ErrorBoundary;\n  exports.useErrorHandler = useErrorHandler;\n  exports.withErrorBoundary = withErrorBoundary;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-error-boundary.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pHLEVBQUUsQ0FDaUk7QUFDbkksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVycm9yLWJvdW5kYXJ5L2Rpc3QvcmVhY3QtZXJyb3ItYm91bmRhcnkudW1kLmpzP2U4OTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdEVycm9yQm91bmRhcnkgPSB7fSwgZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuXG4gIHZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbiAgfShSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoQ29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICB2YXIgV3JhcHBlZCA9IGZ1bmN0aW9uIFdyYXBwZWQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIGVycm9yQm91bmRhcnlQcm9wcywgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTsgLy8gRm9ybWF0IGZvciBkaXNwbGF5IGluIERldlRvb2xzXG5cblxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIiArIG5hbWUgKyBcIilcIjtcbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihnaXZlbkVycm9yKSB7XG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobnVsbCksXG4gICAgICAgIGVycm9yID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRFcnJvciA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGlmIChnaXZlbkVycm9yICE9IG51bGwpIHRocm93IGdpdmVuRXJyb3I7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBzZXRFcnJvcjtcbiAgfVxuICAvKlxuICBlc2xpbnRcbiAgICBAdHlwZXNjcmlwdC1lc2xpbnQvc29ydC10eXBlLXVuaW9uLWludGVyc2VjdGlvbi1tZW1iZXJzOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsOiBcIm9mZlwiLFxuICAgIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nOiBcIm9mZlwiXG4gICovXG5cbiAgZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbiAgZXhwb3J0cy51c2VFcnJvckhhbmRsZXIgPSB1c2VFcnJvckhhbmRsZXI7XG4gIGV4cG9ydHMud2l0aEVycm9yQm91bmRhcnkgPSB3aXRoRXJyb3JCb3VuZGFyeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1lcnJvci1ib3VuZGFyeS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-error-boundary/dist/react-error-boundary.umd.js\n");

/***/ }),

/***/ "./node_modules/react-reverse-portal/dist/web/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-reverse-portal/dist/web/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InPortal\": () => (/* binding */ InPortal),\n/* harmony export */   \"OutPortal\": () => (/* binding */ OutPortal),\n/* harmony export */   \"createHtmlPortalNode\": () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   \"createSvgPortalNode\": () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"react-dom\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = 'html';\nvar ELEMENT_TYPE_SVG = 'svg';\n// ReactDOM can handle several different namespaces, but they're not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error(\"Unrecognized element type \\\"\" + elementType + \"\\\" for validateElementType.\");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement('div');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, 'g');\n    }\n    else {\n        throw new Error(\"Invalid element type \\\"\" + elementType + \"\\\" for createPortalNode: must be \\\"html\\\" or \\\"svg\\\".\");\n    }\n    if (options && typeof options === \"object\") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode's elementType needs to match\n            // the elementType it's being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error(\"Invalid element type for portal: \\\"\" + elementType + \"\\\" portalNodes must be used with \" + elementType + \" elements, but OutPortal is within <\" + newParent.tagName + \">.\");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren't currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we're switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n");

/***/ }),

/***/ "./node_modules/requestidlecallback/index.js":
/*!***************************************************!*\
  !*** ./node_modules/requestidlecallback/index.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/infinitegridscroller.tsx");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});