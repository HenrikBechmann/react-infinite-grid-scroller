(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["Scroller"] = factory(require("React"));
	else
		root["Scroller"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/infinitegridscroller.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/react-is-mounted-hook/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-is-mounted-hook/lib/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar use_is_mounted_1 = __importDefault(__webpack_require__(/*! ./use-is-mounted */ \"./node_modules/react-is-mounted-hook/lib/use-is-mounted.js\"));\nexports.default = use_is_mounted_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL2luZGV4LmpzPzVjOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHVDQUF1QyxtQkFBTyxDQUFDLG9GQUFrQjtBQUNqRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzLW1vdW50ZWQtaG9vay9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1c2VfaXNfbW91bnRlZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3VzZS1pcy1tb3VudGVkXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZV9pc19tb3VudGVkXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is-mounted-hook/lib/index.js\n");

/***/ }),

/***/ "./node_modules/react-is-mounted-hook/lib/use-is-mounted.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-is-mounted-hook/lib/use-is-mounted.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = __webpack_require__(/*! react */ \"react\");\nfunction useIsMounted() {\n    var ref = react_1.useRef(false);\n    react_1.useEffect(function () {\n        ref.current = true;\n        return function () {\n            ref.current = false;\n        };\n    }, []);\n    return function () { return ref.current; };\n}\nexports.default = useIsMounted;\n//# sourceMappingURL=use-is-mounted.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy1tb3VudGVkLWhvb2svbGliL3VzZS1pcy1tb3VudGVkLmpzPzkzMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMtbW91bnRlZC1ob29rL2xpYi91c2UtaXMtbW91bnRlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gICAgdmFyIHJlZiA9IHJlYWN0XzEudXNlUmVmKGZhbHNlKTtcbiAgICByZWFjdF8xLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuY3VycmVudDsgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUlzTW91bnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pcy1tb3VudGVkLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is-mounted-hook/lib/use-is-mounted.js\n");

/***/ }),

/***/ "./node_modules/requestidlecallback/index.js":
/*!***************************************************!*\
  !*** ./node_modules/requestidlecallback/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof global != undefined ?\n\t\t\tglobal :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxLQUFLLElBQTBDO0FBQy9DLEVBQUUsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3JCLEVBQUUsTUFBTSxFQUlOO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyx5REFBeUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixpREFBaUQ7QUFDbkk7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlcXVlc3RpZGxlY2FsbGJhY2svaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuaWRsZUNhbGxiYWNrU2hpbSA9IGZhY3RvcnkoKTtcblx0fVxufShmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBzY2hlZHVsZVN0YXJ0LCB0aHJvdHRsZURlbGF5LCBsYXp5dGltZXIsIGxhenlyYWY7XG5cdHZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/XG5cdFx0d2luZG93IDpcblx0XHR0eXBlb2YgZ2xvYmFsICE9IHVuZGVmaW5lZCA/XG5cdFx0XHRnbG9iYWwgOlxuXHRcdFx0dGhpcyB8fCB7fTtcblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG5cdHZhciBjYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG5cdHZhciB0YXNrcyA9IFtdO1xuXHR2YXIgcnVuQXR0ZW1wdHMgPSAwO1xuXHR2YXIgaXNSdW5uaW5nID0gZmFsc2U7XG5cdHZhciByZW1haW5pbmdUaW1lID0gNztcblx0dmFyIG1pblRocm90dGxlID0gMzU7XG5cdHZhciB0aHJvdHRsZSA9IDEyNTtcblx0dmFyIGluZGV4ID0gMDtcblx0dmFyIHRhc2tTdGFydCA9IDA7XG5cdHZhciB0YXNrbGVuZ3RoID0gMDtcblx0dmFyIElkbGVEZWFkbGluZSA9IHtcblx0XHRnZXQgZGlkVGltZW91dCgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dGltZVJlbWFpbmluZzogZnVuY3Rpb24oKXtcblx0XHRcdHZhciB0aW1lUmVtYWluaW5nID0gcmVtYWluaW5nVGltZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nIDwgMCA/IDAgOiB0aW1lUmVtYWluaW5nO1xuXHRcdH0sXG5cdH07XG5cdHZhciBzZXRJbmFjdGl2ZSA9IGRlYm91bmNlKGZ1bmN0aW9uKCl7XG5cdFx0cmVtYWluaW5nVGltZSA9IDIyO1xuXHRcdHRocm90dGxlID0gNjY7XG5cdFx0bWluVGhyb3R0bGUgPSAwO1xuXHR9KTtcblxuXHRmdW5jdGlvbiBkZWJvdW5jZShmbil7XG5cdFx0dmFyIGlkLCB0aW1lc3RhbXA7XG5cdFx0dmFyIHdhaXQgPSA5OTtcblx0XHR2YXIgY2hlY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGxhc3QgPSAoRGF0ZS5ub3coKSkgLSB0aW1lc3RhbXA7XG5cblx0XHRcdGlmIChsYXN0IDwgd2FpdCkge1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQgLSBsYXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlkID0gbnVsbDtcblx0XHRcdFx0Zm4oKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0dGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblx0XHRcdGlmKCFpZCl7XG5cdFx0XHRcdGlkID0gc2V0VGltZW91dChjaGVjaywgd2FpdCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFib3J0UnVubmluZygpe1xuXHRcdGlmKGlzUnVubmluZyl7XG5cdFx0XHRpZihsYXp5cmFmKXtcblx0XHRcdFx0Y2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxhenlyYWYpO1xuXHRcdFx0fVxuXHRcdFx0aWYobGF6eXRpbWVyKXtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGxhenl0aW1lcik7XG5cdFx0XHR9XG5cdFx0XHRpc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvbklucHV0b3JNdXRhdGlvbigpe1xuXHRcdGlmKHRocm90dGxlICE9IDEyNSl7XG5cdFx0XHRyZW1haW5pbmdUaW1lID0gNztcblx0XHRcdHRocm90dGxlID0gMTI1O1xuXHRcdFx0bWluVGhyb3R0bGUgPSAzNTtcblxuXHRcdFx0aWYoaXNSdW5uaW5nKSB7XG5cdFx0XHRcdGFib3J0UnVubmluZygpO1xuXHRcdFx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2V0SW5hY3RpdmUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlQWZ0ZXJSYWYoKSB7XG5cdFx0bGF6eXJhZiA9IG51bGw7XG5cdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChydW5UYXNrcywgMCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZVJhZigpe1xuXHRcdGxhenl0aW1lciA9IG51bGw7XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlQWZ0ZXJSYWYpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVMYXp5KCl7XG5cblx0XHRpZihpc1J1bm5pbmcpe3JldHVybjt9XG5cdFx0dGhyb3R0bGVEZWxheSA9IHRocm90dGxlIC0gKERhdGUubm93KCkgLSB0YXNrU3RhcnQpO1xuXG5cdFx0c2NoZWR1bGVTdGFydCA9IERhdGUubm93KCk7XG5cblx0XHRpc1J1bm5pbmcgPSB0cnVlO1xuXG5cdFx0aWYobWluVGhyb3R0bGUgJiYgdGhyb3R0bGVEZWxheSA8IG1pblRocm90dGxlKXtcblx0XHRcdHRocm90dGxlRGVsYXkgPSBtaW5UaHJvdHRsZTtcblx0XHR9XG5cblx0XHRpZih0aHJvdHRsZURlbGF5ID4gOSl7XG5cdFx0XHRsYXp5dGltZXIgPSBzZXRUaW1lb3V0KHNjaGVkdWxlUmFmLCB0aHJvdHRsZURlbGF5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3R0bGVEZWxheSA9IDA7XG5cdFx0XHRzY2hlZHVsZVJhZigpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJ1blRhc2tzKCl7XG5cdFx0dmFyIHRhc2ssIGksIGxlbjtcblx0XHR2YXIgdGltZVRocmVzaG9sZCA9IHJlbWFpbmluZ1RpbWUgPiA5ID9cblx0XHRcdDkgOlxuXHRcdFx0MVxuXHRcdDtcblxuXHRcdHRhc2tTdGFydCA9IERhdGUubm93KCk7XG5cdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXG5cdFx0aWYocnVuQXR0ZW1wdHMgPiAyIHx8IHRhc2tTdGFydCAtIHRocm90dGxlRGVsYXkgLSA1MCA8IHNjaGVkdWxlU3RhcnQpe1xuXHRcdFx0Zm9yKGkgPSAwLCBsZW4gPSB0YXNrcy5sZW5ndGg7IGkgPCBsZW4gJiYgSWRsZURlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVUaHJlc2hvbGQ7IGkrKyl7XG5cdFx0XHRcdHRhc2sgPSB0YXNrcy5zaGlmdCgpO1xuXHRcdFx0XHR0YXNrbGVuZ3RoKys7XG5cdFx0XHRcdGlmKHRhc2spe1xuXHRcdFx0XHRcdHRhc2soSWRsZURlYWRsaW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHRhc2tzLmxlbmd0aCl7XG5cdFx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cnVuQXR0ZW1wdHMgPSAwO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltKHRhc2spe1xuXHRcdGluZGV4Kys7XG5cdFx0dGFza3MucHVzaCh0YXNrKTtcblx0XHRzY2hlZHVsZUxhenkoKTtcblx0XHRyZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltKGlkKXtcblx0XHR2YXIgaW5kZXggPSBpZCAtIDEgLSB0YXNrbGVuZ3RoO1xuXHRcdGlmKHRhc2tzW2luZGV4XSl7XG5cdFx0XHR0YXNrc1tpbmRleF0gPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGlmKCFyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgIXJvb3QuY2FuY2VsSWRsZUNhbGxiYWNrKXtcblx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbTtcblx0XHRyb290LmNhbmNlbElkbGVDYWxsYmFjayA9IGNhbmNlbElkbGVDYWxsYmFja1NoaW07XG5cblx0XHRpZihyb290LmRvY3VtZW50ICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpe1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRyb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uSW5wdXRvck11dGF0aW9uKTtcblxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbklucHV0b3JNdXRhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRbJ2NsaWNrJywgJ2tleXByZXNzJywgJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvbklucHV0b3JNdXRhdGlvbiwge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWV9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZihyb290Lk11dGF0aW9uT2JzZXJ2ZXIpe1xuXHRcdFx0XHRuZXcgTXV0YXRpb25PYnNlcnZlciggb25JbnB1dG9yTXV0YXRpb24gKS5vYnNlcnZlKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWV9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRyeXtcblx0XHRcdHJvb3QucmVxdWVzdElkbGVDYWxsYmFjayhmdW5jdGlvbigpe30sIHt0aW1lb3V0OiAwfSk7XG5cdFx0fSBjYXRjaChlKXtcblx0XHRcdChmdW5jdGlvbihySUMpe1xuXHRcdFx0XHR2YXIgdGltZVJlbWFpbmluZ1Byb3RvLCB0aW1lUmVtYWluaW5nO1xuXHRcdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbihmbiwgdGltZW91dCl7XG5cdFx0XHRcdFx0aWYodGltZW91dCAmJiB0eXBlb2YgdGltZW91dC50aW1lb3V0ID09ICdudW1iZXInKXtcblx0XHRcdFx0XHRcdHJldHVybiBySUMoZm4sIHRpbWVvdXQudGltZW91dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBySUMoZm4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZihyb290LklkbGVDYWxsYmFja0RlYWRsaW5lICYmICh0aW1lUmVtYWluaW5nUHJvdG8gPSBJZGxlQ2FsbGJhY2tEZWFkbGluZS5wcm90b3R5cGUpKXtcblx0XHRcdFx0XHR0aW1lUmVtYWluaW5nID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aW1lUmVtYWluaW5nUHJvdG8sICd0aW1lUmVtYWluaW5nJyk7XG5cdFx0XHRcdFx0aWYoIXRpbWVSZW1haW5pbmcgfHwgIXRpbWVSZW1haW5pbmcuY29uZmlndXJhYmxlIHx8ICF0aW1lUmVtYWluaW5nLmdldCl7cmV0dXJuO31cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycsIHtcblx0XHRcdFx0XHRcdHZhbHVlOiAgZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRpbWVSZW1haW5pbmcuZ2V0LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSkocm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cmVxdWVzdDogcmVxdWVzdElkbGVDYWxsYmFja1NoaW0sXG5cdFx0Y2FuY2VsOiBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltLFxuXHR9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n");

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz82ZGQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0MsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDLDZCQUE2QixFQUFFLGFBQWE7QUFDNUcsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUNBQW1DLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpRUFBaUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOENBQThDO0FBQzlDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUEyQztBQUM3RTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWMsb0VBQUssRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/cradle.tsx":
/*!************************!*\
  !*** ./src/cradle.tsx ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // cradle.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    TODO:\n*/\n\n/*\n    Description\n    -----------\n\n    This module has one main design pattern: the butterfuly pattern (my name)\n\n    the butterfly pattern:\n        This pattern consists of two containers for items (the \"wings\"), joined by a 0-length div (the \"spine\").\n        The wings are fixed to the spine through the bottom/right position style on one side, and top/left\n        on the other. Thus additions or deletions effect the distant ends of the wings from the spine on each end.\n        All three together comprise the \"cradle\" of items. After a change of content, the only compensating\n        adjustment required is the change of position of the spine in relation to the viewport.\n\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\");\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"];\n\nvar cradlefunctions_1 = __webpack_require__(/*! ./cradlefunctions */ \"./src/cradlefunctions.tsx\");\n\nvar scrolltracker_1 = __importDefault(__webpack_require__(/*! ./scrolltracker */ \"./src/scrolltracker.tsx\"));\n\nvar SCROLL_TIMEOUT_FOR_ONAFTERSCROLL = 200;\n\nvar Cradle = function Cradle(_a) {\n  var gap = _a.gap,\n      padding = _a.padding,\n      runwaylength = _a.runwaylength,\n      runwaycount = _a.runwaycount,\n      listsize = _a.listsize,\n      offset = _a.offset,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      getItem = _a.getItem,\n      placeholder = _a.placeholder,\n      functions = _a.functions,\n      styles = _a.styles; // functions and styles handled separately\n\n  var cradlePropsRef = react_1.useRef(null); // access by closures\n\n  cradlePropsRef.current = react_1.useMemo(function () {\n    return {\n      gap: gap,\n      padding: padding,\n      runwaylength: runwaylength,\n      runwaycount: runwaycount,\n      listsize: listsize,\n      offset: offset,\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      getItem: getItem,\n      placeholder: placeholder\n    };\n  }, [gap, padding, runwaylength, runwaycount, listsize, offset, orientation, cellHeight, cellWidth, getItem, placeholder]); // =============================================================================================\n  // --------------------------------------[ INITIALIZATION ]-------------------------------------\n  // =============================================================================================\n  // -----------------------------------------------------------------------\n  // -----------------------------------[ utilites ]------------------------\n\n  var isMounted = react_is_mounted_hook_1[\"default\"]();\n  var referenceIndexCallbackRef = react_1.useRef(functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback);\n  var itemObserverRef = react_1.useRef(null); // IntersectionObserver\n\n  var cradleIntersectionObserverRef = react_1.useRef(null);\n  var cradleResizeObserverRef = react_1.useRef(null); // -----------------------------------------------------------------------\n  // ---------------------------[ context data ]----------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n  var viewportDataRef = react_1.useRef(null);\n  viewportDataRef.current = viewportData;\n\n  var _b = react_1.useState('setup'),\n      cradlestate = _b[0],\n      saveCradleState = _b[1];\n\n  var cradlestateRef = react_1.useRef(null); // access by closures\n\n  cradlestateRef.current = cradlestate; // console.log('running cradle with state',cradlestate)\n  // -----------------------------------------------------------------------\n  // -------------------------[ control variables ]-----------------\n\n  var pauseItemObserverRef = react_1.useRef(false);\n  var pauseCradleIntersectionObserverRef = react_1.useRef(false);\n  var pauseCradleResizeObserverRef = react_1.useRef(false);\n  var pauseScrollingEffectsRef = react_1.useRef(false); // to control appearance of repositioning mode\n\n  var isTailCradleInViewRef = react_1.useRef(true);\n  var isHeadCradleInViewRef = react_1.useRef(true);\n  var isCradleInViewRef = react_1.useRef(true); // ------------------------------------------------------------------------\n  // -----------------------[ initialization effects ]-----------------------\n  //initialize host functions properties\n\n  react_1.useEffect(function () {\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('scrollToItem')) {\n      functions.scrollToItem = scrollToItem;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getVisibleList')) {\n      functions.getVisibleList = getVisibleList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('getContentList')) {\n      functions.getContentList = getContentList;\n    }\n\n    if (functions === null || functions === void 0 ? void 0 : functions.hasOwnProperty('reload')) {\n      functions.reload = reload;\n    }\n\n    referenceIndexCallbackRef.current = functions === null || functions === void 0 ? void 0 : functions.referenceIndexCallback;\n  }, [functions]); // initialize window scroll listener\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n    viewportData.elementref.current.addEventListener('scroll', onScroll);\n    return function () {\n      viewportData.elementref.current && viewportData.elementref.current.removeEventListener('scroll', onScroll);\n    };\n  }, []); // -----------------------------------------------------------------------\n  // -----------------------[ reconfiguration effects ]---------------------\n  // trigger resizing based on viewport state\n\n  react_1.useEffect(function () {\n    if (viewportData.isResizing) {\n      // enter resizing mode\n      callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n      pauseItemObserverRef.current = true;\n      pauseCradleIntersectionObserverRef.current = true;\n      pauseScrollingEffectsRef.current = true;\n      saveCradleState('resizing');\n    } // complete resizing mode\n\n\n    if (!viewportData.isResizing && cradlestateRef.current == 'resizing') {\n      saveCradleState('resize');\n    }\n  }, [viewportData.isResizing]); // reload for changed parameters\n\n  react_1.useEffect(function () {\n    if (cradlestateRef.current == 'setup') return;\n    callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    pauseScrollingEffectsRef.current = true;\n    saveCradleState('reload');\n  }, [listsize, cellHeight, cellWidth, gap, padding]); // trigger pivot on change in orientation\n\n  react_1.useEffect(function () {\n    headModelContentRef.current = [];\n    tailModelContentRef.current = [];\n\n    if (cradlestateRef.current != 'setup') {\n      callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n      pauseItemObserverRef.current = true;\n      pauseCradleIntersectionObserverRef.current = true;\n      pauseScrollingEffectsRef.current = true;\n      saveCradleState('pivot');\n    }\n  }, [orientation]); // =======================================================================\n  // -------------------------[ OPERATION ]---------------------------------\n  // =======================================================================\n  // -----------------------------------------------------------------------\n  // ------------------------[ session data ]-------------------------------\n  // ------------------ current location -- first head visible item -------------\n\n  var _c = react_1.useState({\n    index: Math.min(offset, listsize - 1) || 0,\n    scrolloffset: 0\n  }),\n      immediateReferenceIndexData = _c[0],\n      saveImmediateReferenceIndexData = _c[1];\n\n  var immediateReferenceIndexDataRef = react_1.useRef(null); // access by closures\n\n  immediateReferenceIndexDataRef.current = immediateReferenceIndexData;\n  var masterReferenceIndexDataRef = react_1.useRef(immediateReferenceIndexData); // capture for state resetContent operations\n\n  var callingReferenceIndexDataRef = react_1.useRef(immediateReferenceIndexData); // anticipate reposition\n  // -------------------------------[ cradle data ]-------------------------------------\n  // cradle butterfly html components\n\n  var headCradleElementRef = react_1.useRef(null);\n  var tailCradleElementRef = react_1.useRef(null);\n  var spineCradleElementRef = react_1.useRef(null); // data model\n\n  var modelContentRef = react_1.useRef(null);\n  var headModelContentRef = react_1.useRef(null);\n  var tailModelContentRef = react_1.useRef(null); // view model\n\n  var headViewContentRef = react_1.useRef([]);\n  var tailViewContentRef = react_1.useRef([]);\n  var itemElementsRef = react_1.useRef(new Map()); // items register their element\n  // ------------------------------[ cradle configuration ]---------------------------\n  // viewportDimensions, crosscount, rowcount\n\n  var viewportDimensions = viewportData.viewportDimensions;\n  var viewportheight = viewportDimensions.height,\n      viewportwidth = viewportDimensions.width;\n  var crosscount = react_1.useMemo(function () {\n    var crosscount;\n    var size = orientation == 'horizontal' ? viewportheight : viewportwidth;\n    var crossLength = orientation == 'horizontal' ? cellHeight : cellWidth;\n    var lengthforcalc = size - padding * 2 + gap; // length of viewport\n\n    var tilelengthforcalc = crossLength + gap;\n    tilelengthforcalc = Math.min(tilelengthforcalc, lengthforcalc); // result cannot be less than 1\n\n    crosscount = Math.floor(lengthforcalc / tilelengthforcalc);\n    return crosscount;\n  }, [orientation, cellWidth, cellHeight, gap, padding, viewportheight, viewportwidth]);\n  var crosscountRef = react_1.useRef(crosscount); // for easy reference by observer\n\n  crosscountRef.current = crosscount; // available for observer closure\n\n  var _d = react_1.useMemo(function () {\n    var viewportLength, cellLength;\n\n    if (orientation == 'vertical') {\n      viewportLength = viewportheight;\n      cellLength = cellHeight;\n    } else {\n      viewportLength = viewportwidth;\n      cellLength = cellWidth;\n    }\n\n    cellLength += gap;\n    var viewportrowcount = Math.ceil(viewportLength / cellLength);\n    var cradlerowcount = viewportrowcount + runwaycount * 2;\n    var itemcount = cradlerowcount * crosscount;\n\n    if (itemcount > listsize) {\n      itemcount = listsize;\n      cradlerowcount = Math.ceil(itemcount / crosscount);\n    }\n\n    return [cradlerowcount, viewportrowcount];\n  }, [orientation, cellWidth, cellHeight, gap, listsize, // padding,\n  viewportheight, viewportwidth, runwaycount, crosscount]),\n      cradlerowcount = _d[0],\n      viewportrowcount = _d[1];\n\n  var cradlerowcountRef = react_1.useRef(null);\n  cradlerowcountRef.current = cradlerowcount;\n  var viewportrowcountRef = react_1.useRef(null);\n  viewportrowcountRef.current = viewportrowcount; // base styles\n\n  var cradleHeadStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = gap + 'px';\n      left = 0;\n      right = 0;\n      top = 'auto';\n    } else {\n      bottom = 0;\n      left = 'auto';\n      right = gap + 'px';\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]);\n  var cradleTailStyle = react_1.useMemo(function () {\n    var bottom, left, top, right;\n\n    if (orientation == 'vertical') {\n      bottom = 'auto';\n      left = 0;\n      right = 0;\n      top = 0;\n    } else {\n      bottom = 0;\n      left = 0;\n      right = 'right';\n      top = 0;\n    }\n\n    return __assign(__assign({}, {\n      position: 'absolute',\n      backgroundColor: 'blue',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      justifyContent: 'start',\n      alignContent: 'start',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    }), styles === null || styles === void 0 ? void 0 : styles.cradle);\n  }, [gap, padding, styles, orientation]);\n  var cradleSpineStyle = react_1.useMemo(function () {\n    var paddingx, paddingy, top, left;\n\n    if (orientation == 'vertical') {\n      paddingx = 0;\n      paddingy = padding;\n      top = padding + 'px', left = 'auto';\n    } else {\n      paddingx = padding;\n      paddingy = 0;\n      left = padding + 'px';\n      top = 'auto';\n    }\n\n    return {\n      position: 'relative',\n      top: top,\n      left: left\n    };\n  }, [padding, orientation]); // enhanced styles for grid\n\n  var _e = react_1.useMemo(function () {\n    // merge base style and revisions (by observer)\n    var headCradleStyles = __assign({}, cradleHeadStyle);\n\n    var tailCradleStyles = __assign({}, cradleTailStyle);\n\n    var _a = cradlefunctions_1.setCradleGridStyles({\n      orientation: orientation,\n      headCradleStyles: headCradleStyles,\n      tailCradleStyles: tailCradleStyles,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      crosscount: crosscount,\n      viewportheight: viewportheight,\n      viewportwidth: viewportwidth\n    }),\n        headstyles = _a[0],\n        tailstyles = _a[1];\n\n    var top, left;\n\n    if (orientation == 'vertical') {\n      top = padding + 'px';\n      left = 'auto';\n    } else {\n      top = 'auto';\n      left = 'padding' + 'px';\n    }\n\n    var spinestyle = {\n      position: 'relative',\n      top: top,\n      left: left\n    };\n    return [headstyles, tailstyles, spinestyle];\n  }, [orientation, cellHeight, cellWidth, gap, padding, viewportheight, viewportwidth, crosscount, cradleHeadStyle, cradleTailStyle, cradleSpineStyle]),\n      headstyle = _e[0],\n      tailstyle = _e[1],\n      spinestyle = _e[2];\n\n  cradleHeadStyle = headstyle;\n  cradleTailStyle = tailstyle;\n  cradleSpineStyle = spinestyle; // =================================================================================\n  // -------------------------[ IntersectionObserver support]-------------------------\n  // =================================================================================\n\n  /*\n      There are two interection observers, one for the cradle, and another for itemShells;\n          both against the viewport.\n      There is also a resize observer for the cradle wings, to respond to size changes of\n          variable cells.\n  */\n  // --------------------------[ cradle observers ]-----------------------------------\n  // set up cradle resizeobserver\n\n  react_1.useEffect(function () {\n    // ResizeObserver\n    cradleResizeObserverRef.current = new LocalResizeObserver(cradleresizeobservercallback);\n    cradleResizeObserverRef.current.observe(headCradleElementRef.current);\n    cradleResizeObserverRef.current.observe(tailCradleElementRef.current);\n    return function () {\n      cradleResizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleresizeobservercallback = react_1.useCallback(function (entries) {\n    if (pauseCradleResizeObserverRef.current) return; // console.log('cradle resize entries',entries)\n  }, []); // this sets up an IntersectionObserver of the cradle against the viewport. When the\n  // cradle goes out of the observer scope, the \"repositioning\" cradle state is triggerd.\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current; // IntersectionObserver\n\n    cradleIntersectionObserverRef.current = new IntersectionObserver(cradleintersectionobservercallback, {\n      root: viewportData.elementref.current,\n      threshold: 0\n    });\n    cradleIntersectionObserverRef.current.observe(headCradleElementRef.current);\n    cradleIntersectionObserverRef.current.observe(tailCradleElementRef.current);\n    return function () {\n      cradleIntersectionObserverRef.current.disconnect();\n    };\n  }, []);\n  var cradleintersectionobservercallback = react_1.useCallback(function (entries) {\n    if (pauseCradleIntersectionObserverRef.current) return;\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (entry.target.dataset.name == 'head') {\n        isHeadCradleInViewRef.current = entry.isIntersecting;\n      } else {\n        isTailCradleInViewRef.current = entry.isIntersecting;\n      }\n    }\n\n    isCradleInViewRef.current = isHeadCradleInViewRef.current || isTailCradleInViewRef.current;\n  }, []); // --------------------------[ item shell observer ]-----------------------------\n\n  /*\n      The cradle content is driven by notifications from the IntersectionObserver.\n      - as the user scrolls the cradle, which has a runwaycount at both the leading\n          and trailing edges, itemShells scroll into or out of the scope of the observer\n          (defined by the width/height of the viewport + the lengths of the runways). The observer\n          notifies the app (through itemobservercallback() below) at the crossings of the itemshells\n          of the defined observer cradle boundaries.\n           The no-longer-intersecting notifications trigger dropping of that number of affected items from\n          the cradle contentlist. The dropping of items from the trailing end of the content list\n          triggers the addition of an equal number of items at the leading edge of the cradle content.\n           Technically, the opposite end position spec is set (top or left depending on orientation),\n          and the matching end position spec is set to 'auto' when items are added. This causes items to be\n          \"squeezed\" into the leading or trailing ends of the ui content (out of view) as appropriate.\n           There are exceptions for setup and edge cases.\n  */\n\n  react_1.useEffect(function () {\n    itemObserverRef.current = new IntersectionObserver(itemobservercallback, {\n      root: viewportDataRef.current.elementref.current,\n      threshold: .9\n    });\n    return function () {\n      itemObserverRef.current.disconnect();\n    };\n  }, [orientation]); // the async callback from IntersectionObserver.\n\n  var itemobservercallback = react_1.useCallback(function (entries) {\n    if (pauseItemObserverRef.current) {\n      // console.log('returning with pauseItemObserverRef.current',pauseItemObserverRef.current)\n      return;\n    }\n\n    isMounted() && adjustcradleentries(entries);\n  }, []); // TODO: investigate case where both forward and backward scroll\n  // adjust scroll content:\n  // 1.shift, 2.clip, and 3.add clip amount at other end\n\n  var adjustcradleentries = react_1.useCallback(function (entries) {\n    var _a, _b;\n\n    var spinesideintersections;\n\n    var localentries = __spreadArrays(entries); // if (cradlestateRef.current == 'ready' || cradlestateRef.current == 'updatescroll') {\n    //     let orientation = cradlePropsRef.current.orientation\n    //     // console.log('OBSERVER entries',entries)\n    //     spinesideintersections = localentries.filter(entry => {\n    //         if (orientation == 'vertical') {\n    //            // TODO: be sure this works in narrow viewport\n    //            // for closer to the spine, bottom is closer to the top than to the bottom of the viewport\n    //            return (Math.abs( entry.rootBounds.top - entry.intersectionRect.bottom ) < \n    //                Math.abs(entry.rootBounds.bottom - entry.intersectionRect.bottom)) // &&\n    //                // entry.intersectionRatio != 0\n    //         } else {\n    //            return (Math.abs( entry.rootBounds.left - entry.intersectionRect.right ) < \n    //                Math.abs(entry.rootBounds.right - entry.intersectionRect.right)) //&&\n    //                // entry.intersectionRatio != 0\n    //         }\n    //     })\n    // } else {\n    //     return\n    // }\n    // console.log('spinesideintersections.length',spinesideintersections.length,spinesideintersections)\n\n\n    spinesideintersections = localentries; // if (spinesideintersections.length == 0) return\n\n    var viewportData = viewportDataRef.current;\n\n    var localintersections = __spreadArrays(spinesideintersections);\n\n    var contentlistcopy = __spreadArrays(modelContentRef.current);\n\n    var cradleProps = cradlePropsRef.current;\n    var listsize = cradleProps.listsize;\n    var headCradleElement = headCradleElementRef.current;\n    var tailCradleElement = tailCradleElementRef.current;\n    var spineCradleElement = spineCradleElementRef.current;\n    var scrollElement = spineCradleElement.parentElement;\n    var viewportElement = viewportData.elementref.current;\n    var headcontentlist = headModelContentRef.current;\n    var tailcontentlist = tailModelContentRef.current;\n    var crosscount = crosscountRef.current;\n    var indexoffset = contentlistcopy[0].props.index;\n    var scrollforward;\n    localintersections = cradlefunctions_1.isolateRelevantIntersections({\n      intersections: localintersections,\n      headcontent: headcontentlist,\n      tailcontent: tailcontentlist\n    });\n\n    if (localintersections.length == 0) {\n      // console.log('returning with localintersections.length == 0',localintersections.length)\n      return;\n    } // -- isolate forward and backward lists (happens with rapid scrolling changes)\n    //  then set scrollforward\n\n\n    var forwardcount = 0,\n        backwardcount = 0;\n\n    for (var intersectrecordindex = 0; intersectrecordindex < localintersections.length; intersectrecordindex++) {\n      var sampleEntry = localintersections[intersectrecordindex];\n\n      if (orientation == 'vertical') {\n        if (!sampleEntry.isIntersecting) {\n          forwardcount++;\n        } else {\n          backwardcount++;\n        }\n      }\n    } // console.log('forwardcount, backwardcount, localintersections',forwardcount, backwardcount, localintersections)\n\n\n    scrollforward = forwardcount > backwardcount;\n    var shiftitemcount = forwardcount - backwardcount;\n    var referencerowshift = Math.abs(Math.ceil(shiftitemcount / crosscount));\n    var referenceshift;\n    var referenceindex;\n    referenceshift = referencerowshift * crosscount;\n\n    if (scrollforward) {\n      referenceindex = ((_a = tailcontentlist[referenceshift]) === null || _a === void 0 ? void 0 : _a.props.index) || 0; // first time\n    } else {\n      referenceindex = ((_b = headcontentlist[headcontentlist.length - crosscount]) === null || _b === void 0 ? void 0 : _b.props.index) || 0; // 0 = first time\n\n      referenceindex -= referenceshift - crosscount;\n    }\n\n    var entryindexes = [];\n\n    for (var _i = 0, localintersections_1 = localintersections; _i < localintersections_1.length; _i++) {\n      var entry = localintersections_1[_i];\n      entryindexes.push(entry.target.dataset.index);\n    }\n\n    console.log.apply(console, __spreadArrays(['referenceindex, entryindexes', referenceindex], entryindexes)); // console.log('referenceindex, indexoffset',referenceindex, indexoffset)\n\n    if (referenceindex > listsize - 1) {\n      referenceindex = listsize - 1;\n    }\n\n    if (referenceindex < 0) {\n      referenceindex = 0;\n    } // console.log('forwardcount, backwardcount, shiftitemcount, referencerowshift, referenceshift, referenceindex,localintersections',\n    //     forwardcount, backwardcount, shiftitemcount, referencerowshift, referenceshift, referenceindex, localintersections)\n\n\n    if (shiftitemcount == 0) {\n      // console.log('EXIT shiftitemcount',shiftitemcount)\n      return;\n    }\n\n    shiftitemcount = Math.abs(shiftitemcount);\n    var shiftrowcount = Math.ceil(shiftitemcount / crosscount); // console.log('OPENING shiftrowcount, shiftitemcount',shiftrowcount, shiftitemcount)\n    // set pendingcontentoffset\n\n    var pendingcontentoffset;\n    var addcontentcount = 0; // next, verify number of rows to delete\n\n    var headindexchangecount, currentheadrowcount, viewportrowcount, tailindexchangecount, tailrowcount;\n    currentheadrowcount = Math.ceil(headModelContentRef.current.length / crosscount);\n    var cliprowcount = 0,\n        clipitemcount = 0;\n\n    if (scrollforward) {\n      // delete from head; add to tail; head is direction of stroll\n      if (currentheadrowcount + shiftrowcount > cradleProps.runwaycount) {\n        var rowdiff = currentheadrowcount + shiftrowcount - cradleProps.runwaycount;\n        cliprowcount = rowdiff;\n        clipitemcount = cliprowcount * crosscount;\n      }\n\n      addcontentcount = clipitemcount;\n      pendingcontentoffset = indexoffset + clipitemcount;\n      var proposedtailindex = pendingcontentoffset + contentlistcopy.length - 1;\n\n      if (proposedtailindex > listsize - 1) {\n        var diffitemcount = proposedtailindex - (listsize - 1); // items outside range\n\n        addcontentcount -= diffitemcount; // adjust the addcontent accordingly\n\n        var diffrows = Math.floor(diffitemcount / crosscount); // number of full rows to leave in place\n\n        var diffrowitems = diffrows * crosscount; // derived number of items to leave in place\n\n        clipitemcount -= diffrowitems; // apply adjustment to netshift\n        // pendingcontentoffset -= diffrowitems // apply adjustment to new offset for add\n\n        if (addcontentcount <= 0) {\n          // nothing to do\n          clipitemcount = addcontentcount = 0;\n        }\n      }\n\n      headindexchangecount = -clipitemcount;\n      tailindexchangecount = addcontentcount;\n    } else {\n      if (currentheadrowcount - shiftrowcount < cradleProps.runwaycount) {\n        addcontentcount = shiftrowcount * crosscount; // console.log('scrollback adjust for RUNWAY UNDERFLOW')\n\n        var rowdiff = cradleProps.runwaycount - (currentheadrowcount - shiftrowcount);\n        cliprowcount = rowdiff;\n        var tailrowitemcount = listsize % crosscount;\n\n        if (tailrowcount) {\n          clipitemcount = tailrowitemcount;\n\n          if (cliprowcount > 1) {\n            clipitemcount += (cliprowcount - 1) * crosscount;\n          }\n        } else {\n          clipitemcount = cliprowcount * crosscount;\n        }\n      }\n\n      pendingcontentoffset = indexoffset; // add to tail (opposite end of scroll direction), offset will remain the same\n\n      var proposedindexoffset = pendingcontentoffset - clipitemcount;\n\n      if (proposedindexoffset < 0) {\n        // console.log('scrollback adjust for TOP UNDERFLOW')\n        var diffitemcount = -proposedindexoffset;\n        var diffrows = Math.floor(diffitemcount / crosscount); // number of full rows to leave in place\n\n        var diffrowitems = diffrows * crosscount;\n        addcontentcount -= diffitemcount;\n        clipitemcount -= diffrowitems; // console.log('addcontentcount, clipitemcount, diffitemcount, diffrowitems',\n        //     addcontentcount, clipitemcount, diffitemcount, diffrowitems)\n\n        if (addcontentcount <= 0) {\n          clipitemcount = addcontentcount = 0;\n        }\n      }\n\n      headindexchangecount = addcontentcount;\n      tailindexchangecount = -clipitemcount; // console.log('SCROLLBACK scrollforward,referenceindex,headindexchangecount, tailindexchangecount',\n      //     scrollforward,referenceindex,headindexchangecount, tailindexchangecount)\n    } // console.log('getUIContentList headindexchangecount, tailindexchangecount, indexoffset',\n    //     headindexchangecount, tailindexchangecount, indexoffset)\n\n\n    var localContentList;\n\n    if (headindexchangecount || tailindexchangecount) {\n      // console.log('getUIContentList')\n      localContentList = cradlefunctions_1.getUIContentList({\n        localContentList: contentlistcopy,\n        headindexcount: headindexchangecount,\n        tailindexcount: tailindexchangecount,\n        indexoffset: indexoffset,\n        orientation: cradleProps.orientation,\n        cellHeight: cradleProps.cellHeight,\n        cellWidth: cradleProps.cellWidth,\n        observer: itemObserverRef.current,\n        crosscount: crosscount,\n        callbacks: callbacksRef.current,\n        getItem: cradleProps.getItem,\n        listsize: listsize,\n        placeholder: cradleProps.placeholder\n      });\n    } else {\n      localContentList = contentlistcopy;\n    } // headModelContentRef.current = localContentList\n\n\n    var _c = cradlefunctions_1.allocateContentList({\n      contentlist: localContentList,\n      runwaycount: cradleProps.runwaycount,\n      crosscount: crosscount,\n      referenceindex: referenceindex\n    }),\n        headcontent = _c[0],\n        tailcontent = _c[1]; // console.log('SPLIT headcontent count, tailcontent count, referenceindex, headcontent, tailcontent',\n    //     headcontent.length, tailcontent.length, referenceindex, headcontent, tailcontent)\n\n\n    modelContentRef.current = localContentList;\n    headViewContentRef.current = headModelContentRef.current = headcontent;\n    tailViewContentRef.current = tailModelContentRef.current = tailcontent; // console.log('viewport scrolltop BEFORE GETSPINEPOSREF', scrolltop, viewportElement.scrollTop)\n\n    var spineposref = cradlefunctions_1.getSpinePosRef({\n      scrollforward: scrollforward,\n      itemelements: itemElementsRef.current,\n      orientation: cradleProps.orientation,\n      spineElement: spineCradleElementRef.current,\n      referenceindex: referenceindex,\n      crosscount: crosscount,\n      gap: cradleProps.gap,\n      referenceshift: referenceshift\n    }); // console.log('spineposref',spineposref)\n    // console.log('spineposref,headcontent, tailcontent',spineposref,headcontent, tailcontent)\n\n    if (spineposref !== undefined) {\n      if (cradleProps.orientation == 'vertical') {\n        // spineCradleElementRef.current.style.transform = `translate(0px,${spineposref}px)`\n        spineCradleElementRef.current.style.top = spineposref + 'px';\n        spineCradleElementRef.current.style.left = 'auto';\n      } else {\n        // spineCradleElementRef.current.style.transform = `translate(${spineposref}px,0px)`\n        spineCradleElementRef.current.style.left = spineposref + 'px';\n        spineCradleElementRef.current.style.top = 'auto';\n      }\n    } // console.log('viewport scrolltop BEFORE CALLING updatescroll', scrolltop, viewportElement.scrollTop)\n\n\n    saveCradleState('updatescroll');\n  }, []); // End of IntersectionObserver support\n  // ========================================================================================\n  // -------------------------------[ Assembly of content]-----------------------------------\n  // ========================================================================================\n  // reset cradle, including allocation between head and tail parts of the cradle\n\n  var setCradleContent = react_1.useCallback(function (cradleState, referenceIndexData) {\n    var visibletargetindexoffset = referenceIndexData.index,\n        visibletargetscrolloffset = referenceIndexData.scrolloffset;\n    if (cradleState == 'reposition') visibletargetscrolloffset = 0;\n    var localContentList = []; // any duplicated items will be re-used by react\n\n    var _a = cradlefunctions_1.getContentListRequirements({\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      orientation: orientation,\n      runwaycount: runwaycount,\n      rowcount: cradlerowcount,\n      gap: gap,\n      visibletargetindexoffset: visibletargetindexoffset,\n      targetScrollOffset: visibletargetscrolloffset,\n      crosscount: crosscount,\n      listsize: listsize\n    }),\n        indexoffset = _a.indexoffset,\n        referenceoffset = _a.referenceoffset,\n        contentCount = _a.contentCount,\n        scrollblockoffset = _a.scrollblockoffset,\n        cradleoffset = _a.cradleoffset;\n\n    immediateReferenceIndexDataRef.current = {\n      index: referenceoffset,\n      scrolloffset: visibletargetscrolloffset\n    };\n\n    if (referenceIndexCallbackRef.current) {\n      var cstate = cradleState;\n      if (cstate == 'setreload') cstate = 'reload';\n      referenceIndexCallbackRef.current(immediateReferenceIndexDataRef.current.index, 'setCradleContent', cstate);\n    }\n\n    saveImmediateReferenceIndexData(immediateReferenceIndexDataRef.current); // consistent with onScroll\n\n    var childlist = cradlefunctions_1.getUIContentList({\n      indexoffset: indexoffset,\n      headindexcount: 0,\n      tailindexcount: contentCount,\n      orientation: orientation,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      localContentList: localContentList,\n      observer: itemObserverRef.current,\n      crosscount: crosscount,\n      callbacks: callbacksRef.current,\n      getItem: getItem,\n      listsize: listsize,\n      placeholder: placeholder\n    });\n\n    var _b = cradlefunctions_1.allocateContentList({\n      contentlist: childlist,\n      runwaycount: cradlePropsRef.current.runwaycount,\n      crosscount: crosscount,\n      referenceindex: 0\n    }),\n        headcontentlist = _b[0],\n        tailcontentlist = _b[1];\n\n    modelContentRef.current = childlist;\n    headModelContentRef.current = headcontentlist;\n    tailModelContentRef.current = tailcontentlist;\n\n    if (orientation == 'vertical') {\n      scrollPositionDataRef.current = {\n        property: 'scrollTop',\n        value: scrollblockoffset\n      };\n    } else {\n      // orientation = 'horizontal'\n      scrollPositionDataRef.current = {\n        property: 'scrollLeft',\n        value: scrollblockoffset\n      };\n    }\n  }, [getItem, listsize, placeholder, cellHeight, cellWidth, orientation, viewportheight, viewportwidth, runwaylength, runwaycount, gap, padding, crosscount, cradlerowcount]); // =====================================================================================\n  // ----------------------------------[ state management ]-------------------------------\n  // =====================================================================================\n\n  var scrollTimeridRef = react_1.useRef(null); // callback for scroll\n\n  var onScroll = react_1.useCallback(function () {\n    // console.log('onScroll scrollTop',viewportDataRef.current.elementref.current.scrollTop)\n    clearTimeout(scrollTimeridRef.current);\n    if (pauseScrollingEffectsRef.current) return;\n    var cradleState = cradlestateRef.current;\n\n    if (!viewportDataRef.current.isResizing) {\n      if (cradleState == 'ready' || cradleState == 'repositioning') {\n        immediateReferenceIndexDataRef.current = cradlefunctions_1.getReferenceIndexData({\n          viewportData: viewportDataRef.current,\n          cradlePropsRef: cradlePropsRef,\n          crosscountRef: crosscountRef\n        });\n        referenceIndexCallbackRef.current && referenceIndexCallbackRef.current(immediateReferenceIndexDataRef.current.index, 'scrolling', cradleState);\n        saveImmediateReferenceIndexData(immediateReferenceIndexDataRef.current);\n      }\n    }\n\n    if (!isCradleInViewRef.current && !pauseItemObserverRef.current && !viewportDataRef.current.isResizing && !(cradleState == 'resize') && !(cradleState == 'repositioning') && !(cradleState == 'reposition')) {\n      var rect = viewportDataRef.current.elementref.current.getBoundingClientRect();\n      var top_1 = rect.top,\n          right = rect.right,\n          bottom = rect.bottom,\n          left = rect.left;\n      var width = right - left,\n          height = bottom - top_1;\n      viewportDataRef.current.viewportDimensions = {\n        top: top_1,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      }; // update for scrolltracker\n\n      console.log('REPOSITIONING');\n      saveCradleState('repositioning');\n    }\n\n    scrollTimeridRef.current = setTimeout(function () {\n      // isScrollingRef.current = false;\n      var cradleState = cradlestateRef.current;\n\n      if (!viewportDataRef.current.isResizing) {\n        // (cradleState != 'repositioning') && \n        //     normalizeCradleAnchors(headCradleElementRef.current, cradlePropsRef.current.orientation)\n        var localrefdata = __assign({}, immediateReferenceIndexDataRef.current);\n\n        saveImmediateReferenceIndexData(localrefdata); // trigger re-run to capture end of scroll session values\n\n        masterReferenceIndexDataRef.current = localrefdata;\n      }\n\n      switch (cradleState) {\n        case 'repositioning':\n          {\n            callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n            pauseItemObserverRef.current = true;\n            saveCradleState('reposition');\n            break;\n          }\n      }\n    }, SCROLL_TIMEOUT_FOR_ONAFTERSCROLL);\n  }, []); // data for state processing\n\n  var callingCradleState = react_1.useRef(cradlestateRef.current);\n  var headlayoutDataRef = react_1.useRef(null);\n  var scrollPositionDataRef = react_1.useRef(null); // this is the core state engine\n  // useLayout for suppressing flashes\n\n  react_1.useLayoutEffect(function () {\n    var viewportData = viewportDataRef.current;\n\n    switch (cradlestate) {\n      case 'reload':\n        headModelContentRef.current = [];\n        tailModelContentRef.current = [];\n        saveCradleState('setreload');\n        break;\n\n      case 'scrollposition':\n        {\n          viewportData.elementref.current[scrollPositionDataRef.current.property] = scrollPositionDataRef.current.value;\n          saveCradleState('content');\n          break;\n        }\n\n      case 'updatescroll':\n        {\n          // scroll\n          saveCradleState('ready');\n          break;\n        }\n\n      case 'content':\n        {\n          headViewContentRef.current = headModelContentRef.current; // contentDataRef.current\n\n          tailViewContentRef.current = tailModelContentRef.current;\n          saveCradleState('normalize');\n          break;\n        }\n    }\n  }, [cradlestate]); // standard processing stages\n\n  react_1.useEffect(function () {\n    var viewportData = viewportDataRef.current;\n\n    switch (cradlestate) {\n      case 'setup':\n      case 'resize':\n      case 'pivot':\n      case 'setreload':\n      case 'reposition':\n        callingCradleState.current = cradlestate;\n        saveCradleState('settle');\n        break;\n\n      case 'settle':\n        {\n          setCradleContent(callingCradleState.current, callingReferenceIndexDataRef.current);\n          saveCradleState('scrollposition');\n          break;\n        }\n\n      case 'normalize':\n        {\n          setTimeout(function () {\n            // redundant scroll position to avoid accidental positioning at tail end of reposition\n            if (viewportData.elementref.current) {\n              // already unmounted if fails\n              viewportData.elementref.current[scrollPositionDataRef.current.property] = scrollPositionDataRef.current.value; // pick up position from setContent\n\n              masterReferenceIndexDataRef.current = __assign({}, immediateReferenceIndexDataRef.current);\n              pauseItemObserverRef.current && (pauseItemObserverRef.current = false);\n              pauseCradleIntersectionObserverRef.current && (pauseCradleIntersectionObserverRef.current = false);\n              pauseScrollingEffectsRef.current && (pauseScrollingEffectsRef.current = false);\n            }\n          }, 100);\n          saveCradleState('ready');\n          break;\n        }\n\n      case 'ready':\n        break;\n    }\n  }, [cradlestate]); // =============================================================================\n  // ------------------------------[ callbacks ]----------------------------------\n  // =============================================================================\n  // on host demand\n\n  var getVisibleList = react_1.useCallback(function () {\n    var itemlist = Array.from(itemElementsRef.current);\n    return cradlefunctions_1.calcVisibleItems(itemlist, viewportDataRef.current.elementref.current, headCradleElementRef.current, cradlePropsRef.current.orientation);\n  }, []);\n  var getContentList = react_1.useCallback(function () {\n    return Array.from(itemElementsRef.current);\n  }, []);\n  var reload = react_1.useCallback(function () {\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    pauseScrollingEffectsRef.current = true;\n    callingReferenceIndexDataRef.current = __assign({}, masterReferenceIndexDataRef.current);\n    saveCradleState('reload');\n  }, []);\n  var scrollToItem = react_1.useCallback(function (index) {\n    pauseItemObserverRef.current = true;\n    pauseCradleIntersectionObserverRef.current = true;\n    callingReferenceIndexDataRef.current = {\n      index: index,\n      scrolloffset: 0\n    };\n    saveCradleState('reposition');\n  }, []); // content item registration callback; called from item\n\n  var getItemElementData = react_1.useCallback(function (itemElementData, reportType) {\n    var index = itemElementData[0],\n        shellref = itemElementData[1];\n\n    if (reportType == 'register') {\n      itemElementsRef.current.set(index, shellref);\n    } else if (reportType == 'unregister') {\n      // console.log('UNREGISTERING',index)\n      itemElementsRef.current[\"delete\"](index);\n    }\n  }, []);\n  var callbacksRef = react_1.useRef({\n    getElementData: getItemElementData\n  }); // =============================================================================\n  // ------------------------------[ RENDER... ]----------------------------------\n  // =============================================================================\n  // let cradleHeadStyle = cradleHeadStyleRef.current\n  // let cradleTailStyle = cradleTailStyleRef.current\n  // let cradleSpineStyle = cradleSpineStyleRef.current\n\n  var scrollTrackerArgs = react_1.useMemo(function () {\n    return {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      offset: immediateReferenceIndexDataRef.current.index,\n      listsize: cradlePropsRef.current.listsize,\n      styles: cradlePropsRef.current.styles\n    };\n  }, [viewportDimensions, immediateReferenceIndexDataRef, cradlePropsRef]);\n  return react_1[\"default\"].createElement(react_1[\"default\"].Fragment, null, cradlestateRef.current == 'repositioning' ? react_1[\"default\"].createElement(scrolltracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.offset,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    style: cradleSpineStyle,\n    ref: spineCradleElementRef,\n    \"data-name\": 'spine'\n  }, react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradlestateRef.current != 'setup' ? headViewContentRef.current : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradlestateRef.current != 'setup' ? tailViewContentRef.current : null)));\n}; // Cradle\n\n\nexports[\"default\"] = Cradle;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGUudHN4PzE4M2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQ7O0FBRUE7O0FBYUE7O0FBRUEsSUFBTSxnQ0FBZ0MsR0FBRyxHQUF6Qzs7QUFFQSxJQUFNLE1BQU0sR0FBRyxTQUFULE1BQVMsQ0FBQyxFQUFELEVBY1Y7TUFiRyxZO01BQ0Esb0I7TUFDQSw4QjtNQUNBLDRCO01BQ0Esc0I7TUFDQSxrQjtNQUNBLDRCO01BQ0EsMEI7TUFDQSx3QjtNQUNBLG9CO01BQ0EsNEI7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FFRDs7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLElBQVAsQ0FBdkIsQ0FIQyxDQUdtQzs7QUFDcEMsZ0JBQWMsQ0FBQyxPQUFmLEdBQXlCLGdCQUFRO0FBQzdCLFdBQU87QUFDSCxTQUFHLEtBREE7QUFFSCxhQUFPLFNBRko7QUFHSCxrQkFBWSxjQUhUO0FBSUgsaUJBQVcsYUFKUjtBQUtILGNBQVEsVUFMTDtBQU1ILFlBQU0sUUFOSDtBQU9ILGlCQUFXLGFBUFI7QUFRSCxnQkFBVSxZQVJQO0FBU0gsZUFBUyxXQVROO0FBVUgsYUFBTyxTQVZKO0FBV0gsaUJBQVc7QUFYUixLQUFQO0FBWUYsR0FidUIsRUFhdEIsQ0FDQyxHQURELEVBRUMsT0FGRCxFQUdDLFlBSEQsRUFJQyxXQUpELEVBS0MsUUFMRCxFQU1DLE1BTkQsRUFPQyxXQVBELEVBUUMsVUFSRCxFQVNDLFNBVEQsRUFVQyxPQVZELEVBV0MsV0FYRCxDQWJzQixDQUF6QixDQUpDLENBK0JEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FB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QUNHLGlDQUFDLDBCQUFELEVBQWM7QUFDWCxPQUFHLEVBQUksaUJBQWlCLENBQUMsR0FEZDtBQUVYLFFBQUksRUFBSSxpQkFBaUIsQ0FBQyxJQUZmO0FBR1gsVUFBTSxFQUFJLGlCQUFpQixDQUFDLE1BSGpCO0FBSVgsWUFBUSxFQUFJLGlCQUFpQixDQUFDLFFBSm5CO0FBS1gsVUFBTSxFQUFJLGlCQUFpQixDQUFDO0FBTGpCLEdBQWQsQ0FESCxHQVFHLElBVkYsRUFXSDtBQUNJLFNBQUssRUFBSSxnQkFEYjtBQUVJLE9BQUcsRUFBSSxxQkFGWDtBQUVnQyxpQkFDaEI7QUFIaEIsS0FLSTtBQUFBLGlCQUVnQixNQUZoQjtBQUdJLE9BQUcsRUFBSSxvQkFIWDtBQUlJLFNBQUssRUFBSTtBQUpiLEtBUU0sY0FBYyxDQUFDLE9BQWYsSUFBMEIsT0FBM0IsR0FBb0Msa0JBQWtCLENBQUMsT0FBdkQsR0FBK0QsSUFScEUsQ0FMSixFQWdCSTtBQUFBLGlCQUVnQixNQUZoQjtBQUdJLE9BQUcsRUFBSSxvQkFIWDtBQUlJLFNBQUssRUFBSTtBQUpiLEtBUU0sY0FBYyxDQUFDLE9BQWYsSUFBMEIsT0FBM0IsR0FBb0Msa0JBQWtCLENBQUMsT0FBdkQsR0FBK0QsSUFScEUsQ0FoQkosQ0FYRyxDQUFQO0FBMENILENBcDBDRCxDLENBbzBDRTs7O0FBR0YscUJBQWUsTUFBZiIsImZpbGUiOiIuL3NyYy9jcmFkbGUudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gY3JhZGxlLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVE9ETzpcbiovXG5cbi8qXG4gICAgRGVzY3JpcHRpb25cbiAgICAtLS0tLS0tLS0tLVxuXG4gICAgVGhpcyBtb2R1bGUgaGFzIG9uZSBtYWluIGRlc2lnbiBwYXR0ZXJuOiB0aGUgYnV0dGVyZnVseSBwYXR0ZXJuIChteSBuYW1lKVxuXG4gICAgdGhlIGJ1dHRlcmZseSBwYXR0ZXJuOlxuICAgICAgICBUaGlzIHBhdHRlcm4gY29uc2lzdHMgb2YgdHdvIGNvbnRhaW5lcnMgZm9yIGl0ZW1zICh0aGUgXCJ3aW5nc1wiKSwgam9pbmVkIGJ5IGEgMC1sZW5ndGggZGl2ICh0aGUgXCJzcGluZVwiKS4gXG4gICAgICAgIFRoZSB3aW5ncyBhcmUgZml4ZWQgdG8gdGhlIHNwaW5lIHRocm91Z2ggdGhlIGJvdHRvbS9yaWdodCBwb3NpdGlvbiBzdHlsZSBvbiBvbmUgc2lkZSwgYW5kIHRvcC9sZWZ0IFxuICAgICAgICBvbiB0aGUgb3RoZXIuIFRodXMgYWRkaXRpb25zIG9yIGRlbGV0aW9ucyBlZmZlY3QgdGhlIGRpc3RhbnQgZW5kcyBvZiB0aGUgd2luZ3MgZnJvbSB0aGUgc3BpbmUgb24gZWFjaCBlbmQuIFxuICAgICAgICBBbGwgdGhyZWUgdG9nZXRoZXIgY29tcHJpc2UgdGhlIFwiY3JhZGxlXCIgb2YgaXRlbXMuIEFmdGVyIGEgY2hhbmdlIG9mIGNvbnRlbnQsIHRoZSBvbmx5IGNvbXBlbnNhdGluZyBcbiAgICAgICAgYWRqdXN0bWVudCByZXF1aXJlZCBpcyB0aGUgY2hhbmdlIG9mIHBvc2l0aW9uIG9mIHRoZSBzcGluZSBpbiByZWxhdGlvbiB0byB0aGUgdmlld3BvcnQuXG5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgVmlld3BvcnRDb250ZXh0IH0gZnJvbSAnLi92aWV3cG9ydCdcblxuaW1wb3J0IHVzZUlzTW91bnRlZCBmcm9tICdyZWFjdC1pcy1tb3VudGVkLWhvb2snXG5cbmltcG9ydCBSZXNpemVPYnNlcnZlclBvbHlmaWxsIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCdcblxuY29uc3QgTG9jYWxSZXNpemVPYnNlcnZlciA9IHdpbmRvd1snUmVzaXplT2JzZXJ2ZXInXSB8fCBSZXNpemVPYnNlcnZlclBvbHlmaWxsXG5cbmltcG9ydCB7IFxuICAgIHNldENyYWRsZUdyaWRTdHlsZXMsIFxuICAgIGdldFVJQ29udGVudExpc3QsIFxuICAgIGNhbGNWaXNpYmxlSXRlbXMsIFxuICAgIGdldFJlZmVyZW5jZUluZGV4RGF0YSxcbiAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyxcbiAgICBnZXRTcGluZVBvc1JlZixcbiAgICBpc29sYXRlUmVsZXZhbnRJbnRlcnNlY3Rpb25zLFxuICAgIC8vIG5vcm1hbGl6ZUNyYWRsZUFuY2hvcnMsXG4gICAgYWxsb2NhdGVDb250ZW50TGlzdCxcblxufSBmcm9tICcuL2NyYWRsZWZ1bmN0aW9ucydcblxuaW1wb3J0IFNjcm9sbFRyYWNrZXIgZnJvbSAnLi9zY3JvbGx0cmFja2VyJ1xuXG5jb25zdCBTQ1JPTExfVElNRU9VVF9GT1JfT05BRlRFUlNDUk9MTCA9IDIwMFxuXG5jb25zdCBDcmFkbGUgPSAoeyBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIHJ1bndheWxlbmd0aCxcbiAgICAgICAgcnVud2F5Y291bnQsIFxuICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgIG9mZnNldCwgXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgc3R5bGVzLFxuICAgIH0pID0+IHtcblxuICAgIC8vIGZ1bmN0aW9ucyBhbmQgc3R5bGVzIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIGNvbnN0IGNyYWRsZVByb3BzUmVmID0gdXNlUmVmKG51bGwpIC8vIGFjY2VzcyBieSBjbG9zdXJlc1xuICAgIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBydW53YXlsZW5ndGgsXG4gICAgICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgICAgICBvZmZzZXQsIFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICBwbGFjZWhvbGRlciwgXG4gICAgfX0sW1xuICAgICAgICBnYXAsIFxuICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgcnVud2F5bGVuZ3RoLFxuICAgICAgICBydW53YXljb3VudCwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgb2Zmc2V0LCBcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICBdKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIElOSVRJQUxJWkFUSU9OIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyB1dGlsaXRlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKVxuICAgIGNvbnN0IHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYgPSB1c2VSZWYoZnVuY3Rpb25zPy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKVxuXG4gICAgY29uc3QgaXRlbU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpIC8vIEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgY29uc3QgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBjcmFkbGVSZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgZGF0YSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3Qgdmlld3BvcnREYXRhID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG4gICAgY29uc3Qgdmlld3BvcnREYXRhUmVmID0gdXNlUmVmKG51bGwpXG4gICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQgPSB2aWV3cG9ydERhdGFcblxuICAgIGNvbnN0IFtjcmFkbGVzdGF0ZSwgc2F2ZUNyYWRsZVN0YXRlXSA9IHVzZVN0YXRlKCdzZXR1cCcpXG4gICAgY29uc3QgY3JhZGxlc3RhdGVSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzXG4gICAgY3JhZGxlc3RhdGVSZWYuY3VycmVudCA9IGNyYWRsZXN0YXRlXG5cbiAgICAvLyBjb25zb2xlLmxvZygncnVubmluZyBjcmFkbGUgd2l0aCBzdGF0ZScsY3JhZGxlc3RhdGUpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRyb2wgdmFyaWFibGVzIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgcGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZiA9IHVzZVJlZihmYWxzZSlcblxuICAgIC8vIHRvIGNvbnRyb2wgYXBwZWFyYW5jZSBvZiByZXBvc2l0aW9uaW5nIG1vZGVcbiAgICBjb25zdCBpc1RhaWxDcmFkbGVJblZpZXdSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0hlYWRDcmFkbGVJblZpZXdSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0NyYWRsZUluVmlld1JlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluaXRpYWxpemF0aW9uIGVmZmVjdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL2luaXRpYWxpemUgaG9zdCBmdW5jdGlvbnMgcHJvcGVydGllc1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdzY3JvbGxUb0l0ZW0nKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnNjcm9sbFRvSXRlbSA9IHNjcm9sbFRvSXRlbVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdnZXRWaXNpYmxlTGlzdCcpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMuZ2V0VmlzaWJsZUxpc3QgPSBnZXRWaXNpYmxlTGlzdFxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdnZXRDb250ZW50TGlzdCcpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnMuZ2V0Q29udGVudExpc3QgPSBnZXRDb250ZW50TGlzdFxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChmdW5jdGlvbnM/Lmhhc093blByb3BlcnR5KCdyZWxvYWQnKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnJlbG9hZCA9IHJlbG9hZFxuICAgICAgICB9XG5cbiAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50ID0gZnVuY3Rpb25zPy5yZWZlcmVuY2VJbmRleENhbGxiYWNrXG5cbiAgICB9LFtmdW5jdGlvbnNdKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc2Nyb2xsIGxpc3RlbmVyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHZpZXdwb3J0RGF0YSA9IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50XG4gICAgICAgIHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxvblNjcm9sbClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50ICYmIHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxvblNjcm9sbClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgcmVjb25maWd1cmF0aW9uIGVmZmVjdHMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdHJpZ2dlciByZXNpemluZyBiYXNlZCBvbiB2aWV3cG9ydCBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmICh2aWV3cG9ydERhdGEuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICAvLyBlbnRlciByZXNpemluZyBtb2RlXG4gICAgICAgICAgICBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSB7Li4ubWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnR9XG5cbiAgICAgICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgICAgICBwYXVzZVNjcm9sbGluZ0VmZmVjdHNSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVzaXppbmcnKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wbGV0ZSByZXNpemluZyBtb2RlXG4gICAgICAgIGlmICghdmlld3BvcnREYXRhLmlzUmVzaXppbmcgJiYgKGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgPT0gJ3Jlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXNpemUnKVxuXG4gICAgICAgIH1cblxuICAgIH0sW3ZpZXdwb3J0RGF0YS5pc1Jlc2l6aW5nXSlcblxuICAgIC8vIHJlbG9hZCBmb3IgY2hhbmdlZCBwYXJhbWV0ZXJzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gey4uLm1hc3RlclJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50fVxuXG4gICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgLy8gdHJpZ2dlciBwaXZvdCBvbiBjaGFuZ2UgaW4gb3JpZW50YXRpb25cbiAgICB1c2VFZmZlY3QoKCk9PiB7XG5cbiAgICAgICAgaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gW11cbiAgICAgICAgdGFpbE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gW11cblxuICAgICAgICBpZiAoY3JhZGxlc3RhdGVSZWYuY3VycmVudCAhPSAnc2V0dXAnKSB7XG5cbiAgICAgICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5tYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3Bpdm90JylcblxuICAgICAgICB9XG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgT1BFUkFUSU9OIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNlc3Npb24gZGF0YSBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tIGN1cnJlbnQgbG9jYXRpb24gLS0gZmlyc3QgaGVhZCB2aXNpYmxlIGl0ZW0gLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgW2ltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YSwgc2F2ZUltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YV0gPSB1c2VTdGF0ZSh7XG4gICAgICAgIGluZGV4Ok1hdGgubWluKG9mZnNldCwobGlzdHNpemUgLSAxKSkgfHwgMCxcbiAgICAgICAgc2Nyb2xsb2Zmc2V0OjBcbiAgICB9KVxuICAgIGNvbnN0IGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXNcbiAgICBpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVxuICAgIGNvbnN0IG1hc3RlclJlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEpIC8vIGNhcHR1cmUgZm9yIHN0YXRlIHJlc2V0Q29udGVudCBvcGVyYXRpb25zXG4gICAgY29uc3QgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZiA9IHVzZVJlZihpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEpIC8vIGFudGljaXBhdGUgcmVwb3NpdGlvblxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIGRhdGEgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNyYWRsZSBidXR0ZXJmbHkgaHRtbCBjb21wb25lbnRzXG4gICAgY29uc3QgaGVhZENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNwaW5lQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gZGF0YSBtb2RlbFxuICAgIGNvbnN0IG1vZGVsQ29udGVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGhlYWRNb2RlbENvbnRlbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsTW9kZWxDb250ZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyB2aWV3IG1vZGVsXG4gICAgY29uc3QgaGVhZFZpZXdDb250ZW50UmVmID0gdXNlUmVmKFtdKVxuICAgIGNvbnN0IHRhaWxWaWV3Q29udGVudFJlZiA9IHVzZVJlZihbXSlcblxuICAgIGNvbnN0IGl0ZW1FbGVtZW50c1JlZiA9IHVzZVJlZihuZXcgTWFwKCkpIC8vIGl0ZW1zIHJlZ2lzdGVyIHRoZWlyIGVsZW1lbnRcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIGNvbmZpZ3VyYXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdmlld3BvcnREaW1lbnNpb25zLCBjcm9zc2NvdW50LCByb3djb3VudFxuXG4gICAgY29uc3QgeyB2aWV3cG9ydERpbWVuc2lvbnMgfSA9IHZpZXdwb3J0RGF0YVxuXG4gICAgbGV0IHsgaGVpZ2h0OnZpZXdwb3J0aGVpZ2h0LHdpZHRoOnZpZXdwb3J0d2lkdGggfSA9IHZpZXdwb3J0RGltZW5zaW9uc1xuICAgIFxuICAgIGNvbnN0IGNyb3NzY291bnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBsZXQgY3Jvc3Njb3VudFxuICAgICAgICBsZXQgc2l6ZSA9IChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpP3ZpZXdwb3J0aGVpZ2h0OnZpZXdwb3J0d2lkdGhcbiAgICAgICAgbGV0IGNyb3NzTGVuZ3RoID0gKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk/Y2VsbEhlaWdodDpjZWxsV2lkdGhcblxuICAgICAgICBsZXQgbGVuZ3RoZm9yY2FsYyA9IHNpemUgLSAocGFkZGluZyAqIDIpICsgZ2FwIC8vIGxlbmd0aCBvZiB2aWV3cG9ydFxuICAgICAgICBsZXQgdGlsZWxlbmd0aGZvcmNhbGMgPSBjcm9zc0xlbmd0aCArIGdhcFxuICAgICAgICB0aWxlbGVuZ3RoZm9yY2FsYyA9IE1hdGgubWluKHRpbGVsZW5ndGhmb3JjYWxjLGxlbmd0aGZvcmNhbGMpIC8vIHJlc3VsdCBjYW5ub3QgYmUgbGVzcyB0aGFuIDFcbiAgICAgICAgY3Jvc3Njb3VudCA9IE1hdGguZmxvb3IobGVuZ3RoZm9yY2FsYy8odGlsZWxlbmd0aGZvcmNhbGMpKVxuICAgICAgICByZXR1cm4gY3Jvc3Njb3VudFxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgXSlcblxuICAgIGNvbnN0IGNyb3NzY291bnRSZWYgPSB1c2VSZWYoY3Jvc3Njb3VudCkgLy8gZm9yIGVhc3kgcmVmZXJlbmNlIGJ5IG9ic2VydmVyXG4gICAgY3Jvc3Njb3VudFJlZi5jdXJyZW50ID0gY3Jvc3Njb3VudCAvLyBhdmFpbGFibGUgZm9yIG9ic2VydmVyIGNsb3N1cmVcblxuICAgIGNvbnN0IFtjcmFkbGVyb3djb3VudCx2aWV3cG9ydHJvd2NvdW50XSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVuZ3RoLCBjZWxsTGVuZ3RoXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB2aWV3cG9ydExlbmd0aCA9IHZpZXdwb3J0aGVpZ2h0XG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSB2aWV3cG9ydHdpZHRoXG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoXG4gICAgICAgIH1cblxuICAgICAgICBjZWxsTGVuZ3RoICs9IGdhcFxuXG4gICAgICAgIGxldCB2aWV3cG9ydHJvd2NvdW50ID0gTWF0aC5jZWlsKHZpZXdwb3J0TGVuZ3RoL2NlbGxMZW5ndGgpXG4gICAgICAgIGxldCBjcmFkbGVyb3djb3VudCA9IHZpZXdwb3J0cm93Y291bnQgKyAocnVud2F5Y291bnQgKiAyKVxuICAgICAgICBsZXQgaXRlbWNvdW50ID0gY3JhZGxlcm93Y291bnQgKiBjcm9zc2NvdW50XG4gICAgICAgIGlmIChpdGVtY291bnQgPiBsaXN0c2l6ZSkge1xuICAgICAgICAgICAgaXRlbWNvdW50ID0gbGlzdHNpemVcbiAgICAgICAgICAgIGNyYWRsZXJvd2NvdW50ID0gTWF0aC5jZWlsKGl0ZW1jb3VudC9jcm9zc2NvdW50KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3JhZGxlcm93Y291bnQsIHZpZXdwb3J0cm93Y291bnRdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgZ2FwLCBcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIC8vIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgXSlcblxuICAgIGNvbnN0IGNyYWRsZXJvd2NvdW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY3JhZGxlcm93Y291bnRSZWYuY3VycmVudCA9IGNyYWRsZXJvd2NvdW50XG4gICAgY29uc3Qgdmlld3BvcnRyb3djb3VudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIHZpZXdwb3J0cm93Y291bnRSZWYuY3VycmVudCA9IHZpZXdwb3J0cm93Y291bnRcblxuICAgIC8vIGJhc2Ugc3R5bGVzXG4gICAgbGV0IGNyYWRsZUhlYWRTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gZ2FwICsgJ3B4J1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSAwXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICByaWdodCA9IGdhcCArICdweCdcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4ue1xuXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGFsaWduQ29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHRvcCxcblxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsLi4uc3R5bGVzPy5jcmFkbGV9XG5cbiAgICB9LFtcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgIF0pXG5cbiAgICBsZXQgY3JhZGxlVGFpbFN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSAnYXV0bydcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSAwXG4gICAgICAgICAgICByaWdodCA9ICdyaWdodCdcbiAgICAgICAgICAgIHRvcCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4ue1xuXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ2FwICsgJ3B4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcgKyAncHgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6J3N0YXJ0JyxcbiAgICAgICAgICAgIGFsaWduQ29udGVudDonc3RhcnQnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcblxuICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsLi4uc3R5bGVzPy5jcmFkbGV9XG5cbiAgICB9LFtcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgIF0pXG5cbiAgICBsZXQgY3JhZGxlU3BpbmVTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGxldCBwYWRkaW5neCwgcGFkZGluZ3ksIHRvcCwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBwYWRkaW5neCA9IDBcbiAgICAgICAgICAgIHBhZGRpbmd5ID0gcGFkZGluZ1xuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBsZWZ0ID0gJ2F1dG8nXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcGFkZGluZ3ggPSBwYWRkaW5nXG4gICAgICAgICAgICBwYWRkaW5neSA9IDBcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nICsgJ3B4J1xuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybTpgdHJhbnNsYXRlKCR7cGFkZGluZ3h9cHgsJHtwYWRkaW5neX1weClgXG5cbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG5cbiAgICB9LFtcblxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBvcmllbnRhdGlvbixcblxuICAgIF0pXG5cbiAgICAvLyBlbmhhbmNlZCBzdHlsZXMgZm9yIGdyaWRcbiAgICBjb25zdCBbaGVhZHN0eWxlLCB0YWlsc3R5bGUsIHNwaW5lc3R5bGVdID0gdXNlTWVtbygoKT0+IHtcblxuICAgICAgICAvLyBtZXJnZSBiYXNlIHN0eWxlIGFuZCByZXZpc2lvbnMgKGJ5IG9ic2VydmVyKVxuICAgICAgICBsZXQgaGVhZENyYWRsZVN0eWxlczpSZWFjdC5DU1NQcm9wZXJ0aWVzID0gey4uLmNyYWRsZUhlYWRTdHlsZX1cbiAgICAgICAgbGV0IHRhaWxDcmFkbGVTdHlsZXM6UmVhY3QuQ1NTUHJvcGVydGllcyA9IHsuLi5jcmFkbGVUYWlsU3R5bGV9XG4gICAgICAgIGxldCBbaGVhZHN0eWxlcywgdGFpbHN0eWxlc10gPSBzZXRDcmFkbGVHcmlkU3R5bGVzKHtcblxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgaGVhZENyYWRsZVN0eWxlcywgXG4gICAgICAgICAgICB0YWlsQ3JhZGxlU3R5bGVzLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICAgICAgICAgIHZpZXdwb3J0d2lkdGgsIFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IHRvcCwgbGVmdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdG9wID0gcGFkZGluZyArICdweCdcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgbGVmdCA9ICdwYWRkaW5nJyArICdweCdcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzcGluZXN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtOmB0cmFuc2xhdGUoMHB4LCR7cGFkZGluZ31weClgXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc1xuXG4gICAgICAgIHJldHVybiBbaGVhZHN0eWxlcywgdGFpbHN0eWxlcywgc3BpbmVzdHlsZV1cblxuICAgIH0sW1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIGNyb3NzY291bnQsXG5cbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZVNwaW5lU3R5bGVcblxuICAgICAgXSlcblxuICAgIGNyYWRsZUhlYWRTdHlsZSA9IGhlYWRzdHlsZVxuICAgIGNyYWRsZVRhaWxTdHlsZSA9IHRhaWxzdHlsZVxuICAgIGNyYWRsZVNwaW5lU3R5bGUgPSBzcGluZXN0eWxlXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbnRlcnNlY3Rpb25PYnNlcnZlciBzdXBwb3J0XS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qXG4gICAgICAgIFRoZXJlIGFyZSB0d28gaW50ZXJlY3Rpb24gb2JzZXJ2ZXJzLCBvbmUgZm9yIHRoZSBjcmFkbGUsIGFuZCBhbm90aGVyIGZvciBpdGVtU2hlbGxzOyBcbiAgICAgICAgICAgIGJvdGggYWdhaW5zdCB0aGUgdmlld3BvcnQuXG4gICAgICAgIFRoZXJlIGlzIGFsc28gYSByZXNpemUgb2JzZXJ2ZXIgZm9yIHRoZSBjcmFkbGUgd2luZ3MsIHRvIHJlc3BvbmQgdG8gc2l6ZSBjaGFuZ2VzIG9mIFxuICAgICAgICAgICAgdmFyaWFibGUgY2VsbHMuXG4gICAgKi8gICAgXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY3JhZGxlIG9ic2VydmVycyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHNldCB1cCBjcmFkbGUgcmVzaXplb2JzZXJ2ZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyXG4gICAgICAgIGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgTG9jYWxSZXNpemVPYnNlcnZlcihjcmFkbGVyZXNpemVvYnNlcnZlcmNhbGxiYWNrKVxuXG4gICAgICAgIGNyYWRsZVJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQub2JzZXJ2ZShoZWFkQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50KVxuICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUodGFpbENyYWRsZUVsZW1lbnRSZWYuY3VycmVudClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBjcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBjcmFkbGVyZXNpemVvYnNlcnZlcmNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpID0+IHtcblxuICAgICAgICBpZiAocGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlclJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JhZGxlIHJlc2l6ZSBlbnRyaWVzJyxlbnRyaWVzKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIHRoaXMgc2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvZiB0aGUgY3JhZGxlIGFnYWluc3QgdGhlIHZpZXdwb3J0LiBXaGVuIHRoZVxuICAgIC8vIGNyYWRsZSBnb2VzIG91dCBvZiB0aGUgb2JzZXJ2ZXIgc2NvcGUsIHRoZSBcInJlcG9zaXRpb25pbmdcIiBjcmFkbGUgc3RhdGUgaXMgdHJpZ2dlcmQuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcblxuICAgICAgICAgICAgY3JhZGxlaW50ZXJzZWN0aW9ub2JzZXJ2ZXJjYWxsYmFjayxcbiAgICAgICAgICAgIHtyb290OnZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuXG4gICAgICAgIClcblxuICAgICAgICBjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoaGVhZENyYWRsZUVsZW1lbnRSZWYuY3VycmVudClcbiAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudC5vYnNlcnZlKHRhaWxDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudC5kaXNjb25uZWN0KClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgY29uc3QgY3JhZGxlaW50ZXJzZWN0aW9ub2JzZXJ2ZXJjYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc1tpXVxuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldC5kYXRhc2V0Lm5hbWUgPT0gJ2hlYWQnKSB7XG4gICAgICAgICAgICAgICAgaXNIZWFkQ3JhZGxlSW5WaWV3UmVmLmN1cnJlbnQgPSBlbnRyeS5pc0ludGVyc2VjdGluZ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1RhaWxDcmFkbGVJblZpZXdSZWYuY3VycmVudCA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc0NyYWRsZUluVmlld1JlZi5jdXJyZW50ID0gKGlzSGVhZENyYWRsZUluVmlld1JlZi5jdXJyZW50IHx8IGlzVGFpbENyYWRsZUluVmlld1JlZi5jdXJyZW50KVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBpdGVtIHNoZWxsIG9ic2VydmVyIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgICAgVGhlIGNyYWRsZSBjb250ZW50IGlzIGRyaXZlbiBieSBub3RpZmljYXRpb25zIGZyb20gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLlxuICAgICAgICAtIGFzIHRoZSB1c2VyIHNjcm9sbHMgdGhlIGNyYWRsZSwgd2hpY2ggaGFzIGEgcnVud2F5Y291bnQgYXQgYm90aCB0aGUgbGVhZGluZ1xuICAgICAgICAgICAgYW5kIHRyYWlsaW5nIGVkZ2VzLCBpdGVtU2hlbGxzIHNjcm9sbCBpbnRvIG9yIG91dCBvZiB0aGUgc2NvcGUgb2YgdGhlIG9ic2VydmVyIFxuICAgICAgICAgICAgKGRlZmluZWQgYnkgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgdmlld3BvcnQgKyB0aGUgbGVuZ3RocyBvZiB0aGUgcnVud2F5cykuIFRoZSBvYnNlcnZlclxuICAgICAgICAgICAgbm90aWZpZXMgdGhlIGFwcCAodGhyb3VnaCBpdGVtb2JzZXJ2ZXJjYWxsYmFjaygpIGJlbG93KSBhdCB0aGUgY3Jvc3NpbmdzIG9mIHRoZSBpdGVtc2hlbGxzIFxuICAgICAgICAgICAgb2YgdGhlIGRlZmluZWQgb2JzZXJ2ZXIgY3JhZGxlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgICAgIFRoZSBuby1sb25nZXItaW50ZXJzZWN0aW5nIG5vdGlmaWNhdGlvbnMgdHJpZ2dlciBkcm9wcGluZyBvZiB0aGF0IG51bWJlciBvZiBhZmZlY3RlZCBpdGVtcyBmcm9tIFxuICAgICAgICAgICAgdGhlIGNyYWRsZSBjb250ZW50bGlzdC4gVGhlIGRyb3BwaW5nIG9mIGl0ZW1zIGZyb20gdGhlIHRyYWlsaW5nIGVuZCBvZiB0aGUgY29udGVudCBsaXN0XG4gICAgICAgICAgICB0cmlnZ2VycyB0aGUgYWRkaXRpb24gb2YgYW4gZXF1YWwgbnVtYmVyIG9mIGl0ZW1zIGF0IHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIGNyYWRsZSBjb250ZW50LlxuXG4gICAgICAgICAgICBUZWNobmljYWxseSwgdGhlIG9wcG9zaXRlIGVuZCBwb3NpdGlvbiBzcGVjIGlzIHNldCAodG9wIG9yIGxlZnQgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uKSwgXG4gICAgICAgICAgICBhbmQgdGhlIG1hdGNoaW5nIGVuZCBwb3NpdGlvbiBzcGVjIGlzIHNldCB0byAnYXV0bycgd2hlbiBpdGVtcyBhcmUgYWRkZWQuIFRoaXMgY2F1c2VzIGl0ZW1zIHRvIGJlIFxuICAgICAgICAgICAgXCJzcXVlZXplZFwiIGludG8gdGhlIGxlYWRpbmcgb3IgdHJhaWxpbmcgZW5kcyBvZiB0aGUgdWkgY29udGVudCAob3V0IG9mIHZpZXcpIGFzIGFwcHJvcHJpYXRlLlxuXG4gICAgICAgICAgICBUaGVyZSBhcmUgZXhjZXB0aW9ucyBmb3Igc2V0dXAgYW5kIGVkZ2UgY2FzZXMuXG4gICAgKi9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgaXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG5cbiAgICAgICAgICAgIGl0ZW1vYnNlcnZlcmNhbGxiYWNrLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvb3Q6dmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LCBcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6LjksXG4gICAgICAgICAgICAgICAgLy8gcm9vdE1hcmdpbjonNTBweCdcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGl0ZW1PYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKVxuXG4gICAgICAgIH1cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyB0aGUgYXN5bmMgY2FsbGJhY2sgZnJvbSBJbnRlcnNlY3Rpb25PYnNlcnZlci5cbiAgICBjb25zdCBpdGVtb2JzZXJ2ZXJjYWxsYmFjayA9IHVzZUNhbGxiYWNrKChlbnRyaWVzKT0+e1xuXG4gICAgICAgIGlmIChwYXVzZUl0ZW1PYnNlcnZlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmV0dXJuaW5nIHdpdGggcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCcscGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaXNNb3VudGVkKCkgJiYgYWRqdXN0Y3JhZGxlZW50cmllcyhlbnRyaWVzKVxuXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgY2FzZSB3aGVyZSBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkIHNjcm9sbFxuICAgIC8vIGFkanVzdCBzY3JvbGwgY29udGVudDpcbiAgICAvLyAxLnNoaWZ0LCAyLmNsaXAsIGFuZCAzLmFkZCBjbGlwIGFtb3VudCBhdCBvdGhlciBlbmRcbiAgICBjb25zdCBhZGp1c3RjcmFkbGVlbnRyaWVzID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpPT57XG5cbiAgICAgICAgbGV0IHNwaW5lc2lkZWludGVyc2VjdGlvbnNcblxuICAgICAgICBsZXQgbG9jYWxlbnRyaWVzID0gWy4uLmVudHJpZXNdXG5cbiAgICAgICAgLy8gaWYgKGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgPT0gJ3JlYWR5JyB8fCBjcmFkbGVzdGF0ZVJlZi5jdXJyZW50ID09ICd1cGRhdGVzY3JvbGwnKSB7XG5cbiAgICAgICAgLy8gICAgIGxldCBvcmllbnRhdGlvbiA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cblxuICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coJ09CU0VSVkVSIGVudHJpZXMnLGVudHJpZXMpXG5cbiAgICAgICAgLy8gICAgIHNwaW5lc2lkZWludGVyc2VjdGlvbnMgPSBsb2NhbGVudHJpZXMuZmlsdGVyKGVudHJ5ID0+IHtcblxuICAgICAgICAvLyAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgLy8gICAgICAgICAgICAvLyBUT0RPOiBiZSBzdXJlIHRoaXMgd29ya3MgaW4gbmFycm93IHZpZXdwb3J0XG4gICAgICAgIC8vICAgICAgICAgICAgLy8gZm9yIGNsb3NlciB0byB0aGUgc3BpbmUsIGJvdHRvbSBpcyBjbG9zZXIgdG8gdGhlIHRvcCB0aGFuIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIC8vICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyggZW50cnkucm9vdEJvdW5kcy50b3AgLSBlbnRyeS5pbnRlcnNlY3Rpb25SZWN0LmJvdHRvbSApIDwgXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIE1hdGguYWJzKGVudHJ5LnJvb3RCb3VuZHMuYm90dG9tIC0gZW50cnkuaW50ZXJzZWN0aW9uUmVjdC5ib3R0b20pKSAvLyAmJlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAvLyBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyAhPSAwXG5cbiAgICAgICAgLy8gICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyggZW50cnkucm9vdEJvdW5kcy5sZWZ0IC0gZW50cnkuaW50ZXJzZWN0aW9uUmVjdC5yaWdodCApIDwgXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIE1hdGguYWJzKGVudHJ5LnJvb3RCb3VuZHMucmlnaHQgLSBlbnRyeS5pbnRlcnNlY3Rpb25SZWN0LnJpZ2h0KSkgLy8mJlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAvLyBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyAhPSAwXG5cbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9KVxuXG4gICAgICAgIC8vIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gICAgIHJldHVyblxuICAgICAgICBcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzcGluZXNpZGVpbnRlcnNlY3Rpb25zLmxlbmd0aCcsc3BpbmVzaWRlaW50ZXJzZWN0aW9ucy5sZW5ndGgsc3BpbmVzaWRlaW50ZXJzZWN0aW9ucylcblxuICAgICAgICBzcGluZXNpZGVpbnRlcnNlY3Rpb25zID0gbG9jYWxlbnRyaWVzXG5cbiAgICAgICAgLy8gaWYgKHNwaW5lc2lkZWludGVyc2VjdGlvbnMubGVuZ3RoID09IDApIHJldHVyblxuXG4gICAgICAgIGxldCB2aWV3cG9ydERhdGEgPSB2aWV3cG9ydERhdGFSZWYuY3VycmVudFxuICAgICAgICBsZXQgbG9jYWxpbnRlcnNlY3Rpb25zID0gWy4uLnNwaW5lc2lkZWludGVyc2VjdGlvbnNdXG4gICAgICAgIGxldCBjb250ZW50bGlzdGNvcHkgPSBbLi4ubW9kZWxDb250ZW50UmVmLmN1cnJlbnRdXG4gICAgICAgIGxldCBjcmFkbGVQcm9wcyA9IGNyYWRsZVByb3BzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgbGlzdHNpemUgPSBjcmFkbGVQcm9wcy5saXN0c2l6ZVxuXG4gICAgICAgIGxldCBoZWFkQ3JhZGxlRWxlbWVudCA9IGhlYWRDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgbGV0IHRhaWxDcmFkbGVFbGVtZW50ID0gdGFpbENyYWRsZUVsZW1lbnRSZWYuY3VycmVudFxuICAgICAgICBsZXQgc3BpbmVDcmFkbGVFbGVtZW50ID0gc3BpbmVDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgbGV0IHNjcm9sbEVsZW1lbnQgPSBzcGluZUNyYWRsZUVsZW1lbnQucGFyZW50RWxlbWVudFxuICAgICAgICBsZXQgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudFxuXG4gICAgICAgIGxldCBoZWFkY29udGVudGxpc3QgPSBoZWFkTW9kZWxDb250ZW50UmVmLmN1cnJlbnRcbiAgICAgICAgbGV0IHRhaWxjb250ZW50bGlzdCA9IHRhaWxNb2RlbENvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICBsZXQgY3Jvc3Njb3VudCA9IGNyb3NzY291bnRSZWYuY3VycmVudFxuXG4gICAgICAgIGxldCBpbmRleG9mZnNldCA9IGNvbnRlbnRsaXN0Y29weVswXS5wcm9wcy5pbmRleFxuXG4gICAgICAgIGxldCBzY3JvbGxmb3J3YXJkXG5cbiAgICAgICAgbG9jYWxpbnRlcnNlY3Rpb25zID0gaXNvbGF0ZVJlbGV2YW50SW50ZXJzZWN0aW9ucyh7XG5cbiAgICAgICAgICAgIGludGVyc2VjdGlvbnM6bG9jYWxpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgICAgaGVhZGNvbnRlbnQ6aGVhZGNvbnRlbnRsaXN0LCBcbiAgICAgICAgICAgIHRhaWxjb250ZW50OnRhaWxjb250ZW50bGlzdCxcblxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChsb2NhbGludGVyc2VjdGlvbnMubGVuZ3RoID09IDApIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JldHVybmluZyB3aXRoIGxvY2FsaW50ZXJzZWN0aW9ucy5sZW5ndGggPT0gMCcsbG9jYWxpbnRlcnNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLSBpc29sYXRlIGZvcndhcmQgYW5kIGJhY2t3YXJkIGxpc3RzIChoYXBwZW5zIHdpdGggcmFwaWQgc2Nyb2xsaW5nIGNoYW5nZXMpXG4gICAgICAgIC8vICB0aGVuIHNldCBzY3JvbGxmb3J3YXJkXG4gICAgICAgIGxldCBmb3J3YXJkY291bnQgPSAwLCBiYWNrd2FyZGNvdW50ID0gMFxuICAgICAgICBmb3IgKGxldCBpbnRlcnNlY3RyZWNvcmRpbmRleCA9IDA7IGludGVyc2VjdHJlY29yZGluZGV4IDwgbG9jYWxpbnRlcnNlY3Rpb25zLmxlbmd0aDsgaW50ZXJzZWN0cmVjb3JkaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGxldCBzYW1wbGVFbnRyeSA9IGxvY2FsaW50ZXJzZWN0aW9uc1tpbnRlcnNlY3RyZWNvcmRpbmRleF1cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNhbXBsZUVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRjb3VudCsrXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja3dhcmRjb3VudCsrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3J3YXJkY291bnQsIGJhY2t3YXJkY291bnQsIGxvY2FsaW50ZXJzZWN0aW9ucycsZm9yd2FyZGNvdW50LCBiYWNrd2FyZGNvdW50LCBsb2NhbGludGVyc2VjdGlvbnMpXG4gICAgICAgIHNjcm9sbGZvcndhcmQgPSAoZm9yd2FyZGNvdW50ID4gYmFja3dhcmRjb3VudClcbiAgICAgICAgbGV0IHNoaWZ0aXRlbWNvdW50ID0gZm9yd2FyZGNvdW50IC0gYmFja3dhcmRjb3VudFxuICAgICAgICBsZXQgcmVmZXJlbmNlcm93c2hpZnQgPSBNYXRoLmFicyhNYXRoLmNlaWwoc2hpZnRpdGVtY291bnQvY3Jvc3Njb3VudCkpXG4gICAgICAgIGxldCByZWZlcmVuY2VzaGlmdFxuXG4gICAgICAgIGxldCByZWZlcmVuY2VpbmRleFxuICAgICAgICByZWZlcmVuY2VzaGlmdCA9IHJlZmVyZW5jZXJvd3NoaWZ0ICogY3Jvc3Njb3VudFxuICAgICAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuXG4gICAgICAgICAgICByZWZlcmVuY2VpbmRleCA9IHRhaWxjb250ZW50bGlzdFtyZWZlcmVuY2VzaGlmdF0/LnByb3BzLmluZGV4IHx8IDAgLy8gZmlyc3QgdGltZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJlZmVyZW5jZWluZGV4ID0gaGVhZGNvbnRlbnRsaXN0WyhoZWFkY29udGVudGxpc3QubGVuZ3RoIC0gY3Jvc3Njb3VudCldPy5wcm9wcy5pbmRleCB8fCAwIC8vIDAgPSBmaXJzdCB0aW1lXG4gICAgICAgICAgICByZWZlcmVuY2VpbmRleCAtPSByZWZlcmVuY2VzaGlmdCAtIGNyb3NzY291bnRcblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVudHJ5aW5kZXhlcyA9IFtdXG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGxvY2FsaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgZW50cnlpbmRleGVzLnB1c2goZW50cnkudGFyZ2V0LmRhdGFzZXQuaW5kZXgpXG4gICAgICAgIH0gXG5cbiAgICAgICAgY29uc29sZS5sb2coJ3JlZmVyZW5jZWluZGV4LCBlbnRyeWluZGV4ZXMnLHJlZmVyZW5jZWluZGV4LCAuLi5lbnRyeWluZGV4ZXMpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWZlcmVuY2VpbmRleCwgaW5kZXhvZmZzZXQnLHJlZmVyZW5jZWluZGV4LCBpbmRleG9mZnNldClcblxuICAgICAgICBpZiAocmVmZXJlbmNlaW5kZXggPiAobGlzdHNpemUgLTEpKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VpbmRleCA9IGxpc3RzaXplIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZWluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZm9yd2FyZGNvdW50LCBiYWNrd2FyZGNvdW50LCBzaGlmdGl0ZW1jb3VudCwgcmVmZXJlbmNlcm93c2hpZnQsIHJlZmVyZW5jZXNoaWZ0LCByZWZlcmVuY2VpbmRleCxsb2NhbGludGVyc2VjdGlvbnMnLFxuICAgICAgICAvLyAgICAgZm9yd2FyZGNvdW50LCBiYWNrd2FyZGNvdW50LCBzaGlmdGl0ZW1jb3VudCwgcmVmZXJlbmNlcm93c2hpZnQsIHJlZmVyZW5jZXNoaWZ0LCByZWZlcmVuY2VpbmRleCwgbG9jYWxpbnRlcnNlY3Rpb25zKVxuXG4gICAgICAgIGlmIChzaGlmdGl0ZW1jb3VudCA9PSAwKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdFWElUIHNoaWZ0aXRlbWNvdW50JyxzaGlmdGl0ZW1jb3VudClcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBzaGlmdGl0ZW1jb3VudCA9IE1hdGguYWJzKHNoaWZ0aXRlbWNvdW50KSBcbiAgICAgICAgbGV0IHNoaWZ0cm93Y291bnQgPSBNYXRoLmNlaWwoc2hpZnRpdGVtY291bnQvY3Jvc3Njb3VudClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ09QRU5JTkcgc2hpZnRyb3djb3VudCwgc2hpZnRpdGVtY291bnQnLHNoaWZ0cm93Y291bnQsIHNoaWZ0aXRlbWNvdW50KVxuXG4gICAgICAgIC8vIHNldCBwZW5kaW5nY29udGVudG9mZnNldFxuICAgICAgICBsZXQgcGVuZGluZ2NvbnRlbnRvZmZzZXRcbiAgICAgICAgbGV0IGFkZGNvbnRlbnRjb3VudCA9IDBcblxuICAgICAgICAvLyBuZXh0LCB2ZXJpZnkgbnVtYmVyIG9mIHJvd3MgdG8gZGVsZXRlXG4gICAgICAgIGxldCBoZWFkaW5kZXhjaGFuZ2Vjb3VudCwgY3VycmVudGhlYWRyb3djb3VudCwgdmlld3BvcnRyb3djb3VudCwgdGFpbGluZGV4Y2hhbmdlY291bnQsIHRhaWxyb3djb3VudFxuXG4gICAgICAgIGN1cnJlbnRoZWFkcm93Y291bnQgPSBNYXRoLmNlaWwoaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50Lmxlbmd0aC9jcm9zc2NvdW50KVxuXG4gICAgICAgIGxldCBjbGlwcm93Y291bnQgPSAwLCBjbGlwaXRlbWNvdW50ID0gMFxuXG4gICAgICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7IC8vIGRlbGV0ZSBmcm9tIGhlYWQ7IGFkZCB0byB0YWlsOyBoZWFkIGlzIGRpcmVjdGlvbiBvZiBzdHJvbGxcblxuICAgICAgICAgICAgaWYgKChjdXJyZW50aGVhZHJvd2NvdW50ICsgc2hpZnRyb3djb3VudCkgPiAoY3JhZGxlUHJvcHMucnVud2F5Y291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd2RpZmYgPSAoY3VycmVudGhlYWRyb3djb3VudCArIHNoaWZ0cm93Y291bnQpIC0gKGNyYWRsZVByb3BzLnJ1bndheWNvdW50KVxuICAgICAgICAgICAgICAgIGNsaXByb3djb3VudCA9IHJvd2RpZmZcbiAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50ID0gKGNsaXByb3djb3VudCAqIGNyb3NzY291bnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZGNvbnRlbnRjb3VudCA9IGNsaXBpdGVtY291bnRcblxuICAgICAgICAgICAgcGVuZGluZ2NvbnRlbnRvZmZzZXQgPSBpbmRleG9mZnNldCArIGNsaXBpdGVtY291bnRcblxuICAgICAgICAgICAgbGV0IHByb3Bvc2VkdGFpbGluZGV4ID0gcGVuZGluZ2NvbnRlbnRvZmZzZXQgKyBjb250ZW50bGlzdGNvcHkubGVuZ3RoIC0gMVxuXG4gICAgICAgICAgICBpZiAoKHByb3Bvc2VkdGFpbGluZGV4KSA+IChsaXN0c2l6ZSAtMSkgKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGlmZml0ZW1jb3VudCA9IChwcm9wb3NlZHRhaWxpbmRleCAtIChsaXN0c2l6ZSAtMSkpIC8vIGl0ZW1zIG91dHNpZGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBhZGRjb250ZW50Y291bnQgLT0gZGlmZml0ZW1jb3VudCAvLyBhZGp1c3QgdGhlIGFkZGNvbnRlbnQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZGlmZnJvd3MgPSBNYXRoLmZsb29yKGRpZmZpdGVtY291bnQvY3Jvc3Njb3VudCkgLy8gbnVtYmVyIG9mIGZ1bGwgcm93cyB0byBsZWF2ZSBpbiBwbGFjZVxuICAgICAgICAgICAgICAgIGxldCBkaWZmcm93aXRlbXMgPSAoZGlmZnJvd3MgKiBjcm9zc2NvdW50KSAgLy8gZGVyaXZlZCBudW1iZXIgb2YgaXRlbXMgdG8gbGVhdmUgaW4gcGxhY2VcblxuICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgLT0gZGlmZnJvd2l0ZW1zIC8vIGFwcGx5IGFkanVzdG1lbnQgdG8gbmV0c2hpZnRcbiAgICAgICAgICAgICAgICAvLyBwZW5kaW5nY29udGVudG9mZnNldCAtPSBkaWZmcm93aXRlbXMgLy8gYXBwbHkgYWRqdXN0bWVudCB0byBuZXcgb2Zmc2V0IGZvciBhZGRcblxuICAgICAgICAgICAgICAgIGlmIChhZGRjb250ZW50Y291bnQgPD0wKSB7IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50ID0gYWRkY29udGVudGNvdW50ID0gMFxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkaW5kZXhjaGFuZ2Vjb3VudCA9IC1jbGlwaXRlbWNvdW50XG4gICAgICAgICAgICB0YWlsaW5kZXhjaGFuZ2Vjb3VudCA9IGFkZGNvbnRlbnRjb3VudFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICgoY3VycmVudGhlYWRyb3djb3VudCAtIHNoaWZ0cm93Y291bnQpIDwgKGNyYWRsZVByb3BzLnJ1bndheWNvdW50KSkge1xuICAgICAgICAgICAgICAgIGFkZGNvbnRlbnRjb3VudCA9IChzaGlmdHJvd2NvdW50ICogY3Jvc3Njb3VudClcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2Nyb2xsYmFjayBhZGp1c3QgZm9yIFJVTldBWSBVTkRFUkZMT1cnKVxuICAgICAgICAgICAgICAgIGxldCByb3dkaWZmID0gKGNyYWRsZVByb3BzLnJ1bndheWNvdW50KSAtIChjdXJyZW50aGVhZHJvd2NvdW50IC0gc2hpZnRyb3djb3VudClcbiAgICAgICAgICAgICAgICBjbGlwcm93Y291bnQgPSByb3dkaWZmXG4gICAgICAgICAgICAgICAgbGV0IHRhaWxyb3dpdGVtY291bnQgPSAobGlzdHNpemUgJSBjcm9zc2NvdW50KVxuICAgICAgICAgICAgICAgIGlmICh0YWlscm93Y291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IHRhaWxyb3dpdGVtY291bnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXByb3djb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgKz0gKChjbGlwcm93Y291bnQgLTEpICogY3Jvc3Njb3VudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBpdGVtY291bnQgPSAoY2xpcHJvd2NvdW50ICogY3Jvc3Njb3VudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlbmRpbmdjb250ZW50b2Zmc2V0ID0gaW5kZXhvZmZzZXQgLy8gYWRkIHRvIHRhaWwgKG9wcG9zaXRlIGVuZCBvZiBzY3JvbGwgZGlyZWN0aW9uKSwgb2Zmc2V0IHdpbGwgcmVtYWluIHRoZSBzYW1lXG5cbiAgICAgICAgICAgIGxldCBwcm9wb3NlZGluZGV4b2Zmc2V0ID0gcGVuZGluZ2NvbnRlbnRvZmZzZXQgLSBjbGlwaXRlbWNvdW50XG5cbiAgICAgICAgICAgIGlmIChwcm9wb3NlZGluZGV4b2Zmc2V0IDwgMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Njcm9sbGJhY2sgYWRqdXN0IGZvciBUT1AgVU5ERVJGTE9XJylcblxuICAgICAgICAgICAgICAgIGxldCBkaWZmaXRlbWNvdW50ID0gLXByb3Bvc2VkaW5kZXhvZmZzZXRcbiAgICAgICAgICAgICAgICBsZXQgZGlmZnJvd3MgPSBNYXRoLmZsb29yKGRpZmZpdGVtY291bnQvY3Jvc3Njb3VudCkgLy8gbnVtYmVyIG9mIGZ1bGwgcm93cyB0byBsZWF2ZSBpbiBwbGFjZVxuICAgICAgICAgICAgICAgIGxldCBkaWZmcm93aXRlbXMgPSAoZGlmZnJvd3MgKiBjcm9zc2NvdW50KVxuXG4gICAgICAgICAgICAgICAgYWRkY29udGVudGNvdW50IC09IGRpZmZpdGVtY291bnRcbiAgICAgICAgICAgICAgICBjbGlwaXRlbWNvdW50IC09IGRpZmZyb3dpdGVtc1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZGNvbnRlbnRjb3VudCwgY2xpcGl0ZW1jb3VudCwgZGlmZml0ZW1jb3VudCwgZGlmZnJvd2l0ZW1zJyxcbiAgICAgICAgICAgICAgICAvLyAgICAgYWRkY29udGVudGNvdW50LCBjbGlwaXRlbWNvdW50LCBkaWZmaXRlbWNvdW50LCBkaWZmcm93aXRlbXMpXG4gICAgICAgICAgICAgICAgaWYgKGFkZGNvbnRlbnRjb3VudCA8PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpcGl0ZW1jb3VudCA9IGFkZGNvbnRlbnRjb3VudCA9IDBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkaW5kZXhjaGFuZ2Vjb3VudCA9IGFkZGNvbnRlbnRjb3VudFxuICAgICAgICAgICAgdGFpbGluZGV4Y2hhbmdlY291bnQgPSAtY2xpcGl0ZW1jb3VudFxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU0NST0xMQkFDSyBzY3JvbGxmb3J3YXJkLHJlZmVyZW5jZWluZGV4LGhlYWRpbmRleGNoYW5nZWNvdW50LCB0YWlsaW5kZXhjaGFuZ2Vjb3VudCcsXG4gICAgICAgICAgICAvLyAgICAgc2Nyb2xsZm9yd2FyZCxyZWZlcmVuY2VpbmRleCxoZWFkaW5kZXhjaGFuZ2Vjb3VudCwgdGFpbGluZGV4Y2hhbmdlY291bnQpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnZXRVSUNvbnRlbnRMaXN0IGhlYWRpbmRleGNoYW5nZWNvdW50LCB0YWlsaW5kZXhjaGFuZ2Vjb3VudCwgaW5kZXhvZmZzZXQnLFxuICAgICAgICAvLyAgICAgaGVhZGluZGV4Y2hhbmdlY291bnQsIHRhaWxpbmRleGNoYW5nZWNvdW50LCBpbmRleG9mZnNldClcbiAgICAgICAgbGV0IGxvY2FsQ29udGVudExpc3QgXG4gICAgICAgIGlmIChoZWFkaW5kZXhjaGFuZ2Vjb3VudCB8fCB0YWlsaW5kZXhjaGFuZ2Vjb3VudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2dldFVJQ29udGVudExpc3QnKVxuICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdCA9IGdldFVJQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICAgICAgbG9jYWxDb250ZW50TGlzdDpjb250ZW50bGlzdGNvcHksXG4gICAgICAgICAgICAgICAgaGVhZGluZGV4Y291bnQ6aGVhZGluZGV4Y2hhbmdlY291bnQsXG4gICAgICAgICAgICAgICAgdGFpbGluZGV4Y291bnQ6dGFpbGluZGV4Y2hhbmdlY291bnQsXG4gICAgICAgICAgICAgICAgaW5kZXhvZmZzZXQsLy8sOiBwZW5kaW5nY29udGVudG9mZnNldCxcblxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOmNyYWRsZVByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6Y3JhZGxlUHJvcHMuY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGg6Y3JhZGxlUHJvcHMuY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgIG9ic2VydmVyOiBpdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrczpjYWxsYmFja3NSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBnZXRJdGVtOmNyYWRsZVByb3BzLmdldEl0ZW0sXG4gICAgICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6Y3JhZGxlUHJvcHMucGxhY2Vob2xkZXIsXG5cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGxvY2FsQ29udGVudExpc3QgPSBjb250ZW50bGlzdGNvcHlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gbG9jYWxDb250ZW50TGlzdFxuICAgICAgICBsZXQgW2hlYWRjb250ZW50LCB0YWlsY29udGVudF0gPSBhbGxvY2F0ZUNvbnRlbnRMaXN0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0OmxvY2FsQ29udGVudExpc3QsXG4gICAgICAgICAgICAgICAgcnVud2F5Y291bnQ6Y3JhZGxlUHJvcHMucnVud2F5Y291bnQsXG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VpbmRleCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTUExJVCBoZWFkY29udGVudCBjb3VudCwgdGFpbGNvbnRlbnQgY291bnQsIHJlZmVyZW5jZWluZGV4LCBoZWFkY29udGVudCwgdGFpbGNvbnRlbnQnLFxuICAgICAgICAvLyAgICAgaGVhZGNvbnRlbnQubGVuZ3RoLCB0YWlsY29udGVudC5sZW5ndGgsIHJlZmVyZW5jZWluZGV4LCBoZWFkY29udGVudCwgdGFpbGNvbnRlbnQpXG5cbiAgICAgICAgbW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSBsb2NhbENvbnRlbnRMaXN0XG4gICAgICAgIGhlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50ID0gaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gaGVhZGNvbnRlbnRcbiAgICAgICAgdGFpbFZpZXdDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsY29udGVudFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd2aWV3cG9ydCBzY3JvbGx0b3AgQkVGT1JFIEdFVFNQSU5FUE9TUkVGJywgc2Nyb2xsdG9wLCB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wKVxuXG4gICAgICAgIGxldCBzcGluZXBvc3JlZiA9IGdldFNwaW5lUG9zUmVmKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNjcm9sbGZvcndhcmQsXG4gICAgICAgICAgICAgICAgaXRlbWVsZW1lbnRzOml0ZW1FbGVtZW50c1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOmNyYWRsZVByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIHNwaW5lRWxlbWVudDpzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VpbmRleCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIGdhcDpjcmFkbGVQcm9wcy5nYXAsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlc2hpZnQsXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc3BpbmVwb3NyZWYnLHNwaW5lcG9zcmVmKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzcGluZXBvc3JlZixoZWFkY29udGVudCwgdGFpbGNvbnRlbnQnLHNwaW5lcG9zcmVmLGhlYWRjb250ZW50LCB0YWlsY29udGVudClcblxuICAgICAgICBpZiAoc3BpbmVwb3NyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNyYWRsZVByb3BzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDBweCwke3NwaW5lcG9zcmVmfXB4KWBcbiAgICAgICAgICAgICAgICBzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS50b3AgPSBzcGluZXBvc3JlZiArICdweCdcbiAgICAgICAgICAgICAgICBzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS5sZWZ0ID0gJ2F1dG8nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNwaW5lQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtzcGluZXBvc3JlZn1weCwwcHgpYFxuICAgICAgICAgICAgICAgIHNwaW5lQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBzcGluZXBvc3JlZiArICdweCdcbiAgICAgICAgICAgICAgICBzcGluZUNyYWRsZUVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS50b3AgPSAnYXV0bydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd2aWV3cG9ydCBzY3JvbGx0b3AgQkVGT1JFIENBTExJTkcgdXBkYXRlc2Nyb2xsJywgc2Nyb2xsdG9wLCB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wKVxuXG4gICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgndXBkYXRlc2Nyb2xsJylcblxuICAgIH0sW10pXG5cbiAgICAvLyBFbmQgb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgc3VwcG9ydFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIEFzc2VtYmx5IG9mIGNvbnRlbnRdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgLy8gcmVzZXQgY3JhZGxlLCBpbmNsdWRpbmcgYWxsb2NhdGlvbiBiZXR3ZWVuIGhlYWQgYW5kIHRhaWwgcGFydHMgb2YgdGhlIGNyYWRsZVxuICAgIGNvbnN0IHNldENyYWRsZUNvbnRlbnQgPSB1c2VDYWxsYmFjaygoY3JhZGxlU3RhdGUsIHJlZmVyZW5jZUluZGV4RGF0YSkgPT4ge1xuXG4gICAgICAgIGxldCB7IGluZGV4OiB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQsIFxuICAgICAgICAgICAgc2Nyb2xsb2Zmc2V0OiB2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0IH0gPSByZWZlcmVuY2VJbmRleERhdGFcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb24nKSB2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0ID0gMFxuXG4gICAgICAgIGxldCBsb2NhbENvbnRlbnRMaXN0ID0gW10gLy8gYW55IGR1cGxpY2F0ZWQgaXRlbXMgd2lsbCBiZSByZS11c2VkIGJ5IHJlYWN0XG5cbiAgICAgICAgbGV0IHtpbmRleG9mZnNldCwgcmVmZXJlbmNlb2Zmc2V0LCBjb250ZW50Q291bnQsIHNjcm9sbGJsb2Nrb2Zmc2V0LCBjcmFkbGVvZmZzZXR9ID0gXG4gICAgICAgICAgICBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyh7XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgICAgICAgICAgcm93Y291bnQ6Y3JhZGxlcm93Y291bnQsXG4gICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgIHZpc2libGV0YXJnZXRpbmRleG9mZnNldCxcbiAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxPZmZzZXQ6dmlzaWJsZXRhcmdldHNjcm9sbG9mZnNldCxcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICBpbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGluZGV4OnJlZmVyZW5jZW9mZnNldCxcbiAgICAgICAgICAgIHNjcm9sbG9mZnNldDp2aXNpYmxldGFyZ2V0c2Nyb2xsb2Zmc2V0LFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgbGV0IGNzdGF0ZSA9IGNyYWRsZVN0YXRlXG4gICAgICAgICAgICBpZiAoY3N0YXRlID09ICdzZXRyZWxvYWQnKSBjc3RhdGUgPSAncmVsb2FkJ1xuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50KFxuICAgICAgICAgICAgaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQuaW5kZXgsICdzZXRDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuXG4gICAgICAgIH1cblxuICAgICAgICBzYXZlSW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhKGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50KSAvLyBjb25zaXN0ZW50IHdpdGggb25TY3JvbGxcblxuICAgICAgICBsZXQgY2hpbGRsaXN0ID0gZ2V0VUlDb250ZW50TGlzdCh7XG4gICAgICAgICAgICBpbmRleG9mZnNldCwgXG4gICAgICAgICAgICBoZWFkaW5kZXhjb3VudDowLCBcbiAgICAgICAgICAgIHRhaWxpbmRleGNvdW50OmNvbnRlbnRDb3VudCwgXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICBsb2NhbENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgb2JzZXJ2ZXI6aXRlbU9ic2VydmVyUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICAgICAgY2FsbGJhY2tzOmNhbGxiYWNrc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZ2V0SXRlbSxcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IFtoZWFkY29udGVudGxpc3QsIHRhaWxjb250ZW50bGlzdF0gPSBhbGxvY2F0ZUNvbnRlbnRMaXN0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRsaXN0OmNoaWxkbGlzdCxcbiAgICAgICAgICAgICAgICBydW53YXljb3VudDpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LnJ1bndheWNvdW50LFxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlaW5kZXg6MCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIG1vZGVsQ29udGVudFJlZi5jdXJyZW50ID0gY2hpbGRsaXN0XG4gICAgICAgIGhlYWRNb2RlbENvbnRlbnRSZWYuY3VycmVudCA9IGhlYWRjb250ZW50bGlzdFxuICAgICAgICB0YWlsTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSB0YWlsY29udGVudGxpc3RcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudCA9IHtwcm9wZXJ0eTonc2Nyb2xsVG9wJyx2YWx1ZTpzY3JvbGxibG9ja29mZnNldH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudCA9IHtwcm9wZXJ0eTonc2Nyb2xsTGVmdCcsdmFsdWU6c2Nyb2xsYmxvY2tvZmZzZXR9XG5cbiAgICAgICAgfVxuXG4gICAgfSxbXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHJ1bndheWxlbmd0aCxcbiAgICAgICAgcnVud2F5Y291bnQsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgY3JhZGxlcm93Y291bnQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHN0YXRlIG1hbmFnZW1lbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBjb25zdCBzY3JvbGxUaW1lcmlkUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBjYWxsYmFjayBmb3Igc2Nyb2xsXG4gICAgY29uc3Qgb25TY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29uU2Nyb2xsIHNjcm9sbFRvcCcsdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LnNjcm9sbFRvcClcblxuICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZXJpZFJlZi5jdXJyZW50KVxuXG4gICAgICAgIGlmIChwYXVzZVNjcm9sbGluZ0VmZmVjdHNSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgbGV0IGNyYWRsZVN0YXRlID0gY3JhZGxlc3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuaXNSZXNpemluZykge1xuXG4gICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlYWR5JyB8fCBjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZycpIHtcblxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0gZ2V0UmVmZXJlbmNlSW5kZXhEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnREYXRhOnZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBjcmFkbGVQcm9wc1JlZixcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3Njb3VudFJlZixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2tSZWYuY3VycmVudCAmJiBcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXhDYWxsYmFja1JlZi5jdXJyZW50KGltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50LmluZGV4LCdzY3JvbGxpbmcnLCBjcmFkbGVTdGF0ZSlcblxuICAgICAgICAgICAgICAgIHNhdmVJbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGEoaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzQ3JhZGxlSW5WaWV3UmVmLmN1cnJlbnQgJiYgXG4gICAgICAgICAgICAhcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCAmJiBcbiAgICAgICAgICAgICF2aWV3cG9ydERhdGFSZWYuY3VycmVudC5pc1Jlc2l6aW5nICYmXG4gICAgICAgICAgICAhKGNyYWRsZVN0YXRlID09ICdyZXNpemUnKSAmJlxuICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbmluZycpICYmIFxuICAgICAgICAgICAgIShjcmFkbGVTdGF0ZSA9PSAncmVwb3NpdGlvbicpKSB7XG5cbiAgICAgICAgICAgIGxldCByZWN0ID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnQuZWxlbWVudHJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBsZXQge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSByZWN0XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICAgICAgICAgICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQudmlld3BvcnREaW1lbnNpb25zID0ge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0gLy8gdXBkYXRlIGZvciBzY3JvbGx0cmFja2VyXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSRVBPU0lUSU9OSU5HJylcbiAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFRpbWVyaWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBpc1Njcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY3JhZGxlU3RhdGUgPSBjcmFkbGVzdGF0ZVJlZi5jdXJyZW50XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0RGF0YVJlZi5jdXJyZW50LmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgICAgIC8vIChjcmFkbGVTdGF0ZSAhPSAncmVwb3NpdGlvbmluZycpICYmIFxuICAgICAgICAgICAgICAgIC8vICAgICBub3JtYWxpemVDcmFkbGVBbmNob3JzKGhlYWRDcmFkbGVFbGVtZW50UmVmLmN1cnJlbnQsIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb24pXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FscmVmZGF0YSA9IHsuLi5pbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICBzYXZlSW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhKGxvY2FscmVmZGF0YSkgLy8gdHJpZ2dlciByZS1ydW4gdG8gY2FwdHVyZSBlbmQgb2Ygc2Nyb2xsIHNlc3Npb24gdmFsdWVzXG4gICAgICAgICAgICAgICAgbWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSBsb2NhbHJlZmRhdGFcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbmluZyc6IHtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnQgPSB7Li4ubWFzdGVyUmVmZXJlbmNlSW5kZXhEYXRhUmVmLmN1cnJlbnR9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlcG9zaXRpb24nKVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFNDUk9MTF9USU1FT1VUX0ZPUl9PTkFGVEVSU0NST0xMKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGRhdGEgZm9yIHN0YXRlIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjYWxsaW5nQ3JhZGxlU3RhdGUgPSB1c2VSZWYoY3JhZGxlc3RhdGVSZWYuY3VycmVudClcbiAgICBjb25zdCBoZWFkbGF5b3V0RGF0YVJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uRGF0YVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBzdGF0ZSBlbmdpbmVcbiAgICAvLyB1c2VMYXlvdXQgZm9yIHN1cHByZXNzaW5nIGZsYXNoZXNcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgc3dpdGNoIChjcmFkbGVzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVsb2FkJzpcbiAgICAgICAgICAgICAgICBoZWFkTW9kZWxDb250ZW50UmVmLmN1cnJlbnQgPSBbXVxuICAgICAgICAgICAgICAgIHRhaWxNb2RlbENvbnRlbnRSZWYuY3VycmVudCA9IFtdXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXRyZWxvYWQnKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Nyb2xscG9zaXRpb24nOiB7XG5cbiAgICAgICAgICAgICAgICB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50W3Njcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnByb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnZhbHVlXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ2NvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZXNjcm9sbCc6IHsgLy8gc2Nyb2xsXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb250ZW50Jzoge1xuICAgICAgICAgICAgICAgIGhlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50ID0gaGVhZE1vZGVsQ29udGVudFJlZi5jdXJyZW50IC8vIGNvbnRlbnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICB0YWlsVmlld0NvbnRlbnRSZWYuY3VycmVudCA9IHRhaWxNb2RlbENvbnRlbnRSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIHNhdmVDcmFkbGVTdGF0ZSgnbm9ybWFsaXplJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVzdGF0ZV0pXG5cbiAgICAvLyBzdGFuZGFyZCBwcm9jZXNzaW5nIHN0YWdlc1xuICAgIHVzZUVmZmVjdCgoKT0+IHtcblxuICAgICAgICBsZXQgdmlld3BvcnREYXRhID0gdmlld3BvcnREYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgc3dpdGNoIChjcmFkbGVzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiBcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdwaXZvdCc6XG4gICAgICAgICAgICBjYXNlICdzZXRyZWxvYWQnOlxuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG5cbiAgICAgICAgICAgICAgICBjYWxsaW5nQ3JhZGxlU3RhdGUuY3VycmVudCA9IGNyYWRsZXN0YXRlXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzZXR0bGUnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAnc2V0dGxlJzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlQ29udGVudChjYWxsaW5nQ3JhZGxlU3RhdGUuY3VycmVudCwgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50KVxuXG4gICAgICAgICAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdzY3JvbGxwb3NpdGlvbicpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsaXplJzoge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVkdW5kYW50IHNjcm9sbCBwb3NpdGlvbiB0byBhdm9pZCBhY2NpZGVudGFsIHBvc2l0aW9uaW5nIGF0IHRhaWwgZW5kIG9mIHJlcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0RGF0YS5lbGVtZW50cmVmLmN1cnJlbnQpIHsgLy8gYWxyZWFkeSB1bm1vdW50ZWQgaWYgZmFpbHNcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnREYXRhLmVsZW1lbnRyZWYuY3VycmVudFtzY3JvbGxQb3NpdGlvbkRhdGFSZWYuY3VycmVudC5wcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uRGF0YVJlZi5jdXJyZW50LnZhbHVlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpY2sgdXAgcG9zaXRpb24gZnJvbSBzZXRDb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5pbW1lZGlhdGVSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VJdGVtT2JzZXJ2ZXJSZWYuY3VycmVudCAgJiYgKHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCAgJiYgKHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgJiYgKHBhdXNlU2Nyb2xsaW5nRWZmZWN0c1JlZi5jdXJyZW50ID0gZmFsc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwxMDApXG5cbiAgICAgICAgICAgICAgICBzYXZlQ3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrIFxuXG4gICAgICAgICAgICB9ICAgICAgICAgIFxuXG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIH1cblxuICAgIH0sW2NyYWRsZXN0YXRlXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxsYmFja3MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gb24gaG9zdCBkZW1hbmRcbiAgICBjb25zdCBnZXRWaXNpYmxlTGlzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcblxuICAgICAgICBsZXQgaXRlbWxpc3QgPSBBcnJheS5mcm9tKGl0ZW1FbGVtZW50c1JlZi5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiBjYWxjVmlzaWJsZUl0ZW1zKFxuICAgICAgICAgICAgaXRlbWxpc3QsXG4gICAgICAgICAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5lbGVtZW50cmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBoZWFkQ3JhZGxlRWxlbWVudFJlZi5jdXJyZW50LCBcbiAgICAgICAgICAgIGNyYWRsZVByb3BzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cbiAgICAgICAgKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IGdldENvbnRlbnRMaXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtRWxlbWVudHNSZWYuY3VycmVudClcbiAgICB9LFtdKVxuXG4gICAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuXG4gICAgICAgIHBhdXNlSXRlbU9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIHBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICAgIGNhbGxpbmdSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudCA9IHsuLi5tYXN0ZXJSZWZlcmVuY2VJbmRleERhdGFSZWYuY3VycmVudH1cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHNjcm9sbFRvSXRlbSA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4geyAvLyAsIGFsaWdubWVudCA9ICdzdGFydCcpID0+IHtcblxuICAgICAgICBwYXVzZUl0ZW1PYnNlcnZlclJlZi5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyUmVmLmN1cnJlbnQgPSB0cnVlXG5cbiAgICAgICAgY2FsbGluZ1JlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50ID0ge2luZGV4LCBzY3JvbGxvZmZzZXQ6MH1cbiAgICAgICAgc2F2ZUNyYWRsZVN0YXRlKCdyZXBvc2l0aW9uJylcblxuICAgIH0sW10pXG5cbiAgICAvLyBjb250ZW50IGl0ZW0gcmVnaXN0cmF0aW9uIGNhbGxiYWNrOyBjYWxsZWQgZnJvbSBpdGVtXG4gICAgY29uc3QgZ2V0SXRlbUVsZW1lbnREYXRhID0gdXNlQ2FsbGJhY2soKGl0ZW1FbGVtZW50RGF0YSwgcmVwb3J0VHlwZSkgPT4geyAvLyBjYW5kaWRhdGUgdG8gZXhwb3J0XG5cbiAgICAgICAgY29uc3QgW2luZGV4LCBzaGVsbHJlZl0gPSBpdGVtRWxlbWVudERhdGFcblxuICAgICAgICBpZiAocmVwb3J0VHlwZSA9PSAncmVnaXN0ZXInKSB7XG5cbiAgICAgICAgICAgIGl0ZW1FbGVtZW50c1JlZi5jdXJyZW50LnNldChpbmRleCxzaGVsbHJlZilcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcG9ydFR5cGUgPT0gJ3VucmVnaXN0ZXInKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdVTlJFR0lTVEVSSU5HJyxpbmRleClcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnRzUmVmLmN1cnJlbnQuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pXG5cbiAgICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgICAgICBnZXRFbGVtZW50RGF0YTpnZXRJdGVtRWxlbWVudERhdGFcbiAgICB9KVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJFTkRFUi4uLiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBsZXQgY3JhZGxlSGVhZFN0eWxlID0gY3JhZGxlSGVhZFN0eWxlUmVmLmN1cnJlbnRcbiAgICAvLyBsZXQgY3JhZGxlVGFpbFN0eWxlID0gY3JhZGxlVGFpbFN0eWxlUmVmLmN1cnJlbnRcbiAgICAvLyBsZXQgY3JhZGxlU3BpbmVTdHlsZSA9IGNyYWRsZVNwaW5lU3R5bGVSZWYuY3VycmVudFxuXG4gICAgY29uc3Qgc2Nyb2xsVHJhY2tlckFyZ3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDp2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgMyxcbiAgICAgICAgICAgIGxlZnQ6dmlld3BvcnREaW1lbnNpb25zLmxlZnQgKyAzLFxuICAgICAgICAgICAgb2Zmc2V0OmltbWVkaWF0ZVJlZmVyZW5jZUluZGV4RGF0YVJlZi5jdXJyZW50LmluZGV4LFxuICAgICAgICAgICAgbGlzdHNpemU6Y3JhZGxlUHJvcHNSZWYuY3VycmVudC5saXN0c2l6ZSxcbiAgICAgICAgICAgIHN0eWxlczpjcmFkbGVQcm9wc1JlZi5jdXJyZW50LnN0eWxlcyxcbiAgICAgICAgfVxuICAgIH0sW3ZpZXdwb3J0RGltZW5zaW9ucywgaW1tZWRpYXRlUmVmZXJlbmNlSW5kZXhEYXRhUmVmLCBjcmFkbGVQcm9wc1JlZl0pXG5cbiAgICByZXR1cm4gPD5cblxuICAgICAgICB7IChjcmFkbGVzdGF0ZVJlZi5jdXJyZW50ID09ICdyZXBvc2l0aW9uaW5nJylcbiAgICAgICAgICAgID88U2Nyb2xsVHJhY2tlciBcbiAgICAgICAgICAgICAgICB0b3AgPSB7c2Nyb2xsVHJhY2tlckFyZ3MudG9wfSBcbiAgICAgICAgICAgICAgICBsZWZ0ID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxlZnR9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHtzY3JvbGxUcmFja2VyQXJncy5vZmZzZXR9IFxuICAgICAgICAgICAgICAgIGxpc3RzaXplID0ge3Njcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplfVxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IHtzY3JvbGxUcmFja2VyQXJncy5zdHlsZXN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgOm51bGx9XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICBzdHlsZSA9IHtjcmFkbGVTcGluZVN0eWxlfSBcbiAgICAgICAgICAgIHJlZiA9IHtzcGluZUNyYWRsZUVsZW1lbnRSZWZ9XG4gICAgICAgICAgICBkYXRhLW5hbWUgPSAnc3BpbmUnXG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhLW5hbWUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICByZWYgPSB7aGVhZENyYWRsZUVsZW1lbnRSZWZ9IFxuICAgICAgICAgICAgICAgIHN0eWxlID0ge2NyYWRsZUhlYWRTdHlsZX1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgeyhjcmFkbGVzdGF0ZVJlZi5jdXJyZW50ICE9ICdzZXR1cCcpP2hlYWRWaWV3Q29udGVudFJlZi5jdXJyZW50Om51bGx9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRhdGEtbmFtZSA9ICd0YWlsJ1xuICAgICAgICAgICAgICAgIHJlZiA9IHt0YWlsQ3JhZGxlRWxlbWVudFJlZn0gXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7Y3JhZGxlVGFpbFN0eWxlfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7KGNyYWRsZXN0YXRlUmVmLmN1cnJlbnQgIT0gJ3NldHVwJyk/dGFpbFZpZXdDb250ZW50UmVmLmN1cnJlbnQ6bnVsbH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICA8Lz5cblxufSAvLyBDcmFkbGVcblxuXG5leHBvcnQgZGVmYXVsdCBDcmFkbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle.tsx\n");

/***/ }),

/***/ "./src/cradlefunctions.tsx":
/*!*********************************!*\
  !*** ./src/cradlefunctions.tsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // cradlefunctions.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/******************************************************************************************\n ------------------------------------[ SUPPORTING FUNCTIONS ]------------------------------\n*******************************************************************************************/\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar itemshell_1 = __importDefault(__webpack_require__(/*! ./itemshell */ \"./src/itemshell.tsx\"));\n\nexports.calcVisibleItems = function (itemsArray, viewportElement, cradleElement, orientation) {\n  var list = [];\n  var cradleTop = cradleElement.offsetTop,\n      cradleLeft = cradleElement.offsetLeft;\n  var scrollblockTopOffset = -viewportElement.scrollTop,\n      scrollblockLeftOffset = -viewportElement.scrollLeft,\n      viewportHeight = viewportElement.offsetHeight,\n      viewportWidth = viewportElement.offsetWidth,\n      viewportTopOffset = -scrollblockTopOffset,\n      viewportBottomOffset = -scrollblockTopOffset + viewportHeight;\n\n  for (var i = 0; i < itemsArray.length; i++) {\n    var _a = itemsArray[i],\n        index = _a[0],\n        elementRef = _a[1];\n    var element = elementRef.current;\n    var top_1 = element.offsetTop,\n        left = element.offsetLeft,\n        width = element.offsetWidth,\n        height = element.offsetHeight,\n        right = left + width,\n        bottom = top_1 + height;\n    var itemTopOffset = scrollblockTopOffset + cradleTop + top_1,\n        // offset from top of viewport\n    itemBottomOffset = scrollblockTopOffset + cradleTop + bottom,\n        // offset from top of viewport\n    itemLeftOffset = scrollblockLeftOffset + cradleLeft + left,\n        itemRightOffset = scrollblockLeftOffset + cradleLeft + right;\n    var isVisible = false; // default\n\n    var topPortion = void 0,\n        bottomPortion = void 0,\n        leftPortion = void 0,\n        rightPortion = void 0;\n\n    if (itemTopOffset < 0 && itemBottomOffset > 0) {\n      orientation == 'vertical' && (isVisible = true);\n      bottomPortion = itemBottomOffset;\n      topPortion = bottomPortion - height;\n    } else if (itemTopOffset >= 0 && itemBottomOffset < viewportHeight) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = height;\n      bottomPortion = 0;\n    } else if (itemTopOffset > 0 && itemTopOffset - viewportHeight < 0) {\n      orientation == 'vertical' && (isVisible = true);\n      topPortion = viewportHeight - itemTopOffset;\n      bottomPortion = topPortion - height;\n    } else {\n      if (orientation == 'vertical') continue;\n    }\n\n    if (itemLeftOffset < 0 && itemRightOffset > 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      rightPortion = itemRightOffset;\n      leftPortion = rightPortion - width;\n    } else if (itemLeftOffset >= 0 && itemRightOffset < viewportWidth) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = width;\n      rightPortion = 0;\n    } else if (itemLeftOffset > 0 && itemLeftOffset - viewportWidth < 0) {\n      orientation == 'horizontal' && (isVisible = true);\n      leftPortion = viewportWidth - itemLeftOffset;\n      rightPortion = leftPortion - width;\n    } else {\n      if (orientation == 'horizontal') continue;\n    }\n\n    var verticalRatio = topPortion > 0 ? topPortion / height : bottomPortion / height,\n        horizontalRatio = leftPortion > 0 ? leftPortion / width : rightPortion / height;\n    var itemData = {\n      index: index,\n      isVisible: isVisible,\n      top: top_1,\n      right: right,\n      bottom: bottom,\n      left: left,\n      width: width,\n      height: height,\n      itemTopOffset: itemTopOffset,\n      itemBottomOffset: itemBottomOffset,\n      topPortion: topPortion,\n      bottomPortion: bottomPortion,\n      itemLeftOffset: itemLeftOffset,\n      itemRightOffset: itemRightOffset,\n      leftPortion: leftPortion,\n      rightPortion: rightPortion,\n      verticalRatio: verticalRatio,\n      horizontalRatio: horizontalRatio\n    };\n    list.push(itemData);\n  }\n\n  list.sort(function (a, b) {\n    return a.index - b.index;\n  });\n  return list;\n};\n\nexports.getReferenceIndexData = function (_a) {\n  var viewportData = _a.viewportData,\n      cradlePropsRef = _a.cradlePropsRef,\n      crosscountRef = _a.crosscountRef;\n  var cradleProps = cradlePropsRef.current;\n  var viewportElement = viewportData.elementref.current;\n  var orientation = cradleProps.orientation,\n      listsize = cradleProps.listsize;\n  var scrollPos, cellLength;\n\n  if (orientation == 'vertical') {\n    scrollPos = viewportElement.scrollTop;\n    cellLength = cradleProps.cellHeight + cradleProps.gap;\n  } else {\n    scrollPos = viewportElement.scrollLeft;\n    cellLength = cradleProps.cellWidth + cradleProps.gap;\n  }\n\n  var referencescrolloffset = cellLength - scrollPos % cellLength; // + cellSpecs.padding\n\n  if (referencescrolloffset == cellLength + cradleProps.padding) referencescrolloffset = 0;\n  var referencerowindex = Math.ceil((scrollPos - cradleProps.padding) / cellLength);\n  var referenceindex = referencerowindex * crosscountRef.current;\n  var referenceIndexData = {\n    index: Math.min(referenceindex, listsize - 1),\n    scrolloffset: referencescrolloffset\n  };\n  if (referenceIndexData.index == 0) referenceIndexData.scrolloffset = 0; // defensive\n\n  return referenceIndexData;\n}; // evaluate content for requirements\n\n\nexports.getContentListRequirements = function (_a) {\n  // -------------[ calc basic inputs: cellLength, contentCount. ]----------\n  var orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      rowcount = _a.rowcount,\n      runwaycount = _a.runwaycount,\n      gap = _a.gap,\n      visibletargetindexoffset = _a.visibletargetindexoffset,\n      targetScrollOffset = _a.targetScrollOffset,\n      crosscount = _a.crosscount,\n      listsize = _a.listsize; // let cradleContentLength, cellLength, viewportlength\n\n  var cellLength, viewportlength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellHeight + gap; // viewportlength = viewportheight\n  } else {\n    cellLength = cellWidth + gap; // viewportlength = viewportwidth\n  } // cradleContentLength = viewportlength + (runwaylength * 2)\n  // let cradlerowcount = Math.ceil(cradleContentLength/cellLength)\n\n\n  var contentCount = rowcount * crosscount; // cradlerowcount * crosscount\n\n  if (contentCount > listsize) contentCount = listsize; // -----------------------[ calc leadingitemcount, referenceoffset ]-----------------------\n  // let cradleleadingrowcount = runwaycount // Math.floor(runwaylength/cellLength)\n\n  var leadingitemcount = runwaycount * crosscount;\n  var targetdiff = visibletargetindexoffset % crosscount;\n  var referenceoffset = visibletargetindexoffset - targetdiff; // part of return message\n\n  leadingitemcount += targetdiff;\n  leadingitemcount = Math.min(leadingitemcount, visibletargetindexoffset); // for list head\n  // -----------------------[ calc indexoffset ]------------------------\n  // leading edge\n\n  var indexoffset = visibletargetindexoffset - leadingitemcount;\n  var diff = indexoffset % crosscount;\n  indexoffset -= diff; // ------------[ adjust indexoffset and contentCount for listsize ]------------\n\n  diff = 0;\n  var shift = 0;\n\n  if (indexoffset + contentCount > listsize) {\n    diff = indexoffset + contentCount - listsize;\n    shift = diff % crosscount;\n  }\n\n  if (diff) {\n    indexoffset -= diff - shift;\n    contentCount -= shift;\n  } // --------------------[ calc css positioning ]-----------------------\n\n\n  var indexrowoffset = Math.floor(indexoffset / crosscount);\n  var cradleoffset = indexrowoffset * cellLength;\n  var targetrowoffset = Math.floor(visibletargetindexoffset / crosscount);\n  var rowscrollblockoffset = targetrowoffset * cellLength;\n  var scrollblockoffset = Math.max(0, rowscrollblockoffset - targetScrollOffset);\n  return {\n    indexoffset: indexoffset,\n    referenceoffset: referenceoffset,\n    contentCount: contentCount,\n    scrollblockoffset: scrollblockoffset,\n    cradleoffset: cradleoffset\n  }; // summarize requirements message\n}; // filter out items that are already in runways\n\n\nexports.isolateRelevantIntersections = function (_a) {\n  var intersections = _a.intersections,\n      headcontent = _a.headcontent,\n      tailcontent = _a.tailcontent;\n  var headindexes = [],\n      tailindexes = [],\n      headintersectionindexes = [],\n      headintersections = [],\n      tailintersectionindexes = [],\n      tailintersections = [],\n      intersecting = {},\n      filteredintersections = [];\n\n  for (var _i = 0, headcontent_1 = headcontent; _i < headcontent_1.length; _i++) {\n    var item = headcontent_1[_i];\n    headindexes.push(item.props.index);\n  }\n\n  for (var _b = 0, tailcontent_1 = tailcontent; _b < tailcontent_1.length; _b++) {\n    var item = tailcontent_1[_b];\n    tailindexes.push(item.props.index);\n  }\n\n  for (var _c = 0, intersections_1 = intersections; _c < intersections_1.length; _c++) {\n    var entry = intersections_1[_c];\n    var index = parseInt(entry.target.dataset.index);\n\n    if (tailindexes.includes(index)) {\n      tailintersectionindexes.push(index);\n      tailintersections.push(entry);\n    } else if (headindexes.includes(index)) {\n      headintersectionindexes.push(index);\n      headintersections.push(entry);\n    } else {\n      return; // shouldn't happen\n    }\n\n    intersecting[index] = entry.isIntersecting;\n  } // collect headcontent indexes\n\n\n  var headindex = headindexes[headindexes.length - 1];\n  var tailindex = tailindexes[0];\n  var headptr = headintersectionindexes.indexOf(headindex);\n  var tailptr = tailintersectionindexes.indexOf(tailindex); // console.log('headpos, tailpos',headpos, tailpos)\n\n  if (headptr >= 0 && !intersecting[headindex]) {\n    headptr = -1;\n  }\n\n  if (tailptr >= 0 && intersecting[tailindex]) {\n    tailptr = -1;\n  }\n\n  if (headptr >= 0) {\n    var refindex = headintersectionindexes[headptr] + 1;\n    var refintersecting = intersecting[refindex - 1]; // console.log('HEAD refindex, refintersecting',refindex,refintersecting)\n\n    for (var ptr = headptr; ptr >= 0; ptr--) {\n      var index = headintersectionindexes[ptr]; // console.log('index + 1, refindex, intersecting[index],refintersecting',\n      //     index + 1, refindex, intersecting[index],refintersecting)\n\n      if (index + 1 == refindex && intersecting[index] == refintersecting) {\n        // console.log('adding entry to index,filteredintersections',index,headintersections[ptr])\n        filteredintersections.push(headintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[refindex];\n    }\n  }\n\n  if (tailptr >= 0) {\n    var refindex = tailintersectionindexes[tailptr] - 1;\n    var refintersecting = intersecting[refindex + 1]; // console.log('TAIL refindex, refintersecting',refindex,refintersecting, intersecting)\n\n    for (var ptr = tailptr; ptr < tailintersectionindexes.length; ptr++) {\n      var index = tailintersectionindexes[ptr]; // console.log('index - 1, refindex, intersecting[index],refintersecting',\n      //     index - 1, refindex, intersecting[index],refintersecting)\n\n      if (index - 1 == refindex && intersecting[index] == refintersecting) {\n        // console.log('adding entry to index,filteredintersections',index,tailintersections[ptr])\n        filteredintersections.push(tailintersections[ptr]);\n      } else {\n        break;\n      }\n\n      refindex = index;\n      refintersecting = intersecting[index];\n    }\n  } // console.log('headindexes, tailindexes, headintersectionindexes,tailintersectionindexes, intersecting, filteredintersections',\n  //     headindexes, tailindexes, headintersectionindexes,tailintersectionindexes, intersecting, filteredintersections)\n\n\n  return filteredintersections;\n}; // update content\n// adds itemshells at end of contentlist according to headindexcount and tailindescount,\n// or if indexcount values are <0 removes them.\n\n\nexports.getUIContentList = function (props) {\n  var indexoffset = props.indexoffset,\n      headindexcount = props.headindexcount,\n      tailindexcount = props.tailindexcount,\n      orientation = props.orientation,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      contentlist = props.localContentList,\n      crosscount = props.crosscount,\n      listsize = props.listsize,\n      callbacks = props.callbacks,\n      getItem = props.getItem,\n      placeholder = props.placeholder,\n      observer = props.observer;\n\n  var localContentlist = __spreadArrays(contentlist);\n\n  var tailindexoffset = indexoffset + contentlist.length;\n  var returnContentlist;\n  var headContentlist = [];\n\n  if (headindexcount >= 0) {\n    for (var index = indexoffset - headindexcount; index < indexoffset; index++) {\n      headContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(0, -headindexcount);\n  }\n\n  var tailContentlist = [];\n\n  if (tailindexcount >= 0) {\n    for (var index = tailindexoffset; index < tailindexoffset + tailindexcount; index++) {\n      tailContentlist.push(emitItem({\n        index: index,\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        observer: observer,\n        callbacks: callbacks,\n        getItem: getItem,\n        listsize: listsize,\n        placeholder: placeholder\n      }));\n    }\n  } else {\n    localContentlist.splice(tailindexcount, -tailindexcount);\n  }\n\n  returnContentlist = headContentlist.concat(localContentlist, tailContentlist);\n  return returnContentlist;\n}; // butterfly model. Leading (head) all or partially hidden; tail, visible plus following hidden\n\n\nexports.allocateContentList = function (_a) {\n  var contentlist = _a.contentlist,\n      // of cradle, in items (React components)\n  runwaycount = _a.runwaycount,\n      // in rows\n  referenceindex = _a.referenceindex,\n      // first tail item\n  crosscount = _a.crosscount;\n  var offsetindex = contentlist[0].props.index;\n  var runwaytailindex = contentlist[runwaycount * crosscount - 1].props.index;\n  var headitemcount; // if (referenceindex <= runwaytailindex) {\n  //     headitemcount = (referenceindex - offsetindex)\n  // } else {\n  //     headitemcount = (runwaycount * crosscount)\n  // }\n\n  headitemcount = referenceindex - offsetindex;\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount); // console.log('headlist, taillist', [...headlist], [...taillist])\n\n  return [headlist, taillist];\n};\n\nexports.getSpinePosRef = function (_a) {\n  // console.log('referenceindex, referenceshift',referenceindex, referenceshift)\n  var scrollforward = _a.scrollforward,\n      itemelements = _a.itemelements,\n      orientation = _a.orientation,\n      spineElement = _a.spineElement,\n      referenceindex = _a.referenceindex,\n      crosscount = _a.crosscount,\n      gap = _a.gap,\n      referenceshift = _a.referenceshift;\n  var spineposbase, spineposref;\n  var localrefindex = referenceindex;\n\n  if (!scrollforward) {\n    // localrefindex += crosscount\n    localrefindex += referenceshift;\n  }\n\n  var referenceobjects = [];\n\n  if (scrollforward) {\n    referenceobjects.push(itemelements.get(localrefindex));\n  } else {\n    for (var index = localrefindex; index > referenceindex; index -= crosscount) {\n      referenceobjects.push(itemelements.get(index));\n    }\n  }\n\n  var referenceposshift;\n\n  if (orientation == 'vertical') {\n    spineposbase = spineElement.offsetTop;\n  } else {\n    spineposbase = spineElement.offsetLeft;\n  }\n\n  if (scrollforward) {\n    var referenceelement = referenceobjects[0].current;\n\n    if (referenceelement) {\n      // console.log('headindex, headelement.offsetTop',headindex,headelement.offsetTop)\n      if (orientation == 'vertical') {\n        referenceposshift = referenceelement.offsetTop;\n      } else {\n        referenceposshift = referenceelement.offsetLeft;\n      }\n    }\n  } else {\n    referenceposshift = 0;\n\n    for (var _i = 0, referenceobjects_1 = referenceobjects; _i < referenceobjects_1.length; _i++) {\n      var refobj = referenceobjects_1[_i];\n\n      if (orientation == 'vertical') {\n        referenceposshift += refobj.current.offsetHeight + gap;\n      } else {\n        referenceposshift += refobj.current.offsetWidth + gap;\n      }\n    }\n  } // console.log('referenceindex, localrefindex, scrollforward,referenceshift, referenceposshift, referenceelement.offsetTop, referenceelement.offsetHeight, gap, referenceelement',\n  //     referenceindex, localrefindex, scrollforward,referenceshift, referenceposshift, referenceelement.offsetTop, referenceelement.offsetHeight, gap, referenceelement)\n\n\n  if (scrollforward) {\n    spineposref = spineposbase + referenceposshift;\n  } else {\n    spineposref = spineposbase - referenceposshift;\n  } // console.log('in getSpinePosRef referenceobject, scrollforward, spineposbase, localrefindex, referenceposshift, spineposref',\n  //     referenceobject, scrollforward, spineposbase, localrefindex, referenceposshift, spineposref)\n  // console.log('spineposref', spineposref)\n\n\n  return spineposref;\n};\n\nvar emitItem = function emitItem(_a) {\n  var index = _a.index,\n      orientation = _a.orientation,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      observer = _a.observer,\n      callbacks = _a.callbacks,\n      getItem = _a.getItem,\n      listsize = _a.listsize,\n      placeholder = _a.placeholder;\n  return react_1[\"default\"].createElement(itemshell_1[\"default\"], {\n    key: index,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    index: index,\n    observer: observer,\n    callbacks: callbacks,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder\n  });\n}; // ========================================================================================\n// ------------------------------------[ styles ]------------------------------------------\n// ========================================================================================\n\n\nexports.setCradleGridStyles = function (_a) {\n  var orientation = _a.orientation,\n      headstylesobject = _a.headCradleStyles,\n      tailstylesobject = _a.tailCradleStyles,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      crosscount = _a.crosscount,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth;\n\n  var headstyles = __assign({}, headstylesobject);\n\n  var tailstyles = __assign({}, tailstylesobject);\n\n  headstyles.gridGap = gap + 'px';\n  tailstyles.gridGap = gap + 'px';\n\n  if (orientation == 'horizontal') {\n    headstyles.padding = padding + \"px 0 \" + padding + \"px \" + padding + \"px\";\n    headstyles.width = 'auto';\n    headstyles.height = '100%';\n    headstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    headstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    headstyles.gridTemplateColumns = 'none';\n    tailstyles.padding = padding + \"px \" + padding + \"px \" + padding + \"px 0\";\n    tailstyles.width = 'auto';\n    tailstyles.height = '100%';\n    tailstyles.gridAutoFlow = 'column'; // explict crosscount next line as workaround for FF problem - \n    //     sets length of horiz cradle items in one line (row), not multi-row config\n\n    tailstyles.gridTemplateRows = cellHeight ? \"repeat(\" + crosscount + \", minmax(\" + cellHeight + \"px, 1fr))\" : 'auto';\n    tailstyles.gridTemplateColumns = 'none';\n  } else if (orientation == 'vertical') {\n    headstyles.padding = padding + \"px \" + padding + \"px 0 \" + padding + \"px\";\n    headstyles.width = '100%';\n    headstyles.height = 'auto';\n    headstyles.gridAutoFlow = 'row';\n    headstyles.gridTemplateRows = 'none';\n    headstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n    tailstyles.padding = \"0 \" + padding + \"px \" + padding + \"px \" + padding + \"px\";\n    tailstyles.width = '100%';\n    tailstyles.height = 'auto';\n    tailstyles.gridAutoFlow = 'row';\n    tailstyles.gridTemplateRows = 'none';\n    tailstyles.gridTemplateColumns = cellWidth ? \"repeat(auto-fit, minmax(\" + cellWidth + \"px, 1fr))\" : 'auto';\n  }\n\n  return [headstyles, tailstyles];\n}; // export const setCradleStyleRevisionsForDrop = ({ \n//     headcontentlist,\n//     tailcontentlist,\n//     headCradleElement,\n//     tailCradleElement, \n//     parentElement, \n//     scrollforward, \n//     orientation \n// }) => {\n//     let styles = {} as React.CSSProperties\n//     let tailstyles = {} as React.CSSProperties\n//     let headpos, tailpos\n//     // set styles revisions\n//     if (orientation == 'vertical') {\n//         let offsetHeight = headCradleElement.offsetHeight\n//         let parentHeight = parentElement.offsetHeight\n//         let offsetTop = headCradleElement.offsetTop\n//         styles.left = 'auto'\n//         styles.right = 'auto'\n//         if (scrollforward) {\n//             tailpos = offsetTop + offsetHeight\n//             styles.top = 'auto'\n//             styles.bottom = (parentHeight - tailpos) + 'px'\n//         } else {\n//             headpos = offsetTop\n//             styles.top = headpos + 'px'\n//             styles.bottom = 'auto'\n//         }\n//     } else {\n//         let offsetLeft = headCradleElement.offsetLeft\n//         let offsetWidth = headCradleElement.offsetWidth\n//         let parentWidth = parentElement.offsetWidth\n//         let cssleft = parseInt(headCradleElement.style.left)\n//         let cssright = parseInt(headCradleElement.style.bottom)\n//         styles.top = 'auto'\n//         styles.bottom = 'auto'\n//         if (scrollforward) {\n//             tailpos = offsetLeft + offsetWidth\n//             styles.left = 'auto'\n//             styles.right = (parentWidth - tailpos) + 'px'\n//         } else {\n//             headpos = offsetLeft\n//             styles.left = headpos + 'px'\n//             styles.right = 'auto'\n//         }\n//     }\n//     return [styles,tailstyles]\n// }\n// export const setCradleStyleRevisionsForAdd = ({\n//     headcontentlist,\n//     tailcontentlist,\n//     headCradleElement,\n//     tailCradleElement,\n//     parentElement,\n//     scrollforward,\n//     orientation,\n// }) => {\n//     let styles = {} as React.CSSProperties\n//     let tailstyles = {} as React.CSSProperties\n//     let headpos, tailpos\n//     // set style revisions\n//     if (orientation == 'vertical') {\n//         // let offsetTop\n//         let offsetHeight = headCradleElement.offsetHeight\n//         let parentHeight = parentElement.offsetHeight\n//         let csstop = parseInt(headCradleElement.style.top)\n//         let cssbottom = parseInt(headCradleElement.style.bottom)\n//         let offsetTop = headCradleElement.offsetTop\n//         styles.left = 'auto'\n//         styles.right = 'auto'\n//         if (scrollforward) {\n//             headpos = offsetTop\n//             styles.top = headpos + 'px'\n//             styles.bottom = 'auto'\n//         } else { // scroll backward\n//             tailpos = offsetTop + offsetHeight\n//             styles.top = 'auto'\n//             styles.bottom = (parentHeight - tailpos) + 'px'\n//         }\n//     } else {\n//         let offsetLeft = headCradleElement.offsetLeft\n//         let offsetWidth = headCradleElement.offsetWidth\n//         let parentWidth = parentElement.offsetWidth\n//         let cssleft = parseInt(headCradleElement.style.left)\n//         let cssright = parseInt(headCradleElement.style.bottom)\n//         styles.top = 'auto'\n//         styles.bottom = 'auto'\n//         if (scrollforward) {\n//             headpos = offsetLeft\n//             styles.left = headpos + 'px'\n//             styles.right = 'auto'\n//         } else { // scroll backward\n//             tailpos = offsetLeft + offsetWidth\n//             styles.left = 'auto'\n//             styles.right = (parentWidth - tailpos) + 'px'\n//         }\n//     }\n//     return [styles, tailstyles]\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9jcmFkbGVmdW5jdGlvbnMudHN4PzA4YWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVhLDJCQUFtQixVQUFDLFVBQUQsRUFBYSxlQUFiLEVBQThCLGFBQTlCLEVBQTZDLFdBQTdDLEVBQXdEO0FBQ3BGLE1BQUksSUFBSSxHQUFHLEVBQVg7QUFDQSxNQUFJLFNBQVMsR0FBRyxhQUFhLENBQUMsU0FBOUI7QUFBQSxNQUNJLFVBQVUsR0FBRyxhQUFhLENBQUMsVUFEL0I7QUFFQSxNQUFJLG9CQUFvQixHQUFHLENBQUMsZUFBZSxDQUFDLFNBQTVDO0FBQUEsTUFDSSxxQkFBcUIsR0FBRyxDQUFDLGVBQWUsQ0FBQyxVQUQ3QztBQUFBLE1BRUksY0FBYyxHQUFHLGVBQWUsQ0FBQyxZQUZyQztBQUFBLE1BR0ksYUFBYSxHQUFHLGVBQWUsQ0FBQyxXQUhwQztBQUFBLE1BSUksaUJBQWlCLEdBQUcsQ0FBQyxvQkFKekI7QUFBQSxNQUtJLG9CQUFvQixHQUFHLENBQUMsb0JBQUQsR0FBd0IsY0FMbkQ7O0FBT0EsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBL0IsRUFBdUMsQ0FBQyxFQUF4QyxFQUE0QztBQUVwQztBQUFBLFFBQUMsYUFBRDtBQUFBLFFBQVEsa0JBQVI7QUFDSixRQUFJLE9BQU8sR0FBRyxVQUFVLENBQUMsT0FBekI7QUFFQSxRQUFJLEtBQUcsR0FBRyxPQUFPLENBQUMsU0FBbEI7QUFBQSxRQUNJLElBQUksR0FBRyxPQUFPLENBQUMsVUFEbkI7QUFBQSxRQUVJLEtBQUssR0FBRyxPQUFPLENBQUMsV0FGcEI7QUFBQSxRQUdJLE1BQU0sR0FBRyxPQUFPLENBQUMsWUFIckI7QUFBQSxRQUlJLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FKbkI7QUFBQSxRQUtJLE1BQU0sR0FBRyxLQUFHLEdBQUcsTUFMbkI7QUFPQSxRQUFJLGFBQWEsR0FBRyxvQkFBb0IsR0FBRyxTQUF2QixHQUFtQyxLQUF2RDtBQUFBLFFBQTREO0FBQ3hELG9CQUFnQixHQUFHLG9CQUFvQixHQUFHLFNBQXZCLEdBQW1DLE1BRDFEO0FBQUEsUUFDa0U7QUFDOUQsa0JBQWMsR0FBRyxxQkFBcUIsR0FBRyxVQUF4QixHQUFxQyxJQUYxRDtBQUFBLFFBR0ksZUFBZSxHQUFHLHFCQUFxQixHQUFHLFVBQXhCLEdBQXFDLEtBSDNEO0FBTUEsUUFBSSxTQUFTLEdBQUcsS0FBaEIsQ0FsQndDLENBa0JsQjs7QUFFdEIsUUFBSSxVQUFVLFNBQWQ7QUFBQSxRQUNJLGFBQWEsU0FEakI7QUFBQSxRQUVJLFdBQVcsU0FGZjtBQUFBLFFBR0ksWUFBWSxTQUhoQjs7QUFLQSxRQUFLLGFBQWEsR0FBRyxDQUFqQixJQUF3QixnQkFBZ0IsR0FBRyxDQUEvQyxFQUFtRDtBQUU5QyxpQkFBVyxJQUFJLFVBQWhCLEtBQWdDLFNBQVMsR0FBRyxJQUE1QztBQUNBLG1CQUFhLEdBQUcsZ0JBQWhCO0FBQ0EsZ0JBQVUsR0FBRyxhQUFhLEdBQUcsTUFBN0I7QUFFSCxLQU5ELE1BTU8sSUFBSyxhQUFhLElBQUksQ0FBbEIsSUFBeUIsZ0JBQWdCLEdBQUcsY0FBaEQsRUFBaUU7QUFFbkUsaUJBQVcsSUFBSSxVQUFoQixLQUFnQyxTQUFTLEdBQUcsSUFBNUM7QUFDQSxnQkFBVSxHQUFHLE1BQWI7QUFDQSxtQkFBYSxHQUFHLENBQWhCO0FBRUgsS0FOTSxNQU1BLElBQUssYUFBYSxHQUFHLENBQWpCLElBQXlCLGFBQWEsR0FBRyxjQUFqQixHQUFtQyxDQUEvRCxFQUFtRTtBQUVyRSxpQkFBVyxJQUFJLFVBQWhCLEtBQWdDLFNBQVMsR0FBRyxJQUE1QztBQUNBLGdCQUFVLEdBQUcsY0FBYyxHQUFHLGFBQTlCO0FBQ0EsbUJBQWEsR0FBRyxVQUFVLEdBQUcsTUFBN0I7QUFFSCxLQU5NLE1BTUE7QUFFSCxVQUFJLFdBQVcsSUFBSSxVQUFuQixFQUErQjtBQUVsQzs7QUFFRCxRQUFJLGNBQWMsR0FBRyxDQUFqQixJQUFzQixlQUFlLEdBQUcsQ0FBNUMsRUFBK0M7QUFFMUMsaUJBQVcsSUFBSSxZQUFoQixLQUFrQyxTQUFTLEdBQUcsSUFBOUM7QUFDQSxrQkFBWSxHQUFHLGVBQWY7QUFDQSxpQkFBVyxHQUFHLFlBQVksR0FBRyxLQUE3QjtBQUVILEtBTkQsTUFNTyxJQUFJLGNBQWMsSUFBSSxDQUFsQixJQUF1QixlQUFlLEdBQUcsYUFBN0MsRUFBNEQ7QUFFOUQsaUJBQVcsSUFBSSxZQUFoQixLQUFrQyxTQUFTLEdBQUcsSUFBOUM7QUFDQSxpQkFBVyxHQUFHLEtBQWQ7QUFDQSxrQkFBWSxHQUFHLENBQWY7QUFFSCxLQU5NLE1BTUEsSUFBSSxjQUFjLEdBQUcsQ0FBakIsSUFBdUIsY0FBYyxHQUFHLGFBQWxCLEdBQW1DLENBQTdELEVBQWdFO0FBRWxFLGlCQUFXLElBQUksWUFBaEIsS0FBa0MsU0FBUyxHQUFHLElBQTlDO0FBQ0EsaUJBQVcsR0FBRyxhQUFhLEdBQUcsY0FBOUI7QUFDQSxrQkFBWSxHQUFHLFdBQVcsR0FBRyxLQUE3QjtBQUVILEtBTk0sTUFNQTtBQUVILFVBQUksV0FBVyxJQUFJLFlBQW5CLEVBQWlDO0FBRXBDOztBQUVELFFBQUksYUFBYSxHQUFJLFVBQVUsR0FBRyxDQUFkLEdBQWlCLFVBQVUsR0FBQyxNQUE1QixHQUFtQyxhQUFhLEdBQUMsTUFBckU7QUFBQSxRQUNJLGVBQWUsR0FBSSxXQUFXLEdBQUcsQ0FBZixHQUFrQixXQUFXLEdBQUMsS0FBOUIsR0FBb0MsWUFBWSxHQUFDLE1BRHZFO0FBR0EsUUFBSSxRQUFRLEdBQUc7QUFFWCxXQUFLLE9BRk07QUFHWCxlQUFTLFdBSEU7QUFLWCxTQUFHLE9BTFE7QUFNWCxXQUFLLE9BTk07QUFPWCxZQUFNLFFBUEs7QUFRWCxVQUFJLE1BUk87QUFTWCxXQUFLLE9BVE07QUFVWCxZQUFNLFFBVks7QUFZWCxtQkFBYSxlQVpGO0FBYVgsc0JBQWdCLGtCQWJMO0FBY1gsZ0JBQVUsWUFkQztBQWVYLG1CQUFhLGVBZkY7QUFpQlgsb0JBQWMsZ0JBakJIO0FBa0JYLHFCQUFlLGlCQWxCSjtBQW1CWCxpQkFBVyxhQW5CQTtBQW9CWCxrQkFBWSxjQXBCRDtBQXNCWCxtQkFBYSxlQXRCRjtBQXVCWCxxQkFBZTtBQXZCSixLQUFmO0FBMkJBLFFBQUksQ0FBQyxJQUFMLENBQVUsUUFBVjtBQUVIOztBQUVELE1BQUksQ0FBQyxJQUFMLENBQVUsVUFBQyxDQUFELEVBQUcsQ0FBSCxFQUFJO0FBQ1YsV0FBUSxDQUFDLENBQUMsS0FBRixHQUFVLENBQUMsQ0FBQyxLQUFwQjtBQUNILEdBRkQ7QUFJQSxTQUFPLElBQVA7QUFDSCxDQTNIWTs7QUE2SEEsZ0NBQXdCLFVBQ2pDLEVBRGlDLEVBS2hDO01BSEcsOEI7TUFDQSxrQztNQUNBLGdDO0FBR0osTUFBSSxXQUFXLEdBQUcsY0FBYyxDQUFDLE9BQWpDO0FBQ0EsTUFBSSxlQUFlLEdBQUcsWUFBWSxDQUFDLFVBQWIsQ0FBd0IsT0FBOUM7QUFDSztBQUFBLE1BQWEsK0JBQWI7QUFDTCxNQUFJLFNBQUosRUFBZSxVQUFmOztBQUNBLE1BQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBRTNCLGFBQVMsR0FBRyxlQUFlLENBQUMsU0FBNUI7QUFDQSxjQUFVLEdBQUcsV0FBVyxDQUFDLFVBQVosR0FBeUIsV0FBVyxDQUFDLEdBQWxEO0FBRUgsR0FMRCxNQUtPO0FBRUgsYUFBUyxHQUFHLGVBQWUsQ0FBQyxVQUE1QjtBQUNBLGNBQVUsR0FBRyxXQUFXLENBQUMsU0FBWixHQUF3QixXQUFXLENBQUMsR0FBakQ7QUFFSDs7QUFFRCxNQUFJLHFCQUFxQixHQUFHLFVBQVUsR0FBSSxTQUFTLEdBQUcsVUFBdEQsQ0FsQkMsQ0FrQmlFOztBQUNsRSxNQUFJLHFCQUFxQixJQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsT0FBdEQsRUFBK0QscUJBQXFCLEdBQUcsQ0FBeEI7QUFFL0QsTUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsSUFBTCxDQUFVLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxPQUF6QixJQUFrQyxVQUE1QyxDQUF4QjtBQUNBLE1BQUksY0FBYyxHQUFHLGlCQUFpQixHQUFHLGFBQWEsQ0FBQyxPQUF2RDtBQUVBLE1BQUksa0JBQWtCLEdBQUc7QUFDckIsU0FBSyxFQUFDLElBQUksQ0FBQyxHQUFMLENBQVMsY0FBVCxFQUF3QixRQUFRLEdBQUcsQ0FBbkMsQ0FEZTtBQUVyQixnQkFBWSxFQUFDO0FBRlEsR0FBekI7QUFLQSxNQUFJLGtCQUFrQixDQUFDLEtBQW5CLElBQTRCLENBQWhDLEVBQW1DLGtCQUFrQixDQUFDLFlBQW5CLEdBQWtDLENBQWxDLENBN0JsQyxDQTZCc0U7O0FBRXZFLFNBQU8sa0JBQVA7QUFDSCxDQXJDWSxDLENBdUNiOzs7QUFDYSxxQ0FBNkIsVUFBQyxFQUFELEVBV3JDO0FBRUQ7TUFaSSw0QjtNQUNBLDBCO01BQ0Esd0I7TUFDQSxzQjtNQUNBLDRCO01BQ0EsWTtNQUNBLHNEO01BQ0EsMEM7TUFDQSwwQjtNQUNBLHNCLENBQ0gsQ0FJRDs7QUFDQSxNQUFJLFVBQUosRUFBZSxjQUFmOztBQUNBLE1BQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBQzNCLGNBQVUsR0FBRyxVQUFVLEdBQUcsR0FBMUIsQ0FEMkIsQ0FFM0I7QUFDSCxHQUhELE1BR087QUFDSCxjQUFVLEdBQUcsU0FBUyxHQUFHLEdBQXpCLENBREcsQ0FFSDtBQUNILEdBWkEsQ0FjRDtBQUNBOzs7QUFDQSxNQUFJLFlBQVksR0FBRyxRQUFRLEdBQUcsVUFBOUIsQ0FoQkMsQ0FnQndDOztBQUN6QyxNQUFJLFlBQVksR0FBRyxRQUFuQixFQUE2QixZQUFZLEdBQUcsUUFBZixDQWpCNUIsQ0FtQkQ7QUFFQTs7QUFDQSxNQUFJLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxVQUFyQztBQUNBLE1BQUksVUFBVSxHQUFHLHdCQUF3QixHQUFHLFVBQTVDO0FBQ0EsTUFBSSxlQUFlLEdBQUcsd0JBQXdCLEdBQUcsVUFBakQsQ0F4QkMsQ0F3QjJEOztBQUU1RCxrQkFBZ0IsSUFBSSxVQUFwQjtBQUNBLGtCQUFnQixHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsZ0JBQVQsRUFBMkIsd0JBQTNCLENBQW5CLENBM0JDLENBMkJ1RTtBQUV4RTtBQUVBOztBQUNBLE1BQUksV0FBVyxHQUFHLHdCQUF3QixHQUFHLGdCQUE3QztBQUNBLE1BQUksSUFBSSxHQUFHLFdBQVcsR0FBRyxVQUF6QjtBQUNBLGFBQVcsSUFBSSxJQUFmLENBbENDLENBb0NEOztBQUVBLE1BQUksR0FBRyxDQUFQO0FBQ0EsTUFBSSxLQUFLLEdBQUcsQ0FBWjs7QUFDQSxNQUFLLFdBQVcsR0FBRyxZQUFmLEdBQStCLFFBQW5DLEVBQTZDO0FBQ3pDLFFBQUksR0FBSSxXQUFXLEdBQUcsWUFBZixHQUErQixRQUF0QztBQUNBLFNBQUssR0FBRyxJQUFJLEdBQUcsVUFBZjtBQUNIOztBQUVELE1BQUksSUFBSixFQUFVO0FBQ04sZUFBVyxJQUFLLElBQUksR0FBRyxLQUF2QjtBQUNBLGdCQUFZLElBQUksS0FBaEI7QUFDSCxHQWhEQSxDQWtERDs7O0FBRUEsTUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxXQUFXLEdBQUMsVUFBdkIsQ0FBckI7QUFDQSxNQUFJLFlBQVksR0FBRyxjQUFjLEdBQUcsVUFBcEM7QUFFQSxNQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLHdCQUF3QixHQUFDLFVBQXBDLENBQXRCO0FBRUEsTUFBSSxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsVUFBN0M7QUFDQSxNQUFJLGlCQUFpQixHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFXLG9CQUFvQixHQUFHLGtCQUFsQyxDQUF4QjtBQUVBLFNBQU87QUFBQyxlQUFXLGFBQVo7QUFBYyxtQkFBZSxpQkFBN0I7QUFBK0IsZ0JBQVksY0FBM0M7QUFBNkMscUJBQWlCLG1CQUE5RDtBQUFnRSxnQkFBWTtBQUE1RSxHQUFQLENBNURDLENBNERvRjtBQUV4RixDQXpFWSxDLENBMkViOzs7QUFDYSx1Q0FBK0IsVUFBQyxFQUFELEVBSTNDO01BSEcsZ0M7TUFDQSw0QjtNQUNBLDRCO0FBR0EsTUFBSSxXQUFXLEdBQUcsRUFBbEI7QUFBQSxNQUNJLFdBQVcsR0FBRyxFQURsQjtBQUFBLE1BRUksdUJBQXVCLEdBQUcsRUFGOUI7QUFBQSxNQUdJLGlCQUFpQixHQUFHLEVBSHhCO0FBQUEsTUFJSSx1QkFBdUIsR0FBRyxFQUo5QjtBQUFBLE1BS0ksaUJBQWlCLEdBQUcsRUFMeEI7QUFBQSxNQU1JLFlBQVksR0FBTyxFQU52QjtBQUFBLE1BT0kscUJBQXFCLEdBQUcsRUFQNUI7O0FBU0EsT0FBaUIsdUNBQWpCLEVBQWlCLHlCQUFqQixFQUFpQixJQUFqQixFQUE4QjtBQUF6QixRQUFJLElBQUksb0JBQVI7QUFDRCxlQUFXLENBQUMsSUFBWixDQUFpQixJQUFJLENBQUMsS0FBTCxDQUFXLEtBQTVCO0FBQ0g7O0FBRUQsT0FBaUIsdUNBQWpCLEVBQWlCLHlCQUFqQixFQUFpQixJQUFqQixFQUE4QjtBQUF6QixRQUFJLElBQUksb0JBQVI7QUFDRCxlQUFXLENBQUMsSUFBWixDQUFpQixJQUFJLENBQUMsS0FBTCxDQUFXLEtBQTVCO0FBQ0g7O0FBRUQsT0FBa0IsMkNBQWxCLEVBQWtCLDJCQUFsQixFQUFrQixJQUFsQixFQUFpQztBQUE1QixRQUFJLEtBQUssc0JBQVQ7QUFDRCxRQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU4sQ0FBYSxPQUFiLENBQXFCLEtBQXRCLENBQXBCOztBQUNBLFFBQUksV0FBVyxDQUFDLFFBQVosQ0FBcUIsS0FBckIsQ0FBSixFQUFpQztBQUM3Qiw2QkFBdUIsQ0FBQyxJQUF4QixDQUE2QixLQUE3QjtBQUNBLHVCQUFpQixDQUFDLElBQWxCLENBQXVCLEtBQXZCO0FBQ0gsS0FIRCxNQUdPLElBQUksV0FBVyxDQUFDLFFBQVosQ0FBcUIsS0FBckIsQ0FBSixFQUFpQztBQUNwQyw2QkFBdUIsQ0FBQyxJQUF4QixDQUE2QixLQUE3QjtBQUNBLHVCQUFpQixDQUFDLElBQWxCLENBQXVCLEtBQXZCO0FBQ0gsS0FITSxNQUdBO0FBQ0gsYUFERyxDQUNJO0FBQ1Y7O0FBQ0QsZ0JBQVksQ0FBQyxLQUFELENBQVosR0FBc0IsS0FBSyxDQUFDLGNBQTVCO0FBQ0gsR0EvQkosQ0FpQ0c7OztBQUNBLE1BQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsTUFBWixHQUFxQixDQUF0QixDQUEzQjtBQUNBLE1BQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxDQUFELENBQTNCO0FBQ0EsTUFBSSxPQUFPLEdBQUcsdUJBQXVCLENBQUMsT0FBeEIsQ0FBZ0MsU0FBaEMsQ0FBZDtBQUNBLE1BQUksT0FBTyxHQUFHLHVCQUF1QixDQUFDLE9BQXhCLENBQWdDLFNBQWhDLENBQWQsQ0FyQ0gsQ0FzQ0c7O0FBQ0EsTUFBSyxPQUFPLElBQUcsQ0FBWCxJQUFpQixDQUFDLFlBQVksQ0FBQyxTQUFELENBQWxDLEVBQStDO0FBQzNDLFdBQU8sR0FBRyxDQUFDLENBQVg7QUFDSDs7QUFFRCxNQUFLLE9BQU8sSUFBRyxDQUFYLElBQWlCLFlBQVksQ0FBQyxTQUFELENBQWpDLEVBQThDO0FBQzFDLFdBQU8sR0FBRyxDQUFDLENBQVg7QUFDSDs7QUFFRCxNQUFJLE9BQU8sSUFBSSxDQUFmLEVBQWtCO0FBQ2QsUUFBSSxRQUFRLEdBQUcsdUJBQXVCLENBQUMsT0FBRCxDQUF2QixHQUFtQyxDQUFsRDtBQUNBLFFBQUksZUFBZSxHQUFHLFlBQVksQ0FBQyxRQUFRLEdBQUcsQ0FBWixDQUFsQyxDQUZjLENBR2Q7O0FBQ0EsU0FBSyxJQUFJLEdBQUcsR0FBRyxPQUFmLEVBQXdCLEdBQUcsSUFBSSxDQUEvQixFQUFrQyxHQUFHLEVBQXJDLEVBQXlDO0FBQ3JDLFVBQUksS0FBSyxHQUFHLHVCQUF1QixDQUFDLEdBQUQsQ0FBbkMsQ0FEcUMsQ0FFckM7QUFDQTs7QUFDQSxVQUFNLEtBQUssR0FBRyxDQUFULElBQWUsUUFBaEIsSUFBOEIsWUFBWSxDQUFDLEtBQUQsQ0FBWixJQUF1QixlQUF6RCxFQUEyRTtBQUN2RTtBQUNBLDZCQUFxQixDQUFDLElBQXRCLENBQTJCLGlCQUFpQixDQUFDLEdBQUQsQ0FBNUM7QUFDSCxPQUhELE1BR087QUFDSDtBQUNIOztBQUNELGNBQVEsR0FBRyxLQUFYO0FBQ0EscUJBQWUsR0FBRyxZQUFZLENBQUMsUUFBRCxDQUE5QjtBQUNIO0FBQ0o7O0FBRUQsTUFBSSxPQUFPLElBQUksQ0FBZixFQUFrQjtBQUNkLFFBQUksUUFBUSxHQUFHLHVCQUF1QixDQUFDLE9BQUQsQ0FBdkIsR0FBbUMsQ0FBbEQ7QUFDQSxRQUFJLGVBQWUsR0FBRyxZQUFZLENBQUMsUUFBUSxHQUFHLENBQVosQ0FBbEMsQ0FGYyxDQUdkOztBQUNBLFNBQUssSUFBSSxHQUFHLEdBQUcsT0FBZixFQUF3QixHQUFHLEdBQUcsdUJBQXVCLENBQUMsTUFBdEQsRUFBOEQsR0FBRyxFQUFqRSxFQUFxRTtBQUNqRSxVQUFJLEtBQUssR0FBRyx1QkFBdUIsQ0FBQyxHQUFELENBQW5DLENBRGlFLENBRWpFO0FBQ0E7O0FBQ0EsVUFBTSxLQUFLLEdBQUcsQ0FBVCxJQUFlLFFBQWhCLElBQThCLFlBQVksQ0FBQyxLQUFELENBQVosSUFBdUIsZUFBekQsRUFBMkU7QUFDdkU7QUFDQSw2QkFBcUIsQ0FBQyxJQUF0QixDQUEyQixpQkFBaUIsQ0FBQyxHQUFELENBQTVDO0FBQ0gsT0FIRCxNQUdPO0FBQ0g7QUFDSDs7QUFDRCxjQUFRLEdBQUcsS0FBWDtBQUNBLHFCQUFlLEdBQUcsWUFBWSxDQUFDLEtBQUQsQ0FBOUI7QUFDSDtBQUNKLEdBbkZKLENBcUZHO0FBQ0E7OztBQUVBLFNBQU8scUJBQVA7QUFFSCxDQTlGWSxDLENBZ0diO0FBQ0E7QUFDQTs7O0FBQ2EsMkJBQW1CLFVBQUMsS0FBRCxFQUFNO0FBSTlCO0FBQUEsTUFDQSxxQ0FEQTtBQUFBLE1BRUEscUNBRkE7QUFBQSxNQUdBLCtCQUhBO0FBQUEsTUFJQSw2QkFKQTtBQUFBLE1BS0EsMkJBTEE7QUFBQSxNQU1BLG9DQU5BO0FBQUEsTUFPQSw2QkFQQTtBQUFBLE1BUUEseUJBUkE7QUFBQSxNQVVBLDJCQVZBO0FBQUEsTUFXQSx1QkFYQTtBQUFBLE1BWUEsK0JBWkE7QUFBQSxNQWFBLHlCQWJBOztBQWdCSixNQUFJLGdCQUFnQixrQkFBTyxXQUFQLENBQXBCOztBQUNBLE1BQUksZUFBZSxHQUFHLFdBQVcsR0FBRyxXQUFXLENBQUMsTUFBaEQ7QUFDQSxNQUFJLGlCQUFKO0FBRUEsTUFBSSxlQUFlLEdBQUcsRUFBdEI7O0FBRUEsTUFBSSxjQUFjLElBQUksQ0FBdEIsRUFBeUI7QUFFckIsU0FBSyxJQUFJLEtBQUssR0FBRyxXQUFXLEdBQUcsY0FBL0IsRUFBK0MsS0FBSyxHQUFJLFdBQXhELEVBQXNFLEtBQUssRUFBM0UsRUFBK0U7QUFFM0UscUJBQWUsQ0FBQyxJQUFoQixDQUNJLFFBQVEsQ0FDSjtBQUNJLGFBQUssT0FEVDtBQUVJLG1CQUFXLGFBRmY7QUFHSSxrQkFBVSxZQUhkO0FBSUksaUJBQVMsV0FKYjtBQUtJLGdCQUFRLFVBTFo7QUFNSSxpQkFBUyxXQU5iO0FBT0ksZUFBTyxTQVBYO0FBUUksZ0JBQVEsVUFSWjtBQVNJLG1CQUFXO0FBVGYsT0FESSxDQURaO0FBZ0JIO0FBRUosR0F0QkQsTUFzQk87QUFFSCxvQkFBZ0IsQ0FBQyxNQUFqQixDQUF3QixDQUF4QixFQUEwQixDQUFDLGNBQTNCO0FBRUg7O0FBRUQsTUFBSSxlQUFlLEdBQUcsRUFBdEI7O0FBRUEsTUFBSSxjQUFjLElBQUksQ0FBdEIsRUFBeUI7QUFFckIsU0FBSyxJQUFJLEtBQUssR0FBRyxlQUFqQixFQUFrQyxLQUFLLEdBQUcsZUFBZSxHQUFHLGNBQTVELEVBQTZFLEtBQUssRUFBbEYsRUFBc0Y7QUFFbEYscUJBQWUsQ0FBQyxJQUFoQixDQUNJLFFBQVEsQ0FDSjtBQUNJLGFBQUssT0FEVDtBQUVJLG1CQUFXLGFBRmY7QUFHSSxrQkFBVSxZQUhkO0FBSUksaUJBQVMsV0FKYjtBQUtJLGdCQUFRLFVBTFo7QUFNSSxpQkFBUyxXQU5iO0FBT0ksZUFBTyxTQVBYO0FBUUksZ0JBQVEsVUFSWjtBQVNJLG1CQUFXO0FBVGYsT0FESSxDQURaO0FBZ0JIO0FBRUosR0F0QkQsTUFzQk87QUFFSCxvQkFBZ0IsQ0FBQyxNQUFqQixDQUF3QixjQUF4QixFQUF1QyxDQUFDLGNBQXhDO0FBRUg7O0FBRUQsbUJBQWlCLEdBQUcsZUFBZSxDQUFDLE1BQWhCLENBQXVCLGdCQUF2QixFQUF3QyxlQUF4QyxDQUFwQjtBQUVBLFNBQU8saUJBQVA7QUFDSCxDQXZGWSxDLENBeUZiOzs7QUFDYSw4QkFBc0IsVUFDL0IsRUFEK0IsRUFROUI7TUFMRyw0QjtNQUFhO0FBQ2IsOEI7TUFBYTtBQUNiLG9DO01BQWdCO0FBQ2hCLDRCO0FBS0osTUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLENBQUQsQ0FBWCxDQUFlLEtBQWYsQ0FBcUIsS0FBdkM7QUFDQSxNQUFJLGVBQWUsR0FBRyxXQUFXLENBQUUsV0FBVyxHQUFHLFVBQWYsR0FBNkIsQ0FBOUIsQ0FBWCxDQUE0QyxLQUE1QyxDQUFrRCxLQUF4RTtBQUNBLE1BQUksYUFBSixDQUxDLENBT0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxlQUFhLEdBQUksY0FBYyxHQUFHLFdBQWxDO0FBRUEsTUFBSSxRQUFRLEdBQUcsV0FBVyxDQUFDLEtBQVosQ0FBa0IsQ0FBbEIsRUFBb0IsYUFBcEIsQ0FBZjtBQUNBLE1BQUksUUFBUSxHQUFHLFdBQVcsQ0FBQyxLQUFaLENBQWtCLGFBQWxCLENBQWYsQ0FmQyxDQWlCRDs7QUFFQSxTQUFPLENBQUMsUUFBRCxFQUFVLFFBQVYsQ0FBUDtBQUVILENBN0JZOztBQStCQSx5QkFBaUIsVUFDMUIsRUFEMEIsRUFVekI7QUFFRDtNQVZJLGdDO01BQ0EsOEI7TUFDQSw0QjtNQUNBLDhCO01BQ0Esa0M7TUFDQSwwQjtNQUNBLFk7TUFDQSxrQztBQUtKLE1BQUksWUFBSixFQUFpQixXQUFqQjtBQUNBLE1BQUksYUFBYSxHQUFHLGNBQXBCOztBQUNBLE1BQUksQ0FBQyxhQUFMLEVBQW9CO0FBQ2hCO0FBQ0EsaUJBQWEsSUFBSSxjQUFqQjtBQUNIOztBQUNELE1BQUksZ0JBQWdCLEdBQUcsRUFBdkI7O0FBQ0EsTUFBSSxhQUFKLEVBQW1CO0FBQ2Ysb0JBQWdCLENBQUMsSUFBakIsQ0FBc0IsWUFBWSxDQUFDLEdBQWIsQ0FBaUIsYUFBakIsQ0FBdEI7QUFDSCxHQUZELE1BRU87QUFDSCxTQUFLLElBQUksS0FBSyxHQUFHLGFBQWpCLEVBQWdDLEtBQUssR0FBRyxjQUF4QyxFQUF3RCxLQUFLLElBQUksVUFBakUsRUFBOEU7QUFDMUUsc0JBQWdCLENBQUMsSUFBakIsQ0FBc0IsWUFBWSxDQUFDLEdBQWIsQ0FBaUIsS0FBakIsQ0FBdEI7QUFDSDtBQUNKOztBQUNELE1BQUksaUJBQUo7O0FBRUEsTUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFDM0IsZ0JBQVksR0FBRyxZQUFZLENBQUMsU0FBNUI7QUFDSCxHQUZELE1BRU87QUFDSCxnQkFBWSxHQUFHLFlBQVksQ0FBQyxVQUE1QjtBQUNIOztBQUNELE1BQUksYUFBSixFQUFtQjtBQUNmLFFBQUksZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixDQUFvQixPQUEzQzs7QUFDQSxRQUFJLGdCQUFKLEVBQXNCO0FBQ2xCO0FBQ0EsVUFBSSxXQUFXLElBQUksVUFBbkIsRUFBK0I7QUFDM0IseUJBQWlCLEdBQUcsZ0JBQWdCLENBQUMsU0FBckM7QUFDSCxPQUZELE1BRU87QUFDSCx5QkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxVQUFyQztBQUNIO0FBQ0o7QUFDSixHQVZELE1BVU87QUFDSCxxQkFBaUIsR0FBRyxDQUFwQjs7QUFDQSxTQUFtQixpREFBbkIsRUFBbUIsOEJBQW5CLEVBQW1CLElBQW5CLEVBQXFDO0FBQWhDLFVBQUksTUFBTSx5QkFBVjs7QUFDRCxVQUFJLFdBQVcsSUFBSSxVQUFuQixFQUErQjtBQUMzQix5QkFBaUIsSUFBSSxNQUFNLENBQUMsT0FBUCxDQUFlLFlBQWYsR0FBOEIsR0FBbkQ7QUFDSCxPQUZELE1BRU87QUFDSCx5QkFBaUIsSUFBSSxNQUFNLENBQUMsT0FBUCxDQUFlLFdBQWYsR0FBNkIsR0FBbEQ7QUFDSDtBQUNKO0FBQ0osR0E1Q0EsQ0E2Q0Q7QUFDQTs7O0FBRUEsTUFBSSxhQUFKLEVBQW1CO0FBQ2YsZUFBVyxHQUFHLFlBQVksR0FBRyxpQkFBN0I7QUFDSCxHQUZELE1BRU87QUFDSCxlQUFXLEdBQUcsWUFBWSxHQUFHLGlCQUE3QjtBQUNILEdBcERBLENBc0REO0FBQ0E7QUFFQTs7O0FBRUEsU0FBTyxXQUFQO0FBQ0gsQ0F0RVk7O0FBd0ViLElBQU0sUUFBUSxHQUFHLFNBQVgsUUFBVyxDQUFDLEVBQUQsRUFVaEI7TUFURyxnQjtNQUNBLDRCO01BQ0EsMEI7TUFDQSx3QjtNQUNBLHNCO01BQ0Esd0I7TUFDQSxvQjtNQUNBLHNCO01BQ0EsNEI7QUFHQSxTQUFPLGlDQUFDLHNCQUFELEVBQVU7QUFDYixPQUFHLEVBQUksS0FETTtBQUViLGVBQVcsRUFBSSxXQUZGO0FBR2IsY0FBVSxFQUFLLFVBSEY7QUFJYixhQUFTLEVBQUssU0FKRDtBQUtiLFNBQUssRUFBSSxLQUxJO0FBTWIsWUFBUSxFQUFJLFFBTkM7QUFPYixhQUFTLEVBQUksU0FQQTtBQVFiLFdBQU8sRUFBSSxPQVJFO0FBU2IsWUFBUSxFQUFJLFFBVEM7QUFVYixlQUFXLEVBQUs7QUFWSCxHQUFWLENBQVA7QUFhSCxDQXpCRCxDLENBMEJBO0FBQ0E7QUFDQTs7O0FBRWEsOEJBQXNCLFVBQUMsRUFBRCxFQWFsQztNQVhHLDRCO01BQ0Esc0M7TUFDQSxzQztNQUNBLDBCO01BQ0Esd0I7TUFDQSxZO01BQ0Esb0I7TUFDQSwwQjtNQUNBLGtDO01BQ0EsZ0M7O0FBSUksTUFBSSxVQUFVLEdBQUcsYUFBSSxnQkFBSixDQUFqQjs7QUFDQSxNQUFJLFVBQVUsR0FBRyxhQUFJLGdCQUFKLENBQWpCOztBQUVBLFlBQVUsQ0FBQyxPQUFYLEdBQXFCLEdBQUcsR0FBRyxJQUEzQjtBQUVBLFlBQVUsQ0FBQyxPQUFYLEdBQXFCLEdBQUcsR0FBRyxJQUEzQjs7QUFFQSxNQUFJLFdBQVcsSUFBSSxZQUFuQixFQUFpQztBQUU3QixjQUFVLENBQUMsT0FBWCxHQUF3QixPQUFPLFVBQVAsR0FBZSxPQUFmLEdBQXNCLEtBQXRCLEdBQTRCLE9BQTVCLEdBQW1DLElBQTNEO0FBRUEsY0FBVSxDQUFDLEtBQVgsR0FBbUIsTUFBbkI7QUFDQSxjQUFVLENBQUMsTUFBWCxHQUFvQixNQUFwQjtBQUNBLGNBQVUsQ0FBQyxZQUFYLEdBQTBCLFFBQTFCLENBTjZCLENBTzdCO0FBQ0E7O0FBQ0EsY0FBVSxDQUFDLGdCQUFYLEdBQThCLFVBQVUsR0FBQyxZQUFVLFVBQVYsR0FBb0IsV0FBcEIsR0FBZ0MsVUFBaEMsR0FBMEMsV0FBM0MsR0FBdUQsTUFBL0Y7QUFDQSxjQUFVLENBQUMsbUJBQVgsR0FBaUMsTUFBakM7QUFFQSxjQUFVLENBQUMsT0FBWCxHQUF3QixPQUFPLFFBQVAsR0FBYSxPQUFiLEdBQW9CLEtBQXBCLEdBQTBCLE9BQTFCLEdBQWlDLE1BQXpEO0FBRUEsY0FBVSxDQUFDLEtBQVgsR0FBbUIsTUFBbkI7QUFDQSxjQUFVLENBQUMsTUFBWCxHQUFvQixNQUFwQjtBQUNBLGNBQVUsQ0FBQyxZQUFYLEdBQTBCLFFBQTFCLENBaEI2QixDQWlCN0I7QUFDQTs7QUFDQSxjQUFVLENBQUMsZ0JBQVgsR0FBOEIsVUFBVSxHQUFDLFlBQVUsVUFBVixHQUFvQixXQUFwQixHQUFnQyxVQUFoQyxHQUEwQyxXQUEzQyxHQUF1RCxNQUEvRjtBQUNBLGNBQVUsQ0FBQyxtQkFBWCxHQUFpQyxNQUFqQztBQUVILEdBdEJELE1Bc0JPLElBQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBRWxDLGNBQVUsQ0FBQyxPQUFYLEdBQXdCLE9BQU8sUUFBUCxHQUFhLE9BQWIsR0FBb0IsT0FBcEIsR0FBNEIsT0FBNUIsR0FBbUMsSUFBM0Q7QUFFQSxjQUFVLENBQUMsS0FBWCxHQUFtQixNQUFuQjtBQUNBLGNBQVUsQ0FBQyxNQUFYLEdBQW9CLE1BQXBCO0FBQ0EsY0FBVSxDQUFDLFlBQVgsR0FBMEIsS0FBMUI7QUFFQSxjQUFVLENBQUMsZ0JBQVgsR0FBOEIsTUFBOUI7QUFDQSxjQUFVLENBQUMsbUJBQVgsR0FBaUMsU0FBUyxHQUFDLDZCQUEyQixTQUEzQixHQUFvQyxXQUFyQyxHQUFpRCxNQUEzRjtBQUVBLGNBQVUsQ0FBQyxPQUFYLEdBQXFCLE9BQUssT0FBTCxHQUFZLEtBQVosR0FBa0IsT0FBbEIsR0FBeUIsS0FBekIsR0FBK0IsT0FBL0IsR0FBc0MsSUFBM0Q7QUFFQSxjQUFVLENBQUMsS0FBWCxHQUFtQixNQUFuQjtBQUNBLGNBQVUsQ0FBQyxNQUFYLEdBQW9CLE1BQXBCO0FBQ0EsY0FBVSxDQUFDLFlBQVgsR0FBMEIsS0FBMUI7QUFFQSxjQUFVLENBQUMsZ0JBQVgsR0FBOEIsTUFBOUI7QUFDQSxjQUFVLENBQUMsbUJBQVgsR0FBaUMsU0FBUyxHQUFDLDZCQUEyQixTQUEzQixHQUFvQyxXQUFyQyxHQUFpRCxNQUEzRjtBQUNIOztBQUVELFNBQU8sQ0FBQyxVQUFELEVBQVksVUFBWixDQUFQO0FBRVAsQ0FuRVksQyxDQXFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUEiLCJmaWxlIjoiLi9zcmMvY3JhZGxlZnVuY3Rpb25zLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNyYWRsZWZ1bmN0aW9ucy50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTVVBQT1JUSU5HIEZVTkNUSU9OUyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBJdGVtU2hlbGwgZnJvbSAnLi9pdGVtc2hlbGwnXG5cbmV4cG9ydCBjb25zdCBjYWxjVmlzaWJsZUl0ZW1zID0gKGl0ZW1zQXJyYXksIHZpZXdwb3J0RWxlbWVudCwgY3JhZGxlRWxlbWVudCwgb3JpZW50YXRpb24pID0+IHtcbiAgICBsZXQgbGlzdCA9IFtdXG4gICAgbGV0IGNyYWRsZVRvcCA9IGNyYWRsZUVsZW1lbnQub2Zmc2V0VG9wLCBcbiAgICAgICAgY3JhZGxlTGVmdCA9IGNyYWRsZUVsZW1lbnQub2Zmc2V0TGVmdFxuICAgIGxldCBzY3JvbGxibG9ja1RvcE9mZnNldCA9IC12aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wLCBcbiAgICAgICAgc2Nyb2xsYmxvY2tMZWZ0T2Zmc2V0ID0gLXZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICB2aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydEVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgIHZpZXdwb3J0VG9wT2Zmc2V0ID0gLXNjcm9sbGJsb2NrVG9wT2Zmc2V0LFxuICAgICAgICB2aWV3cG9ydEJvdHRvbU9mZnNldCA9IC1zY3JvbGxibG9ja1RvcE9mZnNldCArIHZpZXdwb3J0SGVpZ2h0XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zQXJyYXkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBsZXQgW2luZGV4LCBlbGVtZW50UmVmXSA9IGl0ZW1zQXJyYXlbaV1cbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgdG9wID0gZWxlbWVudC5vZmZzZXRUb3AsIFxuICAgICAgICAgICAgbGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCwgXG4gICAgICAgICAgICB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICByaWdodCA9IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodFxuXG4gICAgICAgIGxldCBpdGVtVG9wT2Zmc2V0ID0gc2Nyb2xsYmxvY2tUb3BPZmZzZXQgKyBjcmFkbGVUb3AgKyB0b3AsIC8vIG9mZnNldCBmcm9tIHRvcCBvZiB2aWV3cG9ydFxuICAgICAgICAgICAgaXRlbUJvdHRvbU9mZnNldCA9IHNjcm9sbGJsb2NrVG9wT2Zmc2V0ICsgY3JhZGxlVG9wICsgYm90dG9tLCAvLyBvZmZzZXQgZnJvbSB0b3Agb2Ygdmlld3BvcnRcbiAgICAgICAgICAgIGl0ZW1MZWZ0T2Zmc2V0ID0gc2Nyb2xsYmxvY2tMZWZ0T2Zmc2V0ICsgY3JhZGxlTGVmdCArIGxlZnQsIFxuICAgICAgICAgICAgaXRlbVJpZ2h0T2Zmc2V0ID0gc2Nyb2xsYmxvY2tMZWZ0T2Zmc2V0ICsgY3JhZGxlTGVmdCArIHJpZ2h0IFxuXG5cbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlIC8vIGRlZmF1bHRcblxuICAgICAgICBsZXQgdG9wUG9ydGlvbixcbiAgICAgICAgICAgIGJvdHRvbVBvcnRpb24sXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbixcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvblxuXG4gICAgICAgIGlmICgoaXRlbVRvcE9mZnNldCA8IDApICYmIChpdGVtQm90dG9tT2Zmc2V0ID4gMCkpIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpICYmIChpc1Zpc2libGUgPSB0cnVlKVxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbiA9IGl0ZW1Cb3R0b21PZmZzZXRcbiAgICAgICAgICAgIHRvcFBvcnRpb24gPSBib3R0b21Qb3J0aW9uIC0gaGVpZ2h0XG5cbiAgICAgICAgfSBlbHNlIGlmICgoaXRlbVRvcE9mZnNldCA+PSAwKSAmJiAoaXRlbUJvdHRvbU9mZnNldCA8IHZpZXdwb3J0SGVpZ2h0KSkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICB0b3BQb3J0aW9uID0gaGVpZ2h0XG4gICAgICAgICAgICBib3R0b21Qb3J0aW9uID0gMFxuXG4gICAgICAgIH0gZWxzZSBpZiAoKGl0ZW1Ub3BPZmZzZXQgPiAwKSAmJiAoKGl0ZW1Ub3BPZmZzZXQgLSB2aWV3cG9ydEhlaWdodCkgPCAwKSkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICB0b3BQb3J0aW9uID0gdmlld3BvcnRIZWlnaHQgLSBpdGVtVG9wT2Zmc2V0XG4gICAgICAgICAgICBib3R0b21Qb3J0aW9uID0gdG9wUG9ydGlvbiAtIGhlaWdodFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSBjb250aW51ZVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbUxlZnRPZmZzZXQgPCAwICYmIGl0ZW1SaWdodE9mZnNldCA+IDApIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICByaWdodFBvcnRpb24gPSBpdGVtUmlnaHRPZmZzZXRcbiAgICAgICAgICAgIGxlZnRQb3J0aW9uID0gcmlnaHRQb3J0aW9uIC0gd2lkdGhcblxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1MZWZ0T2Zmc2V0ID49IDAgJiYgaXRlbVJpZ2h0T2Zmc2V0IDwgdmlld3BvcnRXaWR0aCkge1xuXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSAmJiAoaXNWaXNpYmxlID0gdHJ1ZSlcbiAgICAgICAgICAgIGxlZnRQb3J0aW9uID0gd2lkdGhcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvbiA9IDBcblxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1MZWZ0T2Zmc2V0ID4gMCAmJiAoaXRlbUxlZnRPZmZzZXQgLSB2aWV3cG9ydFdpZHRoKSA8IDApIHtcblxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJykgJiYgKGlzVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbiA9IHZpZXdwb3J0V2lkdGggLSBpdGVtTGVmdE9mZnNldFxuICAgICAgICAgICAgcmlnaHRQb3J0aW9uID0gbGVmdFBvcnRpb24gLSB3aWR0aFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIGNvbnRpbnVlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2ZXJ0aWNhbFJhdGlvID0gKHRvcFBvcnRpb24gPiAwKT90b3BQb3J0aW9uL2hlaWdodDpib3R0b21Qb3J0aW9uL2hlaWdodCxcbiAgICAgICAgICAgIGhvcml6b250YWxSYXRpbyA9IChsZWZ0UG9ydGlvbiA+IDApP2xlZnRQb3J0aW9uL3dpZHRoOnJpZ2h0UG9ydGlvbi9oZWlnaHRcblxuICAgICAgICBsZXQgaXRlbURhdGEgPSB7XG5cbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXNWaXNpYmxlLFxuXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcblxuICAgICAgICAgICAgaXRlbVRvcE9mZnNldCxcbiAgICAgICAgICAgIGl0ZW1Cb3R0b21PZmZzZXQsXG4gICAgICAgICAgICB0b3BQb3J0aW9uLFxuICAgICAgICAgICAgYm90dG9tUG9ydGlvbixcblxuICAgICAgICAgICAgaXRlbUxlZnRPZmZzZXQsXG4gICAgICAgICAgICBpdGVtUmlnaHRPZmZzZXQsXG4gICAgICAgICAgICBsZWZ0UG9ydGlvbixcbiAgICAgICAgICAgIHJpZ2h0UG9ydGlvbixcblxuICAgICAgICAgICAgdmVydGljYWxSYXRpbyxcbiAgICAgICAgICAgIGhvcml6b250YWxSYXRpbyxcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW1EYXRhKVxuXG4gICAgfVxuXG4gICAgbGlzdC5zb3J0KChhLGIpID0+IHtcbiAgICAgICAgcmV0dXJuIChhLmluZGV4IC0gYi5pbmRleClcbiAgICB9KVxuXG4gICAgcmV0dXJuIGxpc3Rcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJlZmVyZW5jZUluZGV4RGF0YSA9IChcbiAgICB7XG4gICAgICAgIHZpZXdwb3J0RGF0YSxcbiAgICAgICAgY3JhZGxlUHJvcHNSZWYsXG4gICAgICAgIGNyb3NzY291bnRSZWYsXG4gICAgfSkgPT4ge1xuXG4gICAgbGV0IGNyYWRsZVByb3BzID0gY3JhZGxlUHJvcHNSZWYuY3VycmVudFxuICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydERhdGEuZWxlbWVudHJlZi5jdXJyZW50XG4gICAgbGV0IHtvcmllbnRhdGlvbiwgbGlzdHNpemV9ID0gY3JhZGxlUHJvcHNcbiAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsSGVpZ2h0ICsgY3JhZGxlUHJvcHMuZ2FwXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVQcm9wcy5jZWxsV2lkdGggKyBjcmFkbGVQcm9wcy5nYXBcblxuICAgIH1cblxuICAgIGxldCByZWZlcmVuY2VzY3JvbGxvZmZzZXQgPSBjZWxsTGVuZ3RoIC0gKHNjcm9sbFBvcyAlIGNlbGxMZW5ndGgpIC8vICsgY2VsbFNwZWNzLnBhZGRpbmdcbiAgICBpZiAocmVmZXJlbmNlc2Nyb2xsb2Zmc2V0ID09IGNlbGxMZW5ndGggKyBjcmFkbGVQcm9wcy5wYWRkaW5nKSByZWZlcmVuY2VzY3JvbGxvZmZzZXQgPSAwXG5cbiAgICBsZXQgcmVmZXJlbmNlcm93aW5kZXggPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVByb3BzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG4gICAgbGV0IHJlZmVyZW5jZWluZGV4ID0gcmVmZXJlbmNlcm93aW5kZXggKiBjcm9zc2NvdW50UmVmLmN1cnJlbnRcblxuICAgIGxldCByZWZlcmVuY2VJbmRleERhdGEgPSB7XG4gICAgICAgIGluZGV4Ok1hdGgubWluKHJlZmVyZW5jZWluZGV4LGxpc3RzaXplIC0gMSksXG4gICAgICAgIHNjcm9sbG9mZnNldDpyZWZlcmVuY2VzY3JvbGxvZmZzZXRcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlSW5kZXhEYXRhLmluZGV4ID09IDApIHJlZmVyZW5jZUluZGV4RGF0YS5zY3JvbGxvZmZzZXQgPSAwIC8vIGRlZmVuc2l2ZVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZUluZGV4RGF0YVxufVxuXG4vLyBldmFsdWF0ZSBjb250ZW50IGZvciByZXF1aXJlbWVudHNcbmV4cG9ydCBjb25zdCBnZXRDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7XG4gICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgIHJvd2NvdW50LFxuICAgICAgICBydW53YXljb3VudCxcbiAgICAgICAgZ2FwLFxuICAgICAgICB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQsXG4gICAgICAgIHRhcmdldFNjcm9sbE9mZnNldCxcbiAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLVsgY2FsYyBiYXNpYyBpbnB1dHM6IGNlbGxMZW5ndGgsIGNvbnRlbnRDb3VudC4gXS0tLS0tLS0tLS1cblxuICAgIC8vIGxldCBjcmFkbGVDb250ZW50TGVuZ3RoLCBjZWxsTGVuZ3RoLCB2aWV3cG9ydGxlbmd0aFxuICAgIGxldCBjZWxsTGVuZ3RoLHZpZXdwb3J0bGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgLy8gdmlld3BvcnRsZW5ndGggPSB2aWV3cG9ydGhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsV2lkdGggKyBnYXBcbiAgICAgICAgLy8gdmlld3BvcnRsZW5ndGggPSB2aWV3cG9ydHdpZHRoXG4gICAgfVxuXG4gICAgLy8gY3JhZGxlQ29udGVudExlbmd0aCA9IHZpZXdwb3J0bGVuZ3RoICsgKHJ1bndheWxlbmd0aCAqIDIpXG4gICAgLy8gbGV0IGNyYWRsZXJvd2NvdW50ID0gTWF0aC5jZWlsKGNyYWRsZUNvbnRlbnRMZW5ndGgvY2VsbExlbmd0aClcbiAgICBsZXQgY29udGVudENvdW50ID0gcm93Y291bnQgKiBjcm9zc2NvdW50IC8vIGNyYWRsZXJvd2NvdW50ICogY3Jvc3Njb3VudFxuICAgIGlmIChjb250ZW50Q291bnQgPiBsaXN0c2l6ZSkgY29udGVudENvdW50ID0gbGlzdHNpemVcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGxlYWRpbmdpdGVtY291bnQsIHJlZmVyZW5jZW9mZnNldCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGxldCBjcmFkbGVsZWFkaW5ncm93Y291bnQgPSBydW53YXljb3VudCAvLyBNYXRoLmZsb29yKHJ1bndheWxlbmd0aC9jZWxsTGVuZ3RoKVxuICAgIGxldCBsZWFkaW5naXRlbWNvdW50ID0gcnVud2F5Y291bnQgKiBjcm9zc2NvdW50XG4gICAgbGV0IHRhcmdldGRpZmYgPSB2aXNpYmxldGFyZ2V0aW5kZXhvZmZzZXQgJSBjcm9zc2NvdW50XG4gICAgbGV0IHJlZmVyZW5jZW9mZnNldCA9IHZpc2libGV0YXJnZXRpbmRleG9mZnNldCAtIHRhcmdldGRpZmYgLy8gcGFydCBvZiByZXR1cm4gbWVzc2FnZVxuXG4gICAgbGVhZGluZ2l0ZW1jb3VudCArPSB0YXJnZXRkaWZmXG4gICAgbGVhZGluZ2l0ZW1jb3VudCA9IE1hdGgubWluKGxlYWRpbmdpdGVtY291bnQsIHZpc2libGV0YXJnZXRpbmRleG9mZnNldCkgLy8gZm9yIGxpc3QgaGVhZFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgaW5kZXhvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gbGVhZGluZyBlZGdlXG4gICAgbGV0IGluZGV4b2Zmc2V0ID0gdmlzaWJsZXRhcmdldGluZGV4b2Zmc2V0IC0gbGVhZGluZ2l0ZW1jb3VudFxuICAgIGxldCBkaWZmID0gaW5kZXhvZmZzZXQgJSBjcm9zc2NvdW50XG4gICAgaW5kZXhvZmZzZXQgLT0gZGlmZlxuXG4gICAgLy8gLS0tLS0tLS0tLS0tWyBhZGp1c3QgaW5kZXhvZmZzZXQgYW5kIGNvbnRlbnRDb3VudCBmb3IgbGlzdHNpemUgXS0tLS0tLS0tLS0tLVxuXG4gICAgZGlmZiA9IDBcbiAgICBsZXQgc2hpZnQgPSAwXG4gICAgaWYgKChpbmRleG9mZnNldCArIGNvbnRlbnRDb3VudCkgPiBsaXN0c2l6ZSkge1xuICAgICAgICBkaWZmID0gKGluZGV4b2Zmc2V0ICsgY29udGVudENvdW50KSAtIGxpc3RzaXplXG4gICAgICAgIHNoaWZ0ID0gZGlmZiAlIGNyb3NzY291bnRcbiAgICB9XG5cbiAgICBpZiAoZGlmZikge1xuICAgICAgICBpbmRleG9mZnNldCAtPSAoZGlmZiAtIHNoaWZ0KVxuICAgICAgICBjb250ZW50Q291bnQgLT0gc2hpZnRcbiAgICB9XG4gICAgXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3NzIHBvc2l0aW9uaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IGluZGV4cm93b2Zmc2V0ID0gTWF0aC5mbG9vcihpbmRleG9mZnNldC9jcm9zc2NvdW50KVxuICAgIGxldCBjcmFkbGVvZmZzZXQgPSBpbmRleHJvd29mZnNldCAqIGNlbGxMZW5ndGhcblxuICAgIGxldCB0YXJnZXRyb3dvZmZzZXQgPSBNYXRoLmZsb29yKHZpc2libGV0YXJnZXRpbmRleG9mZnNldC9jcm9zc2NvdW50KVxuXG4gICAgbGV0IHJvd3Njcm9sbGJsb2Nrb2Zmc2V0ID0gdGFyZ2V0cm93b2Zmc2V0ICogY2VsbExlbmd0aFxuICAgIGxldCBzY3JvbGxibG9ja29mZnNldCA9IE1hdGgubWF4KDAscm93c2Nyb2xsYmxvY2tvZmZzZXQgLSB0YXJnZXRTY3JvbGxPZmZzZXQpXG5cbiAgICByZXR1cm4ge2luZGV4b2Zmc2V0LCByZWZlcmVuY2VvZmZzZXQsIGNvbnRlbnRDb3VudCwgc2Nyb2xsYmxvY2tvZmZzZXQsIGNyYWRsZW9mZnNldH0gLy8gc3VtbWFyaXplIHJlcXVpcmVtZW50cyBtZXNzYWdlXG5cbn1cblxuLy8gZmlsdGVyIG91dCBpdGVtcyB0aGF0IGFyZSBhbHJlYWR5IGluIHJ1bndheXNcbmV4cG9ydCBjb25zdCBpc29sYXRlUmVsZXZhbnRJbnRlcnNlY3Rpb25zID0gKHtcbiAgICBpbnRlcnNlY3Rpb25zLFxuICAgIGhlYWRjb250ZW50LCBcbiAgICB0YWlsY29udGVudCxcbn0pID0+IHtcblxuICAgIGxldCBoZWFkaW5kZXhlcyA9IFtdLCBcbiAgICAgICAgdGFpbGluZGV4ZXMgPSBbXSxcbiAgICAgICAgaGVhZGludGVyc2VjdGlvbmluZGV4ZXMgPSBbXSxcbiAgICAgICAgaGVhZGludGVyc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgdGFpbGludGVyc2VjdGlvbmluZGV4ZXMgPSBbXSxcbiAgICAgICAgdGFpbGludGVyc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgaW50ZXJzZWN0aW5nOmFueSA9IHt9LFxuICAgICAgICBmaWx0ZXJlZGludGVyc2VjdGlvbnMgPSBbXVxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiBoZWFkY29udGVudCkge1xuICAgICAgICBoZWFkaW5kZXhlcy5wdXNoKGl0ZW0ucHJvcHMuaW5kZXgpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiB0YWlsY29udGVudCkge1xuICAgICAgICB0YWlsaW5kZXhlcy5wdXNoKGl0ZW0ucHJvcHMuaW5kZXgpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgZW50cnkgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChlbnRyeS50YXJnZXQuZGF0YXNldC5pbmRleClcbiAgICAgICAgaWYgKHRhaWxpbmRleGVzLmluY2x1ZGVzKGluZGV4KSkge1xuICAgICAgICAgICAgdGFpbGludGVyc2VjdGlvbmluZGV4ZXMucHVzaChpbmRleClcbiAgICAgICAgICAgIHRhaWxpbnRlcnNlY3Rpb25zLnB1c2goZW50cnkpXG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZGluZGV4ZXMuaW5jbHVkZXMoaW5kZXgpKSB7XG4gICAgICAgICAgICBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcy5wdXNoKGluZGV4KVxuICAgICAgICAgICAgaGVhZGludGVyc2VjdGlvbnMucHVzaChlbnRyeSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAvLyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzZWN0aW5nW2luZGV4XSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nXG4gICAgfVxuXG4gICAgLy8gY29sbGVjdCBoZWFkY29udGVudCBpbmRleGVzXG4gICAgbGV0IGhlYWRpbmRleCA9IGhlYWRpbmRleGVzW2hlYWRpbmRleGVzLmxlbmd0aCAtIDFdXG4gICAgbGV0IHRhaWxpbmRleCA9IHRhaWxpbmRleGVzWzBdXG4gICAgbGV0IGhlYWRwdHIgPSBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcy5pbmRleE9mKGhlYWRpbmRleClcbiAgICBsZXQgdGFpbHB0ciA9IHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzLmluZGV4T2YodGFpbGluZGV4KVxuICAgIC8vIGNvbnNvbGUubG9nKCdoZWFkcG9zLCB0YWlscG9zJyxoZWFkcG9zLCB0YWlscG9zKVxuICAgIGlmICgoaGVhZHB0ciA+PTApICYmICFpbnRlcnNlY3RpbmdbaGVhZGluZGV4XSkge1xuICAgICAgICBoZWFkcHRyID0gLTFcbiAgICB9XG5cbiAgICBpZiAoKHRhaWxwdHIgPj0wKSAmJiBpbnRlcnNlY3RpbmdbdGFpbGluZGV4XSkge1xuICAgICAgICB0YWlscHRyID0gLTFcbiAgICB9XG5cbiAgICBpZiAoaGVhZHB0ciA+PSAwKSB7XG4gICAgICAgIGxldCByZWZpbmRleCA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzW2hlYWRwdHJdICsgMVxuICAgICAgICBsZXQgcmVmaW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0aW5nW3JlZmluZGV4IC0gMV1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0hFQUQgcmVmaW5kZXgsIHJlZmludGVyc2VjdGluZycscmVmaW5kZXgscmVmaW50ZXJzZWN0aW5nKVxuICAgICAgICBmb3IgKGxldCBwdHIgPSBoZWFkcHRyOyBwdHIgPj0gMDsgcHRyLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzW3B0cl1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbmRleCArIDEsIHJlZmluZGV4LCBpbnRlcnNlY3RpbmdbaW5kZXhdLHJlZmludGVyc2VjdGluZycsXG4gICAgICAgICAgICAvLyAgICAgaW5kZXggKyAxLCByZWZpbmRleCwgaW50ZXJzZWN0aW5nW2luZGV4XSxyZWZpbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICBpZiAoKChpbmRleCArIDEpID09IHJlZmluZGV4KSAmJiAoaW50ZXJzZWN0aW5nW2luZGV4XSA9PSByZWZpbnRlcnNlY3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZGluZyBlbnRyeSB0byBpbmRleCxmaWx0ZXJlZGludGVyc2VjdGlvbnMnLGluZGV4LGhlYWRpbnRlcnNlY3Rpb25zW3B0cl0pXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRpbnRlcnNlY3Rpb25zLnB1c2goaGVhZGludGVyc2VjdGlvbnNbcHRyXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZmluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tyZWZpbmRleF1cbiAgICAgICAgfVxuICAgIH1cbiAgICAgXG4gICAgaWYgKHRhaWxwdHIgPj0gMCkge1xuICAgICAgICBsZXQgcmVmaW5kZXggPSB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlc1t0YWlscHRyXSAtIDFcbiAgICAgICAgbGV0IHJlZmludGVyc2VjdGluZyA9IGludGVyc2VjdGluZ1tyZWZpbmRleCArIDFdXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdUQUlMIHJlZmluZGV4LCByZWZpbnRlcnNlY3RpbmcnLHJlZmluZGV4LHJlZmludGVyc2VjdGluZywgaW50ZXJzZWN0aW5nKVxuICAgICAgICBmb3IgKGxldCBwdHIgPSB0YWlscHRyOyBwdHIgPCB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcy5sZW5ndGg7IHB0cisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0YWlsaW50ZXJzZWN0aW9uaW5kZXhlc1twdHJdXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaW5kZXggLSAxLCByZWZpbmRleCwgaW50ZXJzZWN0aW5nW2luZGV4XSxyZWZpbnRlcnNlY3RpbmcnLFxuICAgICAgICAgICAgLy8gICAgIGluZGV4IC0gMSwgcmVmaW5kZXgsIGludGVyc2VjdGluZ1tpbmRleF0scmVmaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgaWYgKCgoaW5kZXggLSAxKSA9PSByZWZpbmRleCkgJiYgKGludGVyc2VjdGluZ1tpbmRleF0gPT0gcmVmaW50ZXJzZWN0aW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZGRpbmcgZW50cnkgdG8gaW5kZXgsZmlsdGVyZWRpbnRlcnNlY3Rpb25zJyxpbmRleCx0YWlsaW50ZXJzZWN0aW9uc1twdHJdKVxuICAgICAgICAgICAgICAgIGZpbHRlcmVkaW50ZXJzZWN0aW9ucy5wdXNoKHRhaWxpbnRlcnNlY3Rpb25zW3B0cl0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZpbmRleCA9IGluZGV4XG4gICAgICAgICAgICByZWZpbnRlcnNlY3RpbmcgPSBpbnRlcnNlY3RpbmdbaW5kZXhdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnaGVhZGluZGV4ZXMsIHRhaWxpbmRleGVzLCBoZWFkaW50ZXJzZWN0aW9uaW5kZXhlcyx0YWlsaW50ZXJzZWN0aW9uaW5kZXhlcywgaW50ZXJzZWN0aW5nLCBmaWx0ZXJlZGludGVyc2VjdGlvbnMnLFxuICAgIC8vICAgICBoZWFkaW5kZXhlcywgdGFpbGluZGV4ZXMsIGhlYWRpbnRlcnNlY3Rpb25pbmRleGVzLHRhaWxpbnRlcnNlY3Rpb25pbmRleGVzLCBpbnRlcnNlY3RpbmcsIGZpbHRlcmVkaW50ZXJzZWN0aW9ucylcblxuICAgIHJldHVybiBmaWx0ZXJlZGludGVyc2VjdGlvbnNcblxufVxuXG4vLyB1cGRhdGUgY29udGVudFxuLy8gYWRkcyBpdGVtc2hlbGxzIGF0IGVuZCBvZiBjb250ZW50bGlzdCBhY2NvcmRpbmcgdG8gaGVhZGluZGV4Y291bnQgYW5kIHRhaWxpbmRlc2NvdW50LFxuLy8gb3IgaWYgaW5kZXhjb3VudCB2YWx1ZXMgYXJlIDwwIHJlbW92ZXMgdGhlbS5cbmV4cG9ydCBjb25zdCBnZXRVSUNvbnRlbnRMaXN0ID0gKHByb3BzKSA9PiB7XG5cbiAgICBsZXQgeyBcblxuICAgICAgICBpbmRleG9mZnNldCwgXG4gICAgICAgIGhlYWRpbmRleGNvdW50LCBcbiAgICAgICAgdGFpbGluZGV4Y291bnQsIFxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBsb2NhbENvbnRlbnRMaXN0OmNvbnRlbnRsaXN0LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBsaXN0c2l6ZSxcblxuICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgIGdldEl0ZW0sXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBvYnNlcnZlcixcbiAgICB9ID0gcHJvcHNcblxuICAgIGxldCBsb2NhbENvbnRlbnRsaXN0ID0gWy4uLmNvbnRlbnRsaXN0XVxuICAgIGxldCB0YWlsaW5kZXhvZmZzZXQgPSBpbmRleG9mZnNldCArIGNvbnRlbnRsaXN0Lmxlbmd0aFxuICAgIGxldCByZXR1cm5Db250ZW50bGlzdFxuXG4gICAgbGV0IGhlYWRDb250ZW50bGlzdCA9IFtdXG5cbiAgICBpZiAoaGVhZGluZGV4Y291bnQgPj0gMCkge1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gaW5kZXhvZmZzZXQgLSBoZWFkaW5kZXhjb3VudDsgaW5kZXggPCAoaW5kZXhvZmZzZXQpOyBpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGVtaXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlciwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbG9jYWxDb250ZW50bGlzdC5zcGxpY2UoMCwtaGVhZGluZGV4Y291bnQpXG5cbiAgICB9XG5cbiAgICBsZXQgdGFpbENvbnRlbnRsaXN0ID0gW11cblxuICAgIGlmICh0YWlsaW5kZXhjb3VudCA+PSAwKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0YWlsaW5kZXhvZmZzZXQ7IGluZGV4IDwodGFpbGluZGV4b2Zmc2V0ICsgdGFpbGluZGV4Y291bnQpOyBpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIHRhaWxDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGVtaXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlciwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbG9jYWxDb250ZW50bGlzdC5zcGxpY2UodGFpbGluZGV4Y291bnQsLXRhaWxpbmRleGNvdW50KVxuXG4gICAgfVxuXG4gICAgcmV0dXJuQ29udGVudGxpc3QgPSBoZWFkQ29udGVudGxpc3QuY29uY2F0KGxvY2FsQ29udGVudGxpc3QsdGFpbENvbnRlbnRsaXN0KVxuXG4gICAgcmV0dXJuIHJldHVybkNvbnRlbnRsaXN0XG59XG5cbi8vIGJ1dHRlcmZseSBtb2RlbC4gTGVhZGluZyAoaGVhZCkgYWxsIG9yIHBhcnRpYWxseSBoaWRkZW47IHRhaWwsIHZpc2libGUgcGx1cyBmb2xsb3dpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIHJ1bndheWNvdW50LCAvLyBpbiByb3dzXG4gICAgICAgIHJlZmVyZW5jZWluZGV4LCAvLyBmaXJzdCB0YWlsIGl0ZW1cbiAgICAgICAgY3Jvc3Njb3VudCxcblxuICAgIH1cbikgPT4ge1xuXG4gICAgbGV0IG9mZnNldGluZGV4ID0gY29udGVudGxpc3RbMF0ucHJvcHMuaW5kZXhcbiAgICBsZXQgcnVud2F5dGFpbGluZGV4ID0gY29udGVudGxpc3RbKHJ1bndheWNvdW50ICogY3Jvc3Njb3VudCkgLSAxXS5wcm9wcy5pbmRleFxuICAgIGxldCBoZWFkaXRlbWNvdW50XG5cbiAgICAvLyBpZiAocmVmZXJlbmNlaW5kZXggPD0gcnVud2F5dGFpbGluZGV4KSB7XG4gICAgLy8gICAgIGhlYWRpdGVtY291bnQgPSAocmVmZXJlbmNlaW5kZXggLSBvZmZzZXRpbmRleClcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgICBoZWFkaXRlbWNvdW50ID0gKHJ1bndheWNvdW50ICogY3Jvc3Njb3VudClcbiAgICAvLyB9XG4gICAgaGVhZGl0ZW1jb3VudCA9IChyZWZlcmVuY2VpbmRleCAtIG9mZnNldGluZGV4KVxuXG4gICAgbGV0IGhlYWRsaXN0ID0gY29udGVudGxpc3Quc2xpY2UoMCxoZWFkaXRlbWNvdW50KVxuICAgIGxldCB0YWlsbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKGhlYWRpdGVtY291bnQpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnaGVhZGxpc3QsIHRhaWxsaXN0JywgWy4uLmhlYWRsaXN0XSwgWy4uLnRhaWxsaXN0XSlcblxuICAgIHJldHVybiBbaGVhZGxpc3QsdGFpbGxpc3RdXG5cbn1cblxuZXhwb3J0IGNvbnN0IGdldFNwaW5lUG9zUmVmID0gKFxuICAgIHtcbiAgICAgICAgc2Nyb2xsZm9yd2FyZCxcbiAgICAgICAgaXRlbWVsZW1lbnRzLCBcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBzcGluZUVsZW1lbnQsXG4gICAgICAgIHJlZmVyZW5jZWluZGV4LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBnYXAsXG4gICAgICAgIHJlZmVyZW5jZXNoaWZ0LFxuICAgIH0pID0+IHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdyZWZlcmVuY2VpbmRleCwgcmVmZXJlbmNlc2hpZnQnLHJlZmVyZW5jZWluZGV4LCByZWZlcmVuY2VzaGlmdClcblxuICAgIGxldCBzcGluZXBvc2Jhc2Usc3BpbmVwb3NyZWZcbiAgICB2YXIgbG9jYWxyZWZpbmRleCA9IHJlZmVyZW5jZWluZGV4XG4gICAgaWYgKCFzY3JvbGxmb3J3YXJkKSB7XG4gICAgICAgIC8vIGxvY2FscmVmaW5kZXggKz0gY3Jvc3Njb3VudFxuICAgICAgICBsb2NhbHJlZmluZGV4ICs9IHJlZmVyZW5jZXNoaWZ0XG4gICAgfVxuICAgIGxldCByZWZlcmVuY2VvYmplY3RzID0gW11cbiAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuICAgICAgICByZWZlcmVuY2VvYmplY3RzLnB1c2goaXRlbWVsZW1lbnRzLmdldChsb2NhbHJlZmluZGV4KSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IGxvY2FscmVmaW5kZXg7IGluZGV4ID4gcmVmZXJlbmNlaW5kZXg7IGluZGV4IC09IGNyb3NzY291bnQgKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VvYmplY3RzLnB1c2goaXRlbWVsZW1lbnRzLmdldChpbmRleCkpXG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlZmVyZW5jZXBvc3NoaWZ0XG5cbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzcGluZXBvc2Jhc2UgPSBzcGluZUVsZW1lbnQub2Zmc2V0VG9wXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3BpbmVwb3NiYXNlID0gc3BpbmVFbGVtZW50Lm9mZnNldExlZnRcbiAgICB9XG4gICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcbiAgICAgICAgbGV0IHJlZmVyZW5jZWVsZW1lbnQgPSByZWZlcmVuY2VvYmplY3RzWzBdLmN1cnJlbnRcbiAgICAgICAgaWYgKHJlZmVyZW5jZWVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZWFkaW5kZXgsIGhlYWRlbGVtZW50Lm9mZnNldFRvcCcsaGVhZGluZGV4LGhlYWRlbGVtZW50Lm9mZnNldFRvcClcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlcG9zc2hpZnQgPSByZWZlcmVuY2VlbGVtZW50Lm9mZnNldFRvcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2Vwb3NzaGlmdCA9IHJlZmVyZW5jZWVsZW1lbnQub2Zmc2V0TGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVmZXJlbmNlcG9zc2hpZnQgPSAwXG4gICAgICAgIGZvciAobGV0IHJlZm9iaiBvZiByZWZlcmVuY2VvYmplY3RzKSB7XG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXBvc3NoaWZ0ICs9IHJlZm9iai5jdXJyZW50Lm9mZnNldEhlaWdodCArIGdhcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2Vwb3NzaGlmdCArPSByZWZvYmouY3VycmVudC5vZmZzZXRXaWR0aCArIGdhcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCdyZWZlcmVuY2VpbmRleCwgbG9jYWxyZWZpbmRleCwgc2Nyb2xsZm9yd2FyZCxyZWZlcmVuY2VzaGlmdCwgcmVmZXJlbmNlcG9zc2hpZnQsIHJlZmVyZW5jZWVsZW1lbnQub2Zmc2V0VG9wLCByZWZlcmVuY2VlbGVtZW50Lm9mZnNldEhlaWdodCwgZ2FwLCByZWZlcmVuY2VlbGVtZW50JyxcbiAgICAvLyAgICAgcmVmZXJlbmNlaW5kZXgsIGxvY2FscmVmaW5kZXgsIHNjcm9sbGZvcndhcmQscmVmZXJlbmNlc2hpZnQsIHJlZmVyZW5jZXBvc3NoaWZ0LCByZWZlcmVuY2VlbGVtZW50Lm9mZnNldFRvcCwgcmVmZXJlbmNlZWxlbWVudC5vZmZzZXRIZWlnaHQsIGdhcCwgcmVmZXJlbmNlZWxlbWVudClcblxuICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7XG4gICAgICAgIHNwaW5lcG9zcmVmID0gc3BpbmVwb3NiYXNlICsgcmVmZXJlbmNlcG9zc2hpZnRcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcGluZXBvc3JlZiA9IHNwaW5lcG9zYmFzZSAtIHJlZmVyZW5jZXBvc3NoaWZ0XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ2luIGdldFNwaW5lUG9zUmVmIHJlZmVyZW5jZW9iamVjdCwgc2Nyb2xsZm9yd2FyZCwgc3BpbmVwb3NiYXNlLCBsb2NhbHJlZmluZGV4LCByZWZlcmVuY2Vwb3NzaGlmdCwgc3BpbmVwb3NyZWYnLFxuICAgIC8vICAgICByZWZlcmVuY2VvYmplY3QsIHNjcm9sbGZvcndhcmQsIHNwaW5lcG9zYmFzZSwgbG9jYWxyZWZpbmRleCwgcmVmZXJlbmNlcG9zc2hpZnQsIHNwaW5lcG9zcmVmKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3NwaW5lcG9zcmVmJywgc3BpbmVwb3NyZWYpXG5cbiAgICByZXR1cm4gc3BpbmVwb3NyZWZcbn1cblxuY29uc3QgZW1pdEl0ZW0gPSAoe1xuICAgIGluZGV4LCBcbiAgICBvcmllbnRhdGlvbiwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBvYnNlcnZlciwgXG4gICAgY2FsbGJhY2tzLCBcbiAgICBnZXRJdGVtLCBcbiAgICBsaXN0c2l6ZSwgXG4gICAgcGxhY2Vob2xkZXJcbn0pID0+IHtcblxuICAgIHJldHVybiA8SXRlbVNoZWxsXG4gICAgICAgIGtleSA9IHtpbmRleH0gXG4gICAgICAgIG9yaWVudGF0aW9uID0ge29yaWVudGF0aW9ufVxuICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsV2lkdGggfVxuICAgICAgICBpbmRleCA9IHtpbmRleH1cbiAgICAgICAgb2JzZXJ2ZXIgPSB7b2JzZXJ2ZXJ9XG4gICAgICAgIGNhbGxiYWNrcyA9IHtjYWxsYmFja3N9XG4gICAgICAgIGdldEl0ZW0gPSB7Z2V0SXRlbX1cbiAgICAgICAgbGlzdHNpemUgPSB7bGlzdHNpemV9XG4gICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgLz4gICAgXG5cbn1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgc3R5bGVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNvbnN0IHNldENyYWRsZUdyaWRTdHlsZXMgPSAoe1xuXG4gICAgb3JpZW50YXRpb24sIFxuICAgIGhlYWRDcmFkbGVTdHlsZXM6aGVhZHN0eWxlc29iamVjdCwgXG4gICAgdGFpbENyYWRsZVN0eWxlczp0YWlsc3R5bGVzb2JqZWN0LFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgZ2FwLFxuICAgIHBhZGRpbmcsIFxuICAgIGNyb3NzY291bnQsIFxuICAgIHZpZXdwb3J0aGVpZ2h0LCBcbiAgICB2aWV3cG9ydHdpZHRoXG5cbn0pID0+IHtcblxuICAgICAgICBsZXQgaGVhZHN0eWxlcyA9IHsuLi5oZWFkc3R5bGVzb2JqZWN0fSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgICAgIGxldCB0YWlsc3R5bGVzID0gey4uLnRhaWxzdHlsZXNvYmplY3R9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcblxuICAgICAgICBoZWFkc3R5bGVzLmdyaWRHYXAgPSBnYXAgKyAncHgnXG5cbiAgICAgICAgdGFpbHN0eWxlcy5ncmlkR2FwID0gZ2FwICsgJ3B4J1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAwICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSAnYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdjb2x1bW4nXG4gICAgICAgICAgICAvLyBleHBsaWN0IGNyb3NzY291bnQgbmV4dCBsaW5lIGFzIHdvcmthcm91bmQgZm9yIEZGIHByb2JsZW0gLSBcbiAgICAgICAgICAgIC8vICAgICBzZXRzIGxlbmd0aCBvZiBob3JpeiBjcmFkbGUgaXRlbXMgaW4gb25lIGxpbmUgKHJvdyksIG5vdCBtdWx0aS1yb3cgY29uZmlnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSBjZWxsSGVpZ2h0P2ByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgOidhdXRvJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJ25vbmUnXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwYFxuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAnY29sdW1uJ1xuICAgICAgICAgICAgLy8gZXhwbGljdCBjcm9zc2NvdW50IG5leHQgbGluZSBhcyB3b3JrYXJvdW5kIGZvciBGRiBwcm9ibGVtIC0gXG4gICAgICAgICAgICAvLyAgICAgc2V0cyBsZW5ndGggb2YgaG9yaXogY3JhZGxlIGl0ZW1zIGluIG9uZSBsaW5lIChyb3cpLCBub3QgbXVsdGktcm93IGNvbmZpZ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gY2VsbEhlaWdodD9gcmVwZWF0KCR7Y3Jvc3Njb3VudH0sIG1pbm1heCgke2NlbGxIZWlnaHR9cHgsIDFmcikpYDonYXV0bydcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9ICdub25lJ1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLnBhZGRpbmcgPSBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwICR7cGFkZGluZ31weGBcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaGVhZHN0eWxlcy5oZWlnaHQgPSAnYXV0bydcbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ3JvdydcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gJ25vbmUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBjZWxsV2lkdGg/YHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KCR7Y2VsbFdpZHRofXB4LCAxZnIpKWA6J2F1dG8nXG5cbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAwICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICB0YWlsc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSAncm93J1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZVJvd3MgPSAnbm9uZSdcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IGNlbGxXaWR0aD9gcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoJHtjZWxsV2lkdGh9cHgsIDFmcikpYDonYXV0bydcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbaGVhZHN0eWxlcyx0YWlsc3R5bGVzXVxuICAgICAgICBcbn1cblxuLy8gZXhwb3J0IGNvbnN0IHNldENyYWRsZVN0eWxlUmV2aXNpb25zRm9yRHJvcCA9ICh7IFxuLy8gICAgIGhlYWRjb250ZW50bGlzdCxcbi8vICAgICB0YWlsY29udGVudGxpc3QsXG4vLyAgICAgaGVhZENyYWRsZUVsZW1lbnQsXG4vLyAgICAgdGFpbENyYWRsZUVsZW1lbnQsIFxuLy8gICAgIHBhcmVudEVsZW1lbnQsIFxuLy8gICAgIHNjcm9sbGZvcndhcmQsIFxuLy8gICAgIG9yaWVudGF0aW9uIFxuLy8gfSkgPT4ge1xuXG4vLyAgICAgbGV0IHN0eWxlcyA9IHt9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbi8vICAgICBsZXQgdGFpbHN0eWxlcyA9IHt9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbi8vICAgICBsZXQgaGVhZHBvcywgdGFpbHBvc1xuXG4vLyAgICAgLy8gc2V0IHN0eWxlcyByZXZpc2lvbnNcbi8vICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4vLyAgICAgICAgIGxldCBvZmZzZXRIZWlnaHQgPSBoZWFkQ3JhZGxlRWxlbWVudC5vZmZzZXRIZWlnaHRcbi8vICAgICAgICAgbGV0IHBhcmVudEhlaWdodCA9IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cbi8vICAgICAgICAgbGV0IG9mZnNldFRvcCA9IGhlYWRDcmFkbGVFbGVtZW50Lm9mZnNldFRvcFxuXG4vLyAgICAgICAgIHN0eWxlcy5sZWZ0ID0gJ2F1dG8nXG4vLyAgICAgICAgIHN0eWxlcy5yaWdodCA9ICdhdXRvJ1xuXG4vLyAgICAgICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7XG5cbi8vICAgICAgICAgICAgIHRhaWxwb3MgPSBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHRcbi8vICAgICAgICAgICAgIHN0eWxlcy50b3AgPSAnYXV0bydcbi8vICAgICAgICAgICAgIHN0eWxlcy5ib3R0b20gPSAocGFyZW50SGVpZ2h0IC0gdGFpbHBvcykgKyAncHgnXG5cbi8vICAgICAgICAgfSBlbHNlIHtcblxuLy8gICAgICAgICAgICAgaGVhZHBvcyA9IG9mZnNldFRvcFxuLy8gICAgICAgICAgICAgc3R5bGVzLnRvcCA9IGhlYWRwb3MgKyAncHgnXG4vLyAgICAgICAgICAgICBzdHlsZXMuYm90dG9tID0gJ2F1dG8nXG5cbi8vICAgICAgICAgfVxuXG4vLyAgICAgfSBlbHNlIHtcblxuLy8gICAgICAgICBsZXQgb2Zmc2V0TGVmdCA9IGhlYWRDcmFkbGVFbGVtZW50Lm9mZnNldExlZnRcbi8vICAgICAgICAgbGV0IG9mZnNldFdpZHRoID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0V2lkdGhcbi8vICAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aFxuLy8gICAgICAgICBsZXQgY3NzbGVmdCA9IHBhcnNlSW50KGhlYWRDcmFkbGVFbGVtZW50LnN0eWxlLmxlZnQpXG4vLyAgICAgICAgIGxldCBjc3NyaWdodCA9IHBhcnNlSW50KGhlYWRDcmFkbGVFbGVtZW50LnN0eWxlLmJvdHRvbSlcblxuLy8gICAgICAgICBzdHlsZXMudG9wID0gJ2F1dG8nXG4vLyAgICAgICAgIHN0eWxlcy5ib3R0b20gPSAnYXV0bydcblxuLy8gICAgICAgICBpZiAoc2Nyb2xsZm9yd2FyZCkge1xuXG4vLyAgICAgICAgICAgICB0YWlscG9zID0gb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoXG4vLyAgICAgICAgICAgICBzdHlsZXMubGVmdCA9ICdhdXRvJ1xuLy8gICAgICAgICAgICAgc3R5bGVzLnJpZ2h0ID0gKHBhcmVudFdpZHRoIC0gdGFpbHBvcykgKyAncHgnXG5cbi8vICAgICAgICAgfSBlbHNlIHtcblxuLy8gICAgICAgICAgICAgaGVhZHBvcyA9IG9mZnNldExlZnRcbi8vICAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gaGVhZHBvcyArICdweCdcbi8vICAgICAgICAgICAgIHN0eWxlcy5yaWdodCA9ICdhdXRvJ1xuXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICByZXR1cm4gW3N0eWxlcyx0YWlsc3R5bGVzXVxuXG4vLyB9XG5cbi8vIGV4cG9ydCBjb25zdCBzZXRDcmFkbGVTdHlsZVJldmlzaW9uc0ZvckFkZCA9ICh7XG4vLyAgICAgaGVhZGNvbnRlbnRsaXN0LFxuLy8gICAgIHRhaWxjb250ZW50bGlzdCxcbi8vICAgICBoZWFkQ3JhZGxlRWxlbWVudCxcbi8vICAgICB0YWlsQ3JhZGxlRWxlbWVudCxcbi8vICAgICBwYXJlbnRFbGVtZW50LFxuLy8gICAgIHNjcm9sbGZvcndhcmQsXG4vLyAgICAgb3JpZW50YXRpb24sXG4vLyB9KSA9PiB7XG4vLyAgICAgbGV0IHN0eWxlcyA9IHt9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbi8vICAgICBsZXQgdGFpbHN0eWxlcyA9IHt9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbi8vICAgICBsZXQgaGVhZHBvcywgdGFpbHBvc1xuXG4vLyAgICAgLy8gc2V0IHN0eWxlIHJldmlzaW9uc1xuLy8gICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbi8vICAgICAgICAgLy8gbGV0IG9mZnNldFRvcFxuLy8gICAgICAgICBsZXQgb2Zmc2V0SGVpZ2h0ID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4vLyAgICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuLy8gICAgICAgICBsZXQgY3NzdG9wID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUudG9wKVxuLy8gICAgICAgICBsZXQgY3NzYm90dG9tID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUuYm90dG9tKVxuLy8gICAgICAgICBsZXQgb2Zmc2V0VG9wID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0VG9wXG5cbi8vICAgICAgICAgc3R5bGVzLmxlZnQgPSAnYXV0bydcbi8vICAgICAgICAgc3R5bGVzLnJpZ2h0ID0gJ2F1dG8nXG5cbi8vICAgICAgICAgaWYgKHNjcm9sbGZvcndhcmQpIHtcblxuLy8gICAgICAgICAgICAgaGVhZHBvcyA9IG9mZnNldFRvcFxuLy8gICAgICAgICAgICAgc3R5bGVzLnRvcCA9IGhlYWRwb3MgKyAncHgnXG4vLyAgICAgICAgICAgICBzdHlsZXMuYm90dG9tID0gJ2F1dG8nXG5cbi8vICAgICAgICAgfSBlbHNlIHsgLy8gc2Nyb2xsIGJhY2t3YXJkXG5cbi8vICAgICAgICAgICAgIHRhaWxwb3MgPSBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHRcbi8vICAgICAgICAgICAgIHN0eWxlcy50b3AgPSAnYXV0bydcbi8vICAgICAgICAgICAgIHN0eWxlcy5ib3R0b20gPSAocGFyZW50SGVpZ2h0IC0gdGFpbHBvcykgKyAncHgnXG5cbi8vICAgICAgICAgfVxuXG4vLyAgICAgfSBlbHNlIHtcblxuLy8gICAgICAgICBsZXQgb2Zmc2V0TGVmdCA9IGhlYWRDcmFkbGVFbGVtZW50Lm9mZnNldExlZnRcbi8vICAgICAgICAgbGV0IG9mZnNldFdpZHRoID0gaGVhZENyYWRsZUVsZW1lbnQub2Zmc2V0V2lkdGhcbi8vICAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aFxuXG4vLyAgICAgICAgIGxldCBjc3NsZWZ0ID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUubGVmdClcbi8vICAgICAgICAgbGV0IGNzc3JpZ2h0ID0gcGFyc2VJbnQoaGVhZENyYWRsZUVsZW1lbnQuc3R5bGUuYm90dG9tKVxuXG4vLyAgICAgICAgIHN0eWxlcy50b3AgPSAnYXV0bydcbi8vICAgICAgICAgc3R5bGVzLmJvdHRvbSA9ICdhdXRvJ1xuXG4vLyAgICAgICAgIGlmIChzY3JvbGxmb3J3YXJkKSB7XG5cbi8vICAgICAgICAgICAgIGhlYWRwb3MgPSBvZmZzZXRMZWZ0XG4vLyAgICAgICAgICAgICBzdHlsZXMubGVmdCA9IGhlYWRwb3MgKyAncHgnXG4vLyAgICAgICAgICAgICBzdHlsZXMucmlnaHQgPSAnYXV0bydcblxuLy8gICAgICAgICB9IGVsc2UgeyAvLyBzY3JvbGwgYmFja3dhcmRcblxuLy8gICAgICAgICAgICAgdGFpbHBvcyA9IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aFxuLy8gICAgICAgICAgICAgc3R5bGVzLmxlZnQgPSAnYXV0bydcbi8vICAgICAgICAgICAgIHN0eWxlcy5yaWdodCA9IChwYXJlbnRXaWR0aCAtIHRhaWxwb3MpICsgJ3B4J1xuXG4vLyAgICAgICAgIH1cblxuLy8gICAgIH1cblxuLy8gICAgIHJldHVybiBbc3R5bGVzLCB0YWlsc3R5bGVzXVxuXG4vLyB9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradlefunctions.tsx\n");

/***/ }),

/***/ "./src/infinitegridscroller.tsx":
/*!**************************************!*\
  !*** ./src/infinitegridscroller.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // infinitegridscroller.tsx\n// copyright (c) 2019 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __importDefault(__webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\"));\n\nvar scrollblock_1 = __importDefault(__webpack_require__(/*! ./scrollblock */ \"./src/scrollblock.tsx\"));\n\nvar cradle_1 = __importDefault(__webpack_require__(/*! ./cradle */ \"./src/cradle.tsx\"));\n/*\n    BACKLOG:\n    - cache: none/preload/keepload\n*/\n// ===================================[ INITIALIZE ]===========================\n\n/*\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the scrollblock, which in turn contains the cradle\n        - a component that contains displayed (or nearly displayed) items.\n    The items are skeletons which contain the host content components.\n\n    Scrollblock virtually represents the entirety of the list, and of course scrolls\n    Cradle contains the list items, and is 'virtualiized' -- it appears as\n      though it is the full scrollblock, but in fact it is only slightly larger than\n      the viewport.\n    - individual items are framed by ItemShell, managed by Cradle\n\n    Overall the infinitegridscroller manages the often asynchronous interactions of the\n    components of the mechanism\n*/\n\n\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  var orientation = props.orientation,\n      // vertical or horizontal\n  gap = props.gap,\n      // space between grid cells, not including the leading and trailing edges\n  padding = props.padding,\n      // the space between the items and the viewport, applied to the cradle\n  cellHeight = props.cellHeight,\n      // the outer pixel height - literal for vertical; approximate for horizontal\n  cellWidth = props.cellWidth,\n      // the outer pixel width - literal for horizontal; approximate for vertical\n  runway = props.runway,\n      // the number of items outside the view of each side of the viewport \n  // -- gives time to assemble before display\n  listsize = props.listsize,\n      // the exact number of the size of the virtual list\n  offset = props.offset,\n      // the 0-based starting index of the list, when first loaded\n  getItem = props.getItem,\n      // function provided by host - parameter is index number, set by system; return value is \n  // host-selected component or promise of a component\n  functions = props.functions,\n      // properties with direct access to some component utilites, optional\n  placeholder = props.placeholder,\n      // a sparse component to stand in for content until the content arrives; \n  // optional, replaces default\n  styles = props.styles,\n      // passive style over-rides (eg. color, opacity) for viewport, scrollblock, cradle, or scrolltracker\n  // to come...\n  // cache = \"preload\", \"keepload\", \"none\"\n  // dense, // boolean (only with preload)\n  layout = props.layout; // defaults\n\n  (_a = functions) !== null && _a !== void 0 ? _a : functions = {};\n  (_b = gap) !== null && _b !== void 0 ? _b : gap = 0;\n  (_c = padding) !== null && _c !== void 0 ? _c : padding = 0;\n  (_d = runway) !== null && _d !== void 0 ? _d : runway = 3;\n  (_e = offset) !== null && _e !== void 0 ? _e : offset = 0;\n  (_f = listsize) !== null && _f !== void 0 ? _f : listsize = 0;\n  (_g = layout) !== null && _g !== void 0 ? _g : layout = 'uniform'; // constraints\n\n  offset = Math.max(0, offset); // non-negative\n\n  offset = Math.min(listsize, offset); // not larger than list\n\n  if (!['horizontal', 'vertical'].includes(orientation)) {\n    orientation = 'horizontal';\n  } // convert to pixels\n\n\n  var runwaylength = orientation == 'vertical' ? runway * (cellHeight + gap) : runway * (cellWidth + gap);\n  runwaylength && (runwaylength += padding * 2);\n  return react_1[\"default\"].createElement(viewport_1[\"default\"], {\n    orientation: orientation,\n    cellWidth: cellHeight,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    functions: functions,\n    styles: styles\n  }, react_1[\"default\"].createElement(scrollblock_1[\"default\"], {\n    listsize: listsize,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    gap: gap,\n    padding: padding,\n    orientation: orientation,\n    functions: functions,\n    styles: styles\n  }, react_1[\"default\"].createElement(cradle_1[\"default\"], {\n    gap: gap,\n    padding: padding,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    listsize: listsize,\n    offset: offset,\n    orientation: orientation,\n    runwaylength: runwaylength,\n    getItem: getItem,\n    functions: functions,\n    placeholder: placeholder,\n    styles: styles,\n    runwaycount: runway\n  })));\n};\n\nexports[\"default\"] = InfiniteGridScroller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3g/NjNlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUVBOzs7O0FBS0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTSxvQkFBb0IsR0FBRyxTQUF2QixvQkFBdUIsQ0FBQyxLQUFELEVBQU07OztBQUUzQjtBQUFBLE1BQWE7QUFDYixpQkFEQTtBQUFBLE1BQ0s7QUFDTCx5QkFGQTtBQUFBLE1BRVM7QUFDVCwrQkFIQTtBQUFBLE1BR1k7QUFDWiw2QkFKQTtBQUFBLE1BSVc7QUFDWCx1QkFMQTtBQUFBLE1BS1E7QUFDSjtBQUNKLDJCQVBBO0FBQUEsTUFPVTtBQUNWLHVCQVJBO0FBQUEsTUFRUTtBQUNSLHlCQVRBO0FBQUEsTUFTUztBQUNMO0FBQ0osNkJBWEE7QUFBQSxNQVdXO0FBQ1gsaUNBWkE7QUFBQSxNQVlhO0FBQ1Q7QUFDSix1QkFkQTtBQUFBLE1BY1E7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFsQkEsQ0FGMkIsQ0F1Qi9COztBQUNBLHVCQUFXLElBQVgsSUFBVyxhQUFYLEdBQVcsRUFBWCxHQUFlLFNBQVMsR0FBRyxFQUEzQjtBQUNBLGlCQUFLLElBQUwsSUFBSyxhQUFMLEdBQUssRUFBTCxHQUFTLEdBQUcsR0FBRyxDQUFmO0FBQ0EscUJBQVMsSUFBVCxJQUFTLGFBQVQsR0FBUyxFQUFULEdBQWEsT0FBTyxHQUFHLENBQXZCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLENBQXJCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLENBQXJCO0FBQ0Esc0JBQVUsSUFBVixJQUFVLGFBQVYsR0FBVSxFQUFWLEdBQWMsUUFBUSxHQUFHLENBQXpCO0FBQ0Esb0JBQVEsSUFBUixJQUFRLGFBQVIsR0FBUSxFQUFSLEdBQVksTUFBTSxHQUFHLFNBQXJCLENBOUIrQixDQStCL0I7O0FBQ0EsUUFBTSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFXLE1BQVgsQ0FBVCxDQWhDK0IsQ0FnQ0g7O0FBQzVCLFFBQU0sR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLFFBQVQsRUFBbUIsTUFBbkIsQ0FBVCxDQWpDK0IsQ0FpQ0s7O0FBQ3BDLE1BQUksQ0FBQyxDQUFDLFlBQUQsRUFBYyxVQUFkLEVBQTBCLFFBQTFCLENBQW1DLFdBQW5DLENBQUwsRUFBc0Q7QUFDbEQsZUFBVyxHQUFHLFlBQWQ7QUFDSCxHQXBDOEIsQ0FxQy9COzs7QUFDQSxNQUFJLFlBQVksR0FBSSxXQUFXLElBQUksVUFBaEIsR0FBNkIsTUFBTSxJQUFJLFVBQVUsR0FBRyxHQUFqQixDQUFuQyxHQUEyRCxNQUFNLElBQUksU0FBUyxHQUFHLEdBQWhCLENBQXBGO0FBQ0EsY0FBWSxLQUFLLFlBQVksSUFBSyxPQUFPLEdBQUcsQ0FBaEMsQ0FBWjtBQUVBLFNBQU8saUNBQUMscUJBQUQsRUFBUztBQUVaLGVBQVcsRUFBSyxXQUZKO0FBR1osYUFBUyxFQUFLLFVBSEY7QUFJWixjQUFVLEVBQUssVUFKSDtBQUtaLE9BQUcsRUFBSyxHQUxJO0FBTVosV0FBTyxFQUFLLE9BTkE7QUFPWixhQUFTLEVBQUssU0FQRjtBQVFaLFVBQU0sRUFBSztBQVJDLEdBQVQsRUFXSCxpQ0FBQyx3QkFBRCxFQUFZO0FBRVIsWUFBUSxFQUFLLFFBRkw7QUFHUixhQUFTLEVBQUssU0FITjtBQUlSLGNBQVUsRUFBSyxVQUpQO0FBS1IsT0FBRyxFQUFLLEdBTEE7QUFNUixXQUFPLEVBQUssT0FOSjtBQU9SLGVBQVcsRUFBSyxXQVBSO0FBUVIsYUFBUyxFQUFLLFNBUk47QUFTUixVQUFNLEVBQUs7QUFUSCxHQUFaLEVBYUksaUNBQUMsbUJBQUQsRUFBTztBQUVILE9BQUcsRUFBSyxHQUZMO0FBR0gsV0FBTyxFQUFLLE9BSFQ7QUFJSCxhQUFTLEVBQUssU0FKWDtBQUtILGNBQVUsRUFBSyxVQUxaO0FBTUgsWUFBUSxFQUFLLFFBTlY7QUFPSCxVQUFNLEVBQUssTUFQUjtBQVFILGVBQVcsRUFBSyxXQVJiO0FBU0gsZ0JBQVksRUFBSyxZQVRkO0FBVUgsV0FBTyxFQUFLLE9BVlQ7QUFXSCxhQUFTLEVBQUssU0FYWDtBQVlILGVBQVcsRUFBSyxXQVpiO0FBYUgsVUFBTSxFQUFLLE1BYlI7QUFjSCxlQUFXLEVBQUs7QUFkYixHQUFQLENBYkosQ0FYRyxDQUFQO0FBNkNILENBdEZEOztBQXdGQSxxQkFBZSxvQkFBZiIsImZpbGUiOiIuL3NyYy9pbmZpbml0ZWdyaWRzY3JvbGxlci50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbmZpbml0ZWdyaWRzY3JvbGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOSBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXdwb3J0J1xuaW1wb3J0IFNjcm9sbGJsb2NrIGZyb20gJy4vc2Nyb2xsYmxvY2snXG5pbXBvcnQgQ3JhZGxlIGZyb20gJy4vY3JhZGxlJ1xuXG4vKlxuICAgIEJBQ0tMT0c6IFxuICAgIC0gY2FjaGU6IG5vbmUvcHJlbG9hZC9rZWVwbG9hZFxuKi9cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1bIElOSVRJQUxJWkUgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKlxuICAgIFRoZSBqb2Igb2YgSW5maW5pdGVHcmlkU2Nyb2xsZXIgaXMgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGRlcGVuZGVudHMuXG4gICAgVmlld3BvcnQgY29udGFpbnMgdGhlIHNjcm9sbGJsb2NrLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zIHRoZSBjcmFkbGUgXG4gICAgICAgIC0gYSBjb21wb25lbnQgdGhhdCBjb250YWlucyBkaXNwbGF5ZWQgKG9yIG5lYXJseSBkaXNwbGF5ZWQpIGl0ZW1zLiBcbiAgICBUaGUgaXRlbXMgYXJlIHNrZWxldG9ucyB3aGljaCBjb250YWluIHRoZSBob3N0IGNvbnRlbnQgY29tcG9uZW50cy5cblxuICAgIFNjcm9sbGJsb2NrIHZpcnR1YWxseSByZXByZXNlbnRzIHRoZSBlbnRpcmV0eSBvZiB0aGUgbGlzdCwgYW5kIG9mIGNvdXJzZSBzY3JvbGxzXG4gICAgQ3JhZGxlIGNvbnRhaW5zIHRoZSBsaXN0IGl0ZW1zLCBhbmQgaXMgJ3ZpcnR1YWxpaXplZCcgLS0gaXQgYXBwZWFycyBhc1xuICAgICAgdGhvdWdoIGl0IGlzIHRoZSBmdWxsIHNjcm9sbGJsb2NrLCBidXQgaW4gZmFjdCBpdCBpcyBvbmx5IHNsaWdodGx5IGxhcmdlciB0aGFuXG4gICAgICB0aGUgdmlld3BvcnQuXG4gICAgLSBpbmRpdmlkdWFsIGl0ZW1zIGFyZSBmcmFtZWQgYnkgSXRlbVNoZWxsLCBtYW5hZ2VkIGJ5IENyYWRsZVxuXG4gICAgT3ZlcmFsbCB0aGUgaW5maW5pdGVncmlkc2Nyb2xsZXIgbWFuYWdlcyB0aGUgb2Z0ZW4gYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBvZiB0aGUgXG4gICAgY29tcG9uZW50cyBvZiB0aGUgbWVjaGFuaXNtXG4qL1xuY29uc3QgSW5maW5pdGVHcmlkU2Nyb2xsZXIgPSAocHJvcHMpID0+IHtcbiAgICBsZXQgeyBcbiAgICAgICAgb3JpZW50YXRpb24sIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwLCAvLyBzcGFjZSBiZXR3ZWVuIGdyaWQgY2VsbHMsIG5vdCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGVkZ2VzXG4gICAgICAgIHBhZGRpbmcsIC8vIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBpdGVtcyBhbmQgdGhlIHZpZXdwb3J0LCBhcHBsaWVkIHRvIHRoZSBjcmFkbGVcbiAgICAgICAgY2VsbEhlaWdodCwgLy8gdGhlIG91dGVyIHBpeGVsIGhlaWdodCAtIGxpdGVyYWwgZm9yIHZlcnRpY2FsOyBhcHByb3hpbWF0ZSBmb3IgaG9yaXpvbnRhbFxuICAgICAgICBjZWxsV2lkdGgsIC8vIHRoZSBvdXRlciBwaXhlbCB3aWR0aCAtIGxpdGVyYWwgZm9yIGhvcml6b250YWw7IGFwcHJveGltYXRlIGZvciB2ZXJ0aWNhbFxuICAgICAgICBydW53YXksIC8vIHRoZSBudW1iZXIgb2YgaXRlbXMgb3V0c2lkZSB0aGUgdmlldyBvZiBlYWNoIHNpZGUgb2YgdGhlIHZpZXdwb3J0IFxuICAgICAgICAgICAgLy8gLS0gZ2l2ZXMgdGltZSB0byBhc3NlbWJsZSBiZWZvcmUgZGlzcGxheVxuICAgICAgICBsaXN0c2l6ZSwgLy8gdGhlIGV4YWN0IG51bWJlciBvZiB0aGUgc2l6ZSBvZiB0aGUgdmlydHVhbCBsaXN0XG4gICAgICAgIG9mZnNldCwgLy8gdGhlIDAtYmFzZWQgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGxpc3QsIHdoZW4gZmlyc3QgbG9hZGVkXG4gICAgICAgIGdldEl0ZW0sIC8vIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGhvc3QgLSBwYXJhbWV0ZXIgaXMgaW5kZXggbnVtYmVyLCBzZXQgYnkgc3lzdGVtOyByZXR1cm4gdmFsdWUgaXMgXG4gICAgICAgICAgICAvLyBob3N0LXNlbGVjdGVkIGNvbXBvbmVudCBvciBwcm9taXNlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGZ1bmN0aW9ucywgLy8gcHJvcGVydGllcyB3aXRoIGRpcmVjdCBhY2Nlc3MgdG8gc29tZSBjb21wb25lbnQgdXRpbGl0ZXMsIG9wdGlvbmFsXG4gICAgICAgIHBsYWNlaG9sZGVyLCAvLyBhIHNwYXJzZSBjb21wb25lbnQgdG8gc3RhbmQgaW4gZm9yIGNvbnRlbnQgdW50aWwgdGhlIGNvbnRlbnQgYXJyaXZlczsgXG4gICAgICAgICAgICAvLyBvcHRpb25hbCwgcmVwbGFjZXMgZGVmYXVsdFxuICAgICAgICBzdHlsZXMsIC8vIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KSBmb3Igdmlld3BvcnQsIHNjcm9sbGJsb2NrLCBjcmFkbGUsIG9yIHNjcm9sbHRyYWNrZXJcbiAgICAgICAgLy8gdG8gY29tZS4uLlxuICAgICAgICAvLyBjYWNoZSA9IFwicHJlbG9hZFwiLCBcImtlZXBsb2FkXCIsIFwibm9uZVwiXG4gICAgICAgIC8vIGRlbnNlLCAvLyBib29sZWFuIChvbmx5IHdpdGggcHJlbG9hZClcbiAgICAgICAgbGF5b3V0LCAvLyB1bmlmb3JtLCB2YXJpYWJsZVxuICAgIH0gPSBwcm9wc1xuXG4gICAgLy8gZGVmYXVsdHNcbiAgICBmdW5jdGlvbnMgIT8/IChmdW5jdGlvbnMgPSB7fSlcbiAgICBnYXAgIT8/IChnYXAgPSAwKVxuICAgIHBhZGRpbmcgIT8/IChwYWRkaW5nID0gMClcbiAgICBydW53YXkgIT8/IChydW53YXkgPSAzKVxuICAgIG9mZnNldCAhPz8gKG9mZnNldCA9IDApXG4gICAgbGlzdHNpemUgIT8/IChsaXN0c2l6ZSA9IDApXG4gICAgbGF5b3V0ICE/PyAobGF5b3V0ID0gJ3VuaWZvcm0nKVxuICAgIC8vIGNvbnN0cmFpbnRzXG4gICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCxvZmZzZXQpIC8vIG5vbi1uZWdhdGl2ZVxuICAgIG9mZnNldCA9IE1hdGgubWluKGxpc3RzaXplLCBvZmZzZXQpIC8vIG5vdCBsYXJnZXIgdGhhbiBsaXN0XG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkge1xuICAgICAgICBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IHRvIHBpeGVsc1xuICAgIGxldCBydW53YXlsZW5ndGggPSAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/KHJ1bndheSAqIChjZWxsSGVpZ2h0ICsgZ2FwKSk6KHJ1bndheSAqIChjZWxsV2lkdGggKyBnYXApKVxuICAgIHJ1bndheWxlbmd0aCAmJiAocnVud2F5bGVuZ3RoICs9IChwYWRkaW5nICogMikpXG5cbiAgICByZXR1cm4gPFZpZXdwb3J0IFxuXG4gICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9IFxuICAgICAgICBjZWxsV2lkdGggPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgZ2FwID0geyBnYXAgfVxuICAgICAgICBwYWRkaW5nID0geyBwYWRkaW5nIH1cbiAgICAgICAgZnVuY3Rpb25zID0geyBmdW5jdGlvbnMgfVxuICAgICAgICBzdHlsZXMgPSB7IHN0eWxlcyB9XG4gICAgPlxuICAgIFxuICAgICAgICA8U2Nyb2xsYmxvY2tcblxuICAgICAgICAgICAgbGlzdHNpemUgPSB7IGxpc3RzaXplIH1cbiAgICAgICAgICAgIGNlbGxXaWR0aCA9IHsgY2VsbFdpZHRoIH1cbiAgICAgICAgICAgIGNlbGxIZWlnaHQgPSB7IGNlbGxIZWlnaHQgfVxuICAgICAgICAgICAgZ2FwID0geyBnYXB9XG4gICAgICAgICAgICBwYWRkaW5nID0geyBwYWRkaW5nIH1cbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0geyBvcmllbnRhdGlvbiB9XG4gICAgICAgICAgICBmdW5jdGlvbnMgPSB7IGZ1bmN0aW9ucyB9XG4gICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlcyB9XG5cbiAgICAgICAgPlxuXG4gICAgICAgICAgICA8Q3JhZGxlIFxuXG4gICAgICAgICAgICAgICAgZ2FwID0geyBnYXAgfVxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSB7IHBhZGRpbmcgfVxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCA9IHsgY2VsbFdpZHRoIH1cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgb2Zmc2V0IH1cbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfVxuICAgICAgICAgICAgICAgIHJ1bndheWxlbmd0aCA9IHsgcnVud2F5bGVuZ3RoIH0gXG4gICAgICAgICAgICAgICAgZ2V0SXRlbSA9IHsgZ2V0SXRlbSB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zID0geyBmdW5jdGlvbnMgfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgc3R5bGVzID0geyBzdHlsZXMgfVxuICAgICAgICAgICAgICAgIHJ1bndheWNvdW50ID0geyBydW53YXkgfVxuXG4gICAgICAgICAgICAvPlxuXG4gICAgICAgIDwvU2Nyb2xsYmxvY2s+XG4gICAgPC9WaWV3cG9ydD5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbmZpbml0ZUdyaWRTY3JvbGxlclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/infinitegridscroller.tsx\n");

/***/ }),

/***/ "./src/itemshell.tsx":
/*!***************************!*\
  !*** ./src/itemshell.tsx ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // itemframe.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ \"./node_modules/requestidlecallback/index.js\");\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar placeholder_1 = __importDefault(__webpack_require__(/*! ./placeholder */ \"./src/placeholder.tsx\"));\n\nvar ItemShell = function ItemShell(props) {\n  var orientation = props.orientation,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      index = props.index,\n      observer = props.observer,\n      callbacks = props.callbacks,\n      getItem = props.getItem,\n      listsize = props.listsize,\n      placeholder = props.placeholder;\n\n  var _a = react_1.useState(null),\n      content = _a[0],\n      saveContent = _a[1];\n\n  var _b = react_1.useState(null),\n      error = _b[0],\n      saveError = _b[1];\n\n  var _c = react_1.useState({\n    overflow: 'hidden'\n  }),\n      styles = _c[0],\n      saveStyles = _c[1];\n\n  var shellRef = react_1.useRef(null);\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // initialize\n\n  react_1.useEffect(function () {\n    var itemrequest = {\n      current: null\n    };\n    var requestidlecallback = window['requestIdleCallback'] ? window['requestIdleCallback'] : requestidlecallback_1.requestIdleCallback;\n    var cancelidlecallback = window['cancelIdleCallback'] ? window['cancelIdleCallback'] : requestidlecallback_1.cancelIdleCallback;\n\n    if (getItem) {\n      itemrequest = requestidlecallback(function () {\n        var value = getItem(index);\n\n        if (value && value.then) {\n          value.then(function (value) {\n            if (isMounted()) {\n              saveContent(value);\n              saveError(null);\n            }\n          })[\"catch\"](function (e) {\n            saveContent(null);\n            saveError(e);\n          });\n        } else {\n          if (isMounted()) {\n            if (value) {\n              saveContent(value);\n              saveError(null);\n            } else {\n              saveError(true);\n              saveContent(null);\n            }\n          }\n        }\n      }, {\n        timeout: 2000\n      });\n    }\n\n    return function () {\n      var requesthandle = itemrequest.current;\n      cancelidlecallback(requesthandle);\n    };\n  }, []); // initialize\n\n  react_1.useEffect(function () {\n    var localcalls = callbacks;\n    localcalls.getElementData && localcalls.getElementData(getElementData(), 'register');\n    return function () {\n      localcalls.getElementData && localcalls.getElementData(getElementData(), 'unregister');\n    };\n  }, [callbacks]);\n  react_1.useEffect(function () {\n    observer.observe(shellRef.current);\n    return function () {\n      observer.unobserve(shellRef.current);\n    };\n  }, [observer]);\n  react_1.useEffect(function () {\n    var newStyles = getShellStyles(orientation, cellHeight, cellWidth, styles);\n\n    if (isMounted()) {\n      saveStyles(newStyles);\n    }\n  }, [orientation, cellHeight, cellWidth]); // cradle ondemand callback parameter value\n\n  var getElementData = react_1.useCallback(function () {\n    return [index, shellRef];\n  }, []); // placeholder handling\n\n  var customholderRef = react_1.useRef(placeholder ? react_1[\"default\"].createElement(placeholder, {\n    index: index,\n    listsize: listsize\n  }) : null);\n  return react_1[\"default\"].createElement(\"div\", {\n    ref: shellRef,\n    \"data-index\": index,\n    style: styles\n  }, styles.width ? content ? content : customholderRef.current ? customholderRef.current : react_1[\"default\"].createElement(placeholder_1[\"default\"], {\n    index: index,\n    listsize: listsize,\n    error: error\n  }) : null);\n}; // ItemShell\n// TODO: memoize this\n\n\nvar getShellStyles = function getShellStyles(orientation, cellHeight, cellWidth, styles) {\n  var styleset = Object.assign({\n    position: 'relative'\n  }, styles);\n\n  if (orientation == 'horizontal') {\n    styleset.width = cellWidth ? cellWidth + 'px' : 'auto';\n    styleset.height = 'auto';\n  } else if (orientation === 'vertical') {\n    styleset.width = 'auto';\n    styleset.height = cellHeight ? cellHeight + 'px' : 'auto';\n  }\n\n  return styleset;\n};\n\nexports[\"default\"] = ItemShell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9pdGVtc2hlbGwudHN4P2ZhYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQU0sU0FBUyxHQUFHLFNBQVosU0FBWSxDQUFDLEtBQUQsRUFBTTtBQUNiO0FBQUEsTUFBYSw2QkFBYjtBQUFBLE1BQXlCLDJCQUF6QjtBQUFBLE1BQW9DLG1CQUFwQztBQUFBLE1BQTJDLHlCQUEzQztBQUFBLE1BQXFELDJCQUFyRDtBQUFBLE1BQWdFLHVCQUFoRTtBQUFBLE1BQXlFLHlCQUF6RTtBQUFBLE1BQW1GLCtCQUFuRjs7QUFFRDtBQUFBLE1BQUMsZUFBRDtBQUFBLE1BQVUsbUJBQVY7O0FBQ0E7QUFBQSxNQUFDLGFBQUQ7QUFBQSxNQUFRLGlCQUFSOztBQUNBOztBQUFBO0FBQUEsTUFBQyxjQUFEO0FBQUEsTUFBUSxrQkFBUjs7QUFHTixNQUFNLFFBQVEsR0FBRyxlQUFPLElBQVAsQ0FBakI7QUFFQSxNQUFNLFNBQVMsR0FBRyxvQ0FBbEIsQ0FWb0IsQ0FZcEI7O0FBQ0Esb0JBQVU7QUFDTixRQUFJLFdBQVcsR0FBRztBQUFDLGFBQU8sRUFBQztBQUFULEtBQWxCO0FBQ0EsUUFBSSxtQkFBbUIsR0FBRyxNQUFNLENBQUMscUJBQUQsQ0FBTixHQUE4QixNQUFNLENBQUMscUJBQUQsQ0FBcEMsR0FBNEQseUNBQXRGO0FBQ0EsUUFBSSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsb0JBQUQsQ0FBTixHQUE2QixNQUFNLENBQUMsb0JBQUQsQ0FBbkMsR0FBMEQsd0NBQW5GOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1QsaUJBQVcsR0FBRyxtQkFBbUIsQ0FBQztBQUU5QixZQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBRCxDQUFuQjs7QUFDQSxZQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBbkIsRUFBeUI7QUFDckIs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USxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFBQyxZQUFRLEVBQUM7QUFBVixHQUFkLEVBQW9DLE1BQXBDLENBQWY7O0FBQ0EsTUFBSSxXQUFXLElBQUksWUFBbkIsRUFBaUM7QUFDN0IsWUFBUSxDQUFDLEtBQVQsR0FBaUIsU0FBUyxHQUFFLFNBQVMsR0FBRyxJQUFkLEdBQW9CLE1BQTlDO0FBQ0EsWUFBUSxDQUFDLE1BQVQsR0FBa0IsTUFBbEI7QUFDSCxHQUhELE1BR08sSUFBSSxXQUFXLEtBQUssVUFBcEIsRUFBZ0M7QUFDbkMsWUFBUSxDQUFDLEtBQVQsR0FBaUIsTUFBakI7QUFDQSxZQUFRLENBQUMsTUFBVCxHQUFrQixVQUFVLEdBQUUsVUFBVSxHQUFHLElBQWYsR0FBcUIsTUFBakQ7QUFDSDs7QUFFRCxTQUFPLFFBQVA7QUFFSCxDQWJEOztBQWVBLHFCQUFlLFNBQWYiLCJmaWxlIjoiLi9zcmMvaXRlbXNoZWxsLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGl0ZW1mcmFtZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG5pbXBvcnQgUmVhY3QsIHt1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7cmVxdWVzdElkbGVDYWxsYmFjaywgY2FuY2VsSWRsZUNhbGxiYWNrfSBmcm9tICdyZXF1ZXN0aWRsZWNhbGxiYWNrJ1xuXG5pbXBvcnQgdXNlSXNNb3VudGVkIGZyb20gJ3JlYWN0LWlzLW1vdW50ZWQtaG9vaydcblxuaW1wb3J0IFBsYWNlaG9sZGVyIGZyb20gJy4vcGxhY2Vob2xkZXInXG5cbmNvbnN0IEl0ZW1TaGVsbCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHtvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBpbmRleCwgb2JzZXJ2ZXIsIGNhbGxiYWNrcywgZ2V0SXRlbSwgbGlzdHNpemUsIHBsYWNlaG9sZGVyfSA9IHByb3BzXG4gICAgXG4gICAgY29uc3QgW2NvbnRlbnQsIHNhdmVDb250ZW50XSA9IHVzZVN0YXRlKG51bGwpXG4gICAgY29uc3QgW2Vycm9yLCBzYXZlRXJyb3JdID0gdXNlU3RhdGUobnVsbClcbiAgICBjb25zdCBbc3R5bGVzLHNhdmVTdHlsZXNdID0gdXNlU3RhdGUoe1xuICAgICAgICBvdmVyZmxvdzonaGlkZGVuJyxcbiAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMpXG4gICAgY29uc3Qgc2hlbGxSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpXG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGl0ZW1yZXF1ZXN0ID0ge2N1cnJlbnQ6bnVsbH1cbiAgICAgICAgbGV0IHJlcXVlc3RpZGxlY2FsbGJhY2sgPSB3aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXT93aW5kb3dbJ3JlcXVlc3RJZGxlQ2FsbGJhY2snXTpyZXF1ZXN0SWRsZUNhbGxiYWNrXG4gICAgICAgIGxldCBjYW5jZWxpZGxlY2FsbGJhY2sgPSB3aW5kb3dbJ2NhbmNlbElkbGVDYWxsYmFjayddP3dpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ106Y2FuY2VsSWRsZUNhbGxiYWNrXG4gICAgICAgIGlmIChnZXRJdGVtKSB7XG4gICAgICAgICAgICBpdGVtcmVxdWVzdCA9IHJlcXVlc3RpZGxlY2FsbGJhY2soKCk9PiB7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRJdGVtKGluZGV4KVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNvbnRlbnQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUVycm9yKG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29udGVudChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUVycm9yKGUpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29udGVudCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRXJyb3IobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUVycm9yKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNvbnRlbnQobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0se3RpbWVvdXQ6MjAwMH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3RoYW5kbGUgPSBpdGVtcmVxdWVzdC5jdXJyZW50XG4gICAgICAgICAgICBjYW5jZWxpZGxlY2FsbGJhY2socmVxdWVzdGhhbmRsZSlcbiAgICAgICAgfVxuICAgIH0sW10pXG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBsZXQgbG9jYWxjYWxscyA9IGNhbGxiYWNrc1xuXG4gICAgICAgIGxvY2FsY2FsbHMuZ2V0RWxlbWVudERhdGEgJiYgbG9jYWxjYWxscy5nZXRFbGVtZW50RGF0YShnZXRFbGVtZW50RGF0YSgpLCdyZWdpc3RlcicpXG4gICAgICAgIHJldHVybiAoKCk9PntcblxuICAgICAgICAgICAgbG9jYWxjYWxscy5nZXRFbGVtZW50RGF0YSAmJiBsb2NhbGNhbGxzLmdldEVsZW1lbnREYXRhKGdldEVsZW1lbnREYXRhKCksJ3VucmVnaXN0ZXInKVxuXG4gICAgICAgIH0pXG5cbiAgICB9LFtjYWxsYmFja3NdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShzaGVsbFJlZi5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoc2hlbGxSZWYuY3VycmVudClcbiAgICAgICAgfVxuXG4gICAgfSxbb2JzZXJ2ZXJdKVxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgbGV0IG5ld1N0eWxlcyA9IGdldFNoZWxsU3R5bGVzKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcylcbiAgICAgICAgaWYgKGlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICBzYXZlU3R5bGVzKG5ld1N0eWxlcylcbiAgICAgICAgfVxuXG4gICAgfSxbb3JpZW50YXRpb24sY2VsbEhlaWdodCxjZWxsV2lkdGhdKVxuXG4gICAgLy8gY3JhZGxlIG9uZGVtYW5kIGNhbGxiYWNrIHBhcmFtZXRlciB2YWx1ZVxuICAgIGNvbnN0IGdldEVsZW1lbnREYXRhID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgcmV0dXJuIFtpbmRleCwgc2hlbGxSZWZdXG4gICAgfSxbXSlcblxuICAgIC8vIHBsYWNlaG9sZGVyIGhhbmRsaW5nXG4gICAgY29uc3QgY3VzdG9taG9sZGVyUmVmID0gdXNlUmVmKHBsYWNlaG9sZGVyP1JlYWN0LmNyZWF0ZUVsZW1lbnQocGxhY2Vob2xkZXIsIHtpbmRleCwgbGlzdHNpemV9KTpudWxsKVxuXG4gICAgcmV0dXJuIDxkaXYgcmVmID0geyBzaGVsbFJlZiB9IGRhdGEtaW5kZXggPSB7aW5kZXh9IHN0eWxlID0ge3N0eWxlc30+XG4gICAgICAgIHtzdHlsZXMud2lkdGg/XG4gICAgICAgICAgICBjb250ZW50P1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6Y3VzdG9taG9sZGVyUmVmLmN1cnJlbnQ/XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWhvbGRlclJlZi5jdXJyZW50OjxQbGFjZWhvbGRlciBpbmRleCA9IHtpbmRleH0gbGlzdHNpemUgPSB7bGlzdHNpemV9IGVycm9yID0ge2Vycm9yfS8+XG4gICAgICAgIDpudWxsfVxuICAgIDwvZGl2PlxuXG59IC8vIEl0ZW1TaGVsbFxuXG4vLyBUT0RPOiBtZW1vaXplIHRoaXNcbmNvbnN0IGdldFNoZWxsU3R5bGVzID0gKG9yaWVudGF0aW9uLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHN0eWxlcykgPT4ge1xuXG4gICAgbGV0IHN0eWxlc2V0ID0gT2JqZWN0LmFzc2lnbih7cG9zaXRpb246J3JlbGF0aXZlJ30sc3R5bGVzKVxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSBjZWxsV2lkdGg/KGNlbGxXaWR0aCArICdweCcpOidhdXRvJ1xuICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSAnYXV0bydcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHN0eWxlc2V0LndpZHRoID0gJ2F1dG8nXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IGNlbGxIZWlnaHQ/KGNlbGxIZWlnaHQgKyAncHgnKTonYXV0bydcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzZXRcblxufVxuXG5leHBvcnQgZGVmYXVsdCBJdGVtU2hlbGxcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/itemshell.tsx\n");

/***/ }),

/***/ "./src/placeholder.tsx":
/*!*****************************!*\
  !*** ./src/placeholder.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // placeholder.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar Placeholder = function Placeholder(_a) {\n  var index = _a.index,\n      listsize = _a.listsize,\n      error = _a.error;\n  var stylesRef = react_1.useRef({\n    position: 'relative',\n    boxSizing: 'border-box',\n    backgroundColor: 'cyan',\n    border: '2px solid black',\n    height: '100%',\n    width: '100%'\n  });\n  var itemStylesRef = react_1.useRef({\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    padding: '3px',\n    opacity: .5,\n    borderRadius: '8px',\n    backgroundColor: 'white',\n    margin: '3px',\n    fontSize: 'smaller'\n  });\n  return react_1[\"default\"].createElement(\"div\", {\n    style: stylesRef.current\n  }, !error ? react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, index + 1, \"/\", listsize) : react_1[\"default\"].createElement(\"div\", {\n    style: itemStylesRef.current\n  }, \"item is not available at this time\"));\n};\n\nexports[\"default\"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9wbGFjZWhvbGRlci50c3g/MTEzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQUF5QjtNQUF2QixnQjtNQUFPLHNCO01BQVUsZ0I7QUFFbkMsTUFBTSxTQUFTLEdBQUcsZUFBTztBQUNyQixZQUFRLEVBQUMsVUFEWTtBQUVyQixhQUFTLEVBQUMsWUFGVztBQUdyQixtQkFBZSxFQUFDLE1BSEs7QUFJckIsVUFBTSxFQUFDLGlCQUpjO0FBS3JCLFVBQU0sRUFBQyxNQUxjO0FBTXJCLFNBQUssRUFBQztBQU5lLEdBQVAsQ0FBbEI7QUFRQSxNQUFNLGFBQWEsR0FBRyxlQUNsQjtBQUNJLFlBQVEsRUFBQyxVQURiO0FBRUksT0FBRyxFQUFDLENBRlI7QUFHSSxRQUFJLEVBQUMsQ0FIVDtBQUlJLFdBQU8sRUFBQyxLQUpaO0FBS0ksV0FBTyxFQUFDLEVBTFo7QUFNSSxnQkFBWSxFQUFDLEtBTmpCO0FBT0ksbUJBQWUsRUFBQyxPQVBwQjtBQVFJLFVBQU0sRUFBQyxLQVJYO0FBU0ksWUFBUSxFQUFDO0FBVGIsR0FEa0IsQ0FBdEI7QUFjQSxTQUFPO0FBQUssU0FBSyxFQUFJLFNBQVMsQ0FBQztBQUF4QixLQUNELENBQUMsS0FBRCxHQUNFO0FBQUssU0FBSyxFQUFJLGFBQWEsQ0FBQztBQUE1QixLQUFzQyxLQUFLLEdBQUcsQ0FBOUMsRSxHQUFBLEVBQWtELFFBQWxELENBREYsR0FFRTtBQUFLLFNBQUssRUFBSSxhQUFhLENBQUM7QUFBNUIsS0FBbUMsb0NBQW5DLENBSEQsQ0FBUDtBQU9ILENBL0JEOztBQWlDQSxxQkFBZSxXQUFmIiwiZmlsZSI6Ii4vc3JjL3BsYWNlaG9sZGVyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgUGxhY2Vob2xkZXIgPSAoe2luZGV4LCBsaXN0c2l6ZSwgZXJyb3J9KSA9PiB7XG5cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J2N5YW4nLFxuICAgICAgICBib3JkZXI6JzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgIHdpZHRoOicxMDAlJ1xuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcylcbiAgICBjb25zdCBpdGVtU3R5bGVzUmVmID0gdXNlUmVmKFxuICAgICAgICB7XG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOjAsXG4gICAgICAgICAgICBsZWZ0OjAsXG4gICAgICAgICAgICBwYWRkaW5nOiczcHgnLFxuICAgICAgICAgICAgb3BhY2l0eTouNSxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czonOHB4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLCBcbiAgICAgICAgICAgIG1hcmdpbjonM3B4JyxcbiAgICAgICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgKVxuXG4gICAgcmV0dXJuIDxkaXYgc3R5bGUgPSB7c3R5bGVzUmVmLmN1cnJlbnR9PlxuICAgICAgICB7ICFlcnJvcj9cbiAgICAgICAgICAgIDxkaXYgc3R5bGUgPSB7aXRlbVN0eWxlc1JlZi5jdXJyZW50fT57aW5kZXggKyAxfS97bGlzdHNpemV9PC9kaXY+OlxuICAgICAgICAgICAgPGRpdiBzdHlsZSA9IHtpdGVtU3R5bGVzUmVmLmN1cnJlbnR9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWU8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICA8L2Rpdj5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxhY2Vob2xkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/placeholder.tsx\n");

/***/ }),

/***/ "./src/scrollblock.tsx":
/*!*****************************!*\
  !*** ./src/scrollblock.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // scrollblock.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar viewport_1 = __webpack_require__(/*! ./viewport */ \"./src/viewport.tsx\");\n\nvar Scrollblock = function Scrollblock(_a) {\n  var children = _a.children,\n      listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      functions = _a.functions,\n      styles = _a.styles; // -------------------------[ context and state ]-------------------------\n\n  var viewportData = react_1.useContext(viewport_1.ViewportContext);\n\n  var _b = react_1.useState('prepare'),\n      blockstate = _b[0],\n      setBlockState = _b[1]; // -----------------------------------[ data heap ]-------------------------\n\n\n  var scrollBlockLengthRef = react_1.useRef(null);\n  var scrollblockRef = react_1.useRef(null);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    backgroundColor: 'white',\n    position: 'relative'\n  }, styles === null || styles === void 0 ? void 0 : styles.cradle));\n\n  var _c = react_1.useState(divlinerstyleRef.current),\n      divlinerstyle = _c[0],\n      saveDivlinerstyle = _c[1]; // to trigger render\n\n\n  var viewportDimensions = viewportData.viewportDimensions,\n      itemobserver = viewportData.itemobserver,\n      isResizing = viewportData.isResizing;\n  var top = viewportDimensions.top,\n      right = viewportDimensions.right,\n      bottom = viewportDimensions.bottom,\n      left = viewportDimensions.left,\n      width = viewportDimensions.width,\n      height = viewportDimensions.height; // state engine\n\n  react_1.useEffect(function () {\n    switch (blockstate) {\n      case 'prepare':\n        {\n          setBlockState('render');\n          break;\n        }\n    }\n  }, [blockstate]);\n  react_1.useLayoutEffect(function () {\n    updateBlockLength();\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, scrollBlockLengthRef);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBlockLength = react_1.useCallback(function () {\n    var scrollblocklength = calcScrollblockLength({\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding,\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width\n    });\n    scrollBlockLengthRef.current = scrollblocklength;\n  }, [listsize, cellHeight, cellWidth, gap, padding, orientation, height, width]);\n  return blockstate != 'prepare' ? react_1[\"default\"].createElement(\"div\", {\n    ref: scrollblockRef,\n    style: divlinerstyleRef.current\n  }, children) : null;\n}; // Scrollblock\n// all the parameters affect the length\n\n\nvar calcScrollblockLength = function calcScrollblockLength(_a) {\n  var listsize = _a.listsize,\n      cellHeight = _a.cellHeight,\n      cellWidth = _a.cellWidth,\n      gap = _a.gap,\n      padding = _a.padding,\n      orientation = _a.orientation,\n      viewportheight = _a.viewportheight,\n      viewportwidth = _a.viewportwidth; // dependents of orientation\n\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n\n  if (orientation == 'vertical') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  } // adjustments to viewportcrosslength\n\n\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap;\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  var listlength = Math.ceil(listsize / crosscount);\n  var straightlength = listlength * cellLength - (listlength > 0 ? gap : 0) + padding * 2;\n  return straightlength;\n};\n\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, scrollblocklengthRef) {\n  var localstyles = Object.assign({}, stylesRef.current);\n  var height;\n  var width;\n\n  if (orientation == 'horizontal') {\n    height = '100%';\n    width = scrollblocklengthRef.current + 'px';\n  } else if (orientation == 'vertical') {\n    height = scrollblocklengthRef.current + 'px';\n    width = '100%';\n  }\n\n  localstyles.height = height;\n  localstyles.width = width;\n  return localstyles;\n};\n\nexports[\"default\"] = Scrollblock;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGxibG9jay50c3g/MmZhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFjLENBQUMsRUFBRCxFQVVuQjtNQVRHLHNCO01BQ0Esc0I7TUFDQSwwQjtNQUNBLHdCO01BQ0EsWTtNQUNBLG9CO01BQ0EsNEI7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FFRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxtQkFBVywwQkFBWCxDQUFyQjs7QUFDTTtBQUFBLE1BQUMsa0JBQUQ7QUFBQSxNQUFZLHFCQUFaLENBSlQsQ0FNRzs7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxlQUFPLElBQVAsQ0FBN0I7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLElBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQ0E7QUFFSSxtQkFBZSxFQUFDLE9BRnBCO0FBR0ksWUFBUSxFQUFDO0FBSGIsR0FEQSxFQU0wQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsTUFObEMsQ0FEcUIsQ0FBekI7O0FBVU07QUFBQSxNQUFDLHFCQUFEO0FBQUEsTUFBZSx5QkFBZixDQW5CVCxDQW1CZ0Y7OztBQUV2RTtBQUFBLE1BQW9CLHdDQUFwQjtBQUFBLE1BQWtDLG9DQUFsQztBQUNBO0FBQUEsTUFBSyxnQ0FBTDtBQUFBLE1BQVksa0NBQVo7QUFBQSxNQUFvQiw4QkFBcEI7QUFBQSxNQUEwQixnQ0FBMUI7QUFBQSxNQUFpQyxrQ0FBakMsQ0F0QlQsQ0F3Qkc7O0FBQ0Esb0JBQVU7QUFDTixZQUFRLFVBQVI7QUFDSSxXQUFLLFNBQUw7QUFBZ0I7QUFDWix1QkFBYSxDQUFDLFFBQUQsQ0FBYjtBQUNBO0FBQ0g7QUFKTDtBQU1ILEdBUEQsRUFPRSxDQUFDLFVBQUQsQ0FQRjtB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LElBQXZDO0FBQ0gsR0FIRCxNQUdPLElBQUksV0FBVyxJQUFJLFVBQW5CLEVBQStCO0FBQ2xDLFVBQU0sR0FBRyxvQkFBb0IsQ0FBQyxPQUFyQixHQUErQixJQUF4QztBQUNBLFNBQUssR0FBRyxNQUFSO0FBQ0g7O0FBQ0QsYUFBVyxDQUFDLE1BQVosR0FBcUIsTUFBckI7QUFDQSxhQUFXLENBQUMsS0FBWixHQUFvQixLQUFwQjtBQUVBLFNBQU8sV0FBUDtBQUNILENBaEJEOztBQWtCQSxxQkFBZSxXQUFmIiwiZmlsZSI6Ii4vc3JjL3Njcm9sbGJsb2NrLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGJsb2NrLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDIwIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IFZpZXdwb3J0Q29udGV4dCB9IGZyb20gJy4vdmlld3BvcnQnXG5cbmNvbnN0IFNjcm9sbGJsb2NrID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICBsaXN0c2l6ZSwgXG4gICAgY2VsbEhlaWdodCwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBnYXAsIFxuICAgIHBhZGRpbmcsIFxuICAgIG9yaWVudGF0aW9uLCBcbiAgICBmdW5jdGlvbnMsIFxuICAgIHN0eWxlcyBcbn0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3Qgdmlld3BvcnREYXRhID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG4gICAgY29uc3QgW2Jsb2Nrc3RhdGUsc2V0QmxvY2tTdGF0ZV0gPSB1c2VTdGF0ZSgncHJlcGFyZScpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZGF0YSBoZWFwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3Qgc2Nyb2xsQmxvY2tMZW5ndGhSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBzY3JvbGxibG9ja1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOid3aGl0ZScsXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICAgICAgXG4gICAgICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcywgc3R5bGVzPy5jcmFkbGUpXG5cbiAgICApXG4gICAgY29uc3QgW2RpdmxpbmVyc3R5bGUsc2F2ZURpdmxpbmVyc3R5bGVdID0gdXNlU3RhdGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KSAvLyB0byB0cmlnZ2VyIHJlbmRlclxuXG4gICAgbGV0IHsgdmlld3BvcnREaW1lbnNpb25zLCBpdGVtb2JzZXJ2ZXIsIGlzUmVzaXppbmcgfSA9IHZpZXdwb3J0RGF0YVxuICAgIGxldCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gdmlld3BvcnREaW1lbnNpb25zXG5cbiAgICAvLyBzdGF0ZSBlbmdpbmVcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgc3dpdGNoIChibG9ja3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlJzoge1xuICAgICAgICAgICAgICAgIHNldEJsb2NrU3RhdGUoJ3JlbmRlcicpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sW2Jsb2Nrc3RhdGVdKVxuICAgIFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgdXBkYXRlQmxvY2tMZW5ndGgoKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyhvcmllbnRhdGlvbixkaXZsaW5lcnN0eWxlUmVmLHNjcm9sbEJsb2NrTGVuZ3RoUmVmKVxuICAgICAgICBzYXZlRGl2bGluZXJzdHlsZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGxpc3RzaXplLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICBdKVxuXG4gICAgY29uc3QgdXBkYXRlQmxvY2tMZW5ndGggPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGJsb2NrbGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgY2FsY1Njcm9sbGJsb2NrTGVuZ3RoKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQ6aGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDp3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgc2Nyb2xsQmxvY2tMZW5ndGhSZWYuY3VycmVudCA9IHNjcm9sbGJsb2NrbGVuZ3RoXG5cbiAgICAgICAgfSxbXG4gICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICBdXG4gICAgKVxuXG4gICAgcmV0dXJuIChibG9ja3N0YXRlICE9ICdwcmVwYXJlJylcbiAgICAgICAgPzxkaXYgcmVmID0ge3Njcm9sbGJsb2NrUmVmfSBzdHlsZT17ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fT57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDpudWxsXG5cbn0gLy8gU2Nyb2xsYmxvY2tcblxuLy8gYWxsIHRoZSBwYXJhbWV0ZXJzIGFmZmVjdCB0aGUgbGVuZ3RoXG5jb25zdCBjYWxjU2Nyb2xsYmxvY2tMZW5ndGggPSAoe1xuICAgIGxpc3RzaXplLCBcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBjZWxsV2lkdGgsIFxuICAgIGdhcCwgXG4gICAgcGFkZGluZywgXG4gICAgb3JpZW50YXRpb24sIFxuICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgIHZpZXdwb3J0d2lkdGgsXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gZGVwZW5kZW50cyBvZiBvcmllbnRhdGlvblxuICAgIGxldCBjcm9zc2xlbmd0aFxuICAgIGxldCBjZWxsTGVuZ3RoXG4gICAgbGV0IHZpZXdwb3J0Y3Jvc3NsZW5ndGhcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsSGVpZ2h0ICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydHdpZHRoIFxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxIZWlnaHQgKyBnYXBcbiAgICAgICAgY2VsbExlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnRoZWlnaHRcblxuICAgIH1cbiAgICAvLyBhZGp1c3RtZW50cyB0byB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCAtPSAocGFkZGluZyAqIDIpXG4gICAgdmlld3BvcnRjcm9zc2xlbmd0aCArPSBnYXBcblxuICAgIGlmICh2aWV3cG9ydGNyb3NzbGVuZ3RoIDwgY3Jvc3NsZW5ndGgpIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSBjcm9zc2xlbmd0aCAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZVxuICAgIGxldCBjcm9zc2NvdW50ID0gTWF0aC5mbG9vcih2aWV3cG9ydGNyb3NzbGVuZ3RoL2Nyb3NzbGVuZ3RoKVxuXG4gICAgbGV0IGxpc3RsZW5ndGggPSBNYXRoLmNlaWwobGlzdHNpemUvY3Jvc3Njb3VudClcblxuICAgIGxldCBzdHJhaWdodGxlbmd0aCA9IChsaXN0bGVuZ3RoICogY2VsbExlbmd0aCkgLSAoKGxpc3RsZW5ndGggPiAwKT9nYXA6MCkgKyAocGFkZGluZyAqIDIpXG5cbiAgICByZXR1cm4gc3RyYWlnaHRsZW5ndGhcblxufVxuXG5jb25zdCB1cGRhdGVTY3JvbGxibG9ja1N0eWxlcyA9IChvcmllbnRhdGlvbixzdHlsZXNSZWYsc2Nyb2xsYmxvY2tsZW5ndGhSZWYpID0+IHtcblxuICAgIGxldCBsb2NhbHN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sc3R5bGVzUmVmLmN1cnJlbnQpIGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICBsZXQgaGVpZ2h0IFxuICAgIGxldCB3aWR0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgIHdpZHRoID0gc2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gc2Nyb2xsYmxvY2tsZW5ndGhSZWYuY3VycmVudCArICdweCdcbiAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuXG4gICAgcmV0dXJuIGxvY2Fsc3R5bGVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbGJsb2NrXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scrollblock.tsx\n");

/***/ }),

/***/ "./src/scrolltracker.tsx":
/*!*******************************!*\
  !*** ./src/scrolltracker.tsx ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // scrolltracker.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nvar ScrollTracker = function ScrollTracker(_a) {\n  var top = _a.top,\n      left = _a.left,\n      offset = _a.offset,\n      listsize = _a.listsize,\n      styles = _a.styles;\n  var trackdata = offset + 1 + \"/\" + listsize;\n  var styleRef = react_1.useRef(Object.assign({\n    top: top + 'px',\n    left: left + 'px',\n    position: 'fixed',\n    zIndex: 3,\n    backgroundColor: 'white',\n    border: '1px solid gray',\n    borderRadius: '10px',\n    fontSize: 'smaller',\n    padding: '3px'\n  }, styles === null || styles === void 0 ? void 0 : styles.scrolltracker));\n  return react_1[\"default\"].createElement(\"div\", {\n    \"data-name\": 'scrolltracker',\n    style: styleRef.current\n  }, trackdata);\n};\n\nexports[\"default\"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy9zY3JvbGx0cmFja2VyLnRzeD9mZjgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJDQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQSxJQUFNLGFBQWEsR0FBRyxTQUFoQixhQUFnQixDQUFDLEVBQUQsRUFBd0M7TUFBckMsWTtNQUFLLGM7TUFBTSxrQjtNQUFRLHNCO01BQVUsa0I7QUFFbEQsTUFBSSxTQUFTLEdBQU0sTUFBTSxHQUFHLENBQVQsR0FBVSxHQUFWLEdBQWMsUUFBakM7QUFFQSxNQUFJLFFBQVEsR0FBRyxlQUFPLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDaEMsT0FBRyxFQUFFLEdBQUcsR0FBRyxJQURxQjtBQUVoQyxRQUFJLEVBQUUsSUFBSSxHQUFHLElBRm1CO0FBR2hDLFlBQVEsRUFBQyxPQUh1QjtBQUloQyxVQUFNLEVBQUMsQ0FKeUI7QUFLaEMsbUJBQWUsRUFBQyxPQUxnQjtBQU1oQyxVQUFNLEVBQUUsZ0JBTndCO0FBT2hDLGdCQUFZLEVBQUMsTUFQbUI7QUFRaEMsWUFBUSxFQUFDLFNBUnVCO0FBU2hDLFdBQU8sRUFBQztBQVR3QixHQUFkLEVBVUcsTUFBTSxTQUFOLFVBQU0sV0FBTixHQUFNLE1BQU4sU0FBTSxDQUFFLGFBVlgsQ0FBUCxDQUFmO0FBWUEsU0FBTztBQUFBLGlCQUFpQixlQUFqQjtBQUFpQyxTQUFLLEVBQUksUUFBUSxDQUFDO0FBQW5ELEtBQThELFNBQTlELENBQVA7QUFDSCxDQWpCRDs7QUFtQkEscUJBQWUsYUFBZiIsImZpbGUiOiIuL3NyYy9zY3JvbGx0cmFja2VyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbHRyYWNrZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMjAgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmfSBmcm9tICdyZWFjdCdcblxuY29uc3QgU2Nyb2xsVHJhY2tlciA9ICh7IHRvcCwgbGVmdCwgb2Zmc2V0LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGxldCB0cmFja2RhdGEgPSBgJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfWBcblxuICAgIGxldCBzdHlsZVJlZiA9IHVzZVJlZihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246J2ZpeGVkJyxcbiAgICAgICAgekluZGV4OjMsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjond2hpdGUnLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgZ3JheScsXG4gICAgICAgIGJvcmRlclJhZGl1czonMTBweCcsXG4gICAgICAgIGZvbnRTaXplOidzbWFsbGVyJyxcbiAgICAgICAgcGFkZGluZzonM3B4J1xuICAgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyxzdHlsZXM/LnNjcm9sbHRyYWNrZXIpKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS1uYW1lID0gJ3Njcm9sbHRyYWNrZXInIHN0eWxlID0ge3N0eWxlUmVmLmN1cnJlbnR9ID57dHJhY2tkYXRhfTwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxUcmFja2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scrolltracker.tsx\n");

/***/ }),

/***/ "./src/viewport.tsx":
/*!**************************!*\
  !*** ./src/viewport.tsx ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // viewport.tsx\n// copyright (c) 2020 Henrik Bechmann, Toronto, Licence: MIT\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n    The role of viewport is to provide data to its children (scrollblock and cradle),\n    and act as the visible portal of the list being shown\n*/\n\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n\nexports.ViewportContext = react_1[\"default\"].createContext(null);\n\nvar react_is_mounted_hook_1 = __importDefault(__webpack_require__(/*! react-is-mounted-hook */ \"./node_modules/react-is-mounted-hook/lib/index.js\"));\n\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\n\nvar LocalResizeObserver = window['ResizeObserver'] || resize_observer_polyfill_1[\"default\"]; // control constant\n\nvar RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE = 250;\n\nvar Viewport = function Viewport(_a) {\n  // -----------------------[ initialize ]------------------\n  var children = _a.children,\n      orientation = _a.orientation,\n      cellWidth = _a.cellWidth,\n      cellHeight = _a.cellHeight,\n      gap = _a.gap,\n      padding = _a.padding,\n      functions = _a.functions,\n      styles = _a.styles; // processing state\n\n  var _b = react_1.useState('prepare'),\n      portstate = _b[0],\n      setPortState = _b[1];\n\n  var portstateRef = react_1.useRef(null);\n  portstateRef.current = portstate;\n  var isMounted = react_is_mounted_hook_1[\"default\"](); // data heap\n\n  var timeoutidRef = react_1.useRef(null);\n  var viewportdivRef = react_1.useRef(undefined);\n  var divlinerstyleRef = react_1.useRef(Object.assign({\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    overflow: 'auto',\n    backgroundColor: 'red'\n  }, styles === null || styles === void 0 ? void 0 : styles.viewport));\n  var resizeTimeridRef = react_1.useRef(null);\n  var isResizingRef = react_1.useRef(false);\n  var viewportDataRef = react_1.useRef(null);\n  var resizeObserverRef = react_1.useRef(null); // initialize\n\n  react_1.useEffect(function () {\n    resizeObserverRef.current = new LocalResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportdivRef.current);\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  var resizeCallback = react_1.useCallback(function (entries) {\n    if (portstateRef.current == 'prepare') return;\n\n    if (!isResizingRef.current) {\n      isResizingRef.current = true; // below is a realtime message to cradle.onScroll\n      // to stop updating the referenceIndexData, and to the item observer to stop\n      // triggering responses (anticipating reset of cradle content based on resize)\n\n      viewportDataRef.current.isResizing = true;\n      if (isMounted()) setPortState('resizing');\n    }\n\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMounted()) setPortState('resize');\n    }, RESIZE_TIMEOUT_FOR_ONAFTERSRESIZE);\n  }, []); // ----------------------------------[ calculate ]--------------------------------\n  // calculated values\n\n  divlinerstyleRef.current = react_1.useMemo(function () {\n    var mincrosslength = calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding);\n\n    var styles = __assign({}, divlinerstyleRef.current);\n\n    if (orientation == 'vertical') {\n      styles.minWidth = mincrosslength + 'px';\n      styles.minHeight = 'auto';\n    } else {\n      styles.minWidth = 'auto';\n      styles.minHeight = mincrosslength + 'px';\n    }\n\n    return styles;\n  }, [orientation, cellWidth, cellHeight, padding]); // TODO: gap?\n\n  var viewportClientRect;\n\n  if (viewportdivRef.current) {\n    viewportClientRect = viewportdivRef.current.getBoundingClientRect();\n  } else {\n    viewportClientRect = {};\n  }\n\n  var top = viewportClientRect.top,\n      right = viewportClientRect.right,\n      bottom = viewportClientRect.bottom,\n      left = viewportClientRect.left; // set context data for children\n\n  viewportDataRef.current = react_1.useMemo(function () {\n    var width, height, localViewportData;\n\n    if (!(top === undefined)) {\n      //proxy\n      width = right - left;\n      height = bottom - top;\n      localViewportData = {\n        viewportDimensions: {\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n          width: width,\n          height: height\n        },\n        elementref: viewportdivRef,\n        isResizing: isResizingRef.current\n      };\n    }\n\n    return localViewportData;\n  }, [orientation, top, right, bottom, left, isResizingRef.current]); // --------------------[ state processing ]---------------------------\n\n  react_1.useEffect(function () {\n    switch (portstate) {\n      case 'prepare':\n      case 'resize':\n        {\n          setPortState('render');\n          break;\n        }\n    }\n  }, [portstate]); // ----------------------[ render ]--------------------------------\n\n  return react_1[\"default\"].createElement(exports.ViewportContext.Provider, {\n    value: viewportDataRef.current\n  }, react_1[\"default\"].createElement(\"div\", {\n    style: divlinerstyleRef.current,\n    ref: viewportdivRef\n  }, portstate != 'prepare' ? children : null));\n}; // Viewport\n// establish minimum width/height for the viewport -- approximately one item\n\n\nvar calcMinViewportCrossLength = function calcMinViewportCrossLength(orientation, cellWidth, cellHeight, padding) {\n  var crosslength, cellLength;\n\n  if (orientation == 'vertical') {\n    cellLength = cellWidth;\n  } else {\n    cellLength = cellHeight;\n  }\n\n  crosslength = cellLength + padding * 2;\n  return crosslength;\n};\n\nexports[\"default\"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci8uL3NyYy92aWV3cG9ydC50c3g/MGRlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7O0FBRWEsMEJBQWtCLG1CQUFNLGFBQU4sQ0FBb0IsSUFBcEIsQ0FBbEI7O0FBRWI7O0FBRUE7O0FBRUEsSUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsZ0JBQUQsQ0FBTixJQUE0QixxQ0FBeEQsQyxDQUVBOztBQUNBLElBQU0saUNBQWlDLEdBQUcsR0FBMUM7O0FBRUEsSUFBTSxRQUFRLEdBQUcsU0FBWCxRQUFXLENBQUMsRUFBRCxFQVNoQjtBQUVHO01BVkEsc0I7TUFDQSw0QjtNQUNBLHdCO01BQ0EsMEI7TUFDQSxZO01BQ0Esb0I7TUFDQSx3QjtNQUNBLGtCLENBQ0gsQ0FJRzs7QUFDTTtBQUFBLE1BQUMsaUJBQUQ7QUFBQSxNQUFXLG9CQUFYOztBQUNOLE1BQU0sWUFBWSxHQUFHLGVBQU8sSUFBUCxDQUFyQjtBQUNBLGNBQVksQ0FBQyxPQUFiLEdBQXVCLFNBQXZCO0FBQ0EsTUFBTSxTQUFTLEdBQUcsb0NBQWxCLENBUkgsQ0FTRzs7QUFDQSxNQUFNLFlBQVksR0FBRyxlQUFPLElBQVAsQ0FBckI7QUFDQSxNQUFNLGNBQWMsR0FBRyxlQUFPLFNBQVAsQ0FBdkI7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGVBQ3JCLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDZCxZQUFRLEVBQUMsVUFESztBQUVkLE9BQUcsRUFBQyxDQUZVO0FBR2QsU0FBSyxFQUFDLENBSFE7QUFJZCxVQUFNLEVBQUMsQ0FKTztBQUtkLFFBQUksRUFBQyxDQUxTO0FBTWQsWUFBUSxFQUFDLE1BTks7QUFPZCxtQkFBZSxFQUFDO0FBUEYsR0FBZCxFQVFxQixNQUFNLFNBQU4sVUFBTSxXQUFOLEdBQU0sTUFBTixTQUFNLENBQUUsUUFSN0IsQ0FEcUIsQ0FBekI7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V0FBUDtBQUNILENBVEQ7O0FBV0EscUJBQWUsUUFBZiIsImZpbGUiOiIuL3NyYy92aWV3cG9ydC50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3cG9ydC50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAyMCBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIHZpZXdwb3J0IGlzIHRvIHByb3ZpZGUgZGF0YSB0byBpdHMgY2hpbGRyZW4gKHNjcm9sbGJsb2NrIGFuZCBjcmFkbGUpLCBcbiAgICBhbmQgYWN0IGFzIHRoZSB2aXNpYmxlIHBvcnRhbCBvZiB0aGUgbGlzdCBiZWluZyBzaG93blxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VDYWxsYmFja30gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBWaWV3cG9ydENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpXG5cbmltcG9ydCB1c2VJc01vdW50ZWQgZnJvbSAncmVhY3QtaXMtbW91bnRlZC1ob29rJ1xuXG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbCBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnXG5cbmNvbnN0IExvY2FsUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3dbJ1Jlc2l6ZU9ic2VydmVyJ10gfHwgUmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbFxuXG4vLyBjb250cm9sIGNvbnN0YW50XG5jb25zdCBSRVNJWkVfVElNRU9VVF9GT1JfT05BRlRFUlNSRVNJWkUgPSAyNTBcblxuY29uc3QgVmlld3BvcnQgPSAoe1xuICAgIGNoaWxkcmVuLCBcbiAgICBvcmllbnRhdGlvbiwgXG4gICAgY2VsbFdpZHRoLCBcbiAgICBjZWxsSGVpZ2h0LCBcbiAgICBnYXAsIFxuICAgIHBhZGRpbmcsIFxuICAgIGZ1bmN0aW9ucywgXG4gICAgc3R5bGVzLFxufSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gcHJvY2Vzc2luZyBzdGF0ZVxuICAgIGNvbnN0IFtwb3J0c3RhdGUsc2V0UG9ydFN0YXRlXSA9IHVzZVN0YXRlKCdwcmVwYXJlJylcbiAgICBjb25zdCBwb3J0c3RhdGVSZWYgPSB1c2VSZWYobnVsbClcbiAgICBwb3J0c3RhdGVSZWYuY3VycmVudCA9IHBvcnRzdGF0ZVxuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpXG4gICAgLy8gZGF0YSBoZWFwXG4gICAgY29uc3QgdGltZW91dGlkUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3Qgdmlld3BvcnRkaXZSZWYgPSB1c2VSZWYodW5kZWZpbmVkKVxuICAgIGNvbnN0IGRpdmxpbmVyc3R5bGVSZWYgPSB1c2VSZWYoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICB0b3A6MCxcbiAgICAgICAgcmlnaHQ6MCxcbiAgICAgICAgYm90dG9tOjAsXG4gICAgICAgIGxlZnQ6MCxcbiAgICAgICAgb3ZlcmZsb3c6J2F1dG8nLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J3JlZCcsXG4gICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLHN0eWxlcz8udmlld3BvcnQpKVxuICAgIGNvbnN0IHJlc2l6ZVRpbWVyaWRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBpc1Jlc2l6aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHZpZXdwb3J0RGF0YVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IExvY2FsUmVzaXplT2JzZXJ2ZXIocmVzaXplQ2FsbGJhY2spXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQub2JzZXJ2ZSh2aWV3cG9ydGRpdlJlZi5jdXJyZW50KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IHJlc2l6ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpPT57XG4gICAgICAgIGlmIChwb3J0c3RhdGVSZWYuY3VycmVudCA9PSAncHJlcGFyZScpIHJldHVyblxuXG4gICAgICAgIGlmICghaXNSZXNpemluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgPSB0cnVlIFxuICAgICAgICAgICAgICAgIC8vIGJlbG93IGlzIGEgcmVhbHRpbWUgbWVzc2FnZSB0byBjcmFkbGUub25TY3JvbGxcbiAgICAgICAgICAgICAgICAvLyB0byBzdG9wIHVwZGF0aW5nIHRoZSByZWZlcmVuY2VJbmRleERhdGEsIGFuZCB0byB0aGUgaXRlbSBvYnNlcnZlciB0byBzdG9wXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmluZyByZXNwb25zZXMgKGFudGljaXBhdGluZyByZXNldCBvZiBjcmFkbGUgY29udGVudCBiYXNlZCBvbiByZXNpemUpXG4gICAgICAgICAgICB2aWV3cG9ydERhdGFSZWYuY3VycmVudC5pc1Jlc2l6aW5nID0gdHJ1ZVxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZCgpKSBzZXRQb3J0U3RhdGUoJ3Jlc2l6aW5nJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lcmlkUmVmLmN1cnJlbnQpXG4gICAgICAgIHJlc2l6ZVRpbWVyaWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZCgpKSBzZXRQb3J0U3RhdGUoJ3Jlc2l6ZScpXG5cbiAgICAgICAgfSxSRVNJWkVfVElNRU9VVF9GT1JfT05BRlRFUlNSRVNJWkUpXG5cbiAgICB9LFtdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gY2FsY3VsYXRlZCB2YWx1ZXNcbiAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IG1pbmNyb3NzbGVuZ3RoID0gY2FsY01pblZpZXdwb3J0Q3Jvc3NMZW5ndGgob3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcGFkZGluZylcbiAgICAgICAgbGV0IHN0eWxlcyA9IHsuLi5kaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnR9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHN0eWxlcy5taW5XaWR0aCA9IG1pbmNyb3NzbGVuZ3RoICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9ICdhdXRvJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLm1pbldpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBzdHlsZXMubWluSGVpZ2h0ID0gbWluY3Jvc3NsZW5ndGggKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVzXG5cbiAgICB9LFtvcmllbnRhdGlvbiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBwYWRkaW5nXSkgLy8gVE9ETzogZ2FwP1xuXG4gICAgbGV0IHZpZXdwb3J0Q2xpZW50UmVjdFxuICAgIGlmICh2aWV3cG9ydGRpdlJlZi5jdXJyZW50KSB7XG4gICAgICAgIHZpZXdwb3J0Q2xpZW50UmVjdCA9IHZpZXdwb3J0ZGl2UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3cG9ydENsaWVudFJlY3QgPSB7fVxuICAgIH1cbiAgICBsZXQge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0gPSB2aWV3cG9ydENsaWVudFJlY3RcblxuICAgIC8vIHNldCBjb250ZXh0IGRhdGEgZm9yIGNoaWxkcmVuXG4gICAgdmlld3BvcnREYXRhUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IHdpZHRoLCBoZWlnaHQsIGxvY2FsVmlld3BvcnREYXRhXG4gICAgICAgIGlmICghKHRvcCA9PT0gdW5kZWZpbmVkKSkgeyAvL3Byb3h5XG4gICAgICAgICAgICB3aWR0aCA9IChyaWdodCAtIGxlZnQpXG4gICAgICAgICAgICBoZWlnaHQgPSAoYm90dG9tIC0gdG9wKVxuICAgICAgICAgICAgbG9jYWxWaWV3cG9ydERhdGEgPSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zOnt0b3AscmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodH0sXG4gICAgICAgICAgICAgICAgZWxlbWVudHJlZjp2aWV3cG9ydGRpdlJlZixcbiAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nOmlzUmVzaXppbmdSZWYuY3VycmVudCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxWaWV3cG9ydERhdGFcblxuICAgIH0sW29yaWVudGF0aW9uLCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIGlzUmVzaXppbmdSZWYuY3VycmVudF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgc3RhdGUgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHN3aXRjaCAocG9ydHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdwcmVwYXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6IHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0U3RhdGUoJ3JlbmRlcicpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sW3BvcnRzdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZW5kZXIgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmV0dXJuIDxWaWV3cG9ydENvbnRleHQuUHJvdmlkZXIgdmFsdWUgPSB7IHZpZXdwb3J0RGF0YVJlZi5jdXJyZW50IH0+XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICBzdHlsZSA9IHtkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnR9XG4gICAgICAgICAgICByZWYgPSB7dmlld3BvcnRkaXZSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsgKHBvcnRzdGF0ZSAhPSAncHJlcGFyZScpP2NoaWxkcmVuOm51bGwgfVxuICAgICAgICA8L2Rpdj5cbiAgICA8L1ZpZXdwb3J0Q29udGV4dC5Qcm92aWRlcj5cbiAgICBcbn0gLy8gVmlld3BvcnRcblxuLy8gZXN0YWJsaXNoIG1pbmltdW0gd2lkdGgvaGVpZ2h0IGZvciB0aGUgdmlld3BvcnQgLS0gYXBwcm94aW1hdGVseSBvbmUgaXRlbVxuY29uc3QgY2FsY01pblZpZXdwb3J0Q3Jvc3NMZW5ndGggPSAob3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcGFkZGluZykgPT4ge1xuICAgIGxldCBjcm9zc2xlbmd0aCwgY2VsbExlbmd0aFxuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIGNlbGxMZW5ndGggPSBjZWxsV2lkdGhcbiAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodFxuICAgIH1cbiAgICBjcm9zc2xlbmd0aCA9IGNlbGxMZW5ndGggKyAocGFkZGluZyAqIDIpXG4gICAgcmV0dXJuIGNyb3NzbGVuZ3RoXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/viewport.tsx\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TY3JvbGxlci9leHRlcm5hbCBcIlJlYWN0XCI/YzQ4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJyZWFjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });
});