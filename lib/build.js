/*! For license information please see build.js.LICENSE.txt */
!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],F):"object"==typeof exports?exports["react-infinite-grid-scroller"]=F(require("react"),require("react-dom")):Q["react-infinite-grid-scroller"]=F(Q.react,Q["react-dom"])}(self,((__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{var __webpack_modules__={"./src/CellFrame.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of CellFrame is to fetch user content from the cache, or from the host (using getItem).\n    While an item is being fetched, CellFrame presents a placeholder (either the default or an\n    imported custom version). If there is an error in fetching content then the placeholder is used\n    to present the error to the user. If a new itemID is set by the parent (to synchronize with an altered\n    cache), then CellFrame replaces the old item with the new item.\n\n    getItem (which is a function provided by the host) can return one of several values:\n        - a React component\n        - a promise of a component\n        - null\n        - undefined\n    Anything else is treated as an error\n\n    if a promise is returned, then the promise returns a React component, null or undefined.\n\n    If a valid react component is returned from getItem, then it is instantiated in the cache, and rendered in the\n    CellFrame. If null is returned, then CellFrame sends a message to its scroller that the host has\n    indicated the the item being fetched instead represents the end of the list, and the listsize should\n    be adjusted accordingly. Any other value that is returned is treated as an error, and presented\n    as such to the user through the placeholder component.\n\n    getItem sends the index (logical index in the list) and a session itemID to the host, so that\n    the host can sync its own tracking with the scroller.\n\n    One CellFrame at a time is designated as the host of the two triggerLines with the isTriggerCell flag.\n    The triggerlines trigger an update of the Cradle through an IntersectionObserver.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar requestidlecallback_1 = __webpack_require__(/*! requestidlecallback */ "./node_modules/requestidlecallback/index.js"); // polyfill if needed\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js"); // fetch from cache\nvar Placeholder_1 = __importDefault(__webpack_require__(/*! ./cellframe/Placeholder */ "./src/cellframe/Placeholder.tsx")); // default\nvar Cradle_1 = __webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx");\nvar defaultPlaceholderMessages = {\n  loading: \'(loading...)\',\n  retrieving: \'(retrieving from cache)\',\n  "null": \'end of list\',\n  undefined: \'host returned "undefined"\',\n  invalid: \'invalid React element\'\n};\nvar CellFrame = function CellFrame(_ref) {\n  var orientation = _ref.orientation,\n    cellHeight = _ref.cellHeight,\n    cellWidth = _ref.cellWidth,\n    cellMinHeight = _ref.cellMinHeight,\n    cellMinWidth = _ref.cellMinWidth,\n    layout = _ref.layout,\n    getItem = _ref.getItem,\n    listsize = _ref.listsize,\n    placeholder = _ref.placeholder,\n    itemID = _ref.itemID,\n    index = _ref.index,\n    instanceID = _ref.instanceID,\n    scrollerID = _ref.scrollerID,\n    isTriggercell = _ref.isTriggercell,\n    placeholderFrameStyles = _ref.placeholderFrameStyles,\n    placeholderLinerStyles = _ref.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref.placeholderErrorLinerStyles,\n    placeholderMessages = _ref.placeholderMessages,\n    usePlaceholder = _ref.usePlaceholder,\n    gridstartstyle = _ref.gridstartstyle;\n  var coreConfigRef = (0, react_1.useRef)(null);\n  coreConfigRef.current = {\n    orientation: orientation,\n    layout: layout,\n    cellWidth: cellWidth,\n    cellHeight: cellHeight\n  };\n  // ----------------------[ setup ]----------------------\n  var cradleContext = (0, react_1.useContext)(Cradle_1.CradleContext);\n  var cacheAPI = cradleContext.cacheAPI,\n    scrollerPropertiesRef = cradleContext.scrollerPropertiesRef,\n    nullItemSetMaxListsize = cradleContext.nullItemSetMaxListsize,\n    itemExceptionCallback = cradleContext.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT = cradleContext.IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef = cradleContext.triggercellTriggerlinesRef;\n  // style change generates state refresh\n  var stylesRef = (0, react_1.useRef)({});\n  var holderStylesRef = (0, react_1.useRef)({});\n  var placeholderMessagesRef = (0, react_1.useRef)(null);\n  placeholderMessagesRef.current = (0, react_1.useMemo)(function () {\n    var newMessages = Object.assign(Object.assign({}, defaultPlaceholderMessages), placeholderMessages);\n    return newMessages;\n  }, [placeholderMessages]);\n  // processing state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameState = _ref3[0],\n    setFrameState = _ref3[1];\n  var frameStateRef = (0, react_1.useRef)(null);\n  frameStateRef.current = frameState;\n  // DOM ref\n  var frameRef = (0, react_1.useRef)(null);\n  // to track unmount interrupt\n  var isMountedRef = (0, react_1.useRef)(true);\n  // cache data\n  var portalMetadataRef = (0, react_1.useRef)(null);\n  // the placeholder to use\n  var placeholderRef = (0, react_1.useRef)(null);\n  // the session itemID to use; could be updated by parent\n  var itemIDRef = (0, react_1.useRef)(null);\n  itemIDRef.current = itemID;\n  var cellFramePropertiesRef = (0, react_1.useRef)(null);\n  cellFramePropertiesRef.current = {\n    itemID: itemID,\n    index: index\n  };\n  // fetch error\n  var errorRef = (0, react_1.useRef)(false);\n  // placeholder message\n  var messageRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // for unmount\n  (0, react_1.useEffect)(function () {\n    return function () {\n      cancelidlecallback(requestIdleCallbackIdRef.current);\n      cacheAPI.unregisterPendingPortal(index);\n    };\n  }, []);\n  // refresh content if itemID changes\n  (0, react_1.useLayoutEffect)(function () {\n    if (frameStateRef.current == \'setup\') return;\n    if (isMountedRef.current) setFrameState(\'getusercontent\');\n  }, [itemID]);\n  // ----------------- [ placeholder definition ] -------------------------\n  var customplaceholder = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    return placeholder ? react_1["default"].createElement(placeholder, {\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current\n    }) : null;\n  }, [index, placeholder, listsize, messageRef.current, errorRef.current, usePlaceholder]);\n  placeholderRef.current = (0, react_1.useMemo)(function () {\n    if (!usePlaceholder) return null;\n    var placeholder = customplaceholder ? customplaceholder : react_1["default"].createElement(Placeholder_1["default"], {\n      key: \'placeholder\',\n      index: index,\n      listsize: listsize,\n      message: messageRef.current,\n      error: errorRef.current,\n      userFrameStyles: placeholderFrameStyles,\n      userLinerStyles: placeholderLinerStyles,\n      userErrorFrameStyles: placeholderErrorFrameStyles,\n      userErrorLinerStyles: placeholderErrorLinerStyles\n    });\n    return placeholder;\n  }, [index, customplaceholder, listsize, messageRef.current, errorRef.current, usePlaceholder, placeholderFrameStyles, placeholderLinerStyles, placeholderErrorFrameStyles, placeholderErrorLinerStyles]);\n  // ---------------- [ requestidlecallback config ] ------------------------\n  var requestidlecallback =\n  // requestIdleCallback\n  window[\'requestIdleCallback\'] ? window[\'requestIdleCallback\'] : requestidlecallback_1.requestIdleCallback;\n  var cancelidlecallback =\n  // cancelIdleCallback\n  window[\'cancelIdleCallback\'] ? window[\'cancelIdleCallback\'] : requestidlecallback_1.cancelIdleCallback;\n  var requestIdleCallbackIdRef = (0, react_1.useRef)(null);\n  // --------------------[ processing ]-----------------\n  // set styles\n  (0, react_1.useEffect)(function () {\n    var newFrameStyles = getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, stylesRef.current);\n    if (gridstartstyle) {\n      newFrameStyles = Object.assign(Object.assign({}, newFrameStyles), gridstartstyle);\n    }\n    var newHolderStyles = getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight);\n    if (isMountedRef.current) {\n      stylesRef.current = newFrameStyles;\n      holderStylesRef.current = newHolderStyles;\n    }\n  }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, gridstartstyle]);\n  var portalNodeRef = (0, react_1.useRef)(null);\n  (0, react_1.useLayoutEffect)(function () {\n    switch (frameState) {\n      case \'setup\':\n        {\n          setFrameState(\'working\'); // \'getusercontent\' will be called\n          break;\n        }\n      case \'working\':\n        {\n          setFrameState(\'getusercontent\'); // delay paint while working\n          break;\n        }\n      case \'getusercontent\':\n        {\n          var _itemID = itemIDRef.current;\n          var cached = cacheAPI.hasPortal(_itemID);\n          var _coreConfigRef$curren = coreConfigRef.current,\n            _layout = _coreConfigRef$curren.layout,\n            _orientation = _coreConfigRef$curren.orientation,\n            _cellWidth = _coreConfigRef$curren.cellWidth,\n            _cellHeight = _coreConfigRef$curren.cellHeight;\n          if (cached) {\n            messageRef.current = placeholderMessagesRef.current.retrieving;\n            if (isMountedRef.current) {\n              // get cache data\n              portalMetadataRef.current = cacheAPI.getPortalMetadata(_itemID);\n              // update cell and scroller properties ref in case of switch in either\n              portalMetadataRef.current.scrollerProperties.cellFramePropertiesRef = cellFramePropertiesRef;\n              portalMetadataRef.current.scrollerProperties.scrollerPropertiesRef = scrollerPropertiesRef;\n              // get OutPortal node\n              portalNodeRef.current = portalMetadataRef.current.portalNode;\n              setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n              setFrameState(\'retrieved\');\n            }\n          } else {\n            messageRef.current = placeholderMessagesRef.current.loading;\n            // reserve space in the cache\n            cacheAPI.registerPendingPortal(index);\n            // enqueue the fetch\n            requestIdleCallbackIdRef.current = requestidlecallback(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _a, _b, returnvalue, usercontent, error, isValidElement, content, scrollerProperties, addinCount, addinProps, retval;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.prev = 0;\n                      _context.next = 3;\n                      return getItem(index, _itemID);\n                    case 3:\n                      usercontent = _context.sent;\n                      if (usercontent === null) returnvalue = usercontent;\n                      if (usercontent === undefined) {\n                        error = new Error(placeholderMessagesRef.current.undefined);\n                      }\n                      _context.next = 12;\n                      break;\n                    case 8:\n                      _context.prev = 8;\n                      _context.t0 = _context["catch"](0);\n                      returnvalue = usercontent = undefined;\n                      error = _context.t0;\n                    case 12:\n                      // process the return value\n                      if (usercontent !== null && usercontent !== undefined) {\n                        isValidElement = react_1["default"].isValidElement(usercontent);\n                        if (!isValidElement) {\n                          returnvalue = usercontent;\n                          usercontent = undefined;\n                          error = new Error(placeholderMessagesRef.current.invalid);\n                        }\n                      }\n                      if (!isMountedRef.current) {\n                        _context.next = 30;\n                        break;\n                      }\n                      if (!(usercontent !== null && usercontent !== undefined)) {\n                        _context.next = 28;\n                        break;\n                      }\n                      // if usercontent is otherwise disallowed, let error handling deal with it.\n                      scrollerProperties = {\n                        cellFramePropertiesRef: cellFramePropertiesRef,\n                        scrollerPropertiesRef: scrollerPropertiesRef\n                      };\n                      addinCount = 0;\n                      addinProps = {};\n                      if ((_a = usercontent.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\'scrollerProperties\')) {\n                        addinProps.scrollerProperties = scrollerProperties;\n                        addinCount++;\n                      }\n                      if ((_b = usercontent.props) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(\'cacheAPI\')) {\n                        addinProps.cacheAPI = cacheAPI.instance;\n                        addinCount++;\n                      }\n                      if (addinCount) {\n                        content = react_1["default"].cloneElement(usercontent, addinProps);\n                      } else {\n                        content = usercontent;\n                      }\n                      _context.next = 23;\n                      return cacheAPI.createPortal(content, index, _itemID, scrollerProperties);\n                    case 23:\n                      retval = portalMetadataRef.current = _context.sent;\n                      if (retval) {\n                        portalNodeRef.current = portalMetadataRef.current.portalNode;\n                        setContainerStyles(portalNodeRef.current.element, _layout, _orientation, _cellWidth, _cellHeight);\n                      }\n                      isMountedRef.current && setFrameState(\'inserting\');\n                      _context.next = 30;\n                      break;\n                    case 28:\n                      // null or undefined; handle non-component value\n                      cacheAPI.unregisterPendingPortal(index); // create portal failed\n                      if (usercontent === null) {\n                        // truncate listsize at this index\n                        itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', new Error(placeholderMessagesRef.current["null"]));\n                        nullItemSetMaxListsize(index);\n                      } else {\n                        // usercontent === undefined, meaning an error has occurred\n                        // change placeholder message to error message\n                        errorRef.current = error;\n                        // notify the host\n                        itemExceptionCallback && itemExceptionCallback(index, _itemID, returnvalue, \'cellFrame\', error);\n                        isMountedRef.current && setFrameState(\'error\');\n                      }\n                    case 30:\n                    case "end":\n                      return _context.stop();\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n            }, {\n              timeout: IDLECALLBACK_TIMEOUT\n            });\n          }\n          break;\n        }\n      case \'inserting\':\n      case \'retrieved\':\n        {\n          setFrameState(\'ready\');\n          break;\n        }\n    }\n  }, [frameState]);\n  // Note: the contentholder type layer is included to provide an anchor for the triggerlines.\n  return react_1["default"].createElement("div", {\n    ref: frameRef,\n    "data-type": \'cellframe\',\n    "data-scrollerid": scrollerID,\n    "data-index": index,\n    "data-instanceid": instanceID,\n    style: stylesRef.current\n  }, frameState != \'setup\' ? react_1["default"].createElement("div", {\n    "data-type": \'contentholder\',\n    style: holderStylesRef.current\n  }, frameState != \'ready\' ? placeholderRef.current : react_1["default"].createElement(react_reverse_portal_1.OutPortal, {\n    key: \'portal\',\n    node: portalNodeRef.current\n  })) : react_1["default"].createElement("div", null), isTriggercell ? triggercellTriggerlinesRef.current : null);\n}; // CellFrame\n//(frameState != \'setup\') && \nexports["default"] = CellFrame;\n// utilities\nvar getFrameStyles = function getFrameStyles(orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, layout, styles) {\n  var styleset = Object.assign(Object.assign({}, styles), {\n    position: \'relative\',\n    overflow: \'visible\'\n  });\n  if (orientation === \'vertical\') {\n    styleset.width = null;\n    if (layout == \'uniform\') {\n      styleset.height = cellHeight + \'px\';\n      styleset.minHeight = null;\n      styleset.maxHeight = null;\n    } else {\n      // \'variable\'\n      styleset.height = null;\n      styleset.minHeight = cellMinHeight + \'px\';\n      styleset.maxHeight = cellHeight + \'px\';\n    }\n  } else {\n    // \'horizontal\'\n    styleset.height = null;\n    if (layout == \'uniform\') {\n      styleset.width = cellWidth + \'px\';\n      styleset.minWidth = null;\n      styleset.maxWidth = null;\n    } else {\n      // \'variable\'\n      styleset.width = null;\n      styleset.minWidth = cellMinWidth + \'px\';\n      styleset.maxWidth = cellWidth + \'px\';\n    }\n  }\n  return styleset;\n};\nvar getContentHolderStyles = function getContentHolderStyles(layout, orientation, cellMinWidth, cellMinHeight) {\n  var styles = {};\n  if (layout == \'uniform\') {\n    styles = {\n      inset: \'0px\',\n      position: \'absolute\',\n      height: null,\n      width: null,\n      minWidth: null,\n      minHeight: null\n    };\n  } else {\n    // variable\n    styles.inset = null;\n    styles.position = null;\n    if (orientation == \'vertical\') {\n      styles.width = \'100%\';\n      styles.height = null;\n      styles.minWidth = null;\n      styles.minHeight = cellMinHeight + \'px\';\n    } else {\n      styles.width = null;\n      styles.height = \'100%\';\n      styles.minWidth = cellMinWidth + \'px\';\n      styles.minHeight = null;\n    }\n  }\n  return styles;\n};\n// see also some base styles set in cachehandler\nvar setContainerStyles = function setContainerStyles(container, layout, orientation, cellWidth, cellHeight) {\n  container.style.overflow = \'hidden\';\n  if (layout == \'uniform\') {\n    container.style.inset = \'0px\';\n    container.style.position = \'absolute\';\n    container.style.maxWidth = null;\n    container.style.maxHeight = null;\n    container.style.height = null;\n    container.style.width = null;\n  } else {\n    // variable\n    container.style.inset = null;\n    container.style.position = null;\n    if (orientation == \'vertical\') {\n      container.style.width = \'100%\';\n      container.style.height = null;\n      container.style.maxWidth = null;\n      container.style.maxHeight = cellHeight + \'px\';\n    } else {\n      container.style.width = null;\n      container.style.height = \'100%\';\n      container.style.maxWidth = cellWidth + \'px\';\n      container.style.maxHeight = null;\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b2xsZXIvLi9zcmMvQ2VsbEZyYW1lLnRzeD9mMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbGxGcmFtZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIHJvbGUgb2YgQ2VsbEZyYW1lIGlzIHRvIGZldGNoIHVzZXIgY29udGVudCBmcm9tIHRoZSBjYWNoZSwgb3IgZnJvbSB0aGUgaG9zdCAodXNpbmcgZ2V0SXRlbSkuXG4gICAgV2hpbGUgYW4gaXRlbSBpcyBiZWluZyBmZXRjaGVkLCBDZWxsRnJhbWUgcHJlc2VudHMgYSBwbGFjZWhvbGRlciAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGFuIFxuICAgIGltcG9ydGVkIGN1c3RvbSB2ZXJzaW9uKS4gSWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gZmV0Y2hpbmcgY29udGVudCB0aGVuIHRoZSBwbGFjZWhvbGRlciBpcyB1c2VkXG4gICAgdG8gcHJlc2VudCB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuIElmIGEgbmV3IGl0ZW1JRCBpcyBzZXQgYnkgdGhlIHBhcmVudCAodG8gc3luY2hyb25pemUgd2l0aCBhbiBhbHRlcmVkXG4gICAgY2FjaGUpLCB0aGVuIENlbGxGcmFtZSByZXBsYWNlcyB0aGUgb2xkIGl0ZW0gd2l0aCB0aGUgbmV3IGl0ZW0uXG5cbiAgICBnZXRJdGVtICh3aGljaCBpcyBhIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBob3N0KSBjYW4gcmV0dXJuIG9uZSBvZiBzZXZlcmFsIHZhbHVlczpcbiAgICAgICAgLSBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgICAtIGEgcHJvbWlzZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICAtIG51bGxcbiAgICAgICAgLSB1bmRlZmluZWRcbiAgICBBbnl0aGluZyBlbHNlIGlzIHRyZWF0ZWQgYXMgYW4gZXJyb3JcblxuICAgIGlmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCwgdGhlbiB0aGUgcHJvbWlzZSByZXR1cm5zIGEgUmVhY3QgY29tcG9uZW50LCBudWxsIG9yIHVuZGVmaW5lZC5cblxuICAgIElmIGEgdmFsaWQgcmVhY3QgY29tcG9uZW50IGlzIHJldHVybmVkIGZyb20gZ2V0SXRlbSwgdGhlbiBpdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlIGNhY2hlLCBhbmQgcmVuZGVyZWQgaW4gdGhlXG4gICAgQ2VsbEZyYW1lLiBJZiBudWxsIGlzIHJldHVybmVkLCB0aGVuIENlbGxGcmFtZSBzZW5kcyBhIG1lc3NhZ2UgdG8gaXRzIHNjcm9sbGVyIHRoYXQgdGhlIGhvc3QgaGFzIFxuICAgIGluZGljYXRlZCB0aGUgdGhlIGl0ZW0gYmVpbmcgZmV0Y2hlZCBpbnN0ZWFkIHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGUgbGlzdCwgYW5kIHRoZSBsaXN0c2l6ZSBzaG91bGRcbiAgICBiZSBhZGp1c3RlZCBhY2NvcmRpbmdseS4gQW55IG90aGVyIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvciwgYW5kIHByZXNlbnRlZFxuICAgIGFzIHN1Y2ggdG8gdGhlIHVzZXIgdGhyb3VnaCB0aGUgcGxhY2Vob2xkZXIgY29tcG9uZW50LlxuXG4gICAgZ2V0SXRlbSBzZW5kcyB0aGUgaW5kZXggKGxvZ2ljYWwgaW5kZXggaW4gdGhlIGxpc3QpIGFuZCBhIHNlc3Npb24gaXRlbUlEIHRvIHRoZSBob3N0LCBzbyB0aGF0XG4gICAgdGhlIGhvc3QgY2FuIHN5bmMgaXRzIG93biB0cmFja2luZyB3aXRoIHRoZSBzY3JvbGxlci5cblxuICAgIE9uZSBDZWxsRnJhbWUgYXQgYSB0aW1lIGlzIGRlc2lnbmF0ZWQgYXMgdGhlIGhvc3Qgb2YgdGhlIHR3byB0cmlnZ2VyTGluZXMgd2l0aCB0aGUgaXNUcmlnZ2VyQ2VsbCBmbGFnLiBcbiAgICBUaGUgdHJpZ2dlcmxpbmVzIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBDcmFkbGUgdGhyb3VnaCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlci5cbiovXG5cbmltcG9ydCBSZWFjdCwge1xuICAgIHVzZVJlZiwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDb250ZXh0IFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHtyZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2t9IGZyb20gJ3JlcXVlc3RpZGxlY2FsbGJhY2snIC8vIHBvbHlmaWxsIGlmIG5lZWRlZFxuXG5pbXBvcnQgeyBPdXRQb3J0YWwgfSBmcm9tICdyZWFjdC1yZXZlcnNlLXBvcnRhbCcgLy8gZmV0Y2ggZnJvbSBjYWNoZVxuXG5pbXBvcnQgUGxhY2Vob2xkZXIgZnJvbSAnLi9jZWxsZnJhbWUvUGxhY2Vob2xkZXInIC8vIGRlZmF1bHRcblxuaW1wb3J0IHsgQ3JhZGxlQ29udGV4dCB9IGZyb20gJy4vQ3JhZGxlJ1xuXG5jb25zdCBkZWZhdWx0UGxhY2Vob2xkZXJNZXNzYWdlcyA9IHtcbiAgICBsb2FkaW5nOicobG9hZGluZy4uLiknLFxuICAgIHJldHJpZXZpbmc6JyhyZXRyaWV2aW5nIGZyb20gY2FjaGUpJyxcbiAgICBudWxsOidlbmQgb2YgbGlzdCcsXG4gICAgdW5kZWZpbmVkOidob3N0IHJldHVybmVkIFwidW5kZWZpbmVkXCInLFxuICAgIGludmFsaWQ6J2ludmFsaWQgUmVhY3QgZWxlbWVudCcsXG59XG5cbmNvbnN0IENlbGxGcmFtZSA9ICh7XG4gICAgb3JpZW50YXRpb24sIFxuICAgIGNlbGxIZWlnaHQsIFxuICAgIGNlbGxXaWR0aCwgXG4gICAgY2VsbE1pbkhlaWdodCxcbiAgICBjZWxsTWluV2lkdGgsXG4gICAgbGF5b3V0LFxuICAgIGdldEl0ZW0sIC8vIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGhvc3RcbiAgICBsaXN0c2l6ZSwgLy8gZm9yIGZlZWRiYWNrIGluIHBsYWNlaG9sZGVyXG4gICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsbHkgcHJvdmlkZWQgYnkgaG9zdFxuICAgIGl0ZW1JRCwgLy8gc2Vzc2lvbiBpdGVtSURcbiAgICBpbmRleCwgLy8gbG9naWNhbCBpbmRleCBpbiBpbmZpbml0ZSBsaXN0XG4gICAgaW5zdGFuY2VJRCwgLy8gQ2VsbEZyYW1lIHNlc3Npb24gSURcbiAgICBzY3JvbGxlcklELCAvLyBzY3JvbGxlciBJRCAoZm9yIGRlYnVnZ2luZylcbiAgICBpc1RyaWdnZXJjZWxsLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgdXNlUGxhY2Vob2xkZXIsXG4gICAgZ3JpZHN0YXJ0c3R5bGUsXG59KSA9PiB7XG5cbiAgICBjb25zdCBjb3JlQ29uZmlnUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29yZUNvbmZpZ1JlZi5jdXJyZW50ID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxIZWlnaHRcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBzZXR1cCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGV4dCA9IHVzZUNvbnRleHQoQ3JhZGxlQ29udGV4dClcblxuICAgIGNvbnN0IHsgXG4gICAgICAgIGNhY2hlQVBJLCBcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLCAvLyBmb3IgdGhlIHVzZXIgY29udGVudCwgaWYgcmVxdWVzdGVkXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsIC8vIGZvciBpbnRlcm5hbCBub3RpZmljYXRpb24gb2YgZW5kLW9mLWxpc3RcbiAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLCAvLyBmb3Igbm90aWZpY2F0aW9uIHRvIGhvc3Qgb2YgZXJyb3JcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsIC8vIHRvIG9wdGltaXplIHJlcXVlc3RJZGxlQ2FsbGJhY2tcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSA9IGNyYWRsZUNvbnRleHRcbiAgICBcbiAgICAvLyBzdHlsZSBjaGFuZ2UgZ2VuZXJhdGVzIHN0YXRlIHJlZnJlc2hcbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoe30pXG4gICAgY29uc3QgaG9sZGVyU3R5bGVzUmVmID0gdXNlUmVmKHt9KVxuXG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZiA9IHVzZVJlZihudWxsKVxuXG4gICBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICBjb25zdCBuZXdNZXNzYWdlcyA9IHsuLi5kZWZhdWx0UGxhY2Vob2xkZXJNZXNzYWdlcywuLi5wbGFjZWhvbGRlck1lc3NhZ2VzfVxuXG4gICAgICAgIHJldHVybiBuZXdNZXNzYWdlc1xuXG4gICAgfSxbcGxhY2Vob2xkZXJNZXNzYWdlc10pXG5cbiAgICAvLyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgY29uc3QgW2ZyYW1lU3RhdGUsIHNldEZyYW1lU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBmcmFtZVN0YXRlUmVmID0gdXNlUmVmKG51bGwpXG4gICAgZnJhbWVTdGF0ZVJlZi5jdXJyZW50ID0gZnJhbWVTdGF0ZVxuXG4gICAgLy8gRE9NIHJlZlxuICAgIGNvbnN0IGZyYW1lUmVmID0gdXNlUmVmKG51bGwpXG4gICAgLy8gdG8gdHJhY2sgdW5tb3VudCBpbnRlcnJ1cHRcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICAvLyBjYWNoZSBkYXRhXG4gICAgY29uc3QgcG9ydGFsTWV0YWRhdGFSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgcGxhY2Vob2xkZXIgdG8gdXNlXG4gICAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgICAvLyB0aGUgc2Vzc2lvbiBpdGVtSUQgdG8gdXNlOyBjb3VsZCBiZSB1cGRhdGVkIGJ5IHBhcmVudFxuICAgIGNvbnN0IGl0ZW1JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGl0ZW1JRFJlZi5jdXJyZW50ID0gaXRlbUlEXG4gICAgY29uc3QgY2VsbEZyYW1lUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIGNlbGxGcmFtZVByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgaXRlbUlELFxuICAgICAgICBpbmRleFxuICAgIH1cbiAgICAvLyBmZXRjaCBlcnJvclxuICAgIGNvbnN0IGVycm9yUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIC8vIHBsYWNlaG9sZGVyIG1lc3NhZ2VcbiAgICBjb25zdCBtZXNzYWdlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGZvciB1bm1vdW50XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY2FuY2VsaWRsZWNhbGxiYWNrKHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZi5jdXJyZW50KVxuXG4gICAgICAgICAgICBjYWNoZUFQSS51bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbChpbmRleClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gcmVmcmVzaCBjb250ZW50IGlmIGl0ZW1JRCBjaGFuZ2VzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGZyYW1lU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldEZyYW1lU3RhdGUoJ2dldHVzZXJjb250ZW50JylcblxuICAgIH0sW2l0ZW1JRF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLSBbIHBsYWNlaG9sZGVyIGRlZmluaXRpb24gXSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBjdXN0b21wbGFjZWhvbGRlciA9IHVzZU1lbW8oKCkgPT4ge1xuXG4gICAgICAgIGlmICghdXNlUGxhY2Vob2xkZXIpIHJldHVybiBudWxsICAgICAgICBcblxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI/XG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHBsYWNlaG9sZGVyLCBcbiAgICAgICAgICAgICAgICB7aW5kZXgsIGxpc3RzaXplLCBtZXNzYWdlOm1lc3NhZ2VSZWYuY3VycmVudCwgZXJyb3I6ZXJyb3JSZWYuY3VycmVudH0pOlxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXG4gICAgfSxbXG4gICAgICAgIGluZGV4LCBcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50LCBcbiAgICAgICAgZXJyb3JSZWYuY3VycmVudCwgXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyXG4gICAgXSlcblxuICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpPT57XG5cbiAgICAgICAgaWYgKCF1c2VQbGFjZWhvbGRlcikgcmV0dXJuIG51bGxcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IFxuICAgICAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXI/XG4gICAgICAgICAgICAgICAgY3VzdG9tcGxhY2Vob2xkZXI6XG4gICAgICAgICAgICAgICAgPFBsYWNlaG9sZGVyIFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSAncGxhY2Vob2xkZXInXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICAgICAgICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfSBcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHsgbWVzc2FnZVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7IGVycm9yUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRnJhbWVTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyTGluZXJTdHlsZXMgPSB7IHBsYWNlaG9sZGVyTGluZXJTdHlsZXMgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRXJyb3JGcmFtZVN0eWxlcyA9IHsgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckVycm9yTGluZXJTdHlsZXMgPSB7IHBsYWNlaG9sZGVyRXJyb3JMaW5lclN0eWxlcyB9XG4gICAgICAgICAgICAgICAgLz5cblxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJcblxuICAgIH0sIFtcbiAgICAgICAgaW5kZXgsIFxuICAgICAgICBjdXN0b21wbGFjZWhvbGRlciwgXG4gICAgICAgIGxpc3RzaXplLCBcbiAgICAgICAgbWVzc2FnZVJlZi5jdXJyZW50LCBcbiAgICAgICAgZXJyb3JSZWYuY3VycmVudCxcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyTGluZXJTdHlsZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyxcbiAgICAgICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzLFxuICAgIF0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFsgcmVxdWVzdGlkbGVjYWxsYmFjayBjb25maWcgXSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHJlcXVlc3RpZGxlY2FsbGJhY2sgPSAvLyByZXF1ZXN0SWRsZUNhbGxiYWNrXG4gICAgICAgIHdpbmRvd1sncmVxdWVzdElkbGVDYWxsYmFjayddP1xuICAgICAgICAgICAgd2luZG93WydyZXF1ZXN0SWRsZUNhbGxiYWNrJ106XG4gICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrXG5cbiAgICBjb25zdCBjYW5jZWxpZGxlY2FsbGJhY2sgPSAvLyBjYW5jZWxJZGxlQ2FsbGJhY2tcbiAgICAgICAgd2luZG93WydjYW5jZWxJZGxlQ2FsbGJhY2snXT9cbiAgICAgICAgICAgIHdpbmRvd1snY2FuY2VsSWRsZUNhbGxiYWNrJ106XG4gICAgICAgICAgICBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICAgIGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHByb2Nlc3NpbmcgXS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBzZXQgc3R5bGVzXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgbGV0IG5ld0ZyYW1lU3R5bGVzID0gZ2V0RnJhbWVTdHlsZXMoXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsIGxheW91dCwgc3R5bGVzUmVmLmN1cnJlbnQpXG5cbiAgICAgICAgaWYgKGdyaWRzdGFydHN0eWxlKSB7XG4gICAgICAgICAgICBuZXdGcmFtZVN0eWxlcyA9IHsuLi5uZXdGcmFtZVN0eWxlcywuLi5ncmlkc3RhcnRzdHlsZX1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3SG9sZGVyU3R5bGVzID0gZ2V0Q29udGVudEhvbGRlclN0eWxlcyhsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsTWluV2lkdGgsIGNlbGxNaW5IZWlnaHQpXG5cbiAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHN0eWxlc1JlZi5jdXJyZW50ID0gbmV3RnJhbWVTdHlsZXNcbiAgICAgICAgICAgIGhvbGRlclN0eWxlc1JlZi5jdXJyZW50ID0gbmV3SG9sZGVyU3R5bGVzXG5cbiAgICAgICAgfVxuXG4gICAgfSxbb3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgY2VsbE1pbkhlaWdodCwgY2VsbE1pbldpZHRoLCBsYXlvdXQsIGdyaWRzdGFydHN0eWxlXSkgXG5cbiAgICBjb25zdCBwb3J0YWxOb2RlUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAoZnJhbWVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3dvcmtpbmcnKSAvLyAnZ2V0dXNlcmNvbnRlbnQnIHdpbGwgYmUgY2FsbGVkXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3dvcmtpbmcnOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRGcmFtZVN0YXRlKCdnZXR1c2VyY29udGVudCcpIC8vIGRlbGF5IHBhaW50IHdoaWxlIHdvcmtpbmdcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldHVzZXJjb250ZW50Jzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaXRlbUlEUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZUFQSS5oYXNQb3J0YWwoaXRlbUlEKVxuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gPSBjb3JlQ29uZmlnUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUmVmLmN1cnJlbnQgPSBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQucmV0cmlldmluZ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudCA9IGNhY2hlQVBJLmdldFBvcnRhbE1ldGFkYXRhKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjZWxsIGFuZCBzY3JvbGxlciBwcm9wZXJ0aWVzIHJlZiBpbiBjYXNlIG9mIHN3aXRjaCBpbiBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQuc2Nyb2xsZXJQcm9wZXJ0aWVzLmNlbGxGcmFtZVByb3BlcnRpZXNSZWYgPSBjZWxsRnJhbWVQcm9wZXJ0aWVzUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxNZXRhZGF0YVJlZi5jdXJyZW50LnNjcm9sbGVyUHJvcGVydGllcy5zY3JvbGxlclByb3BlcnRpZXNSZWYgPSBzY3JvbGxlclByb3BlcnRpZXNSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBPdXRQb3J0YWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudC5wb3J0YWxOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250YWluZXJTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50LmVsZW1lbnQsIGxheW91dCwgb3JpZW50YXRpb24sIGNlbGxXaWR0aCwgY2VsbEhlaWdodClcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhbWVTdGF0ZSgncmV0cmlldmVkJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudC5sb2FkaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZSBzcGFjZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVBUEkucmVnaXN0ZXJQZW5kaW5nUG9ydGFsKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVucXVldWUgdGhlIGZldGNoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2tJZFJlZi5jdXJyZW50ID0gcmVxdWVzdGlkbGVjYWxsYmFjayhhc3luYyAoKT0+e1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJudmFsdWUsIHVzZXJjb250ZW50LCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyY29udGVudCA9IGF3YWl0IGdldEl0ZW0oaW5kZXgsIGl0ZW1JRClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudCA9PT0gbnVsbCkgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQudW5kZWZpbmVkKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gUmVhY3QuaXNWYWxpZEVsZW1lbnQodXNlcmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocGxhY2Vob2xkZXJNZXNzYWdlc1JlZi5jdXJyZW50LmludmFsaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1c2VyY29udGVudCAhPT0gbnVsbCkgJiYgKHVzZXJjb250ZW50ICE9PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlcmNvbnRlbnQgaXMgb3RoZXJ3aXNlIGRpc2FsbG93ZWQsIGxldCBlcnJvciBoYW5kbGluZyBkZWFsIHdpdGggaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRnJhbWVQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRpbkNvdW50ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRpblByb3BzOntzY3JvbGxlclByb3BlcnRpZXM/Ok9iamVjdCwgY2FjaGVBUEk/OkZ1bmN0aW9ufSA9IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyY29udGVudC5wcm9wcz8uaGFzT3duUHJvcGVydHkoJ3Njcm9sbGVyUHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpblByb3BzLnNjcm9sbGVyUHJvcGVydGllcyA9IHNjcm9sbGVyUHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaW5Db3VudCsrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzPy5oYXNPd25Qcm9wZXJ0eSgnY2FjaGVBUEknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaW5Qcm9wcy5jYWNoZUFQSSA9IGNhY2hlQVBJLmluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpbkNvdW50KytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaW5Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudCh1c2VyY29udGVudCwgYWRkaW5Qcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB1c2VyY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dmFsID0gcG9ydGFsTWV0YWRhdGFSZWYuY3VycmVudCA9IGF3YWl0IGNhY2hlQVBJLmNyZWF0ZVBvcnRhbChjb250ZW50LCBpbmRleCwgaXRlbUlELCBzY3JvbGxlclByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHBvcnRhbE1ldGFkYXRhUmVmLmN1cnJlbnQucG9ydGFsTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGFpbmVyU3R5bGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudC5lbGVtZW50LCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmIHNldEZyYW1lU3RhdGUoJ2luc2VydGluZycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZDsgaGFuZGxlIG5vbi1jb21wb25lbnQgdmFsdWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUFQSS51bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbChpbmRleCkgLy8gY3JlYXRlIHBvcnRhbCBmYWlsZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgbGlzdHNpemUgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIGl0ZW1JRCwgcmV0dXJudmFsdWUsICdjZWxsRnJhbWUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQubnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsSXRlbVNldE1heExpc3RzaXplKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQsIG1lYW5pbmcgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBwbGFjZWhvbGRlciBtZXNzYWdlIHRvIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBob3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgaXRlbUlELCByZXR1cm52YWx1ZSwgJ2NlbGxGcmFtZScsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCAmJiBzZXRGcmFtZVN0YXRlKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0se3RpbWVvdXQ6SURMRUNBTExCQUNLX1RJTUVPVVR9KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0aW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3JldHJpZXZlZCc6IHtcblxuICAgICAgICAgICAgICAgIHNldEZyYW1lU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LCBbZnJhbWVTdGF0ZV0pXG5cbiAgICAvLyBOb3RlOiB0aGUgY29udGVudGhvbGRlciB0eXBlIGxheWVyIGlzIGluY2x1ZGVkIHRvIHByb3ZpZGUgYW4gYW5jaG9yIGZvciB0aGUgdHJpZ2dlcmxpbmVzLlxuICAgIHJldHVybiA8ZGl2IFxuXG4gICAgICAgIHJlZiA9IHsgZnJhbWVSZWYgfSBcbiAgICAgICAgZGF0YS10eXBlID0gJ2NlbGxmcmFtZScgXG4gICAgICAgIGRhdGEtc2Nyb2xsZXJpZCA9IHsgc2Nyb2xsZXJJRCB9IFxuICAgICAgICBkYXRhLWluZGV4ID0geyBpbmRleCB9IFxuICAgICAgICBkYXRhLWluc3RhbmNlaWQgPSB7IGluc3RhbmNlSUQgfSBcbiAgICAgICAgc3R5bGUgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cblxuICAgID5cblxuICAgICAgICB7KGZyYW1lU3RhdGUgIT0gJ3NldHVwJyk/XG4gICAgICAgICAgICAoPGRpdiBkYXRhLXR5cGUgPSAnY29udGVudGhvbGRlcicgc3R5bGUgPSB7aG9sZGVyU3R5bGVzUmVmLmN1cnJlbnR9PiBcbiAgICAgICAgICAgICAgICB7KChmcmFtZVN0YXRlICE9ICdyZWFkeScpP1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICAgICAgPE91dFBvcnRhbCBrZXkgPSAncG9ydGFsJyBub2RlID0geyBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgfS8+KX1cbiAgICAgICAgICAgIDwvZGl2Pik6PGRpdj48L2Rpdj59XG4gICAgICAgIHsoaXNUcmlnZ2VyY2VsbD9cbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmLmN1cnJlbnQ6XG4gICAgICAgICAgICBudWxsKVxuICAgICAgICB9XG5cbiAgICA8L2Rpdj5cblxufSAvLyBDZWxsRnJhbWVcbi8vKGZyYW1lU3RhdGUgIT0gJ3NldHVwJykgJiYgXG5leHBvcnQgZGVmYXVsdCBDZWxsRnJhbWVcblxuLy8gdXRpbGl0aWVzXG5jb25zdCBnZXRGcmFtZVN0eWxlcyA9IFxuICAgIChvcmllbnRhdGlvbiwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBjZWxsTWluSGVpZ2h0LCBjZWxsTWluV2lkdGgsIGxheW91dCwgc3R5bGVzKSA9PiB7XG5cbiAgICBjb25zdCBzdHlsZXNldCA9IHsuLi5zdHlsZXMscG9zaXRpb246J3JlbGF0aXZlJywgb3ZlcmZsb3c6J3Zpc2libGUnfVxuXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5tYXhIZWlnaHQgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJ1xuXG4gICAgICAgICAgICBzdHlsZXNldC5oZWlnaHQgPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5IZWlnaHQgPSBjZWxsTWluSGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgc3R5bGVzZXQubWF4SGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCdcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIHN0eWxlc2V0LmhlaWdodCA9IG51bGxcbiAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBjZWxsV2lkdGggKyAncHgnXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IG51bGxcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gbnVsbFxuXG4gICAgICAgIH0gZWxzZSB7IC8vICd2YXJpYWJsZSdcblxuICAgICAgICAgICAgc3R5bGVzZXQud2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXNldC5taW5XaWR0aCA9IGNlbGxNaW5XaWR0aCArICdweCdcbiAgICAgICAgICAgIHN0eWxlc2V0Lm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXNldFxuXG59XG5cbmNvbnN0IGdldENvbnRlbnRIb2xkZXJTdHlsZXMgPSAobGF5b3V0LG9yaWVudGF0aW9uLGNlbGxNaW5XaWR0aCwgY2VsbE1pbkhlaWdodCApID0+IHtcbiAgICBsZXQgc3R5bGVzOlJlYWN0LkNTU1Byb3BlcnRpZXMgPSB7fVxuICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgIHN0eWxlcyA9IHtcbiAgICAgICAgICAgIGluc2V0OicwcHgnLFxuICAgICAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgICAgIGhlaWdodDpudWxsLFxuICAgICAgICAgICAgd2lkdGg6bnVsbCxcbiAgICAgICAgICAgIG1pbldpZHRoOm51bGwsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6bnVsbCxcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIHZhcmlhYmxlXG4gICAgICAgIHN0eWxlcy5pbnNldCA9IG51bGxcbiAgICAgICAgc3R5bGVzLnBvc2l0aW9uID0gbnVsbFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzLm1pbldpZHRoID0gbnVsbFxuICAgICAgICAgICAgc3R5bGVzLm1pbkhlaWdodCA9IGNlbGxNaW5IZWlnaHQgKyAncHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMud2lkdGggPSBudWxsXG4gICAgICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICAgICAgICBzdHlsZXMubWluV2lkdGggPSBjZWxsTWluV2lkdGggKyAncHgnXG4gICAgICAgICAgICBzdHlsZXMubWluSGVpZ2h0ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXNcbn1cblxuLy8gc2VlIGFsc28gc29tZSBiYXNlIHN0eWxlcyBzZXQgaW4gY2FjaGVoYW5kbGVyXG5jb25zdCBzZXRDb250YWluZXJTdHlsZXMgPSAoY29udGFpbmVyLCBsYXlvdXQsIG9yaWVudGF0aW9uLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpID0+IHtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5pbnNldCA9ICcwcHgnIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhXaWR0aCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG51bGxcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuXG4gICAgfSBlbHNlIHsgLy8gdmFyaWFibGVcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSBudWxsIFxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBudWxsXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbFxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gY2VsbFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IG51bGxcblxuICAgICAgICB9XG5cbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiZGVzYyIsInZhbHVlIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJjb250ZXh0IiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfX2F3YWl0IiwidGhlbiIsInVud3JhcHBlZCIsImVycm9yIiwicHJldmlvdXNQcm9taXNlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJzdGF0ZSIsIkVycm9yIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJkb25lIiwibWV0aG9kTmFtZSIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImxlbmd0aCIsImkiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwiaXRlciIsImtleXMiLCJ2YWwiLCJvYmplY3QiLCJyZXZlcnNlIiwicG9wIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwiX2NhdGNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiX2kiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwicmVxdWVzdGlkbGVjYWxsYmFja18xIiwicmVhY3RfcmV2ZXJzZV9wb3J0YWxfMSIsIlBsYWNlaG9sZGVyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJDcmFkbGVfMSIsImRlZmF1bHRQbGFjZWhvbGRlck1lc3NhZ2VzIiwibG9hZGluZyIsInJldHJpZXZpbmciLCJpbnZhbGlkIiwiQ2VsbEZyYW1lIiwiX3JlZiIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJsYXlvdXQiLCJnZXRJdGVtIiwibGlzdHNpemUiLCJwbGFjZWhvbGRlciIsIml0ZW1JRCIsImluZGV4IiwiaW5zdGFuY2VJRCIsInNjcm9sbGVySUQiLCJpc1RyaWdnZXJjZWxsIiwicGxhY2Vob2xkZXJGcmFtZVN0eWxlcyIsInBsYWNlaG9sZGVyTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlck1lc3NhZ2VzIiwidXNlUGxhY2Vob2xkZXIiLCJncmlkc3RhcnRzdHlsZSIsImNvcmVDb25maWdSZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY3JhZGxlQ29udGV4dCIsInVzZUNvbnRleHQiLCJDcmFkbGVDb250ZXh0IiwiY2FjaGVBUEkiLCJzY3JvbGxlclByb3BlcnRpZXNSZWYiLCJudWxsSXRlbVNldE1heExpc3RzaXplIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lc1JlZiIsInN0eWxlc1JlZiIsImhvbGRlclN0eWxlc1JlZiIsInBsYWNlaG9sZGVyTWVzc2FnZXNSZWYiLCJ1c2VNZW1vIiwibmV3TWVzc2FnZXMiLCJhc3NpZ24iLCJfcmVmMiIsInVzZVN0YXRlIiwiX3JlZjMiLCJmcmFtZVN0YXRlIiwic2V0RnJhbWVTdGF0ZSIsImZyYW1lU3RhdGVSZWYiLCJmcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInBvcnRhbE1ldGFkYXRhUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJpdGVtSURSZWYiLCJjZWxsRnJhbWVQcm9wZXJ0aWVzUmVmIiwiZXJyb3JSZWYiLCJtZXNzYWdlUmVmIiwidXNlRWZmZWN0IiwiY2FuY2VsaWRsZWNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFja0lkUmVmIiwidW5yZWdpc3RlclBlbmRpbmdQb3J0YWwiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjdXN0b21wbGFjZWhvbGRlciIsImNyZWF0ZUVsZW1lbnQiLCJtZXNzYWdlIiwidXNlckZyYW1lU3R5bGVzIiwidXNlckxpbmVyU3R5bGVzIiwidXNlckVycm9yRnJhbWVTdHlsZXMiLCJ1c2VyRXJyb3JMaW5lclN0eWxlcyIsInJlcXVlc3RpZGxlY2FsbGJhY2siLCJ3aW5kb3ciLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwibmV3RnJhbWVTdHlsZXMiLCJnZXRGcmFtZVN0eWxlcyIsIm5ld0hvbGRlclN0eWxlcyIsImdldENvbnRlbnRIb2xkZXJTdHlsZXMiLCJwb3J0YWxOb2RlUmVmIiwiY2FjaGVkIiwiaGFzUG9ydGFsIiwiX2NvcmVDb25maWdSZWYkY3VycmVuIiwiZ2V0UG9ydGFsTWV0YWRhdGEiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJwb3J0YWxOb2RlIiwic2V0Q29udGFpbmVyU3R5bGVzIiwiZWxlbWVudCIsInJlZ2lzdGVyUGVuZGluZ1BvcnRhbCIsIl9fYXdhaXRlciIsIl9jYWxsZWUiLCJfYSIsIl9iIiwicmV0dXJudmFsdWUiLCJ1c2VyY29udGVudCIsImlzVmFsaWRFbGVtZW50IiwiY29udGVudCIsImFkZGluQ291bnQiLCJhZGRpblByb3BzIiwicmV0dmFsIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInQwIiwicHJvcHMiLCJpbnN0YW5jZSIsImNsb25lRWxlbWVudCIsImNyZWF0ZVBvcnRhbCIsInRpbWVvdXQiLCJyZWYiLCJzdHlsZSIsIk91dFBvcnRhbCIsIm5vZGUiLCJzdHlsZXMiLCJzdHlsZXNldCIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJ3aWR0aCIsImhlaWdodCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJpbnNldCIsImNvbnRhaW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/CellFrame.tsx\n')},"./src/Cradle.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// Cradle.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CradleContext = void 0;\n/*\n    The Cradle does the bulk of the work for the infinite grid scroller. It does so with the help of\n    eight process handlers (class instances), and one main sub-component - the CellFrame.\n\n    Cradle's main responsibility is to manage the ~30 state changes of the system.\n\n    The illusion of infinite content is maintained by synchronizing changes in cradle content with the\n    Cradle location inside the Scrollblock, such that as the Scrollblock is moved, the cradle moves\n    oppositely to stay visible within the viewport.\n\n    The Scrollblock is sized to approximate the list being viewed, so as to have a scroll thumb size\n    and position which realistically reflects the size of the list being shown.\n\n    The position of the cradle is controlled by an 'axis' which is a 0px height/width div\n    (along the medial - ScrollBlock can be vertical or horizontal). The purpose of the axis is to\n    act as a 'fold', above which cradle content expands 'headwards' (up or left) in the Cradle, and\n    below which the cradle content expands 'tailwards' (doen or right). The Cradle content is held in\n    two CSS grids (children of the axis): one above or left (the 'head' grid), and one below or right,\n    of the position of the axis (the 'tail' grid).\n\n    The axis is kept near the leading (headward) edge of the visible cell rows of the Viewport\n\n    Technically, there are several key reference points tracked by the Cradle. These are:\n        - axisReferenceIndex is the virtual index of the item controlling the location of the axis.\n            The axisReferenceIndex is also used to allocate items above (lower index value) and below\n            (same or higher index value) the axis fold. The axisRefernceIndex is the first item in the\n            tail section of the Cradle.\n        - (cradleReferenceIndex is inferred from the axisReferenceIndex, and is the virtual index of\n            the item defining the leading bound of the cradle content. The cradleReferenceIndex is usually\n            the first item in the head section of the Cradle, unless the cradle shows the very top of the\n            list, in which case the cradleReferenceIndex is the same as the AxisReferenceIndex)\n        - axisViewportPixelOffset (pixels that place the axis in relation to the viewport's leading edge)\n        - the blockScrollPos, which is the amount of scroll (Viewport scrollTop or scrollLeft) of the\n            ScrollBlock\n    \n    Overscroll handling (repositioning):\n        Owing to the potential rapidity of scrolling, which in the case of large lists and heavy content\n        can be too fast for the system to keep up, there is an overscroll protocol called 'repositioning'.\n\n        If the overscroll is such that the cradle (including its two content grids) has entirely passed\n        out of the viewport, then the Cradle component is replaced by a ScrollTracker (or by null if\n        the host takes responsibility for feedback). The ScrollTracker displays to the user the relative\n        location in the virtual list at the edge of the viewport during repositioning. When the scrolling\n        stops Cradle recreates the cradle content, according to the final position of the repositioning\n        process.\n\n    Cradle changes are activated by interrupts:\n    - scrolling\n    - resizing of the viewport\n    - observer callbacks:\n        - cradle/viewport intersection for repositioning when the cradle races out of scope\n        - two 'triggerline'/viewport intersections which trigger rolling of content\n            - rolling content triggers re-allocation of content between cradle head and tail grids\n    - pivot - change of orientation\n    - host changes of configuration specs through property changes or direct service calls\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./src/Viewport.tsx\");\n// popup position tracker for repositioning\nvar ScrollTracker_1 = __importDefault(__webpack_require__(/*! ./cradle/ScrollTracker */ \"./src/cradle/ScrollTracker.tsx\"));\n// support code; process handlers\nvar scrollhandler_1 = __importDefault(__webpack_require__(/*! ./cradle/scrollhandler */ \"./src/cradle/scrollhandler.tsx\"));\nvar statehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/statehandler */ \"./src/cradle/statehandler.tsx\"));\nvar contenthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/contenthandler */ \"./src/cradle/contenthandler.tsx\"));\nvar layouthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/layouthandler */ \"./src/cradle/layouthandler.tsx\"));\nvar interrupthandler_1 = __importDefault(__webpack_require__(/*! ./cradle/interrupthandler */ \"./src/cradle/interrupthandler.tsx\"));\nvar servicehandler_1 = __importDefault(__webpack_require__(/*! ./cradle/servicehandler */ \"./src/cradle/servicehandler.tsx\"));\nvar styleshandler_1 = __importDefault(__webpack_require__(/*! ./cradle/styleshandler */ \"./src/cradle/styleshandler.tsx\"));\n// cacheAPI is imported as a property; instantiated at the root\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ./InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// for children\nexports.CradleContext = react_1[\"default\"].createContext(null);\n// component\nvar Cradle = function Cradle(_ref) {\n  var gridSpecs = _ref.gridSpecs,\n    runwaySize = _ref.runwaySize,\n    virtualListSpecs = _ref.virtualListSpecs,\n    setVirtualListSpecs = _ref.setVirtualListSpecs,\n    startingIndex = _ref.startingIndex,\n    getItem = _ref.getItem,\n    placeholder = _ref.placeholder,\n    placeholderMessages = _ref.placeholderMessages,\n    userCallbacks = _ref.userCallbacks,\n    styles = _ref.styles,\n    triggerlineOffset = _ref.triggerlineOffset,\n    cache = _ref.cache,\n    cacheMax = _ref.cacheMax,\n    scrollerID = _ref.scrollerID,\n    cacheAPI = _ref.cacheAPI,\n    usePlaceholder = _ref.usePlaceholder,\n    useScrollTracker = _ref.useScrollTracker,\n    showAxis = _ref.showAxis,\n    ONAFTERSCROLL_TIMEOUT = _ref.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _ref.IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _ref.MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _ref.VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerProperties = _ref.scrollerProperties;\n  (0, react_1.useEffect)(function () {}, []);\n  var listsize = virtualListSpecs.size;\n  // ========================[ DATA SETUP ]========================\n  // unpack gridSpecs\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth,\n    cellMinHeight = gridSpecs.cellMinHeight,\n    cellMinWidth = gridSpecs.cellMinWidth,\n    layout = gridSpecs.layout;\n  // get viewport context\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  var ViewportContextPropertiesRef = (0, react_1.useRef)(null);\n  ViewportContextPropertiesRef.current = ViewportContextProperties; // for closures\n  // flags\n  var isMountedRef = (0, react_1.useRef)(true);\n  var isCachedRef = (0, react_1.useRef)(false);\n  var wasCachedRef = (0, react_1.useRef)(false);\n  var hasBeenRenderedRef = (0, react_1.useRef)(false);\n  // trigger control\n  var triggerHistoryRef = (0, react_1.useRef)({\n    previousReferenceName: null\n  });\n  //  viewport dimensions and cached state\n  var getViewportDimensions = function getViewportDimensions() {\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    return {\n      width: viewportElement.offsetWidth,\n      height: viewportElement.offsetHeight\n    };\n  };\n  // two sources; could use some reconciliation\n  var viewportDimensions = ViewportContextProperties.viewportDimensions; // for scrollTracker\n  var _getViewportDimension = getViewportDimensions(),\n    viewportheight = _getViewportDimension.height,\n    viewportwidth = _getViewportDimension.width; // viewportDimensions\n  // cache test\n  // zero width and height means the component must be in portal (cache) state\n  var isInPortal = viewportwidth == 0 && viewportheight == 0;\n  var isCacheChange = isInPortal != isCachedRef.current;\n  if (isCacheChange) {\n    wasCachedRef.current = isCachedRef.current;\n    isCachedRef.current = isInPortal;\n  }\n  // cradle state\n  var _ref2 = (0, react_1.useState)('setup'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    cradleState = _ref3[0],\n    setCradleState = _ref3[1];\n  var cradleStateRef = (0, react_1.useRef)(null); // access by closures\n  cradleStateRef.current = cradleState;\n  // if (!scrollerProperties) {\n  // console.log('--\x3e cradleState','-'+scrollerID+'-', cradleState)\n  // console.log('-- index','~'+scrollerProperties?.cellFramePropertiesRef.current.index+'~')\n  // }\n  // cradle scaffold element refs\n  var headCradleElementRef = (0, react_1.useRef)(null);\n  var tailCradleElementRef = (0, react_1.useRef)(null);\n  var axisCradleElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineHeadElementRef = (0, react_1.useRef)(null);\n  var triggercellTriggerlineTailElementRef = (0, react_1.useRef)(null);\n  // layout bundle\n  var cradleElementsRef = (0, react_1.useRef)({\n    headRef: headCradleElementRef,\n    tailRef: tailCradleElementRef,\n    axisRef: axisCradleElementRef,\n    triggercellTriggerlineHeadRef: triggercellTriggerlineHeadElementRef,\n    triggercellTriggerlineTailRef: triggercellTriggerlineTailElementRef\n  });\n  // ------------------------[ calculated properties ]------------------------\n  // configuration calculations\n  // crosscount (also calculated by Scrollblock for deriving Scrollblock length)\n  var crosscount = (0, react_1.useMemo)(function () {\n    if (isCachedRef.current) return 0;\n    var viewportcrosslength = orientation == 'vertical' ? viewportwidth : viewportheight;\n    // cross length of viewport (gap to match crossLength)\n    var viewportcrosslengthforcalc = viewportcrosslength - padding * 2 + gap;\n    var cellcrosslength = (orientation == 'vertical' ? cellWidth : cellHeight) + gap;\n    var cellcrosslengthforcalc = Math.min(cellcrosslength, viewportcrosslengthforcalc); // result cannot be less than 1\n    var crosscount = Math.floor(viewportcrosslengthforcalc / cellcrosslengthforcalc);\n    // console.log('calculated crosscount', crosscount)\n    return crosscount;\n  }, [orientation, gap, padding, cellWidth, cellHeight, viewportheight, viewportwidth]);\n  var lowindex = virtualListSpecs.lowindex,\n    highindex = virtualListSpecs.highindex;\n  var _ref4 = (0, react_1.useMemo)(function () {\n      // add position adjustment for 0\n      var endadjustment = highindex < 0 ? -1 : 1;\n      // get initial values\n      var baserowblanks = Math.abs(lowindex) % crosscount;\n      var endrowblanks = (Math.abs(highindex) + endadjustment) % crosscount;\n      // take inverse depending on direction\n      if (lowindex < 0) {\n        baserowblanks = baserowblanks == 0 ? 0 : crosscount - baserowblanks;\n      }\n      if (highindex >= 0) {\n        endrowblanks = endrowblanks == 0 ? 0 : crosscount - endrowblanks;\n      }\n      // console.log('lowrange, highrange, crosscount, baserowblanks, endrowblanks',\n      //     lowrange, highrange, crosscount, baserowblanks, endrowblanks)\n      return [baserowblanks, endrowblanks];\n    }, [crosscount, lowindex, highindex]),\n    _ref5 = _slicedToArray(_ref4, 2),\n    baserowblanks = _ref5[0],\n    endrowblanks = _ref5[1];\n  // various row counts\n  var _ref6 = (0, react_1.useMemo)(function () {\n      var viewportLength = orientation == 'vertical' ? viewportheight : viewportwidth;\n      var baseRowLength;\n      if (layout == 'uniform') {\n        if (orientation == 'vertical') {\n          baseRowLength = cellHeight;\n        } else {\n          baseRowLength = cellWidth;\n        }\n      } else {\n        // layout == 'variable'\n        if (orientation == 'vertical') {\n          baseRowLength = cellMinHeight;\n        } else {\n          baseRowLength = cellMinWidth;\n        }\n      }\n      baseRowLength += gap;\n      var viewportRowcount = Math.ceil(viewportLength / baseRowLength);\n      // const listRowcount = Math.ceil(listsize/crosscount)\n      var listRowcount = Math.ceil((listsize + baserowblanks + endrowblanks) / crosscount);\n      var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n      var cradleRowcount = Math.min(listRowcount, calculatedCradleRowcount);\n      // console.log('Cradle:listRowcount, calculatedCradleRowcount, cradleRowcount', \n      //     listRowcount, calculatedCradleRowcount, cradleRowcount)\n      var runwayRowcount;\n      if (calculatedCradleRowcount >= cradleRowcount) {\n        runwayRowcount = runwaySize;\n      } else {\n        var diff = cradleRowcount - calculatedCradleRowcount;\n        runwayRowcount -= Math.floor(diff / 2);\n        runwayRowcount = Math.max(0, runwayRowcount);\n      }\n      var itemcount = cradleRowcount * crosscount;\n      if (itemcount > listsize) {\n        itemcount = listsize;\n        cradleRowcount = Math.ceil((itemcount + baserowblanks + endrowblanks) / crosscount);\n      }\n      // console.log('revised cradleRowCount',cradleRowcount)\n      return [cradleRowcount, viewportRowcount, listRowcount, runwayRowcount];\n    }, [orientation, gap,\n    // padding,\n    cellWidth, cellHeight, cellMinWidth, cellMinHeight, viewportheight, viewportwidth, listsize, baserowblanks, endrowblanks, runwaySize, crosscount, layout]),\n    _ref7 = _slicedToArray(_ref6, 4),\n    cradleRowcount = _ref7[0],\n    viewportRowcount = _ref7[1],\n    listRowcount = _ref7[2],\n    runwayRowcount = _ref7[3];\n  var rangerowshift = (0, react_1.useMemo)(function () {\n    return Math.floor(lowindex / crosscount);\n  }, [crosscount, lowindex]);\n  var virtualListProps = Object.assign(Object.assign({}, virtualListSpecs), {\n    baserowblanks: baserowblanks,\n    endrowblanks: endrowblanks,\n    crosscount: crosscount,\n    rowcount: listRowcount,\n    rowshift: rangerowshift\n  });\n  // console.log('virtualListProps',virtualListProps)\n  var cradleContentPropsRef = (0, react_1.useRef)({\n    cradleRowcount: cradleRowcount,\n    viewportRowcount: viewportRowcount,\n    runwayRowcount: runwayRowcount,\n    SOL: false,\n    EOL: false,\n    lowindex: null,\n    highindex: null,\n    size: 0\n  });\n  var cradleContentProps = cradleContentPropsRef.current;\n  cradleContentProps.cradleRowcount = cradleRowcount;\n  cradleContentProps.viewportRowcount = viewportRowcount;\n  cradleContentProps.runwayRowcount = runwayRowcount;\n  // ----------------------[ callbacks ]----------------------------\n  // host callbacks, upacked by serviceHandler\n  var externalCallbacksRef = (0, react_1.useRef)({\n    referenceIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.referenceIndexCallback,\n    repositioningFlagCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningFlagCallback,\n    repositioningIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.repositioningIndexCallback,\n    preloadIndexCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.preloadIndexCallback,\n    deleteListCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.deleteListCallback,\n    changeListsizeCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.changeListsizeCallback,\n    itemExceptionCallback: userCallbacks === null || userCallbacks === void 0 ? void 0 : userCallbacks.itemExceptionCallback\n  });\n  // -----------------[ bundle properties for handlers ]-------------------\n  // bundle all cradle props to pass to handlers - ultimately cradleParametersRef\n  var cradleInheritedPropertiesRef = (0, react_1.useRef)(null); // access by closures and support callbacks\n  // up to date values\n  cradleInheritedPropertiesRef.current = {\n    // gridSpecs\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    // ...rest\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    runwaySize: runwaySize,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessages,\n    usePlaceholder: usePlaceholder,\n    triggerlineOffset: triggerlineOffset,\n    scrollerID: scrollerID,\n    // objects\n    userCallbacks: userCallbacks,\n    styles: styles,\n    cacheAPI: cacheAPI,\n    // control values\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    scrollerProperties: scrollerProperties\n  };\n  var scrollerPropertiesRef = (0, react_1.useRef)(null);\n  // passed to cellFrame content (user content) if requested\n  scrollerPropertiesRef.current = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    layout: layout,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    virtualListProps: virtualListProps,\n    cradleContentProps: cradleContentProps,\n    runwayRowcount: runwayRowcount,\n    cache: cache,\n    cacheMax: cacheMax,\n    startingIndex: startingIndex,\n    crosscount: crosscount,\n    scrollerID: scrollerID\n  };\n  // configuration properties to share with handlers\n  var cradleInternalPropertiesRef = (0, react_1.useRef)(null);\n  cradleInternalPropertiesRef.current = {\n    // updated values\n    // crosscount,\n    // cradleRowcount,\n    // viewportRowcount,\n    // listRowcount,\n    virtualListProps: virtualListProps,\n    setVirtualListSpecs: setVirtualListSpecs,\n    // runwayRowcount,\n    cradleContentProps: cradleContentPropsRef.current,\n    // the following values are maintained elsewhere\n    isMountedRef: isMountedRef,\n    cradleElementsRef: cradleElementsRef,\n    isCachedRef: isCachedRef,\n    wasCachedRef: wasCachedRef,\n    triggerHistoryRef: triggerHistoryRef,\n    // for stateHandler\n    cradleStateRef: cradleStateRef,\n    setCradleState: setCradleState\n  };\n  // placeholder in cradleParameters to make available individual handlers\n  var handlersRef = (0, react_1.useRef)(null);\n  // cradle parameters MASTER BUNDLE\n  var cradleParameters = {\n    handlersRef: handlersRef,\n    ViewportContextPropertiesRef: ViewportContextPropertiesRef,\n    cradleInheritedPropertiesRef: cradleInheritedPropertiesRef,\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cradleInternalPropertiesRef: cradleInternalPropertiesRef,\n    externalCallbacksRef: externalCallbacksRef\n  };\n  var cradleParametersRef = (0, react_1.useRef)(null);\n  cradleParametersRef.current = cradleParameters;\n  // ongoing source of handlers - note all Handlers are given all parameters (cradleParameters)\n  if (!handlersRef.current) {\n    handlersRef.current = getCradleHandlers(cradleParameters);\n  }\n  // make handlers directly available to cradle code below\n  var _handlersRef$current = handlersRef.current,\n    interruptHandler = _handlersRef$current.interruptHandler,\n    scrollHandler = _handlersRef$current.scrollHandler,\n    contentHandler = _handlersRef$current.contentHandler,\n    layoutHandler = _handlersRef$current.layoutHandler,\n    serviceHandler = _handlersRef$current.serviceHandler,\n    stylesHandler = _handlersRef$current.stylesHandler;\n  // =======================[ INTERCEPT CACHING STATE CHANGE ]=========================\n  /*\n      Intercept change in caching status:\n      when a component is cached in a portal (in the React virtual DOM), including the transition of\n      being moved from one cellFrame to another when crossing the Cradle axis,\n      the scrollPos (scrollLeft or scrollTop) is reset to 0 (zero). When the scroller is\n      moved to a cellFrame, this code triggers restoration the scrollPos (see case 'parentingtransition'\n      in the state management section below).\n  \n      This supports InfiniteGridScroller components to be cached as content.\n  \n      The restore scrollPos action must be the first priority to hide these scrollPos adjustments\n      from the user.\n  */\n  var restoreScrollPos = function restoreScrollPos() {\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var blockScrollPos = cradlePositionData.blockScrollPos;\n    var blockXScrollPos = cradlePositionData.blockXScrollPos;\n    if (blockScrollPos !== null) {\n      var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n      viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n      viewportElement[cradlePositionData.blockXScrollProperty] = blockXScrollPos;\n    }\n  };\n  if (isCacheChange && !isCachedRef.current) {\n    restoreScrollPos();\n  }\n  // change state for entering or leaving cache\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return; // nothing to do\n    if (isCachedRef.current && !wasCachedRef.current) {\n      // into cache\n      setCradleState('cached');\n    } else if (!isCachedRef.current && wasCachedRef.current) {\n      // out of cache\n      wasCachedRef.current = false;\n      if (hasBeenRenderedRef.current) {\n        setCradleState('rerenderfromcache');\n      } else {\n        setCradleState('firstrenderfromcache');\n      }\n    }\n  }, [isCachedRef.current, wasCachedRef.current]);\n  // ===================[ INITIALIZATION effects ]=========================\n  // initialization effects are independent of caching\n  // clear mounted flag on unmount\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    // unmount\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  //send call-in functions to host\n  (0, react_1.useEffect)(function () {\n    if (!userCallbacks.functionsCallback) return;\n    var scrollToIndex = serviceHandler.scrollToIndex,\n      reload = serviceHandler.reload,\n      setListsize = serviceHandler.setListsize,\n      clearCache = serviceHandler.clearCache,\n      getCacheIndexMap = serviceHandler.getCacheIndexMap,\n      getCacheItemMap = serviceHandler.getCacheItemMap,\n      getCradleIndexMap = serviceHandler.getCradleIndexMap,\n      remapIndexes = serviceHandler.remapIndexes,\n      moveIndex = serviceHandler.moveIndex,\n      insertIndex = serviceHandler.insertIndex,\n      removeIndex = serviceHandler.removeIndex;\n    var functions = {\n      scrollToIndex: scrollToIndex,\n      reload: reload,\n      setListsize: setListsize,\n      clearCache: clearCache,\n      getCacheIndexMap: getCacheIndexMap,\n      getCacheItemMap: getCacheItemMap,\n      getCradleIndexMap: getCradleIndexMap,\n      remapIndexes: remapIndexes,\n      moveIndex: moveIndex,\n      insertIndex: insertIndex,\n      removeIndex: removeIndex\n    };\n    userCallbacks.functionsCallback(functions);\n  }, []);\n  // initialize window scroll listeners\n  (0, react_1.useEffect)(function () {\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.onScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.onScroll);\n    };\n  }, []);\n  // iOS Safari requires special handling - it ignores assignments to scrollLeft/scrollTop during scrolling\n  (0, react_1.useEffect)(function () {\n    var layout = cradleInheritedPropertiesRef.current.layout;\n    if (!(0, InfiniteGridScroller_1.isSafariIOS)() || layout == 'uniform') return;\n    var viewportElement = ViewportContextPropertiesRef.current.elementRef.current;\n    viewportElement.addEventListener('scroll', scrollHandler.iOSonScroll);\n    return function () {\n      viewportElement && viewportElement.removeEventListener('scroll', scrollHandler.iOSonScroll);\n    };\n  }, []);\n  // observer support\n  /*\n      There are two interection observers: one for the two cradle grids, and another for triggerlines;\n          both against the viewport.\n  */\n  (0, react_1.useEffect)(function () {\n    var cradleIntersect = interruptHandler.cradleIntersect,\n      triggerlinesIntersect = interruptHandler.triggerlinesIntersect;\n    // intersection observer for cradle body\n    // this sets up an IntersectionObserver of the cradle against the viewport. When the\n    // cradle goes out of the observer scope, the 'repositioningRender' cradle state is triggered.\n    var cradleintersectobserver = cradleIntersect.createObserver();\n    cradleIntersect.connectElements();\n    // triggerobserver triggers cradle content updates \n    //     when triggerlines pass the edge of the viewport\n    // defer connectElements until triggercell triggerlines have been assigned\n    var triggerobserver = triggerlinesIntersect.createObserver();\n    return function () {\n      cradleintersectobserver.disconnect();\n      triggerobserver.disconnect();\n    };\n  }, []);\n  // =====================[ RECONFIGURATION effects ]======================\n  // change listsize, caching, resize (UI resize of the viewport), reconfigure, or pivot\n  // inernal callback: the new list size will always be less than current listsize\n  // invoked if getItem returns null\n  var nullItemSetMaxListsize = (0, react_1.useCallback)(function (maxListsize) {\n    var listsize = cradleInternalPropertiesRef.current.virtualListProps.size;\n    if (maxListsize < listsize) {\n      var _serviceHandler$callb = serviceHandler.callbacks,\n        deleteListCallback = _serviceHandler$callb.deleteListCallback,\n        changeListsizeCallback = _serviceHandler$callb.changeListsizeCallback;\n      var dListCallback;\n      if (deleteListCallback) {\n        dListCallback = function dListCallback(deleteList) {\n          deleteListCallback('getItem returned null', deleteList);\n        };\n      }\n      contentHandler.updateVirtualListSpecs(maxListsize);\n      cacheAPI.changeCacheListsize(maxListsize, dListCallback, changeListsizeCallback);\n    }\n  }, []);\n  // caching change\n  (0, react_1.useEffect)(function () {\n    if (cache == 'preload') {\n      setCradleState('startpreload');\n      return;\n    }\n    if (cradleStateRef.current == 'setup') return;\n    switch (cache) {\n      case 'keepload':\n        {\n          var modelIndexList = contentHandler.getModelIndexList();\n          var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var dListCallback;\n          if (deleteListCallback) {\n            dListCallback = function dListCallback(deleteList) {\n              deleteListCallback('pare cache to cacheMax', deleteList);\n            };\n          }\n          var _cacheMax = cradleParameters.cradleInheritedPropertiesRef.current.cacheMax;\n          if (cacheAPI.pareCacheToMax(_cacheMax, modelIndexList, dListCallback)) {\n            cacheAPI.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n      case 'cradle':\n        {\n          var _modelIndexList = contentHandler.getModelIndexList();\n          var _deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n          var _dListCallback;\n          if (_deleteListCallback) {\n            _dListCallback = function _dListCallback(deleteList) {\n              _deleteListCallback('match cache to cradle', deleteList);\n            };\n          }\n          if (cacheAPI.matchCacheToCradle(_modelIndexList, _dListCallback)) {\n            cacheAPI.renderPortalLists();\n          }\n          setCradleState('changecaching');\n          break;\n        }\n    }\n  }, [cache, cacheMax]);\n  // trigger viewportresizing response based on viewport state\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    // movement to and from cache is independent of ui viewportresizing\n    if (isCachedRef.current || wasCachedRef.current) {\n      return;\n    }\n    if (ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current != 'viewportresizing') {\n      interruptHandler.pauseInterrupts();\n      setCradleState('viewportresizing');\n    }\n    // complete viewportresizing mode\n    if (!ViewportContextPropertiesRef.current.isResizing && cradleStateRef.current == 'viewportresizing') {\n      setCradleState('finishviewportresize');\n    }\n  }, [ViewportContextPropertiesRef.current.isResizing]);\n  // reconfigure for changed size parameters\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reconfigure');\n  }, [cellHeight, cellWidth, gap, padding, triggerlineOffset, layout, runwaySize]);\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    if (isCachedRef.current) return;\n    var _cradleInternalProper = cradleInternalPropertiesRef.current,\n      virtualListProps = _cradleInternalProper.virtualListProps,\n      cradleContentProps = _cradleInternalProper.cradleContentProps;\n    var viewportRowcount = cradleContentProps.viewportRowcount,\n      lowCradleIndex = cradleContentProps.lowindex,\n      highCradleIndex = cradleContentProps.highindex,\n      cradleCount = cradleContentProps.size;\n    var listhighrange = virtualListProps.highindex;\n    var crosscount = cradleInternalPropertiesRef.current.virtualListProps.crosscount;\n    var runwaySize = cradleInheritedPropertiesRef.current.runwaySize;\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var calculatedCradleItemcount = calculatedCradleRowcount * crosscount;\n    // const indexSpan = contentHandler.indexSpan\n    // const [lowCradleIndex,highCradleIndex] = indexSpan\n    var measuredCradleItemCount;\n    var changeIsWithinCradle;\n    // if (indexSpan.length == 0) {\n    if (cradleCount == 0) {\n      measuredCradleItemCount = 0;\n      changeIsWithinCradle = true;\n    } else {\n      measuredCradleItemCount = highCradleIndex - lowCradleIndex + 1;\n      changeIsWithinCradle = highCradleIndex >= listhighrange; // (cradleInternalPropertiesRef.current.virtualListProps.highrange))\n    }\n\n    if (measuredCradleItemCount < calculatedCradleItemcount ||\n    // sub-viewport visible listcount\n    changeIsWithinCradle) {\n      // change is not beyond cradle\n      interruptHandler.pauseInterrupts();\n      setCradleState('reconfigureforlistsize');\n    } else {\n      setCradleState('ready');\n    }\n  }, [listsize]);\n  // a new getItem function implies the need to reload\n  (0, react_1.useEffect)(function () {\n    if (cradleStateRef.current == 'setup') return;\n    interruptHandler.pauseInterrupts();\n    setCradleState('reload');\n  }, [getItem]);\n  // pivot triggered on change of orientation\n  (0, react_1.useEffect)(function () {\n    layoutHandler.cradlePositionData.blockScrollProperty = orientation == \"vertical\" ? \"scrollTop\" : \"scrollLeft\";\n    layoutHandler.cradlePositionData.blockXScrollProperty = orientation == \"horizontal\" ? \"scrollTop\" : \"scrollLeft\";\n    if (cradleStateRef.current == 'setup') {\n      layoutHandler.cradlePositionData.blockScrollPos = 0;\n      layoutHandler.cradlePositionData.blockXScrollPos = 0;\n      return;\n    }\n    if (isCachedRef.current) {\n      hasBeenRenderedRef.current = false;\n      return;\n    }\n    var _cradleInheritedPrope = cradleInheritedPropertiesRef.current,\n      layout = _cradleInheritedPrope.layout,\n      gap = _cradleInheritedPrope.gap;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    if (layout == 'uniform') {\n      var _cradleInheritedPrope2 = cradleInheritedPropertiesRef.current,\n        _cellWidth = _cradleInheritedPrope2.cellWidth,\n        _cellHeight = _cradleInheritedPrope2.cellHeight,\n        _gap = _cradleInheritedPrope2.gap;\n      // get previous ratio\n      var previousCellPixelLength = (orientation == 'vertical' ? _cellWidth : _cellHeight) + _gap;\n      var previousAxisOffset = layoutHandler.cradlePositionData.targetAxisViewportPixelOffset;\n      var previousratio = previousAxisOffset / previousCellPixelLength;\n      var pivotCellPixelLength = (orientation == 'vertical' ? _cellHeight : _cellWidth) + _gap;\n      var pivotAxisOffset = previousratio * pivotCellPixelLength;\n      cradlePositionData.targetAxisViewportPixelOffset = Math.round(pivotAxisOffset);\n    } else {\n      cradlePositionData.targetAxisViewportPixelOffset = gap;\n    }\n    interruptHandler.pauseInterrupts();\n    setCradleState('pivot');\n  }, [orientation]);\n  // =====================[ STYLES ]===========================\n  // styles for the six scaffold components\n  var _ref8 = (0, react_1.useMemo)(function () {\n      return stylesHandler.getCradleStyles({\n        orientation: orientation,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        cellMinHeight: cellMinHeight,\n        cellMinWidth: cellMinWidth,\n        gap: gap,\n        padding: padding,\n        viewportheight: viewportheight,\n        viewportwidth: viewportwidth,\n        crosscount: crosscount,\n        userstyles: styles,\n        triggerlineOffset: triggerlineOffset,\n        layout: layout\n      });\n    }, [orientation, cellHeight, cellWidth, cellMinHeight, cellMinWidth, gap, padding, viewportheight, viewportwidth, crosscount, styles, triggerlineOffset, layout]),\n    _ref9 = _slicedToArray(_ref8, 6),\n    cradleHeadStyle = _ref9[0],\n    cradleTailStyle = _ref9[1],\n    cradleAxisStyle = _ref9[2],\n    cradleDividerStyle = _ref9[3],\n    triggercellTriggerlineHeadStyle = _ref9[4],\n    triggercellTriggerlineTailStyle = _ref9[5];\n  // =====================[ STATE MANAGEMENT ]==========================\n  // this is the core state engine (about 30 states), using named states\n  // useLayoutEffect for suppressing flashes\n  (0, react_1.useLayoutEffect)(function () {\n    switch (cradleState) {\n      // --------------[ precursors to setCradleContent ]---------------\n      // these are all workflow related, but\n      // resize could be asynchronous when rotating phone during scroll intertia\n      case 'setup':\n        {\n          // cycle to allow for ref assignments\n          if (cradleInheritedPropertiesRef.current.cache != 'preload') {\n            if (isCachedRef.current) {\n              setCradleState('cached');\n            } else {\n              setCradleState('firstrender'); // load grid\n            }\n          }\n\n          break;\n        }\n      case 'viewportresizing':\n        {\n          // no-op, wait for resizing to end\n          break;\n        }\n      case 'startpreload':\n        {\n          var finalCallback = function finalCallback() {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('pare cache to cacheMax', deleteList);\n              };\n            }\n            if (cacheAPI.pareCacheToMax(cacheMax, modelIndexList, dListCallback)) {\n              cacheAPI.renderPortalLists();\n            }\n            if (!isCachedRef.current) {\n              setCradleState('finishpreload');\n            } else {\n              setCradleState('cached');\n            }\n          };\n          cacheAPI.preload(finalCallback, nullItemSetMaxListsize);\n          break;\n        }\n      case 'cached':\n        {\n          if (!wasCachedRef.current && !isCachedRef.current) {\n            if (hasBeenRenderedRef.current) {\n              setCradleState('rerenderfromcache');\n            } else {\n              setCradleState('firstrenderfromcache');\n            }\n          } // else wait for reparenting\n          break;\n        }\n      case 'startreposition':\n        {\n          var signals = interruptHandler.signals;\n          signals.pauseTriggerlinesObserver = true;\n          // avoid recursive cradle intersection interrupts\n          signals.pauseCradleIntersectionObserver = true;\n          signals.repositioningRequired = false; // because now underway\n          scrollerID == 1 && console.log('Cradle: startreposition, scrollHandler.isScrolling', scrollHandler.isScrolling);\n          if (scrollHandler.isScrolling) {\n            setCradleState('repositioningRender'); // toggles with repositioningContinuation\n          } else {\n            setCradleState('finishreposition');\n          }\n          break;\n        }\n      // -------------------[ setCradleContent ]------------------\n      /*\n          the following 12 cradle states all resolve with\n          a chain starting with setCradleContent,\n          continuing with 'preparerender', and ending with\n          'restoreinterrupts', with a detour for variable layout\n          to reconfigure the scrollblock\n      */\n      case 'firstrender':\n      case 'firstrenderfromcache':\n      case 'rerenderfromcache':\n      case 'scrollto':\n      case 'changecaching':\n      case 'finishpreload':\n      case 'finishreposition':\n      case 'finishviewportresize':\n      case 'pivot':\n      case 'reconfigure':\n      case 'reconfigureforlistsize':\n      case 'reload':\n        {\n          if (!isMountedRef.current) return; // possible async latency with nested scrollers\n          if (isCachedRef.current) {\n            setCradleState('cached');\n            break;\n          }\n          var _cradleContent = contentHandler.content;\n          _cradleContent.headModelComponents = [];\n          _cradleContent.tailModelComponents = [];\n          var _layout = cradleInheritedPropertiesRef.current.layout;\n          interruptHandler.triggerlinesIntersect.disconnect();\n          interruptHandler.cradleIntersect.disconnect();\n          if (_layout == 'variable') {\n            // restore base config to scrollblock\n            // already done for reposition\n            cradleState != 'finishreposition' && layoutHandler.restoreBaseScrollblockConfig();\n          }\n          if (cradleState == 'reload') {\n            cacheAPI.clearCache();\n          }\n          if (cradleState == 'finishreposition') {\n            scrollHandler.calcImpliedRepositioningData('onScroll');\n          }\n          var _listsize = cradleInternalPropertiesRef.current.virtualListProps.size;\n          // set data\n          if (_listsize) contentHandler.setCradleContent(cradleState);\n          if (cradleState != 'finishpreload') {\n            hasBeenRenderedRef.current = true;\n          }\n          // synchronize cache if necessary\n          var _cache = cradleInheritedPropertiesRef.current.cache;\n          if (_cache == 'cradle') {\n            var modelIndexList = contentHandler.getModelIndexList();\n            var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n            var dListCallback;\n            if (deleteListCallback) {\n              dListCallback = function dListCallback(deleteList) {\n                deleteListCallback('match cache to cradle', deleteList);\n              };\n            }\n            if (cacheAPI.matchCacheToCradle(modelIndexList, dListCallback)) {\n              cacheAPI.renderPortalLists();\n            }\n          }\n          // prepare the cycle for preparerender\n          _cradleContent.headDisplayComponents = _cradleContent.headModelComponents;\n          _cradleContent.tailDisplayComponents = _cradleContent.tailModelComponents;\n          // update virtual DOM\n          if (_layout == 'uniform') {\n            setCradleState('preparerender');\n          } else {\n            setCradleState('refreshDOMsetforvariability');\n          }\n          break;\n        }\n      case 'preparerender':\n        {\n          // cycle for DOM update\n          // triggerlines will have been assigned to a new triggerCell by now.\n          // connectElements was delayed for a cycle to render triggercell triggerlines\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.cradleIntersect.connectElements();\n          setCradleState('restoreinterrupts'); // to restore interrupts\n          break;\n        }\n      case 'restoreinterrupts':\n        {\n          // normalize\n          interruptHandler.restoreInterrupts();\n          setCradleState('ready');\n          break;\n        }\n      // ----------------------[ followup from updateCradleContent ]------------\n      // scroll effects\n      // renderupdatedcontent is called from updateCradleContent. \n      // it is required to integrate changed DOM configurations before 'ready' is displayed\n      case 'renderupdatedcontent':\n        {\n          // cycle for DOM update\n          contentHandler.updateCradleContent();\n          setCradleState('finishupdatedcontent');\n          break;\n        }\n      case 'finishupdatedcontent':\n        {\n          // cycle for DOM update\n          // synchronize cache\n          var _cache2 = cradleInternalPropertiesRef.current.cache;\n          if (_cache2 == 'keepload') {\n            contentHandler.guardAgainstRunawayCaching();\n          }\n          var _layout2 = cradleInheritedPropertiesRef.current.layout;\n          if (_layout2 == 'uniform') {\n            interruptHandler.triggerlinesIntersect.connectElements();\n            // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n            // setCradleState('reconnectupdatedcontent')\n            setCradleState('ready');\n          } else {\n            // 'variable' content requiring reconfiguration\n            setCradleState('refreshDOMupdateforvariability');\n          }\n          break;\n        }\n      // ---------------------[ adjust scrollblock for set variable content ]--------------\n      case 'refreshDOMsetforvariability':\n        {\n          setCradleState('preparesetforvariability');\n          break;\n        }\n      case 'preparesetforvariability':\n        {\n          setTimeout(function () {\n            if (isMountedRef.current) {\n              contentHandler.adjustScrollblockForVariability('setcradle');\n              setCradleState('finishsetforvariability');\n            }\n          }, VARIABLE_MEASUREMENTS_TIMEOUT);\n          break;\n        }\n      case 'finishsetforvariability':\n        {\n          setCradleState('preparerender');\n          break;\n        }\n      // ------------------------[ adjust scrollblock for update variable content ]--------------\n      case 'refreshDOMupdateforvariability':\n        {\n          // extra cycle to allow for DOM synchronizion with grid changes\n          setCradleState('adjustupdateforvariability');\n          break;\n        }\n      case 'adjustupdateforvariability':\n        {\n          setTimeout(function () {\n            contentHandler.adjustScrollblockForVariability('updatecradle');\n            setCradleState('finishupdateforvariability');\n          }, 0);\n          break;\n        }\n      case 'finishupdateforvariability':\n        {\n          // re-activate triggers; triggerlines will have been assigned to a new triggerCell by now.\n          interruptHandler.triggerlinesIntersect.connectElements();\n          interruptHandler.signals.pauseCradleIntersectionObserver = false;\n          setCradleState('ready');\n          break;\n        }\n      // ----------------[ user requests ]-------------\n      case 'channelcradleresetafterinsertremove':\n        {\n          cacheAPI.applyPortalPartitionItemsForDeleteList();\n          setCradleState('changelistsizeafterinsertremove');\n          break;\n        }\n      // support for various host service requests; syncs cradle content with cache changes\n      case 'applyinsertremovechanges':\n      case 'applyremapchanges':\n      case 'applymovechanges':\n        {\n          cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n          cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n          cacheAPI.applyPortalPartitionItemsForDeleteList();\n          if (cradleState == 'applyinsertremovechanges') {\n            setCradleState('changelistsizeafterinsertremove');\n          } else {\n            setCradleState('ready');\n          }\n          break;\n        }\n      case 'changelistsizeafterinsertremove':\n        {\n          var newlistsize = serviceHandler.newlistsize;\n          serviceHandler.newlistsize = null;\n          setCradleState('ready');\n          // service handler called because this is a followon of a user intervention\n          serviceHandler.setListsize(newlistsize);\n          break;\n        }\n      case 'clearcache':\n        {\n          contentHandler.clearCradle();\n          cradleContent.headDisplayComponents = [];\n          cradleContent.tailDisplayComponents = [];\n          cacheAPI.clearCache();\n          setCradleState('ready');\n          break;\n        }\n    }\n  }, [cradleState]);\n  // standard rendering states (3 states)\n  (0, react_1.useEffect)(function () {\n    switch (cradleState) {\n      // repositioningRender and repositioningContinuation are toggled to generate continuous \n      // repositioning renders\n      case 'repositioningRender':\n        // no-op\n        break;\n      case 'repositioningContinuation':\n        // set from onScroll\n        setCradleState('repositioningRender');\n        break;\n      case 'ready':\n        // no-op\n        break;\n    }\n  }, [cradleState]);\n  // ==========================[ RENDER ]===========================\n  var scrollAxisReferencePosition = layoutHandler.cradlePositionData.targetAxisReferencePosition;\n  var scrollAxisReferenceIndex = scrollAxisReferencePosition + lowindex;\n  var scrollIndexRef = (0, react_1.useRef)(scrollAxisReferencePosition);\n  var scrollTrackerArgs = (0, react_1.useMemo)(function () {\n    if (!['repositioningContinuation', 'repositioningRender', 'finishreposition'].includes(cradleState)) {\n      return null;\n    }\n    if (scrollAxisReferencePosition != scrollIndexRef.current) {\n      scrollIndexRef.current = scrollAxisReferencePosition;\n      var repositioningIndexCallback = serviceHandler.callbacks.repositioningIndexCallback;\n      repositioningIndexCallback && repositioningIndexCallback(scrollAxisReferenceIndex);\n    }\n    if (!useScrollTracker) return null;\n    var trackerargs = {\n      top: viewportDimensions.top + 3,\n      left: viewportDimensions.left + 3,\n      scrollAxisReferenceIndex: scrollAxisReferenceIndex,\n      scrollAxisReferencePosition: scrollAxisReferencePosition,\n      listsize: listsize,\n      styles: styles\n    };\n    return trackerargs;\n  }, [cradleState, viewportDimensions, scrollAxisReferenceIndex, scrollAxisReferencePosition, listsize, styles, useScrollTracker]);\n  var cradleContent = contentHandler.content;\n  var triggercellTriggerlinesRef = (0, react_1.useRef)(null);\n  triggercellTriggerlinesRef.current = (0, react_1.useMemo)(function () {\n    return [react_1[\"default\"].createElement(\"div\", {\n      key: 'head',\n      \"data-type\": 'headtrigger',\n      style: triggercellTriggerlineHeadStyle,\n      ref: triggercellTriggerlineHeadElementRef\n    }), react_1[\"default\"].createElement(\"div\", {\n      key: 'tail',\n      \"data-type\": 'tailtrigger',\n      style: triggercellTriggerlineTailStyle,\n      ref: triggercellTriggerlineTailElementRef\n    })];\n  }, [triggercellTriggerlineHeadStyle, triggercellTriggerlineTailStyle]);\n  var contextvalueRef = (0, react_1.useRef)({\n    scrollerPropertiesRef: scrollerPropertiesRef,\n    cacheAPI: cacheAPI,\n    nullItemSetMaxListsize: nullItemSetMaxListsize,\n    itemExceptionCallback: serviceHandler.callbacks.itemExceptionCallback,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    triggercellTriggerlinesRef: triggercellTriggerlinesRef\n  });\n  // display the cradle components, the ScrollTracker, or null\n  return react_1[\"default\"].createElement(exports.CradleContext.Provider, {\n    value: contextvalueRef.current\n  }, ['repositioningContinuation', 'repositioningRender'].includes(cradleState) ? useScrollTracker ? react_1[\"default\"].createElement(ScrollTracker_1[\"default\"], {\n    top: scrollTrackerArgs.top,\n    left: scrollTrackerArgs.left,\n    offset: scrollTrackerArgs.scrollAxisReferencePosition,\n    index: scrollTrackerArgs.scrollAxisReferenceIndex,\n    listsize: scrollTrackerArgs.listsize,\n    styles: scrollTrackerArgs.styles\n  }) : null : react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-axis',\n    style: cradleAxisStyle,\n    ref: axisCradleElementRef\n  }, showAxis ?\n  // for debug\n  react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'cradle-divider',\n    style: cradleDividerStyle\n  }) : null, react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'head',\n    ref: headCradleElementRef,\n    style: cradleHeadStyle\n  }, cradleState != 'setup' ? cradleContent.headDisplayComponents : null), react_1[\"default\"].createElement(\"div\", {\n    \"data-type\": 'tail',\n    ref: tailCradleElementRef,\n    style: cradleTailStyle\n  }, cradleState != 'setup' ? cradleContent.tailDisplayComponents : null)));\n}; // Cradle\nexports[\"default\"] = Cradle;\n// utility\nvar getCradleHandlers = function getCradleHandlers(cradleParameters) {\n  var createHandler = function createHandler(handler) {\n    return new handler(cradleParameters);\n  };\n  var cacheAPI = cradleParameters.cradleInheritedPropertiesRef.current.cacheAPI;\n  cacheAPI.cradleParameters = cradleParameters;\n  return {\n    cacheAPI: cacheAPI,\n    interruptHandler: createHandler(interrupthandler_1[\"default\"]),\n    scrollHandler: createHandler(scrollhandler_1[\"default\"]),\n    stateHandler: createHandler(statehandler_1[\"default\"]),\n    contentHandler: createHandler(contenthandler_1[\"default\"]),\n    layoutHandler: createHandler(layouthandler_1[\"default\"]),\n    serviceHandler: createHandler(servicehandler_1[\"default\"]),\n    stylesHandler: createHandler(styleshandler_1[\"default\"])\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZUFBQSxXQUFhO0dBRTVDO0FBRUwsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvQ3JhZGxlLnRzeD83MTk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyYWRsZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhlIENyYWRsZSBkb2VzIHRoZSBidWxrIG9mIHRoZSB3b3JrIGZvciB0aGUgaW5maW5pdGUgZ3JpZCBzY3JvbGxlci4gSXQgZG9lcyBzbyB3aXRoIHRoZSBoZWxwIG9mXG4gICAgZWlnaHQgcHJvY2VzcyBoYW5kbGVycyAoY2xhc3MgaW5zdGFuY2VzKSwgYW5kIG9uZSBtYWluIHN1Yi1jb21wb25lbnQgLSB0aGUgQ2VsbEZyYW1lLlxuXG4gICAgQ3JhZGxlJ3MgbWFpbiByZXNwb25zaWJpbGl0eSBpcyB0byBtYW5hZ2UgdGhlIH4zMCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBzeXN0ZW0uXG5cbiAgICBUaGUgaWxsdXNpb24gb2YgaW5maW5pdGUgY29udGVudCBpcyBtYWludGFpbmVkIGJ5IHN5bmNocm9uaXppbmcgY2hhbmdlcyBpbiBjcmFkbGUgY29udGVudCB3aXRoIHRoZVxuICAgIENyYWRsZSBsb2NhdGlvbiBpbnNpZGUgdGhlIFNjcm9sbGJsb2NrLCBzdWNoIHRoYXQgYXMgdGhlIFNjcm9sbGJsb2NrIGlzIG1vdmVkLCB0aGUgY3JhZGxlIG1vdmVzIFxuICAgIG9wcG9zaXRlbHkgdG8gc3RheSB2aXNpYmxlIHdpdGhpbiB0aGUgdmlld3BvcnQuXG5cbiAgICBUaGUgU2Nyb2xsYmxvY2sgaXMgc2l6ZWQgdG8gYXBwcm94aW1hdGUgdGhlIGxpc3QgYmVpbmcgdmlld2VkLCBzbyBhcyB0byBoYXZlIGEgc2Nyb2xsIHRodW1iIHNpemUgXG4gICAgYW5kIHBvc2l0aW9uIHdoaWNoIHJlYWxpc3RpY2FsbHkgcmVmbGVjdHMgdGhlIHNpemUgb2YgdGhlIGxpc3QgYmVpbmcgc2hvd24uXG5cbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGNyYWRsZSBpcyBjb250cm9sbGVkIGJ5IGFuICdheGlzJyB3aGljaCBpcyBhIDBweCBoZWlnaHQvd2lkdGggZGl2XG4gICAgKGFsb25nIHRoZSBtZWRpYWwgLSBTY3JvbGxCbG9jayBjYW4gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCkuIFRoZSBwdXJwb3NlIG9mIHRoZSBheGlzIGlzIHRvIFxuICAgIGFjdCBhcyBhICdmb2xkJywgYWJvdmUgd2hpY2ggY3JhZGxlIGNvbnRlbnQgZXhwYW5kcyAnaGVhZHdhcmRzJyAodXAgb3IgbGVmdCkgaW4gdGhlIENyYWRsZSwgYW5kIFxuICAgIGJlbG93IHdoaWNoIHRoZSBjcmFkbGUgY29udGVudCBleHBhbmRzICd0YWlsd2FyZHMnIChkb2VuIG9yIHJpZ2h0KS4gVGhlIENyYWRsZSBjb250ZW50IGlzIGhlbGQgaW4gXG4gICAgdHdvIENTUyBncmlkcyAoY2hpbGRyZW4gb2YgdGhlIGF4aXMpOiBvbmUgYWJvdmUgb3IgbGVmdCAodGhlICdoZWFkJyBncmlkKSwgYW5kIG9uZSBiZWxvdyBvciByaWdodCwgXG4gICAgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBheGlzICh0aGUgJ3RhaWwnIGdyaWQpLlxuXG4gICAgVGhlIGF4aXMgaXMga2VwdCBuZWFyIHRoZSBsZWFkaW5nIChoZWFkd2FyZCkgZWRnZSBvZiB0aGUgdmlzaWJsZSBjZWxsIHJvd3Mgb2YgdGhlIFZpZXdwb3J0XG5cbiAgICBUZWNobmljYWxseSwgdGhlcmUgYXJlIHNldmVyYWwga2V5IHJlZmVyZW5jZSBwb2ludHMgdHJhY2tlZCBieSB0aGUgQ3JhZGxlLiBUaGVzZSBhcmU6XG4gICAgICAgIC0gYXhpc1JlZmVyZW5jZUluZGV4IGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIHRoZSBpdGVtIGNvbnRyb2xsaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgYXhpcy5cbiAgICAgICAgICAgIFRoZSBheGlzUmVmZXJlbmNlSW5kZXggaXMgYWxzbyB1c2VkIHRvIGFsbG9jYXRlIGl0ZW1zIGFib3ZlIChsb3dlciBpbmRleCB2YWx1ZSkgYW5kIGJlbG93IFxuICAgICAgICAgICAgKHNhbWUgb3IgaGlnaGVyIGluZGV4IHZhbHVlKSB0aGUgYXhpcyBmb2xkLiBUaGUgYXhpc1JlZmVybmNlSW5kZXggaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIFxuICAgICAgICAgICAgdGFpbCBzZWN0aW9uIG9mIHRoZSBDcmFkbGUuXG4gICAgICAgIC0gKGNyYWRsZVJlZmVyZW5jZUluZGV4IGlzIGluZmVycmVkIGZyb20gdGhlIGF4aXNSZWZlcmVuY2VJbmRleCwgYW5kIGlzIHRoZSB2aXJ0dWFsIGluZGV4IG9mIFxuICAgICAgICAgICAgdGhlIGl0ZW0gZGVmaW5pbmcgdGhlIGxlYWRpbmcgYm91bmQgb2YgdGhlIGNyYWRsZSBjb250ZW50LiBUaGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdXN1YWxseSBcbiAgICAgICAgICAgIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBoZWFkIHNlY3Rpb24gb2YgdGhlIENyYWRsZSwgdW5sZXNzIHRoZSBjcmFkbGUgc2hvd3MgdGhlIHZlcnkgdG9wIG9mIHRoZVxuICAgICAgICAgICAgbGlzdCwgaW4gd2hpY2ggY2FzZSB0aGUgY3JhZGxlUmVmZXJlbmNlSW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIEF4aXNSZWZlcmVuY2VJbmRleClcbiAgICAgICAgLSBheGlzVmlld3BvcnRQaXhlbE9mZnNldCAocGl4ZWxzIHRoYXQgcGxhY2UgdGhlIGF4aXMgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0J3MgbGVhZGluZyBlZGdlKVxuICAgICAgICAtIHRoZSBibG9ja1Njcm9sbFBvcywgd2hpY2ggaXMgdGhlIGFtb3VudCBvZiBzY3JvbGwgKFZpZXdwb3J0IHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0KSBvZiB0aGUgXG4gICAgICAgICAgICBTY3JvbGxCbG9ja1xuICAgIFxuICAgIE92ZXJzY3JvbGwgaGFuZGxpbmcgKHJlcG9zaXRpb25pbmcpOlxuICAgICAgICBPd2luZyB0byB0aGUgcG90ZW50aWFsIHJhcGlkaXR5IG9mIHNjcm9sbGluZywgd2hpY2ggaW4gdGhlIGNhc2Ugb2YgbGFyZ2UgbGlzdHMgYW5kIGhlYXZ5IGNvbnRlbnQgXG4gICAgICAgIGNhbiBiZSB0b28gZmFzdCBmb3IgdGhlIHN5c3RlbSB0byBrZWVwIHVwLCB0aGVyZSBpcyBhbiBvdmVyc2Nyb2xsIHByb3RvY29sIGNhbGxlZCAncmVwb3NpdGlvbmluZycuXG5cbiAgICAgICAgSWYgdGhlIG92ZXJzY3JvbGwgaXMgc3VjaCB0aGF0IHRoZSBjcmFkbGUgKGluY2x1ZGluZyBpdHMgdHdvIGNvbnRlbnQgZ3JpZHMpIGhhcyBlbnRpcmVseSBwYXNzZWQgXG4gICAgICAgIG91dCBvZiB0aGUgdmlld3BvcnQsIHRoZW4gdGhlIENyYWRsZSBjb21wb25lbnQgaXMgcmVwbGFjZWQgYnkgYSBTY3JvbGxUcmFja2VyIChvciBieSBudWxsIGlmIFxuICAgICAgICB0aGUgaG9zdCB0YWtlcyByZXNwb25zaWJpbGl0eSBmb3IgZmVlZGJhY2spLiBUaGUgU2Nyb2xsVHJhY2tlciBkaXNwbGF5cyB0byB0aGUgdXNlciB0aGUgcmVsYXRpdmUgXG4gICAgICAgIGxvY2F0aW9uIGluIHRoZSB2aXJ0dWFsIGxpc3QgYXQgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGR1cmluZyByZXBvc2l0aW9uaW5nLiBXaGVuIHRoZSBzY3JvbGxpbmdcbiAgICAgICAgc3RvcHMgQ3JhZGxlIHJlY3JlYXRlcyB0aGUgY3JhZGxlIGNvbnRlbnQsIGFjY29yZGluZyB0byB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIHJlcG9zaXRpb25pbmcgXG4gICAgICAgIHByb2Nlc3MuXG5cbiAgICBDcmFkbGUgY2hhbmdlcyBhcmUgYWN0aXZhdGVkIGJ5IGludGVycnVwdHM6XG4gICAgLSBzY3JvbGxpbmdcbiAgICAtIHJlc2l6aW5nIG9mIHRoZSB2aWV3cG9ydFxuICAgIC0gb2JzZXJ2ZXIgY2FsbGJhY2tzOlxuICAgICAgICAtIGNyYWRsZS92aWV3cG9ydCBpbnRlcnNlY3Rpb24gZm9yIHJlcG9zaXRpb25pbmcgd2hlbiB0aGUgY3JhZGxlIHJhY2VzIG91dCBvZiBzY29wZVxuICAgICAgICAtIHR3byAndHJpZ2dlcmxpbmUnL3ZpZXdwb3J0IGludGVyc2VjdGlvbnMgd2hpY2ggdHJpZ2dlciByb2xsaW5nIG9mIGNvbnRlbnRcbiAgICAgICAgICAgIC0gcm9sbGluZyBjb250ZW50IHRyaWdnZXJzIHJlLWFsbG9jYXRpb24gb2YgY29udGVudCBiZXR3ZWVuIGNyYWRsZSBoZWFkIGFuZCB0YWlsIGdyaWRzXG4gICAgLSBwaXZvdCAtIGNoYW5nZSBvZiBvcmllbnRhdGlvblxuICAgIC0gaG9zdCBjaGFuZ2VzIG9mIGNvbmZpZ3VyYXRpb24gc3BlY3MgdGhyb3VnaCBwcm9wZXJ0eSBjaGFuZ2VzIG9yIGRpcmVjdCBzZXJ2aWNlIGNhbGxzXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgXG4gICAgdXNlU3RhdGUsIFxuICAgIHVzZVJlZiwgXG4gICAgdXNlQ29udGV4dCwgXG4gICAgdXNlRWZmZWN0LCBcbiAgICB1c2VMYXlvdXRFZmZlY3QsIFxuICAgIHVzZU1lbW8sXG4gICAgdXNlQ2FsbGJhY2ssIFxufSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgVmlld3BvcnRDb250ZXh0IH0gZnJvbSAnLi9WaWV3cG9ydCdcblxuLy8gcG9wdXAgcG9zaXRpb24gdHJhY2tlciBmb3IgcmVwb3NpdGlvbmluZ1xuaW1wb3J0IFNjcm9sbFRyYWNrZXIgZnJvbSAnLi9jcmFkbGUvU2Nyb2xsVHJhY2tlcidcblxuLy8gc3VwcG9ydCBjb2RlOyBwcm9jZXNzIGhhbmRsZXJzXG5pbXBvcnQgU2Nyb2xsSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zY3JvbGxoYW5kbGVyJ1xuaW1wb3J0IFN0YXRlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zdGF0ZWhhbmRsZXInXG5pbXBvcnQgQ29udGVudEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvY29udGVudGhhbmRsZXInXG5pbXBvcnQgTGF5b3V0SGFuZGxlciBmcm9tICcuL2NyYWRsZS9sYXlvdXRoYW5kbGVyJ1xuaW1wb3J0IEludGVycnVwdEhhbmRsZXIgZnJvbSAnLi9jcmFkbGUvaW50ZXJydXB0aGFuZGxlcidcbmltcG9ydCBTZXJ2aWNlSGFuZGxlciBmcm9tICcuL2NyYWRsZS9zZXJ2aWNlaGFuZGxlcidcbmltcG9ydCBTdHlsZXNIYW5kbGVyIGZyb20gJy4vY3JhZGxlL3N0eWxlc2hhbmRsZXInXG4vLyBjYWNoZUFQSSBpcyBpbXBvcnRlZCBhcyBhIHByb3BlcnR5OyBpbnN0YW50aWF0ZWQgYXQgdGhlIHJvb3RcblxuaW1wb3J0IHsgaXNTYWZhcmlJT1MgfSBmcm9tICcuL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG4vLyBmb3IgY2hpbGRyZW5cbmV4cG9ydCBjb25zdCBDcmFkbGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKVxuXG4vLyBjb21wb25lbnRcbmNvbnN0IENyYWRsZSA9ICh7IFxuICAgICAgICBncmlkU3BlY3MsXG4gICAgICAgIC8vIGJhc2ljc1xuICAgICAgICBydW53YXlTaXplLCBcbiAgICAgICAgLy8gbGlzdHNpemUsIFxuICAgICAgICB2aXJ0dWFsTGlzdFNwZWNzLFxuICAgICAgICBzZXRWaXJ0dWFsTGlzdFNwZWNzLFxuICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgIHBsYWNlaG9sZGVyLCBcbiAgICAgICAgcGxhY2Vob2xkZXJNZXNzYWdlcyxcbiAgICAgICAgdXNlckNhbGxiYWNrcyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIC8vIGZvciBoYW5kbGVyIGxpc3RcbiAgICAgICAgY2FjaGVBUEksXG4gICAgICAgIC8vIHN5c3RlbVxuICAgICAgICB1c2VQbGFjZWhvbGRlcixcbiAgICAgICAgdXNlU2Nyb2xsVHJhY2tlcixcbiAgICAgICAgc2hvd0F4aXMsXG4gICAgICAgIE9OQUZURVJTQ1JPTExfVElNRU9VVCxcbiAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQsXG4gICAgICAgIE1BWF9DQUNIRV9PVkVSX1JVTixcbiAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQsXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcblxuICAgIH0pID0+IHtcblxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICB9LFtdKVxuXG4gICAgY29uc3QgbGlzdHNpemUgPSB2aXJ0dWFsTGlzdFNwZWNzLnNpemVcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PVsgREFUQSBTRVRVUCBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1bnBhY2sgZ3JpZFNwZWNzXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9ID0gZ3JpZFNwZWNzXG5cbiAgICAvLyBnZXQgdmlld3BvcnQgY29udGV4dFxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB1c2VDb250ZXh0KFZpZXdwb3J0Q29udGV4dClcblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIC8vIGZvciBjbG9zdXJlc1xuXG4gICAgLy8gZmxhZ3NcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcbiAgICBjb25zdCBpc0NhY2hlZFJlZiA9IHVzZVJlZihmYWxzZSlcbiAgICBjb25zdCB3YXNDYWNoZWRSZWYgPSB1c2VSZWYoZmFsc2UpXG4gICAgY29uc3QgaGFzQmVlblJlbmRlcmVkUmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gICAgLy8gdHJpZ2dlciBjb250cm9sXG4gICAgY29uc3QgdHJpZ2dlckhpc3RvcnlSZWYgPSB1c2VSZWYoe1xuICAgICAgICBwcmV2aW91c1JlZmVyZW5jZU5hbWU6bnVsbCxcbiAgICB9KVxuXG4gICAgLy8gIHZpZXdwb3J0IGRpbWVuc2lvbnMgYW5kIGNhY2hlZCBzdGF0ZVxuICAgIGNvbnN0IGdldFZpZXdwb3J0RGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOnZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDp2aWV3cG9ydEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0d28gc291cmNlczsgY291bGQgdXNlIHNvbWUgcmVjb25jaWxpYXRpb25cbiAgICBjb25zdCB7IHZpZXdwb3J0RGltZW5zaW9ucyB9ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyAvLyBmb3Igc2Nyb2xsVHJhY2tlclxuICAgIGNvbnN0IHsgaGVpZ2h0OnZpZXdwb3J0aGVpZ2h0LHdpZHRoOnZpZXdwb3J0d2lkdGggfSA9IGdldFZpZXdwb3J0RGltZW5zaW9ucygpIC8vIHZpZXdwb3J0RGltZW5zaW9uc1xuXG4gICAgLy8gY2FjaGUgdGVzdFxuICAgIC8vIHplcm8gd2lkdGggYW5kIGhlaWdodCBtZWFucyB0aGUgY29tcG9uZW50IG11c3QgYmUgaW4gcG9ydGFsIChjYWNoZSkgc3RhdGVcbiAgICBjb25zdCBpc0luUG9ydGFsID0gKCh2aWV3cG9ydHdpZHRoID09IDApICYmICh2aWV3cG9ydGhlaWdodCA9PSAwKSkgXG5cbiAgICBjb25zdCBpc0NhY2hlQ2hhbmdlID0gKGlzSW5Qb3J0YWwgIT0gaXNDYWNoZWRSZWYuY3VycmVudClcblxuICAgIGlmIChpc0NhY2hlQ2hhbmdlKSB7XG4gICAgICAgIHdhc0NhY2hlZFJlZi5jdXJyZW50ID0gaXNDYWNoZWRSZWYuY3VycmVudFxuICAgICAgICBpc0NhY2hlZFJlZi5jdXJyZW50ID0gaXNJblBvcnRhbFxuICAgIH1cblxuICAgIC8vIGNyYWRsZSBzdGF0ZVxuICAgIGNvbnN0IFtjcmFkbGVTdGF0ZSwgc2V0Q3JhZGxlU3RhdGVdID0gdXNlU3RhdGUoJ3NldHVwJylcbiAgICBjb25zdCBjcmFkbGVTdGF0ZVJlZiA9IHVzZVJlZihudWxsKSAvLyBhY2Nlc3MgYnkgY2xvc3VyZXNcbiAgICBjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID0gY3JhZGxlU3RhdGVcblxuICAgIC8vIGlmICghc2Nyb2xsZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLT4gY3JhZGxlU3RhdGUnLCctJytzY3JvbGxlcklEKyctJywgY3JhZGxlU3RhdGUpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLSBpbmRleCcsJ34nK3Njcm9sbGVyUHJvcGVydGllcz8uY2VsbEZyYW1lUHJvcGVydGllc1JlZi5jdXJyZW50LmluZGV4Kyd+JylcbiAgICAvLyB9XG5cbiAgICAvLyBjcmFkbGUgc2NhZmZvbGQgZWxlbWVudCByZWZzXG4gICAgY29uc3QgaGVhZENyYWRsZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCB0YWlsQ3JhZGxlRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IGF4aXNDcmFkbGVFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBsYXlvdXQgYnVuZGxlXG4gICAgY29uc3QgY3JhZGxlRWxlbWVudHNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRSZWY6aGVhZENyYWRsZUVsZW1lbnRSZWYsIFxuICAgICAgICAgICAgdGFpbFJlZjp0YWlsQ3JhZGxlRWxlbWVudFJlZiwgXG4gICAgICAgICAgICBheGlzUmVmOmF4aXNDcmFkbGVFbGVtZW50UmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWY6dHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRFbGVtZW50UmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWY6dHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxFbGVtZW50UmVmLFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGVkIHByb3BlcnRpZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNvbmZpZ3VyYXRpb24gY2FsY3VsYXRpb25zXG5cbiAgICAvLyBjcm9zc2NvdW50IChhbHNvIGNhbGN1bGF0ZWQgYnkgU2Nyb2xsYmxvY2sgZm9yIGRlcml2aW5nIFNjcm9sbGJsb2NrIGxlbmd0aClcbiAgICBjb25zdCBjcm9zc2NvdW50ID0gdXNlTWVtbygoKSA9PiB7IC8vIHRoZSBudW1iZXIgb2YgY2VsbHMgY3Jvc3Npbmcgb3JpZW50YXRpb25cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkgcmV0dXJuIDBcblxuICAgICAgICBjb25zdCB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodFxuXG4gICAgICAgIC8vIGNyb3NzIGxlbmd0aCBvZiB2aWV3cG9ydCAoZ2FwIHRvIG1hdGNoIGNyb3NzTGVuZ3RoKVxuICAgICAgICBjb25zdCB2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYyA9IHZpZXdwb3J0Y3Jvc3NsZW5ndGggLSAocGFkZGluZyAqIDIpICsgZ2FwIFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGg6XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCkgXG4gICAgICAgICAgICArIGdhcFxuXG4gICAgICAgIGNvbnN0IGNlbGxjcm9zc2xlbmd0aGZvcmNhbGMgPSBcbiAgICAgICAgICAgIE1hdGgubWluKGNlbGxjcm9zc2xlbmd0aCx2aWV3cG9ydGNyb3NzbGVuZ3RoZm9yY2FsYykgLy8gcmVzdWx0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMVxuXG4gICAgICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjL2NlbGxjcm9zc2xlbmd0aGZvcmNhbGMpXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGN1bGF0ZWQgY3Jvc3Njb3VudCcsIGNyb3NzY291bnQpXG5cbiAgICAgICAgcmV0dXJuIGNyb3NzY291bnRcblxuICAgIH0sW1xuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGdhcCwgXG4gICAgICAgIHBhZGRpbmcsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LCBcbiAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgIF0pXG5cbiAgICBjb25zdCB7bG93aW5kZXgsIGhpZ2hpbmRleH0gPSB2aXJ0dWFsTGlzdFNwZWNzXG5cbiAgICBjb25zdCBbYmFzZXJvd2JsYW5rcywgZW5kcm93YmxhbmtzXSA9IHVzZU1lbW8oKCk9PiB7XG5cbiAgICAgICAgLy8gYWRkIHBvc2l0aW9uIGFkanVzdG1lbnQgZm9yIDBcbiAgICAgICAgY29uc3QgZW5kYWRqdXN0bWVudCA9XG4gICAgICAgICAgICAoaGlnaGluZGV4IDwgMCk/XG4gICAgICAgICAgICAgICAgLTE6XG4gICAgICAgICAgICAgICAgMVxuXG4gICAgICAgIC8vIGdldCBpbml0aWFsIHZhbHVlc1xuICAgICAgICBsZXQgYmFzZXJvd2JsYW5rcyA9IE1hdGguYWJzKGxvd2luZGV4KSAlIGNyb3NzY291bnRcbiAgICAgICAgbGV0IGVuZHJvd2JsYW5rcyA9IChNYXRoLmFicyhoaWdoaW5kZXgpICsgZW5kYWRqdXN0bWVudCkgJSBjcm9zc2NvdW50XG5cbiAgICAgICAgLy8gdGFrZSBpbnZlcnNlIGRlcGVuZGluZyBvbiBkaXJlY3Rpb25cbiAgICAgICAgaWYgKGxvd2luZGV4IDwgMCkge1xuICAgICAgICAgICAgYmFzZXJvd2JsYW5rcyA9XG4gICAgICAgICAgICAgICAgKGJhc2Vyb3dibGFua3MgPT0gMCk/IFxuICAgICAgICAgICAgICAgIDA6XG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCAtIGJhc2Vyb3dibGFua3NcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoaWdoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgZW5kcm93YmxhbmtzID1cbiAgICAgICAgICAgICAgICAoZW5kcm93YmxhbmtzID09IDApPyBcbiAgICAgICAgICAgICAgICAwOlxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQgLSBlbmRyb3dibGFua3NcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb3dyYW5nZSwgaGlnaHJhbmdlLCBjcm9zc2NvdW50LCBiYXNlcm93YmxhbmtzLCBlbmRyb3dibGFua3MnLFxuICAgICAgICAvLyAgICAgbG93cmFuZ2UsIGhpZ2hyYW5nZSwgY3Jvc3Njb3VudCwgYmFzZXJvd2JsYW5rcywgZW5kcm93YmxhbmtzKVxuXG4gICAgICAgIHJldHVybiBbYmFzZXJvd2JsYW5rcywgZW5kcm93YmxhbmtzXVxuXG4gICAgfSxbY3Jvc3Njb3VudCwgbG93aW5kZXgsIGhpZ2hpbmRleF0pXG5cblxuICAgIC8vIHZhcmlvdXMgcm93IGNvdW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlUm93Y291bnQsIFxuICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICBsaXN0Um93Y291bnQsXG4gICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0TGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQ6XG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aFxuXG4gICAgICAgIGxldCBiYXNlUm93TGVuZ3RoXG4gICAgICAgIGlmIChsYXlvdXQgPT0gJ3VuaWZvcm0nKSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbEhlaWdodFxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgYmFzZVJvd0xlbmd0aCA9IGNlbGxXaWR0aFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gbGF5b3V0ID09ICd2YXJpYWJsZSdcblxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgIGJhc2VSb3dMZW5ndGggPSBjZWxsTWluSGVpZ2h0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBiYXNlUm93TGVuZ3RoID0gY2VsbE1pbldpZHRoXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgYmFzZVJvd0xlbmd0aCArPSBnYXBcblxuICAgICAgICBjb25zdCB2aWV3cG9ydFJvd2NvdW50ID0gTWF0aC5jZWlsKHZpZXdwb3J0TGVuZ3RoL2Jhc2VSb3dMZW5ndGgpXG5cbiAgICAgICAgLy8gY29uc3QgbGlzdFJvd2NvdW50ID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG4gICAgICAgIGNvbnN0IGxpc3RSb3djb3VudCA9IE1hdGguY2VpbCgobGlzdHNpemUgKyBiYXNlcm93YmxhbmtzICsgZW5kcm93YmxhbmtzKS9jcm9zc2NvdW50KVxuXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG5cbiAgICAgICAgbGV0IGNyYWRsZVJvd2NvdW50ID0gTWF0aC5taW4obGlzdFJvd2NvdW50LCBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQpXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NyYWRsZTpsaXN0Um93Y291bnQsIGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCwgY3JhZGxlUm93Y291bnQnLCBcbiAgICAgICAgLy8gICAgIGxpc3RSb3djb3VudCwgY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50LCBjcmFkbGVSb3djb3VudClcblxuICAgICAgICBsZXQgcnVud2F5Um93Y291bnRcbiAgICAgICAgaWYgKGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA+PSBjcmFkbGVSb3djb3VudCkge1xuXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCA9IHJ1bndheVNpemVcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gKGNyYWRsZVJvd2NvdW50IC0gY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50KVxuICAgICAgICAgICAgcnVud2F5Um93Y291bnQgLT0gTWF0aC5mbG9vcihkaWZmLzIpXG4gICAgICAgICAgICBydW53YXlSb3djb3VudCA9IE1hdGgubWF4KDAscnVud2F5Um93Y291bnQpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtY291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICAgICAgaWYgKGl0ZW1jb3VudCA+IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGl0ZW1jb3VudCA9IGxpc3RzaXplXG4gICAgICAgICAgICBjcmFkbGVSb3djb3VudCA9IE1hdGguY2VpbCgoaXRlbWNvdW50ICsgYmFzZXJvd2JsYW5rcyArIGVuZHJvd2JsYW5rcykvY3Jvc3Njb3VudClcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JldmlzZWQgY3JhZGxlUm93Q291bnQnLGNyYWRsZVJvd2NvdW50KVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjcmFkbGVSb3djb3VudCwgXG4gICAgICAgICAgICB2aWV3cG9ydFJvd2NvdW50LCBcbiAgICAgICAgICAgIGxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJ1bndheVJvd2NvdW50LFxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICBnYXAsIFxuICAgICAgICAvLyBwYWRkaW5nLFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsIFxuICAgICAgICB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIHZpZXdwb3J0d2lkdGgsXG5cbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGJhc2Vyb3dibGFua3MsIFxuICAgICAgICBlbmRyb3dibGFua3MsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIGxheW91dCxcbiAgICBdKVxuXG4gICAgY29uc3QgcmFuZ2Vyb3dzaGlmdCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihsb3dpbmRleC9jcm9zc2NvdW50KVxuICAgIH0sW2Nyb3NzY291bnQsbG93aW5kZXhdKVxuXG4gICAgY29uc3QgdmlydHVhbExpc3RQcm9wcyA9IFxuICAgICAgICB7XG5cbiAgICAgICAgICAgIC4uLnZpcnR1YWxMaXN0U3BlY3MsXG4gICAgICAgICAgICBiYXNlcm93YmxhbmtzLFxuICAgICAgICAgICAgZW5kcm93YmxhbmtzLFxuICAgICAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgICAgIHJvd2NvdW50Omxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIHJvd3NoaWZ0OnJhbmdlcm93c2hpZnQsXG5cbiAgICAgICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3ZpcnR1YWxMaXN0UHJvcHMnLHZpcnR1YWxMaXN0UHJvcHMpXG5cbiAgICBjb25zdCBjcmFkbGVDb250ZW50UHJvcHNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBjcmFkbGVSb3djb3VudCxcbiAgICAgICAgdmlld3BvcnRSb3djb3VudCxcbiAgICAgICAgcnVud2F5Um93Y291bnQsXG4gICAgICAgIFNPTDpmYWxzZSwgLy8gc3RhcnQgb2YgbGlzdFxuICAgICAgICBFT0w6ZmFsc2UsIC8vIGVuZCBvZiBsaXN0XG4gICAgICAgIGxvd2luZGV4Om51bGwsXG4gICAgICAgIGhpZ2hpbmRleDpudWxsLFxuICAgICAgICBzaXplOjAsXG4gICAgIH0pXG5cbiAgICAgY29uc3QgY3JhZGxlQ29udGVudFByb3BzID0gY3JhZGxlQ29udGVudFByb3BzUmVmLmN1cnJlbnRcbiAgICAgY3JhZGxlQ29udGVudFByb3BzLmNyYWRsZVJvd2NvdW50ID0gY3JhZGxlUm93Y291bnRcbiAgICAgY3JhZGxlQ29udGVudFByb3BzLnZpZXdwb3J0Um93Y291bnQgPSB2aWV3cG9ydFJvd2NvdW50XG4gICAgIGNyYWRsZUNvbnRlbnRQcm9wcy5ydW53YXlSb3djb3VudCA9IHJ1bndheVJvd2NvdW50XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxsYmFja3MgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGhvc3QgY2FsbGJhY2tzLCB1cGFja2VkIGJ5IHNlcnZpY2VIYW5kbGVyXG4gICAgY29uc3QgZXh0ZXJuYWxDYWxsYmFja3NSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucmVmZXJlbmNlSW5kZXhDYWxsYmFjayxcbiAgICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayxcbiAgICAgICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrOnVzZXJDYWxsYmFja3M/LnJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrLFxuICAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2s6dXNlckNhbGxiYWNrcz8ucHJlbG9hZEluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2s6dXNlckNhbGxiYWNrcz8uZGVsZXRlTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFjazp1c2VyQ2FsbGJhY2tzPy5jaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLFxuICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrOnVzZXJDYWxsYmFja3M/Lml0ZW1FeGNlcHRpb25DYWxsYmFjayxcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tWyBidW5kbGUgcHJvcGVydGllcyBmb3IgaGFuZGxlcnMgXS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGJ1bmRsZSBhbGwgY3JhZGxlIHByb3BzIHRvIHBhc3MgdG8gaGFuZGxlcnMgLSB1bHRpbWF0ZWx5IGNyYWRsZVBhcmFtZXRlcnNSZWZcblxuICAgIGNvbnN0IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYgPSB1c2VSZWYobnVsbCkgLy8gYWNjZXNzIGJ5IGNsb3N1cmVzIGFuZCBzdXBwb3J0IGNhbGxiYWNrc1xuICAgIC8vIHVwIHRvIGRhdGUgdmFsdWVzXG4gICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAvLyBncmlkU3BlY3NcbiAgICAgICAgb3JpZW50YXRpb24sIGdhcCwgcGFkZGluZywgbGF5b3V0LFxuICAgICAgICBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgLy8gLi4ucmVzdFxuICAgICAgICBjYWNoZSwgY2FjaGVNYXgsXG4gICAgICAgIHN0YXJ0aW5nSW5kZXgsIFxuICAgICAgICBydW53YXlTaXplLFxuICAgICAgICBnZXRJdGVtLCBcbiAgICAgICAgcGxhY2Vob2xkZXIsIHBsYWNlaG9sZGVyTWVzc2FnZXMsIHVzZVBsYWNlaG9sZGVyLFxuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgLy8gb2JqZWN0c1xuICAgICAgICB1c2VyQ2FsbGJhY2tzLCBzdHlsZXMsIGNhY2hlQVBJLFxuICAgICAgICAvLyBjb250cm9sIHZhbHVlc1xuICAgICAgICBPTkFGVEVSU0NST0xMX1RJTUVPVVQsIE1BWF9DQUNIRV9PVkVSX1JVTiwgXG4gICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcblxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbGVyUHJvcGVydGllc1JlZiA9IHVzZVJlZihudWxsKVxuICAgIC8vIHBhc3NlZCB0byBjZWxsRnJhbWUgY29udGVudCAodXNlciBjb250ZW50KSBpZiByZXF1ZXN0ZWRcbiAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb3JpZW50YXRpb24sIGdhcCwgcGFkZGluZywgbGF5b3V0LFxuICAgICAgICBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxNaW5IZWlnaHQsIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgdmlydHVhbExpc3RQcm9wcyxcbiAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLFxuICAgICAgICBydW53YXlSb3djb3VudCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGNhY2hlTWF4LFxuICAgICAgICBzdGFydGluZ0luZGV4LFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzY3JvbGxlcklELFxuICAgIH1cblxuICAgIC8vIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBzaGFyZSB3aXRoIGhhbmRsZXJzXG4gICAgY29uc3QgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgPSB7XG5cbiAgICAgICAgLy8gdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgLy8gY3Jvc3Njb3VudCxcbiAgICAgICAgLy8gY3JhZGxlUm93Y291bnQsXG4gICAgICAgIC8vIHZpZXdwb3J0Um93Y291bnQsXG4gICAgICAgIC8vIGxpc3RSb3djb3VudCxcbiAgICAgICAgdmlydHVhbExpc3RQcm9wcyxcbiAgICAgICAgc2V0VmlydHVhbExpc3RTcGVjcyxcbiAgICAgICAgLy8gcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgY3JhZGxlQ29udGVudFByb3BzOmNyYWRsZUNvbnRlbnRQcm9wc1JlZi5jdXJyZW50LFxuICAgICAgICBcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG1haW50YWluZWQgZWxzZXdoZXJlXG4gICAgICAgIGlzTW91bnRlZFJlZixcbiAgICAgICAgY3JhZGxlRWxlbWVudHNSZWYsXG4gICAgICAgIGlzQ2FjaGVkUmVmLFxuICAgICAgICB3YXNDYWNoZWRSZWYsXG4gICAgICAgIHRyaWdnZXJIaXN0b3J5UmVmLFxuXG4gICAgICAgIC8vIGZvciBzdGF0ZUhhbmRsZXJcbiAgICAgICAgY3JhZGxlU3RhdGVSZWYsXG4gICAgICAgIHNldENyYWRsZVN0YXRlLFxuICAgIH1cblxuICAgIC8vIHBsYWNlaG9sZGVyIGluIGNyYWRsZVBhcmFtZXRlcnMgdG8gbWFrZSBhdmFpbGFibGUgaW5kaXZpZHVhbCBoYW5kbGVyc1xuICAgIGNvbnN0IGhhbmRsZXJzUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBjcmFkbGUgcGFyYW1ldGVycyBNQVNURVIgQlVORExFXG4gICAgY29uc3QgY3JhZGxlUGFyYW1ldGVycyA9IHtcbiAgICAgICAgaGFuZGxlcnNSZWYsXG4gICAgICAgIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYsIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiwgXG4gICAgICAgIGV4dGVybmFsQ2FsbGJhY2tzUmVmLFxuICAgIH1cblxuICAgIGNvbnN0IGNyYWRsZVBhcmFtZXRlcnNSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjcmFkbGVQYXJhbWV0ZXJzUmVmLmN1cnJlbnQgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBvbmdvaW5nIHNvdXJjZSBvZiBoYW5kbGVycyAtIG5vdGUgYWxsIEhhbmRsZXJzIGFyZSBnaXZlbiBhbGwgcGFyYW1ldGVycyAoY3JhZGxlUGFyYW1ldGVycylcbiAgICBpZiAoIWhhbmRsZXJzUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICBoYW5kbGVyc1JlZi5jdXJyZW50ID0gZ2V0Q3JhZGxlSGFuZGxlcnMoY3JhZGxlUGFyYW1ldGVycylcblxuICAgIH1cblxuICAgIC8vIG1ha2UgaGFuZGxlcnMgZGlyZWN0bHkgYXZhaWxhYmxlIHRvIGNyYWRsZSBjb2RlIGJlbG93XG4gICAgY29uc3QgeyAvLyBjYWNoZUFQSSBhbHJlYWR5IGF2YWlsYWJsZVxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLFxuICAgICAgICBzY3JvbGxIYW5kbGVyLFxuICAgICAgICAvLyBzdGF0ZUhhbmRsZXIsIC8vIG5vdCB1c2VkXG4gICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgc3R5bGVzSGFuZGxlcixcbiAgICB9ID0gaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1bIElOVEVSQ0VQVCBDQUNISU5HIFNUQVRFIENIQU5HRSBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKiAgICBcbiAgICBJbnRlcmNlcHQgY2hhbmdlIGluIGNhY2hpbmcgc3RhdHVzOlxuICAgIHdoZW4gYSBjb21wb25lbnQgaXMgY2FjaGVkIGluIGEgcG9ydGFsIChpbiB0aGUgUmVhY3QgdmlydHVhbCBET00pLCBpbmNsdWRpbmcgdGhlIHRyYW5zaXRpb24gb2YgXG4gICAgYmVpbmcgbW92ZWQgZnJvbSBvbmUgY2VsbEZyYW1lIHRvIGFub3RoZXIgd2hlbiBjcm9zc2luZyB0aGUgQ3JhZGxlIGF4aXMsIFxuICAgIHRoZSBzY3JvbGxQb3MgKHNjcm9sbExlZnQgb3Igc2Nyb2xsVG9wKSBpcyByZXNldCB0byAwICh6ZXJvKS4gV2hlbiB0aGUgc2Nyb2xsZXIgaXMgXG4gICAgbW92ZWQgdG8gYSBjZWxsRnJhbWUsIHRoaXMgY29kZSB0cmlnZ2VycyByZXN0b3JhdGlvbiB0aGUgc2Nyb2xsUG9zIChzZWUgY2FzZSAncGFyZW50aW5ndHJhbnNpdGlvbidcbiAgICBpbiB0aGUgc3RhdGUgbWFuYWdlbWVudCBzZWN0aW9uIGJlbG93KS5cblxuICAgIFRoaXMgc3VwcG9ydHMgSW5maW5pdGVHcmlkU2Nyb2xsZXIgY29tcG9uZW50cyB0byBiZSBjYWNoZWQgYXMgY29udGVudC5cblxuICAgIFRoZSByZXN0b3JlIHNjcm9sbFBvcyBhY3Rpb24gbXVzdCBiZSB0aGUgZmlyc3QgcHJpb3JpdHkgdG8gaGlkZSB0aGVzZSBzY3JvbGxQb3MgYWRqdXN0bWVudHNcbiAgICBmcm9tIHRoZSB1c2VyLlxuKi9cbiAgICBcbiAgICBjb25zdCByZXN0b3JlU2Nyb2xsUG9zID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG5cbiAgICAgICAgY29uc3QgYmxvY2tTY3JvbGxQb3MgPSBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgY29uc3QgYmxvY2tYU2Nyb2xsUG9zID0gY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFBvc1xuICAgICAgICBpZiAoYmxvY2tTY3JvbGxQb3MgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID0gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tYU2Nyb2xsUHJvcGVydHldID0gYmxvY2tYU2Nyb2xsUG9zXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGlzQ2FjaGVDaGFuZ2UgJiYgIWlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zKCkgICAgICAgIFxuXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIHN0YXRlIGZvciBlbnRlcmluZyBvciBsZWF2aW5nIGNhY2hlXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuIC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCAmJiAhd2FzQ2FjaGVkUmVmLmN1cnJlbnQpIHsgLy8gaW50byBjYWNoZVxuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2FjaGVkJylcblxuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhY2hlZFJlZi5jdXJyZW50ICYmIHdhc0NhY2hlZFJlZi5jdXJyZW50KSB7IC8vIG91dCBvZiBjYWNoZVxuXG4gICAgICAgICAgICB3YXNDYWNoZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChoYXNCZWVuUmVuZGVyZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaXJzdHJlbmRlcmZyb21jYWNoZScpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtpc0NhY2hlZFJlZi5jdXJyZW50LCB3YXNDYWNoZWRSZWYuY3VycmVudF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09WyBJTklUSUFMSVpBVElPTiBlZmZlY3RzIF09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWZmZWN0cyBhcmUgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xuXG4gICAgLy8gY2xlYXIgbW91bnRlZCBmbGFnIG9uIHVubW91bnRcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWVcbiAgICAgICAgLy8gdW5tb3VudFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vc2VuZCBjYWxsLWluIGZ1bmN0aW9ucyB0byBob3N0XG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKCF1c2VyQ2FsbGJhY2tzLmZ1bmN0aW9uc0NhbGxiYWNrKSByZXR1cm5cblxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIHNjcm9sbFRvSW5kZXgsIFxuICAgICAgICAgICAgcmVsb2FkLCBcbiAgICAgICAgICAgIHNldExpc3RzaXplLFxuICAgICAgICAgICAgY2xlYXJDYWNoZSwgXG5cbiAgICAgICAgICAgIGdldENhY2hlSW5kZXhNYXAsIFxuICAgICAgICAgICAgZ2V0Q2FjaGVJdGVtTWFwLFxuICAgICAgICAgICAgZ2V0Q3JhZGxlSW5kZXhNYXAsXG5cbiAgICAgICAgICAgIHJlbWFwSW5kZXhlcyxcbiAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlSW5kZXgsXG5cbiAgICAgICAgfSA9IHNlcnZpY2VIYW5kbGVyXG5cbiAgICAgICAgY29uc3QgZnVuY3Rpb25zID0ge1xuXG4gICAgICAgICAgICBzY3JvbGxUb0luZGV4LFxuICAgICAgICAgICAgcmVsb2FkLFxuICAgICAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgICAgICBjbGVhckNhY2hlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBnZXRDYWNoZUluZGV4TWFwLFxuICAgICAgICAgICAgZ2V0Q2FjaGVJdGVtTWFwLFxuICAgICAgICAgICAgZ2V0Q3JhZGxlSW5kZXhNYXAsXG4gICAgICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgICAgICAgICBtb3ZlSW5kZXgsXG4gICAgICAgICAgICBpbnNlcnRJbmRleCxcbiAgICAgICAgICAgIHJlbW92ZUluZGV4LFxuXG4gICAgICAgIH1cblxuICAgICAgICB1c2VyQ2FsbGJhY2tzLmZ1bmN0aW9uc0NhbGxiYWNrKGZ1bmN0aW9ucylcblxuICAgIH0sW10pXG5cbiAgICAvLyBpbml0aWFsaXplIHdpbmRvdyBzY3JvbGwgbGlzdGVuZXJzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIub25TY3JvbGwpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50ICYmIFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLHNjcm9sbEhhbmRsZXIub25TY3JvbGwpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vIGlPUyBTYWZhcmkgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZyAtIGl0IGlnbm9yZXMgYXNzaWdubWVudHMgdG8gc2Nyb2xsTGVmdC9zY3JvbGxUb3AgZHVyaW5nIHNjcm9sbGluZ1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghaXNTYWZhcmlJT1MoKSB8fCAobGF5b3V0ID09ICd1bmlmb3JtJykpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgdmlld3BvcnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5pT1NvblNjcm9sbClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQgJiYgXG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsc2Nyb2xsSGFuZGxlci5pT1NvblNjcm9sbClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gb2JzZXJ2ZXIgc3VwcG9ydFxuICAgIC8qXG4gICAgICAgIFRoZXJlIGFyZSB0d28gaW50ZXJlY3Rpb24gb2JzZXJ2ZXJzOiBvbmUgZm9yIHRoZSB0d28gY3JhZGxlIGdyaWRzLCBhbmQgYW5vdGhlciBmb3IgdHJpZ2dlcmxpbmVzOyBcbiAgICAgICAgICAgIGJvdGggYWdhaW5zdCB0aGUgdmlld3BvcnQuXG4gICAgKi8gICAgXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY3JhZGxlSW50ZXJzZWN0LFxuICAgICAgICAgICAgdHJpZ2dlcmxpbmVzSW50ZXJzZWN0LFxuICAgICAgICB9ID0gaW50ZXJydXB0SGFuZGxlclxuXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBvYnNlcnZlciBmb3IgY3JhZGxlIGJvZHlcbiAgICAgICAgLy8gdGhpcyBzZXRzIHVwIGFuIEludGVyc2VjdGlvbk9ic2VydmVyIG9mIHRoZSBjcmFkbGUgYWdhaW5zdCB0aGUgdmlld3BvcnQuIFdoZW4gdGhlXG4gICAgICAgIC8vIGNyYWRsZSBnb2VzIG91dCBvZiB0aGUgb2JzZXJ2ZXIgc2NvcGUsIHRoZSAncmVwb3NpdGlvbmluZ1JlbmRlcicgY3JhZGxlIHN0YXRlIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgY29uc3QgY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIgPSBjcmFkbGVJbnRlcnNlY3QuY3JlYXRlT2JzZXJ2ZXIoKVxuICAgICAgICBjcmFkbGVJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcblxuICAgICAgICAvLyB0cmlnZ2Vyb2JzZXJ2ZXIgdHJpZ2dlcnMgY3JhZGxlIGNvbnRlbnQgdXBkYXRlcyBcbiAgICAgICAgLy8gICAgIHdoZW4gdHJpZ2dlcmxpbmVzIHBhc3MgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIC8vIGRlZmVyIGNvbm5lY3RFbGVtZW50cyB1bnRpbCB0cmlnZ2VyY2VsbCB0cmlnZ2VybGluZXMgaGF2ZSBiZWVuIGFzc2lnbmVkXG4gICAgICAgIGNvbnN0IHRyaWdnZXJvYnNlcnZlciA9IHRyaWdnZXJsaW5lc0ludGVyc2VjdC5jcmVhdGVPYnNlcnZlcigpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgY3JhZGxlaW50ZXJzZWN0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB0cmlnZ2Vyb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PVsgUkVDT05GSUdVUkFUSU9OIGVmZmVjdHMgXT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBjaGFuZ2UgbGlzdHNpemUsIGNhY2hpbmcsIHJlc2l6ZSAoVUkgcmVzaXplIG9mIHRoZSB2aWV3cG9ydCksIHJlY29uZmlndXJlLCBvciBwaXZvdFxuXG4gICAgLy8gaW5lcm5hbCBjYWxsYmFjazogdGhlIG5ldyBsaXN0IHNpemUgd2lsbCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnJlbnQgbGlzdHNpemVcbiAgICAvLyBpbnZva2VkIGlmIGdldEl0ZW0gcmV0dXJucyBudWxsXG4gICAgY29uc3QgbnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSA9IHVzZUNhbGxiYWNrKChtYXhMaXN0c2l6ZSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0c2l6ZSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LnZpcnR1YWxMaXN0UHJvcHMuc2l6ZVxuXG4gICAgICAgIGlmIChtYXhMaXN0c2l6ZSA8IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrLCBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ2dldEl0ZW0gcmV0dXJuZWQgbnVsbCcsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci51cGRhdGVWaXJ0dWFsTGlzdFNwZWNzKG1heExpc3RzaXplKVxuICAgICAgICAgICAgY2FjaGVBUEkuY2hhbmdlQ2FjaGVMaXN0c2l6ZShtYXhMaXN0c2l6ZSwgXG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrKVxuXG4gICAgICAgIH1cbiAgICB9LFtdKVxuXG4gICAgLy8gY2FjaGluZyBjaGFuZ2VcbiAgICB1c2VFZmZlY3QoKCk9PiB7XG5cbiAgICAgICAgaWYgKGNhY2hlID09ICdwcmVsb2FkJykge1xuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnc3RhcnRwcmVsb2FkJylcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIHN3aXRjaCAoY2FjaGUpIHtcblxuICAgICAgICAgICAgY2FzZSAna2VlcGxvYWQnOiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlTGlzdENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcblxuICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVNYXggfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVBUEkucGFyZUNhY2hlVG9NYXgoY2FjaGVNYXgsIG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQVBJLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWNhY2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3JhZGxlJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnbWF0Y2ggY2FjaGUgdG8gY3JhZGxlJyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZUFQSS5tYXRjaENhY2hlVG9DcmFkbGUobW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVBUEkucmVuZGVyUG9ydGFsTGlzdHMoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWNhY2hpbmcnKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtjYWNoZSwgY2FjaGVNYXhdKVxuXG4gICAgLy8gdHJpZ2dlciB2aWV3cG9ydHJlc2l6aW5nIHJlc3BvbnNlIGJhc2VkIG9uIHZpZXdwb3J0IHN0YXRlXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgLy8gbW92ZW1lbnQgdG8gYW5kIGZyb20gY2FjaGUgaXMgaW5kZXBlbmRlbnQgb2YgdWkgdmlld3BvcnRyZXNpemluZ1xuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCB8fCB3YXNDYWNoZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZykgJiYgXG4gICAgICAgICAgICAgICAgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgIT0gJ3ZpZXdwb3J0cmVzaXppbmcnKSkge1xuXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG4gXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgndmlld3BvcnRyZXNpemluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbXBsZXRlIHZpZXdwb3J0cmVzaXppbmcgbW9kZVxuICAgICAgICBpZiAoIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5pc1Jlc2l6aW5nICYmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICd2aWV3cG9ydHJlc2l6aW5nJykpIHtcblxuICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJylcblxuICAgICAgICB9XG5cbiAgICB9LFtWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuaXNSZXNpemluZ10pXG5cbiAgICAvLyByZWNvbmZpZ3VyZSBmb3IgY2hhbmdlZCBzaXplIHBhcmFtZXRlcnNcbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpZiAoY3JhZGxlU3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWNvbmZpZ3VyZScpXG5cbiAgICB9LFtcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHJ1bndheVNpemUsXG4gICAgXSlcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZVJlZi5jdXJyZW50ID09ICdzZXR1cCcpIHJldHVyblxuXG4gICAgICAgIGlmIChpc0NhY2hlZFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBjb25zdCB7IHZpcnR1YWxMaXN0UHJvcHMsIGNyYWRsZUNvbnRlbnRQcm9wcyB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydFJvd2NvdW50LCBsb3dpbmRleDpsb3dDcmFkbGVJbmRleCwgaGlnaGluZGV4OmhpZ2hDcmFkbGVJbmRleCwgc2l6ZTpjcmFkbGVDb3VudCB9ID0gY3JhZGxlQ29udGVudFByb3BzXG4gICAgICAgIGNvbnN0IHsgaGlnaGluZGV4Omxpc3RoaWdocmFuZ2UgfSA9IHZpcnR1YWxMaXN0UHJvcHNcblxuICAgICAgICBjb25zdCB7IGNyb3NzY291bnQgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LnZpcnR1YWxMaXN0UHJvcHNcbiAgICAgICAgY29uc3QgeyBydW53YXlTaXplIH0gPSAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQgPSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG5cbiAgICAgICAgLy8gY29uc3QgaW5kZXhTcGFuID0gY29udGVudEhhbmRsZXIuaW5kZXhTcGFuXG4gICAgICAgIC8vIGNvbnN0IFtsb3dDcmFkbGVJbmRleCxoaWdoQ3JhZGxlSW5kZXhdID0gaW5kZXhTcGFuXG5cbiAgICAgICAgbGV0IG1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50XG4gICAgICAgIGxldCBjaGFuZ2VJc1dpdGhpbkNyYWRsZVxuXG4gICAgICAgIC8vIGlmIChpbmRleFNwYW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgaWYgKGNyYWRsZUNvdW50ID09IDApIHtcblxuICAgICAgICAgICAgbWVhc3VyZWRDcmFkbGVJdGVtQ291bnQgPSAwXG4gICAgICAgICAgICBjaGFuZ2VJc1dpdGhpbkNyYWRsZSA9IHRydWVcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBtZWFzdXJlZENyYWRsZUl0ZW1Db3VudCA9IGhpZ2hDcmFkbGVJbmRleCAtIGxvd0NyYWRsZUluZGV4ICsgMVxuICAgICAgICAgICAgY2hhbmdlSXNXaXRoaW5DcmFkbGUgPSAoaGlnaENyYWRsZUluZGV4ID49IGxpc3RoaWdocmFuZ2UpIC8vIChjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC52aXJ0dWFsTGlzdFByb3BzLmhpZ2hyYW5nZSkpXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWVhc3VyZWRDcmFkbGVJdGVtQ291bnQgPCBjYWxjdWxhdGVkQ3JhZGxlSXRlbWNvdW50KSB8fCAvLyBzdWItdmlld3BvcnQgdmlzaWJsZSBsaXN0Y291bnRcbiAgICAgICAgICAgIGNoYW5nZUlzV2l0aGluQ3JhZGxlKSB7IC8vIGNoYW5nZSBpcyBub3QgYmV5b25kIGNyYWRsZVxuXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnBhdXNlSW50ZXJydXB0cygpXG5cbiAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWNvbmZpZ3VyZWZvcmxpc3RzaXplJylcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgIH1cblxuICAgIH0sW1xuICAgICAgICBsaXN0c2l6ZSxcbiAgICBdKVxuXG4gICAgLy8gYSBuZXcgZ2V0SXRlbSBmdW5jdGlvbiBpbXBsaWVzIHRoZSBuZWVkIHRvIHJlbG9hZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykgcmV0dXJuXG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWxvYWQnKVxuXG4gICAgfSxbZ2V0SXRlbV0pXG5cbiAgICAvLyBwaXZvdCB0cmlnZ2VyZWQgb24gY2hhbmdlIG9mIG9yaWVudGF0aW9uXG4gICAgdXNlRWZmZWN0KCgpPT4ge1xuXG4gICAgICAgIGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHkgPSBcbiAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpP1xuICAgICAgICAgICAgICAgIFwic2Nyb2xsVG9wXCI6XG4gICAgICAgICAgICAgICAgXCJzY3JvbGxMZWZ0XCJcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQcm9wZXJ0eSA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiKT9cbiAgICAgICAgICAgICAgICBcInNjcm9sbFRvcFwiOlxuICAgICAgICAgICAgICAgIFwic2Nyb2xsTGVmdFwiXG5cbiAgICAgICAgaWYgKGNyYWRsZVN0YXRlUmVmLmN1cnJlbnQgPT0gJ3NldHVwJykge1xuICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5jcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1hTY3JvbGxQb3MgPSAwXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGdhcCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlUG9zaXRpb25EYXRhIH0gPSBsYXlvdXRIYW5kbGVyXG4gICAgICAgIFxuICAgICAgICBpZiAobGF5b3V0ID09ICd1bmlmb3JtJykge1xuXG4gICAgICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGdhcCxcbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgLy8gZ2V0IHByZXZpb3VzIHJhdGlvXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0NlbGxQaXhlbExlbmd0aCA9IFxuICAgICAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodClcbiAgICAgICAgICAgICAgICArIGdhcFxuXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0F4aXNPZmZzZXQgPSBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c3JhdGlvID0gcHJldmlvdXNBeGlzT2Zmc2V0L3ByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoXG5cbiAgICAgICAgICAgIGNvbnN0IHBpdm90Q2VsbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgY2VsbEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgICAgIGNvbnN0IHBpdm90QXhpc09mZnNldCA9IHByZXZpb3VzcmF0aW8gKiBwaXZvdENlbGxQaXhlbExlbmd0aFxuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBNYXRoLnJvdW5kKHBpdm90QXhpc09mZnNldClcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBnYXBcblxuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJydXB0SGFuZGxlci5wYXVzZUludGVycnVwdHMoKVxuXG4gICAgICAgIHNldENyYWRsZVN0YXRlKCdwaXZvdCcpXG5cbiAgICB9LFtvcmllbnRhdGlvbl0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUWUxFUyBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBzdHlsZXMgZm9yIHRoZSBzaXggc2NhZmZvbGQgY29tcG9uZW50c1xuICAgIGNvbnN0IFtcbiAgICAgICAgY3JhZGxlSGVhZFN0eWxlLFxuICAgICAgICBjcmFkbGVUYWlsU3R5bGUsXG4gICAgICAgIGNyYWRsZUF4aXNTdHlsZSxcbiAgICAgICAgY3JhZGxlRGl2aWRlclN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlLFxuICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlLFxuICAgIF0gPSB1c2VNZW1vKCgpPT4ge1xuXG4gICAgICAgIHJldHVybiBzdHlsZXNIYW5kbGVyLmdldENyYWRsZVN0eWxlcyh7XG5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgdmlld3BvcnRoZWlnaHQsIFxuICAgICAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgdXNlcnN0eWxlczpzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VybGluZU9mZnNldCxcbiAgICAgICAgICAgIGxheW91dCxcblxuICAgICAgICB9KVxuXG4gICAgfSxbXG5cbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgY2VsbE1pbkhlaWdodCxcbiAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHZpZXdwb3J0aGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydHdpZHRoLFxuICAgICAgICBjcm9zc2NvdW50LFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICAgIF0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFNUQVRFIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIHN0YXRlIGVuZ2luZSAoYWJvdXQgMzAgc3RhdGVzKSwgdXNpbmcgbmFtZWQgc3RhdGVzXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGZvciBzdXBwcmVzc2luZyBmbGFzaGVzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVsgcHJlY3Vyc29ycyB0byBzZXRDcmFkbGVDb250ZW50IF0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhbGwgd29ya2Zsb3cgcmVsYXRlZCwgYnV0XG4gICAgICAgICAgICAvLyByZXNpemUgY291bGQgYmUgYXN5bmNocm9ub3VzIHdoZW4gcm90YXRpbmcgcGhvbmUgZHVyaW5nIHNjcm9sbCBpbnRlcnRpYVxuXG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHsgLy8gY3ljbGUgdG8gYWxsb3cgZm9yIHJlZiBhc3NpZ25tZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudC5jYWNoZSAhPSAncHJlbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjYWNoZWQnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpcnN0cmVuZGVyJykgLy8gbG9hZCBncmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydHJlc2l6aW5nJzoge1xuXG4gICAgICAgICAgICAgICAgLy8gbm8tb3AsIHdhaXQgZm9yIHJlc2l6aW5nIHRvIGVuZFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0cHJlbG9hZCc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJbmRleExpc3QgPSBjb250ZW50SGFuZGxlci5nZXRNb2RlbEluZGV4TGlzdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVMaXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUFQSS5wYXJlQ2FjaGVUb01heChjYWNoZU1heCwgbW9kZWxJbmRleExpc3QsIGRMaXN0Q2FsbGJhY2spKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQVBJLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hwcmVsb2FkJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2FjaGVkJylcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWNoZUFQSS5wcmVsb2FkKGZpbmFsQ2FsbGJhY2ssIG51bGxJdGVtU2V0TWF4TGlzdHNpemUpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjYWNoZWQnOiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXdhc0NhY2hlZFJlZi5jdXJyZW50ICYmICFpc0NhY2hlZFJlZi5jdXJyZW50KXtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmVlblJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlcmVuZGVyZnJvbWNhY2hlJylcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmlyc3RyZW5kZXJmcm9tY2FjaGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB3YWl0IGZvciByZXBhcmVudGluZ1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc3RhcnRyZXBvc2l0aW9uJzoge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSBpbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgICAgICAgICBzaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgY3JhZGxlIGludGVyc2VjdGlvbiBpbnRlcnJ1cHRzXG4gICAgICAgICAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gZmFsc2UgLy8gYmVjYXVzZSBub3cgdW5kZXJ3YXlcblxuICAgICAgICAgICAgICAgIHNjcm9sbGVySUQgPT0gMSAmJiBjb25zb2xlLmxvZygnQ3JhZGxlOiBzdGFydHJlcG9zaXRpb24sIHNjcm9sbEhhbmRsZXIuaXNTY3JvbGxpbmcnLCBzY3JvbGxIYW5kbGVyLmlzU2Nyb2xsaW5nKVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEhhbmRsZXIuaXNTY3JvbGxpbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ1JlbmRlcicpIC8vIHRvZ2dsZXMgd2l0aCByZXBvc2l0aW9uaW5nQ29udGludWF0aW9uXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdmaW5pc2hyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVsgc2V0Q3JhZGxlQ29udGVudCBdLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdGhlIGZvbGxvd2luZyAxMiBjcmFkbGUgc3RhdGVzIGFsbCByZXNvbHZlIHdpdGhcbiAgICAgICAgICAgICAgICBhIGNoYWluIHN0YXJ0aW5nIHdpdGggc2V0Q3JhZGxlQ29udGVudCwgXG4gICAgICAgICAgICAgICAgY29udGludWluZyB3aXRoICdwcmVwYXJlcmVuZGVyJywgYW5kIGVuZGluZyB3aXRoXG4gICAgICAgICAgICAgICAgJ3Jlc3RvcmVpbnRlcnJ1cHRzJywgd2l0aCBhIGRldG91ciBmb3IgdmFyaWFibGUgbGF5b3V0IFxuICAgICAgICAgICAgICAgIHRvIHJlY29uZmlndXJlIHRoZSBzY3JvbGxibG9ja1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcmVuZGVyZnJvbWNhY2hlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njcm9sbHRvJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5nZWNhY2hpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNocHJlbG9hZCc6XG4gICAgICAgICAgICBjYXNlICdmaW5pc2hyZXBvc2l0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJzpcbiAgICAgICAgICAgIGNhc2UgJ3Bpdm90JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY29uZmlndXJlZm9ybGlzdHNpemUnOlxuICAgICAgICAgICAgY2FzZSAncmVsb2FkJzoge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuIC8vIHBvc3NpYmxlIGFzeW5jIGxhdGVuY3kgd2l0aCBuZXN0ZWQgc2Nyb2xsZXJzXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnY2FjaGVkJylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gY29udGVudEhhbmRsZXIuY29udGVudFxuXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBbXVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScpIHsgLy8gcmVzdG9yZSBiYXNlIGNvbmZpZyB0byBzY3JvbGxibG9ja1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZG9uZSBmb3IgcmVwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAoY3JhZGxlU3RhdGUgIT0gJ2ZpbmlzaHJlcG9zaXRpb24nKSAmJiBsYXlvdXRIYW5kbGVyLnJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcoKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdyZWxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQVBJLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAnZmluaXNocmVwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGFuZGxlci5jYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhKCdvblNjcm9sbCcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdHNpemUgPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC52aXJ0dWFsTGlzdFByb3BzLnNpemVcbiAgICAgICAgICAgICAgICAvLyBzZXQgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChsaXN0c2l6ZSkgY29udGVudEhhbmRsZXIuc2V0Q3JhZGxlQ29udGVudCggY3JhZGxlU3RhdGUgKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlICE9ICdmaW5pc2hwcmVsb2FkJykge1xuXG4gICAgICAgICAgICAgICAgICAgIGhhc0JlZW5SZW5kZXJlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbml6ZSBjYWNoZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUgPT0gJ2NyYWRsZScpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRMaXN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2soJ21hdGNoIGNhY2hlIHRvIGNyYWRsZScsZGVsZXRlTGlzdClcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVBUEkubWF0Y2hDYWNoZVRvQ3JhZGxlKG1vZGVsSW5kZXhMaXN0LCBkTGlzdENhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUFQSS5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGN5Y2xlIGZvciBwcmVwYXJlcmVuZGVyXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZpcnR1YWwgRE9NXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVyZW5kZXInKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVyZW5kZXInOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RFbGVtZW50cyB3YXMgZGVsYXllZCBmb3IgYSBjeWNsZSB0byByZW5kZXIgdHJpZ2dlcmNlbGwgdHJpZ2dlcmxpbmVzXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci50cmlnZ2VybGluZXNJbnRlcnNlY3QuY29ubmVjdEVsZW1lbnRzKClcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLmNyYWRsZUludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3Jlc3RvcmVpbnRlcnJ1cHRzJykgLy8gdG8gcmVzdG9yZSBpbnRlcnJ1cHRzXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZXN0b3JlaW50ZXJydXB0cyc6IHsgLy8gbm9ybWFsaXplXG5cbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnJlc3RvcmVJbnRlcnJ1cHRzKClcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICBicmVhayBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBmb2xsb3d1cCBmcm9tIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gc2Nyb2xsIGVmZmVjdHNcblxuICAgICAgICAgICAgLy8gcmVuZGVydXBkYXRlZGNvbnRlbnQgaXMgY2FsbGVkIGZyb20gdXBkYXRlQ3JhZGxlQ29udGVudC4gXG4gICAgICAgICAgICAvLyBpdCBpcyByZXF1aXJlZCB0byBpbnRlZ3JhdGUgY2hhbmdlZCBET00gY29uZmlndXJhdGlvbnMgYmVmb3JlICdyZWFkeScgaXMgZGlzcGxheWVkXG4gICAgICAgICAgICBjYXNlICdyZW5kZXJ1cGRhdGVkY29udGVudCc6IHsgLy8gY3ljbGUgZm9yIERPTSB1cGRhdGVcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnVwZGF0ZUNyYWRsZUNvbnRlbnQoKVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2ZpbmlzaHVwZGF0ZWRjb250ZW50JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNodXBkYXRlZGNvbnRlbnQnOiB7IC8vIGN5Y2xlIGZvciBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbml6ZSBjYWNoZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09ICdrZWVwbG9hZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5ndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZygpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGxheW91dCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAndW5pZm9ybScpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5jb25uZWN0RWxlbWVudHMoKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRDcmFkbGVTdGF0ZSgncmVjb25uZWN0dXBkYXRlZGNvbnRlbnQnKVxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gJ3ZhcmlhYmxlJyBjb250ZW50IHJlcXVpcmluZyByZWNvbmZpZ3VyYXRpb25cblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVmcmVzaERPTXVwZGF0ZWZvcnZhcmlhYmlsaXR5JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgYWRqdXN0IHNjcm9sbGJsb2NrIGZvciBzZXQgdmFyaWFibGUgY29udGVudCBdLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgY2FzZSAncmVmcmVzaERPTXNldGZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3ByZXBhcmVzZXRmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXBhcmVzZXRmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBnaXZlIHRpbWUgZm9yIERPTSB0byBwcm9kdWNlIGxheW91dFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5hZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5KCdzZXRjcmFkbGUnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNoc2V0Zm9ydmFyaWFiaWxpdHknKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIFZBUklBQkxFX01FQVNVUkVNRU5UU19USU1FT1VUKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluaXNoc2V0Zm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncHJlcGFyZXJlbmRlcicpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBhZGp1c3Qgc2Nyb2xsYmxvY2sgZm9yIHVwZGF0ZSB2YXJpYWJsZSBjb250ZW50IF0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBjYXNlICdyZWZyZXNoRE9NdXBkYXRlZm9ydmFyaWFiaWxpdHknOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYSBjeWNsZSB0byBhbGxvdyBmb3IgRE9NIHN5bmNocm9uaXppb24gd2l0aCBncmlkIGNoYW5nZXNcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdhZGp1c3R1cGRhdGVmb3J2YXJpYWJpbGl0eScpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkanVzdHVwZGF0ZWZvcnZhcmlhYmlsaXR5Jzoge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+IHsgLy8gYWxsb3cgbW9yZSBET00gdXBkYXRlXG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhhbmRsZXIuYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eSgndXBkYXRlY3JhZGxlJylcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgnZmluaXNodXBkYXRlZm9ydmFyaWFiaWxpdHknKVxuXG4gICAgICAgICAgICAgICAgfSwwKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5pc2h1cGRhdGVmb3J2YXJpYWJpbGl0eSc6IHtcblxuICAgICAgICAgICAgICAgIC8vIHJlLWFjdGl2YXRlIHRyaWdnZXJzOyB0cmlnZ2VybGluZXMgd2lsbCBoYXZlIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgdHJpZ2dlckNlbGwgYnkgbm93LlxuICAgICAgICAgICAgICAgIGludGVycnVwdEhhbmRsZXIudHJpZ2dlcmxpbmVzSW50ZXJzZWN0LmNvbm5lY3RFbGVtZW50cygpXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlci5zaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ3JlYWR5JylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLVsgdXNlciByZXF1ZXN0cyBdLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBjYXNlICdjaGFubmVsY3JhZGxlcmVzZXRhZnRlcmluc2VydHJlbW92ZSc6IHtcblxuICAgICAgICAgICAgICAgIGNhY2hlQVBJLmFwcGx5UG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0KClcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdjaGFuZ2VsaXN0c2l6ZWFmdGVyaW5zZXJ0cmVtb3ZlJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHZhcmlvdXMgaG9zdCBzZXJ2aWNlIHJlcXVlc3RzOyBzeW5jcyBjcmFkbGUgY29udGVudCB3aXRoIGNhY2hlIGNoYW5nZXNcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5aW5zZXJ0cmVtb3ZlY2hhbmdlcyc6XG4gICAgICAgICAgICBjYXNlICdhcHBseXJlbWFwY2hhbmdlcyc6XG4gICAgICAgICAgICBjYXNlICdhcHBseW1vdmVjaGFuZ2VzJzoge1xuXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgY2FjaGVBUEkuYXBwbHlQb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QoKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNyYWRsZVN0YXRlID09ICdhcHBseWluc2VydHJlbW92ZWNoYW5nZXMnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3JhZGxlU3RhdGUoJ2NoYW5nZWxpc3RzaXplYWZ0ZXJpbnNlcnRyZW1vdmUnKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY2hhbmdlbGlzdHNpemVhZnRlcmluc2VydHJlbW92ZSc6IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld2xpc3RzaXplID0gc2VydmljZUhhbmRsZXIubmV3bGlzdHNpemVcbiAgICAgICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5uZXdsaXN0c2l6ZSA9IG51bGxcblxuICAgICAgICAgICAgICAgIHNldENyYWRsZVN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgICAgICAgICAvLyBzZXJ2aWNlIGhhbmRsZXIgY2FsbGVkIGJlY2F1c2UgdGhpcyBpcyBhIGZvbGxvd29uIG9mIGEgdXNlciBpbnRlcnZlbnRpb25cbiAgICAgICAgICAgICAgICBzZXJ2aWNlSGFuZGxlci5zZXRMaXN0c2l6ZShuZXdsaXN0c2l6ZSlcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2NsZWFyY2FjaGUnOiB7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50SGFuZGxlci5jbGVhckNyYWRsZSgpXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbERpc3BsYXlDb21wb25lbnRzID0gW11cbiAgICAgICAgICAgICAgICBjYWNoZUFQSS5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVhZHknKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyBzdGFuZGFyZCByZW5kZXJpbmcgc3RhdGVzICgzIHN0YXRlcylcbiAgICB1c2VFZmZlY3QoKCk9PiB7IFxuXG4gICAgICAgIHN3aXRjaCAoY3JhZGxlU3RhdGUpIHtcblxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbmluZ1JlbmRlciBhbmQgcmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbiBhcmUgdG9nZ2xlZCB0byBnZW5lcmF0ZSBjb250aW51b3VzIFxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbmluZyByZW5kZXJzXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nUmVuZGVyJzogLy8gbm8tb3BcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJzogLy8gc2V0IGZyb20gb25TY3JvbGxcbiAgICAgICAgICAgICAgICBzZXRDcmFkbGVTdGF0ZSgncmVwb3NpdGlvbmluZ1JlbmRlcicpXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAncmVhZHknOiAvLyBuby1vcFxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICB9XG5cbiAgICB9LFtjcmFkbGVTdGF0ZV0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgUkVOREVSIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGNvbnN0IHNjcm9sbEF4aXNSZWZlcmVuY2VQb3NpdGlvbiA9IGxheW91dEhhbmRsZXIuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvblxuICAgIGNvbnN0IHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCA9IHNjcm9sbEF4aXNSZWZlcmVuY2VQb3NpdGlvbiArIGxvd2luZGV4XG4gICAgY29uc3Qgc2Nyb2xsSW5kZXhSZWYgPSB1c2VSZWYoc2Nyb2xsQXhpc1JlZmVyZW5jZVBvc2l0aW9uKVxuICAgIGNvbnN0IHNjcm9sbFRyYWNrZXJBcmdzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlcicsJ2ZpbmlzaHJlcG9zaXRpb24nXS5pbmNsdWRlcyhjcmFkbGVTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbEF4aXNSZWZlcmVuY2VQb3NpdGlvbiAhPSBzY3JvbGxJbmRleFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzY3JvbGxJbmRleFJlZi5jdXJyZW50ID0gc2Nyb2xsQXhpc1JlZmVyZW5jZVBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB7IHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrKHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghdXNlU2Nyb2xsVHJhY2tlcikgcmV0dXJuIG51bGxcbiAgICAgICAgY29uc3QgdHJhY2tlcmFyZ3MgPSB7XG4gICAgICAgICAgICB0b3A6dmlld3BvcnREaW1lbnNpb25zLnRvcCArIDMsXG4gICAgICAgICAgICBsZWZ0OnZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgMyxcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgIHNjcm9sbEF4aXNSZWZlcmVuY2VQb3NpdGlvbixcbiAgICAgICAgICAgIGxpc3RzaXplLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFja2VyYXJnc1xuICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGNyYWRsZVN0YXRlLCBcbiAgICAgICAgICAgIHZpZXdwb3J0RGltZW5zaW9ucywgXG4gICAgICAgICAgICBzY3JvbGxBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBzY3JvbGxBeGlzUmVmZXJlbmNlUG9zaXRpb24sIFxuICAgICAgICAgICAgbGlzdHNpemUsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyLFxuICAgICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgY3JhZGxlQ29udGVudCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnRcblxuICAgIGNvbnN0IHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVzUmVmID0gdXNlUmVmKG51bGwpXG4gICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYuY3VycmVudCA9IHVzZU1lbW8oKCk9PntcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleSA9ICdoZWFkJ1xuICAgICAgICAgICAgICAgIGRhdGEtdHlwZSA9ICdoZWFkdHJpZ2dlcidcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlfVxuICAgICAgICAgICAgICAgIHJlZiA9IHt0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZEVsZW1lbnRSZWZ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5ID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWx0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmID0ge3RyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBdXG5cbiAgICB9LFtcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxTdHlsZVxuICAgIF0pXG5cbiAgICBjb25zdCBjb250ZXh0dmFsdWVSZWYgPSB1c2VSZWYoe1xuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBjYWNoZUFQSSwgXG4gICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUsXG4gICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjazpzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3MuaXRlbUV4Y2VwdGlvbkNhbGxiYWNrLFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYsXG4gICAgfSlcblxuXG4gICAgLy8gZGlzcGxheSB0aGUgY3JhZGxlIGNvbXBvbmVudHMsIHRoZSBTY3JvbGxUcmFja2VyLCBvciBudWxsXG4gICAgcmV0dXJuIDxDcmFkbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBjb250ZXh0dmFsdWVSZWYuY3VycmVudCB9PlxuXG4gICAgICAgIHsoWydyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJywncmVwb3NpdGlvbmluZ1JlbmRlciddLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSk/XG4gICAgICAgICAgICB1c2VTY3JvbGxUcmFja2VyPzxTY3JvbGxUcmFja2VyIFxuICAgICAgICAgICAgICAgIHRvcCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MudG9wIH0gXG4gICAgICAgICAgICAgICAgbGVmdCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3MubGVmdCB9IFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgc2Nyb2xsVHJhY2tlckFyZ3Muc2Nyb2xsQXhpc1JlZmVyZW5jZVBvc2l0aW9uIH0gXG4gICAgICAgICAgICAgICAgaW5kZXggPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnNjcm9sbEF4aXNSZWZlcmVuY2VJbmRleCB9XG4gICAgICAgICAgICAgICAgbGlzdHNpemUgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLmxpc3RzaXplIH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHNjcm9sbFRyYWNrZXJBcmdzLnN0eWxlcyB9XG4gICAgICAgICAgICAvPjpudWxsOlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnY3JhZGxlLWF4aXMnXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZUF4aXNTdHlsZSB9IFxuICAgICAgICAgICAgICAgIHJlZiA9IHsgYXhpc0NyYWRsZUVsZW1lbnRSZWYgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgc2hvd0F4aXM/IC8vIGZvciBkZWJ1Z1xuICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ2NyYWRsZS1kaXZpZGVyJyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVEaXZpZGVyU3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhLXR5cGUgPSAnaGVhZCdcbiAgICAgICAgICAgICAgICAgICAgcmVmID0geyBoZWFkQ3JhZGxlRWxlbWVudFJlZiB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyBjcmFkbGVIZWFkU3R5bGUgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeyhjcmFkbGVTdGF0ZSAhPSAnc2V0dXAnKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZERpc3BsYXlDb21wb25lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10eXBlID0gJ3RhaWwnXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IHsgdGFpbENyYWRsZUVsZW1lbnRSZWYgfSBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7IGNyYWRsZVRhaWxTdHlsZSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB7KGNyYWRsZVN0YXRlICE9ICdzZXR1cCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG5cbiAgICA8L0NyYWRsZUNvbnRleHQuUHJvdmlkZXI+XG5cbn0gLy8gQ3JhZGxlXG5cbmV4cG9ydCBkZWZhdWx0IENyYWRsZVxuXG4vLyB1dGlsaXR5XG5cbmNvbnN0IGdldENyYWRsZUhhbmRsZXJzID0gKGNyYWRsZVBhcmFtZXRlcnMpID0+IHtcblxuICAgIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSBoYW5kbGVyID0+IG5ldyBoYW5kbGVyKGNyYWRsZVBhcmFtZXRlcnMpXG5cbiAgICBjb25zdCB7IGNhY2hlQVBJIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgY2FjaGVBUEkuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgY2FjaGVBUEksXG4gICAgICAgIGludGVycnVwdEhhbmRsZXI6Y3JlYXRlSGFuZGxlcihJbnRlcnJ1cHRIYW5kbGVyKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNjcm9sbEhhbmRsZXIpLFxuICAgICAgICBzdGF0ZUhhbmRsZXI6Y3JlYXRlSGFuZGxlcihTdGF0ZUhhbmRsZXIpLFxuICAgICAgICBjb250ZW50SGFuZGxlcjpjcmVhdGVIYW5kbGVyKENvbnRlbnRIYW5kbGVyKSxcbiAgICAgICAgbGF5b3V0SGFuZGxlcjpjcmVhdGVIYW5kbGVyKExheW91dEhhbmRsZXIpLFxuICAgICAgICBzZXJ2aWNlSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFNlcnZpY2VIYW5kbGVyKSxcbiAgICAgICAgc3R5bGVzSGFuZGxlcjpjcmVhdGVIYW5kbGVyKFN0eWxlc0hhbmRsZXIpLFxuXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsIlZpZXdwb3J0XzEiLCJTY3JvbGxUcmFja2VyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJzY3JvbGxoYW5kbGVyXzEiLCJzdGF0ZWhhbmRsZXJfMSIsImNvbnRlbnRoYW5kbGVyXzEiLCJsYXlvdXRoYW5kbGVyXzEiLCJpbnRlcnJ1cHRoYW5kbGVyXzEiLCJzZXJ2aWNlaGFuZGxlcl8xIiwic3R5bGVzaGFuZGxlcl8xIiwiSW5maW5pdGVHcmlkU2Nyb2xsZXJfMSIsImV4cG9ydHMiLCJDcmFkbGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkNyYWRsZSIsIl9yZWYiLCJncmlkU3BlY3MiLCJydW53YXlTaXplIiwidmlydHVhbExpc3RTcGVjcyIsInNldFZpcnR1YWxMaXN0U3BlY3MiLCJzdGFydGluZ0luZGV4IiwiZ2V0SXRlbSIsInBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJNZXNzYWdlcyIsInVzZXJDYWxsYmFja3MiLCJzdHlsZXMiLCJ0cmlnZ2VybGluZU9mZnNldCIsImNhY2hlIiwiY2FjaGVNYXgiLCJzY3JvbGxlcklEIiwiY2FjaGVBUEkiLCJ1c2VQbGFjZWhvbGRlciIsInVzZVNjcm9sbFRyYWNrZXIiLCJzaG93QXhpcyIsIk9OQUZURVJTQ1JPTExfVElNRU9VVCIsIklETEVDQUxMQkFDS19USU1FT1VUIiwiTUFYX0NBQ0hFX09WRVJfUlVOIiwiVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQiLCJzY3JvbGxlclByb3BlcnRpZXMiLCJ1c2VFZmZlY3QiLCJsaXN0c2l6ZSIsInNpemUiLCJvcmllbnRhdGlvbiIsImdhcCIsInBhZGRpbmciLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwiY2VsbE1pbkhlaWdodCIsImNlbGxNaW5XaWR0aCIsImxheW91dCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJ1c2VDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJpc01vdW50ZWRSZWYiLCJpc0NhY2hlZFJlZiIsIndhc0NhY2hlZFJlZiIsImhhc0JlZW5SZW5kZXJlZFJlZiIsInRyaWdnZXJIaXN0b3J5UmVmIiwicHJldmlvdXNSZWZlcmVuY2VOYW1lIiwiZ2V0Vmlld3BvcnREaW1lbnNpb25zIiwidmlld3BvcnRFbGVtZW50IiwiZWxlbWVudFJlZiIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJfZ2V0Vmlld3BvcnREaW1lbnNpb24iLCJ2aWV3cG9ydGhlaWdodCIsInZpZXdwb3J0d2lkdGgiLCJpc0luUG9ydGFsIiwiaXNDYWNoZUNoYW5nZSIsIl9yZWYyIiwidXNlU3RhdGUiLCJfcmVmMyIsImNyYWRsZVN0YXRlIiwic2V0Q3JhZGxlU3RhdGUiLCJjcmFkbGVTdGF0ZVJlZiIsImhlYWRDcmFkbGVFbGVtZW50UmVmIiwidGFpbENyYWRsZUVsZW1lbnRSZWYiLCJheGlzQ3JhZGxlRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkRWxlbWVudFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsRWxlbWVudFJlZiIsImNyYWRsZUVsZW1lbnRzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJheGlzUmVmIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZiIsImNyb3NzY291bnQiLCJ1c2VNZW1vIiwidmlld3BvcnRjcm9zc2xlbmd0aCIsInZpZXdwb3J0Y3Jvc3NsZW5ndGhmb3JjYWxjIiwiY2VsbGNyb3NzbGVuZ3RoIiwiY2VsbGNyb3NzbGVuZ3RoZm9yY2FsYyIsIk1hdGgiLCJtaW4iLCJmbG9vciIsImxvd2luZGV4IiwiaGlnaGluZGV4IiwiX3JlZjQiLCJlbmRhZGp1c3RtZW50IiwiYmFzZXJvd2JsYW5rcyIsImFicyIsImVuZHJvd2JsYW5rcyIsIl9yZWY1IiwiX3JlZjYiLCJ2aWV3cG9ydExlbmd0aCIsImJhc2VSb3dMZW5ndGgiLCJ2aWV3cG9ydFJvd2NvdW50IiwiY2VpbCIsImxpc3RSb3djb3VudCIsImNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCIsImNyYWRsZVJvd2NvdW50IiwicnVud2F5Um93Y291bnQiLCJkaWZmIiwibWF4IiwiaXRlbWNvdW50IiwiX3JlZjciLCJyYW5nZXJvd3NoaWZ0IiwidmlydHVhbExpc3RQcm9wcyIsImFzc2lnbiIsInJvd2NvdW50Iiwicm93c2hpZnQiLCJjcmFkbGVDb250ZW50UHJvcHNSZWYiLCJTT0wiLCJFT0wiLCJjcmFkbGVDb250ZW50UHJvcHMiLCJleHRlcm5hbENhbGxiYWNrc1JlZiIsInJlZmVyZW5jZUluZGV4Q2FsbGJhY2siLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2siLCJwcmVsb2FkSW5kZXhDYWxsYmFjayIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwic2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiaGFuZGxlcnNSZWYiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiY3JhZGxlUGFyYW1ldGVyc1JlZiIsImdldENyYWRsZUhhbmRsZXJzIiwiX2hhbmRsZXJzUmVmJGN1cnJlbnQiLCJpbnRlcnJ1cHRIYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsImNvbnRlbnRIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsInNlcnZpY2VIYW5kbGVyIiwic3R5bGVzSGFuZGxlciIsInJlc3RvcmVTY3JvbGxQb3MiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrWFNjcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJibG9ja1hTY3JvbGxQcm9wZXJ0eSIsImZ1bmN0aW9uc0NhbGxiYWNrIiwic2Nyb2xsVG9JbmRleCIsInJlbG9hZCIsInNldExpc3RzaXplIiwiY2xlYXJDYWNoZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsInJlbWFwSW5kZXhlcyIsIm1vdmVJbmRleCIsImluc2VydEluZGV4IiwicmVtb3ZlSW5kZXgiLCJmdW5jdGlvbnMiLCJhZGRFdmVudExpc3RlbmVyIiwib25TY3JvbGwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNTYWZhcmlJT1MiLCJpT1NvblNjcm9sbCIsImNyYWRsZUludGVyc2VjdCIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsImNyYWRsZWludGVyc2VjdG9ic2VydmVyIiwiY3JlYXRlT2JzZXJ2ZXIiLCJjb25uZWN0RWxlbWVudHMiLCJ0cmlnZ2Vyb2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsInVzZUNhbGxiYWNrIiwibWF4TGlzdHNpemUiLCJfc2VydmljZUhhbmRsZXIkY2FsbGIiLCJjYWxsYmFja3MiLCJkTGlzdENhbGxiYWNrIiwiZGVsZXRlTGlzdCIsInVwZGF0ZVZpcnR1YWxMaXN0U3BlY3MiLCJjaGFuZ2VDYWNoZUxpc3RzaXplIiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsInBhcmVDYWNoZVRvTWF4IiwicmVuZGVyUG9ydGFsTGlzdHMiLCJfZExpc3RDYWxsYmFjayIsIm1hdGNoQ2FjaGVUb0NyYWRsZSIsImlzUmVzaXppbmciLCJwYXVzZUludGVycnVwdHMiLCJfY3JhZGxlSW50ZXJuYWxQcm9wZXIiLCJsb3dDcmFkbGVJbmRleCIsImhpZ2hDcmFkbGVJbmRleCIsImNyYWRsZUNvdW50IiwibGlzdGhpZ2hyYW5nZSIsImNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQiLCJtZWFzdXJlZENyYWRsZUl0ZW1Db3VudCIsImNoYW5nZUlzV2l0aGluQ3JhZGxlIiwiX2NyYWRsZUluaGVyaXRlZFByb3BlIiwiX2NyYWRsZUluaGVyaXRlZFByb3BlMiIsInByZXZpb3VzQ2VsbFBpeGVsTGVuZ3RoIiwicHJldmlvdXNBeGlzT2Zmc2V0IiwidGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQiLCJwcmV2aW91c3JhdGlvIiwicGl2b3RDZWxsUGl4ZWxMZW5ndGgiLCJwaXZvdEF4aXNPZmZzZXQiLCJyb3VuZCIsIl9yZWY4IiwiZ2V0Q3JhZGxlU3R5bGVzIiwidXNlcnN0eWxlcyIsIl9yZWY5IiwiY3JhZGxlSGVhZFN0eWxlIiwiY3JhZGxlVGFpbFN0eWxlIiwiY3JhZGxlQXhpc1N0eWxlIiwiY3JhZGxlRGl2aWRlclN0eWxlIiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRTdHlsZSIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmaW5hbENhbGxiYWNrIiwicHJlbG9hZCIsInNpZ25hbHMiLCJwYXVzZVRyaWdnZXJsaW5lc09ic2VydmVyIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJlcG9zaXRpb25pbmdSZXF1aXJlZCIsImNvbnNvbGUiLCJsb2ciLCJpc1Njcm9sbGluZyIsImNyYWRsZUNvbnRlbnQiLCJjb250ZW50IiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnIiwiY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YSIsInNldENyYWRsZUNvbnRlbnQiLCJoZWFkRGlzcGxheUNvbXBvbmVudHMiLCJ0YWlsRGlzcGxheUNvbXBvbmVudHMiLCJyZXN0b3JlSW50ZXJydXB0cyIsInVwZGF0ZUNyYWRsZUNvbnRlbnQiLCJndWFyZEFnYWluc3RSdW5hd2F5Q2FjaGluZyIsInNldFRpbWVvdXQiLCJhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IiwiYXBwbHlQb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QiLCJuZXdsaXN0c2l6ZSIsImNsZWFyQ3JhZGxlIiwic2Nyb2xsQXhpc1JlZmVyZW5jZVBvc2l0aW9uIiwidGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uIiwic2Nyb2xsQXhpc1JlZmVyZW5jZUluZGV4Iiwic2Nyb2xsSW5kZXhSZWYiLCJzY3JvbGxUcmFja2VyQXJncyIsImluY2x1ZGVzIiwidHJhY2tlcmFyZ3MiLCJ0b3AiLCJsZWZ0IiwidHJpZ2dlcmNlbGxUcmlnZ2VybGluZXNSZWYiLCJjcmVhdGVFbGVtZW50Iiwia2V5Iiwic3R5bGUiLCJyZWYiLCJjb250ZXh0dmFsdWVSZWYiLCJQcm92aWRlciIsIm9mZnNldCIsImluZGV4IiwiY3JlYXRlSGFuZGxlciIsImhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Cradle.tsx\n")},"./src/InfiniteGridScroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// InfiniteGridScroller.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isSafariIOS = void 0;\n/*\n    react-infinite-grid-scroller = RIGS\n\n    The job of InfiniteGridScroller is to pass parameters to dependents.\n    Viewport contains the Scrollblock, which is full size for listsize of given cell height/width.\n    Scrollblock in turn contains the Cradle - a component that contains CellFrames, which contain\n    displayed user content (items) or transitional placeholders.\n\n    Host content is instantiated in a cache of React portals (via cacheAPI). Content is then\n    portal\'d to CellFrames. The cache can be configured to hold more items than the Cradle (limited by\n    device memory). Caching allows host content to maintain state.\n\n    Scrollblock represents the entirety of the list (and is sized accordingly). It is the object that is scrolled.\n\n    Cradle contains the list items, and is \'virtualized\' -- it appears as though it scrolls through a filled\n    scrollblock, but in fact it is only slightly larger than the viewport. Content is rotated in and out of the\n    cradle through the cache.\n    \n    Individual host items are framed by CellFrame, which are managed by Cradle.\n\n    Overall the InfiniteGridScroller as a package manages the asynchronous interactions of the\n    components of the mechanism. Most of the work occurs in the Cradle component.\n\n    The Rigs liner (the top level Viewport element) is set with \'display:absolute\' and \'inset:0\', so the user\n    containing block should be styles accordingly.\n*/\n/*\n\nTODO:\n\n- add startingListRange property (2 part array); setListRange API function\n\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar isSafariIOS = function isSafariIOS() {\n  var is_ios = /iP(ad|od|hone)/i.test(window.navigator.userAgent),\n    is_safari = !!navigator.userAgent.match(/Version\\/[\\d\\.]+.*Safari/);\n  return is_ios && is_safari;\n};\nexports.isSafariIOS = isSafariIOS;\n// based on module template\nfunction ErrorFallback(_ref) {\n  var error = _ref.error,\n    resetErrorBoundary = _ref.resetErrorBoundary;\n  return react_1["default"].createElement("div", {\n    role: "alert",\n    style: {\n      margin: \'3px\'\n    }\n  }, react_1["default"].createElement("p", null, "Something went wrong inside react-infinite-grid-scroller. See the console for details."), react_1["default"].createElement("p", null, "Click to cancel the error and try to continue."), react_1["default"].createElement("button", {\n    style: {\n      border: \'1px solid black\',\n      margin: \'3px\',\n      padding: \'3px\'\n    },\n    onClick: resetErrorBoundary\n  }, "Cancel error"));\n}\n// scroller components\nvar Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx"));\nvar Scrollblock_1 = __importDefault(__webpack_require__(/*! ./Scrollblock */ "./src/Scrollblock.tsx"));\nvar Cradle_1 = __importDefault(__webpack_require__(/*! ./Cradle */ "./src/Cradle.tsx"));\n// loaded here to minimize redundant renders in Cradle\nvar PortalCache_1 = __importDefault(__webpack_require__(/*! ./PortalCache */ "./src/PortalCache.tsx"));\n// -------------------[ global session ID generator ]----------------\nvar globalScrollerID = 0;\n// ===================================[ INITIALIZE ]===========================\nvar InfiniteGridScroller = function InfiniteGridScroller(props) {\n  // state\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    scrollerState = _ref3[0],\n    setScrollerState = _ref3[1]; // setup, setlistprops, ready\n  // ------------------[ normalize properties ]--------------------\n  var cellHeight = props.cellHeight,\n    cellWidth = props.cellWidth,\n    _props$startingListSi = props.startingListSize,\n    startingListSize = _props$startingListSi === void 0 ? 0 : _props$startingListSi,\n    _props$startingListRa = props.startingListRange,\n    startingListRange = _props$startingListRa === void 0 ? [-350, 243] : _props$startingListRa,\n    getItem = props.getItem,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \'vertical\' : _props$orientation,\n    _props$gap = props.gap,\n    gap = _props$gap === void 0 ? 0 : _props$gap,\n    _props$padding = props.padding,\n    padding = _props$padding === void 0 ? 0 : _props$padding,\n    _props$layout = props.layout,\n    layout = _props$layout === void 0 ? \'uniform\' : _props$layout,\n    _props$cellMinHeight = props.cellMinHeight,\n    cellMinHeight = _props$cellMinHeight === void 0 ? 25 : _props$cellMinHeight,\n    _props$cellMinWidth = props.cellMinWidth,\n    cellMinWidth = _props$cellMinWidth === void 0 ? 25 : _props$cellMinWidth,\n    _props$runwaySize = props.runwaySize,\n    runwaySize = _props$runwaySize === void 0 ? 3 : _props$runwaySize,\n    _props$startingIndex = props.startingIndex,\n    startingIndex = _props$startingIndex === void 0 ? 0 : _props$startingIndex,\n    _props$cache = props.cache,\n    cache = _props$cache === void 0 ? \'cradle\' : _props$cache,\n    _props$cacheMax = props.cacheMax,\n    cacheMax = _props$cacheMax === void 0 ? null : _props$cacheMax,\n    placeholder = props.placeholder,\n    _props$usePlaceholder = props.usePlaceholder,\n    usePlaceholder = _props$usePlaceholder === void 0 ? true : _props$usePlaceholder,\n    _props$useScrollTrack = props.useScrollTracker,\n    useScrollTracker = _props$useScrollTrack === void 0 ? true : _props$useScrollTrack,\n    _props$styles = props.styles,\n    styles = _props$styles === void 0 ? {} : _props$styles,\n    _props$placeholderMes = props.placeholderMessages,\n    placeholderMessages = _props$placeholderMes === void 0 ? {} : _props$placeholderMes,\n    _props$callbacks = props.callbacks,\n    callbacks = _props$callbacks === void 0 ? {} : _props$callbacks,\n    _props$technical = props.technical,\n    technical = _props$technical === void 0 ? {} : _props$technical,\n    _props$cacheAPI = props.cacheAPI,\n    cacheAPI = _props$cacheAPI === void 0 ? null : _props$cacheAPI,\n    dragdropProperties = props.dragdropProperties,\n    scrollerProperties = props.scrollerProperties;\n  var isMinimalPropsFail = false;\n  if (!(cellWidth && cellHeight && getItem)) {\n    console.log(\'RIGS: cellWidth, cellHeight, and getItem are required\');\n    isMinimalPropsFail = true;\n  }\n  // ---------------------[ Data setup ]----------------------\n  var originalValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  // avoid null/undefined\n  styles = styles !== null && styles !== void 0 ? styles : {};\n  callbacks = callbacks !== null && callbacks !== void 0 ? callbacks : {};\n  technical = technical !== null && technical !== void 0 ? technical : {};\n  startingIndex = startingIndex !== null && startingIndex !== void 0 ? startingIndex : 0;\n  startingListSize = startingListSize !== null && startingListSize !== void 0 ? startingListSize : 0;\n  runwaySize = runwaySize !== null && runwaySize !== void 0 ? runwaySize : 3;\n  usePlaceholder = usePlaceholder !== null && usePlaceholder !== void 0 ? usePlaceholder : true;\n  useScrollTracker = useScrollTracker !== null && useScrollTracker !== void 0 ? useScrollTracker : true;\n  cellMinHeight = cellMinHeight !== null && cellMinHeight !== void 0 ? cellMinHeight : 0;\n  cellMinWidth = cellMinWidth !== null && cellMinWidth !== void 0 ? cellMinWidth : 0;\n  cacheMax = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n  cellHeight = +cellHeight;\n  cellWidth = +cellWidth;\n  cellMinHeight = +cellMinHeight;\n  cellMinWidth = +cellMinWidth;\n  gap = +gap;\n  padding = +padding;\n  startingIndex = +startingIndex;\n  startingListSize = +startingListSize;\n  runwaySize = +runwaySize;\n  cacheMax = +cacheMax;\n  var verifiedValues = {\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    gap: gap,\n    padding: padding,\n    startingIndex: startingIndex,\n    startingListSize: startingListSize,\n    runwaySize: runwaySize,\n    cacheMax: cacheMax\n  };\n  cellMinHeight = Math.max(cellMinHeight, 25);\n  cellMinWidth = Math.max(cellMinWidth, 25);\n  cellMinHeight = Math.min(cellHeight, cellMinHeight);\n  cellMinWidth = Math.min(cellWidth, cellMinWidth);\n  // prop constraints - non-negative values\n  runwaySize = Math.max(1, runwaySize); // runwaysize must be at least 1\n  startingListSize = Math.max(0, startingListSize);\n  startingIndex = Math.max(0, startingIndex);\n  // package\n  var problems = 0;\n  for (var prop in verifiedValues) {\n    if (isNaN(verifiedValues[prop])) {\n      problems++;\n    }\n  }\n  if (problems) {\n    console.error(\'Error: invalid number - compare originalValues and verifiedValues\', originalValues, verifiedValues);\n  }\n  // rationalize startingListsize and startingListRange\n  if (!problems && scrollerState == \'setup\') {\n    var goodrange = true;\n    if (!startingListRange || !Array.isArray(startingListRange) || !(startingListRange.length == 2)) {\n      goodrange = false;\n    }\n    if (goodrange) {\n      var _startingListRange = startingListRange,\n        _startingListRange2 = _slicedToArray(_startingListRange, 2),\n        lowindex = _startingListRange2[0],\n        highindex = _startingListRange2[1];\n      lowindex = +lowindex;\n      highindex = +highindex;\n      if (isNaN(lowindex) || isNaN(highindex)) {\n        goodrange = false;\n      } else if (lowindex > highindex) {\n        goodrange = false;\n      }\n      if (goodrange) {\n        startingListSize = highindex - lowindex + 1;\n      }\n    }\n    if (!goodrange) {\n      if (startingListSize) {\n        startingListRange = [0, startingListSize - 1];\n      } else {\n        startingListRange = null;\n      }\n    }\n  }\n  // enums\n  if (![\'horizontal\', \'vertical\'].includes(orientation)) {\n    orientation = \'vertical\';\n  }\n  if (![\'preload\', \'keepload\', \'cradle\'].includes(cache)) {\n    cache = \'cradle\';\n  }\n  if (![\'uniform\', \'variable\'].includes(layout)) {\n    layout = \'uniform\';\n  }\n  var gridSpecs = {\n    orientation: orientation,\n    gap: gap,\n    padding: padding,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout\n  };\n  var gridSpecsRef = (0, react_1.useRef)(gridSpecs);\n  // system\n  var stylesRef = (0, react_1.useRef)(styles);\n  var callbacksRef = (0, react_1.useRef)(callbacks);\n  var placeholderMessagesRef = (0, react_1.useRef)(placeholderMessages);\n  var _technical = technical,\n    showAxis = _technical.showAxis,\n    triggerlineOffset = _technical.triggerlineOffset,\n    VIEWPORT_RESIZE_TIMEOUT = _technical.VIEWPORT_RESIZE_TIMEOUT,\n    ONAFTERSCROLL_TIMEOUT = _technical.ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT = _technical.IDLECALLBACK_TIMEOUT,\n    VARIABLE_MEASUREMENTS_TIMEOUT = _technical.VARIABLE_MEASUREMENTS_TIMEOUT,\n    MAX_CACHE_OVER_RUN = _technical.MAX_CACHE_OVER_RUN,\n    CACHE_PARTITION_SIZE = _technical.CACHE_PARTITION_SIZE;\n  VIEWPORT_RESIZE_TIMEOUT = VIEWPORT_RESIZE_TIMEOUT !== null && VIEWPORT_RESIZE_TIMEOUT !== void 0 ? VIEWPORT_RESIZE_TIMEOUT : 250;\n  ONAFTERSCROLL_TIMEOUT = ONAFTERSCROLL_TIMEOUT !== null && ONAFTERSCROLL_TIMEOUT !== void 0 ? ONAFTERSCROLL_TIMEOUT : 100;\n  IDLECALLBACK_TIMEOUT = IDLECALLBACK_TIMEOUT !== null && IDLECALLBACK_TIMEOUT !== void 0 ? IDLECALLBACK_TIMEOUT : 250;\n  VARIABLE_MEASUREMENTS_TIMEOUT = VARIABLE_MEASUREMENTS_TIMEOUT !== null && VARIABLE_MEASUREMENTS_TIMEOUT !== void 0 ? VARIABLE_MEASUREMENTS_TIMEOUT : 250;\n  MAX_CACHE_OVER_RUN = MAX_CACHE_OVER_RUN !== null && MAX_CACHE_OVER_RUN !== void 0 ? MAX_CACHE_OVER_RUN : 1.5;\n  CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE !== null && CACHE_PARTITION_SIZE !== void 0 ? CACHE_PARTITION_SIZE : 30;\n  if (typeof showAxis != \'boolean\') showAxis = false;\n  triggerlineOffset = triggerlineOffset !== null && triggerlineOffset !== void 0 ? triggerlineOffset : 10;\n  if (typeof usePlaceholder != \'boolean\') usePlaceholder = true;\n  if (typeof useScrollTracker != \'boolean\') useScrollTracker = true;\n  // for mount version\n  var scrollerSessionIDRef = (0, react_1.useRef)(null);\n  var scrollerID = scrollerSessionIDRef.current;\n  // for children\n  var cacheAPIRef = (0, react_1.useRef)(cacheAPI);\n  var updateFunctionRef = (0, react_1.useRef)(null);\n  var listsizeRef = (0, react_1.useRef)(startingListSize);\n  var listRangeRef = (0, react_1.useRef)(startingListRange);\n  var listsize = listsizeRef.current;\n  var listrange = listRangeRef.current;\n  var _listrange = _slicedToArray(listrange, 2),\n    lowlistrange = _listrange[0],\n    highlistrange = _listrange[1]; // ranges undefined if listrange is null\n  var virtualListSpecs = {\n    size: listsize,\n    range: listrange,\n    lowindex: lowlistrange,\n    highindex: highlistrange\n  };\n  var virtualListSpecsRef = (0, react_1.useRef)(virtualListSpecs);\n  if (!compareProps(virtualListSpecs, virtualListSpecsRef.current)) {\n    virtualListSpecsRef.current = virtualListSpecs;\n  }\n  // console.log(\'listsize, listrange, virtualListProps\', listsize, listrange, virtualListProps)\n  // tests for React with Object.is for changed properties; avoid re-renders with no change\n  if (!compareProps(gridSpecs, gridSpecsRef.current)) {\n    gridSpecsRef.current = gridSpecs;\n  }\n  if (!compareProps(styles, stylesRef.current)) {\n    stylesRef.current = styles;\n  }\n  if (!compareProps(callbacks, callbacksRef.current)) {\n    callbacksRef.current = callbacks;\n  }\n  if (!compareProps(placeholderMessages, placeholderMessagesRef.current)) {\n    placeholderMessagesRef.current = placeholderMessages;\n  }\n  // -------------------------[ Initialization ]-------------------------------\n  var getCacheAPI = function getCacheAPI(cacheAPI) {\n    cacheAPIRef.current = cacheAPI;\n  };\n  var getUpdateFunction = function getUpdateFunction(fn) {\n    updateFunctionRef.current = fn;\n  };\n  var useLocalCache = !cacheAPI;\n  var isMountedRef = (0, react_1.useRef)(true);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    if (scrollerSessionIDRef.current === null) {\n      // defend against React.StrictMode double run\n      scrollerSessionIDRef.current = globalScrollerID++;\n    }\n  }, []);\n  // called when getItem returns null, or direct call from user (see serviceHandler)\n  var setVirtualListSpecs = (0, react_1.useCallback)(function (listsizearg) {\n    var listsize, lowindex, highindex, listrange;\n    var _listRangeRef$current = _slicedToArray(listRangeRef.current, 2),\n      prevlowrange = _listRangeRef$current[0],\n      prevhighrange = _listRangeRef$current[1];\n    if (Array.isArray(listsizearg)) {\n      var _listsizearg = _slicedToArray(listsizearg, 2);\n      lowindex = _listsizearg[0];\n      highindex = _listsizearg[1];\n      listsize = highindex - lowindex + 1;\n      listrange = listsizearg;\n    } else {\n      listsize = listsizearg;\n      var _listRangeRef$current2 = _slicedToArray(listRangeRef.current, 2);\n      lowindex = _listRangeRef$current2[0];\n      highindex = _listRangeRef$current2[1];\n      listrange = [lowindex, lowindex + listsize - 1];\n    }\n    if (listsize == listsizeRef.current && lowindex === prevlowrange && highindex === prevhighrange) return;\n    listsizeRef.current = listsize;\n    listRangeRef.current = listrange;\n    // inform the user\n    callbacksRef.current.newListsize && listsizeRef.current != listsize && callbacksRef.current.newListsize(listsize);\n    setScrollerState(\'setlistprops\');\n  }, []);\n  // ---------------------[ State handling ]------------------------\n  var itemSetRef = (0, react_1.useRef)(null);\n  (0, react_1.useEffect)(function () {\n    switch (scrollerState) {\n      case \'setup\':\n        // replace cacheAPI with facade which includes hidden scrollerID\n        cacheAPIRef.current = cacheAPIRef.current.registerScroller(scrollerSessionIDRef.current);\n        itemSetRef.current = cacheAPIRef.current.itemSet; // for unmount unRegisterScroller\n        if (updateFunctionRef.current) {\n          // obtained from PortalCache\n          cacheAPIRef.current.partitionRepoForceUpdate = updateFunctionRef.current;\n        }\n      case \'setlistprops\':\n        setScrollerState(\'ready\');\n    }\n    return function () {\n      if (!isMountedRef.current) {\n        cacheAPIRef.current.unRegisterScroller(itemSetRef.current);\n      }\n    };\n  }, [scrollerState]);\n  // --------------------[ Render ]---------------------\n  if (problems || isMinimalPropsFail) {\n    return react_1["default"].createElement("div", null, "error: see console.");\n  }\n  // component calls are deferred by scrollerState to give cacheAPI a chance to initialize\n  // return <ErrorBoundary\n  //     FallbackComponent= { ErrorFallback }\n  //     // elaboration TBD\n  //     onReset = { () => {} }\n  //     onError = { () => {} }\n  //     // onError = {(error: Error, info: {componentStack: string}) => {\n  //     //     console.log(\'react-infinite-grid-scroller captured error\', error)\n  //     // }}\n  // >\n  return react_1["default"].createElement(react_1["default"].Fragment, null, scrollerState != \'setup\' && react_1["default"].createElement(Viewport_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    scrollerID: scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT: VIEWPORT_RESIZE_TIMEOUT\n  }, react_1["default"].createElement(Scrollblock_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    // listsize = { listsize }\n    virtualListSpecs: virtualListSpecsRef.current,\n    scrollerID: scrollerID\n  }, react_1["default"].createElement(Cradle_1["default"], {\n    gridSpecs: gridSpecsRef.current,\n    styles: stylesRef.current,\n    // listsize = { listsize }\n    virtualListSpecs: virtualListSpecsRef.current,\n    setVirtualListSpecs: setVirtualListSpecs,\n    cache: cache,\n    cacheMax: cacheMax,\n    userCallbacks: callbacksRef.current,\n    startingIndex: startingIndex,\n    getItem: getItem,\n    placeholder: placeholder,\n    placeholderMessages: placeholderMessagesRef.current,\n    runwaySize: runwaySize,\n    triggerlineOffset: triggerlineOffset,\n    scrollerProperties: scrollerProperties,\n    cacheAPI: cacheAPIRef.current,\n    usePlaceholder: usePlaceholder,\n    useScrollTracker: useScrollTracker,\n    showAxis: showAxis,\n    ONAFTERSCROLL_TIMEOUT: ONAFTERSCROLL_TIMEOUT,\n    IDLECALLBACK_TIMEOUT: IDLECALLBACK_TIMEOUT,\n    MAX_CACHE_OVER_RUN: MAX_CACHE_OVER_RUN,\n    VARIABLE_MEASUREMENTS_TIMEOUT: VARIABLE_MEASUREMENTS_TIMEOUT,\n    scrollerID: scrollerID\n  }))), react_1["default"].createElement("div", null, useLocalCache && react_1["default"].createElement("div", {\n    "data-type": \'cacheroot\',\n    style: cacherootstyle\n  }, react_1["default"].createElement(PortalCache_1["default"], {\n    getCacheAPI: getCacheAPI,\n    getUpdateFunction: getUpdateFunction,\n    CACHE_PARTITION_SIZE: CACHE_PARTITION_SIZE\n  }))));\n  // </ErrorBoundary>\n};\n\nexports["default"] = InfiniteGridScroller;\n// ----------------------------[ Support ]------------------------------\nvar cacherootstyle = {\n  display: \'none\'\n}; // as React.CSSProperties // static, out of view \n// utility\nfunction compareProps(obj1, obj2) {\n  if (!obj1 || !obj2) return false;\n  var keys = Object.keys(obj1);\n  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n    if (!Object.is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvSW5maW5pdGVHcmlkU2Nyb2xsZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBLFNBQUFBLGVBQUFDLEdBQUEsRUFBQUMsQ0FBQSxXQUFBQyxlQUFBLENBQUFGLEdBQUEsS0FBQUcscUJBQUEsQ0FBQUgsR0FBQSxFQUFBQyxDQUFBLEtBQUFHLDJCQUFBLENBQUFKLEdBQUEsRUFBQUMsQ0FBQSxLQUFBSSxnQkFBQTtBQUFBLFNBQUFBLGlCQUFBLGNBQUFDLFNBQUE7QUFBQSxTQUFBRiw0QkFBQUcsQ0FBQSxFQUFBQyxNQUFBLFNBQUFELENBQUEscUJBQUFBLENBQUEsc0JBQUFFLGlCQUFBLENBQUFGLENBQUEsRUFBQUMsTUFBQSxPQUFBRSxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsU0FBQSxDQUFBQyxRQUFBLENBQUFDLElBQUEsQ0FBQVAsQ0FBQSxFQUFBUSxLQUFBLGFBQUFMLENBQUEsaUJBQUFILENBQUEsQ0FBQVMsV0FBQSxFQUFBTixDQUFBLEdBQUFILENBQUEsQ0FBQVMsV0FBQSxDQUFBQyxJQUFBLE1BQUFQLENBQUEsY0FBQUEsQ0FBQSxtQkFBQVEsS0FBQSxDQUFBQyxJQUFBLENBQUFaLENBQUEsT0FBQUcsQ0FBQSwrREFBQVUsSUFBQSxDQUFBVixDQUFBLFVBQUFELGlCQUFBLENBQUFGLENBQUEsRUFBQUMsTUFBQTtBQUFBLFNBQUFDLGtCQUFBVCxHQUFBLEVBQUFxQixHQUFBLFFBQUFBLEdBQUEsWUFBQUEsR0FBQSxHQUFBckIsR0FBQSxDQUFBc0IsTUFBQSxFQUFBRCxHQUFBLEdBQUFyQixHQUFBLENBQUFzQixNQUFBLFdBQUFyQixDQUFBLE1BQUFzQixJQUFBLE9BQUFMLEtBQUEsQ0FBQUcsR0FBQSxHQUFBcEIsQ0FBQSxHQUFBb0IsR0FBQSxFQUFBcEIsQ0FBQSxJQUFBc0IsSUFBQSxDQUFBdEIsQ0FBQSxJQUFBRCxHQUFBLENBQUFDLENBQUEsVUFBQXNCLElBQUE7QUFBQSxTQUFBcEIsc0JBQUFILEdBQUEsRUFBQUMsQ0FBQSxRQUFBdUIsRUFBQSxXQUFBeEIsR0FBQSxnQ0FBQXlCLE1BQUEsSUFBQXpCLEdBQUEsQ0FBQXlCLE1BQUEsQ0FBQUMsUUFBQSxLQUFBMUIsR0FBQSw0QkFBQXdCLEVBQUEsUUFBQUcsRUFBQSxFQUFBQyxFQUFBLEVBQUFDLEVBQUEsRUFBQUMsRUFBQSxFQUFBQyxJQUFBLE9BQUFDLEVBQUEsT0FBQUMsRUFBQSxpQkFBQUosRUFBQSxJQUFBTCxFQUFBLEdBQUFBLEVBQUEsQ0FBQVYsSUFBQSxDQUFBZCxHQUFBLEdBQUFrQyxJQUFBLFFBQUFqQyxDQUFBLFFBQUFVLE1BQUEsQ0FBQWEsRUFBQSxNQUFBQSxFQUFBLFVBQUFRLEVBQUEsdUJBQUFBLEVBQUEsSUFBQUwsRUFBQSxHQUFBRSxFQUFBLENBQUFmLElBQUEsQ0FBQVUsRUFBQSxHQUFBVyxJQUFBLE1BQUFKLElBQUEsQ0FBQUssSUFBQSxDQUFBVCxFQUFBLENBQUFVLEtBQUEsR0FBQU4sSUFBQSxDQUFBVCxNQUFBLEtBQUFyQixDQUFBLEdBQUErQixFQUFBLGlCQUFBTSxHQUFBLElBQUFMLEVBQUEsT0FBQUwsRUFBQSxHQUFBVSxHQUFBLHlCQUFBTixFQUFBLFlBQUFSLEVBQUEsZUFBQU0sRUFBQSxHQUFBTixFQUFBLGNBQUFiLE1BQUEsQ0FBQW1CLEVBQUEsTUFBQUEsRUFBQSwyQkFBQUcsRUFBQSxRQUFBTCxFQUFBLGFBQUFHLElBQUE7QUFBQSxTQUFBN0IsZ0JBQUFGLEdBQUEsUUFBQWtCLEtBQUEsQ0FBQXFCLE9BQUEsQ0FBQXZDLEdBQUEsVUFBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7QUFRQSxJQUFBd0MsT0FBQSxHQUFBQyxZQUFBLENBQUFDLG1CQUFBO0FBS08sSUFBTUMsV0FBVyxHQUFHLFNBQWRBLFdBQVdBLENBQUEsRUFBUTtFQUM1QixJQUNJQyxNQUFNLEdBQUcsaUJBQWlCLENBQUN4QixJQUFJLENBQUN5QixNQUFNLENBQUNDLFNBQVMsQ0FBQ0MsU0FBUyxDQUFDO0lBQzNEQyxTQUFTLEdBQUcsQ0FBQyxDQUFDRixTQUFTLENBQUNDLFNBQVMsQ0FBQ0UsS0FBSyxDQUFDLDBCQUEwQixDQUFDO0VBQ3ZFLE9BQVNMLE1BQU0sSUFBSUksU0FBUztBQUNoQyxDQUFDO0FBTFlFLG1CQUFXLEdBQUFQLFdBQUE7QUFPeEI7QUFDQSxTQUFTUSxhQUFhQSxDQUFBQyxJQUFBLEVBQTRCO0VBQUEsSUFBMUJDLEtBQUssR0FBQUQsSUFBQSxDQUFMQyxLQUFLO0lBQUVDLGtCQUFrQixHQUFBRixJQUFBLENBQWxCRSxrQkFBa0I7RUFDL0MsT0FDRWQsT0FBQSxZQUFBZSxhQUFBO0lBQUtDLElBQUksRUFBQyxPQUFPO0lBQUNDLEtBQUssRUFBSTtNQUFDQyxNQUFNLEVBQUM7SUFBSztFQUFDLEdBQ3ZDbEIsT0FBQSxZQUFBZSxhQUFBLHFHQUE2RixFQUM3RmYsT0FBQSxZQUFBZSxhQUFBLDZEQUFxRCxFQUNyRGYsT0FBQSxZQUFBZSxhQUFBO0lBQ0lFLEtBQUssRUFBSTtNQUFDRSxNQUFNLEVBQUMsaUJBQWlCO01BQUVELE1BQU0sRUFBQyxLQUFLO01BQUVFLE9BQU8sRUFBQztJQUFLLENBQUM7SUFDaEVDLE9BQU8sRUFBS1A7RUFBa0Isa0JBR3pCLENBQ0w7QUFFVjtBQUVBO0FBQ0EsSUFBQVEsVUFBQSxHQUFBQyxlQUFBLENBQUFyQixtQkFBQTtBQUNBLElBQUFzQixhQUFBLEdBQUFELGVBQUEsQ0FBQXJCLG1CQUFBO0FBQ0EsSUFBQXVCLFFBQUEsR0FBQUYsZUFBQSxDQUFBckIsbUJBQUE7QUFFQTtBQUNBLElBQUF3QixhQUFBLEdBQUFILGVBQUEsQ0FBQXJCLG1CQUFBO0FBRUE7QUFFQSxJQUFJeUIsZ0JBQWdCLEdBQUcsQ0FBQztBQUV4QjtBQUVBLElBQU1DLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBb0JBLENBQUlDLEtBQUssRUFBSTtFQUVuQztFQUNBLElBQUFDLEtBQUEsR0FBMEMsSUFBQTlCLE9BQUEsQ0FBQStCLFFBQVEsRUFBQyxPQUFPLENBQUM7SUFBQUMsS0FBQSxHQUFBekUsY0FBQSxDQUFBdUUsS0FBQTtJQUFwREcsYUFBYSxHQUFBRCxLQUFBO0lBQUVFLGdCQUFnQixHQUFBRixLQUFBLElBQXFCLENBQUM7RUFFNUQ7RUFFQSxJQUdJRyxVQUFVLEdBK0NWTixLQUFLLENBL0NMTSxVQUFVO0lBRVZDLFNBQVMsR0E2Q1RQLEtBQUssQ0E3Q0xPLFNBQVM7SUFBQUMscUJBQUEsR0E2Q1RSLEtBQUssQ0EzQ0xTLGdCQUFnQjtJQUFoQkEsZ0JBQWdCLEdBQUFELHFCQUFBLGNBQUcsQ0FBQyxHQUFBQSxxQkFBQTtJQUFBRSxxQkFBQSxHQTJDcEJWLEtBQUssQ0F6Q0xXLGlCQUFpQjtJQUFqQkEsaUJBQWlCLEdBQUFELHFCQUFBLGNBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBQyxHQUFHLENBQUMsR0FBQUEscUJBQUE7SUFDOUJFLE9BQU8sR0F3Q1BaLEtBQUssQ0F4Q0xZLE9BQU87SUFBQUMsa0JBQUEsR0F3Q1BiLEtBQUssQ0FuQ0xjLFdBQVc7SUFBWEEsV0FBVyxHQUFBRCxrQkFBQSxjQUFHLFVBQVUsR0FBQUEsa0JBQUE7SUFBQUUsVUFBQSxHQW1DeEJmLEtBQUssQ0FsQ0xnQixHQUFHO0lBQUhBLEdBQUcsR0FBQUQsVUFBQSxjQUFHLENBQUMsR0FBQUEsVUFBQTtJQUFBRSxjQUFBLEdBa0NQakIsS0FBSyxDQWpDTFQsT0FBTztJQUFQQSxPQUFPLEdBQUEwQixjQUFBLGNBQUcsQ0FBQyxHQUFBQSxjQUFBO0lBQUFDLGFBQUEsR0FpQ1hsQixLQUFLLENBaENMbUIsTUFBTTtJQUFOQSxNQUFNLEdBQUFELGFBQUEsY0FBRyxTQUFTLEdBQUFBLGFBQUE7SUFBQUUsb0JBQUEsR0FnQ2xCcEIsS0FBSyxDQS9CTHFCLGFBQWE7SUFBYkEsYUFBYSxHQUFBRCxvQkFBQSxjQUFHLEVBQUUsR0FBQUEsb0JBQUE7SUFBQUUsbUJBQUEsR0ErQmxCdEIsS0FBSyxDQTlCTHVCLFlBQVk7SUFBWkEsWUFBWSxHQUFBRCxtQkFBQSxjQUFHLEVBQUUsR0FBQUEsbUJBQUE7SUFBQUUsaUJBQUEsR0E4QmpCeEIsS0FBSyxDQTNCTHlCLFVBQVU7SUFBVkEsVUFBVSxHQUFBRCxpQkFBQSxjQUFHLENBQUMsR0FBQUEsaUJBQUE7SUFBQUUsb0JBQUEsR0EyQmQxQixLQUFLLENBekJMMkIsYUFBYTtJQUFiQSxhQUFhLEdBQUFELG9CQUFBLGNBQUcsQ0FBQyxHQUFBQSxvQkFBQTtJQUFBRSxZQUFBLEdBeUJqQjVCLEtBQUssQ0F0Qkw2QixLQUFLO0lBQUxBLEtBQUssR0FBQUQsWUFBQSxjQUFHLFFBQVEsR0FBQUEsWUFBQTtJQUFBRSxlQUFBLEdBc0JoQjlCLEtBQUssQ0FyQkwrQixRQUFRO0lBQVJBLFFBQVEsR0FBQUQsZUFBQSxjQUFHLElBQUksR0FBQUEsZUFBQTtJQUNmRSxXQUFXLEdBb0JYaEMsS0FBSyxDQXBCTGdDLFdBQVc7SUFBQUMscUJBQUEsR0FvQlhqQyxLQUFLLENBbEJMa0MsY0FBYztJQUFkQSxjQUFjLEdBQUFELHFCQUFBLGNBQUcsSUFBSSxHQUFBQSxxQkFBQTtJQUFBRSxxQkFBQSxHQWtCckJuQyxLQUFLLENBakJMb0MsZ0JBQWdCO0lBQWhCQSxnQkFBZ0IsR0FBQUQscUJBQUEsY0FBRyxJQUFJLEdBQUFBLHFCQUFBO0lBQUFFLGFBQUEsR0FpQnZCckMsS0FBSyxDQWRMc0MsTUFBTTtJQUFOQSxNQUFNLEdBQUFELGFBQUEsY0FBRyxFQUFFLEdBQUFBLGFBQUE7SUFBQUUscUJBQUEsR0FjWHZDLEtBQUssQ0FYTHdDLG1CQUFtQjtJQUFuQkEsbUJBQW1CLEdBQUFELHFCQUFBLGNBQUcsRUFBRSxHQUFBQSxxQkFBQTtJQUFBRSxnQkFBQSxHQVd4QnpDLEtBQUssQ0FWTDBDLFNBQVM7SUFBVEEsU0FBUyxHQUFBRCxnQkFBQSxjQUFHLEVBQUUsR0FBQUEsZ0JBQUE7SUFBQUUsZ0JBQUEsR0FVZDNDLEtBQUssQ0FQTDRDLFNBQVM7SUFBVEEsU0FBUyxHQUFBRCxnQkFBQSxjQUFHLEVBQUUsR0FBQUEsZ0JBQUE7SUFBQUUsZUFBQSxHQU9kN0MsS0FBSyxDQU5MOEMsUUFBUTtJQUFSQSxRQUFRLEdBQUFELGVBQUEsY0FBRyxJQUFJLEdBQUFBLGVBQUE7SUFDZkUsa0JBQWtCLEdBS2xCL0MsS0FBSyxDQUxMK0Msa0JBQWtCO0lBR2xCQyxrQkFBa0IsR0FFbEJoRCxLQUFLLENBRkxnRCxrQkFBa0I7RUFJdEIsSUFBSUMsa0JBQWtCLEdBQUcsS0FBSztFQUM5QixJQUFJLEVBQUUxQyxTQUFTLElBQUlELFVBQVUsSUFBSU0sT0FBTyxDQUFFLEVBQUU7SUFDeENzQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyx1REFBdUQsQ0FBQztJQUNwRUYsa0JBQWtCLEdBQUcsSUFBSTs7RUFHN0I7RUFFQSxJQUFNRyxjQUFjLEdBQUc7SUFDbkI5QyxVQUFVLEVBQVZBLFVBQVU7SUFDVkMsU0FBUyxFQUFUQSxTQUFTO0lBQ1RjLGFBQWEsRUFBYkEsYUFBYTtJQUNiRSxZQUFZLEVBQVpBLFlBQVk7SUFDWlAsR0FBRyxFQUFIQSxHQUFHO0lBQ0h6QixPQUFPLEVBQVBBLE9BQU87SUFDUG9DLGFBQWEsRUFBYkEsYUFBYTtJQUNibEIsZ0JBQWdCLEVBQWhCQSxnQkFBZ0I7SUFDaEJnQixVQUFVLEVBQVZBLFVBQVU7SUFDVk0sUUFBUSxFQUFSQTtHQUNIO0VBRUQ7RUFDQU8sTUFBTSxHQUFHQSxNQUFNLGFBQU5BLE1BQU0sY0FBTkEsTUFBTSxHQUFJLEVBQUU7RUFDckJJLFNBQVMsR0FBR0EsU0FBUyxhQUFUQSxTQUFTLGNBQVRBLFNBQVMsR0FBSSxFQUFFO0VBQzNCRSxTQUFTLEdBQUdBLFNBQVMsYUFBVEEsU0FBUyxjQUFUQSxTQUFTLEdBQUksRUFBRTtFQUMzQmpCLGFBQWEsR0FBR0EsYUFBYSxhQUFiQSxhQUFhLGNBQWJBLGFBQWEsR0FBSSxDQUFDO0VBQ2xDbEIsZ0JBQWdCLEdBQUdBLGdCQUFnQixhQUFoQkEsZ0JBQWdCLGNBQWhCQSxnQkFBZ0IsR0FBSSxDQUFDO0VBQ3hDZ0IsVUFBVSxHQUFHQSxVQUFVLGFBQVZBLFVBQVUsY0FBVkEsVUFBVSxHQUFJLENBQUM7RUFDNUJTLGNBQWMsR0FBR0EsY0FBYyxhQUFkQSxjQUFjLGNBQWRBLGNBQWMsR0FBSSxJQUFJO0VBQ3ZDRSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLGFBQWhCQSxnQkFBZ0IsY0FBaEJBLGdCQUFnQixHQUFJLElBQUk7RUFDM0NmLGFBQWEsR0FBR0EsYUFBYSxhQUFiQSxhQUFhLGNBQWJBLGFBQWEsR0FBSSxDQUFDO0VBQ2xDRSxZQUFZLEdBQUdBLFlBQVksYUFBWkEsWUFBWSxjQUFaQSxZQUFZLEdBQUksQ0FBQztFQUNoQ1EsUUFBUSxHQUFHQSxRQUFRLGFBQVJBLFFBQVEsY0FBUkEsUUFBUSxHQUFJLENBQUM7RUFFeEJ6QixVQUFVLEdBQUcsQ0FBQ0EsVUFBVTtFQUN4QkMsU0FBUyxHQUFHLENBQUNBLFNBQVM7RUFDdEJjLGFBQWEsR0FBRyxDQUFDQSxhQUFhO0VBQzlCRSxZQUFZLEdBQUcsQ0FBQ0EsWUFBWTtFQUM1QlAsR0FBRyxHQUFHLENBQUNBLEdBQUc7RUFDVnpCLE9BQU8sR0FBRyxDQUFDQSxPQUFPO0VBQ2xCb0MsYUFBYSxHQUFHLENBQUNBLGFBQWE7RUFDOUJsQixnQkFBZ0IsR0FBRyxDQUFDQSxnQkFBZ0I7RUFDcENnQixVQUFVLEdBQUcsQ0FBQ0EsVUFBVTtFQUN4Qk0sUUFBUSxHQUFHLENBQUNBLFFBQVE7RUFFcEIsSUFBTXNCLGNBQWMsR0FBRztJQUNuQi9DLFVBQVUsRUFBVkEsVUFBVTtJQUNWQyxTQUFTLEVBQVRBLFNBQVM7SUFDVGMsYUFBYSxFQUFiQSxhQUFhO0lBQ2JFLFlBQVksRUFBWkEsWUFBWTtJQUNaUCxHQUFHLEVBQUhBLEdBQUc7SUFDSHpCLE9BQU8sRUFBUEEsT0FBTztJQUNQb0MsYUFBYSxFQUFiQSxhQUFhO0lBQ2JsQixnQkFBZ0IsRUFBaEJBLGdCQUFnQjtJQUNoQmdCLFVBQVUsRUFBVkEsVUFBVTtJQUNWTSxRQUFRLEVBQVJBO0dBQ0g7RUFFRFYsYUFBYSxHQUFHaUMsSUFBSSxDQUFDQyxHQUFHLENBQUNsQyxhQUFhLEVBQUUsRUFBRSxDQUFDO0VBQzNDRSxZQUFZLEdBQUcrQixJQUFJLENBQUNDLEdBQUcsQ0FBQ2hDLFlBQVksRUFBRSxFQUFFLENBQUM7RUFDekNGLGFBQWEsR0FBR2lDLElBQUksQ0FBQ0UsR0FBRyxDQUFDbEQsVUFBVSxFQUFFZSxhQUFhLENBQUM7RUFDbkRFLFlBQVksR0FBRytCLElBQUksQ0FBQ0UsR0FBRyxDQUFDakQsU0FBUyxFQUFFZ0IsWUFBWSxDQUFDO0VBRWhEO0VBQ0FFLFVBQVUsR0FBRzZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBQzlCLFVBQVUsQ0FBQyxFQUFDO0VBQ3BDaEIsZ0JBQWdCLEdBQUc2QyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUM5QyxnQkFBZ0IsQ0FBQztFQUMvQ2tCLGFBQWEsR0FBRzJCLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBQzVCLGFBQWEsQ0FBQztFQUV6QztFQUNBLElBQUk4QixRQUFRLEdBQUcsQ0FBQztFQUNoQixLQUFLLElBQU1DLElBQUksSUFBSUwsY0FBYyxFQUFFO0lBQy9CLElBQUlNLEtBQUssQ0FBQ04sY0FBYyxDQUFDSyxJQUFJLENBQUMsQ0FBQyxFQUFFO01BQzdCRCxRQUFRLEVBQUU7OztFQUlsQixJQUFJQSxRQUFRLEVBQUU7SUFDVlAsT0FBTyxDQUFDbEUsS0FBSyxDQUFDLG1FQUFtRSxFQUM3RW9FLGNBQWMsRUFBRUMsY0FBYyxDQUFDOztFQUd2QztFQUNBLElBQUksQ0FBQ0ksUUFBUSxJQUFJckQsYUFBYSxJQUFJLE9BQU8sRUFBRTtJQUV2QyxJQUFJd0QsU0FBUyxHQUFHLElBQUk7SUFDcEIsSUFBSSxDQUFDakQsaUJBQWlCLElBQUksQ0FBQzlELEtBQUssQ0FBQ3FCLE9BQU8sQ0FBQ3lDLGlCQUFpQixDQUFDLElBQUksRUFBRUEsaUJBQWlCLENBQUMxRCxNQUFNLElBQUksQ0FBQyxDQUFDLEVBQUU7TUFDN0YyRyxTQUFTLEdBQUcsS0FBSzs7SUFFckIsSUFBSUEsU0FBUyxFQUFFO01BQ1gsSUFBQUMsa0JBQUEsR0FBMkJsRCxpQkFBaUI7UUFBQW1ELG1CQUFBLEdBQUFwSSxjQUFBLENBQUFtSSxrQkFBQTtRQUF2Q0UsUUFBUSxHQUFBRCxtQkFBQTtRQUFDRSxTQUFTLEdBQUFGLG1CQUFBO01BQ3ZCQyxRQUFRLEdBQUcsQ0FBQ0EsUUFBUTtNQUNwQkMsU0FBUyxHQUFHLENBQUNBLFNBQVM7TUFDdEIsSUFBSUwsS0FBSyxDQUFDSSxRQUFRLENBQUMsSUFBSUosS0FBSyxDQUFDSyxTQUFTLENBQUMsRUFBRTtRQUNyQ0osU0FBUyxHQUFHLEtBQUs7T0FDcEIsTUFBTSxJQUFJRyxRQUFRLEdBQUdDLFNBQVMsRUFBRTtRQUM3QkosU0FBUyxHQUFHLEtBQUs7O01BRXJCLElBQUlBLFNBQVMsRUFBRTtRQUNYbkQsZ0JBQWdCLEdBQUd1RCxTQUFTLEdBQUdELFFBQVEsR0FBRyxDQUFDOzs7SUFHbkQsSUFBSSxDQUFDSCxTQUFTLEVBQUU7TUFDWixJQUFJbkQsZ0JBQWdCLEVBQUU7UUFDbEJFLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxFQUFDRixnQkFBZ0IsR0FBRyxDQUFDLENBQUM7T0FDL0MsTUFBTTtRQUNIRSxpQkFBaUIsR0FBRyxJQUFJOzs7O0VBS3BDO0VBQ0EsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFDLFVBQVUsQ0FBQyxDQUFDc0QsUUFBUSxDQUFDbkQsV0FBVyxDQUFDLEVBQUU7SUFDbERBLFdBQVcsR0FBRyxVQUFVOztFQUU1QixJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUMsVUFBVSxFQUFDLFFBQVEsQ0FBQyxDQUFDbUQsUUFBUSxDQUFDcEMsS0FBSyxDQUFDLEVBQUU7SUFDbERBLEtBQUssR0FBRyxRQUFROztFQUVwQixJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUNvQyxRQUFRLENBQUM5QyxNQUFNLENBQUMsRUFBRTtJQUMzQ0EsTUFBTSxHQUFHLFNBQVM7O0VBR3RCLElBQU0rQyxTQUFTLEdBQUc7SUFDZHBELFdBQVcsRUFBWEEsV0FBVztJQUNYRSxHQUFHLEVBQUhBLEdBQUc7SUFDSHpCLE9BQU8sRUFBUEEsT0FBTztJQUNQZSxVQUFVLEVBQVZBLFVBQVU7SUFDVkMsU0FBUyxFQUFUQSxTQUFTO0lBQ1RjLGFBQWEsRUFBYkEsYUFBYTtJQUNiRSxZQUFZLEVBQVpBLFlBQVk7SUFDWkosTUFBTSxFQUFOQTtHQUNIO0VBRUQsSUFBTWdELFlBQVksR0FBRyxJQUFBaEcsT0FBQSxDQUFBaUcsTUFBTSxFQUFDRixTQUFTLENBQUM7RUFFdEM7RUFDQSxJQUFNRyxTQUFTLEdBQUcsSUFBQWxHLE9BQUEsQ0FBQWlHLE1BQU0sRUFBQzlCLE1BQU0sQ0FBQztFQUNoQyxJQUFNZ0MsWUFBWSxHQUFHLElBQUFuRyxPQUFBLENBQUFpRyxNQUFNLEVBQUMxQixTQUFTLENBQUM7RUFDdEMsSUFBTTZCLHNCQUFzQixHQUFHLElBQUFwRyxPQUFBLENBQUFpRyxNQUFNLEVBQUM1QixtQkFBbUIsQ0FBQztFQUUxRCxJQUFBZ0MsVUFBQSxHQWFJNUIsU0FBUztJQVhUNkIsUUFBUSxHQUFBRCxVQUFBLENBQVJDLFFBQVE7SUFDUkMsaUJBQWlCLEdBQUFGLFVBQUEsQ0FBakJFLGlCQUFpQjtJQUVqQkMsdUJBQXVCLEdBQUFILFVBQUEsQ0FBdkJHLHVCQUF1QjtJQUN2QkMscUJBQXFCLEdBQUFKLFVBQUEsQ0FBckJJLHFCQUFxQjtJQUNyQkMsb0JBQW9CLEdBQUFMLFVBQUEsQ0FBcEJLLG9CQUFvQjtJQUNwQkMsNkJBQTZCLEdBQUFOLFVBQUEsQ0FBN0JNLDZCQUE2QjtJQUU3QkMsa0JBQWtCLEdBQUFQLFVBQUEsQ0FBbEJPLGtCQUFrQjtJQUNsQkMsb0JBQW9CLEdBQUFSLFVBQUEsQ0FBcEJRLG9CQUFvQjtFQUl4QkwsdUJBQXVCLEdBQUdBLHVCQUF1QixhQUF2QkEsdUJBQXVCLGNBQXZCQSx1QkFBdUIsR0FBSSxHQUFHO0VBQ3hEQyxxQkFBcUIsR0FBR0EscUJBQXFCLGFBQXJCQSxxQkFBcUIsY0FBckJBLHFCQUFxQixHQUFJLEdBQUc7RUFDcERDLG9CQUFvQixHQUFHQSxvQkFBb0IsYUFBcEJBLG9CQUFvQixjQUFwQkEsb0JBQW9CLEdBQUksR0FBRztFQUNsREMsNkJBQTZCLEdBQUdBLDZCQUE2QixhQUE3QkEsNkJBQTZCLGNBQTdCQSw2QkFBNkIsR0FBSSxHQUFHO0VBRXBFQyxrQkFBa0IsR0FBR0Esa0JBQWtCLGFBQWxCQSxrQkFBa0IsY0FBbEJBLGtCQUFrQixHQUFJLEdBQUc7RUFDOUNDLG9CQUFvQixHQUFHQSxvQkFBb0IsYUFBcEJBLG9CQUFvQixjQUFwQkEsb0JBQW9CLEdBQUksRUFBRTtFQUVqRCxJQUFJLE9BQU9QLFFBQVEsSUFBSSxTQUFTLEVBQUVBLFFBQVEsR0FBRyxLQUFLO0VBRWxEQyxpQkFBaUIsR0FBR0EsaUJBQWlCLGFBQWpCQSxpQkFBaUIsY0FBakJBLGlCQUFpQixHQUFJLEVBQUU7RUFFM0MsSUFBSSxPQUFPeEMsY0FBYyxJQUFJLFNBQVMsRUFBRUEsY0FBYyxHQUFHLElBQUk7RUFDN0QsSUFBSSxPQUFPRSxnQkFBZ0IsSUFBSSxTQUFTLEVBQUVBLGdCQUFnQixHQUFHLElBQUk7RUFFakU7RUFDQSxJQUFNNkMsb0JBQW9CLEdBQUcsSUFBQTlHLE9BQUEsQ0FBQWlHLE1BQU0sRUFBQyxJQUFJLENBQUM7RUFDekMsSUFBTWMsVUFBVSxHQUFHRCxvQkFBb0IsQ0FBQ0UsT0FBTztFQUUvQztFQUNBLElBQU1DLFdBQVcsR0FBRyxJQUFBakgsT0FBQSxDQUFBaUcsTUFBTSxFQUFDdEIsUUFBUSxDQUFDO0VBRXBDLElBQU11QyxpQkFBaUIsR0FBRyxJQUFBbEgsT0FBQSxDQUFBaUcsTUFBTSxFQUFDLElBQUksQ0FBQztFQUV0QyxJQUFNa0IsV0FBVyxHQUFHLElBQUFuSCxPQUFBLENBQUFpRyxNQUFNLEVBQUMzRCxnQkFBZ0IsQ0FBQztFQUM1QyxJQUFNOEUsWUFBWSxHQUFHLElBQUFwSCxPQUFBLENBQUFpRyxNQUFNLEVBQUN6RCxpQkFBaUIsQ0FBQztFQUU5QyxJQUFNNkUsUUFBUSxHQUFHRixXQUFXLENBQUNILE9BQU87RUFDcEMsSUFBTU0sU0FBUyxHQUFHRixZQUFZLENBQUNKLE9BQU87RUFDdEMsSUFBQU8sVUFBQSxHQUFBaEssY0FBQSxDQUFzQytKLFNBQVM7SUFBeENFLFlBQVksR0FBQUQsVUFBQTtJQUFFRSxhQUFhLEdBQUFGLFVBQUEsSUFBYSxDQUFDO0VBRWhELElBQU1HLGdCQUFnQixHQUFHO0lBQ3JCQyxJQUFJLEVBQUNOLFFBQVE7SUFDYk8sS0FBSyxFQUFDTixTQUFTO0lBQ2YxQixRQUFRLEVBQUM0QixZQUFZO0lBQ3JCM0IsU0FBUyxFQUFDNEI7R0FDYjtFQUVELElBQU1JLG1CQUFtQixHQUFHLElBQUE3SCxPQUFBLENBQUFpRyxNQUFNLEVBQUN5QixnQkFBZ0IsQ0FBQztFQUVwRCxJQUFJLENBQUNJLFlBQVksQ0FBQ0osZ0JBQWdCLEVBQUVHLG1CQUFtQixDQUFDYixPQUFPLENBQUMsRUFBRTtJQUM5RGEsbUJBQW1CLENBQUNiLE9BQU8sR0FBR1UsZ0JBQWdCOztFQUdsRDtFQUVBO0VBQ0EsSUFBSSxDQUFDSSxZQUFZLENBQUMvQixTQUFTLEVBQUVDLFlBQVksQ0FBQ2dCLE9BQU8sQ0FBQyxFQUFFO0lBQ2hEaEIsWUFBWSxDQUFDZ0IsT0FBTyxHQUFHakIsU0FBUzs7RUFHcEMsSUFBSSxDQUFDK0IsWUFBWSxDQUFDM0QsTUFBTSxFQUFFK0IsU0FBUyxDQUFDYyxPQUFPLENBQUMsRUFBRTtJQUMxQ2QsU0FBUyxDQUFDYyxPQUFPLEdBQUc3QyxNQUFNOztFQUU5QixJQUFJLENBQUMyRCxZQUFZLENBQUN2RCxTQUFTLEVBQUU0QixZQUFZLENBQUNhLE9BQU8sQ0FBQyxFQUFFO0lBQ2hEYixZQUFZLENBQUNhLE9BQU8sR0FBR3pDLFNBQVM7O0VBRXBDLElBQUksQ0FBQ3VELFlBQVksQ0FBQ3pELG1CQUFtQixFQUFFK0Isc0JBQXNCLENBQUNZLE9BQU8sQ0FBQyxFQUFFO0lBQ3BFWixzQkFBc0IsQ0FBQ1ksT0FBTyxHQUFHM0MsbUJBQW1COztFQUd4RDtFQUVBLElBQU0wRCxXQUFXLEdBQUcsU0FBZEEsV0FBV0EsQ0FBSXBELFFBQVEsRUFBSTtJQUU3QnNDLFdBQVcsQ0FBQ0QsT0FBTyxHQUFHckMsUUFBUTtFQUVsQyxDQUFDO0VBRUQsSUFBTXFELGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBaUJBLENBQUlDLEVBQUUsRUFBSTtJQUU3QmYsaUJBQWlCLENBQUNGLE9BQU8sR0FBR2lCLEVBQUU7RUFFbEMsQ0FBQztFQUVELElBQU1DLGFBQWEsR0FBRyxDQUFDdkQsUUFBUTtFQUUvQixJQUFNd0QsWUFBWSxHQUFHLElBQUFuSSxPQUFBLENBQUFpRyxNQUFNLEVBQUMsSUFBSSxDQUFDO0VBRWpDLElBQUFqRyxPQUFBLENBQUFvSSxTQUFTLEVBQUMsWUFBSTtJQUVWRCxZQUFZLENBQUNuQixPQUFPLEdBQUcsSUFBSTtJQUUzQixPQUFPLFlBQUs7TUFFUm1CLFlBQVksQ0FBQ25CLE9BQU8sR0FBRyxLQUFLO0lBRWhDLENBQUM7RUFFTCxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUwsSUFBQWhILE9BQUEsQ0FBQW9JLFNBQVMsRUFBRSxZQUFLO0lBRVosSUFBSXRCLG9CQUFvQixDQUFDRSxPQUFPLEtBQUssSUFBSSxFQUFFO01BQUU7TUFDekNGLG9CQUFvQixDQUFDRSxPQUFPLEdBQUdyRixnQkFBZ0IsRUFBRTs7RUFHekQsQ0FBQyxFQUFDLEVBQUUsQ0FBQztFQUVMO0VBQ0EsSUFBTTBHLG1CQUFtQixHQUFHLElBQUFySSxPQUFBLENBQUFzSSxXQUFXLEVBQUMsVUFBQ0MsV0FBVyxFQUFJO0lBRXBELElBQUlsQixRQUFRLEVBQUV6QixRQUFRLEVBQUVDLFNBQVMsRUFBRXlCLFNBQVM7SUFDNUMsSUFBQWtCLHFCQUFBLEdBQUFqTCxjQUFBLENBQXNDNkosWUFBWSxDQUFDSixPQUFPO01BQW5EeUIsWUFBWSxHQUFBRCxxQkFBQTtNQUFFRSxhQUFhLEdBQUFGLHFCQUFBO0lBQ2xDLElBQUk5SixLQUFLLENBQUNxQixPQUFPLENBQUN3SSxXQUFXLENBQUMsRUFBRTtNQUFBLElBQUFJLFlBQUEsR0FBQXBMLGNBQUEsQ0FDTGdMLFdBQVc7TUFBakMzQyxRQUFRLEdBQUErQyxZQUFBO01BQUM5QyxTQUFTLEdBQUE4QyxZQUFBO01BQ25CdEIsUUFBUSxHQUFHeEIsU0FBUyxHQUFHRCxRQUFRLEdBQUcsQ0FBQztNQUNuQzBCLFNBQVMsR0FBR2lCLFdBQVc7S0FDMUIsTUFBTTtNQUNIbEIsUUFBUSxHQUFHa0IsV0FBVztNQUFDLElBQUFLLHNCQUFBLEdBQUFyTCxjQUFBLENBQ0E2SixZQUFZLENBQUNKLE9BQU87TUFBMUNwQixRQUFRLEdBQUFnRCxzQkFBQTtNQUFDL0MsU0FBUyxHQUFBK0Msc0JBQUE7TUFDbkJ0QixTQUFTLEdBQUcsQ0FBQzFCLFFBQVEsRUFBQ0EsUUFBUSxHQUFHeUIsUUFBUSxHQUFHLENBQUMsQ0FBQzs7SUFHbEQsSUFBSUEsUUFBUSxJQUFJRixXQUFXLENBQUNILE9BQU8sSUFBSXBCLFFBQVEsS0FBSzZDLFlBQVksSUFBSTVDLFNBQVMsS0FBSzZDLGFBQWEsRUFBRTtJQUVqR3ZCLFdBQVcsQ0FBQ0gsT0FBTyxHQUFHSyxRQUFRO0lBQzlCRCxZQUFZLENBQUNKLE9BQU8sR0FBR00sU0FBUztJQUVoQztJQUNBbkIsWUFBWSxDQUFDYSxPQUFPLENBQUM2QixXQUFXLElBQzVCMUIsV0FBVyxDQUFDSCxPQUFPLElBQUlLLFFBQVEsSUFDL0JsQixZQUFZLENBQUNhLE9BQU8sQ0FBQzZCLFdBQVcsQ0FBQ3hCLFFBQVEsQ0FBQztJQUU5Q25GLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztFQUVwQyxDQUFDLEVBQUMsRUFBRSxDQUFDO0VBRUw7RUFFQSxJQUFNNEcsVUFBVSxHQUFHLElBQUE5SSxPQUFBLENBQUFpRyxNQUFNLEVBQUMsSUFBSSxDQUFDO0VBRS9CLElBQUFqRyxPQUFBLENBQUFvSSxTQUFTLEVBQUMsWUFBSztJQUVYLFFBQVFuRyxhQUFhO01BRWpCLEtBQUssT0FBTztRQUNSO1FBQ0FnRixXQUFXLENBQUNELE9BQU8sR0FBR0MsV0FBVyxDQUFDRCxPQUFPLENBQUMrQixnQkFBZ0IsQ0FBQ2pDLG9CQUFvQixDQUFDRSxPQUFPLENBQUM7UUFDeEY4QixVQUFVLENBQUM5QixPQUFPLEdBQUdDLFdBQVcsQ0FBQ0QsT0FBTyxDQUFDZ0MsT0FBTyxFQUFDO1FBRWpELElBQUk5QixpQkFBaUIsQ0FBQ0YsT0FBTyxFQUFFO1VBQUU7VUFFN0JDLFdBQVcsQ0FBQ0QsT0FBTyxDQUFDaUMsd0JBQXdCLEdBQUcvQixpQkFBaUIsQ0FBQ0YsT0FBTzs7TUFJaEYsS0FBSyxjQUFjO1FBQ2Y5RSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7O0lBSWpDLE9BQU8sWUFBSztNQUVSLElBQUksQ0FBQ2lHLFlBQVksQ0FBQ25CLE9BQU8sRUFBRTtRQUV2QkMsV0FBVyxDQUFDRCxPQUFPLENBQUNrQyxrQkFBa0IsQ0FBQ0osVUFBVSxDQUFDOUIsT0FBTyxDQUFDOztJQUlsRSxDQUFDO0VBRUwsQ0FBQyxFQUFDLENBQUMvRSxhQUFhLENBQUMsQ0FBQztFQUVsQjtFQUVBLElBQUlxRCxRQUFRLElBQUlSLGtCQUFrQixFQUFFO0lBQ2hDLE9BQU85RSxPQUFBLFlBQUFlLGFBQUEsb0NBQThCOztFQUd6QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUVBLE9BQU9mLE9BQUEsWUFBQWUsYUFBQSxDQUFBZixPQUFBLFlBQUFtSixRQUFBLFFBQUlsSCxhQUFhLElBQUksT0FBTyxJQUFLakMsT0FBQSxZQUFBZSxhQUFBLENBQUNPLFVBQUEsV0FBUTtJQUV6Q3lFLFNBQVMsRUFBS0MsWUFBWSxDQUFDZ0IsT0FBTztJQUNsQzdDLE1BQU0sRUFBSytCLFNBQVMsQ0FBQ2MsT0FBTztJQUM1QkQsVUFBVSxFQUFLQSxVQUFVO0lBQ3pCUCx1QkFBdUIsRUFBS0E7RUFBdUIsR0FJbER4RyxPQUFBLFlBQUFlLGFBQUEsQ0FBQ1MsYUFBQSxXQUFXO0lBRVR1RSxTQUFTLEVBQUtDLFlBQVksQ0FBQ2dCLE9BQU87SUFDbEM3QyxNQUFNLEVBQUsrQixTQUFTLENBQUNjLE9BQU87SUFDNUI7SUFDQVUsZ0JBQWdCLEVBQUlHLG1CQUFtQixDQUFDYixPQUFPO0lBQy9DRCxVQUFVLEVBQUtBO0VBQVUsR0FHekIvRyxPQUFBLFlBQUFlLGFBQUEsQ0FBQ1UsUUFBQSxXQUFNO0lBRUhzRSxTQUFTLEVBQUtDLFlBQVksQ0FBQ2dCLE9BQU87SUFDbEM3QyxNQUFNLEVBQUsrQixTQUFTLENBQUNjLE9BQU87SUFDNUI7SUFDQVUsZ0JBQWdCLEVBQUlHLG1CQUFtQixDQUFDYixPQUFPO0lBQy9DcUIsbUJBQW1CLEVBQUtBLG1CQUFtQjtJQUMzQzNFLEtBQUssRUFBS0EsS0FBSztJQUNmRSxRQUFRLEVBQUtBLFFBQVE7SUFDckJ3RixhQUFhLEVBQUtqRCxZQUFZLENBQUNhLE9BQU87SUFDdEN4RCxhQUFhLEVBQUtBLGFBQWE7SUFDL0JmLE9BQU8sRUFBS0EsT0FBTztJQUNuQm9CLFdBQVcsRUFBS0EsV0FBVztJQUMzQlEsbUJBQW1CLEVBQUsrQixzQkFBc0IsQ0FBQ1ksT0FBTztJQUN0RDFELFVBQVUsRUFBS0EsVUFBVTtJQUN6QmlELGlCQUFpQixFQUFLQSxpQkFBaUI7SUFDdkMxQixrQkFBa0IsRUFBS0Esa0JBQWtCO0lBRXpDRixRQUFRLEVBQUtzQyxXQUFXLENBQUNELE9BQU87SUFDaENqRCxjQUFjLEVBQUtBLGNBQWM7SUFDakNFLGdCQUFnQixFQUFLQSxnQkFBZ0I7SUFDckNxQyxRQUFRLEVBQUtBLFFBQVE7SUFDckJHLHFCQUFxQixFQUFLQSxxQkFBcUI7SUFDL0NDLG9CQUFvQixFQUFLQSxvQkFBb0I7SUFDN0NFLGtCQUFrQixFQUFLQSxrQkFBa0I7SUFDekNELDZCQUE2QixFQUFLQSw2QkFBNkI7SUFDL0RJLFVBQVUsRUFBS0E7RUFBVSxFQUUzQixDQUNRLENBQ1AsRUFDWC9HLE9BQUEsWUFBQWUsYUFBQSxjQUNDbUgsYUFBYSxJQUFJbEksT0FBQSxZQUFBZSxhQUFBO0lBQUEsYUFBaUIsV0FBVztJQUFDRSxLQUFLLEVBQUtvSTtFQUFjLEdBQ25FckosT0FBQSxZQUFBZSxhQUFBLENBQUNXLGFBQUEsV0FBVztJQUVScUcsV0FBVyxFQUFLQSxXQUFXO0lBQzNCQyxpQkFBaUIsRUFBS0EsaUJBQWlCO0lBQ3ZDbkIsb0JBQW9CLEVBQUtBO0VBQW9CLEVBQUssQ0FFcEQsQ0FDQSxDQUNIO0VBQ1A7QUFDSixDQUFDOztBQUVEbkcsa0JBQUEsR0FBZWtCLG9CQUFvQjtBQUVuQztBQUVBLElBQU15SCxjQUFjLEdBQUc7RUFBQ0MsT0FBTyxFQUFDO0FBQU0sQ0FBQztBQUV2QztBQUNBLFNBQVN4QixZQUFZQSxDQUFFeUIsSUFBSSxFQUFDQyxJQUFJO0VBQzVCLElBQUksQ0FBQ0QsSUFBSSxJQUFJLENBQUNDLElBQUksRUFBRSxPQUFPLEtBQUs7RUFDaEMsSUFBTUMsSUFBSSxHQUFHdEwsTUFBTSxDQUFDc0wsSUFBSSxDQUFDRixJQUFJLENBQUM7RUFDOUIsU0FBQUcsR0FBQSxNQUFBQyxLQUFBLEdBQWtCRixJQUFJLEVBQUFDLEdBQUEsR0FBQUMsS0FBQSxDQUFBN0ssTUFBQSxFQUFBNEssR0FBQSxJQUFFO0lBQW5CLElBQU1FLEdBQUcsR0FBQUQsS0FBQSxDQUFBRCxHQUFBO0lBQ1YsSUFBSSxDQUFDdkwsTUFBTSxDQUFDMEwsRUFBRSxDQUFDTixJQUFJLENBQUNLLEdBQUcsQ0FBQyxFQUFDSixJQUFJLENBQUNJLEdBQUcsQ0FBQyxDQUFDLEVBQUU7TUFDakMsT0FBTyxLQUFLOzs7RUFHcEIsT0FBTyxJQUFJO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL0luZmluaXRlR3JpZFNjcm9sbGVyLnRzeD83ZjZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEluZmluaXRlR3JpZFNjcm9sbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICByZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyID0gUklHU1xuXG4gICAgVGhlIGpvYiBvZiBJbmZpbml0ZUdyaWRTY3JvbGxlciBpcyB0byBwYXNzIHBhcmFtZXRlcnMgdG8gZGVwZW5kZW50cy5cbiAgICBWaWV3cG9ydCBjb250YWlucyB0aGUgU2Nyb2xsYmxvY2ssIHdoaWNoIGlzIGZ1bGwgc2l6ZSBmb3IgbGlzdHNpemUgb2YgZ2l2ZW4gY2VsbCBoZWlnaHQvd2lkdGguXG4gICAgU2Nyb2xsYmxvY2sgaW4gdHVybiBjb250YWlucyB0aGUgQ3JhZGxlIC0gYSBjb21wb25lbnQgdGhhdCBjb250YWlucyBDZWxsRnJhbWVzLCB3aGljaCBjb250YWluIFxuICAgIGRpc3BsYXllZCB1c2VyIGNvbnRlbnQgKGl0ZW1zKSBvciB0cmFuc2l0aW9uYWwgcGxhY2Vob2xkZXJzLiBcblxuICAgIEhvc3QgY29udGVudCBpcyBpbnN0YW50aWF0ZWQgaW4gYSBjYWNoZSBvZiBSZWFjdCBwb3J0YWxzICh2aWEgY2FjaGVBUEkpLiBDb250ZW50IGlzIHRoZW4gXG4gICAgcG9ydGFsJ2QgdG8gQ2VsbEZyYW1lcy4gVGhlIGNhY2hlIGNhbiBiZSBjb25maWd1cmVkIHRvIGhvbGQgbW9yZSBpdGVtcyB0aGFuIHRoZSBDcmFkbGUgKGxpbWl0ZWQgYnkgXG4gICAgZGV2aWNlIG1lbW9yeSkuIENhY2hpbmcgYWxsb3dzIGhvc3QgY29udGVudCB0byBtYWludGFpbiBzdGF0ZS5cblxuICAgIFNjcm9sbGJsb2NrIHJlcHJlc2VudHMgdGhlIGVudGlyZXR5IG9mIHRoZSBsaXN0IChhbmQgaXMgc2l6ZWQgYWNjb3JkaW5nbHkpLiBJdCBpcyB0aGUgb2JqZWN0IHRoYXQgaXMgc2Nyb2xsZWQuXG5cbiAgICBDcmFkbGUgY29udGFpbnMgdGhlIGxpc3QgaXRlbXMsIGFuZCBpcyAndmlydHVhbGl6ZWQnIC0tIGl0IGFwcGVhcnMgYXMgdGhvdWdoIGl0IHNjcm9sbHMgdGhyb3VnaCBhIGZpbGxlZCBcbiAgICBzY3JvbGxibG9jaywgYnV0IGluIGZhY3QgaXQgaXMgb25seSBzbGlnaHRseSBsYXJnZXIgdGhhbiB0aGUgdmlld3BvcnQuIENvbnRlbnQgaXMgcm90YXRlZCBpbiBhbmQgb3V0IG9mIHRoZSBcbiAgICBjcmFkbGUgdGhyb3VnaCB0aGUgY2FjaGUuXG4gICAgXG4gICAgSW5kaXZpZHVhbCBob3N0IGl0ZW1zIGFyZSBmcmFtZWQgYnkgQ2VsbEZyYW1lLCB3aGljaCBhcmUgbWFuYWdlZCBieSBDcmFkbGUuXG5cbiAgICBPdmVyYWxsIHRoZSBJbmZpbml0ZUdyaWRTY3JvbGxlciBhcyBhIHBhY2thZ2UgbWFuYWdlcyB0aGUgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBvZiB0aGUgXG4gICAgY29tcG9uZW50cyBvZiB0aGUgbWVjaGFuaXNtLiBNb3N0IG9mIHRoZSB3b3JrIG9jY3VycyBpbiB0aGUgQ3JhZGxlIGNvbXBvbmVudC5cblxuICAgIFRoZSBSaWdzIGxpbmVyICh0aGUgdG9wIGxldmVsIFZpZXdwb3J0IGVsZW1lbnQpIGlzIHNldCB3aXRoICdkaXNwbGF5OmFic29sdXRlJyBhbmQgJ2luc2V0OjAnLCBzbyB0aGUgdXNlciBcbiAgICBjb250YWluaW5nIGJsb2NrIHNob3VsZCBiZSBzdHlsZXMgYWNjb3JkaW5nbHkuXG4qL1xuXG4vKlxuXG5UT0RPOlxuXG4tIGFkZCBzdGFydGluZ0xpc3RSYW5nZSBwcm9wZXJ0eSAoMiBwYXJ0IGFycmF5KTsgc2V0TGlzdFJhbmdlIEFQSSBmdW5jdGlvblxuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBkZWZlbnNpdmVcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICdyZWFjdC1lcnJvci1ib3VuZGFyeScgLy8gd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LWVycm9yLWJvdW5kYXJ5XG5cbmV4cG9ydCBjb25zdCBpc1NhZmFyaUlPUyA9ICgpID0+IHtcbiAgICBjb25zdFxuICAgICAgICBpc19pb3MgPSAvaVAoYWR8b2R8aG9uZSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgaXNfc2FmYXJpID0gISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvW1xcZFxcLl0rLipTYWZhcmkvKVxuICAgIHJldHVybiAoIGlzX2lvcyAmJiBpc19zYWZhcmkgKSBcbn1cblxuLy8gYmFzZWQgb24gbW9kdWxlIHRlbXBsYXRlXG5mdW5jdGlvbiBFcnJvckZhbGxiYWNrKHtlcnJvciwgcmVzZXRFcnJvckJvdW5kYXJ5fSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgcm9sZT1cImFsZXJ0XCIgc3R5bGUgPSB7e21hcmdpbjonM3B4J319PlxuICAgICAgPHA+U29tZXRoaW5nIHdlbnQgd3JvbmcgaW5zaWRlIHJlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIuIFNlZSB0aGUgY29uc29sZSBmb3IgZGV0YWlscy48L3A+XG4gICAgICA8cD5DbGljayB0byBjYW5jZWwgdGhlIGVycm9yIGFuZCB0cnkgdG8gY29udGludWUuPC9wPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICBzdHlsZSA9IHt7Ym9yZGVyOicxcHggc29saWQgYmxhY2snLCBtYXJnaW46JzNweCcsIHBhZGRpbmc6JzNweCd9fSBcbiAgICAgICAgICBvbkNsaWNrID0geyByZXNldEVycm9yQm91bmRhcnkgfVxuICAgICAgPlxuICAgICAgICAgIENhbmNlbCBlcnJvclxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuLy8gc2Nyb2xsZXIgY29tcG9uZW50c1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vVmlld3BvcnQnXG5pbXBvcnQgU2Nyb2xsYmxvY2sgZnJvbSAnLi9TY3JvbGxibG9jaydcbmltcG9ydCBDcmFkbGUgZnJvbSAnLi9DcmFkbGUnXG5cbi8vIGxvYWRlZCBoZXJlIHRvIG1pbmltaXplIHJlZHVuZGFudCByZW5kZXJzIGluIENyYWRsZVxuaW1wb3J0IFBvcnRhbENhY2hlIGZyb20gJy4vUG9ydGFsQ2FjaGUnXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1bIGdsb2JhbCBzZXNzaW9uIElEIGdlbmVyYXRvciBdLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgZ2xvYmFsU2Nyb2xsZXJJRCA9IDBcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1bIElOSVRJQUxJWkUgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBJbmZpbml0ZUdyaWRTY3JvbGxlciA9IChwcm9wcykgPT4ge1xuXG4gICAgLy8gc3RhdGVcbiAgICBjb25zdCBbc2Nyb2xsZXJTdGF0ZSwgc2V0U2Nyb2xsZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKSAvLyBzZXR1cCwgc2V0bGlzdHByb3BzLCByZWFkeVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tWyBub3JtYWxpemUgcHJvcGVydGllcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCB7IFxuXG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIGNlbGxIZWlnaHQsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgaGVpZ2h0IC0gbGl0ZXJhbCBmb3IgdmVydGljYWw7IGFwcHJveGltYXRlIGZvciBob3Jpem9udGFsXG4gICAgICAgICAgICAvLyBtYXggZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICBjZWxsV2lkdGgsIC8vIHJlcXVpcmVkLiB0aGUgb3V0ZXIgcGl4ZWwgd2lkdGggLSBsaXRlcmFsIGZvciBob3Jpem9udGFsOyBhcHByb3hpbWF0ZSBmb3IgdmVydGljYWxcbiAgICAgICAgICAgIC8vIG1heCBmb3IgdmFyaWFibGUgbGF5b3V0XG4gICAgICAgIHN0YXJ0aW5nTGlzdFNpemUgPSAwLCAvLyB0aGUgc3RhcmdpbmcgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB2aXJ0dWFsIGxpc3QuIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHN0YXJ0aW5nTGlzdFJhbmdlID0gbnVsbCxcbiAgICAgICAgc3RhcnRpbmdMaXN0UmFuZ2UgPSBbLTM1MCwyNDNdLFxuICAgICAgICBnZXRJdGVtLCAvLyByZXF1aXJlZC4gZnVuY3Rpb24gcHJvdmlkZWQgYnkgaG9zdCAtIHBhcmFtZXRlcnMgc2V0IGJ5IHN5c3RlbSBhcmUgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAvLyBhbmQgc2Vzc2lvbiBpdGVtSUQgZm9yIHRyYWNraW5nIGFuZCBtYXRjaGluZzsgXG4gICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaG9zdC1zZWxlY3RlZCBjb21wb25lbnQgb3IgcHJvbWlzZSBvZiBhIGNvbXBvbmVudCwgb3IgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICAvLyBncmlkIHNwZWNzOlxuICAgICAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsIC8vIHZlcnRpY2FsIG9yIGhvcml6b250YWxcbiAgICAgICAgZ2FwID0gMCwgLy8gc3BhY2UgYmV0d2VlbiBncmlkIGNlbGxzLCBub3QgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG4gICAgICAgIHBhZGRpbmcgPSAwLCAvLyB0aGUgYm9yZGVyIHNwYWNlIGJldHdlZW4gdGhlIGl0ZW1zIGFuZCB0aGUgdmlld3BvcnQsIGFwcGxpZWQgdG8gdGhlIGNyYWRsZVxuICAgICAgICBsYXlvdXQgPSAndW5pZm9ybScsIC8vIHVuaWZvcm0sIHZhcmlhYmxlXG4gICAgICAgIGNlbGxNaW5IZWlnaHQgPSAyNSwgLy8gZm9yIGxheW91dCA9PSAndmFyaWFibGUnICYmIG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCdcbiAgICAgICAgY2VsbE1pbldpZHRoID0gMjUsIC8vIGZvciBsYXlvdXQgPT0gJ3ZhcmlhYmxlJyAmJiBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAvLyBzY3JvbGxlciBzcGVjczpcbiAgICAgICAgcnVud2F5U2l6ZSA9IDMsIC8vIHRoZSBudW1iZXIgb2Ygcm93cyBvdXRzaWRlIHRoZSB2aWV3IG9mIGVhY2ggc2lkZSBvZiB0aGUgdmlld3BvcnQgXG4gICAgICAgICAgICAvLyAtLSBnaXZlcyB0aW1lIHRvIGFzc2VtYmxlIGNlbGxGcmFtZXMgYmVmb3JlIGRpc3BsYXlcbiAgICAgICAgc3RhcnRpbmdJbmRleCA9IDAsIC8vIHRoZSAwLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBsaXN0LCB3aGVuIGZpcnN0IGxvYWRlZFxuXG4gICAgICAgIC8vIHN5c3RlbSBzcGVjczpcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJywgLy8gXCJwcmVsb2FkXCIsIFwia2VlcGxvYWRcIiBvciBcImNyYWRsZVwiXG4gICAgICAgIGNhY2hlTWF4ID0gbnVsbCwgLy8gYWx3YXlzIG1pbmltdW0gY3JhZGxlIGNvbnRlbnQgc2l6ZTsgZmFsc2V5IG1lYW5zIGxpbWl0ZWQgYnkgbGlzdHNpemVcbiAgICAgICAgcGxhY2Vob2xkZXIsIC8vIG9wdGlvbmFsLiBhIHNwYXJzZSBjb21wb25lbnQgdG8gc3RhbmQgaW4gZm9yIGNvbnRlbnQgdW50aWwgdGhlIGNvbnRlbnQgYXJyaXZlczsgXG4gICAgICAgICAgICAvLyByZXBsYWNlcyBkZWZhdWx0IHBsYWNlaG9sZGVyIGlmIHByZXNlbnRcbiAgICAgICAgdXNlUGxhY2Vob2xkZXIgPSB0cnVlLCAvLyBubyBwbGFjZWhvbGRlciByZW5kZXJlZCBpZiBmYWxzZVxuICAgICAgICB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZSwgLy8gdGhlIGludGVybmFsIGNvbXBvbmVudCB0byBnaXZlIGZlZWRiYWNrIGZvciByZXBvc2l0aW9uaW5nXG5cbiAgICAgICAgLy8gYWR2YW5jZWQgb2JqZWN0c1xuICAgICAgICBzdHlsZXMgPSB7fSwgLy8gb3B0aW9uYWwuIHBhc3NpdmUgc3R5bGUgb3Zlci1yaWRlcyAoZWcuIGNvbG9yLCBvcGFjaXR5KTsgaGFzIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB2aWV3cG9ydCwgc2Nyb2xsYmxvY2ssIGNyYWRsZSwgc2Nyb2xsdHJhY2tlciwgcGxhY2Vob2xkZXJmcmFtZSwgXG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlcmVycm9yZnJhbWUsIHBsYWNlaG9sZGVybGluZXIgb3IgcGxhY2Vob2xkZXJlcnJvcmxpbmVyLiBEbyBub3QgbWFrZSBzdHJ1Y3R1cmFsIGNoYW5nZXMhXG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMgPSB7fSwgLy8gbWVzc2FnZXMgcHJlc2VudGVkIGJ5IGRlZmF1bHQgcGxhY2Vob2xkZXIuIFNlZSBkb2N1bWVudGF0aW9uXG4gICAgICAgIGNhbGxiYWNrcyA9IHt9LCAvLyBvcHRpb25hbC4gY2xvc3VyZXMgdG8gZ2V0IGRpcmVjdCBpbmZvcm1hdGlvbiBzdHJlYW1zIG9mIHNvbWUgY29tcG9uZW50IHV0aWxpdGVzXG4gICAgICAgICAgICAvLyBjYW4gY29udGFpbiBmdW5jdGlvbnNDYWxsYmFjaywgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGludGVybmFsIHNjcm9sbGVyIGZ1bmN0aW9ucyBcbiAgICAgICAgICAgIC8vKG1vc3RseSBjYWNoZSBtYW5hZ2VtZW50KVxuICAgICAgICB0ZWNobmljYWwgPSB7fSwgLy8gb3B0aW9uYWwuIHRlY2huaWNhbCBzZXR0aW5ncyBsaWtlIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUXG4gICAgICAgIGNhY2hlQVBJID0gbnVsbCxcbiAgICAgICAgZHJhZ2Ryb3BQcm9wZXJ0aWVzLCAvLyBwbGFjZWhvbGRlciFcblxuICAgICAgICAvLyBpbmZvcm1hdGlvbiBmb3IgaG9zdCBjZWxsIGNvbnRlbnRcbiAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzLCAvLyByZXF1aXJlZCBmb3IgZW1iZWRkZWQgc2Nyb2xsZXI7IHNoYXJlcyBzY3JvbGxlciBzZXR0aW5ncyB3aXRoIGNvbnRlbnRcblxuICAgIH0gPSBwcm9wc1xuXG4gICAgbGV0IGlzTWluaW1hbFByb3BzRmFpbCA9IGZhbHNlXG4gICAgaWYgKCEoY2VsbFdpZHRoICYmIGNlbGxIZWlnaHQgJiYgZ2V0SXRlbSApKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSSUdTOiBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGFuZCBnZXRJdGVtIGFyZSByZXF1aXJlZCcpXG4gICAgICAgIGlzTWluaW1hbFByb3BzRmFpbCA9IHRydWVcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIERhdGEgc2V0dXAgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWVzID0ge1xuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBzdGFydGluZ0luZGV4LFxuICAgICAgICBzdGFydGluZ0xpc3RTaXplLFxuICAgICAgICBydW53YXlTaXplLFxuICAgICAgICBjYWNoZU1heCxcbiAgICB9XG5cbiAgICAvLyBhdm9pZCBudWxsL3VuZGVmaW5lZFxuICAgIHN0eWxlcyA9IHN0eWxlcyA/PyB7fVxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyA/PyB7fVxuICAgIHRlY2huaWNhbCA9IHRlY2huaWNhbCA/PyB7fVxuICAgIHN0YXJ0aW5nSW5kZXggPSBzdGFydGluZ0luZGV4ID8/IDBcbiAgICBzdGFydGluZ0xpc3RTaXplID0gc3RhcnRpbmdMaXN0U2l6ZSA/PyAwXG4gICAgcnVud2F5U2l6ZSA9IHJ1bndheVNpemUgPz8gM1xuICAgIHVzZVBsYWNlaG9sZGVyID0gdXNlUGxhY2Vob2xkZXIgPz8gdHJ1ZVxuICAgIHVzZVNjcm9sbFRyYWNrZXIgPSB1c2VTY3JvbGxUcmFja2VyID8/IHRydWVcbiAgICBjZWxsTWluSGVpZ2h0ID0gY2VsbE1pbkhlaWdodCA/PyAwXG4gICAgY2VsbE1pbldpZHRoID0gY2VsbE1pbldpZHRoID8/IDBcbiAgICBjYWNoZU1heCA9IGNhY2hlTWF4ID8/IDBcblxuICAgIGNlbGxIZWlnaHQgPSArY2VsbEhlaWdodFxuICAgIGNlbGxXaWR0aCA9ICtjZWxsV2lkdGhcbiAgICBjZWxsTWluSGVpZ2h0ID0gK2NlbGxNaW5IZWlnaHRcbiAgICBjZWxsTWluV2lkdGggPSArY2VsbE1pbldpZHRoXG4gICAgZ2FwID0gK2dhcFxuICAgIHBhZGRpbmcgPSArcGFkZGluZ1xuICAgIHN0YXJ0aW5nSW5kZXggPSArc3RhcnRpbmdJbmRleFxuICAgIHN0YXJ0aW5nTGlzdFNpemUgPSArc3RhcnRpbmdMaXN0U2l6ZVxuICAgIHJ1bndheVNpemUgPSArcnVud2F5U2l6ZVxuICAgIGNhY2hlTWF4ID0gK2NhY2hlTWF4XG5cbiAgICBjb25zdCB2ZXJpZmllZFZhbHVlcyA9IHtcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBjZWxsTWluSGVpZ2h0LFxuICAgICAgICBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgc3RhcnRpbmdJbmRleCxcbiAgICAgICAgc3RhcnRpbmdMaXN0U2l6ZSxcbiAgICAgICAgcnVud2F5U2l6ZSxcbiAgICAgICAgY2FjaGVNYXgsICAgICAgICBcbiAgICB9XG5cbiAgICBjZWxsTWluSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbE1pbkhlaWdodCwgMjUpXG4gICAgY2VsbE1pbldpZHRoID0gTWF0aC5tYXgoY2VsbE1pbldpZHRoLCAyNSlcbiAgICBjZWxsTWluSGVpZ2h0ID0gTWF0aC5taW4oY2VsbEhlaWdodCwgY2VsbE1pbkhlaWdodClcbiAgICBjZWxsTWluV2lkdGggPSBNYXRoLm1pbihjZWxsV2lkdGgsIGNlbGxNaW5XaWR0aClcblxuICAgIC8vIHByb3AgY29uc3RyYWludHMgLSBub24tbmVnYXRpdmUgdmFsdWVzXG4gICAgcnVud2F5U2l6ZSA9IE1hdGgubWF4KDEscnVud2F5U2l6ZSkgLy8gcnVud2F5c2l6ZSBtdXN0IGJlIGF0IGxlYXN0IDFcbiAgICBzdGFydGluZ0xpc3RTaXplID0gTWF0aC5tYXgoMCxzdGFydGluZ0xpc3RTaXplKVxuICAgIHN0YXJ0aW5nSW5kZXggPSBNYXRoLm1heCgwLHN0YXJ0aW5nSW5kZXgpXG5cbiAgICAvLyBwYWNrYWdlXG4gICAgbGV0IHByb2JsZW1zID0gMFxuICAgIGZvciAoY29uc3QgcHJvcCBpbiB2ZXJpZmllZFZhbHVlcykge1xuICAgICAgICBpZiAoaXNOYU4odmVyaWZpZWRWYWx1ZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICBwcm9ibGVtcysrXG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgaWYgKHByb2JsZW1zKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiBpbnZhbGlkIG51bWJlciAtIGNvbXBhcmUgb3JpZ2luYWxWYWx1ZXMgYW5kIHZlcmlmaWVkVmFsdWVzJywgXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlcywgdmVyaWZpZWRWYWx1ZXMpXG4gICAgfVxuXG4gICAgLy8gcmF0aW9uYWxpemUgc3RhcnRpbmdMaXN0c2l6ZSBhbmQgc3RhcnRpbmdMaXN0UmFuZ2VcbiAgICBpZiAoIXByb2JsZW1zICYmIHNjcm9sbGVyU3RhdGUgPT0gJ3NldHVwJykge1xuXG4gICAgICAgIGxldCBnb29kcmFuZ2UgPSB0cnVlXG4gICAgICAgIGlmICghc3RhcnRpbmdMaXN0UmFuZ2UgfHwgIUFycmF5LmlzQXJyYXkoc3RhcnRpbmdMaXN0UmFuZ2UpIHx8ICEoc3RhcnRpbmdMaXN0UmFuZ2UubGVuZ3RoID09IDIpKSB7XG4gICAgICAgICAgICBnb29kcmFuZ2UgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGlmIChnb29kcmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbbG93aW5kZXgsaGlnaGluZGV4XSA9IHN0YXJ0aW5nTGlzdFJhbmdlXG4gICAgICAgICAgICBsb3dpbmRleCA9ICtsb3dpbmRleFxuICAgICAgICAgICAgaGlnaGluZGV4ID0gK2hpZ2hpbmRleFxuICAgICAgICAgICAgaWYgKGlzTmFOKGxvd2luZGV4KSB8fCBpc05hTihoaWdoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgZ29vZHJhbmdlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG93aW5kZXggPiBoaWdoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBnb29kcmFuZ2UgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvb2RyYW5nZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGlzdFNpemUgPSBoaWdoaW5kZXggLSBsb3dpbmRleCArIDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdvb2RyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nTGlzdFNpemUpIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xpc3RSYW5nZSA9IFswLHN0YXJ0aW5nTGlzdFNpemUgLSAxXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xpc3RSYW5nZSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVudW1zXG4gICAgaWYgKCFbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddLmluY2x1ZGVzKG9yaWVudGF0aW9uKSkgeyBcbiAgICAgICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnXG4gICAgfVxuICAgIGlmICghWydwcmVsb2FkJywna2VlcGxvYWQnLCdjcmFkbGUnXS5pbmNsdWRlcyhjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUgPSAnY3JhZGxlJ1xuICAgIH1cbiAgICBpZiAoIVsndW5pZm9ybScsICd2YXJpYWJsZSddLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgbGF5b3V0ID0gJ3VuaWZvcm0nXG4gICAgfVxuXG4gICAgY29uc3QgZ3JpZFNwZWNzID0ge1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgbGF5b3V0LFxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRTcGVjc1JlZiA9IHVzZVJlZihncmlkU3BlY3MpXG5cbiAgICAvLyBzeXN0ZW1cbiAgICBjb25zdCBzdHlsZXNSZWYgPSB1c2VSZWYoc3R5bGVzKVxuICAgIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZihjYWxsYmFja3MpXG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNzYWdlc1JlZiA9IHVzZVJlZihwbGFjZWhvbGRlck1lc3NhZ2VzKVxuXG4gICAgbGV0IHtcblxuICAgICAgICBzaG93QXhpcywgLy8gYm9vbGVhbjsgYXhpcyBjYW4gYmUgbWFkZSB2aXNpYmxlIGZvciBkZWJ1Z1xuICAgICAgICB0cmlnZ2VybGluZU9mZnNldCwgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGhlYWQgb3IgdGFpbCBmb3IgY29udGVudCBzaGlmdHMgYWJvdmUvYmVsb3cgYXhpc1xuICAgICAgICAvLyB0aW1lb3V0c1xuICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCxcbiAgICAgICAgT05BRlRFUlNDUk9MTF9USU1FT1VULFxuICAgICAgICBJRExFQ0FMTEJBQ0tfVElNRU9VVCxcbiAgICAgICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQsXG4gICAgICAgIC8vIHJhdGlvczpcbiAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOLCAvLyBtYXggc3RyZWFtaW5nIG92ZXItcnVuIGFzIHJhdGlvIHRvIGNhY2hlTWF4XG4gICAgICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFLCBcblxuICAgIH0gPSB0ZWNobmljYWxcblxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VUID0gVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgPz8gMjUwXG4gICAgT05BRlRFUlNDUk9MTF9USU1FT1VUID0gT05BRlRFUlNDUk9MTF9USU1FT1VUID8/IDEwMFxuICAgIElETEVDQUxMQkFDS19USU1FT1VUID0gSURMRUNBTExCQUNLX1RJTUVPVVQgPz8gMjUwXG4gICAgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgPSBWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCA/PyAyNTBcbiAgICBcbiAgICBNQVhfQ0FDSEVfT1ZFUl9SVU4gPSBNQVhfQ0FDSEVfT1ZFUl9SVU4gPz8gMS41XG4gICAgQ0FDSEVfUEFSVElUSU9OX1NJWkUgPSBDQUNIRV9QQVJUSVRJT05fU0laRSA/PyAzMFxuXG4gICAgaWYgKHR5cGVvZiBzaG93QXhpcyAhPSAnYm9vbGVhbicpIHNob3dBeGlzID0gZmFsc2VcblxuICAgIHRyaWdnZXJsaW5lT2Zmc2V0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgPz8gMTBcblxuICAgIGlmICh0eXBlb2YgdXNlUGxhY2Vob2xkZXIgIT0gJ2Jvb2xlYW4nKSB1c2VQbGFjZWhvbGRlciA9IHRydWVcbiAgICBpZiAodHlwZW9mIHVzZVNjcm9sbFRyYWNrZXIgIT0gJ2Jvb2xlYW4nKSB1c2VTY3JvbGxUcmFja2VyID0gdHJ1ZVxuXG4gICAgLy8gZm9yIG1vdW50IHZlcnNpb25cbiAgICBjb25zdCBzY3JvbGxlclNlc3Npb25JRFJlZiA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHNjcm9sbGVySUQgPSBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50XG5cbiAgICAvLyBmb3IgY2hpbGRyZW5cbiAgICBjb25zdCBjYWNoZUFQSVJlZiA9IHVzZVJlZihjYWNoZUFQSSlcblxuICAgIGNvbnN0IHVwZGF0ZUZ1bmN0aW9uUmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICBjb25zdCBsaXN0c2l6ZVJlZiA9IHVzZVJlZihzdGFydGluZ0xpc3RTaXplKVxuICAgIGNvbnN0IGxpc3RSYW5nZVJlZiA9IHVzZVJlZihzdGFydGluZ0xpc3RSYW5nZSlcblxuICAgIGNvbnN0IGxpc3RzaXplID0gbGlzdHNpemVSZWYuY3VycmVudFxuICAgIGNvbnN0IGxpc3RyYW5nZSA9IGxpc3RSYW5nZVJlZi5jdXJyZW50XG4gICAgY29uc3QgW2xvd2xpc3RyYW5nZSwgaGlnaGxpc3RyYW5nZV0gPSBsaXN0cmFuZ2UgLy8gcmFuZ2VzIHVuZGVmaW5lZCBpZiBsaXN0cmFuZ2UgaXMgbnVsbFxuXG4gICAgY29uc3QgdmlydHVhbExpc3RTcGVjcyA9IHtcbiAgICAgICAgc2l6ZTpsaXN0c2l6ZSxcbiAgICAgICAgcmFuZ2U6bGlzdHJhbmdlLFxuICAgICAgICBsb3dpbmRleDpsb3dsaXN0cmFuZ2UsXG4gICAgICAgIGhpZ2hpbmRleDpoaWdobGlzdHJhbmdlLFxuICAgIH1cblxuICAgIGNvbnN0IHZpcnR1YWxMaXN0U3BlY3NSZWYgPSB1c2VSZWYodmlydHVhbExpc3RTcGVjcylcblxuICAgIGlmICghY29tcGFyZVByb3BzKHZpcnR1YWxMaXN0U3BlY3MsIHZpcnR1YWxMaXN0U3BlY3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgdmlydHVhbExpc3RTcGVjc1JlZi5jdXJyZW50ID0gdmlydHVhbExpc3RTcGVjc1xuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdsaXN0c2l6ZSwgbGlzdHJhbmdlLCB2aXJ0dWFsTGlzdFByb3BzJywgbGlzdHNpemUsIGxpc3RyYW5nZSwgdmlydHVhbExpc3RQcm9wcylcblxuICAgIC8vIHRlc3RzIGZvciBSZWFjdCB3aXRoIE9iamVjdC5pcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzOyBhdm9pZCByZS1yZW5kZXJzIHdpdGggbm8gY2hhbmdlXG4gICAgaWYgKCFjb21wYXJlUHJvcHMoZ3JpZFNwZWNzLCBncmlkU3BlY3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgZ3JpZFNwZWNzUmVmLmN1cnJlbnQgPSBncmlkU3BlY3NcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhzdHlsZXMsIHN0eWxlc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBzdHlsZXNSZWYuY3VycmVudCA9IHN0eWxlc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhjYWxsYmFja3MsIGNhbGxiYWNrc1JlZi5jdXJyZW50KSkge1xuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudCA9IGNhbGxiYWNrc1xuICAgIH1cbiAgICBpZiAoIWNvbXBhcmVQcm9wcyhwbGFjZWhvbGRlck1lc3NhZ2VzLCBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXNSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyTWVzc2FnZXNcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBJbml0aWFsaXphdGlvbiBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgZ2V0Q2FjaGVBUEkgPSAoY2FjaGVBUEkpID0+IHtcblxuICAgICAgICBjYWNoZUFQSVJlZi5jdXJyZW50ID0gY2FjaGVBUElcblxuICAgIH1cblxuICAgIGNvbnN0IGdldFVwZGF0ZUZ1bmN0aW9uID0gKGZuKSA9PiB7XG5cbiAgICAgICAgdXBkYXRlRnVuY3Rpb25SZWYuY3VycmVudCA9IGZuXG5cbiAgICB9XG5cbiAgICBjb25zdCB1c2VMb2NhbENhY2hlID0gIWNhY2hlQVBJXG5cbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgdXNlRWZmZWN0ICgoKSA9PiB7XG5cbiAgICAgICAgaWYgKHNjcm9sbGVyU2Vzc2lvbklEUmVmLmN1cnJlbnQgPT09IG51bGwpIHsgLy8gZGVmZW5kIGFnYWluc3QgUmVhY3QuU3RyaWN0TW9kZSBkb3VibGUgcnVuXG4gICAgICAgICAgICBzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50ID0gZ2xvYmFsU2Nyb2xsZXJJRCsrXG4gICAgICAgIH1cblxuICAgIH0sW10pO1xuXG4gICAgLy8gY2FsbGVkIHdoZW4gZ2V0SXRlbSByZXR1cm5zIG51bGwsIG9yIGRpcmVjdCBjYWxsIGZyb20gdXNlciAoc2VlIHNlcnZpY2VIYW5kbGVyKVxuICAgIGNvbnN0IHNldFZpcnR1YWxMaXN0U3BlY3MgPSB1c2VDYWxsYmFjaygobGlzdHNpemVhcmcpID0+e1xuXG4gICAgICAgIGxldCBsaXN0c2l6ZSwgbG93aW5kZXgsIGhpZ2hpbmRleCwgbGlzdHJhbmdlXG4gICAgICAgIGNvbnN0IFtwcmV2bG93cmFuZ2UsIHByZXZoaWdocmFuZ2VdID0gbGlzdFJhbmdlUmVmLmN1cnJlbnRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdHNpemVhcmcpKSB7XG4gICAgICAgICAgICBbbG93aW5kZXgsaGlnaGluZGV4XSA9IGxpc3RzaXplYXJnXG4gICAgICAgICAgICBsaXN0c2l6ZSA9IGhpZ2hpbmRleCAtIGxvd2luZGV4ICsgMVxuICAgICAgICAgICAgbGlzdHJhbmdlID0gbGlzdHNpemVhcmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RzaXplID0gbGlzdHNpemVhcmc7XG4gICAgICAgICAgICBbbG93aW5kZXgsaGlnaGluZGV4XSA9IGxpc3RSYW5nZVJlZi5jdXJyZW50XG4gICAgICAgICAgICBsaXN0cmFuZ2UgPSBbbG93aW5kZXgsbG93aW5kZXggKyBsaXN0c2l6ZSAtIDFdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdHNpemUgPT0gbGlzdHNpemVSZWYuY3VycmVudCAmJiBsb3dpbmRleCA9PT0gcHJldmxvd3JhbmdlICYmIGhpZ2hpbmRleCA9PT0gcHJldmhpZ2hyYW5nZSkgcmV0dXJuXG5cbiAgICAgICAgbGlzdHNpemVSZWYuY3VycmVudCA9IGxpc3RzaXplXG4gICAgICAgIGxpc3RSYW5nZVJlZi5jdXJyZW50ID0gbGlzdHJhbmdlXG5cbiAgICAgICAgLy8gaW5mb3JtIHRoZSB1c2VyXG4gICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm5ld0xpc3RzaXplICYmIFxuICAgICAgICAgICAgbGlzdHNpemVSZWYuY3VycmVudCAhPSBsaXN0c2l6ZSAmJlxuICAgICAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQubmV3TGlzdHNpemUobGlzdHNpemUpXG5cbiAgICAgICAgc2V0U2Nyb2xsZXJTdGF0ZSgnc2V0bGlzdHByb3BzJylcblxuICAgIH0sW10pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFN0YXRlIGhhbmRsaW5nIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IGl0ZW1TZXRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgc3dpdGNoIChzY3JvbGxlclN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzpcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGNhY2hlQVBJIHdpdGggZmFjYWRlIHdoaWNoIGluY2x1ZGVzIGhpZGRlbiBzY3JvbGxlcklEXG4gICAgICAgICAgICAgICAgY2FjaGVBUElSZWYuY3VycmVudCA9IGNhY2hlQVBJUmVmLmN1cnJlbnQucmVnaXN0ZXJTY3JvbGxlcihzY3JvbGxlclNlc3Npb25JRFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGl0ZW1TZXRSZWYuY3VycmVudCA9IGNhY2hlQVBJUmVmLmN1cnJlbnQuaXRlbVNldCAvLyBmb3IgdW5tb3VudCB1blJlZ2lzdGVyU2Nyb2xsZXJcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVGdW5jdGlvblJlZi5jdXJyZW50KSB7IC8vIG9idGFpbmVkIGZyb20gUG9ydGFsQ2FjaGVcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZUFQSVJlZi5jdXJyZW50LnBhcnRpdGlvblJlcG9Gb3JjZVVwZGF0ZSA9IHVwZGF0ZUZ1bmN0aW9uUmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnc2V0bGlzdHByb3BzJzpcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlclN0YXRlKCdyZWFkeScpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgIGNhY2hlQVBJUmVmLmN1cnJlbnQudW5SZWdpc3RlclNjcm9sbGVyKGl0ZW1TZXRSZWYuY3VycmVudClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sW3Njcm9sbGVyU3RhdGVdKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1bIFJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBpZiAocHJvYmxlbXMgfHwgaXNNaW5pbWFsUHJvcHNGYWlsKSB7XG4gICAgICAgIHJldHVybiA8ZGl2PmVycm9yOiBzZWUgY29uc29sZS48L2Rpdj4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudCBjYWxscyBhcmUgZGVmZXJyZWQgYnkgc2Nyb2xsZXJTdGF0ZSB0byBnaXZlIGNhY2hlQVBJIGEgY2hhbmNlIHRvIGluaXRpYWxpemVcbiAgICAvLyByZXR1cm4gPEVycm9yQm91bmRhcnlcbiAgICAvLyAgICAgRmFsbGJhY2tDb21wb25lbnQ9IHsgRXJyb3JGYWxsYmFjayB9XG4gICAgLy8gICAgIC8vIGVsYWJvcmF0aW9uIFRCRFxuICAgIC8vICAgICBvblJlc2V0ID0geyAoKSA9PiB7fSB9XG4gICAgLy8gICAgIG9uRXJyb3IgPSB7ICgpID0+IHt9IH1cbiAgICAvLyAgICAgLy8gb25FcnJvciA9IHsoZXJyb3I6IEVycm9yLCBpbmZvOiB7Y29tcG9uZW50U3RhY2s6IHN0cmluZ30pID0+IHtcbiAgICAvLyAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdyZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyIGNhcHR1cmVkIGVycm9yJywgZXJyb3IpXG4gICAgLy8gICAgIC8vIH19XG4gICAgLy8gPlxuXG4gICAgcmV0dXJuIDw+eyhzY3JvbGxlclN0YXRlICE9ICdzZXR1cCcpICYmIDxWaWV3cG9ydFxuXG4gICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgc2Nyb2xsZXJJRCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICBWSUVXUE9SVF9SRVNJWkVfVElNRU9VVCA9IHsgVklFV1BPUlRfUkVTSVpFX1RJTUVPVVQgfVxuXG4gICAgICAgID5cbiAgICAgICAgXG4gICAgICAgICAgICB7PFNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgICAgICBncmlkU3BlY3MgPSB7IGdyaWRTcGVjc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB7IHN0eWxlc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAvLyBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgICAgIHZpcnR1YWxMaXN0U3BlY3MgPSB7dmlydHVhbExpc3RTcGVjc1JlZi5jdXJyZW50fVxuICAgICAgICAgICAgICAgIHNjcm9sbGVySUQgPSB7IHNjcm9sbGVySUQgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxDcmFkbGUgXG5cbiAgICAgICAgICAgICAgICAgICAgZ3JpZFNwZWNzID0geyBncmlkU3BlY3NSZWYuY3VycmVudCB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHsgc3R5bGVzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsTGlzdFNwZWNzID0ge3ZpcnR1YWxMaXN0U3BlY3NSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VmlydHVhbExpc3RTcGVjcyA9IHsgc2V0VmlydHVhbExpc3RTcGVjcyB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0geyBjYWNoZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlTWF4ID0geyBjYWNoZU1heCB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDYWxsYmFja3MgPSB7IGNhbGxiYWNrc1JlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleCA9IHsgc3RhcnRpbmdJbmRleCB9XG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzID0geyBwbGFjZWhvbGRlck1lc3NhZ2VzUmVmLmN1cnJlbnQgfVxuICAgICAgICAgICAgICAgICAgICBydW53YXlTaXplID0geyBydW53YXlTaXplIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmxpbmVPZmZzZXQgPSB7IHRyaWdnZXJsaW5lT2Zmc2V0IH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzID0geyBzY3JvbGxlclByb3BlcnRpZXMgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQVBJID0geyBjYWNoZUFQSVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgICAgICAgICAgdXNlUGxhY2Vob2xkZXIgPSB7IHVzZVBsYWNlaG9sZGVyIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlU2Nyb2xsVHJhY2tlciA9IHsgdXNlU2Nyb2xsVHJhY2tlciB9XG4gICAgICAgICAgICAgICAgICAgIHNob3dBeGlzID0geyBzaG93QXhpcyB9XG4gICAgICAgICAgICAgICAgICAgIE9OQUZURVJTQ1JPTExfVElNRU9VVCA9IHsgT05BRlRFUlNDUk9MTF9USU1FT1VUIH1cbiAgICAgICAgICAgICAgICAgICAgSURMRUNBTExCQUNLX1RJTUVPVVQgPSB7IElETEVDQUxMQkFDS19USU1FT1VUIH1cbiAgICAgICAgICAgICAgICAgICAgTUFYX0NBQ0hFX09WRVJfUlVOID0geyBNQVhfQ0FDSEVfT1ZFUl9SVU4gfVxuICAgICAgICAgICAgICAgICAgICBWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCA9IHsgVkFSSUFCTEVfTUVBU1VSRU1FTlRTX1RJTUVPVVQgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cblxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1Njcm9sbGJsb2NrPn1cbiAgICAgICAgPC9WaWV3cG9ydD59XG4gICAgICAgIDxkaXY+XG4gICAgICAgIHt1c2VMb2NhbENhY2hlICYmIDxkaXYgZGF0YS10eXBlID0gJ2NhY2hlcm9vdCcgc3R5bGUgPSB7IGNhY2hlcm9vdHN0eWxlIH0+XG4gICAgICAgICAgICA8UG9ydGFsQ2FjaGUgXG5cbiAgICAgICAgICAgICAgICBnZXRDYWNoZUFQSSA9IHsgZ2V0Q2FjaGVBUEkgfSBcbiAgICAgICAgICAgICAgICBnZXRVcGRhdGVGdW5jdGlvbiA9IHsgZ2V0VXBkYXRlRnVuY3Rpb24gfVxuICAgICAgICAgICAgICAgIENBQ0hFX1BBUlRJVElPTl9TSVpFID0geyBDQUNIRV9QQVJUSVRJT05fU0laRSB9IC8+XG5cbiAgICAgICAgPC9kaXY+fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgLy8gPC9FcnJvckJvdW5kYXJ5PlxufVxuXG5leHBvcnQgZGVmYXVsdCBJbmZpbml0ZUdyaWRTY3JvbGxlclxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBTdXBwb3J0IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY2FjaGVyb290c3R5bGUgPSB7ZGlzcGxheTonbm9uZSd9Ly8gYXMgUmVhY3QuQ1NTUHJvcGVydGllcyAvLyBzdGF0aWMsIG91dCBvZiB2aWV3IFxuXG4vLyB1dGlsaXR5XG5mdW5jdGlvbiBjb21wYXJlUHJvcHMgKG9iajEsb2JqMikge1xuICAgIGlmICghb2JqMSB8fCAhb2JqMikgcmV0dXJuIGZhbHNlXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iajEpXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIU9iamVjdC5pcyhvYmoxW2tleV0sb2JqMltrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiaXNTYWZhcmlJT1MiLCJpc19pb3MiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc19zYWZhcmkiLCJtYXRjaCIsImV4cG9ydHMiLCJFcnJvckZhbGxiYWNrIiwiX3JlZiIsImVycm9yIiwicmVzZXRFcnJvckJvdW5kYXJ5IiwiY3JlYXRlRWxlbWVudCIsInJvbGUiLCJzdHlsZSIsIm1hcmdpbiIsImJvcmRlciIsInBhZGRpbmciLCJvbkNsaWNrIiwiVmlld3BvcnRfMSIsIl9faW1wb3J0RGVmYXVsdCIsIlNjcm9sbGJsb2NrXzEiLCJDcmFkbGVfMSIsIlBvcnRhbENhY2hlXzEiLCJnbG9iYWxTY3JvbGxlcklEIiwiSW5maW5pdGVHcmlkU2Nyb2xsZXIiLCJwcm9wcyIsIl9yZWYyIiwidXNlU3RhdGUiLCJfcmVmMyIsInNjcm9sbGVyU3RhdGUiLCJzZXRTY3JvbGxlclN0YXRlIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsIl9wcm9wcyRzdGFydGluZ0xpc3RTaSIsInN0YXJ0aW5nTGlzdFNpemUiLCJfcHJvcHMkc3RhcnRpbmdMaXN0UmEiLCJzdGFydGluZ0xpc3RSYW5nZSIsImdldEl0ZW0iLCJfcHJvcHMkb3JpZW50YXRpb24iLCJvcmllbnRhdGlvbiIsIl9wcm9wcyRnYXAiLCJnYXAiLCJfcHJvcHMkcGFkZGluZyIsIl9wcm9wcyRsYXlvdXQiLCJsYXlvdXQiLCJfcHJvcHMkY2VsbE1pbkhlaWdodCIsImNlbGxNaW5IZWlnaHQiLCJfcHJvcHMkY2VsbE1pbldpZHRoIiwiY2VsbE1pbldpZHRoIiwiX3Byb3BzJHJ1bndheVNpemUiLCJydW53YXlTaXplIiwiX3Byb3BzJHN0YXJ0aW5nSW5kZXgiLCJzdGFydGluZ0luZGV4IiwiX3Byb3BzJGNhY2hlIiwiY2FjaGUiLCJfcHJvcHMkY2FjaGVNYXgiLCJjYWNoZU1heCIsInBsYWNlaG9sZGVyIiwiX3Byb3BzJHVzZVBsYWNlaG9sZGVyIiwidXNlUGxhY2Vob2xkZXIiLCJfcHJvcHMkdXNlU2Nyb2xsVHJhY2siLCJ1c2VTY3JvbGxUcmFja2VyIiwiX3Byb3BzJHN0eWxlcyIsInN0eWxlcyIsIl9wcm9wcyRwbGFjZWhvbGRlck1lcyIsInBsYWNlaG9sZGVyTWVzc2FnZXMiLCJfcHJvcHMkY2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiX3Byb3BzJHRlY2huaWNhbCIsInRlY2huaWNhbCIsIl9wcm9wcyRjYWNoZUFQSSIsImNhY2hlQVBJIiwiZHJhZ2Ryb3BQcm9wZXJ0aWVzIiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwiaXNNaW5pbWFsUHJvcHNGYWlsIiwiY29uc29sZSIsImxvZyIsIm9yaWdpbmFsVmFsdWVzIiwidmVyaWZpZWRWYWx1ZXMiLCJNYXRoIiwibWF4IiwibWluIiwicHJvYmxlbXMiLCJwcm9wIiwiaXNOYU4iLCJnb29kcmFuZ2UiLCJfc3RhcnRpbmdMaXN0UmFuZ2UiLCJfc3RhcnRpbmdMaXN0UmFuZ2UyIiwibG93aW5kZXgiLCJoaWdoaW5kZXgiLCJpbmNsdWRlcyIsImdyaWRTcGVjcyIsImdyaWRTcGVjc1JlZiIsInVzZVJlZiIsInN0eWxlc1JlZiIsImNhbGxiYWNrc1JlZiIsInBsYWNlaG9sZGVyTWVzc2FnZXNSZWYiLCJfdGVjaG5pY2FsIiwic2hvd0F4aXMiLCJ0cmlnZ2VybGluZU9mZnNldCIsIlZJRVdQT1JUX1JFU0laRV9USU1FT1VUIiwiT05BRlRFUlNDUk9MTF9USU1FT1VUIiwiSURMRUNBTExCQUNLX1RJTUVPVVQiLCJWQVJJQUJMRV9NRUFTVVJFTUVOVFNfVElNRU9VVCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsIkNBQ0hFX1BBUlRJVElPTl9TSVpFIiwic2Nyb2xsZXJTZXNzaW9uSURSZWYiLCJzY3JvbGxlcklEIiwiY3VycmVudCIsImNhY2hlQVBJUmVmIiwidXBkYXRlRnVuY3Rpb25SZWYiLCJsaXN0c2l6ZVJlZiIsImxpc3RSYW5nZVJlZiIsImxpc3RzaXplIiwibGlzdHJhbmdlIiwiX2xpc3RyYW5nZSIsImxvd2xpc3RyYW5nZSIsImhpZ2hsaXN0cmFuZ2UiLCJ2aXJ0dWFsTGlzdFNwZWNzIiwic2l6ZSIsInJhbmdlIiwidmlydHVhbExpc3RTcGVjc1JlZiIsImNvbXBhcmVQcm9wcyIsImdldENhY2hlQVBJIiwiZ2V0VXBkYXRlRnVuY3Rpb24iLCJmbiIsInVzZUxvY2FsQ2FjaGUiLCJpc01vdW50ZWRSZWYiLCJ1c2VFZmZlY3QiLCJzZXRWaXJ0dWFsTGlzdFNwZWNzIiwidXNlQ2FsbGJhY2siLCJsaXN0c2l6ZWFyZyIsIl9saXN0UmFuZ2VSZWYkY3VycmVudCIsInByZXZsb3dyYW5nZSIsInByZXZoaWdocmFuZ2UiLCJfbGlzdHNpemVhcmciLCJfbGlzdFJhbmdlUmVmJGN1cnJlbnQyIiwibmV3TGlzdHNpemUiLCJpdGVtU2V0UmVmIiwicmVnaXN0ZXJTY3JvbGxlciIsIml0ZW1TZXQiLCJwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUiLCJ1blJlZ2lzdGVyU2Nyb2xsZXIiLCJGcmFnbWVudCIsInVzZXJDYWxsYmFja3MiLCJjYWNoZXJvb3RzdHlsZSIsImRpc3BsYXkiLCJvYmoxIiwib2JqMiIsImtleXMiLCJfaTIiLCJfa2V5cyIsImtleSIsImlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/InfiniteGridScroller.tsx\n')},"./src/PortalCache.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar cacheAPI_1 = __importDefault(__webpack_require__(/*! ./portalcache/cacheAPI */ "./src/portalcache/cacheAPI.tsx"));\nvar PortalCache = function PortalCache(_ref) {\n  var CACHE_PARTITION_SIZE = _ref.CACHE_PARTITION_SIZE,\n    getCacheAPI = _ref.getCacheAPI,\n    getUpdateFunction = _ref.getUpdateFunction;\n  var cacheAPIRef = (0, react_1.useRef)(null);\n  var partitionArrayRef = (0, react_1.useRef)(null);\n  var partitionRepoForceUpdate = (0, react_1.useCallback)(function (partitionRenderList) {\n    partitionArrayRef.current = partitionRenderList;\n    isMountedRef.current && setPortalCacheCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    if (cacheAPIRef.current) return;\n    var cacheAPI = new cacheAPI_1["default"](CACHE_PARTITION_SIZE);\n    cacheAPIRef.current = cacheAPI;\n    getCacheAPI(cacheAPI);\n    getUpdateFunction(partitionRepoForceUpdate);\n  }, []);\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalCacheCounter = _ref3[0],\n    setPortalCacheCounter = _ref3[1];\n  var counterRef = (0, react_1.useRef)(portalCacheCounter);\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n    _ref5 = _slicedToArray(_ref4, 2),\n    masterState = _ref5[0],\n    setMasterState = _ref5[1];\n  var isMountedRef = (0, react_1.useRef)(true);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (masterState) {\n      case \'setup\':\n        {\n          setMasterState(\'ready\');\n        }\n    }\n  }, [masterState]);\n  return react_1["default"].createElement("div", {\n    "data-type": \'portal-master\'\n  }, partitionArrayRef.current);\n};\nexports["default"] = PortalCache;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQztJQUFBSSxLQUFBLEdBQUFwRSxjQUFBLENBQUFtRSxLQUFBO0lBQWhERSxXQUFXLEdBQUFELEtBQUE7SUFBRUUsY0FBYyxHQUFBRixLQUFBO0VBRWxDLElBQU1WLFlBQVksR0FBRyxJQUFBakIsT0FBQSxDQUFBVyxNQUFNLEVBQUMsSUFBSSxDQUFDO0VBRWpDLElBQUFYLE9BQUEsQ0FBQW9CLFNBQVMsRUFBQyxZQUFJO0lBRVZILFlBQVksQ0FBQ0QsT0FBTyxHQUFHLElBQUk7SUFFM0IsT0FBTyxZQUFLO01BRVJDLFlBQVksQ0FBQ0QsT0FBTyxHQUFHLEtBQUs7SUFFaEMsQ0FBQztFQUVMLENBQUMsRUFBQyxFQUFFLENBQUM7RUFFTCxJQUFBaEIsT0FBQSxDQUFBb0IsU0FBUyxFQUFDLFlBQUk7SUFFVixRQUFRUSxXQUFXO01BQ2YsS0FBSyxPQUFPO1FBQUU7VUFDVkMsY0FBYyxDQUFDLE9BQU8sQ0FBQzs7O0VBSW5DLENBQUMsRUFBQyxDQUFDRCxXQUFXLENBQUMsQ0FBQztFQUVoQixPQUFPNUIsT0FBQSxZQUFBOEIsYUFBQTtJQUFBLGFBQWlCO0VBQWUsR0FBRWxCLGlCQUFpQixDQUFDSSxPQUFPLENBQU87QUFFN0UsQ0FBQztBQUVEZSxrQkFBQSxHQUFlMUIsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvUG9ydGFsQ2FjaGUudHN4P2IyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VsbEZyYW1lLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuaW1wb3J0IFJlYWN0LCB7RkMsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2t9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgQ2FjaGVBUEkgZnJvbSAnLi9wb3J0YWxjYWNoZS9jYWNoZUFQSSdcblxuY29uc3QgUG9ydGFsQ2FjaGU6RkM8YW55PiA9ICh7Q0FDSEVfUEFSVElUSU9OX1NJWkUsIGdldENhY2hlQVBJLCBnZXRVcGRhdGVGdW5jdGlvbiB9KSA9PiB7XG5cbiAgICBjb25zdCBjYWNoZUFQSVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgY29uc3QgcGFydGl0aW9uQXJyYXlSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IHBhcnRpdGlvblJlcG9Gb3JjZVVwZGF0ZSA9IHVzZUNhbGxiYWNrKChwYXJ0aXRpb25SZW5kZXJMaXN0OmFueSkgPT4ge1xuXG4gICAgICAgIHBhcnRpdGlvbkFycmF5UmVmLmN1cnJlbnQgPSBwYXJ0aXRpb25SZW5kZXJMaXN0XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0UG9ydGFsQ2FjaGVDb3VudGVyKCsrY291bnRlclJlZi5jdXJyZW50KSAvLyBmb3JjZSByZW5kZXJcblxuICAgIH0sW10pXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGlmIChjYWNoZUFQSVJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgICAgICBjb25zdCBjYWNoZUFQSSA9IG5ldyBDYWNoZUFQSShDQUNIRV9QQVJUSVRJT05fU0laRSlcblxuICAgICAgICBjYWNoZUFQSVJlZi5jdXJyZW50ID0gY2FjaGVBUElcblxuICAgICAgICBnZXRDYWNoZUFQSShjYWNoZUFQSSlcbiAgICAgICAgZ2V0VXBkYXRlRnVuY3Rpb24ocGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlKVxuXG4gICAgfSxbXSlcblxuICAgIGNvbnN0IFtwb3J0YWxDYWNoZUNvdW50ZXIsIHNldFBvcnRhbENhY2hlQ291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuICAgIGNvbnN0IGNvdW50ZXJSZWYgPSB1c2VSZWYocG9ydGFsQ2FjaGVDb3VudGVyKVxuXG4gICAgY29uc3QgW21hc3RlclN0YXRlLCBzZXRNYXN0ZXJTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWVcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuXG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlXG5cbiAgICAgICAgfVxuXG4gICAgfSxbXSkgXG5cbiAgICB1c2VFZmZlY3QoKCk9PntcblxuICAgICAgICBzd2l0Y2ggKG1hc3RlclN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdzZXR1cCc6IHtcbiAgICAgICAgICAgICAgICBzZXRNYXN0ZXJTdGF0ZSgncmVhZHknKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFttYXN0ZXJTdGF0ZV0pXG5cbiAgICByZXR1cm4gPGRpdiBkYXRhLXR5cGUgPSAncG9ydGFsLW1hc3Rlcic+e3BhcnRpdGlvbkFycmF5UmVmLmN1cnJlbnR9PC9kaXY+XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9ydGFsQ2FjaGVcbiJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiY2FjaGVBUElfMSIsIl9faW1wb3J0RGVmYXVsdCIsIlBvcnRhbENhY2hlIiwiX3JlZiIsIkNBQ0hFX1BBUlRJVElPTl9TSVpFIiwiZ2V0Q2FjaGVBUEkiLCJnZXRVcGRhdGVGdW5jdGlvbiIsImNhY2hlQVBJUmVmIiwidXNlUmVmIiwicGFydGl0aW9uQXJyYXlSZWYiLCJwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUiLCJ1c2VDYWxsYmFjayIsInBhcnRpdGlvblJlbmRlckxpc3QiLCJjdXJyZW50IiwiaXNNb3VudGVkUmVmIiwic2V0UG9ydGFsQ2FjaGVDb3VudGVyIiwiY291bnRlclJlZiIsInVzZUVmZmVjdCIsImNhY2hlQVBJIiwiX3JlZjIiLCJ1c2VTdGF0ZSIsIl9yZWYzIiwicG9ydGFsQ2FjaGVDb3VudGVyIiwiX3JlZjQiLCJfcmVmNSIsIm1hc3RlclN0YXRlIiwic2V0TWFzdGVyU3RhdGUiLCJjcmVhdGVFbGVtZW50IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/PortalCache.tsx\n')},"./src/Scrollblock.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Scrollblock.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n\n    The scrollblock provides the scrollable element (scrolled by Viewport) of the infinite grid scroller.\n    It is sized according to the given cell size and row counts, adjusted for variable cradle content.\n    Its only state change is change of styles.\n\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ "./src/Viewport.tsx");\nvar Scrollblock = function Scrollblock(_ref) {\n  var children = _ref.children,\n    virtualListSpecs = _ref.virtualListSpecs,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID;\n  var orientation = gridSpecs.orientation,\n    gap = gridSpecs.gap,\n    padding = gridSpecs.padding,\n    cellHeight = gridSpecs.cellHeight,\n    cellWidth = gridSpecs.cellWidth;\n  var listsize = virtualListSpecs.size;\n  // -------------------------[ context and state ]-------------------------\n  var ViewportContextProperties = (0, react_1.useContext)(Viewport_1.ViewportContext);\n  // -----------------------------------[ data heap ]-------------------------\n  var baseScrollBlockLengthRef = (0, react_1.useRef)(null);\n  // just for init\n  var linerStyle = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.scrollblock), {\n      position: \'relative\'\n    });\n  }, []);\n  var divlinerstyleRef = (0, react_1.useRef)(linerStyle);\n  var _ref2 = (0, react_1.useState)(divlinerstyleRef.current),\n    _ref3 = _slicedToArray(_ref2, 2),\n    divlinerstyle = _ref3[0],\n    saveDivlinerstyle = _ref3[1]; // to trigger render\n  var _ViewportContextPrope = ViewportContextProperties.viewportDimensions,\n    width = _ViewportContextPrope.width,\n    height = _ViewportContextPrope.height;\n  // reconfigure\n  (0, react_1.useLayoutEffect)(function () {\n    updateBaseBlockLength({\n      orientation: orientation,\n      viewportheight: height,\n      viewportwidth: width,\n      listsize: listsize,\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      gap: gap,\n      padding: padding\n    });\n    divlinerstyleRef.current = updateScrollblockStyles(orientation, divlinerstyleRef, baseScrollBlockLengthRef, cellWidth, cellHeight, padding);\n    saveDivlinerstyle(divlinerstyleRef.current);\n  }, [orientation, height, width, listsize, cellHeight, cellWidth, gap, padding]);\n  var updateBaseBlockLength = (0, react_1.useCallback)(function (layoutspecs) {\n    var basescrollblocklength = calcBaseScrollblockLength(layoutspecs);\n    baseScrollBlockLengthRef.current = basescrollblocklength;\n  }, []);\n  return react_1["default"].createElement("div", {\n    "data-type": \'scrollblock\',\n    style: divlinerstyleRef.current\n  }, children);\n}; // Scrollblock\nexports["default"] = Scrollblock;\n// any of the parameters can affect the length\nvar calcBaseScrollblockLength = function calcBaseScrollblockLength(_ref4) {\n  var orientation = _ref4.orientation,\n    viewportheight = _ref4.viewportheight,\n    viewportwidth = _ref4.viewportwidth,\n    listsize = _ref4.listsize,\n    cellHeight = _ref4.cellHeight,\n    cellWidth = _ref4.cellWidth,\n    gap = _ref4.gap,\n    padding = _ref4.padding;\n  // ---------------[ calculate crosscount ]------------------\n  //crosscount is also calculated by Cradle\n  var crosslength;\n  var cellLength;\n  var viewportcrosslength;\n  if (orientation == \'vertical\') {\n    crosslength = cellWidth + gap;\n    cellLength = cellHeight + gap;\n    viewportcrosslength = viewportwidth;\n  } else {\n    // \'horizontal\'\n    crosslength = cellHeight + gap;\n    cellLength = cellWidth + gap;\n    viewportcrosslength = viewportheight;\n  }\n  // adjustments to viewportcrosslength\n  viewportcrosslength -= padding * 2;\n  viewportcrosslength += gap; // to match crossLength\n  if (viewportcrosslength < crosslength) viewportcrosslength = crosslength; // must be at least one\n  var crosscount = Math.floor(viewportcrosslength / crosslength);\n  // -------------------[ calculate scrollblock length ]-----------------\n  var listrowcount = Math.ceil(listsize / crosscount);\n  var baselength = listrowcount * cellLength - (listrowcount > 0 ? gap :\n  // final cell has no trailing gap\n  0) + padding * 2; // leading and trailing padding\n  return baselength;\n};\nvar updateScrollblockStyles = function updateScrollblockStyles(orientation, stylesRef, baseScrollblocklengthRef, cellWidth, cellHeight, padding) {\n  var localstyles = Object.assign({}, stylesRef.current); // new object\n  var height, width, minHeight, minWidth;\n  if (orientation == \'vertical\') {\n    height = baseScrollblocklengthRef.current + \'px\';\n    width = \'100%\';\n    minWidth = cellWidth + padding * 2 + \'px\';\n    minHeight = null;\n  } else {\n    // orientation == \'horizontal\'\n    height = \'100%\';\n    width = baseScrollblocklengthRef.current + \'px\';\n    minHeight = cellHeight + padding * 2 + \'px\';\n    minWidth = null;\n  }\n  localstyles.height = height;\n  localstyles.width = width;\n  localstyles.minHeight = minHeight;\n  localstyles.minWidth = minWidth;\n  return localstyles;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekIwQixXQUFXLENBQUNDLFNBQVMsR0FBR0EsU0FBUztFQUNqQ0QsV0FBVyxDQUFDRSxRQUFRLEdBQUdBLFFBQVE7RUFFL0IsT0FBT0YsV0FBVztBQUV0QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9TY3JvbGxibG9jay50c3g/M2I2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTY3JvbGxibG9jay50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG5cbiAgICBUaGUgc2Nyb2xsYmxvY2sgcHJvdmlkZXMgdGhlIHNjcm9sbGFibGUgZWxlbWVudCAoc2Nyb2xsZWQgYnkgVmlld3BvcnQpIG9mIHRoZSBpbmZpbml0ZSBncmlkIHNjcm9sbGVyLlxuICAgIEl0IGlzIHNpemVkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY2VsbCBzaXplIGFuZCByb3cgY291bnRzLCBhZGp1c3RlZCBmb3IgdmFyaWFibGUgY3JhZGxlIGNvbnRlbnQuXG4gICAgSXRzIG9ubHkgc3RhdGUgY2hhbmdlIGlzIGNoYW5nZSBvZiBzdHlsZXMuXG5cbiovXG5cbmltcG9ydCBSZWFjdCwge3VzZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW99IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBWaWV3cG9ydENvbnRleHQgfSBmcm9tICcuL1ZpZXdwb3J0J1xuXG5jb25zdCBTY3JvbGxibG9jayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgLy8gbGlzdHNpemUsXG4gICAgdmlydHVhbExpc3RTcGVjcyxcbiAgICBncmlkU3BlY3MsIFxuICAgIHN0eWxlcyxcbiAgICBzY3JvbGxlcklELFxufSkgPT4ge1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgY29uc3QgbGlzdHNpemUgPSB2aXJ0dWFsTGlzdFNwZWNzLnNpemVcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNvbnRleHQgYW5kIHN0YXRlIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdXNlQ29udGV4dChWaWV3cG9ydENvbnRleHQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgZGF0YSBoZWFwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBiYXNlU2Nyb2xsQmxvY2tMZW5ndGhSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIC8vIGp1c3QgZm9yIGluaXRcbiAgICBjb25zdCBsaW5lclN0eWxlID0gdXNlTWVtbygoKSA9PntcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3R5bGVzLnNjcm9sbGJsb2NrLFxuICAgICAgICAgICAgcG9zaXRpb246J3JlbGF0aXZlJyxcbiAgICAgICAgfVxuXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBkaXZsaW5lcnN0eWxlUmVmID0gdXNlUmVmKGxpbmVyU3R5bGUpXG5cbiAgICBjb25zdCBbZGl2bGluZXJzdHlsZSxzYXZlRGl2bGluZXJzdHlsZV0gPSB1c2VTdGF0ZShkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQpIC8vIHRvIHRyaWdnZXIgcmVuZGVyXG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMudmlld3BvcnREaW1lbnNpb25zXG4gICAgXG4gICAgLy8gcmVjb25maWd1cmVcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIHVwZGF0ZUJhc2VCbG9ja0xlbmd0aChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICB2aWV3cG9ydGhlaWdodDpoZWlnaHQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnR3aWR0aDp3aWR0aCxcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSBcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGRpdmxpbmVyc3R5bGVSZWYsXG4gICAgICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmLFxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgc2F2ZURpdmxpbmVyc3R5bGUoZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50KVxuXG4gICAgfSxbXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBsaXN0c2l6ZSxcbiAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICBnYXAsXG4gICAgICAgIHBhZGRpbmcsXG4gICAgXSlcblxuICAgIGNvbnN0IHVwZGF0ZUJhc2VCbG9ja0xlbmd0aCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAobGF5b3V0c3BlY3MpID0+IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYmFzZXNjcm9sbGJsb2NrbGVuZ3RoID0gY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aChsYXlvdXRzcGVjcylcblxuICAgICAgICAgICAgYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmLmN1cnJlbnQgPSBiYXNlc2Nyb2xsYmxvY2tsZW5ndGhcblxuICAgICAgICB9LFtdXG4gICAgKVxuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3Njcm9sbGJsb2NrJyBzdHlsZT17ZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50fT57Y2hpbGRyZW59PC9kaXY+XG5cbn0gLy8gU2Nyb2xsYmxvY2tcblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsYmxvY2tcblxuLy8gYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGNhbiBhZmZlY3QgdGhlIGxlbmd0aFxuY29uc3QgY2FsY0Jhc2VTY3JvbGxibG9ja0xlbmd0aCA9ICh7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICB2aWV3cG9ydGhlaWdodCxcbiAgICAgICAgdmlld3BvcnR3aWR0aCxcbiAgICAgICAgbGlzdHNpemUsXG4gICAgICAgIGNlbGxIZWlnaHQsXG4gICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgZ2FwLFxuICAgICAgICBwYWRkaW5nLFxuICAgIH0pID0+IHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVsgY2FsY3VsYXRlIGNyb3NzY291bnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vY3Jvc3Njb3VudCBpcyBhbHNvIGNhbGN1bGF0ZWQgYnkgQ3JhZGxlXG5cbiAgICBsZXQgY3Jvc3NsZW5ndGhcbiAgICBsZXQgY2VsbExlbmd0aFxuICAgIGxldCB2aWV3cG9ydGNyb3NzbGVuZ3RoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICBjcm9zc2xlbmd0aCA9IGNlbGxXaWR0aCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gdmlld3BvcnR3aWR0aCBcblxuICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgIGNyb3NzbGVuZ3RoID0gY2VsbEhlaWdodCArIGdhcFxuICAgICAgICBjZWxsTGVuZ3RoID0gY2VsbFdpZHRoICsgZ2FwXG4gICAgICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggPSB2aWV3cG9ydGhlaWdodFxuXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0bWVudHMgdG8gdmlld3BvcnRjcm9zc2xlbmd0aFxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggLT0gKHBhZGRpbmcgKiAyKVxuICAgIHZpZXdwb3J0Y3Jvc3NsZW5ndGggKz0gZ2FwIC8vIHRvIG1hdGNoIGNyb3NzTGVuZ3RoXG5cbiAgICBpZiAodmlld3BvcnRjcm9zc2xlbmd0aCA8IGNyb3NzbGVuZ3RoKSB2aWV3cG9ydGNyb3NzbGVuZ3RoID0gY3Jvc3NsZW5ndGggLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmVcblxuICAgIGNvbnN0IGNyb3NzY291bnQgPSBNYXRoLmZsb29yKHZpZXdwb3J0Y3Jvc3NsZW5ndGgvY3Jvc3NsZW5ndGgpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjdWxhdGUgc2Nyb2xsYmxvY2sgbGVuZ3RoIF0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgbGlzdHJvd2NvdW50ID0gTWF0aC5jZWlsKGxpc3RzaXplL2Nyb3NzY291bnQpXG5cbiAgICBjb25zdCBiYXNlbGVuZ3RoID0gKGxpc3Ryb3djb3VudCAqIGNlbGxMZW5ndGgpIC0gXG4gICAgICAgICgobGlzdHJvd2NvdW50ID4gMCk/XG4gICAgICAgICAgICBnYXA6IC8vIGZpbmFsIGNlbGwgaGFzIG5vIHRyYWlsaW5nIGdhcFxuICAgICAgICAgICAgMCkgXG4gICAgICAgICsgKHBhZGRpbmcgKiAyKSAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG5cbiAgICByZXR1cm4gYmFzZWxlbmd0aFxuXG59XG5cbmNvbnN0IHVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzID0gKFxuICAgIG9yaWVudGF0aW9uLCBzdHlsZXNSZWYsIGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBwYWRkaW5nKSA9PiB7XG5cbiAgICBjb25zdCBsb2NhbHN0eWxlcyA9IHsuLi5zdHlsZXNSZWYuY3VycmVudH0gLy8gbmV3IG9iamVjdFxuICAgIGxldCBoZWlnaHQsIHdpZHRoLCBtaW5IZWlnaHQsIG1pbldpZHRoXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmLmN1cnJlbnQgKyAncHgnXG4gICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgIG1pbldpZHRoID0gKGNlbGxXaWR0aCArIChwYWRkaW5nICogMikpICsgJ3B4J1xuICAgICAgICBtaW5IZWlnaHQgPSBudWxsXG4gICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnXG4gICAgICAgIGhlaWdodCA9ICcxMDAlJ1xuICAgICAgICB3aWR0aCA9IGJhc2VTY3JvbGxibG9ja2xlbmd0aFJlZi5jdXJyZW50ICsgJ3B4J1xuICAgICAgICBtaW5IZWlnaHQgPSAoY2VsbEhlaWdodCArIChwYWRkaW5nICogMikpICsgJ3B4J1xuICAgICAgICBtaW5XaWR0aCA9IG51bGxcbiAgICB9XG4gICAgbG9jYWxzdHlsZXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgbG9jYWxzdHlsZXMud2lkdGggPSB3aWR0aFxuICAgIGxvY2Fsc3R5bGVzLm1pbkhlaWdodCA9IG1pbkhlaWdodFxuICAgIGxvY2Fsc3R5bGVzLm1pbldpZHRoID0gbWluV2lkdGhcblxuICAgIHJldHVybiBsb2NhbHN0eWxlc1xuXG59XG4iXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsIlZpZXdwb3J0XzEiLCJTY3JvbGxibG9jayIsIl9yZWYiLCJjaGlsZHJlbiIsInZpcnR1YWxMaXN0U3BlY3MiLCJncmlkU3BlY3MiLCJzdHlsZXMiLCJzY3JvbGxlcklEIiwib3JpZW50YXRpb24iLCJnYXAiLCJwYWRkaW5nIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxpc3RzaXplIiwic2l6ZSIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJ1c2VDb250ZXh0IiwiVmlld3BvcnRDb250ZXh0IiwiYmFzZVNjcm9sbEJsb2NrTGVuZ3RoUmVmIiwidXNlUmVmIiwibGluZXJTdHlsZSIsInVzZU1lbW8iLCJhc3NpZ24iLCJzY3JvbGxibG9jayIsInBvc2l0aW9uIiwiZGl2bGluZXJzdHlsZVJlZiIsIl9yZWYyIiwidXNlU3RhdGUiLCJjdXJyZW50IiwiX3JlZjMiLCJkaXZsaW5lcnN0eWxlIiwic2F2ZURpdmxpbmVyc3R5bGUiLCJfVmlld3BvcnRDb250ZXh0UHJvcGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInVzZUxheW91dEVmZmVjdCIsInVwZGF0ZUJhc2VCbG9ja0xlbmd0aCIsInZpZXdwb3J0aGVpZ2h0Iiwidmlld3BvcnR3aWR0aCIsInVwZGF0ZVNjcm9sbGJsb2NrU3R5bGVzIiwidXNlQ2FsbGJhY2siLCJsYXlvdXRzcGVjcyIsImJhc2VzY3JvbGxibG9ja2xlbmd0aCIsImNhbGNCYXNlU2Nyb2xsYmxvY2tMZW5ndGgiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJleHBvcnRzIiwiX3JlZjQiLCJjcm9zc2xlbmd0aCIsImNlbGxMZW5ndGgiLCJ2aWV3cG9ydGNyb3NzbGVuZ3RoIiwiY3Jvc3Njb3VudCIsIk1hdGgiLCJmbG9vciIsImxpc3Ryb3djb3VudCIsImNlaWwiLCJiYXNlbGVuZ3RoIiwic3R5bGVzUmVmIiwiYmFzZVNjcm9sbGJsb2NrbGVuZ3RoUmVmIiwibG9jYWxzdHlsZXMiLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Scrollblock.tsx\n')},"./src/Viewport.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Viewport.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ViewportContext = void 0;\n/*\n    The role of viewport is to provide viewport data to its children (scrollblock and cradle) through the\n    ViewportContext object, and act as the visible screen portal of the list being shown.\n    If Viewport is resized, it notifies the Cradle to reconfigure.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nexports.ViewportContext = react_1["default"].createContext(null); // for children\nvar Viewport = function Viewport(_ref) {\n  var children = _ref.children,\n    gridSpecs = _ref.gridSpecs,\n    styles = _ref.styles,\n    scrollerID = _ref.scrollerID,\n    VIEWPORT_RESIZE_TIMEOUT = _ref.VIEWPORT_RESIZE_TIMEOUT;\n  // -----------------------[ initialize ]------------------\n  var orientation = gridSpecs.orientation;\n  var _ref2 = (0, react_1.useState)(\'setup\'),\n    _ref3 = _slicedToArray(_ref2, 2),\n    viewportState = _ref3[0],\n    setViewportState = _ref3[1]; // setup, resizing, resized, ready\n  var viewportStateRef = (0, react_1.useRef)(null); // for useCallback -> resizeCallback scope\n  viewportStateRef.current = viewportState;\n  var isMountedRef = (0, react_1.useRef)(true);\n  var viewportElementRef = (0, react_1.useRef)(null);\n  // ViewportContextPropertiesRef is passed as a resizing interrupt (through context) to children\n  var ViewportContextPropertiesRef = (0, react_1.useRef)({\n    isResizing: false,\n    viewportDimensions: null,\n    elementRef: null\n  });\n  // mark as unmounted\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  // --------------------[ viewport resizer interrupt ]-----------------------\n  var resizeTimeridRef = (0, react_1.useRef)(null);\n  var isResizingRef = (0, react_1.useRef)(false);\n  var resizeObserverRef = (0, react_1.useRef)(null);\n  // set up resizeObserver\n  (0, react_1.useEffect)(function () {\n    // initialize\n    resizeObserverRef.current = new ResizeObserver(resizeCallback);\n    resizeObserverRef.current.observe(viewportElementRef.current);\n    // unmount\n    return function () {\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  // used by resizeObserver; generates interrupt\n  var resizeCallback = (0, react_1.useCallback)(function (entries) {\n    if (viewportStateRef.current == \'setup\') return;\n    var target = entries[0].target;\n    // no need to trigger interrupt on first resize notification\n    if (!target.dataset.initialized) {\n      target.dataset.initialized = \'true\';\n      return;\n    }\n    // generate interrupt response, if initiating resize\n    if (!isResizingRef.current) {\n      ViewportContextPropertiesRef.current.isResizing = isResizingRef.current = true;\n      // new object creation triggers a realtime interrupt message to cradle through context\n      ViewportContextPropertiesRef.current = Object.assign({}, ViewportContextPropertiesRef.current);\n      if (isMountedRef.current) setViewportState(\'resizing\');\n    }\n    // finalize resizing after timeout\n    clearTimeout(resizeTimeridRef.current);\n    resizeTimeridRef.current = setTimeout(function () {\n      isResizingRef.current = false;\n      if (isMountedRef.current) {\n        setViewportState(\'resized\');\n      }\n    }, VIEWPORT_RESIZE_TIMEOUT);\n  }, []);\n  // ----------------------------------[ calculate config values ]--------------------------------\n  // styles\n  var divlinerstyleRef = (0, react_1.useRef)(null);\n  // initialize with inherited styles\n  divlinerstyleRef.current = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign({}, styles.viewport), {\n      position: \'absolute\',\n      inset: 0,\n      overflow: \'scroll\',\n      WebkitOverflowScrolling: \'touch\',\n      overflowAnchor: \'none\'\n    });\n  }, [styles.viewport]);\n  // update ViewportContextPropertiesRef; add viewport dimensions\n  ViewportContextPropertiesRef.current = (0, react_1.useMemo)(function () {\n    if (viewportState == \'setup\') return ViewportContextPropertiesRef.current;\n    var _viewportElementRef$c = viewportElementRef.current.getBoundingClientRect(),\n      top = _viewportElementRef$c.top,\n      right = _viewportElementRef$c.right,\n      bottom = _viewportElementRef$c.bottom,\n      left = _viewportElementRef$c.left;\n    var width = right - left;\n    var height = bottom - top;\n    // this is a dimension update procedure for resize. \n    // See also interrupthandler.tsx cradleIntersectionObserverCallback for cradle intersection update\n    var localViewportData = {\n      viewportDimensions: {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left,\n        width: width,\n        height: height\n      },\n      elementRef: viewportElementRef,\n      isResizing: isResizingRef.current\n    };\n    // trigger context change with new object\n    var viewportdataobject = Object.assign(Object.assign({}, ViewportContextPropertiesRef.current), localViewportData);\n    return viewportdataobject;\n  }, [orientation, isResizingRef.current, viewportState]);\n  // --------------------[ state processing ]---------------------------\n  (0, react_1.useLayoutEffect)(function () {\n    switch (viewportState) {\n      case \'resized\':\n      case \'setup\':\n        {\n          setViewportState(\'ready\');\n          break;\n        }\n    }\n  }, [viewportState]);\n  // ----------------------[ render ]--------------------------------\n  return react_1["default"].createElement(exports.ViewportContext.Provider, {\n    value: ViewportContextPropertiesRef.current\n  }, react_1["default"].createElement("div", {\n    "data-type": \'viewport\',\n    "data-scrollerid": scrollerID,\n    style: divlinerstyleRef.current,\n    ref: viewportElementRef\n  }, viewportState != \'setup\' && children));\n}; // Viewport\nexports["default"] = Viewport;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDRCQUE0QixDQUFDSDtFQUFPLEdBQzNFckIsT0FBQSxZQUFBK0QsYUFBQTtJQUFBLGFBQ2dCLFVBQVU7SUFBQSxtQkFDRnBELFVBQVU7SUFDOUJzRCxLQUFLLEVBQUtyQixnQkFBZ0IsQ0FBQ3ZCLE9BQU87SUFDbEM2QyxHQUFHLEVBQUszQztFQUFrQixHQUV2Qk4sYUFBYSxJQUFJLE9BQU8sSUFBS1QsUUFBUSxDQUN0QyxDQUNpQjtBQUUvQixDQUFDLEVBQUM7QUFFRkwsa0JBQUEsR0FBZUcsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvVmlld3BvcnQudHN4P2M4MjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVmlld3BvcnQudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoZSByb2xlIG9mIHZpZXdwb3J0IGlzIHRvIHByb3ZpZGUgdmlld3BvcnQgZGF0YSB0byBpdHMgY2hpbGRyZW4gKHNjcm9sbGJsb2NrIGFuZCBjcmFkbGUpIHRocm91Z2ggdGhlXG4gICAgVmlld3BvcnRDb250ZXh0IG9iamVjdCwgYW5kIGFjdCBhcyB0aGUgdmlzaWJsZSBzY3JlZW4gcG9ydGFsIG9mIHRoZSBsaXN0IGJlaW5nIHNob3duLlxuICAgIElmIFZpZXdwb3J0IGlzIHJlc2l6ZWQsIGl0IG5vdGlmaWVzIHRoZSBDcmFkbGUgdG8gcmVjb25maWd1cmUuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHtcblxuICAgIHVzZVN0YXRlLCBcbiAgICB1c2VSZWYsIFxuICAgIHVzZUVmZmVjdCwgXG4gICAgdXNlTGF5b3V0RWZmZWN0LCBcbiAgICB1c2VNZW1vLCBcbiAgICB1c2VDYWxsYmFjaywgXG5cbn0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBWaWV3cG9ydENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpIC8vIGZvciBjaGlsZHJlblxuXG5jb25zdCBWaWV3cG9ydCA9ICh7XG5cbiAgICBjaGlsZHJlbiwgXG4gICAgZ3JpZFNwZWNzLFxuICAgIHN0eWxlcyxcbiAgICBzY3JvbGxlcklELFxuICAgIFZJRVdQT1JUX1JFU0laRV9USU1FT1VULFxuICAgIFxufSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAvLyBnYXAsXG4gICAgICAgIC8vIHBhZGRpbmcsXG4gICAgICAgIC8vIGNlbGxIZWlnaHQsXG4gICAgICAgIC8vIGNlbGxXaWR0aCxcbiAgICAgICAgLy8gbGF5b3V0LFxuXG4gICAgfSA9IGdyaWRTcGVjc1xuXG4gICAgY29uc3QgW3ZpZXdwb3J0U3RhdGUsc2V0Vmlld3BvcnRTdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKSAvLyBzZXR1cCwgcmVzaXppbmcsIHJlc2l6ZWQsIHJlYWR5XG5cbiAgICBjb25zdCB2aWV3cG9ydFN0YXRlUmVmID0gdXNlUmVmKG51bGwpIC8vIGZvciB1c2VDYWxsYmFjayAtPiByZXNpemVDYWxsYmFjayBzY29wZVxuICAgIHZpZXdwb3J0U3RhdGVSZWYuY3VycmVudCA9IHZpZXdwb3J0U3RhdGVcblxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgY29uc3Qgdmlld3BvcnRFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgICAvLyBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIGlzIHBhc3NlZCBhcyBhIHJlc2l6aW5nIGludGVycnVwdCAodGhyb3VnaCBjb250ZXh0KSB0byBjaGlsZHJlblxuICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYgPSB1c2VSZWYoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzUmVzaXppbmc6ZmFsc2UsIFxuICAgICAgICAgICAgdmlld3BvcnREaW1lbnNpb25zOm51bGwsXG4gICAgICAgICAgICBlbGVtZW50UmVmOm51bGxcbiAgICAgICAgfVxuICAgIClcblxuICAgIC8vIG1hcmsgYXMgdW5tb3VudGVkXG4gICAgdXNlRWZmZWN0KCgpID0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2VcblxuICAgICAgICB9XG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tWyB2aWV3cG9ydCByZXNpemVyIGludGVycnVwdCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IHJlc2l6ZVRpbWVyaWRSZWYgPSB1c2VSZWYobnVsbClcbiAgICBjb25zdCBpc1Jlc2l6aW5nUmVmID0gdXNlUmVmKGZhbHNlKVxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyUmVmID0gdXNlUmVmKG51bGwpOyAgICBcblxuICAgIC8vIHNldCB1cCByZXNpemVPYnNlcnZlclxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcihyZXNpemVDYWxsYmFjaylcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudC5vYnNlcnZlKHZpZXdwb3J0RWxlbWVudFJlZi5jdXJyZW50KVxuXG4gICAgICAgIC8vIHVubW91bnRcbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudC5kaXNjb25uZWN0KClcblxuICAgICAgICB9XG5cbiAgICB9LFtdKVxuXG4gICAgLy8gdXNlZCBieSByZXNpemVPYnNlcnZlcjsgZ2VuZXJhdGVzIGludGVycnVwdFxuICAgIGNvbnN0IHJlc2l6ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVudHJpZXMpPT57XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0U3RhdGVSZWYuY3VycmVudCA9PSAnc2V0dXAnKSByZXR1cm5cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBlbnRyaWVzWzBdLnRhcmdldFxuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gdHJpZ2dlciBpbnRlcnJ1cHQgb24gZmlyc3QgcmVzaXplIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAoIXRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkKSB7XG5cbiAgICAgICAgICAgIHRhcmdldC5kYXRhc2V0LmluaXRpYWxpemVkID0gJ3RydWUnXG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdlbmVyYXRlIGludGVycnVwdCByZXNwb25zZSwgaWYgaW5pdGlhdGluZyByZXNpemVcbiAgICAgICAgaWYgKCFpc1Jlc2l6aW5nUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmlzUmVzaXppbmcgPSBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgPSB0cnVlIFxuXG4gICAgICAgICAgICAvLyBuZXcgb2JqZWN0IGNyZWF0aW9uIHRyaWdnZXJzIGEgcmVhbHRpbWUgaW50ZXJydXB0IG1lc3NhZ2UgdG8gY3JhZGxlIHRocm91Z2ggY29udGV4dFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gey4uLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudH1cblxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSBzZXRWaWV3cG9ydFN0YXRlKCdyZXNpemluZycpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsaXplIHJlc2l6aW5nIGFmdGVyIHRpbWVvdXRcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVyaWRSZWYuY3VycmVudClcbiAgICAgICAgcmVzaXplVGltZXJpZFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGlzUmVzaXppbmdSZWYuY3VycmVudCA9IGZhbHNlXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKCdyZXNpemVkJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFZJRVdQT1JUX1JFU0laRV9USU1FT1VUKVxuXG4gICAgfSxbXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0ZSBjb25maWcgdmFsdWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gc3R5bGVzXG4gICAgY29uc3QgZGl2bGluZXJzdHlsZVJlZiA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB3aXRoIGluaGVyaXRlZCBzdHlsZXNcbiAgICBkaXZsaW5lcnN0eWxlUmVmLmN1cnJlbnQgPSB1c2VNZW1vKCgpID0+IHtcblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICAuLi5zdHlsZXMudmlld3BvcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgICAgICAgaW5zZXQ6MCxcbiAgICAgICAgICAgIG92ZXJmbG93OidzY3JvbGwnLC8vJ2F1dG8nLCAnc2Nyb2xsJyBmb3IgaU9TIFNhZmFyaVxuICAgICAgICAgICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCcsLy8gZm9yIGlPUyBTYWZhcmlcbiAgICAgICAgICAgIG92ZXJmbG93QW5jaG9yOidub25lJywgLy8gY3J1Y2lhbCFcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICB9LFtzdHlsZXMudmlld3BvcnRdKVxuXG4gICAgLy8gdXBkYXRlIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWY7IGFkZCB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0U3RhdGUgPT0gJ3NldHVwJykgcmV0dXJuIFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnR9ID0gdmlld3BvcnRFbGVtZW50UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgY29uc3Qgd2lkdGggPSAocmlnaHQgLSBsZWZ0KVxuICAgICAgICBjb25zdCBoZWlnaHQgPSAoYm90dG9tIC0gdG9wKVxuXG4gICAgICAgIC8vIHRoaXMgaXMgYSBkaW1lbnNpb24gdXBkYXRlIHByb2NlZHVyZSBmb3IgcmVzaXplLiBcbiAgICAgICAgLy8gU2VlIGFsc28gaW50ZXJydXB0aGFuZGxlci50c3ggY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayBmb3IgY3JhZGxlIGludGVyc2VjdGlvbiB1cGRhdGVcbiAgICAgICAgY29uc3QgbG9jYWxWaWV3cG9ydERhdGEgPSB7XG4gICAgICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnM6e3RvcCxyaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSxcbiAgICAgICAgICAgIGVsZW1lbnRSZWY6dmlld3BvcnRFbGVtZW50UmVmLFxuICAgICAgICAgICAgaXNSZXNpemluZzppc1Jlc2l6aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGNvbnRleHQgY2hhbmdlIHdpdGggbmV3IG9iamVjdFxuICAgICAgICBjb25zdCB2aWV3cG9ydGRhdGFvYmplY3QgPSB7Li4uVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LCAuLi5sb2NhbFZpZXdwb3J0RGF0YX1cblxuICAgICAgICByZXR1cm4gIHZpZXdwb3J0ZGF0YW9iamVjdFxuXG4gICAgfSxbb3JpZW50YXRpb24sIGlzUmVzaXppbmdSZWYuY3VycmVudCwgdmlld3BvcnRTdGF0ZV0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgc3RhdGUgcHJvY2Vzc2luZyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHN3aXRjaCAodmlld3BvcnRTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZXNpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldHVwJzoge1xuICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0U3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LFt2aWV3cG9ydFN0YXRlXSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHJlbmRlciBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJldHVybiA8Vmlld3BvcnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlID0geyBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQgfT5cbiAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGRhdGEtdHlwZSA9ICd2aWV3cG9ydCdcbiAgICAgICAgICAgIGRhdGEtc2Nyb2xsZXJpZCA9IHsgc2Nyb2xsZXJJRCB9XG4gICAgICAgICAgICBzdHlsZSA9IHsgZGl2bGluZXJzdHlsZVJlZi5jdXJyZW50IH1cbiAgICAgICAgICAgIHJlZiA9IHsgdmlld3BvcnRFbGVtZW50UmVmIH1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyAodmlld3BvcnRTdGF0ZSAhPSAnc2V0dXAnKSAmJiBjaGlsZHJlbiB9XG4gICAgICAgIDwvZGl2PlxuICAgIDwvVmlld3BvcnRDb250ZXh0LlByb3ZpZGVyPlxuICAgIFxufSAvLyBWaWV3cG9ydFxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydFxuIl0sIm5hbWVzIjpbIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJlcnIiLCJpc0FycmF5IiwicmVhY3RfMSIsIl9faW1wb3J0U3RhciIsInJlcXVpcmUiLCJleHBvcnRzIiwiVmlld3BvcnRDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIlZpZXdwb3J0IiwiX3JlZiIsImNoaWxkcmVuIiwiZ3JpZFNwZWNzIiwic3R5bGVzIiwic2Nyb2xsZXJJRCIsIlZJRVdQT1JUX1JFU0laRV9USU1FT1VUIiwib3JpZW50YXRpb24iLCJfcmVmMiIsInVzZVN0YXRlIiwiX3JlZjMiLCJ2aWV3cG9ydFN0YXRlIiwic2V0Vmlld3BvcnRTdGF0ZSIsInZpZXdwb3J0U3RhdGVSZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwiaXNNb3VudGVkUmVmIiwidmlld3BvcnRFbGVtZW50UmVmIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImlzUmVzaXppbmciLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJlbGVtZW50UmVmIiwidXNlRWZmZWN0IiwicmVzaXplVGltZXJpZFJlZiIsImlzUmVzaXppbmdSZWYiLCJyZXNpemVPYnNlcnZlclJlZiIsIlJlc2l6ZU9ic2VydmVyIiwicmVzaXplQ2FsbGJhY2siLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInVzZUNhbGxiYWNrIiwiZW50cmllcyIsInRhcmdldCIsImRhdGFzZXQiLCJpbml0aWFsaXplZCIsImFzc2lnbiIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJkaXZsaW5lcnN0eWxlUmVmIiwidXNlTWVtbyIsInZpZXdwb3J0IiwicG9zaXRpb24iLCJpbnNldCIsIm92ZXJmbG93IiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJvdmVyZmxvd0FuY2hvciIsIl92aWV3cG9ydEVsZW1lbnRSZWYkYyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibG9jYWxWaWV3cG9ydERhdGEiLCJ2aWV3cG9ydGRhdGFvYmplY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJzdHlsZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Viewport.tsx\n')},"./src/cellframe/Placeholder.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// Placeholder.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of the default PlaceHolder is to hold the content display until the host content\n    is received. The placeholder presents a waiting message, or an error message if the load\n    of the host content failed.\n\n    The default placeholder can be replaced by a placeholder provided by the host.\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar Placeholder = function Placeholder(_ref) {\n  var index = _ref.index,\n    listsize = _ref.listsize,\n    message = _ref.message,\n    error = _ref.error,\n    userFrameStyles = _ref.userFrameStyles,\n    userLinerStyles = _ref.userLinerStyles,\n    userErrorFrameStyles = _ref.userErrorFrameStyles,\n    userErrorLinerStyles = _ref.userErrorLinerStyles;\n  var _ref2 = (0, react_1.useMemo)(function () {\n      var uFrameStyles = !error ? userFrameStyles : userErrorFrameStyles;\n      var uLinerStyles = !error ? userLinerStyles : userErrorLinerStyles;\n      var frameStyles = Object.assign(Object.assign({\n        border: \'2px solid black\',\n        backgroundColor: \'cyan\'\n      }, uFrameStyles), {\n        position: \'relative\',\n        boxSizing: \'border-box\',\n        height: \'100%\',\n        width: \'100%\',\n        overflow: \'hidden\'\n      });\n      var linerStyles = Object.assign({\n        position: \'absolute\',\n        top: 0,\n        left: 0,\n        padding: \'3px\',\n        margin: \'3px\',\n        fontSize: \'smaller\'\n      }, uLinerStyles);\n      return [frameStyles, linerStyles];\n    }, [error, userFrameStyles, userLinerStyles, userErrorFrameStyles, userErrorLinerStyles]),\n    _ref3 = _slicedToArray(_ref2, 2),\n    frameStyles = _ref3[0],\n    linerStyles = _ref3[1];\n  message = message !== null && message !== void 0 ? message : \'(loading...)\';\n  return react_1["default"].createElement("div", {\n    "data-type": \'placeholderframe\',\n    style: frameStyles\n  }, !error ? react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, index + 1, "/", listsize, " ", message) : react_1["default"].createElement("div", {\n    "data-type": \'placeholderliner\',\n    style: linerStyles\n  }, "item is not available (", error.message, ")"));\n};\nexports["default"] = Placeholder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBb0IsQ0FDdkIsQ0FBQztJQUFBb0IsS0FBQSxHQUFBekUsY0FBQSxDQUFBc0QsS0FBQTtJQXhDS0ksV0FBVyxHQUFBZSxLQUFBO0lBQUVOLFdBQVcsR0FBQU0sS0FBQTtFQTJDL0J6QixPQUFPLEdBQUdBLE9BQU8sYUFBUEEsT0FBTyxjQUFQQSxPQUFPLEdBQUksY0FBYztFQUVuQyxPQUFPUCxPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBSWpCO0VBQVcsR0FDekQsQ0FBQ1QsS0FBSyxHQUNKUixPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBS1I7RUFBVyxHQUFJckIsS0FBSyxHQUFHLENBQUMsRSxLQUFHQyxRQUFRLEUsS0FBR0MsT0FBTyxDQUFPLEdBQ2xHUCxPQUFBLFlBQUFpQyxhQUFBO0lBQUEsYUFBaUIsa0JBQWtCO0lBQUNDLEtBQUssRUFBS1I7RUFBVyxHLDJCQUEyQmxCLEtBQUssQ0FBQ0QsT0FBTyxFLElBQVEsQ0FHM0c7QUFDVixDQUFDO0FBRUQ0QixrQkFBQSxHQUFlaEMsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY2VsbGZyYW1lL1BsYWNlaG9sZGVyLnRzeD9iYjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlaG9sZGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiB0aGUgZGVmYXVsdCBQbGFjZUhvbGRlciBpcyB0byBob2xkIHRoZSBjb250ZW50IGRpc3BsYXkgdW50aWwgdGhlIGhvc3QgY29udGVudFxuICAgIGlzIHJlY2VpdmVkLiBUaGUgcGxhY2Vob2xkZXIgcHJlc2VudHMgYSB3YWl0aW5nIG1lc3NhZ2UsIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGxvYWRcbiAgICBvZiB0aGUgaG9zdCBjb250ZW50IGZhaWxlZC5cblxuICAgIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNhbiBiZSByZXBsYWNlZCBieSBhIHBsYWNlaG9sZGVyIHByb3ZpZGVkIGJ5IHRoZSBob3N0LlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlTWVtb30gZnJvbSAncmVhY3QnXG5cbmNvbnN0IFBsYWNlaG9sZGVyID0gKHtcbiAgICBpbmRleCwgXG4gICAgbGlzdHNpemUsIFxuICAgIG1lc3NhZ2UsIFxuICAgIGVycm9yLCBcbiAgICB1c2VyRnJhbWVTdHlsZXMsIFxuICAgIHVzZXJMaW5lclN0eWxlcyxcbiAgICB1c2VyRXJyb3JGcmFtZVN0eWxlcywgXG4gICAgdXNlckVycm9yTGluZXJTdHlsZXNcbn0pID0+IHtcblxuICAgIGNvbnN0IFtmcmFtZVN0eWxlcywgbGluZXJTdHlsZXNdID0gdXNlTWVtbygoKT0+e1xuXG4gICAgICAgIGNvbnN0IHVGcmFtZVN0eWxlcyA9IFxuICAgICAgICAgICAgKCFlcnJvcik/XG4gICAgICAgICAgICAgICAgdXNlckZyYW1lU3R5bGVzOlxuICAgICAgICAgICAgICAgIHVzZXJFcnJvckZyYW1lU3R5bGVzXG5cbiAgICAgICAgY29uc3QgdUxpbmVyU3R5bGVzID0gXG4gICAgICAgICAgICAoIWVycm9yKT9cbiAgICAgICAgICAgICAgICB1c2VyTGluZXJTdHlsZXM6XG4gICAgICAgICAgICAgICAgdXNlckVycm9yTGluZXJTdHlsZXNcblxuICAgICAgICBjb25zdCBmcmFtZVN0eWxlcyA9IHtcbiAgICAgICAgICAgIGJvcmRlcjonMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjonY3lhbicsXG4gICAgICAgICAgICAuLi51RnJhbWVTdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnLFxuICAgICAgICAgICAgYm94U2l6aW5nOidib3JkZXItYm94JyxcbiAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICB3aWR0aDonMTAwJScsXG4gICAgICAgICAgICBvdmVyZmxvdzonaGlkZGVuJyxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lclN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6MCxcbiAgICAgICAgICAgIGxlZnQ6MCxcbiAgICAgICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgICAgICBtYXJnaW46JzNweCcsXG4gICAgICAgICAgICBmb250U2l6ZTonc21hbGxlcicsXG4gICAgICAgICAgICAuLi51TGluZXJTdHlsZXMsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ZyYW1lU3R5bGVzLCBsaW5lclN0eWxlc11cblxuICAgIH0sIFtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHVzZXJGcmFtZVN0eWxlcywgXG4gICAgICAgIHVzZXJMaW5lclN0eWxlcyxcbiAgICAgICAgdXNlckVycm9yRnJhbWVTdHlsZXMsIFxuICAgICAgICB1c2VyRXJyb3JMaW5lclN0eWxlcyxcbiAgICBdKVxuXG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSA/PyAnKGxvYWRpbmcuLi4pJ1xuXG4gICAgcmV0dXJuIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVyZnJhbWUnIHN0eWxlID0ge2ZyYW1lU3R5bGVzfT5cbiAgICAgICAgeyAhZXJyb3I/XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9ICdwbGFjZWhvbGRlcmxpbmVyJyBzdHlsZSA9IHsgbGluZXJTdHlsZXMgfT57aW5kZXggKyAxfS97bGlzdHNpemV9IHttZXNzYWdlfTwvZGl2PjpcbiAgICAgICAgICAgIDxkaXYgZGF0YS10eXBlID0gJ3BsYWNlaG9sZGVybGluZXInIHN0eWxlID0geyBsaW5lclN0eWxlcyB9Pml0ZW0gaXMgbm90IGF2YWlsYWJsZSAoe2Vycm9yLm1lc3NhZ2V9KTwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIFxuICAgIDwvZGl2PlxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGFjZWhvbGRlciJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsInJlYWN0XzEiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwiUGxhY2Vob2xkZXIiLCJfcmVmIiwiaW5kZXgiLCJsaXN0c2l6ZSIsIm1lc3NhZ2UiLCJlcnJvciIsInVzZXJGcmFtZVN0eWxlcyIsInVzZXJMaW5lclN0eWxlcyIsInVzZXJFcnJvckZyYW1lU3R5bGVzIiwidXNlckVycm9yTGluZXJTdHlsZXMiLCJfcmVmMiIsInVzZU1lbW8iLCJ1RnJhbWVTdHlsZXMiLCJ1TGluZXJTdHlsZXMiLCJmcmFtZVN0eWxlcyIsImFzc2lnbiIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsInBvc2l0aW9uIiwiYm94U2l6aW5nIiwiaGVpZ2h0Iiwid2lkdGgiLCJvdmVyZmxvdyIsImxpbmVyU3R5bGVzIiwidG9wIiwibGVmdCIsInBhZGRpbmciLCJtYXJnaW4iLCJmb250U2l6ZSIsIl9yZWYzIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cellframe/Placeholder.tsx\n')},"./src/cradle/ScrollTracker.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// scrolltracker.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    The role of ScrollTracker is to provide feedback to the user of the relative position in the\n    virtual list during repositiong.\n\n    ScrollTracker can be suppressed by the host (in favour of the host\'s own location feedback)\n*/\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar ScrollTracker = function ScrollTracker(_ref) {\n  var top = _ref.top,\n    left = _ref.left,\n    offset = _ref.offset,\n    index = _ref.index,\n    listsize = _ref.listsize,\n    styles = _ref.styles;\n  var trackdata = "".concat(index, " (").concat(offset + 1, "/").concat(listsize, ")");\n  var styleRef = (0, react_1.useRef)(Object.assign({\n    top: top + \'px\',\n    left: left + \'px\',\n    position: \'fixed\',\n    zIndex: 3,\n    backgroundColor: \'white\',\n    border: \'1px solid gray\',\n    borderRadius: \'10px\',\n    fontSize: \'smaller\',\n    padding: \'3px\'\n  }, styles.scrolltracker));\n  return react_1["default"].createElement("div", {\n    "data-name": \'scrolltracker\',\n    style: styleRef.current\n  }, trackdata);\n};\nexports["default"] = ScrollTracker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL1Njcm9sbFRyYWNrZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0FBT0EsSUFBQUEsT0FBQSxHQUFBQyxZQUFBLENBQUFDLG1CQUFBO0FBRUEsSUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFhQSxDQUFBQyxJQUFBLEVBQXNEO0VBQUEsSUFBaERDLEdBQUcsR0FBQUQsSUFBQSxDQUFIQyxHQUFHO0lBQUVDLElBQUksR0FBQUYsSUFBQSxDQUFKRSxJQUFJO0lBQUVDLE1BQU0sR0FBQUgsSUFBQSxDQUFORyxNQUFNO0lBQUVDLEtBQUssR0FBQUosSUFBQSxDQUFMSSxLQUFLO0lBQUVDLFFBQVEsR0FBQUwsSUFBQSxDQUFSSyxRQUFRO0lBQUVDLE1BQU0sR0FBQU4sSUFBQSxDQUFOTSxNQUFNO0VBRS9ELElBQU1DLFNBQVMsTUFBQUMsTUFBQSxDQUFNSixLQUFLLFFBQUFJLE1BQUEsQ0FBS0wsTUFBTSxHQUFHLENBQUMsT0FBQUssTUFBQSxDQUFJSCxRQUFRLE1BQUc7RUFFeEQsSUFBTUksUUFBUSxHQUFHLElBQUFiLE9BQUEsQ0FBQWMsTUFBTSxFQUFBQyxNQUFBLENBQUFDLE1BQUE7SUFDbkJYLEdBQUcsRUFBRUEsR0FBRyxHQUFHLElBQUk7SUFDZkMsSUFBSSxFQUFFQSxJQUFJLEdBQUcsSUFBSTtJQUNqQlcsUUFBUSxFQUFDLE9BQU87SUFDaEJDLE1BQU0sRUFBQyxDQUFDO0lBQ1JDLGVBQWUsRUFBQyxPQUFPO0lBQ3ZCQyxNQUFNLEVBQUUsZ0JBQWdCO0lBQ3hCQyxZQUFZLEVBQUMsTUFBTTtJQUNuQkMsUUFBUSxFQUFDLFNBQVM7SUFDbEJDLE9BQU8sRUFBQztFQUFLLEdBQ1ZiLE1BQU0sQ0FBQ2MsYUFBYSxFQUN6QjtFQUVGLE9BQU94QixPQUFBLFlBQUF5QixhQUFBO0lBQUEsYUFBaUIsZUFBZTtJQUFDQyxLQUFLLEVBQUliLFFBQVEsQ0FBQ2M7RUFBTyxHQUFJaEIsU0FBUyxDQUFPO0FBQ3pGLENBQUM7QUFFRGlCLGtCQUFBLEdBQWV6QixhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvU2Nyb2xsVHJhY2tlci50c3g/MGIzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY3JvbGx0cmFja2VyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGUgcm9sZSBvZiBTY3JvbGxUcmFja2VyIGlzIHRvIHByb3ZpZGUgZmVlZGJhY2sgdG8gdGhlIHVzZXIgb2YgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZVxuICAgIHZpcnR1YWwgbGlzdCBkdXJpbmcgcmVwb3NpdGlvbmcuXG5cbiAgICBTY3JvbGxUcmFja2VyIGNhbiBiZSBzdXBwcmVzc2VkIGJ5IHRoZSBob3N0IChpbiBmYXZvdXIgb2YgdGhlIGhvc3QncyBvd24gbG9jYXRpb24gZmVlZGJhY2spXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHt1c2VSZWZ9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBTY3JvbGxUcmFja2VyID0gKHsgdG9wLCBsZWZ0LCBvZmZzZXQsIGluZGV4LCBsaXN0c2l6ZSwgc3R5bGVzIH0pID0+IHtcblxuICAgIGNvbnN0IHRyYWNrZGF0YSA9IGAke2luZGV4fSAoJHtvZmZzZXQgKyAxfS8ke2xpc3RzaXplfSlgXG5cbiAgICBjb25zdCBzdHlsZVJlZiA9IHVzZVJlZih7XG4gICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgbGVmdDogbGVmdCArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOidmaXhlZCcsXG4gICAgICAgIHpJbmRleDozLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6J3doaXRlJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGdyYXknLFxuICAgICAgICBib3JkZXJSYWRpdXM6JzEwcHgnLFxuICAgICAgICBmb250U2l6ZTonc21hbGxlcicsXG4gICAgICAgIHBhZGRpbmc6JzNweCcsXG4gICAgICAgIC4uLnN0eWxlcy5zY3JvbGx0cmFja2VyXG4gICAgfSlcblxuICAgIHJldHVybiA8ZGl2IGRhdGEtbmFtZSA9ICdzY3JvbGx0cmFja2VyJyBzdHlsZSA9IHtzdHlsZVJlZi5jdXJyZW50fSA+e3RyYWNrZGF0YX08L2Rpdj5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsVHJhY2tlciJdLCJuYW1lcyI6WyJyZWFjdF8xIiwiX19pbXBvcnRTdGFyIiwicmVxdWlyZSIsIlNjcm9sbFRyYWNrZXIiLCJfcmVmIiwidG9wIiwibGVmdCIsIm9mZnNldCIsImluZGV4IiwibGlzdHNpemUiLCJzdHlsZXMiLCJ0cmFja2RhdGEiLCJjb25jYXQiLCJzdHlsZVJlZiIsInVzZVJlZiIsIk9iamVjdCIsImFzc2lnbiIsInBvc2l0aW9uIiwiekluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiZm9udFNpemUiLCJwYWRkaW5nIiwic2Nyb2xsdHJhY2tlciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImN1cnJlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/ScrollTracker.tsx\n')},"./src/cradle/contentfunctions.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\n// contentfunctions.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.deletePortals = exports.allocateContentList = exports.getCellFrameComponentList = exports.calculateShiftSpecs = exports.generateShiftInstruction = exports.calculateContentListRequirements = void 0;\n/*\n    This module supports the contenthandler module. The functions in this module perform\n    the detailed calculations and processes required by the contenthandler.\n\n    calculateContentListRequirements is called by the contenthandler's setCradleContent function.\n\n    generateShiftInstruction and calcContentShift are called by contentHandler's updateCradleContent\n    function.\n    \n    getCellFrameComponentList, allocateContentList, and deletePortals functions are shared by both.\n\n    createCellFrame is called internally by getCellFrameComponentList as needed.\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nvar CellFrame_1 = __importDefault(__webpack_require__(/*! ../CellFrame */ \"./src/CellFrame.tsx\"));\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ \"./src/InfiniteGridScroller.tsx\");\n// ======================[ for setCradleContent ]===========================\nvar calculateContentListRequirements = function calculateContentListRequirements(_ref) {\n  var targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n    baseRowPixelLength = _ref.baseRowPixelLength,\n    targetAxisViewportPixelOffset = _ref.targetAxisViewportPixelOffset,\n    cradleInheritedProperties = _ref.cradleInheritedProperties,\n    cradleInternalProperties = _ref.cradleInternalProperties;\n  // console.log('==>> calculateContentListRequirements:1. targetAxisReferenceIndex\\n',targetAxisReferenceIndex)\n  var padding = cradleInheritedProperties.padding;\n  var cradleContentProps = cradleInternalProperties.cradleContentProps,\n    virtualListProps = cradleInternalProperties.virtualListProps;\n  var cradleRowcount = cradleContentProps.cradleRowcount,\n    runwayRowcount = cradleContentProps.runwayRowcount;\n  var listlowindex = virtualListProps.lowindex,\n    listhighindex = virtualListProps.highindex,\n    crosscount = virtualListProps.crosscount,\n    listRowcount = virtualListProps.rowcount,\n    baserowblanks = virtualListProps.baserowblanks,\n    endrowblanks = virtualListProps.endrowblanks,\n    rangerowshift = virtualListProps.rowshift;\n  // align axis reference to list scope\n  targetAxisReferenceIndex = Math.min(targetAxisReferenceIndex, listhighindex);\n  targetAxisReferenceIndex = Math.max(targetAxisReferenceIndex, listlowindex);\n  // console.log('2. targetAxisReferenceIndex\\n',targetAxisReferenceIndex)\n  // derive target row\n  var targetAxisReferenceRow = Math.floor(targetAxisReferenceIndex / crosscount);\n  // console.log('3. targetAxisReferenceIndex\\n',targetAxisReferenceIndex)\n  // -----------------------[ calc cradleReferenceRow & Index ]------------------------\n  // leading edge\n  var targetCradleReferenceRow = Math.max(rangerowshift, targetAxisReferenceRow - runwayRowcount);\n  // trailing edge\n  var targetCradleEndRow = targetCradleReferenceRow + (cradleRowcount - 1);\n  var listEndRowOffset = listRowcount - 1 + rangerowshift;\n  if (targetCradleEndRow > listEndRowOffset) {\n    var diff = targetCradleEndRow - listEndRowOffset;\n    targetCradleReferenceRow -= diff;\n    targetCradleEndRow -= diff;\n  }\n  var targetCradleReferenceIndex = targetCradleReferenceRow * crosscount;\n  targetCradleReferenceIndex = Math.max(targetCradleReferenceIndex, listlowindex);\n  // ---------------------[ calc cradle content count ]---------------------\n  var newCradleContentCount = cradleRowcount * crosscount;\n  if (targetCradleEndRow == listEndRowOffset) {\n    if (endrowblanks) {\n      newCradleContentCount -= endrowblanks; // endRowRemainderCount)\n    }\n  }\n\n  if (targetCradleReferenceRow == rangerowshift) {\n    // first row\n    if (baserowblanks) {\n      newCradleContentCount -= baserowblanks;\n    }\n  }\n  // --------------------[ calc css positioning ]-----------------------\n  var targetScrollblockViewportPixelOffset = (targetAxisReferenceRow - rangerowshift) * baseRowPixelLength + padding - targetAxisViewportPixelOffset;\n  // ----------------------[ return required values ]---------------------\n  // console.log('4.targetCradleReferenceIndex, targetAxisReferenceIndex, newCradleContentCount\\n',\n  //     targetCradleReferenceIndex, targetAxisReferenceIndex, newCradleContentCount)\n  return {\n    targetCradleReferenceIndex: targetCradleReferenceIndex,\n    targetAxisReferenceIndex: targetAxisReferenceIndex,\n    targetScrollblockViewportPixelOffset: targetScrollblockViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount\n  };\n};\nexports.calculateContentListRequirements = calculateContentListRequirements;\n// ======================[ for updateCradleContent ]===========================\n/*\n    the two triggerlines must straddle the head of the viewport (top or left) so that\n    cradle motion can be detected. Motion is most often caused by scrolling, but\n    can also occur with change of size of cradle content rows.\n\n    generateShiftInstruction determines whether the axis should be moved toward the head or tail\n        to restore the straddling position of the two trigger lines. Lots of relative motion.\n\n    'moveaxisheadward' (scrolling down or right) means moving the axis up or left, adjacent items down\n         or right to the tail, dropping trailing tail items, and adding leading head items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'moveaxistailward' (scrolling up or left) means moving the axis down or right, adjacent items up\n         or left to the head, dropping trailing head items, and adding leading tail items as necessary\n         to maintain number of cradle rows of content constant.\n\n    'none' means no shift is required\n*/\nvar generateShiftInstruction = function generateShiftInstruction(_ref2) {\n  var orientation = _ref2.orientation,\n    triggerlineEntries = _ref2.triggerlineEntries,\n    triggerlineSpan = _ref2.triggerlineSpan,\n    scrollerID = _ref2.scrollerID,\n    isFirstRowTriggerConfig = _ref2.isFirstRowTriggerConfig,\n    viewportBoundingRect = _ref2.viewportBoundingRect,\n    triggerHistoryRef = _ref2.triggerHistoryRef;\n  var triggerData = {\n    headOffset: null,\n    tailOffset: null,\n    span: triggerlineSpan,\n    isFirstRowTriggerConfig: isFirstRowTriggerConfig\n  };\n  // most recent; either triggerline will do\n  var entry = triggerlineEntries[triggerlineEntries.length - 1]; //.at(-1) at not available in iOS 15\n  var referencename = entry.target.dataset.type;\n  entry.referencename = referencename;\n  var span = triggerlineSpan;\n  var intersectrootpos = orientation == 'vertical' ? Math.trunc(entry.rootBounds.y) : Math.trunc(entry.rootBounds.x);\n  var boundingrootpos = orientation == 'vertical' ? Math.trunc(viewportBoundingRect.y) : Math.trunc(viewportBoundingRect.x);\n  // this selection is redundant, but documents what's going on\n  var rootpos = intersectrootpos == boundingrootpos ? intersectrootpos : boundingrootpos; // we're in Safari, zoomed\n  var entrypos = orientation == 'vertical' ? Math.trunc(entry.boundingClientRect.y) : Math.trunc(entry.boundingClientRect.x);\n  var viewportTriggerOffset = entrypos - rootpos;\n  if (referencename == 'headtrigger') {\n    triggerData.headOffset = viewportTriggerOffset;\n    triggerData.tailOffset = viewportTriggerOffset + span;\n  } else {\n    // tailtrigger\n    triggerData.headOffset = viewportTriggerOffset - span;\n    triggerData.tailOffset = viewportTriggerOffset;\n  }\n  var shiftinstruction;\n  var triggerHistory = triggerHistoryRef.current;\n  // since triggers are moved and can share the 0 (zero) offset, an infinite loop can occur\n  // between the head and tail triggers. The following short-circuits that.\n  // Obviously needs work to generalize...\n  if ((0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset == 0 || triggerData.tailOffset == 0) || !(0, InfiniteGridScroller_1.isSafariIOS)() && (triggerData.headOffset >= -1 && triggerData.headOffset <= 1 || triggerData.tailOffset >= -1 && triggerData.tailOffset <= 1)) {\n    // some browsers do an infinite loop with the same previousReferenceName;\n    // usually alternates\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n      shiftinstruction = 'none';\n    } else {\n      if (triggerData.headOffset >= -1 && triggerData.headOffset <= 1) {\n        triggerHistory.previousReferenceName = 'headtrigger';\n      } else {\n        triggerHistory.previousReferenceName = 'tailtrigger';\n      }\n    }\n  } else {\n    if (triggerHistory.previousReferenceName) {\n      triggerHistory.previousReferenceName = null;\n    }\n  }\n  if (shiftinstruction) {\n    // will be 'none'\n    return [shiftinstruction, 0];\n  }\n  if (isFirstRowTriggerConfig) {\n    if (triggerData.headOffset <= 0) {\n      shiftinstruction = 'moveaxistailward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  } else {\n    if (triggerData.tailOffset <= 0) {\n      shiftinstruction = 'moveaxistailward';\n    } else if (triggerData.headOffset >= 0) {\n      shiftinstruction = 'moveaxisheadward';\n    } else {\n      shiftinstruction = 'none';\n    }\n  }\n  var triggerViewportReferencePixelPos = shiftinstruction == 'moveaxistailward' ?\n  // block is scrolling up or left\n  triggerData.tailOffset :\n  // needs to move up or left toward head\n  triggerData.headOffset; // needs to move down or right toward tail\n  // console.log('shiftinstruction, triggerViewportReferencePixelPos, triggerData\\n', \n  //     shiftinstruction, triggerViewportReferencePixelPos, triggerData)\n  return [shiftinstruction, triggerViewportReferencePixelPos];\n};\nexports.generateShiftInstruction = generateShiftInstruction;\n/*\n    The basic goal of calcContentShoft is to determine the number and direction of rows to shift between\n    the head and tail grids (which determines the new location of the axis), and also to\n    calculate the rolling addition and deletion of cradle content to accommodate the changes.\n\n    The number of rows to shift is determined by the pixel shift required to restore the\n    triggerlines to their straddle configuration around the head (top or left) of the viewport.\n\n    Adjustments are made to accommodate special requirements at the start and end of the virtual list.\n\n    DOM measurements are used where available (to accommodate variable dimension rows), and standard\n    units (cellHeight, cellWidth) used for estimates where necessary.\n*/\n// rowshift is at least 1 by the time this function is reached\n// ie. a shiftinstruction of 'moveaxisheadward' or 'moveaxistailward'\nvar calculateShiftSpecs = function calculateShiftSpecs(_ref3) {\n  var shiftinstruction = _ref3.shiftinstruction,\n    triggerViewportReferencePixelPos = _ref3.triggerViewportReferencePixelPos,\n    scrollPos = _ref3.scrollPos,\n    scrollblockElement = _ref3.scrollblockElement,\n    cradleInheritedProperties = _ref3.cradleInheritedProperties,\n    cradleContentProps = _ref3.cradleContentProps,\n    virtualListProps = _ref3.virtualListProps,\n    cradleContent = _ref3.cradleContent,\n    cradleElements = _ref3.cradleElements;\n  // ------------------------[ 1. initialize ]-----------------------\n  var _a, _b;\n  // cradle elements\n  var axisElement = cradleElements.axisRef.current,\n    headGridElement = cradleElements.headRef.current,\n    tailGridElement = cradleElements.tailRef.current;\n  var gap = cradleInheritedProperties.gap,\n    padding = cradleInheritedProperties.padding,\n    orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    layout = cradleInheritedProperties.layout,\n    scrollerID = cradleInheritedProperties.scrollerID,\n    cradlecontentlist = cradleContent.cradleModelComponents,\n    tailcontentlist = cradleContent.tailModelComponents,\n    cradleRowcount = cradleContentProps.cradleRowcount,\n    viewportRowcount = cradleContentProps.viewportRowcount,\n    runwayRowcount = cradleContentProps.runwayRowcount,\n    crosscount = virtualListProps.crosscount,\n    listRowcount = virtualListProps.rowcount,\n    listsize = virtualListProps.size,\n    listlowindex = virtualListProps.lowindex,\n    baserowblanks = virtualListProps.baserowblanks,\n    endrowblanks = virtualListProps.endrowblanks,\n    rangerowshift = virtualListProps.rowshift;\n  // scrollerID == 1 && console.log('vitrualListProps', virtualListProps)\n  // normalize\n  var previousCradleReferenceIndex = ((_a = cradlecontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n  var previousCradleReferenceRow = Math.floor(previousCradleReferenceIndex / crosscount);\n  var previousAxisReferenceIndex = ((_b = tailcontentlist[0]) === null || _b === void 0 ? void 0 : _b.props.index) || 0;\n  var previousAxisReferenceRow = Math.floor(previousAxisReferenceIndex / crosscount);\n  // scrollerID == 1 && console.log('previousCradleReferenceRow = Math.floor(previousCradleReferenceIndex/crosscount)\\n',\n  //     previousCradleReferenceRow, previousCradleReferenceIndex, crosscount)\n  // scrollerID == 1 && console.log('previousAxisReferenceRow = Math.floor(previousAxisReferenceIndex/crosscount)\\n',\n  //     previousAxisReferenceRow, previousAxisReferenceIndex, crosscount)\n  var listEndRow = listRowcount - 1 + rangerowshift;\n  var baseRowPixelLength = (orientation == 'vertical' ? cellHeight : cellWidth) + gap;\n  var foundGridSpanRowShiftIncrement,\n    gridSpanAxisPixelShift = 0,\n    // in relation to viewport head boundary\n    byPixelMeasureGridRowShiftCount = 0,\n    isListBoundary = false,\n    totalPixelShift,\n    finalVariableRowLength; // special case\n  // ----------------------------[ 2. calculate base row shift ]--------------------------\n  // measure exising variable rows for pixel length\n  if (layout == 'variable') {\n    var engagedGridElement =\n    // moving axis (and triggers) toward the reference grid element\n    shiftinstruction == 'moveaxistailward' ?\n    // scrolling up or left\n    tailGridElement : headGridElement;\n    var gridRowPixelLengthsList = getGridRowLengths(engagedGridElement, orientation, crosscount, gap);\n    if (shiftinstruction == 'moveaxisheadward') {\n      // scrolling down or right; move triggerlines up or left\n      gridRowPixelLengthsList.reverse(); // head grid row lengths listed from axis toward head\n    }\n\n    var gridRowCumulativePixelLengthsList = getGridRowAggregateSpans(gridRowPixelLengthsList); // count pixels where available\n    // first try to find position based on known (instantiated) rows\n    if (shiftinstruction == 'moveaxistailward') {\n      // scroll up\n      // tail trigger needs to move down or right until position relative to viewport top or left is positive\n      foundGridSpanRowShiftIncrement = gridRowCumulativePixelLengthsList.findIndex(function (cumulativepixellength) {\n        return triggerViewportReferencePixelPos + cumulativepixellength >= 0;\n      });\n    } else {\n      // 'moveaxisheadward', scrolldown\n      // head trigger needs to move up or left until position relative to viewport top or left is negative\n      foundGridSpanRowShiftIncrement = gridRowCumulativePixelLengthsList.findIndex(function (cumulativepixellength) {\n        return triggerViewportReferencePixelPos - cumulativepixellength <= 0;\n      });\n    }\n    if (foundGridSpanRowShiftIncrement != -1) {\n      // found measureed row for shift\n      gridSpanAxisPixelShift = shiftinstruction == 'moveaxistailward' ? gridRowCumulativePixelLengthsList[foundGridSpanRowShiftIncrement] :\n      // move axis toward tail from viewport boundary (positive)\n      -gridRowCumulativePixelLengthsList[foundGridSpanRowShiftIncrement]; // move axis toward head from viewport boundary (negative)\n    } else {\n      // no foundGridSpanRowShiftIncrement; either in boundary, or shy of target\n      isListBoundary = gridRowCumulativePixelLengthsList.length == 0; // boundary at head of list\n      if (!isListBoundary) {\n        // interim working result\n        byPixelMeasureGridRowShiftCount = gridRowCumulativePixelLengthsList.length - 1; // base: failed measured row ptr\n        totalPixelShift = gridRowCumulativePixelLengthsList[byPixelMeasureGridRowShiftCount]; // set base of working overshoot\n        finalVariableRowLength = gridRowPixelLengthsList.at(-1); // for oversize cell adjustment below\n      } else {\n        // else if isListBoundary row and pixel shifts remain at default of 0 each\n        byPixelMeasureGridRowShiftCount = 0;\n        totalPixelShift = 0;\n      }\n    }\n  } else {\n    // layout == 'uniform'; use only defined lengths\n    foundGridSpanRowShiftIncrement = -1; // \"not found\", ie not applicable\n    // these are the defaults\n    byPixelMeasureGridRowShiftCount = 0;\n    totalPixelShift = 0;\n  }\n  // uniform layout, or overshoot of instantiated rows; continue with virtual base rows\n  if (foundGridSpanRowShiftIncrement == -1) {\n    if (!isListBoundary) {\n      if (shiftinstruction == 'moveaxistailward') {\n        // scrolling up/left\n        do {\n          totalPixelShift += baseRowPixelLength;\n          byPixelMeasureGridRowShiftCount++;\n        } while (triggerViewportReferencePixelPos + totalPixelShift < 0);\n        gridSpanAxisPixelShift = totalPixelShift;\n      } else {\n        // moveaxisheadward; scrolling down/right\n        do {\n          totalPixelShift += baseRowPixelLength;\n          byPixelMeasureGridRowShiftCount++;\n          if (previousAxisReferenceRow - rangerowshift - byPixelMeasureGridRowShiftCount == 0) {\n            // stop cycling at head limit\n            break;\n          }\n        } while (triggerViewportReferencePixelPos - totalPixelShift > 0);\n        gridSpanAxisPixelShift = -totalPixelShift;\n      }\n    }\n    // byPixelMeasureGridRowCount is one greater than foundGridSpanRowIncrement with actual measurements above\n    // this -1 makes them compatible for span conversion (next step)\n    foundGridSpanRowShiftIncrement = byPixelMeasureGridRowShiftCount - 1;\n  }\n  var gridSpanRowShift =\n  // pick up row shift with or without overshoot\n  shiftinstruction == 'moveaxistailward' ? foundGridSpanRowShiftIncrement + 1 : -(foundGridSpanRowShiftIncrement + 1);\n  // the following two values (axisReferenceRowShift & axisPixelShift), and no other calcs, \n  //     are carried forward in this function.\n  // for axisReferenceRowshift:\n  // negative for moving rows out of head into tail;\n  // positive for moving rows out of tail into head\n  var axisReferenceRowShift = gridSpanRowShift,\n    axisPixelShift = gridSpanAxisPixelShift;\n  // this can only happen with oversized cellLength (ie > viewportLength)\n  //     and only using measured length\n  // axis must be no farther than 1 back of the last row end position\n  if (previousAxisReferenceRow + axisReferenceRowShift > listEndRow) {\n    axisReferenceRowShift -= 1;\n    if (layout == 'variable') {\n      axisPixelShift -= finalVariableRowLength;\n    } else {\n      axisPixelShift -= baseRowPixelLength;\n    }\n  }\n  // -----------[ 3. calculate current viewport axis pixel offset ]-------------------\n  // gaps beyond rendered rows can be caused by rapid scrolling\n  var scrollblockAxisPixelOffset = orientation == 'vertical' ? axisElement.offsetTop : axisElement.offsetLeft;\n  var scrollblockPixelOffset =\n  // to capture current top/left adjustment to viewport for variable layout\n  orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n  // currentViewportAxisOffset will be negative (above viewport edge) for scroll block headward \n  //     and positive for scroll block tailward\n  // the pixel distance between the viewport frame and the axis, toward the head\n  var currentViewportAxisPixelOffset = scrollblockAxisPixelOffset + scrollblockPixelOffset - scrollPos;\n  // -------------[ 4. calculate new axis pixel position ]------------------\n  var newAxisViewportPixelOffset = currentViewportAxisPixelOffset + axisPixelShift;\n  // Note: sections 5, 6 and 7 deal entirely with row calculations; no pixels\n  // ------------[ 5. calc new cradle and axis reference row offsets ]-------------\n  // base value for cradle reference shift; may change if beyond list bounds\n  var cradleReferenceRowshift = axisReferenceRowShift;\n  // base values\n  var newCradleReferenceRow = previousCradleReferenceRow + cradleReferenceRowshift;\n  var newAxisReferenceRow = previousAxisReferenceRow + axisReferenceRowShift;\n  // scrollerID == 1 && console.log('A-1. newCradleReferenceRow = previousCradleReferenceRow + cradleReferenceRowshift\\n',\n  //     newCradleReferenceRow, previousCradleReferenceRow, cradleReferenceRowshift)\n  // scrollerID == 1 && console.log('A-2. newAxisReferenceRow = previousAxisReferenceRow + axisReferenceRowShift\\n',\n  //     newAxisReferenceRow, previousAxisReferenceRow, axisReferenceRowShift)\n  // --------[ 6. adjust cradle contents for start and end of list ]-------\n  // ...to maintain constant number of cradle rows\n  if (shiftinstruction == 'moveaxistailward') {\n    // scrolling up/left\n    // a. if scrolling the block headward near the start of the list, new cradle row offset and\n    // cradle row shift count has to be adjusted to accommodate the leading runway\n    // b. if scrolling the block headward (revealing tail of list), as the cradle last row offset \n    // approaches max listrow, new cradle offset and cradle row shift have to be adjusted to prevent \n    // shortening of cradle content.\n    // --- start of list adjustment\n    var targetCradleReferenceRow = Math.max(rangerowshift, newAxisReferenceRow - runwayRowcount - 1); // extra row for visibility\n    var headrowDiff = newCradleReferenceRow - targetCradleReferenceRow;\n    if (headrowDiff > 0) {\n      newCradleReferenceRow -= headrowDiff;\n      cradleReferenceRowshift -= headrowDiff;\n    }\n    // --- end of list adjustment: case of being in bounds of trailing runway (end of list)\n    var targetCradleEndrow = newCradleReferenceRow + (cradleRowcount - 1);\n    var tailrowdiff = targetCradleEndrow - listEndRow;\n    // console.log('tailrowdiff = targetCradleEndrowOffset - listEndrowOffset, virtualListProps\\n',\n    //     tailrowdiff, targetCradleEndrowOffset, listEndrowOffset, virtualListProps)\n    if (tailrowdiff > 0) {\n      cradleReferenceRowshift -= tailrowdiff;\n      newCradleReferenceRow -= tailrowdiff;\n    }\n  } else {\n    // shiftinstruction == 'moveaxisheadward'; scrolling down/right\n    // c. if scrolling the block down or right (toward revealing head of list), as the cradlerowoffset \n    // hits 0, cradle changes have to be adjusted to prevent shortening of cradle content\n    // d. if scrolling headward near the end of the list, cradle changes have to be adjusted to \n    // accomodate the trailing runway\n    // --- start of list adjustment\n    // console.log('1. newCradleReferenceRowOffset < rangerowshift\\n',\n    //     newCradleReferenceRowOffset, rangerowshift)\n    if (newCradleReferenceRow < rangerowshift) {\n      var diff = rangerowshift - newCradleReferenceRow;\n      cradleReferenceRowshift += diff;\n      newCradleReferenceRow += diff;\n    }\n    // console.log('2. newCradleReferenceRowOffset\\n',\n    //     newCradleReferenceRowOffset)\n    if (layout == 'variable' && newAxisReferenceRow == rangerowshift) {\n      // start of list\n      newAxisViewportPixelOffset = padding;\n    }\n    // --- end of list adjustment; case of in bounds of trailing runway\n    var computedNextCradleEndRow = previousCradleReferenceRow + (cradleRowcount - 1) + cradleReferenceRowshift;\n    // console.log('computedNextCradleEndrowOffset = (previousCradleRowOffset + (cradleRowcount -1) + cradleReferenceRowshift)\\n',\n    //     computedNextCradleEndrowOffset, previousCradleRowOffset, cradleRowcount, cradleReferenceRowshift)\n    var targetCradleEndRow = newAxisReferenceRow + (viewportRowcount - 1) + (runwayRowcount - 1);\n    // console.log('targetCradleEndrowOffset = newAxisReferenceRowOffset + (viewportRowcount - 1) + (runwayRowcount - 1)\\n',\n    //     targetCradleEndrowOffset, listEndrowOffset, newAxisReferenceRowOffset, viewportRowcount, runwayRowcount)\n    // const tailrowdiff = targetCradleEndrowOffset - computedNextCradleEndrowOffset\n    var _tailrowdiff = computedNextCradleEndRow - targetCradleEndRow;\n    // console.log('tailrowdiff = computedNextCradleEndrowOffset - targetCradleEndrowOffset\\n',\n    //     tailrowdiff, computedNextCradleEndrowOffset, targetCradleEndrowOffset)\n    if (_tailrowdiff < 0) {\n      _tailrowdiff = Math.max(_tailrowdiff, cradleReferenceRowshift);\n      cradleReferenceRowshift -= _tailrowdiff;\n      newCradleReferenceRow -= _tailrowdiff;\n    }\n    // console.log('3. newCradleReferenceRowOffset, rangerowshift\\n',\n    //     newCradleReferenceRowOffset, rangerowshift)\n  }\n  // ----------------------[ 7. map rows to item references ]----------------------\n  var newCradleReferenceIndex = Math.max(listlowindex, newCradleReferenceRow * crosscount);\n  var cradleReferenceItemShift = newCradleReferenceIndex - previousCradleReferenceIndex;\n  var newAxisReferenceIndex = Math.max(listlowindex, newAxisReferenceRow * crosscount);\n  var axisReferenceItemShift = newAxisReferenceIndex - previousAxisReferenceIndex;\n  var newCradleContentCount = cradleRowcount * crosscount; // base count\n  var includesLastRow = newCradleReferenceRow + cradleRowcount - rangerowshift >= listRowcount;\n  // console.log('includesLastRow = ((newCradleReferenceRowOffset + cradleRowcount - rangerowshift) >= listRowcount)\\n',\n  //     includesLastRow, newCradleReferenceRowOffset, cradleRowcount, rangerowshift, listRowcount)\n  var includesFirstRow = newCradleReferenceRow == rangerowshift;\n  if (includesLastRow) {\n    newCradleContentCount -= endrowblanks;\n  }\n  if (includesFirstRow) {\n    newCradleContentCount -= baserowblanks;\n  }\n  // create head and tail change counts\n  var changeOfCradleContentCount = cradlecontentlist.length - newCradleContentCount;\n  var listStartChangeCount = -cradleReferenceItemShift;\n  var listEndChangeCount = -listStartChangeCount - changeOfCradleContentCount;\n  // console.log('listStartChangeCount, listEndChangeCount, cradleReferenceItemShift, changeOfCradleContentCount\\n',\n  //     listStartChangeCount, listEndChangeCount, cradleReferenceItemShift, changeOfCradleContentCount)\n  // ---------------------[ 8. return required values ]-------------------\n  // console.log('--\x3e> newCradleReferenceIndex, newAxisReferenceIndex\\n',\n  //     newCradleReferenceIndex, newAxisReferenceIndex)\n  return {\n    // newCradleReferenceIndex, \n    cradleReferenceItemShift: cradleReferenceItemShift,\n    newAxisReferenceIndex: newAxisReferenceIndex,\n    axisReferenceItemShift: axisReferenceItemShift,\n    newAxisViewportPixelOffset: newAxisViewportPixelOffset,\n    newCradleContentCount: newCradleContentCount,\n    listStartChangeCount: listStartChangeCount,\n    listEndChangeCount: listEndChangeCount\n  };\n};\nexports.calculateShiftSpecs = calculateShiftSpecs;\n// supports calcContentShift above\nvar getGridRowLengths = function getGridRowLengths(grid, orientation, crosscount, gap) {\n  var rowLengths = [];\n  var elementList = grid.childNodes;\n  var elementPtr = 0;\n  var element = elementList[elementPtr];\n  while (element) {\n    var rowlength = (orientation == 'vertical' ? element.offsetHeight : element.offsetWidth) + gap;\n    rowLengths.push(rowlength);\n    elementPtr += crosscount;\n    element = elementList[elementPtr];\n  }\n  return rowLengths;\n};\n// supports calcContentShift above\nvar getGridRowAggregateSpans = function getGridRowAggregateSpans(rowLengths) {\n  var rowSpans = [];\n  var span = 0;\n  rowLengths.forEach(function (value) {\n    span += value;\n    rowSpans.push(span);\n  });\n  return rowSpans;\n};\n// =====================[ shared by both setCradleContent and updateCradleContent ]====================\n// update content\n// adds CellFrames at end of contentlist according to headindexcount and tailindexcount,\n// or if indexcount values are <0 removes them.\nvar getCellFrameComponentList = function getCellFrameComponentList(_ref4) {\n  var cradleInheritedProperties = _ref4.cradleInheritedProperties,\n    cradleInternalProperties = _ref4.cradleInternalProperties,\n    cacheAPI = _ref4.cacheAPI,\n    cradleContentCount = _ref4.cradleContentCount,\n    cradleReferenceIndex = _ref4.cradleReferenceIndex,\n    listStartChangeCount = _ref4.listStartChangeCount,\n    listEndChangeCount = _ref4.listEndChangeCount,\n    contentlist = _ref4.workingContentList,\n    instanceIdCounterRef = _ref4.instanceIdCounterRef,\n    styles = _ref4.styles,\n    placeholderMessages = _ref4.placeholderMessages;\n  var localContentlist = _toConsumableArray(contentlist);\n  var lastindexoffset = cradleReferenceIndex + localContentlist.length - 1;\n  var headContentlist = [],\n    tailContentlist = [];\n  var deletedtailitems = [],\n    deletedheaditems = [];\n  if (listStartChangeCount >= 0) {\n    // acquire new items\n    var referenceIndex = cradleReferenceIndex;\n    var changeCount = listStartChangeCount;\n    if (listStartChangeCount > cradleContentCount) {\n      referenceIndex = cradleReferenceIndex - (listStartChangeCount - cradleContentCount);\n      changeCount = cradleContentCount;\n    }\n    for (var newindex = referenceIndex - changeCount; newindex < referenceIndex; newindex++) {\n      headContentlist.push(createCellFrame({\n        index: newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheAPI: cacheAPI,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedheaditems = localContentlist.splice(0, -listStartChangeCount);\n  }\n  if (listEndChangeCount >= 0) {\n    // acquire new items\n    var _referenceIndex = lastindexoffset;\n    var _changeCount = listEndChangeCount;\n    if (listEndChangeCount > cradleContentCount) {\n      _referenceIndex = lastindexoffset + (listEndChangeCount - cradleContentCount);\n      _changeCount = cradleContentCount;\n    }\n    for (var _newindex = _referenceIndex + 1; _newindex < _referenceIndex + 1 + _changeCount; _newindex++) {\n      tailContentlist.push(createCellFrame({\n        index: _newindex,\n        cradleInheritedProperties: cradleInheritedProperties,\n        cradleInternalProperties: cradleInternalProperties,\n        instanceIdCounterRef: instanceIdCounterRef,\n        cacheAPI: cacheAPI,\n        placeholderFrameStyles: styles.placeholderframe,\n        placeholderLinerStyles: styles.placeholderliner,\n        placeholderErrorFrameStyles: styles.placeholdererrorframe,\n        placeholderErrorLinerStyles: styles.placeholdererrorliner,\n        placeholderMessages: placeholderMessages\n      }));\n    }\n  } else {\n    deletedtailitems = localContentlist.splice(listEndChangeCount, -listEndChangeCount);\n  }\n  var deletedItems = [].concat(_toConsumableArray(deletedheaditems), _toConsumableArray(deletedtailitems));\n  var componentList = [].concat(headContentlist, _toConsumableArray(localContentlist), tailContentlist);\n  return [componentList, deletedItems];\n};\nexports.getCellFrameComponentList = getCellFrameComponentList;\n// Leading (head) all or partially hidden; tail, visible plus trailing hidden\nvar allocateContentList = function allocateContentList(_ref5) {\n  var contentlist = _ref5.contentlist,\n    axisReferenceIndex = _ref5.axisReferenceIndex,\n    layoutHandler = _ref5.layoutHandler;\n  var _a;\n  var triggercellIndex = layoutHandler.triggercellIndex;\n  var lowcontentindex = (_a = contentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index,\n    highcontentindex = lowcontentindex + contentlist.length;\n  var headitemcount = axisReferenceIndex - lowcontentindex;\n  var targetTriggercellIndex = headitemcount == 0 ? axisReferenceIndex : axisReferenceIndex - 1;\n  layoutHandler.triggercellIsInTail = headitemcount == 0 ? true : false;\n  if (triggercellIndex !== undefined && lowcontentindex !== undefined) {\n    //&& \n    if (triggercellIndex >= lowcontentindex && triggercellIndex <= highcontentindex) {\n      var _triggercellPtr = triggercellIndex - lowcontentindex;\n      var _triggercellComponent = contentlist[_triggercellPtr];\n      if (_triggercellComponent) {\n        // otherwise has been asynchronously cleared\n        contentlist[_triggercellPtr] = react_1[\"default\"].cloneElement(_triggercellComponent, {\n          isTriggercell: false\n        });\n      }\n    }\n  }\n  var triggercellPtr = targetTriggercellIndex - lowcontentindex;\n  var triggercellComponent = contentlist[triggercellPtr];\n  if (triggercellComponent) {\n    contentlist[triggercellPtr] = react_1[\"default\"].cloneElement(triggercellComponent, {\n      isTriggercell: true\n    });\n    layoutHandler.triggercellIndex = targetTriggercellIndex;\n  } else {\n    // defensive; shouldn't happen\n    console.log('FAILURE TO REGISTER TRIGGERCELL:');\n    console.log('axisReferenceIndex, triggercellIndex, lowcontentindex, highcontentindex, headitemcount, targetTriggercellIndex\\n', axisReferenceIndex, triggercellIndex, lowcontentindex, highcontentindex, headitemcount, targetTriggercellIndex);\n    console.log('triggercellPtr, triggercellComponent, triggercellComponent?.props.isTriggecell, contentlist\\n', triggercellPtr, triggercellComponent, triggercellComponent === null || triggercellComponent === void 0 ? void 0 : triggercellComponent.props.isTriggecell, Object.assign({}, contentlist));\n  }\n  var headlist = contentlist.slice(0, headitemcount);\n  var taillist = contentlist.slice(headitemcount);\n  return [headlist, taillist];\n};\nexports.allocateContentList = allocateContentList;\nvar deletePortals = function deletePortals(cacheAPI, deleteList, deleteListCallback) {\n  var dlist = deleteList.map(function (item) {\n    return item.props.index;\n  });\n  cacheAPI.deletePortalByIndex(dlist, deleteListCallback);\n};\nexports.deletePortals = deletePortals;\n// =====================[ internal, acquire item ]======================\nvar createCellFrame = function createCellFrame(_ref6) {\n  var index = _ref6.index,\n    cradleInheritedProperties = _ref6.cradleInheritedProperties,\n    cradleInternalProperties = _ref6.cradleInternalProperties,\n    instanceIdCounterRef = _ref6.instanceIdCounterRef,\n    cacheAPI = _ref6.cacheAPI,\n    placeholderFrameStyles = _ref6.placeholderFrameStyles,\n    placeholderLinerStyles = _ref6.placeholderLinerStyles,\n    placeholderErrorFrameStyles = _ref6.placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles = _ref6.placeholderErrorLinerStyles,\n    placeholderMessages = _ref6.placeholderMessages;\n  var instanceID = instanceIdCounterRef.current++;\n  var orientation = cradleInheritedProperties.orientation,\n    cellHeight = cradleInheritedProperties.cellHeight,\n    cellWidth = cradleInheritedProperties.cellWidth,\n    cellMinHeight = cradleInheritedProperties.cellMinHeight,\n    cellMinWidth = cradleInheritedProperties.cellMinWidth,\n    getItem = cradleInheritedProperties.getItem,\n    placeholder = cradleInheritedProperties.placeholder,\n    scrollerID = cradleInheritedProperties.scrollerID,\n    layout = cradleInheritedProperties.layout,\n    usePlaceholder = cradleInheritedProperties.usePlaceholder;\n  var listsize = cradleInternalProperties.virtualListProps.size;\n  // get new or existing itemID\n  var itemID = cacheAPI.getNewOrExistingItemID(index);\n  return react_1[\"default\"].createElement(CellFrame_1[\"default\"], {\n    key: instanceID,\n    orientation: orientation,\n    cellHeight: cellHeight,\n    cellWidth: cellWidth,\n    cellMinHeight: cellMinHeight,\n    cellMinWidth: cellMinWidth,\n    layout: layout,\n    index: index,\n    getItem: getItem,\n    listsize: listsize,\n    placeholder: placeholder,\n    itemID: itemID,\n    instanceID: instanceID,\n    scrollerID: scrollerID,\n    isTriggercell: false,\n    usePlaceholder: usePlaceholder,\n    placeholderFrameStyles: placeholderFrameStyles,\n    placeholderLinerStyles: placeholderLinerStyles,\n    placeholderErrorFrameStyles: placeholderErrorFrameStyles,\n    placeholderErrorLinerStyles: placeholderErrorLinerStyles,\n    placeholderMessages: placeholderMessages,\n    gridstartstyle: null\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdqRSxRQUFRLENBQUNrRSxzQkFBc0IsQ0FBQy9ILEtBQUssQ0FBQztFQUVyRCxPQUFPckcsT0FBQSxZQUFBcU8sYUFBQSxDQUFDbE8sV0FBQSxXQUFTO0lBQ2JtTyxHQUFHLEVBQUtULFVBQVU7SUFDbEJsTCxXQUFXLEVBQUtBLFdBQVc7SUFDM0I2QyxVQUFVLEVBQUtBLFVBQVU7SUFDekJDLFNBQVMsRUFBS0EsU0FBUztJQUN2QnFJLGFBQWEsRUFBS0EsYUFBYTtJQUMvQkMsWUFBWSxFQUFLQSxZQUFZO0lBQzdCckksTUFBTSxFQUFLQSxNQUFNO0lBQ2pCVyxLQUFLLEVBQUtBLEtBQUs7SUFDZjJILE9BQU8sRUFBS0EsT0FBTztJQUNuQmhJLFFBQVEsRUFBS0EsUUFBUTtJQUNyQmlJLFdBQVcsRUFBS0EsV0FBVztJQUMzQkUsTUFBTSxFQUFLQSxNQUFNO0lBQ2pCTixVQUFVLEVBQUtBLFVBQVU7SUFDekIvSyxVQUFVLEVBQUtBLFVBQVU7SUFDekJnSyxhQUFhLEVBQUssS0FBSztJQUN2Qm9CLGNBQWMsRUFBS0EsY0FBYztJQUNqQzlDLHNCQUFzQixFQUFLQSxzQkFBc0I7SUFDakRFLHNCQUFzQixFQUFLQSxzQkFBc0I7SUFDakRFLDJCQUEyQixFQUFLQSwyQkFBMkI7SUFDM0RFLDJCQUEyQixFQUFLQSwyQkFBMkI7SUFDM0RqQixtQkFBbUIsRUFBS0EsbUJBQW1CO0lBQzNDOEQsY0FBYyxFQUFJO0VBQUksRUFDeEI7QUFFTixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvY29udGVudGZ1bmN0aW9ucy50c3g/ZDJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb250ZW50ZnVuY3Rpb25zLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBzdXBwb3J0cyB0aGUgY29udGVudGhhbmRsZXIgbW9kdWxlLiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHBlcmZvcm1cbiAgICB0aGUgZGV0YWlsZWQgY2FsY3VsYXRpb25zIGFuZCBwcm9jZXNzZXMgcmVxdWlyZWQgYnkgdGhlIGNvbnRlbnRoYW5kbGVyLlxuXG4gICAgY2FsY3VsYXRlQ29udGVudExpc3RSZXF1aXJlbWVudHMgaXMgY2FsbGVkIGJ5IHRoZSBjb250ZW50aGFuZGxlcidzIHNldENyYWRsZUNvbnRlbnQgZnVuY3Rpb24uXG5cbiAgICBnZW5lcmF0ZVNoaWZ0SW5zdHJ1Y3Rpb24gYW5kIGNhbGNDb250ZW50U2hpZnQgYXJlIGNhbGxlZCBieSBjb250ZW50SGFuZGxlcidzIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICBmdW5jdGlvbi4gXG4gICAgXG4gICAgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCwgYWxsb2NhdGVDb250ZW50TGlzdCwgYW5kIGRlbGV0ZVBvcnRhbHMgZnVuY3Rpb25zIGFyZSBzaGFyZWQgYnkgYm90aC4gXG5cbiAgICBjcmVhdGVDZWxsRnJhbWUgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCBhcyBuZWVkZWQuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCBDZWxsRnJhbWUgZnJvbSAnLi4vQ2VsbEZyYW1lJ1xuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4uL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09WyBmb3Igc2V0Q3JhZGxlQ29udGVudCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50cyA9ICh7IC8vIGNhbGxlZCBmcm9tIHNldENyYWRsZUNvbnRlbnQgb25seVxuXG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZnJvbSB1c2VyLCBvciBmcm9tIHBpdm90XG4gICAgICAgIC8vIHBpeGVsc1xuICAgICAgICBiYXNlUm93UGl4ZWxMZW5ndGgsXG4gICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuICAgICAgICAvLyByZXNvdXJjZXNcbiAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuXG4gICAgfSkgPT4ge1xuXG4gICAgLy8gY29uc29sZS5sb2coJz09Pj4gY2FsY3VsYXRlQ29udGVudExpc3RSZXF1aXJlbWVudHM6MS4gdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4XFxuJyx0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICBjb25zdCB7IFxuICAgICAgICBwYWRkaW5nLFxuICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICBjb25zdCB7XG5cbiAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLFxuICAgICAgICB2aXJ0dWFsTGlzdFByb3BzLFxuXG4gICAgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuXG4gICAgY29uc3Qge1xuXG4gICAgICAgIGNyYWRsZVJvd2NvdW50LFxuICAgICAgICBydW53YXlSb3djb3VudCxcblxuICAgIH0gPSBjcmFkbGVDb250ZW50UHJvcHNcblxuICAgIGNvbnN0IHtcblxuICAgICAgICBsb3dpbmRleDpsaXN0bG93aW5kZXgsIFxuICAgICAgICBoaWdoaW5kZXg6bGlzdGhpZ2hpbmRleCwgXG4gICAgICAgIC8vIHNpemU6bGlzdHNpemUsIFxuICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgcm93Y291bnQ6bGlzdFJvd2NvdW50LFxuICAgICAgICBiYXNlcm93YmxhbmtzLFxuICAgICAgICBlbmRyb3dibGFua3MsXG4gICAgICAgIHJvd3NoaWZ0OnJhbmdlcm93c2hpZnQsXG5cbiAgICB9ID0gdmlydHVhbExpc3RQcm9wc1xuXG4gICAgLy8gYWxpZ24gYXhpcyByZWZlcmVuY2UgdG8gbGlzdCBzY29wZVxuICAgIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCA9IE1hdGgubWluKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgbGlzdGhpZ2hpbmRleClcbiAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXggPSBNYXRoLm1heCh0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIGxpc3Rsb3dpbmRleClcblxuICAgIC8vIGNvbnNvbGUubG9nKCcyLiB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXhcXG4nLHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleClcblxuICAgIC8vIGRlcml2ZSB0YXJnZXQgcm93XG4gICAgbGV0IHRhcmdldEF4aXNSZWZlcmVuY2VSb3cgPSBNYXRoLmZsb29yKHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuXG4gICAgLy8gY29uc29sZS5sb2coJzMuIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleFxcbicsdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGMgY3JhZGxlUmVmZXJlbmNlUm93ICYgSW5kZXggXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gbGVhZGluZyBlZGdlXG4gICAgbGV0IHRhcmdldENyYWRsZVJlZmVyZW5jZVJvdyA9IE1hdGgubWF4KHJhbmdlcm93c2hpZnQsdGFyZ2V0QXhpc1JlZmVyZW5jZVJvdyAtIHJ1bndheVJvd2NvdW50KVxuXG4gICAgLy8gdHJhaWxpbmcgZWRnZVxuICAgIGxldCB0YXJnZXRDcmFkbGVFbmRSb3cgPSB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3cgKyAoY3JhZGxlUm93Y291bnQgLSAxKVxuXG4gICAgY29uc3QgbGlzdEVuZFJvd09mZnNldCA9IChsaXN0Um93Y291bnQgLSAxKSArIHJhbmdlcm93c2hpZnRcblxuICAgIGlmICh0YXJnZXRDcmFkbGVFbmRSb3cgPiAobGlzdEVuZFJvd09mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9ICh0YXJnZXRDcmFkbGVFbmRSb3cgLSBsaXN0RW5kUm93T2Zmc2V0KVxuICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3cgLT0gZGlmZlxuICAgICAgICB0YXJnZXRDcmFkbGVFbmRSb3cgLT0gZGlmZlxuICAgIH1cblxuICAgIGxldCB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCA9ICh0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3cgKiBjcm9zc2NvdW50KVxuICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4ID0gTWF0aC5tYXgodGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsbGlzdGxvd2luZGV4KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWxjIGNyYWRsZSBjb250ZW50IGNvdW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnRcbiAgICBpZiAodGFyZ2V0Q3JhZGxlRW5kUm93ID09IGxpc3RFbmRSb3dPZmZzZXQpIHtcbiAgICAgICAgaWYgKGVuZHJvd2JsYW5rcykge1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50IC09IGVuZHJvd2JsYW5rcy8vIGVuZFJvd1JlbWFpbmRlckNvdW50KVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXRDcmFkbGVSZWZlcmVuY2VSb3cgPT0gcmFuZ2Vyb3dzaGlmdCkgeyAvLyBmaXJzdCByb3dcbiAgICAgICAgaWYgKGJhc2Vyb3dibGFua3MpIHtcbiAgICAgICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSBiYXNlcm93YmxhbmtzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVsgY2FsYyBjc3MgcG9zaXRpb25pbmcgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgKCh0YXJnZXRBeGlzUmVmZXJlbmNlUm93IC0gcmFuZ2Vyb3dzaGlmdCkgKiBiYXNlUm93UGl4ZWxMZW5ndGgpICsgcGFkZGluZyAtIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyByZXR1cm4gcmVxdWlyZWQgdmFsdWVzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbnNvbGUubG9nKCc0LnRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIG5ld0NyYWRsZUNvbnRlbnRDb3VudFxcbicsXG4gICAgLy8gICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIG5ld0NyYWRsZUNvbnRlbnRDb3VudClcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LFxuICAgICAgICB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIFxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQsIFxuICAgIH0gXG5cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PVsgZm9yIHVwZGF0ZUNyYWRsZUNvbnRlbnQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKlxuICAgIHRoZSB0d28gdHJpZ2dlcmxpbmVzIG11c3Qgc3RyYWRkbGUgdGhlIGhlYWQgb2YgdGhlIHZpZXdwb3J0ICh0b3Agb3IgbGVmdCkgc28gdGhhdFxuICAgIGNyYWRsZSBtb3Rpb24gY2FuIGJlIGRldGVjdGVkLiBNb3Rpb24gaXMgbW9zdCBvZnRlbiBjYXVzZWQgYnkgc2Nyb2xsaW5nLCBidXRcbiAgICBjYW4gYWxzbyBvY2N1ciB3aXRoIGNoYW5nZSBvZiBzaXplIG9mIGNyYWRsZSBjb250ZW50IHJvd3MuXG5cbiAgICBnZW5lcmF0ZVNoaWZ0SW5zdHJ1Y3Rpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBheGlzIHNob3VsZCBiZSBtb3ZlZCB0b3dhcmQgdGhlIGhlYWQgb3IgdGFpbFxuICAgICAgICB0byByZXN0b3JlIHRoZSBzdHJhZGRsaW5nIHBvc2l0aW9uIG9mIHRoZSB0d28gdHJpZ2dlciBsaW5lcy4gTG90cyBvZiByZWxhdGl2ZSBtb3Rpb24uXG5cbiAgICAnbW92ZWF4aXNoZWFkd2FyZCcgKHNjcm9sbGluZyBkb3duIG9yIHJpZ2h0KSBtZWFucyBtb3ZpbmcgdGhlIGF4aXMgdXAgb3IgbGVmdCwgYWRqYWNlbnQgaXRlbXMgZG93blxuICAgICAgICAgb3IgcmlnaHQgdG8gdGhlIHRhaWwsIGRyb3BwaW5nIHRyYWlsaW5nIHRhaWwgaXRlbXMsIGFuZCBhZGRpbmcgbGVhZGluZyBoZWFkIGl0ZW1zIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgdG8gbWFpbnRhaW4gbnVtYmVyIG9mIGNyYWRsZSByb3dzIG9mIGNvbnRlbnQgY29uc3RhbnQuXG5cbiAgICAnbW92ZWF4aXN0YWlsd2FyZCcgKHNjcm9sbGluZyB1cCBvciBsZWZ0KSBtZWFucyBtb3ZpbmcgdGhlIGF4aXMgZG93biBvciByaWdodCwgYWRqYWNlbnQgaXRlbXMgdXBcbiAgICAgICAgIG9yIGxlZnQgdG8gdGhlIGhlYWQsIGRyb3BwaW5nIHRyYWlsaW5nIGhlYWQgaXRlbXMsIGFuZCBhZGRpbmcgbGVhZGluZyB0YWlsIGl0ZW1zIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgdG8gbWFpbnRhaW4gbnVtYmVyIG9mIGNyYWRsZSByb3dzIG9mIGNvbnRlbnQgY29uc3RhbnQuXG5cbiAgICAnbm9uZScgbWVhbnMgbm8gc2hpZnQgaXMgcmVxdWlyZWRcbiovXG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVNoaWZ0SW5zdHJ1Y3Rpb24gPSAoe1xuXG4gICAgb3JpZW50YXRpb24sXG4gICAgdHJpZ2dlcmxpbmVFbnRyaWVzLFxuICAgIHRyaWdnZXJsaW5lU3BhbixcbiAgICBzY3JvbGxlcklELCAvLyBmb3IgZGVidWdcbiAgICBcbiAgICAvLyBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZyBpcyB0cnVlIGlmIHRoZSB0cmlnZ2VybGluZXMgYXJlIHdpdGggdGhlIGZpcnN0IHRhaWwgcm93IGluc3RlYWQgb2YgdGhlXG4gICAgLy8gbGFzdCBoZWFkcm93LiBUaGF0IGhhcHBlbnMgKHdvcmthcm91bmQpIHdoZW4gdGhlcmUgYXJlIG5vIGhlYWQgcm93c1xuICAgIGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnLCBcblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IG1lYXN1cmUgem9vbWVkIHZhbHVlcyBmb3Igcm9vdGJvdW5kcyBpbiB0cmlnZ2VybGluZUVudHJpZXMsIHNvIHdlIHRha2UgYSBkaXJlY3QgcmVhZGluZ1xuICAgIHZpZXdwb3J0Qm91bmRpbmdSZWN0LCBcbiAgICB0cmlnZ2VySGlzdG9yeVJlZixcblxufSkgPT4ge1xuXG4gICAgY29uc3QgdHJpZ2dlckRhdGEgPSB7XG4gICAgICAgIGhlYWRPZmZzZXQ6bnVsbCxcbiAgICAgICAgdGFpbE9mZnNldDpudWxsLFxuICAgICAgICBzcGFuOnRyaWdnZXJsaW5lU3BhbixcbiAgICAgICAgaXNGaXJzdFJvd1RyaWdnZXJDb25maWdcbiAgICB9XG5cbiAgICAvLyBtb3N0IHJlY2VudDsgZWl0aGVyIHRyaWdnZXJsaW5lIHdpbGwgZG9cbiAgICBjb25zdCBlbnRyeSA9IHRyaWdnZXJsaW5lRW50cmllc1t0cmlnZ2VybGluZUVudHJpZXMubGVuZ3RoIC0gMV0gLy8uYXQoLTEpIGF0IG5vdCBhdmFpbGFibGUgaW4gaU9TIDE1XG4gICAgY29uc3QgcmVmZXJlbmNlbmFtZSA9IGVudHJ5LnRhcmdldC5kYXRhc2V0LnR5cGVcbiAgICBlbnRyeS5yZWZlcmVuY2VuYW1lID0gcmVmZXJlbmNlbmFtZVxuICAgIGNvbnN0IHNwYW4gPSB0cmlnZ2VybGluZVNwYW5cblxuICAgIGNvbnN0IGludGVyc2VjdHJvb3Rwb3MgPSBcbiAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgTWF0aC50cnVuYyhlbnRyeS5yb290Qm91bmRzLnkpOlxuICAgICAgICAgICAgTWF0aC50cnVuYyhlbnRyeS5yb290Qm91bmRzLngpXG5cbiAgICBjb25zdCBib3VuZGluZ3Jvb3Rwb3MgPVxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBNYXRoLnRydW5jKHZpZXdwb3J0Qm91bmRpbmdSZWN0LnkpOlxuICAgICAgICAgICAgTWF0aC50cnVuYyh2aWV3cG9ydEJvdW5kaW5nUmVjdC54KVxuXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgcmVkdW5kYW50LCBidXQgZG9jdW1lbnRzIHdoYXQncyBnb2luZyBvblxuICAgIGNvbnN0IHJvb3Rwb3MgPSBcbiAgICAgICAgKGludGVyc2VjdHJvb3Rwb3MgPT0gYm91bmRpbmdyb290cG9zKT9cbiAgICAgICAgaW50ZXJzZWN0cm9vdHBvczpcbiAgICAgICAgYm91bmRpbmdyb290cG9zIC8vIHdlJ3JlIGluIFNhZmFyaSwgem9vbWVkXG5cbiAgICBjb25zdCBlbnRyeXBvcyA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBNYXRoLnRydW5jKGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC55KTpcbiAgICAgICAgICAgIE1hdGgudHJ1bmMoZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LngpXG5cbiAgICBjb25zdCB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgPSBlbnRyeXBvcyAtIHJvb3Rwb3NcblxuICAgIGlmIChyZWZlcmVuY2VuYW1lID09ICdoZWFkdHJpZ2dlcicpIHtcblxuICAgICAgICB0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID0gdmlld3BvcnRUcmlnZ2VyT2Zmc2V0XG4gICAgICAgIHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgKyBzcGFuXG5cbiAgICB9IGVsc2UgeyAvLyB0YWlsdHJpZ2dlclxuXG4gICAgICAgIHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXQgLSBzcGFuXG4gICAgICAgIHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPSB2aWV3cG9ydFRyaWdnZXJPZmZzZXRcblxuICAgIH1cblxuICAgIGxldCBzaGlmdGluc3RydWN0aW9uXG4gICAgXG4gICAgY29uc3QgdHJpZ2dlckhpc3RvcnkgPSB0cmlnZ2VySGlzdG9yeVJlZi5jdXJyZW50O1xuXG4gICAgLy8gc2luY2UgdHJpZ2dlcnMgYXJlIG1vdmVkIGFuZCBjYW4gc2hhcmUgdGhlIDAgKHplcm8pIG9mZnNldCwgYW4gaW5maW5pdGUgbG9vcCBjYW4gb2NjdXJcbiAgICAvLyBiZXR3ZWVuIHRoZSBoZWFkIGFuZCB0YWlsIHRyaWdnZXJzLiBUaGUgZm9sbG93aW5nIHNob3J0LWNpcmN1aXRzIHRoYXQuXG4gICAgLy8gT2J2aW91c2x5IG5lZWRzIHdvcmsgdG8gZ2VuZXJhbGl6ZS4uLlxuICAgIGlmICgoaXNTYWZhcmlJT1MoKSAmJiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA9PSAwIHx8IHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPT0gMCkpIHx8XG4gICAgICAgICghaXNTYWZhcmlJT1MoKSAmJiAoKCh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IC0xKSAmJiAodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA8PSAxKSkgfHwgXG4gICAgICAgICgodHJpZ2dlckRhdGEudGFpbE9mZnNldCA+PSAtMSkgJiYgKHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPD0gMSkpKSkpIHtcblxuICAgICAgICAvLyBzb21lIGJyb3dzZXJzIGRvIGFuIGluZmluaXRlIGxvb3Agd2l0aCB0aGUgc2FtZSBwcmV2aW91c1JlZmVyZW5jZU5hbWU7XG4gICAgICAgIC8vIHVzdWFsbHkgYWx0ZXJuYXRlc1xuICAgICAgICBpZiAodHJpZ2dlckhpc3RvcnkucHJldmlvdXNSZWZlcmVuY2VOYW1lKSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSA9IG51bGxcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICgodHJpZ2dlckRhdGEuaGVhZE9mZnNldCA+PSAtMSkgJiYgKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPD0gMSkpIHtcblxuICAgICAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSA9ICdoZWFkdHJpZ2dlcidcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSA9ICd0YWlsdHJpZ2dlcidcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJIaXN0b3J5LnByZXZpb3VzUmVmZXJlbmNlTmFtZSkge1xuXG4gICAgICAgICAgICB0cmlnZ2VySGlzdG9yeS5wcmV2aW91c1JlZmVyZW5jZU5hbWUgPSBudWxsXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaGlmdGluc3RydWN0aW9uKSB7IC8vIHdpbGwgYmUgJ25vbmUnXG5cbiAgICAgICAgcmV0dXJuIFtzaGlmdGluc3RydWN0aW9uLCAwXVxuXG4gICAgfVxuXG4gICAgaWYgKGlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnKSB7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJEYXRhLmhlYWRPZmZzZXQgPD0gMCkge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ21vdmVheGlzdGFpbHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdub25lJ1xuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJEYXRhLnRhaWxPZmZzZXQgPD0gMCkge1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uID0gJ21vdmVheGlzdGFpbHdhcmQnXG5cbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0ID49IDApIHtcblxuICAgICAgICAgICAgc2hpZnRpbnN0cnVjdGlvbiA9ICdtb3ZlYXhpc2hlYWR3YXJkJ1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24gPSAnbm9uZSdcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcyA9IFxuICAgICAgICAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpPyAvLyBibG9jayBpcyBzY3JvbGxpbmcgdXAgb3IgbGVmdFxuICAgICAgICAgICAgdHJpZ2dlckRhdGEudGFpbE9mZnNldDogLy8gbmVlZHMgdG8gbW92ZSB1cCBvciBsZWZ0IHRvd2FyZCBoZWFkXG4gICAgICAgICAgICB0cmlnZ2VyRGF0YS5oZWFkT2Zmc2V0IC8vIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB0b3dhcmQgdGFpbFxuXG4gICAgLy8gY29uc29sZS5sb2coJ3NoaWZ0aW5zdHJ1Y3Rpb24sIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zLCB0cmlnZ2VyRGF0YVxcbicsIFxuICAgIC8vICAgICBzaGlmdGluc3RydWN0aW9uLCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcywgdHJpZ2dlckRhdGEpXG5cbiAgICByZXR1cm4gW3NoaWZ0aW5zdHJ1Y3Rpb24sIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zXVxuXG59XG5cbi8qXG4gICAgVGhlIGJhc2ljIGdvYWwgb2YgY2FsY0NvbnRlbnRTaG9mdCBpcyB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBhbmQgZGlyZWN0aW9uIG9mIHJvd3MgdG8gc2hpZnQgYmV0d2VlblxuICAgIHRoZSBoZWFkIGFuZCB0YWlsIGdyaWRzICh3aGljaCBkZXRlcm1pbmVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGF4aXMpLCBhbmQgYWxzbyB0b1xuICAgIGNhbGN1bGF0ZSB0aGUgcm9sbGluZyBhZGRpdGlvbiBhbmQgZGVsZXRpb24gb2YgY3JhZGxlIGNvbnRlbnQgdG8gYWNjb21tb2RhdGUgdGhlIGNoYW5nZXMuXG5cbiAgICBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gc2hpZnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGl4ZWwgc2hpZnQgcmVxdWlyZWQgdG8gcmVzdG9yZSB0aGUgXG4gICAgdHJpZ2dlcmxpbmVzIHRvIHRoZWlyIHN0cmFkZGxlIGNvbmZpZ3VyYXRpb24gYXJvdW5kIHRoZSBoZWFkICh0b3Agb3IgbGVmdCkgb2YgdGhlIHZpZXdwb3J0LlxuXG4gICAgQWRqdXN0bWVudHMgYXJlIG1hZGUgdG8gYWNjb21tb2RhdGUgc3BlY2lhbCByZXF1aXJlbWVudHMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHZpcnR1YWwgbGlzdC5cblxuICAgIERPTSBtZWFzdXJlbWVudHMgYXJlIHVzZWQgd2hlcmUgYXZhaWxhYmxlICh0byBhY2NvbW1vZGF0ZSB2YXJpYWJsZSBkaW1lbnNpb24gcm93cyksIGFuZCBzdGFuZGFyZFxuICAgIHVuaXRzIChjZWxsSGVpZ2h0LCBjZWxsV2lkdGgpIHVzZWQgZm9yIGVzdGltYXRlcyB3aGVyZSBuZWNlc3NhcnkuXG4qL1xuXG4vLyByb3dzaGlmdCBpcyBhdCBsZWFzdCAxIGJ5IHRoZSB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgcmVhY2hlZFxuLy8gaWUuIGEgc2hpZnRpbnN0cnVjdGlvbiBvZiAnbW92ZWF4aXNoZWFkd2FyZCcgb3IgJ21vdmVheGlzdGFpbHdhcmQnXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU2hpZnRTcGVjcyA9ICh7XG5cbiAgICAvLyBkaXJlY3Rpb24gb2YgY2hhbmdlXG4gICAgc2hpZnRpbnN0cnVjdGlvbixcbiAgICB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcyxcblxuICAgIC8vIHBvc2l0aW9uYWxcbiAgICBzY3JvbGxQb3MsXG4gICAgc2Nyb2xsYmxvY2tFbGVtZW50LFxuXG4gICAgLy8gcHJvcGVydHkgcmVwb3NcbiAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgIGNyYWRsZUNvbnRlbnRQcm9wcyxcbiAgICB2aXJ0dWFsTGlzdFByb3BzLFxuXG4gICAgLy8gY3JhZGxlIHJlcG9zXG4gICAgY3JhZGxlQ29udGVudCxcbiAgICBjcmFkbGVFbGVtZW50cyxcblxufSkgPT4ge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gY3JhZGxlIGVsZW1lbnRzXG4gICAgY29uc3QgXG4gICAgICAgIGF4aXNFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuYXhpc1JlZi5jdXJyZW50LFxuICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudFxuXG4gICAgY29uc3QgXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb24gZGF0YVxuICAgICAgICB7IFxuXG4gICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgc2Nyb2xsZXJJRCwgLy8gZGVidWdcblxuICAgICAgICB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcblxuICAgICAgICAvLyBjcmFkbGUgY29udGVudHNcbiAgICAgICAge1xuXG4gICAgICAgICAgICBjcmFkbGVNb2RlbENvbXBvbmVudHM6Y3JhZGxlY29udGVudGxpc3QsIFxuICAgICAgICAgICAgdGFpbE1vZGVsQ29tcG9uZW50czp0YWlsY29udGVudGxpc3QsXG5cbiAgICAgICAgfSA9IGNyYWRsZUNvbnRlbnQsXG5cbiAgICAgICAgeyBcblxuICAgICAgICAgICAgY3JhZGxlUm93Y291bnQsXG4gICAgICAgICAgICB2aWV3cG9ydFJvd2NvdW50LFxuICAgICAgICAgICAgcnVud2F5Um93Y291bnQsXG5cbiAgICAgICAgfSA9IGNyYWRsZUNvbnRlbnRQcm9wcyxcblxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgcm93Y291bnQ6bGlzdFJvd2NvdW50LCBcbiAgICAgICAgICAgIHNpemU6bGlzdHNpemUsXG4gICAgICAgICAgICBsb3dpbmRleDpsaXN0bG93aW5kZXgsXG4gICAgICAgICAgICBiYXNlcm93YmxhbmtzLFxuICAgICAgICAgICAgZW5kcm93YmxhbmtzLFxuICAgICAgICAgICAgcm93c2hpZnQ6cmFuZ2Vyb3dzaGlmdCxcbiAgICAgICAgICAgIFxuICAgICAgICB9ID0gdmlydHVhbExpc3RQcm9wc1xuXG4gICAgLy8gc2Nyb2xsZXJJRCA9PSAxICYmIGNvbnNvbGUubG9nKCd2aXRydWFsTGlzdFByb3BzJywgdmlydHVhbExpc3RQcm9wcylcblxuICAgIC8vIG5vcm1hbGl6ZVxuICAgIGNvbnN0IHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXggPSAoY3JhZGxlY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApXG4gICAgY29uc3QgcHJldmlvdXNDcmFkbGVSZWZlcmVuY2VSb3cgPSBNYXRoLmZsb29yKHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcblxuICAgIGNvbnN0IHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4ID0gKHRhaWxjb250ZW50bGlzdFswXT8ucHJvcHMuaW5kZXggfHwgMClcbiAgICBjb25zdCBwcmV2aW91c0F4aXNSZWZlcmVuY2VSb3cgPSBNYXRoLmZsb29yKHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG5cbiAgICAvLyBzY3JvbGxlcklEID09IDEgJiYgY29uc29sZS5sb2coJ3ByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlUm93ID0gTWF0aC5mbG9vcihwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXFxuJyxcbiAgICAvLyAgICAgcHJldmlvdXNDcmFkbGVSZWZlcmVuY2VSb3csIHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlSW5kZXgsIGNyb3NzY291bnQpXG5cbiAgICAvLyBzY3JvbGxlcklEID09IDEgJiYgY29uc29sZS5sb2coJ3ByZXZpb3VzQXhpc1JlZmVyZW5jZVJvdyA9IE1hdGguZmxvb3IocHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudClcXG4nLFxuICAgIC8vICAgICBwcmV2aW91c0F4aXNSZWZlcmVuY2VSb3csIHByZXZpb3VzQXhpc1JlZmVyZW5jZUluZGV4LCBjcm9zc2NvdW50KVxuXG4gICAgY29uc3QgbGlzdEVuZFJvdyA9IChsaXN0Um93Y291bnQgLSAxKSArIHJhbmdlcm93c2hpZnRcblxuICAgIGNvbnN0IGJhc2VSb3dQaXhlbExlbmd0aCA9XG4gICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgY2VsbFdpZHRoKSBcbiAgICAgICAgKyBnYXBcblxuICAgIGxldCBmb3VuZEdyaWRTcGFuUm93U2hpZnRJbmNyZW1lbnQsXG4gICAgICAgIGdyaWRTcGFuQXhpc1BpeGVsU2hpZnQgPSAwLCAvLyBpbiByZWxhdGlvbiB0byB2aWV3cG9ydCBoZWFkIGJvdW5kYXJ5XG4gICAgICAgIGJ5UGl4ZWxNZWFzdXJlR3JpZFJvd1NoaWZ0Q291bnQgPSAwLFxuICAgICAgICBpc0xpc3RCb3VuZGFyeSA9IGZhbHNlLFxuICAgICAgICB0b3RhbFBpeGVsU2hpZnQsXG4gICAgICAgIGZpbmFsVmFyaWFibGVSb3dMZW5ndGggLy8gc3BlY2lhbCBjYXNlXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAyLiBjYWxjdWxhdGUgYmFzZSByb3cgc2hpZnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBtZWFzdXJlIGV4aXNpbmcgdmFyaWFibGUgcm93cyBmb3IgcGl4ZWwgbGVuZ3RoXG4gICAgaWYgKGxheW91dCA9PSAndmFyaWFibGUnKSB7IFxuXG4gICAgICAgIGNvbnN0IGVuZ2FnZWRHcmlkRWxlbWVudCA9IC8vIG1vdmluZyBheGlzIChhbmQgdHJpZ2dlcnMpIHRvd2FyZCB0aGUgcmVmZXJlbmNlIGdyaWQgZWxlbWVudFxuICAgICAgICAgICAgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzdGFpbHdhcmQnKT8gLy8gc2Nyb2xsaW5nIHVwIG9yIGxlZnRcbiAgICAgICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQ6XG4gICAgICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50XG5cbiAgICAgICAgY29uc3QgZ3JpZFJvd1BpeGVsTGVuZ3Roc0xpc3QgPSBnZXRHcmlkUm93TGVuZ3RocyhlbmdhZ2VkR3JpZEVsZW1lbnQsIG9yaWVudGF0aW9uLCBjcm9zc2NvdW50LCBnYXApXG5cbiAgICAgICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzaGVhZHdhcmQnKSB7IC8vIHNjcm9sbGluZyBkb3duIG9yIHJpZ2h0OyBtb3ZlIHRyaWdnZXJsaW5lcyB1cCBvciBsZWZ0XG5cbiAgICAgICAgICAgIGdyaWRSb3dQaXhlbExlbmd0aHNMaXN0LnJldmVyc2UoKSAvLyBoZWFkIGdyaWQgcm93IGxlbmd0aHMgbGlzdGVkIGZyb20gYXhpcyB0b3dhcmQgaGVhZFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmlkUm93Q3VtdWxhdGl2ZVBpeGVsTGVuZ3Roc0xpc3QgPSBnZXRHcmlkUm93QWdncmVnYXRlU3BhbnMoZ3JpZFJvd1BpeGVsTGVuZ3Roc0xpc3QpIC8vIGNvdW50IHBpeGVscyB3aGVyZSBhdmFpbGFibGVcblxuICAgICAgICAvLyBmaXJzdCB0cnkgdG8gZmluZCBwb3NpdGlvbiBiYXNlZCBvbiBrbm93biAoaW5zdGFudGlhdGVkKSByb3dzXG4gICAgICAgIGlmIChzaGlmdGluc3RydWN0aW9uID09ICdtb3ZlYXhpc3RhaWx3YXJkJykgeyAvLyBzY3JvbGwgdXBcblxuICAgICAgICAgICAgLy8gdGFpbCB0cmlnZ2VyIG5lZWRzIHRvIG1vdmUgZG93biBvciByaWdodCB1bnRpbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3Agb3IgbGVmdCBpcyBwb3NpdGl2ZVxuICAgICAgICAgICAgZm91bmRHcmlkU3BhblJvd1NoaWZ0SW5jcmVtZW50ID0gZ3JpZFJvd0N1bXVsYXRpdmVQaXhlbExlbmd0aHNMaXN0LmZpbmRJbmRleCgoY3VtdWxhdGl2ZXBpeGVsbGVuZ3RoKSA9PiBcbiAgICAgICAgICAgICAgICAodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUGl4ZWxQb3MgKyBjdW11bGF0aXZlcGl4ZWxsZW5ndGgpID49IDAgKVxuICAgICAgICBcbiAgICAgICAgfSBlbHNlIHsgLy8gJ21vdmVheGlzaGVhZHdhcmQnLCBzY3JvbGxkb3duXG5cbiAgICAgICAgICAgIC8vIGhlYWQgdHJpZ2dlciBuZWVkcyB0byBtb3ZlIHVwIG9yIGxlZnQgdW50aWwgcG9zaXRpb24gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wIG9yIGxlZnQgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgIGZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudCA9IGdyaWRSb3dDdW11bGF0aXZlUGl4ZWxMZW5ndGhzTGlzdC5maW5kSW5kZXgoKGN1bXVsYXRpdmVwaXhlbGxlbmd0aCkgPT4gXG4gICAgICAgICAgICAgICAgKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zIC0gY3VtdWxhdGl2ZXBpeGVsbGVuZ3RoKSA8PSAwKVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmRHcmlkU3BhblJvd1NoaWZ0SW5jcmVtZW50ICE9IC0xKSB7IC8vIGZvdW5kIG1lYXN1cmVlZCByb3cgZm9yIHNoaWZ0XG5cbiAgICAgICAgICAgIGdyaWRTcGFuQXhpc1BpeGVsU2hpZnQgPSBcbiAgICAgICAgICAgICAgICAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgICAgICAgICBncmlkUm93Q3VtdWxhdGl2ZVBpeGVsTGVuZ3Roc0xpc3RbZm91bmRHcmlkU3BhblJvd1NoaWZ0SW5jcmVtZW50XTogLy8gbW92ZSBheGlzIHRvd2FyZCB0YWlsIGZyb20gdmlld3BvcnQgYm91bmRhcnkgKHBvc2l0aXZlKVxuICAgICAgICAgICAgICAgICAgICAtZ3JpZFJvd0N1bXVsYXRpdmVQaXhlbExlbmd0aHNMaXN0W2ZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudF0gLy8gbW92ZSBheGlzIHRvd2FyZCBoZWFkIGZyb20gdmlld3BvcnQgYm91bmRhcnkgKG5lZ2F0aXZlKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG5vIGZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudDsgZWl0aGVyIGluIGJvdW5kYXJ5LCBvciBzaHkgb2YgdGFyZ2V0XG5cbiAgICAgICAgICAgIGlzTGlzdEJvdW5kYXJ5ID0gKGdyaWRSb3dDdW11bGF0aXZlUGl4ZWxMZW5ndGhzTGlzdC5sZW5ndGggPT0gMCkgLy8gYm91bmRhcnkgYXQgaGVhZCBvZiBsaXN0XG5cbiAgICAgICAgICAgIGlmICghaXNMaXN0Qm91bmRhcnkpIHsgLy8gaW50ZXJpbSB3b3JraW5nIHJlc3VsdFxuXG4gICAgICAgICAgICAgICAgYnlQaXhlbE1lYXN1cmVHcmlkUm93U2hpZnRDb3VudCA9IGdyaWRSb3dDdW11bGF0aXZlUGl4ZWxMZW5ndGhzTGlzdC5sZW5ndGggLSAxIC8vIGJhc2U6IGZhaWxlZCBtZWFzdXJlZCByb3cgcHRyXG4gICAgICAgICAgICAgICAgdG90YWxQaXhlbFNoaWZ0ID0gZ3JpZFJvd0N1bXVsYXRpdmVQaXhlbExlbmd0aHNMaXN0W2J5UGl4ZWxNZWFzdXJlR3JpZFJvd1NoaWZ0Q291bnRdIC8vIHNldCBiYXNlIG9mIHdvcmtpbmcgb3ZlcnNob290XG4gICAgICAgICAgICAgICAgZmluYWxWYXJpYWJsZVJvd0xlbmd0aCA9IGdyaWRSb3dQaXhlbExlbmd0aHNMaXN0LmF0KC0xKSAvLyBmb3Igb3ZlcnNpemUgY2VsbCBhZGp1c3RtZW50IGJlbG93XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGVsc2UgaWYgaXNMaXN0Qm91bmRhcnkgcm93IGFuZCBwaXhlbCBzaGlmdHMgcmVtYWluIGF0IGRlZmF1bHQgb2YgMCBlYWNoXG5cbiAgICAgICAgICAgICAgICBieVBpeGVsTWVhc3VyZUdyaWRSb3dTaGlmdENvdW50ID0gMFxuICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCA9IDBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIGxheW91dCA9PSAndW5pZm9ybSc7IHVzZSBvbmx5IGRlZmluZWQgbGVuZ3Roc1xuXG4gICAgICAgIGZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudCA9IC0xIC8vIFwibm90IGZvdW5kXCIsIGllIG5vdCBhcHBsaWNhYmxlXG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSBkZWZhdWx0c1xuICAgICAgICBieVBpeGVsTWVhc3VyZUdyaWRSb3dTaGlmdENvdW50ID0gMFxuICAgICAgICB0b3RhbFBpeGVsU2hpZnQgPSAwXG5cbiAgICB9XG5cbiAgICAvLyB1bmlmb3JtIGxheW91dCwgb3Igb3ZlcnNob290IG9mIGluc3RhbnRpYXRlZCByb3dzOyBjb250aW51ZSB3aXRoIHZpcnR1YWwgYmFzZSByb3dzXG4gICAgaWYgKGZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudCA9PSAtMSApIHsgXG5cbiAgICAgICAgaWYgKCFpc0xpc3RCb3VuZGFyeSkge1xuXG4gICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIHVwL2xlZnRcblxuICAgICAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgICAgICB0b3RhbFBpeGVsU2hpZnQgKz0gYmFzZVJvd1BpeGVsTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGJ5UGl4ZWxNZWFzdXJlR3JpZFJvd1NoaWZ0Q291bnQrK1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zICsgdG90YWxQaXhlbFNoaWZ0KSA8IDApIFxuXG4gICAgICAgICAgICAgICAgZ3JpZFNwYW5BeGlzUGl4ZWxTaGlmdCA9IHRvdGFsUGl4ZWxTaGlmdFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtb3ZlYXhpc2hlYWR3YXJkOyBzY3JvbGxpbmcgZG93bi9yaWdodFxuXG4gICAgICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUGl4ZWxTaGlmdCArPSBiYXNlUm93UGl4ZWxMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgYnlQaXhlbE1lYXN1cmVHcmlkUm93U2hpZnRDb3VudCsrXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aW91c0F4aXNSZWZlcmVuY2VSb3cgLSByYW5nZXJvd3NoaWZ0IC0gYnlQaXhlbE1lYXN1cmVHcmlkUm93U2hpZnRDb3VudCkgPT0gMCkgeyAvLyBzdG9wIGN5Y2xpbmcgYXQgaGVhZCBsaW1pdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgodHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUGl4ZWxQb3MgLSB0b3RhbFBpeGVsU2hpZnQpID4gMClcblxuICAgICAgICAgICAgICAgIGdyaWRTcGFuQXhpc1BpeGVsU2hpZnQgPSAtdG90YWxQaXhlbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnlQaXhlbE1lYXN1cmVHcmlkUm93Q291bnQgaXMgb25lIGdyZWF0ZXIgdGhhbiBmb3VuZEdyaWRTcGFuUm93SW5jcmVtZW50IHdpdGggYWN0dWFsIG1lYXN1cmVtZW50cyBhYm92ZVxuICAgICAgICAvLyB0aGlzIC0xIG1ha2VzIHRoZW0gY29tcGF0aWJsZSBmb3Igc3BhbiBjb252ZXJzaW9uIChuZXh0IHN0ZXApXG4gICAgICAgIGZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudCA9IGJ5UGl4ZWxNZWFzdXJlR3JpZFJvd1NoaWZ0Q291bnQgLSAxXG5cbiAgICB9XG5cbiAgICBjb25zdCBncmlkU3BhblJvd1NoaWZ0ID0gLy8gcGljayB1cCByb3cgc2hpZnQgd2l0aCBvciB3aXRob3V0IG92ZXJzaG9vdFxuICAgICAgICAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpP1xuICAgICAgICAgICAgZm91bmRHcmlkU3BhblJvd1NoaWZ0SW5jcmVtZW50ICsgMTpcbiAgICAgICAgICAgIC0oZm91bmRHcmlkU3BhblJvd1NoaWZ0SW5jcmVtZW50ICsgMSlcblxuICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIHZhbHVlcyAoYXhpc1JlZmVyZW5jZVJvd1NoaWZ0ICYgYXhpc1BpeGVsU2hpZnQpLCBhbmQgbm8gb3RoZXIgY2FsY3MsIFxuICAgIC8vICAgICBhcmUgY2FycmllZCBmb3J3YXJkIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgLy8gZm9yIGF4aXNSZWZlcmVuY2VSb3dzaGlmdDpcbiAgICAvLyBuZWdhdGl2ZSBmb3IgbW92aW5nIHJvd3Mgb3V0IG9mIGhlYWQgaW50byB0YWlsO1xuICAgIC8vIHBvc2l0aXZlIGZvciBtb3Zpbmcgcm93cyBvdXQgb2YgdGFpbCBpbnRvIGhlYWRcbiAgICBsZXQgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0ID0gZ3JpZFNwYW5Sb3dTaGlmdCxcbiAgICAgICAgYXhpc1BpeGVsU2hpZnQgPSBncmlkU3BhbkF4aXNQaXhlbFNoaWZ0IFxuXG4gICAgLy8gdGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aCBvdmVyc2l6ZWQgY2VsbExlbmd0aCAoaWUgPiB2aWV3cG9ydExlbmd0aClcbiAgICAvLyAgICAgYW5kIG9ubHkgdXNpbmcgbWVhc3VyZWQgbGVuZ3RoXG4gICAgLy8gYXhpcyBtdXN0IGJlIG5vIGZhcnRoZXIgdGhhbiAxIGJhY2sgb2YgdGhlIGxhc3Qgcm93IGVuZCBwb3NpdGlvblxuICAgIGlmICgocHJldmlvdXNBeGlzUmVmZXJlbmNlUm93ICsgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0KSA+IGxpc3RFbmRSb3cpIHtcblxuICAgICAgICBheGlzUmVmZXJlbmNlUm93U2hpZnQgLT0gMVxuICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGF4aXNQaXhlbFNoaWZ0IC09IGZpbmFsVmFyaWFibGVSb3dMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXNQaXhlbFNoaWZ0IC09IGJhc2VSb3dQaXhlbExlbmd0aFxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLVsgMy4gY2FsY3VsYXRlIGN1cnJlbnQgdmlld3BvcnQgYXhpcyBwaXhlbCBvZmZzZXQgXS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnYXBzIGJleW9uZCByZW5kZXJlZCByb3dzIGNhbiBiZSBjYXVzZWQgYnkgcmFwaWQgc2Nyb2xsaW5nXG5cbiAgICBjb25zdCBzY3JvbGxibG9ja0F4aXNQaXhlbE9mZnNldCA9IFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICBjb25zdCBzY3JvbGxibG9ja1BpeGVsT2Zmc2V0ID0gLy8gdG8gY2FwdHVyZSBjdXJyZW50IHRvcC9sZWZ0IGFkanVzdG1lbnQgdG8gdmlld3BvcnQgZm9yIHZhcmlhYmxlIGxheW91dFxuICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wOlxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgIC8vIGN1cnJlbnRWaWV3cG9ydEF4aXNPZmZzZXQgd2lsbCBiZSBuZWdhdGl2ZSAoYWJvdmUgdmlld3BvcnQgZWRnZSkgZm9yIHNjcm9sbCBibG9jayBoZWFkd2FyZCBcbiAgICAvLyAgICAgYW5kIHBvc2l0aXZlIGZvciBzY3JvbGwgYmxvY2sgdGFpbHdhcmRcbiAgICAvLyB0aGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgZnJhbWUgYW5kIHRoZSBheGlzLCB0b3dhcmQgdGhlIGhlYWRcbiAgICBjb25zdCBjdXJyZW50Vmlld3BvcnRBeGlzUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgc2Nyb2xsYmxvY2tBeGlzUGl4ZWxPZmZzZXQgKyBzY3JvbGxibG9ja1BpeGVsT2Zmc2V0IC0gc2Nyb2xsUG9zXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tWyA0LiBjYWxjdWxhdGUgbmV3IGF4aXMgcGl4ZWwgcG9zaXRpb24gXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gY3VycmVudFZpZXdwb3J0QXhpc1BpeGVsT2Zmc2V0ICsgYXhpc1BpeGVsU2hpZnRcblxuICAgIC8vIE5vdGU6IHNlY3Rpb25zIDUsIDYgYW5kIDcgZGVhbCBlbnRpcmVseSB3aXRoIHJvdyBjYWxjdWxhdGlvbnM7IG5vIHBpeGVsc1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tWyA1LiBjYWxjIG5ldyBjcmFkbGUgYW5kIGF4aXMgcmVmZXJlbmNlIHJvdyBvZmZzZXRzIF0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBiYXNlIHZhbHVlIGZvciBjcmFkbGUgcmVmZXJlbmNlIHNoaWZ0OyBtYXkgY2hhbmdlIGlmIGJleW9uZCBsaXN0IGJvdW5kc1xuICAgIGxldCBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCA9IGF4aXNSZWZlcmVuY2VSb3dTaGlmdFxuXG4gICAgLy8gYmFzZSB2YWx1ZXNcbiAgICBsZXQgbmV3Q3JhZGxlUmVmZXJlbmNlUm93ID0gcHJldmlvdXNDcmFkbGVSZWZlcmVuY2VSb3cgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdFxuICAgIGNvbnN0IG5ld0F4aXNSZWZlcmVuY2VSb3cgPSBwcmV2aW91c0F4aXNSZWZlcmVuY2VSb3cgKyBheGlzUmVmZXJlbmNlUm93U2hpZnRcblxuXG4gICAgLy8gc2Nyb2xsZXJJRCA9PSAxICYmIGNvbnNvbGUubG9nKCdBLTEuIG5ld0NyYWRsZVJlZmVyZW5jZVJvdyA9IHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlUm93ICsgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnRcXG4nLFxuICAgIC8vICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3csIHByZXZpb3VzQ3JhZGxlUmVmZXJlbmNlUm93LCBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdClcblxuICAgIC8vIHNjcm9sbGVySUQgPT0gMSAmJiBjb25zb2xlLmxvZygnQS0yLiBuZXdBeGlzUmVmZXJlbmNlUm93ID0gcHJldmlvdXNBeGlzUmVmZXJlbmNlUm93ICsgYXhpc1JlZmVyZW5jZVJvd1NoaWZ0XFxuJyxcbiAgICAvLyAgICAgbmV3QXhpc1JlZmVyZW5jZVJvdywgcHJldmlvdXNBeGlzUmVmZXJlbmNlUm93LCBheGlzUmVmZXJlbmNlUm93U2hpZnQpXG5cbiAgICAvLyAtLS0tLS0tLVsgNi4gYWRqdXN0IGNyYWRsZSBjb250ZW50cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBsaXN0IF0tLS0tLS0tXG4gICAgLy8gLi4udG8gbWFpbnRhaW4gY29uc3RhbnQgbnVtYmVyIG9mIGNyYWRsZSByb3dzXG5cbiAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiA9PSAnbW92ZWF4aXN0YWlsd2FyZCcpIHsgLy8gc2Nyb2xsaW5nIHVwL2xlZnRcblxuICAgICAgICAvLyBhLiBpZiBzY3JvbGxpbmcgdGhlIGJsb2NrIGhlYWR3YXJkIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBsaXN0LCBuZXcgY3JhZGxlIHJvdyBvZmZzZXQgYW5kXG4gICAgICAgIC8vIGNyYWRsZSByb3cgc2hpZnQgY291bnQgaGFzIHRvIGJlIGFkanVzdGVkIHRvIGFjY29tbW9kYXRlIHRoZSBsZWFkaW5nIHJ1bndheVxuXG4gICAgICAgIC8vIGIuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgaGVhZHdhcmQgKHJldmVhbGluZyB0YWlsIG9mIGxpc3QpLCBhcyB0aGUgY3JhZGxlIGxhc3Qgcm93IG9mZnNldCBcbiAgICAgICAgLy8gYXBwcm9hY2hlcyBtYXggbGlzdHJvdywgbmV3IGNyYWRsZSBvZmZzZXQgYW5kIGNyYWRsZSByb3cgc2hpZnQgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBwcmV2ZW50IFxuICAgICAgICAvLyBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50LlxuXG4gICAgICAgIC8vIC0tLSBzdGFydCBvZiBsaXN0IGFkanVzdG1lbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93ID0gXG4gICAgICAgICAgICBNYXRoLm1heChyYW5nZXJvd3NoaWZ0LCAobmV3QXhpc1JlZmVyZW5jZVJvdyAtIHJ1bndheVJvd2NvdW50IC0gMSkpIC8vIGV4dHJhIHJvdyBmb3IgdmlzaWJpbGl0eVxuXG4gICAgICAgIGNvbnN0IGhlYWRyb3dEaWZmID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93IC0gdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93XG4gICAgICAgIGlmIChoZWFkcm93RGlmZiA+IDApIHtcblxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93IC09IGhlYWRyb3dEaWZmXG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdCAtPSBoZWFkcm93RGlmZlxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0gZW5kIG9mIGxpc3QgYWRqdXN0bWVudDogY2FzZSBvZiBiZWluZyBpbiBib3VuZHMgb2YgdHJhaWxpbmcgcnVud2F5IChlbmQgb2YgbGlzdClcbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlRW5kcm93ID0gbmV3Q3JhZGxlUmVmZXJlbmNlUm93ICsgKGNyYWRsZVJvd2NvdW50IC0gMSlcbiAgICAgICAgY29uc3QgdGFpbHJvd2RpZmYgPSB0YXJnZXRDcmFkbGVFbmRyb3cgLSBsaXN0RW5kUm93XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RhaWxyb3dkaWZmID0gdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0IC0gbGlzdEVuZHJvd09mZnNldCwgdmlydHVhbExpc3RQcm9wc1xcbicsXG4gICAgICAgIC8vICAgICB0YWlscm93ZGlmZiwgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0LCBsaXN0RW5kcm93T2Zmc2V0LCB2aXJ0dWFsTGlzdFByb3BzKVxuXG4gICAgICAgIGlmICh0YWlscm93ZGlmZiA+IDApIHtcblxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQgLT0gdGFpbHJvd2RpZmZcbiAgICAgICAgICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvdyAtPSB0YWlscm93ZGlmZlxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzaGVhZHdhcmQnOyBzY3JvbGxpbmcgZG93bi9yaWdodFxuXG4gICAgICAgIC8vIGMuIGlmIHNjcm9sbGluZyB0aGUgYmxvY2sgZG93biBvciByaWdodCAodG93YXJkIHJldmVhbGluZyBoZWFkIG9mIGxpc3QpLCBhcyB0aGUgY3JhZGxlcm93b2Zmc2V0IFxuICAgICAgICAvLyBoaXRzIDAsIGNyYWRsZSBjaGFuZ2VzIGhhdmUgdG8gYmUgYWRqdXN0ZWQgdG8gcHJldmVudCBzaG9ydGVuaW5nIG9mIGNyYWRsZSBjb250ZW50XG5cbiAgICAgICAgLy8gZC4gaWYgc2Nyb2xsaW5nIGhlYWR3YXJkIG5lYXIgdGhlIGVuZCBvZiB0aGUgbGlzdCwgY3JhZGxlIGNoYW5nZXMgaGF2ZSB0byBiZSBhZGp1c3RlZCB0byBcbiAgICAgICAgLy8gYWNjb21vZGF0ZSB0aGUgdHJhaWxpbmcgcnVud2F5XG5cbiAgICAgICAgLy8gLS0tIHN0YXJ0IG9mIGxpc3QgYWRqdXN0bWVudFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCcxLiBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQgPCByYW5nZXJvd3NoaWZ0XFxuJyxcbiAgICAgICAgLy8gICAgIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCwgcmFuZ2Vyb3dzaGlmdClcblxuICAgICAgICBpZiAobmV3Q3JhZGxlUmVmZXJlbmNlUm93IDwgcmFuZ2Vyb3dzaGlmdCkge1xuXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gcmFuZ2Vyb3dzaGlmdCAtIG5ld0NyYWRsZVJlZmVyZW5jZVJvd1xuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQgKz0gZGlmZlxuICAgICAgICAgICAgbmV3Q3JhZGxlUmVmZXJlbmNlUm93ICs9IGRpZmZcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJzIuIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldFxcbicsXG4gICAgICAgIC8vICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQpXG5cbiAgICAgICAgaWYgKGxheW91dCA9PSAndmFyaWFibGUnICYmIG5ld0F4aXNSZWZlcmVuY2VSb3cgPT0gcmFuZ2Vyb3dzaGlmdCkgeyAvLyBzdGFydCBvZiBsaXN0XG4gICAgICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IHBhZGRpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBlbmQgb2YgbGlzdCBhZGp1c3RtZW50OyBjYXNlIG9mIGluIGJvdW5kcyBvZiB0cmFpbGluZyBydW53YXlcblxuICAgICAgICBjb25zdCBjb21wdXRlZE5leHRDcmFkbGVFbmRSb3cgPSBcbiAgICAgICAgICAgIChwcmV2aW91c0NyYWRsZVJlZmVyZW5jZVJvdyArIChjcmFkbGVSb3djb3VudCAtMSkgKyBjcmFkbGVSZWZlcmVuY2VSb3dzaGlmdClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY29tcHV0ZWROZXh0Q3JhZGxlRW5kcm93T2Zmc2V0ID0gKHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0ICsgKGNyYWRsZVJvd2NvdW50IC0xKSArIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0KVxcbicsXG4gICAgICAgIC8vICAgICBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQsIHByZXZpb3VzQ3JhZGxlUm93T2Zmc2V0LCBjcmFkbGVSb3djb3VudCwgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQpXG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q3JhZGxlRW5kUm93ID0gXG4gICAgICAgICAgICBuZXdBeGlzUmVmZXJlbmNlUm93ICsgKHZpZXdwb3J0Um93Y291bnQgLSAxKSArIChydW53YXlSb3djb3VudCAtIDEpXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RhcmdldENyYWRsZUVuZHJvd09mZnNldCA9IG5ld0F4aXNSZWZlcmVuY2VSb3dPZmZzZXQgKyAodmlld3BvcnRSb3djb3VudCAtIDEpICsgKHJ1bndheVJvd2NvdW50IC0gMSlcXG4nLFxuICAgICAgICAvLyAgICAgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0LCBsaXN0RW5kcm93T2Zmc2V0LCBuZXdBeGlzUmVmZXJlbmNlUm93T2Zmc2V0LCB2aWV3cG9ydFJvd2NvdW50LCBydW53YXlSb3djb3VudClcblxuICAgICAgICAvLyBjb25zdCB0YWlscm93ZGlmZiA9IHRhcmdldENyYWRsZUVuZHJvd09mZnNldCAtIGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldFxuXG4gICAgICAgIGxldCB0YWlscm93ZGlmZiA9ICBjb21wdXRlZE5leHRDcmFkbGVFbmRSb3cgLSB0YXJnZXRDcmFkbGVFbmRSb3dcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndGFpbHJvd2RpZmYgPSBjb21wdXRlZE5leHRDcmFkbGVFbmRyb3dPZmZzZXQgLSB0YXJnZXRDcmFkbGVFbmRyb3dPZmZzZXRcXG4nLFxuICAgICAgICAvLyAgICAgdGFpbHJvd2RpZmYsIGNvbXB1dGVkTmV4dENyYWRsZUVuZHJvd09mZnNldCwgdGFyZ2V0Q3JhZGxlRW5kcm93T2Zmc2V0KVxuXG4gICAgICAgIGlmICh0YWlscm93ZGlmZiA8IDApIHtcblxuICAgICAgICAgICAgdGFpbHJvd2RpZmYgPSBNYXRoLm1heCh0YWlscm93ZGlmZiwgY3JhZGxlUmVmZXJlbmNlUm93c2hpZnQpXG5cbiAgICAgICAgICAgIGNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IC09IHRhaWxyb3dkaWZmXG4gICAgICAgICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3cgLT0gdGFpbHJvd2RpZmZcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJzMuIG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCwgcmFuZ2Vyb3dzaGlmdFxcbicsXG4gICAgICAgIC8vICAgICBuZXdDcmFkbGVSZWZlcmVuY2VSb3dPZmZzZXQsIHJhbmdlcm93c2hpZnQpXG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA3LiBtYXAgcm93cyB0byBpdGVtIHJlZmVyZW5jZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gTWF0aC5tYXgobGlzdGxvd2luZGV4LCBuZXdDcmFkbGVSZWZlcmVuY2VSb3cgKiBjcm9zc2NvdW50KVxuICAgIGNvbnN0IGNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCA9IG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4IC0gcHJldmlvdXNDcmFkbGVSZWZlcmVuY2VJbmRleFxuXG4gICAgY29uc3QgbmV3QXhpc1JlZmVyZW5jZUluZGV4ID0gTWF0aC5tYXgobGlzdGxvd2luZGV4LCBuZXdBeGlzUmVmZXJlbmNlUm93ICogY3Jvc3Njb3VudClcbiAgICBjb25zdCBheGlzUmVmZXJlbmNlSXRlbVNoaWZ0ID0gbmV3QXhpc1JlZmVyZW5jZUluZGV4IC0gcHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXhcblxuICAgIGxldCBuZXdDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVSb3djb3VudCAqIGNyb3NzY291bnQgLy8gYmFzZSBjb3VudFxuXG4gICAgY29uc3QgaW5jbHVkZXNMYXN0Um93ID0gKChuZXdDcmFkbGVSZWZlcmVuY2VSb3cgKyBjcmFkbGVSb3djb3VudCAtIHJhbmdlcm93c2hpZnQpID49IGxpc3RSb3djb3VudClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdpbmNsdWRlc0xhc3RSb3cgPSAoKG5ld0NyYWRsZVJlZmVyZW5jZVJvd09mZnNldCArIGNyYWRsZVJvd2NvdW50IC0gcmFuZ2Vyb3dzaGlmdCkgPj0gbGlzdFJvd2NvdW50KVxcbicsXG4gICAgLy8gICAgIGluY2x1ZGVzTGFzdFJvdywgbmV3Q3JhZGxlUmVmZXJlbmNlUm93T2Zmc2V0LCBjcmFkbGVSb3djb3VudCwgcmFuZ2Vyb3dzaGlmdCwgbGlzdFJvd2NvdW50KVxuXG4gICAgY29uc3QgaW5jbHVkZXNGaXJzdFJvdyA9IChuZXdDcmFkbGVSZWZlcmVuY2VSb3cgPT0gcmFuZ2Vyb3dzaGlmdClcblxuICAgIGlmIChpbmNsdWRlc0xhc3RSb3cpIHtcblxuICAgICAgICBuZXdDcmFkbGVDb250ZW50Q291bnQgLT0gZW5kcm93YmxhbmtzXG5cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZXNGaXJzdFJvdykge1xuXG4gICAgICAgIG5ld0NyYWRsZUNvbnRlbnRDb3VudCAtPSBiYXNlcm93YmxhbmtzXG5cbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaGVhZCBhbmQgdGFpbCBjaGFuZ2UgY291bnRzXG4gICAgY29uc3QgY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQgPSBjcmFkbGVjb250ZW50bGlzdC5sZW5ndGggLSBuZXdDcmFkbGVDb250ZW50Q291bnRcblxuICAgIGNvbnN0IGxpc3RTdGFydENoYW5nZUNvdW50ID0gLShjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQpXG4gICAgY29uc3QgbGlzdEVuZENoYW5nZUNvdW50ID0gLWxpc3RTdGFydENoYW5nZUNvdW50IC0gY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnRcblxuICAgIC8vIGNvbnNvbGUubG9nKCdsaXN0U3RhcnRDaGFuZ2VDb3VudCwgbGlzdEVuZENoYW5nZUNvdW50LCBjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQsIGNoYW5nZU9mQ3JhZGxlQ29udGVudENvdW50XFxuJyxcbiAgICAvLyAgICAgbGlzdFN0YXJ0Q2hhbmdlQ291bnQsIGxpc3RFbmRDaGFuZ2VDb3VudCwgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0LCBjaGFuZ2VPZkNyYWRsZUNvbnRlbnRDb3VudClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgOC4gcmV0dXJuIHJlcXVpcmVkIHZhbHVlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gY29uc29sZS5sb2coJy0tPj4gbmV3Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIG5ld0F4aXNSZWZlcmVuY2VJbmRleFxcbicsXG4gICAgLy8gICAgIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LCBuZXdBeGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIC8vIG5ld0NyYWRsZVJlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0LCBcbiAgICAgICAgbmV3QXhpc1JlZmVyZW5jZUluZGV4LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCwgXG5cbiAgICAgICAgbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50XG4gICAgfVxuXG59XG5cbi8vIHN1cHBvcnRzIGNhbGNDb250ZW50U2hpZnQgYWJvdmVcbmNvbnN0IGdldEdyaWRSb3dMZW5ndGhzID0gKGdyaWQsIG9yaWVudGF0aW9uLCBjcm9zc2NvdW50LCBnYXApID0+IHtcblxuICAgIGNvbnN0IHJvd0xlbmd0aHMgPSBbXVxuICAgIGNvbnN0IGVsZW1lbnRMaXN0ID0gZ3JpZC5jaGlsZE5vZGVzXG5cbiAgICBsZXQgZWxlbWVudFB0ciA9IDBcbiAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRMaXN0W2VsZW1lbnRQdHJdXG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCByb3dsZW5ndGggPSBcbiAgICAgICAgICAgICgob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRXaWR0aCkgXG4gICAgICAgICAgICArIGdhcFxuICAgICAgICByb3dMZW5ndGhzLnB1c2gocm93bGVuZ3RoKVxuICAgICAgICBlbGVtZW50UHRyICs9IGNyb3NzY291bnRcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRMaXN0W2VsZW1lbnRQdHJdXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd0xlbmd0aHNcbn1cblxuLy8gc3VwcG9ydHMgY2FsY0NvbnRlbnRTaGlmdCBhYm92ZVxuY29uc3QgZ2V0R3JpZFJvd0FnZ3JlZ2F0ZVNwYW5zID0gKHJvd0xlbmd0aHMpID0+IHtcblxuICAgIGNvbnN0IHJvd1NwYW5zID0gW11cbiAgICBsZXQgc3BhbiA9IDBcbiAgICByb3dMZW5ndGhzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHNwYW4gKz0gdmFsdWVcbiAgICAgICAgcm93U3BhbnMucHVzaChzcGFuKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcm93U3BhbnNcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBzaGFyZWQgYnkgYm90aCBzZXRDcmFkbGVDb250ZW50IGFuZCB1cGRhdGVDcmFkbGVDb250ZW50IF09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB1cGRhdGUgY29udGVudFxuLy8gYWRkcyBDZWxsRnJhbWVzIGF0IGVuZCBvZiBjb250ZW50bGlzdCBhY2NvcmRpbmcgdG8gaGVhZGluZGV4Y291bnQgYW5kIHRhaWxpbmRleGNvdW50LFxuLy8gb3IgaWYgaW5kZXhjb3VudCB2YWx1ZXMgYXJlIDwwIHJlbW92ZXMgdGhlbS5cbmV4cG9ydCBjb25zdCBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0ID0gKHsgXG5cbiAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICBjYWNoZUFQSSxcbiAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LCBcbiAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50LCBcbiAgICAgICAgd29ya2luZ0NvbnRlbnRMaXN0OmNvbnRlbnRsaXN0LFxuICAgICAgICBpbnN0YW5jZUlkQ291bnRlclJlZixcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgIH0pID0+IHtcblxuICAgIGNvbnN0IGxvY2FsQ29udGVudGxpc3QgPSBbLi4uY29udGVudGxpc3RdXG4gICAgY29uc3QgbGFzdGluZGV4b2Zmc2V0ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggKyBsb2NhbENvbnRlbnRsaXN0Lmxlbmd0aCAtIDFcblxuICAgIGNvbnN0IGhlYWRDb250ZW50bGlzdCA9IFtdLCB0YWlsQ29udGVudGxpc3QgPSBbXVxuXG4gICAgbGV0IGRlbGV0ZWR0YWlsaXRlbXMgPSBbXSwgZGVsZXRlZGhlYWRpdGVtcyA9IFtdXG5cbiAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPj0gMCkgeyAvLyBhY3F1aXJlIG5ldyBpdGVtc1xuICAgICAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBjcmFkbGVSZWZlcmVuY2VJbmRleFxuICAgICAgICBsZXQgY2hhbmdlQ291bnQgPSBsaXN0U3RhcnRDaGFuZ2VDb3VudFxuICAgICAgICBpZiAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgPiBjcmFkbGVDb250ZW50Q291bnQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4ID0gY3JhZGxlUmVmZXJlbmNlSW5kZXggLSAobGlzdFN0YXJ0Q2hhbmdlQ291bnQgLSBjcmFkbGVDb250ZW50Q291bnQpXG4gICAgICAgICAgICBjaGFuZ2VDb3VudCA9IGNyYWRsZUNvbnRlbnRDb3VudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbmV3aW5kZXggPSByZWZlcmVuY2VJbmRleCAtIGNoYW5nZUNvdW50OyBuZXdpbmRleCA8IHJlZmVyZW5jZUluZGV4OyBuZXdpbmRleCsrKSB7XG5cbiAgICAgICAgICAgIGhlYWRDb250ZW50bGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNlbGxGcmFtZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6bmV3aW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVBUEksXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJsaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlczpzdHlsZXMucGxhY2Vob2xkZXJlcnJvcmZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmVycm9ybGluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZGVsZXRlZGhlYWRpdGVtcyA9IGxvY2FsQ29udGVudGxpc3Quc3BsaWNlKCAwLCAtbGlzdFN0YXJ0Q2hhbmdlQ291bnQgKVxuXG4gICAgfVxuXG4gICAgaWYgKGxpc3RFbmRDaGFuZ2VDb3VudCA+PSAwKSB7IC8vIGFjcXVpcmUgbmV3IGl0ZW1zXG5cbiAgICAgICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gbGFzdGluZGV4b2Zmc2V0XG4gICAgICAgIGxldCBjaGFuZ2VDb3VudCA9IGxpc3RFbmRDaGFuZ2VDb3VudFxuICAgICAgICBpZiAobGlzdEVuZENoYW5nZUNvdW50ID4gY3JhZGxlQ29udGVudENvdW50KSB7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGxhc3RpbmRleG9mZnNldCArIChsaXN0RW5kQ2hhbmdlQ291bnQgLSBjcmFkbGVDb250ZW50Q291bnQpXG4gICAgICAgICAgICBjaGFuZ2VDb3VudCA9IGNyYWRsZUNvbnRlbnRDb3VudFxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5ld2luZGV4ID0gcmVmZXJlbmNlSW5kZXggKyAxOyBuZXdpbmRleCA8IChyZWZlcmVuY2VJbmRleCArIDEgKyBjaGFuZ2VDb3VudCk7IG5ld2luZGV4KyspIHtcblxuICAgICAgICAgICAgdGFpbENvbnRlbnRsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2VsbEZyYW1lKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDpuZXdpbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUFQSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckxpbmVyU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmxpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzOnN0eWxlcy5wbGFjZWhvbGRlcmVycm9yZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXM6c3R5bGVzLnBsYWNlaG9sZGVyZXJyb3JsaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBkZWxldGVkdGFpbGl0ZW1zID0gbG9jYWxDb250ZW50bGlzdC5zcGxpY2UobGlzdEVuZENoYW5nZUNvdW50LC1saXN0RW5kQ2hhbmdlQ291bnQpXG5cbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkSXRlbXMgPSBbLi4uZGVsZXRlZGhlYWRpdGVtcywuLi5kZWxldGVkdGFpbGl0ZW1zXVxuXG4gICAgY29uc3QgY29tcG9uZW50TGlzdCA9IFsuLi5oZWFkQ29udGVudGxpc3QsLi4ubG9jYWxDb250ZW50bGlzdCwuLi50YWlsQ29udGVudGxpc3RdXG5cbiAgICByZXR1cm4gW2NvbXBvbmVudExpc3QsZGVsZXRlZEl0ZW1zXVxuXG59XG5cbi8vIExlYWRpbmcgKGhlYWQpIGFsbCBvciBwYXJ0aWFsbHkgaGlkZGVuOyB0YWlsLCB2aXNpYmxlIHBsdXMgdHJhaWxpbmcgaGlkZGVuXG5leHBvcnQgY29uc3QgYWxsb2NhdGVDb250ZW50TGlzdCA9IChcbiAgICB7XG5cbiAgICAgICAgY29udGVudGxpc3QsIC8vIG9mIGNyYWRsZSwgaW4gaXRlbXMgKFJlYWN0IGNvbXBvbmVudHMpXG4gICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgLy8gZmlyc3QgdGFpbCBpdGVtXG4gICAgICAgIGxheW91dEhhbmRsZXIsXG5cbiAgICB9XG4pID0+IHtcblxuICAgIGNvbnN0IHsgdHJpZ2dlcmNlbGxJbmRleCB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgY29uc3QgbG93Y29udGVudGluZGV4ID0gY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4LFxuICAgICAgICBoaWdoY29udGVudGluZGV4ID0gbG93Y29udGVudGluZGV4ICsgY29udGVudGxpc3QubGVuZ3RoXG5cbiAgICBjb25zdCBoZWFkaXRlbWNvdW50ID0gKGF4aXNSZWZlcmVuY2VJbmRleCAtIGxvd2NvbnRlbnRpbmRleClcblxuICAgIGNvbnN0IHRhcmdldFRyaWdnZXJjZWxsSW5kZXggPSBcbiAgICAgICAgKGhlYWRpdGVtY291bnQgPT0gMCk/XG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXg6XG4gICAgICAgICAgICBheGlzUmVmZXJlbmNlSW5kZXggLSAxXG5cbiAgICBsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwgPSBcbiAgICAgICAgKGhlYWRpdGVtY291bnQgPT0gMCk/XG4gICAgICAgICAgICB0cnVlOlxuICAgICAgICAgICAgZmFsc2VcblxuICAgIGlmICgodHJpZ2dlcmNlbGxJbmRleCAhPT0gdW5kZWZpbmVkKSAmJiAobG93Y29udGVudGluZGV4ICE9PSB1bmRlZmluZWQpKSB7IC8vJiYgXG4gICAgICAgIGlmICgodHJpZ2dlcmNlbGxJbmRleCA+PSBsb3djb250ZW50aW5kZXgpICYmICh0cmlnZ2VyY2VsbEluZGV4IDw9IGhpZ2hjb250ZW50aW5kZXgpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyY2VsbFB0ciA9IHRyaWdnZXJjZWxsSW5kZXggLSBsb3djb250ZW50aW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsQ29tcG9uZW50ID0gY29udGVudGxpc3RbdHJpZ2dlcmNlbGxQdHJdXG4gICAgICAgICAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQpIHsgLy8gb3RoZXJ3aXNlIGhhcyBiZWVuIGFzeW5jaHJvbm91c2x5IGNsZWFyZWRcbiAgICAgICAgICAgICAgICBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlcmNlbGxDb21wb25lbnQsIHtpc1RyaWdnZXJjZWxsOmZhbHNlfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyaWdnZXJjZWxsUHRyID0gdGFyZ2V0VHJpZ2dlcmNlbGxJbmRleCAtIGxvd2NvbnRlbnRpbmRleFxuXG4gICAgY29uc3QgdHJpZ2dlcmNlbGxDb21wb25lbnQgPSBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl1cbiAgICBpZiAodHJpZ2dlcmNlbGxDb21wb25lbnQpIHtcblxuICAgICAgICBjb250ZW50bGlzdFt0cmlnZ2VyY2VsbFB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlcmNlbGxDb21wb25lbnQsIHtpc1RyaWdnZXJjZWxsOnRydWV9KVxuICAgICAgICBsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSW5kZXggPSB0YXJnZXRUcmlnZ2VyY2VsbEluZGV4XG5cbiAgICB9IGVsc2UgeyAvLyBkZWZlbnNpdmU7IHNob3VsZG4ndCBoYXBwZW5cblxuICAgICAgICBjb25zb2xlLmxvZygnRkFJTFVSRSBUTyBSRUdJU1RFUiBUUklHR0VSQ0VMTDonKVxuICAgICAgICBjb25zb2xlLmxvZygnYXhpc1JlZmVyZW5jZUluZGV4LCB0cmlnZ2VyY2VsbEluZGV4LCBsb3djb250ZW50aW5kZXgsIGhpZ2hjb250ZW50aW5kZXgsIGhlYWRpdGVtY291bnQsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXhcXG4nLFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCB0cmlnZ2VyY2VsbEluZGV4LCBsb3djb250ZW50aW5kZXgsIGhpZ2hjb250ZW50aW5kZXgsIGhlYWRpdGVtY291bnQsIHRhcmdldFRyaWdnZXJjZWxsSW5kZXgpXG4gICAgICAgIGNvbnNvbGUubG9nKCd0cmlnZ2VyY2VsbFB0ciwgdHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGwsIGNvbnRlbnRsaXN0XFxuJywgXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFB0ciwgdHJpZ2dlcmNlbGxDb21wb25lbnQsIHRyaWdnZXJjZWxsQ29tcG9uZW50Py5wcm9wcy5pc1RyaWdnZWNlbGwsIFxuICAgICAgICAgICAgICAgIHsuLi5jb250ZW50bGlzdH0pXG5cbiAgICB9XG5cbiAgICBjb25zdCBoZWFkbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKDAsaGVhZGl0ZW1jb3VudClcbiAgICBjb25zdCB0YWlsbGlzdCA9IGNvbnRlbnRsaXN0LnNsaWNlKGhlYWRpdGVtY291bnQpXG5cbiAgICByZXR1cm4gWyBoZWFkbGlzdCwgdGFpbGxpc3QgXVxuXG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVQb3J0YWxzID0gKGNhY2hlQVBJLCBkZWxldGVMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgIGNvbnN0IGRsaXN0ID0gZGVsZXRlTGlzdC5tYXAoKGl0ZW0pPT57XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcHMuaW5kZXhcbiAgICAgICAgXG4gICAgfSlcblxuICAgIGNhY2hlQVBJLmRlbGV0ZVBvcnRhbEJ5SW5kZXgoZGxpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09WyBpbnRlcm5hbCwgYWNxdWlyZSBpdGVtIF09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGNyZWF0ZUNlbGxGcmFtZSA9ICh7XG4gICAgaW5kZXgsIFxuICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG4gICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgIGluc3RhbmNlSWRDb3VudGVyUmVmLFxuICAgIGNhY2hlQVBJLFxuICAgIHBsYWNlaG9sZGVyRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyxcbiAgICBwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMsXG4gICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzLFxuICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG59KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VJRCA9IGluc3RhbmNlSWRDb3VudGVyUmVmLmN1cnJlbnQrK1xuXG4gICAgY29uc3QgeyBcbiAgICAgICAgXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgIGNlbGxNaW5IZWlnaHQsXG4gICAgICAgIGNlbGxNaW5XaWR0aCxcbiAgICAgICAgZ2V0SXRlbSxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIHNjcm9sbGVySUQsXG4gICAgICAgIGxheW91dCwgXG4gICAgICAgIHVzZVBsYWNlaG9sZGVyLFxuXG4gICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcblxuICAgIGNvbnN0IGxpc3RzaXplID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLnZpcnR1YWxMaXN0UHJvcHMuc2l6ZVxuXG4gICAgLy8gZ2V0IG5ldyBvciBleGlzdGluZyBpdGVtSURcbiAgICBjb25zdCBpdGVtSUQgPSBjYWNoZUFQSS5nZXROZXdPckV4aXN0aW5nSXRlbUlEKGluZGV4KVxuXG4gICAgcmV0dXJuIDxDZWxsRnJhbWUgXG4gICAgICAgIGtleSA9IHsgaW5zdGFuY2VJRCB9IFxuICAgICAgICBvcmllbnRhdGlvbiA9IHsgb3JpZW50YXRpb24gfVxuICAgICAgICBjZWxsSGVpZ2h0ID0geyBjZWxsSGVpZ2h0IH1cbiAgICAgICAgY2VsbFdpZHRoID0geyBjZWxsV2lkdGggfVxuICAgICAgICBjZWxsTWluSGVpZ2h0ID0geyBjZWxsTWluSGVpZ2h0IH1cbiAgICAgICAgY2VsbE1pbldpZHRoID0geyBjZWxsTWluV2lkdGggfVxuICAgICAgICBsYXlvdXQgPSB7IGxheW91dCB9XG4gICAgICAgIGluZGV4ID0geyBpbmRleCB9XG4gICAgICAgIGdldEl0ZW0gPSB7IGdldEl0ZW0gfVxuICAgICAgICBsaXN0c2l6ZSA9IHsgbGlzdHNpemUgfVxuICAgICAgICBwbGFjZWhvbGRlciA9IHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICBpdGVtSUQgPSB7IGl0ZW1JRCB9XG4gICAgICAgIGluc3RhbmNlSUQgPSB7IGluc3RhbmNlSUQgfVxuICAgICAgICBzY3JvbGxlcklEID0geyBzY3JvbGxlcklEIH1cbiAgICAgICAgaXNUcmlnZ2VyY2VsbCA9IHsgZmFsc2UgfVxuICAgICAgICB1c2VQbGFjZWhvbGRlciA9IHsgdXNlUGxhY2Vob2xkZXIgfVxuICAgICAgICBwbGFjZWhvbGRlckZyYW1lU3R5bGVzID0geyBwbGFjZWhvbGRlckZyYW1lU3R5bGVzIH1cbiAgICAgICAgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyA9IHsgcGxhY2Vob2xkZXJMaW5lclN0eWxlcyB9XG4gICAgICAgIHBsYWNlaG9sZGVyRXJyb3JGcmFtZVN0eWxlcyA9IHsgcGxhY2Vob2xkZXJFcnJvckZyYW1lU3R5bGVzIH1cbiAgICAgICAgcGxhY2Vob2xkZXJFcnJvckxpbmVyU3R5bGVzID0geyBwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMgfVxuICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzID0geyBwbGFjZWhvbGRlck1lc3NhZ2VzIH1cbiAgICAgICAgZ3JpZHN0YXJ0c3R5bGUgPSB7bnVsbH1cbiAgICAvPlxuXG59XG4iXSwibmFtZXMiOlsiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwibGVuIiwibGVuZ3RoIiwiaSIsImFycjIiLCJyZWFjdF8xIiwiX19pbXBvcnREZWZhdWx0IiwicmVxdWlyZSIsIkNlbGxGcmFtZV8xIiwiSW5maW5pdGVHcmlkU2Nyb2xsZXJfMSIsImNhbGN1bGF0ZUNvbnRlbnRMaXN0UmVxdWlyZW1lbnRzIiwiX3JlZiIsInRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCIsImJhc2VSb3dQaXhlbExlbmd0aCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsInBhZGRpbmciLCJjcmFkbGVDb250ZW50UHJvcHMiLCJ2aXJ0dWFsTGlzdFByb3BzIiwiY3JhZGxlUm93Y291bnQiLCJydW53YXlSb3djb3VudCIsImxpc3Rsb3dpbmRleCIsImxvd2luZGV4IiwibGlzdGhpZ2hpbmRleCIsImhpZ2hpbmRleCIsImNyb3NzY291bnQiLCJsaXN0Um93Y291bnQiLCJyb3djb3VudCIsImJhc2Vyb3dibGFua3MiLCJlbmRyb3dibGFua3MiLCJyYW5nZXJvd3NoaWZ0Iiwicm93c2hpZnQiLCJNYXRoIiwibWluIiwibWF4IiwidGFyZ2V0QXhpc1JlZmVyZW5jZVJvdyIsImZsb29yIiwidGFyZ2V0Q3JhZGxlUmVmZXJlbmNlUm93IiwidGFyZ2V0Q3JhZGxlRW5kUm93IiwibGlzdEVuZFJvd09mZnNldCIsImRpZmYiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCIsIm5ld0NyYWRsZUNvbnRlbnRDb3VudCIsInRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsImV4cG9ydHMiLCJnZW5lcmF0ZVNoaWZ0SW5zdHJ1Y3Rpb24iLCJfcmVmMiIsIm9yaWVudGF0aW9uIiwidHJpZ2dlcmxpbmVFbnRyaWVzIiwidHJpZ2dlcmxpbmVTcGFuIiwic2Nyb2xsZXJJRCIsImlzRmlyc3RSb3dUcmlnZ2VyQ29uZmlnIiwidmlld3BvcnRCb3VuZGluZ1JlY3QiLCJ0cmlnZ2VySGlzdG9yeVJlZiIsInRyaWdnZXJEYXRhIiwiaGVhZE9mZnNldCIsInRhaWxPZmZzZXQiLCJzcGFuIiwiZW50cnkiLCJyZWZlcmVuY2VuYW1lIiwidGFyZ2V0IiwiZGF0YXNldCIsInR5cGUiLCJpbnRlcnNlY3Ryb290cG9zIiwidHJ1bmMiLCJyb290Qm91bmRzIiwieSIsIngiLCJib3VuZGluZ3Jvb3Rwb3MiLCJyb290cG9zIiwiZW50cnlwb3MiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJ2aWV3cG9ydFRyaWdnZXJPZmZzZXQiLCJzaGlmdGluc3RydWN0aW9uIiwidHJpZ2dlckhpc3RvcnkiLCJjdXJyZW50IiwiaXNTYWZhcmlJT1MiLCJwcmV2aW91c1JlZmVyZW5jZU5hbWUiLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcyIsImNhbGN1bGF0ZVNoaWZ0U3BlY3MiLCJfcmVmMyIsInNjcm9sbFBvcyIsInNjcm9sbGJsb2NrRWxlbWVudCIsImNyYWRsZUNvbnRlbnQiLCJjcmFkbGVFbGVtZW50cyIsImF4aXNFbGVtZW50IiwiYXhpc1JlZiIsImhlYWRHcmlkRWxlbWVudCIsImhlYWRSZWYiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwiZ2FwIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImxheW91dCIsImNyYWRsZWNvbnRlbnRsaXN0IiwiY3JhZGxlTW9kZWxDb21wb25lbnRzIiwidGFpbGNvbnRlbnRsaXN0IiwidGFpbE1vZGVsQ29tcG9uZW50cyIsInZpZXdwb3J0Um93Y291bnQiLCJsaXN0c2l6ZSIsInNpemUiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2EiLCJwcm9wcyIsImluZGV4IiwicHJldmlvdXNDcmFkbGVSZWZlcmVuY2VSb3ciLCJwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCIsIl9iIiwicHJldmlvdXNBeGlzUmVmZXJlbmNlUm93IiwibGlzdEVuZFJvdyIsImZvdW5kR3JpZFNwYW5Sb3dTaGlmdEluY3JlbWVudCIsImdyaWRTcGFuQXhpc1BpeGVsU2hpZnQiLCJieVBpeGVsTWVhc3VyZUdyaWRSb3dTaGlmdENvdW50IiwiaXNMaXN0Qm91bmRhcnkiLCJ0b3RhbFBpeGVsU2hpZnQiLCJmaW5hbFZhcmlhYmxlUm93TGVuZ3RoIiwiZW5nYWdlZEdyaWRFbGVtZW50IiwiZ3JpZFJvd1BpeGVsTGVuZ3Roc0xpc3QiLCJnZXRHcmlkUm93TGVuZ3RocyIsInJldmVyc2UiLCJncmlkUm93Q3VtdWxhdGl2ZVBpeGVsTGVuZ3Roc0xpc3QiLCJnZXRHcmlkUm93QWdncmVnYXRlU3BhbnMiLCJmaW5kSW5kZXgiLCJjdW11bGF0aXZlcGl4ZWxsZW5ndGgiLCJhdCIsImdyaWRTcGFuUm93U2hpZnQiLCJheGlzUmVmZXJlbmNlUm93U2hpZnQiLCJheGlzUGl4ZWxTaGlmdCIsInNjcm9sbGJsb2NrQXhpc1BpeGVsT2Zmc2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInNjcm9sbGJsb2NrUGl4ZWxPZmZzZXQiLCJjdXJyZW50Vmlld3BvcnRBeGlzUGl4ZWxPZmZzZXQiLCJuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCIsImNyYWRsZVJlZmVyZW5jZVJvd3NoaWZ0IiwibmV3Q3JhZGxlUmVmZXJlbmNlUm93IiwibmV3QXhpc1JlZmVyZW5jZVJvdyIsImhlYWRyb3dEaWZmIiwidGFyZ2V0Q3JhZGxlRW5kcm93IiwidGFpbHJvd2RpZmYiLCJjb21wdXRlZE5leHRDcmFkbGVFbmRSb3ciLCJuZXdDcmFkbGVSZWZlcmVuY2VJbmRleCIsImNyYWRsZVJlZmVyZW5jZUl0ZW1TaGlmdCIsIm5ld0F4aXNSZWZlcmVuY2VJbmRleCIsImF4aXNSZWZlcmVuY2VJdGVtU2hpZnQiLCJpbmNsdWRlc0xhc3RSb3ciLCJpbmNsdWRlc0ZpcnN0Um93IiwiY2hhbmdlT2ZDcmFkbGVDb250ZW50Q291bnQiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsImdyaWQiLCJyb3dMZW5ndGhzIiwiZWxlbWVudExpc3QiLCJjaGlsZE5vZGVzIiwiZWxlbWVudFB0ciIsImVsZW1lbnQiLCJyb3dsZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInB1c2giLCJyb3dTcGFucyIsImZvckVhY2giLCJ2YWx1ZSIsImdldENlbGxGcmFtZUNvbXBvbmVudExpc3QiLCJfcmVmNCIsImNhY2hlQVBJIiwiY3JhZGxlQ29udGVudENvdW50IiwiY3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJjb250ZW50bGlzdCIsIndvcmtpbmdDb250ZW50TGlzdCIsImluc3RhbmNlSWRDb3VudGVyUmVmIiwic3R5bGVzIiwicGxhY2Vob2xkZXJNZXNzYWdlcyIsImxvY2FsQ29udGVudGxpc3QiLCJsYXN0aW5kZXhvZmZzZXQiLCJoZWFkQ29udGVudGxpc3QiLCJ0YWlsQ29udGVudGxpc3QiLCJkZWxldGVkdGFpbGl0ZW1zIiwiZGVsZXRlZGhlYWRpdGVtcyIsInJlZmVyZW5jZUluZGV4IiwiY2hhbmdlQ291bnQiLCJuZXdpbmRleCIsImNyZWF0ZUNlbGxGcmFtZSIsInBsYWNlaG9sZGVyRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlcmZyYW1lIiwicGxhY2Vob2xkZXJMaW5lclN0eWxlcyIsInBsYWNlaG9sZGVybGluZXIiLCJwbGFjZWhvbGRlckVycm9yRnJhbWVTdHlsZXMiLCJwbGFjZWhvbGRlcmVycm9yZnJhbWUiLCJwbGFjZWhvbGRlckVycm9yTGluZXJTdHlsZXMiLCJwbGFjZWhvbGRlcmVycm9ybGluZXIiLCJzcGxpY2UiLCJkZWxldGVkSXRlbXMiLCJjb25jYXQiLCJjb21wb25lbnRMaXN0IiwiYWxsb2NhdGVDb250ZW50TGlzdCIsIl9yZWY1IiwiYXhpc1JlZmVyZW5jZUluZGV4IiwibGF5b3V0SGFuZGxlciIsInRyaWdnZXJjZWxsSW5kZXgiLCJsb3djb250ZW50aW5kZXgiLCJoaWdoY29udGVudGluZGV4IiwiaGVhZGl0ZW1jb3VudCIsInRhcmdldFRyaWdnZXJjZWxsSW5kZXgiLCJ0cmlnZ2VyY2VsbElzSW5UYWlsIiwidW5kZWZpbmVkIiwidHJpZ2dlcmNlbGxQdHIiLCJ0cmlnZ2VyY2VsbENvbXBvbmVudCIsImNsb25lRWxlbWVudCIsImlzVHJpZ2dlcmNlbGwiLCJjb25zb2xlIiwibG9nIiwiaXNUcmlnZ2VjZWxsIiwiYXNzaWduIiwiaGVhZGxpc3QiLCJ0YWlsbGlzdCIsImRlbGV0ZVBvcnRhbHMiLCJkZWxldGVMaXN0IiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiZGxpc3QiLCJtYXAiLCJpdGVtIiwiZGVsZXRlUG9ydGFsQnlJbmRleCIsIl9yZWY2IiwiaW5zdGFuY2VJRCIsImNlbGxNaW5IZWlnaHQiLCJjZWxsTWluV2lkdGgiLCJnZXRJdGVtIiwicGxhY2Vob2xkZXIiLCJ1c2VQbGFjZWhvbGRlciIsIml0ZW1JRCIsImdldE5ld09yRXhpc3RpbmdJdGVtSUQiLCJjcmVhdGVFbGVtZW50Iiwia2V5IiwiZ3JpZHN0YXJ0c3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cradle/contentfunctions.tsx\n")},"./src/cradle/contenthandler.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// contenthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module supports the setup, rollover and positioning of content in the Cradle.\n\n    There are three key functions in this module: setCradleContent, updateCradleContent, and\n    adjustScrollblockForVariability.\n\n    There are also a few functions which support synchronization of Cradle content with cache\n    content (see internal and external services below).\n\n    setCradleContent is called directly from Cradle (in the state manager), and instantiates new Cradle\n    content in response to the scroller setup, or changes to its configuration. setCradleContent\n    creates a list of Cradle content CellFrames, and allocates those to the two Cradle grids. This\n    process occurs in response to many state changes, such as finishreposition, pivot, a host scrollto\n    request, and more.\n\n    updateCradleContent rolls over the Cradle content in response to user scrolling. When scrolling\n    down (or right), content is removed from the Cradle tail and added to the Cradle head (thus moving the\n    Cradle axis), while new content is added to the tail. When scrolling up (or left), the reverse occurs.\n\n    adjustScrollblockForVariability reconfigures the scrollblock to accommodate variable sized grid rows.\n\n    The Cradle (through the contentfunctions module) delegates fetching content items to the CellFrame.\n\n    This module is supported primarily by the contentfunctions module.\n\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ "./src/cradle/contentfunctions.tsx");\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar ContentHandler = /*#__PURE__*/function () {\n  function ContentHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, ContentHandler);\n    this.content = {\n      cradleModelComponents: null,\n      headModelComponents: null,\n      tailModelComponents: null,\n      // the following two only used in cradle for render\n      headDisplayComponents: [],\n      tailDisplayComponents: []\n    };\n    this.instanceIdCounterRef = {\n      current: 0\n    };\n    // Three main public methods - setCradleContent, updateCradleContent, and adjustScrollblockForVariability\n    // ==========================[ SET CONTENT ]===========================\n    // reset the cradle with new content, including allocation between head and tail parts of the cradle\n    // - called only from the Cradle state handler\n    this.updateVirtualListSpecs = function (newlistsize) {\n      if (newlistsize == 0) {\n        var cradleContent = _this.content;\n        _this.clearCradle();\n        cradleContent.headDisplayComponents = [];\n        cradleContent.tailDisplayComponents = [];\n      }\n      _this.cradleParameters.cradleInternalPropertiesRef.current.setVirtualListSpecs(newlistsize);\n    };\n    this.setCradleContent = function (cradleState) {\n      // ------------------------------[ 1. initialize ]---------------------------\n      var cradleParameters = _this.cradleParameters;\n      var ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleHandlers = cradleParameters.handlersRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var cacheAPI = cradleHandlers.cacheAPI,\n        layoutHandler = cradleHandlers.layoutHandler,\n        serviceHandler = cradleHandlers.serviceHandler,\n        scrollHandler = cradleHandlers.scrollHandler,\n        cradlePositionData = layoutHandler.cradlePositionData,\n        requestedAxisReferencePosition = cradlePositionData.targetAxisReferencePosition,\n        orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages,\n        scrollerID = cradleInheritedProperties.scrollerID,\n        virtualListProps = cradleInternalProperties.virtualListProps,\n        cradleContentProps = cradleInternalProperties.cradleContentProps,\n        listlowindex = virtualListProps.lowindex,\n        listsize = virtualListProps.size,\n        crosscount = virtualListProps.crosscount,\n        listRowcount = virtualListProps.rowcount,\n        baserowblanks = virtualListProps.baserowblanks;\n      scrollerID == 1 && console.log(\'setCradleContent: opening cradlePositionData\', Object.assign({}, cradlePositionData));\n      var cradleContent = _this.content;\n      var targetAxisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset;\n      // ----------------------[ 2. normalize data ]--------------------------\n      // in bounds\n      var workingAxisReferencePosition = Math.min(requestedAxisReferencePosition, listsize - 1);\n      // shifted by virtual list low range\n      var workingAxisReferenceIndex = workingAxisReferencePosition + listlowindex;\n      // console.log(\'first calc: workingAxisReferenceIndex, workingAxisReferencePosition, listlowindex, workingAxisReferenceIndex % crosscount, crosscount\\n\', \n      //     workingAxisReferenceIndex, workingAxisReferencePosition, listlowindex, workingAxisReferenceIndex % crosscount, crosscount)\n      // calculate axis reference base index\n      workingAxisReferenceIndex -= workingAxisReferenceIndex < 0 ? workingAxisReferenceIndex % crosscount ? crosscount - Math.abs(workingAxisReferenceIndex % crosscount) : 0 : workingAxisReferenceIndex % crosscount;\n      // console.log(\'second calc: workingAxisReferenceIndex, crosscount\',\n      //     workingAxisReferenceIndex, crosscount)\n      // reposition at row boundary\n      if ([\'firstrender\', \'firstrenderfromcache\', \'finishreposition\', \'reconfigure\', \'scrollto\'].includes(cradleState)) {\n        targetAxisViewportPixelOffset = workingAxisReferenceIndex == 0 ? padding : gap; // default\n      }\n\n      var workingContentList = [];\n      // ----------------------[ 3. get content requirements ]----------------------\n      var baseRowPixelLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      // note that targetAxisReferencePosition replaces requestedAxisReferenceIndex here\n      var _ref = (0, contentfunctions_1.calculateContentListRequirements)({\n          // pixel\n          baseRowPixelLength: baseRowPixelLength,\n          targetAxisViewportPixelOffset: targetAxisViewportPixelOffset,\n          // index\n          targetAxisReferenceIndex: workingAxisReferenceIndex,\n          // resources\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties\n        }),\n        targetCradleReferenceIndex = _ref.targetCradleReferenceIndex,\n        targetAxisReferenceIndex = _ref.targetAxisReferenceIndex,\n        cradleContentCount = _ref.newCradleContentCount,\n        scrollblockViewportPixelOffset = _ref.targetScrollblockViewportPixelOffset;\n      // console.log(\'from calculateContentListRequirements: targetCradleReferenceIndex, targetAxisReferenceIndex, scrollblockViewportPixelOffset\\n\',\n      //     targetCradleReferenceIndex, targetAxisReferenceIndex, scrollblockViewportPixelOffset)\n      var axisViewportPixelOffset = targetAxisViewportPixelOffset; // semantics\n      // ----------------------[ 4. get and config content ]----------------------\n      // console.log(\'setCradleContent: getCellFrameComponentList args - cradleContentCount, targetCradleReferenceIndex\',\n      //     cradleContentCount, targetCradleReferenceIndex)\n      // returns content constrained by cradleRowcount\n      var _ref2 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheAPI: cacheAPI,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          cradleReferenceIndex: targetCradleReferenceIndex,\n          listStartChangeCount: 0,\n          listEndChangeCount: cradleContentCount,\n          workingContentList: workingContentList,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        }),\n        _ref3 = _slicedToArray(_ref2, 1),\n        newcontentlist = _ref3[0];\n      // update cradleContentProps from newcontentlise\n      cradleContentProps.size = newcontentlist.length;\n      if (cradleContentProps.size) {\n        cradleContentProps.lowindex = newcontentlist[0].props.index;\n        cradleContentProps.highindex = cradleContentProps.lowindex + cradleContentProps.size - 1;\n        cradleContentProps.SOL = virtualListProps.lowindex == cradleContentProps.lowindex;\n        cradleContentProps.EOL = virtualListProps.highindex == cradleContentProps.highindex;\n      } else {\n        cradleContentProps.lowindex = null;\n        cradleContentProps.highindex = null;\n        cradleContentProps.SOL = true; // TODO harmonize across app\n        cradleContentProps.EOL = true;\n      }\n      // console.log(\'setCradleContent: virtualListProps, cradleContentProps\',virtualListProps, cradleContentProps)\n      // set or cancel first row offset if within cradle\n      var gridstart;\n      // console.log(\'virtualListProps, cradleContentProps, newcontentlist\',\n      //     virtualListProps, cradleContentProps, newcontentlist)\n      if (cradleContentProps.SOL && virtualListProps.baserowblanks) {\n        gridstart = "".concat(virtualListProps.baserowblanks + 1);\n      } else {\n        gridstart = \'unset\';\n      }\n      var firstcomponent = newcontentlist[0];\n      if (!firstcomponent) return; // possible child dismounts with nested scrollers\n      var gridstartstyle;\n      if (orientation == \'vertical\') {\n        gridstartstyle = {\n          gridColumnStart: gridstart\n        };\n      } else {\n        gridstartstyle = {\n          gridRowStart: gridstart\n        };\n      }\n      var revisedcomponent = react_1["default"].cloneElement(firstcomponent, {\n        gridstartstyle: gridstartstyle\n      });\n      newcontentlist[0] = revisedcomponent;\n      // console.log(\'gridstartstyle,revisedcomponent\',gridstartstyle,revisedcomponent)\n      var _ref4 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: newcontentlist,\n          axisReferenceIndex: targetAxisReferenceIndex,\n          layoutHandler: layoutHandler\n          // listlowindex,\n        }),\n        _ref5 = _slicedToArray(_ref4, 2),\n        headcontentlist = _ref5[0],\n        tailcontentlist = _ref5[1];\n      // console.log(\'SET targetAxisReferenceIndex, headcontentlist, tailcontentlist\',\n      //     targetAxisReferenceIndex, headcontentlist, tailcontentlist)\n      // console.log(\'SET cradleContentProps\',cradleContentProps)\n      cradleContent.cradleModelComponents = newcontentlist;\n      cradleContent.headModelComponents = headcontentlist;\n      cradleContent.tailModelComponents = tailcontentlist;\n      cradlePositionData.targetAxisReferencePosition = targetAxisReferenceIndex - listlowindex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      scrollerID == 1 && console.log(\'setCradleContent: closing cradlePositionData\', Object.assign({}, cradlePositionData));\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = cradleState;\n        serviceHandler.callbacks.referenceIndexCallback(cradlePositionData.targetAxisReferencePosition, \'setCradleContent\', cstate);\n      }\n      //  ----------------------[ 5. set CSS ]-----------------------\n      // reset scrollblock Offset and length\n      var scrollblockElement = viewportElement.firstChild;\n      var blockbaselength = listRowcount * baseRowPixelLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (cradleState == \'pivot\') {\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.left = null;\n        } else {\n          scrollblockElement.style.top = null;\n        }\n      }\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = blockbaselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = blockbaselength + \'px\';\n      }\n      cradlePositionData.blockScrollPos = scrollblockViewportPixelOffset;\n      // avoid bogus call to updateCradleContent\n      scrollerID == 1 && console.log(\'setCradleContent.resetScrollData: scrollblockViewportPixelOffset\\n\', scrollblockViewportPixelOffset);\n      scrollHandler.resetScrollData(scrollblockViewportPixelOffset);\n      viewportElement[cradlePositionData.blockScrollProperty] = cradlePositionData.blockScrollPos;\n      var cradleElements = layoutHandler.elements;\n      var axisElement = cradleElements.axisRef.current,\n        headElement = cradleElements.headRef.current;\n      var axisScrollblockPixelOffset = scrollblockViewportPixelOffset + axisViewportPixelOffset;\n      // console.log(\'blockbaselength, axisScrollblockPixelOffset, scrollblockViewportPixelOffset, axisViewportPixelOffset\',\n      //     blockbaselength, axisScrollblockPixelOffset, scrollblockViewportPixelOffset, axisViewportPixelOffset)\n      if (orientation == \'vertical\') {\n        var top = axisScrollblockPixelOffset;\n        axisElement.style.top = top + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // orientation = \'horizontal\'\n        var left = axisScrollblockPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = left + \'px\';\n        headElement.style.padding = headcontentlist.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ==================[ UPDATE CONTENT through scroll ]========================\n    // updateCradleContent does not touch the viewport element\'s scroll position for the scrollblock\n    // instead it reconfigures elements within the cradle. It is called solely from\n    // axisTriggerlinesObserverCallback of interruptHandler.\n    // typically called for scroll action, but can also be called if the triggerLineCell changes\n    // size with variant layout.\n    this.updateCradleContent = function () {\n      // console.log(\'running updateCradleContent\')\n      var _a;\n      // ----------------------[ 1. initialize ]-------------------------\n      var cradleParameters = _this.cradleParameters,\n        cradleContent = _this.content;\n      var viewportElement = cradleParameters.ViewportContextPropertiesRef.current.elementRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n        cradleHandlers = cradleParameters.handlersRef.current;\n      var cacheAPI = cradleHandlers.cacheAPI,\n        layoutHandler = cradleHandlers.layoutHandler,\n        stateHandler = cradleHandlers.stateHandler,\n        interruptHandler = cradleHandlers.interruptHandler,\n        serviceHandler = cradleHandlers.serviceHandler,\n        shiftinstruction = interruptHandler.shiftinstruction,\n        triggerViewportReferencePixelPos = interruptHandler.triggerViewportReferencePixelPos,\n        cradleElements = layoutHandler.elements,\n        cradlePositionData = layoutHandler.cradlePositionData,\n        orientation = cradleInheritedProperties.orientation,\n        cache = cradleInheritedProperties.cache,\n        styles = cradleInheritedProperties.styles,\n        placeholderMessages = cradleInheritedProperties.placeholderMessages,\n        layout = cradleInheritedProperties.layout,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        padding = cradleInheritedProperties.padding,\n        gap = cradleInheritedProperties.gap,\n        scrollerID = cradleInheritedProperties.scrollerID,\n        virtualListProps = cradleInternalProperties.virtualListProps,\n        cradleContentProps = cradleInternalProperties.cradleContentProps,\n        crosscount = virtualListProps.crosscount,\n        listlowindex = virtualListProps.lowindex;\n      // if (interruptHandler.signals.repositioningRequired) return\n      // new vars\n      var scrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      var modelcontentlist = cradleContent.cradleModelComponents || [];\n      var previousCradleReferenceIndex = ((_a = modelcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n      // console.log(\'==>> shift instruction\', shiftinstruction)\n      // --------------------------------[ 3. Calculate shifts ]-------------------------------\n      // cradle properties\n      var _ref6 = (0, contentfunctions_1.calculateShiftSpecs)({\n          shiftinstruction: shiftinstruction,\n          triggerViewportReferencePixelPos: triggerViewportReferencePixelPos,\n          scrollPos: scrollPos,\n          scrollblockElement: viewportElement.firstChild,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleContentProps: cradleContentProps,\n          virtualListProps: virtualListProps,\n          cradleContent: cradleContent,\n          cradleElements: cradleElements\n        }),\n        cradleItemShift = _ref6.cradleReferenceItemShift,\n        axisReferenceIndex = _ref6.newAxisReferenceIndex,\n        axisItemShift = _ref6.axisReferenceItemShift,\n        cradleContentCount = _ref6.newCradleContentCount,\n        listStartChangeCount = _ref6.listStartChangeCount,\n        listEndChangeCount = _ref6.listEndChangeCount,\n        newAxisViewportPixelOffset = _ref6.newAxisViewportPixelOffset;\n      //         console.log(\n      // `\n      // cradleReferenceItemShift: cradleItemShift, \n      // newAxisReferenceIndex: axisReferenceIndex, \n      // axisReferenceItemShift: axisItemShift, \n      // // counts\n      // newCradleContentCount: cradleContentCount,\n      // listStartChangeCount,\n      // listEndChangeCount,\n      // // pixels\n      // newAxisViewportPixelOffset, \n      // `,\n      // cradleItemShift, \n      // axisReferenceIndex, \n      // axisItemShift,\'\\n\', \n      // cradleContentCount,\n      // listStartChangeCount,\n      // listEndChangeCount,\'\\n\',\n      // newAxisViewportPixelOffset\n      // )\n      var axisViewportPixelOffset = newAxisViewportPixelOffset;\n      var isShift = !(axisItemShift == 0 && cradleItemShift == 0);\n      var axisElement = cradleElements.axisRef.current;\n      var headElement = cradleElements.headRef.current;\n      // the triggerlines will be moved, so disconnect them from their observer.\n      // they are reconnected with \'renderupdatedcontent\' state in cradle.tsx, or at \'finishupdateforvariability\'\n      //    for variable content\n      interruptHandler.triggerlinesIntersect.disconnect();\n      // abandon option; nothing to do but reposition\n      if (!isShift) {\n        // can happen first row; oversized last row\n        cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n        _this.applyStyling({\n          layout: layout,\n          orientation: orientation,\n          padding: padding,\n          gap: gap,\n          cellHeight: cellHeight,\n          cellWidth: cellWidth,\n          crosscount: crosscount,\n          axisReferenceIndex: axisReferenceIndex,\n          axisViewportPixelOffset: axisViewportPixelOffset,\n          scrollPos: scrollPos,\n          headcontent: cradleContent.headModelComponents,\n          axisElement: axisElement,\n          headElement: headElement,\n          listlowindex: listlowindex\n        });\n        return;\n      }\n      // ----------------------------------[ 4. reconfigure cradle content ]--------------------------\n      // collect changed content\n      var updatedContentList,\n        deletedContentItems = [];\n      if (listStartChangeCount || listEndChangeCount) {\n        // if either is non-0 then modify content\n        // console.log(\'updatedContentList, deletedContentItems\',updatedContentList, deletedContentItems)\n        var _ref7 = (0, contentfunctions_1.getCellFrameComponentList)({\n          cacheAPI: cacheAPI,\n          cradleInheritedProperties: cradleInheritedProperties,\n          cradleInternalProperties: cradleInternalProperties,\n          cradleContentCount: cradleContentCount,\n          workingContentList: modelcontentlist,\n          listStartChangeCount: listStartChangeCount,\n          listEndChangeCount: listEndChangeCount,\n          cradleReferenceIndex: previousCradleReferenceIndex,\n          instanceIdCounterRef: _this.instanceIdCounterRef,\n          styles: styles,\n          placeholderMessages: placeholderMessages\n        });\n        var _ref8 = _slicedToArray(_ref7, 2);\n        updatedContentList = _ref8[0];\n        deletedContentItems = _ref8[1];\n        cradleContentProps.size = updatedContentList.length;\n        if (cradleContentProps.size) {\n          cradleContentProps.lowindex = updatedContentList[0].props.index;\n          cradleContentProps.highindex = cradleContentProps.lowindex + cradleContentProps.size - 1;\n          cradleContentProps.SOL = virtualListProps.lowindex == cradleContentProps.lowindex;\n          cradleContentProps.EOL = virtualListProps.highindex == cradleContentProps.highindex;\n        } else {\n          cradleContentProps.lowindex = null;\n          cradleContentProps.highindex = null;\n          cradleContentProps.SOL = true;\n          cradleContentProps.EOL = true;\n        }\n        var gridstart;\n        // console.log(\'virtualListProps, cradleContentProps, newcontentlist\',virtualListProps, cradleContentProps, newcontentlist)\n        if (cradleContentProps.SOL && virtualListProps.baserowblanks) {\n          gridstart = "".concat(virtualListProps.baserowblanks + 1);\n        } else {\n          gridstart = \'unset\';\n        }\n        var firstcomponent = updatedContentList[0];\n        var gridstartstyle;\n        if (orientation == \'vertical\') {\n          gridstartstyle = {\n            gridColumnStart: gridstart\n          };\n        } else {\n          gridstartstyle = {\n            gridRowStart: gridstart\n          };\n        }\n        var revisedcomponent = react_1["default"].cloneElement(firstcomponent, {\n          gridstartstyle: gridstartstyle\n        });\n        updatedContentList[0] = revisedcomponent;\n        // console.log(\'gridstartstyle,revisedcomponent\',gridstartstyle,revisedcomponent)\n        // console.log(\'UPDATE cradleContentProps\',cradleContentProps)\n      } else {\n        updatedContentList = modelcontentlist;\n      }\n      if (deletedContentItems.length && cache == \'cradle\') {\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cradle\', deleteList);\n          };\n        }\n        (0, contentfunctions_1.deletePortals)(cacheAPI, deletedContentItems, dListCallback);\n      }\n      // ----------------------------------[ 5. allocate cradle content ]--------------------------\n      var _ref9 = (0, contentfunctions_1.allocateContentList)({\n          contentlist: updatedContentList,\n          axisReferenceIndex: axisReferenceIndex,\n          layoutHandler: layoutHandler\n          // listlowindex,\n        }),\n        _ref10 = _slicedToArray(_ref9, 2),\n        headcontent = _ref10[0],\n        tailcontent = _ref10[1];\n      // console.log(\'==>> headcontent, tailcontent\',headcontent, tailcontent)\n      // return\n      cradleContent.cradleModelComponents = updatedContentList;\n      cradleContent.headModelComponents = headcontent;\n      cradleContent.tailModelComponents = tailcontent;\n      if (serviceHandler.callbacks.referenceIndexCallback) {\n        var cstate = stateHandler.cradleStateRef.current;\n        serviceHandler.callbacks.referenceIndexCallback(axisReferenceIndex, \'updateCradleContent\', cstate);\n      }\n      // console.log(\'updateCradleContent: axisReferenceIndex\', axisReferenceIndex)\n      // -------------------------------[ 6. css changes ]-------------------------\n      cradlePositionData.targetAxisReferencePosition = axisReferenceIndex - listlowindex;\n      cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n      scrollerID == 1 && console.log(\'updateCradleContent: shiftinstruction, ending cradlePositionData\', shiftinstruction, Object.assign({}, cradlePositionData));\n      if (isShift) cacheAPI.renderPortalLists();\n      // console.log(\'calling applyStyling:axisViewportPixelOffset\',axisViewportPixelOffset)\n      _this.applyStyling({\n        layout: layout,\n        orientation: orientation,\n        padding: padding,\n        gap: gap,\n        cellHeight: cellHeight,\n        cellWidth: cellWidth,\n        crosscount: crosscount,\n        axisReferenceIndex: axisReferenceIndex,\n        axisViewportPixelOffset: axisViewportPixelOffset,\n        scrollPos: scrollPos,\n        headcontent: headcontent,\n        axisElement: axisElement,\n        headElement: headElement,\n        listlowindex: listlowindex\n      });\n      // load new display data\n      cradleContent.headDisplayComponents = cradleContent.headModelComponents;\n      cradleContent.tailDisplayComponents = cradleContent.tailModelComponents;\n    };\n    // move the offset of the axis\n    this.applyStyling = function (_ref11) {\n      var layout = _ref11.layout,\n        orientation = _ref11.orientation,\n        padding = _ref11.padding,\n        gap = _ref11.gap,\n        cellHeight = _ref11.cellHeight,\n        cellWidth = _ref11.cellWidth,\n        crosscount = _ref11.crosscount,\n        axisReferenceIndex = _ref11.axisReferenceIndex,\n        axisViewportPixelOffset = _ref11.axisViewportPixelOffset,\n        scrollPos = _ref11.scrollPos,\n        headcontent = _ref11.headcontent,\n        axisElement = _ref11.axisElement,\n        headElement = _ref11.headElement,\n        listlowindex = _ref11.listlowindex;\n      // console.log(\'==>> applyStyling: axisReferenceIndex, axisViewportPixelOffset, listlowindex\', \n      //     axisReferenceIndex, axisViewportPixelOffset, listlowindex)\n      if (layout == \'variable\') return; // there\'s a separate routine for variable adjustments and css\n      // --------------\n      // Safari when zoomed drifts (calc precision one presumes). This is a hack to correct that.\n      var preAxisVirtualRows = Math.ceil((axisReferenceIndex - listlowindex) / crosscount);\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var testScrollPos = baseCellLength * preAxisVirtualRows + padding - axisViewportPixelOffset;\n      var scrollDiff = testScrollPos - scrollPos;\n      if (scrollDiff) {\n        axisViewportPixelOffset += scrollDiff;\n      }\n      var topAxisPos, leftAxisPos; // available for debug\n      if (orientation == \'vertical\') {\n        topAxisPos = scrollPos + axisViewportPixelOffset;\n        // console.log(\'topAxisPos, baseCellLength, preAxisVirtualRows, testScrollPos, scrollPos, scrollDiff, axisViewportPixelOffset\\n\', \n        //     topAxisPos, baseCellLength, preAxisVirtualRows, testScrollPos, scrollPos, scrollDiff, axisViewportPixelOffset)\n        axisElement.style.top = topAxisPos + \'px\';\n        axisElement.style.left = \'auto\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        // \'horizontal\'\n        leftAxisPos = scrollPos + axisViewportPixelOffset;\n        axisElement.style.top = \'auto\';\n        axisElement.style.left = leftAxisPos + \'px\';\n        headElement.style.padding = headcontent.length ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n    };\n    // ===================[ RECONFIGURE THE SCROLLBLOCK FOR VARIABLE CONTENT ]=======================\n    /*\n        blockScrollPos is the amount the scrollBlock is scrolled to reveal the centre of the Cradle\n            at the edge of the Viewport\n        \n        newAxisScrollblockOffset is the exact offset of blockScrollPos, plus the axisViewportOffset\n        \n        axisViewportOffset is the amount the axis is ahead of the Viewport edge\n        \n        the length of the Scrollblock is shortened by the amount the measured tail length differs from the\n            base tail length\n    \n        Called for variable layout only. All DOM elements should have been rendered at this point\n        sets CSS: scrollblockElement top and height (or left and width), and axisElement top (or left)\n        to get closer to natural proportions to minimize janky scroll thumb\n    */\n    this.adjustScrollblockForVariability = function (source) {\n      // console.log(\'adjustScrollblockForVariability: source\',source)\n      // ----------------------[ setup base values and references ]------------------------\n      // resources...\n      var cradleParameters = _this.cradleParameters,\n        cradleHandlers = cradleParameters.handlersRef.current,\n        ViewportContextProperties = cradleParameters.ViewportContextPropertiesRef.current,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current,\n        layoutHandler = cradleHandlers.layoutHandler,\n        scrollHandler = cradleHandlers.scrollHandler,\n        interruptHandler = cradleHandlers.interruptHandler,\n        cradleElements = layoutHandler.elements,\n        cradlePositionData = layoutHandler.cradlePositionData,\n        axisReferencePosition = cradlePositionData.targetAxisReferencePosition,\n        axisViewportPixelOffset = cradlePositionData.targetAxisViewportPixelOffset,\n        viewportElement = ViewportContextProperties.elementRef.current,\n        scrollblockElement = viewportElement.firstChild,\n        headGridElement = cradleElements.headRef.current,\n        tailGridElement = cradleElements.tailRef.current,\n        axisElement = cradleElements.axisRef.current,\n        orientation = cradleInheritedProperties.orientation,\n        gap = cradleInheritedProperties.gap,\n        padding = cradleInheritedProperties.padding,\n        cellHeight = cradleInheritedProperties.cellHeight,\n        cellWidth = cradleInheritedProperties.cellWidth,\n        virtualListProps = cradleInternalProperties.virtualListProps,\n        cradleContentProps = cradleInternalProperties.cradleContentProps,\n        crosscount = virtualListProps.crosscount,\n        listRowcount = virtualListProps.rowcount,\n        listlowindex = virtualListProps.lowindex,\n        listrowshift = virtualListProps.rowshift;\n\n      // ------------------------[ calculations ]------------------------\n      var axisReferenceIndex = axisReferencePosition + listlowindex;\n      // rowcounts and row offsets for positioning\n      // listRowcount taken from internal properties above\n      var headRowCount = Math.ceil(headGridElement.childNodes.length / crosscount),\n        tailRowCount = Math.ceil(tailGridElement.childNodes.length / crosscount);\n      // console.log(\'------------------\\n\',\'headRowCount, headGridElement.childNodes.length, tailRowCount, axisReferenceIndex\\n\',\n      //     headRowCount, headGridElement.childNodes.length, tailRowCount, axisReferenceIndex )\n      // reference rows - cradle first/last; axis; list end\n      var axisReferenceRow = Math.floor(axisReferenceIndex / crosscount);\n      // (axisReferenceIndex < 0)?\n      //     Math.floor(axisReferenceIndex/crosscount):\n      //     Math.ceil(axisReferenceIndex/crosscount)\n      var cradleReferenceRow = axisReferenceRow - headRowCount,\n        cradleLastRow = axisReferenceRow + (tailRowCount - 1),\n        listLastRow = listRowcount - 1 + listrowshift;\n      // console.log(\'axisReferenceRow, cradleReferenceRow, headRowCount\\n\',\n      //     axisReferenceRow, cradleReferenceRow, headRowCount)\n      var preCradleRowCount = cradleReferenceRow - listrowshift,\n        postCradleRowCount = listLastRow - cradleLastRow;\n      // console.log(\'preCradleRowCount, cradleReferenceRow, listrowshift\\n\',\n      //     preCradleRowCount, cradleReferenceRow, listrowshift)\n      // base pixel values\n      var baseCellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var measuredTailPixelLength = orientation == \'vertical\' ? tailGridElement.offsetHeight : tailGridElement.offsetWidth;\n      var basePostCradlePixelLength = postCradleRowCount * baseCellLength;\n      var computedPostAxisPixelLength = basePostCradlePixelLength + measuredTailPixelLength;\n      // base figures used for preAxis #s for compatibility with repositioning, which uses base figures\n      var basePreAxisPixelLength = (preCradleRowCount + headRowCount) * baseCellLength + padding;\n      // ------------------------[ layout adjustments ]----------------------\n      interruptHandler.signals.pauseCradleIntersectionObserver = true;\n      var computedScrollblockPixelLength = basePreAxisPixelLength + computedPostAxisPixelLength;\n      var blockScrollPos = basePreAxisPixelLength - axisViewportPixelOffset;\n      var newAxisScrollblockPixelOffset = blockScrollPos + axisViewportPixelOffset; // ie. basePreAxisPixelLength, but semantics\n      // console.log(\'newAxisScrollblockOffset, blockScrollPos, axisViewportPixelOffset\\n\',\n      //     newAxisScrollblockOffset, blockScrollPos, axisViewportPixelOffset)\n      if (orientation == \'vertical\') {\n        axisElement.style.top = newAxisScrollblockPixelOffset + \'px\';\n        scrollblockElement.style.height = computedScrollblockPixelLength + \'px\';\n      } else {\n        // \'horizontal\'\n        axisElement.style.left = newAxisScrollblockPixelOffset + \'px\';\n        scrollblockElement.style.width = computedScrollblockPixelLength + \'px\';\n      }\n      // -----------------------[ scrollPos adjustment ]-------------------------\n      if (orientation == \'vertical\') {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(padding, "px ").concat(gap, "px ").concat(padding, "px") : "".concat(padding, "px ").concat(padding, "px 0px ").concat(padding, "px");\n      } else {\n        headGridElement.style.padding = headRowCount ? "".concat(padding, "px ").concat(gap, "px ").concat(padding, "px ").concat(padding, "px") : "".concat(padding, "px 0px ").concat(padding, "px ").concat(padding, "px");\n      }\n      if (!(0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // adjust blockScrollPos directly - most browsers including Safari desktop\n        cradlePositionData.blockScrollPos = blockScrollPos;\n        viewportElement[cradlePositionData.blockScrollProperty] = blockScrollPos;\n        scrollHandler.resetScrollData(blockScrollPos);\n      } else {\n        // for Safari iOS\n        // temporarily adjust scrollblockElement offset; iOSonAfterScroll transfers shift to blockScrollPos\n        // - direct change of scrollTop/ScrollLeft in Safari iOS is ignored by the browser momentum engine\n        var startingScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollDiff = blockScrollPos - startingScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = -scrollDiff + \'px\';\n        } else {\n          scrollblockElement.style.left = -scrollDiff + \'px\';\n        }\n      }\n      // check for gotoIndex or resize overshoot\n      if (source == \'setcradle\' && !postCradleRowCount) {\n        var viewportPixelLength = orientation == \'vertical\' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n        var alignedEndPosDiff = axisViewportPixelOffset + measuredTailPixelLength - viewportPixelLength;\n        // console.log(\'source, alignedEndPosDiff, axisViewportPixelOffset, measuredTailPixelLength, viewportPixelLength\\n\',\n        //     source, alignedEndPosDiff, axisViewportPixelOffset, measuredTailPixelLength, viewportPixelLength)\n        if (alignedEndPosDiff < 0) {\n          // fill the bottom of the viewport using scrollBy\n          var scrollByY = orientation == \'vertical\' ? alignedEndPosDiff : 0;\n          var scrollByX = orientation == \'vertical\' ? 0 : alignedEndPosDiff;\n          viewportElement.scrollBy(scrollByX, scrollByY);\n        }\n      }\n    };\n    // ========================= [ INTERNAL CONTENT MANAGEMENT SERVICES ]=====================\n    this.guardAgainstRunawayCaching = function () {\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cacheMax = _this$cradleParameter.cacheMax,\n        MAX_CACHE_OVER_RUN = _this$cradleParameter.MAX_CACHE_OVER_RUN;\n      var cacheAPI = _this.cradleParameters.handlersRef.current.cacheAPI;\n      var modelComponentList = _this.content.cradleModelComponents;\n      if (cacheAPI.guardAgainstRunawayCaching(cacheMax, modelComponentList.length, MAX_CACHE_OVER_RUN)) {\n        _this.pareCacheToMax();\n      }\n    };\n    this.pareCacheToMax = function () {\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n      var cache = cradleInheritedProperties.cache,\n        scrollerID = cradleInheritedProperties.scrollerID;\n      if (cache == \'keepload\') {\n        var cradleHandlers = _this.cradleParameters.handlersRef.current;\n        var cacheAPI = cradleHandlers.cacheAPI,\n          serviceHandler = cradleHandlers.serviceHandler;\n        var modelIndexList = _this.getModelIndexList();\n        var deleteListCallback = serviceHandler.callbacks.deleteListCallback;\n        var dListCallback;\n        if (deleteListCallback) {\n          dListCallback = function dListCallback(deleteList) {\n            deleteListCallback(\'pare cache to cacheMax\', deleteList);\n          };\n        }\n        if (cacheAPI.pareCacheToMax(cradleInheritedProperties.cacheMax, modelIndexList, dListCallback)) {\n          cacheAPI.renderPortalLists();\n        }\n      }\n    };\n    // ==========================[ EXTERNAL SERVICE SUPPORT ]=======================\n    // supports clearCache\n    this.clearCradle = function () {\n      var cradleContent = _this.content;\n      // const { cacheAPI } = this.cradleParameters.handlersRef.current\n      cradleContent.cradleModelComponents = [];\n      cradleContent.headModelComponents = [];\n      cradleContent.tailModelComponents = [];\n    };\n    this.cradleParameters = cradleParameters;\n  }\n  // called from serviceHandler getCradleIndexMap\n  // also supports pareCacheToMax, matchCacheToCradle\n  _createClass(ContentHandler, [{\n    key: "getModelIndexList",\n    value: function getModelIndexList() {\n      var cradleModelComponents = this.content.cradleModelComponents;\n      if (!cradleModelComponents) {\n        return [];\n      } else {\n        return cradleModelComponents.map(function (item) {\n          return item.props.index;\n        });\n      }\n    }\n    // get indexSpan() {\n    //     const { cradleModelComponents } = this.content\n    //     if (cradleModelComponents.length == 0) return []\n    //     const lowIndex =  cradleModelComponents[0].props.index\n    //     const highIndex = lowIndex + (cradleModelComponents.length - 1)\n    //     return [lowIndex, highIndex]\n    // }\n    // called from service handler\'s remapIndexes, as last step\n  }, {\n    key: "reconcileCellFrames",\n    value: function reconcileCellFrames(modifiedIndexesList) {\n      if (!modifiedIndexesList.length) return;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cacheAPI = this.cradleParameters.handlersRef.current.cacheAPI;\n      // const { indexToItemIDMap } = cacheAPI.cacheProps\n      var indexToItemIDMap = cacheAPI.indexToItemIDMap;\n      function processComponentFn(component, i, array) {\n        var _component$props = component.props,\n          index = _component$props.index,\n          itemID = _component$props.itemID;\n        if (modifiedIndexesList.includes(index)) {\n          var newItemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : cacheAPI.getNewItemID();\n          if (newItemID != itemID) {\n            // defensive; shouldn\'t happen\n            array[i] = react_1["default"].cloneElement(component, {\n              itemID: newItemID\n            });\n          }\n        }\n      }\n      cradleModelComponents.forEach(processComponentFn);\n      this.content.headModelComponents = cradleModelComponents.slice(0, this.content.headModelComponents.length);\n      this.content.tailModelComponents = cradleModelComponents.slice(this.content.headModelComponents.length);\n    }\n    // supports moveIndex and insertRemoveIndex, updates cradle contiguous items from startChangeIndex or start of cradle\n  }, {\n    key: "synchronizeCradleItemIDsToCache",\n    value: function synchronizeCradleItemIDsToCache(updatedIndexList) {\n      var isInsertRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var startChangeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      // asssemble resources\n      var cacheAPI = this.cradleParameters.handlersRef.current.cacheAPI;\n      // const { indexToItemIDMap } = cacheAPI.cacheProps\n      var indexToItemIDMap = cacheAPI.indexToItemIDMap;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cradleContentProps = this.cradleParameters.cradleInheritedPropertiesRef.current.cradleContentProps;\n      // assemble parameters\n      // const indexSpan = this.indexSpan\n      // if (indexSpan.length == 0) return // defensive; shouldn\'t be here\n      // const [lowSpan,highSpan] = indexSpan\n      if (cradleContentProps.size == 0) return;\n      var lowSpan = cradleContentProps.lowindex,\n        highSpan = cradleContentProps.highindex;\n      var startIndex, endIndex;\n      if (isInsertRemove) {\n        if (startChangeIndex > highSpan) return;\n        startIndex = startChangeIndex;\n        endIndex = highSpan;\n      } else {\n        // move\n        if (updatedIndexList.length == 0) return;\n        startIndex = updatedIndexList[0];\n        endIndex = updatedIndexList.at(-1);\n      }\n      var updatedSpan = endIndex - startIndex + 1;\n      var firstIndex = startIndex;\n      if (firstIndex > highSpan) return;\n      if (firstIndex < lowSpan) firstIndex = lowSpan;\n      var lowPtr = firstIndex - lowSpan;\n      var highPtr = isInsertRemove ? cradleModelComponents.length - 1 : Math.min(cradleModelComponents.length - 1, lowPtr + updatedSpan - 1);\n      // function to update individual cradle components to cache changes\n      function processcomponentFn(component, componentptr, componentarray) {\n        var index = component.props.index;\n        var cacheItemID = indexToItemIDMap.get(index);\n        // if cache has no component for cradle item, then get one\n        if (cacheItemID === undefined) {\n          var newItemID = cacheAPI.getNewItemID();\n          componentarray[componentptr] = react_1["default"].cloneElement(component, {\n            itemID: newItemID\n          });\n          return;\n        } else {\n          // match cache itemID to cradle component itemID\n          var cradleItemID = component.props.itemID;\n          var updateptr = updatedIndexList.indexOf(index); // TODO verify need for updatelist\n          if (updateptr != -1) {\n            // update list confirms there is a cache item for this index\n            if (cacheItemID == cradleItemID) return;\n            componentarray[componentptr] = react_1["default"].cloneElement(component, {\n              itemID: cacheItemID\n            });\n          } else {\n            var _newItemID = cacheAPI.getNewItemID();\n            componentarray[componentptr] = react_1["default"].cloneElement(component, {\n              itemID: _newItemID\n            });\n          }\n        }\n      }\n      for (var ptr = lowPtr; ptr <= highPtr; ptr++) {\n        processcomponentFn(cradleModelComponents[ptr], ptr, cradleModelComponents);\n      }\n    }\n    // supports insertRemoveIndex\n  }, {\n    key: "createNewItemIDs",\n    value: function createNewItemIDs(newList) {\n      if (!newList.length) return;\n      var cacheAPI = this.cradleParameters.handlersRef.current.cacheAPI;\n      var cradleModelComponents = this.content.cradleModelComponents;\n      var cradleContentProps = this.cradleParameters.cradleInheritedPropertiesRef.current.cradleContentProps;\n      // const indexSpan = this.indexSpan\n      // if (indexSpan.length == 0) return // defensive\n      // const [lowSpan, highSpan] = indexSpan\n      if (cradleContentProps.size == 0) return;\n      var lowSpan = cradleContentProps.lowindex,\n        highSpan = cradleContentProps.highindex;\n      function processcomponentFn(newlistindex) {\n        if (newlistindex < lowSpan || newlistindex > highSpan) return; // defensive\n        var cradlePtr = newlistindex - lowSpan;\n        var component = cradleModelComponents[cradlePtr];\n        var newItemID = cacheAPI.getNewItemID();\n        cradleModelComponents[cradlePtr] = react_1["default"].cloneElement(component, {\n          itemID: newItemID\n        });\n      }\n      // cradleModelComponents.forEach(processcomponentFn)\n      newList.forEach(processcomponentFn);\n    }\n  }]);\n  return ContentHandler;\n}();\nexports["default"] = ContentHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFlBQVk7UUFFcEMsSUFBSUEsWUFBWSxHQUFHbkIsT0FBTyxJQUFJbUIsWUFBWSxHQUFHbEIsUUFBUSxFQUFFLE9BQU0sQ0FBQztRQUU5RCxJQUFNbUIsU0FBUyxHQUFHRCxZQUFZLEdBQUduQixPQUFPO1FBRXhDLElBQU1kLFNBQVMsR0FBR3JOLHFCQUFxQixDQUFDdVAsU0FBUyxDQUFDO1FBRWxELElBQU05QixTQUFTLEdBQUdqTSxRQUFRLENBQUNvTSxZQUFZLEVBQUU7UUFFekM1TixxQkFBcUIsQ0FBQ3VQLFNBQVMsQ0FBQyxHQUFHaFEsT0FBQSxXQUFLLENBQUNpRyxZQUFZLENBQUM2SCxTQUFTLEVBQUU7VUFBQ0csTUFBTSxFQUFDQztRQUFTLENBQUMsQ0FBQztNQUV4RjtNQUVBO01BRUE0QixPQUFPLENBQUN4QixPQUFPLENBQUNlLGtCQUFrQixDQUFDO0lBRXZDO0VBQUM7RUFBQSxPQUFBaFAsY0FBQTtBQUFBO0FBdndDTDRQLGtCQUFBLEdBQUE1UCxjQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvY29udGVudGhhbmRsZXIudHN4P2E4OWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29udGVudGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHN1cHBvcnRzIHRoZSBzZXR1cCwgcm9sbG92ZXIgYW5kIHBvc2l0aW9uaW5nIG9mIGNvbnRlbnQgaW4gdGhlIENyYWRsZS4gXG5cbiAgICBUaGVyZSBhcmUgdGhyZWUga2V5IGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZTogc2V0Q3JhZGxlQ29udGVudCwgdXBkYXRlQ3JhZGxlQ29udGVudCwgYW5kXG4gICAgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eS5cblxuICAgIFRoZXJlIGFyZSBhbHNvIGEgZmV3IGZ1bmN0aW9ucyB3aGljaCBzdXBwb3J0IHN5bmNocm9uaXphdGlvbiBvZiBDcmFkbGUgY29udGVudCB3aXRoIGNhY2hlIFxuICAgIGNvbnRlbnQgKHNlZSBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgc2VydmljZXMgYmVsb3cpLlxuXG4gICAgc2V0Q3JhZGxlQ29udGVudCBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSBDcmFkbGUgKGluIHRoZSBzdGF0ZSBtYW5hZ2VyKSwgYW5kIGluc3RhbnRpYXRlcyBuZXcgQ3JhZGxlXG4gICAgY29udGVudCBpbiByZXNwb25zZSB0byB0aGUgc2Nyb2xsZXIgc2V0dXAsIG9yIGNoYW5nZXMgdG8gaXRzIGNvbmZpZ3VyYXRpb24uIHNldENyYWRsZUNvbnRlbnRcbiAgICBjcmVhdGVzIGEgbGlzdCBvZiBDcmFkbGUgY29udGVudCBDZWxsRnJhbWVzLCBhbmQgYWxsb2NhdGVzIHRob3NlIHRvIHRoZSB0d28gQ3JhZGxlIGdyaWRzLiBUaGlzIFxuICAgIHByb2Nlc3Mgb2NjdXJzIGluIHJlc3BvbnNlIHRvIG1hbnkgc3RhdGUgY2hhbmdlcywgc3VjaCBhcyBmaW5pc2hyZXBvc2l0aW9uLCBwaXZvdCwgYSBob3N0IHNjcm9sbHRvXG4gICAgcmVxdWVzdCwgYW5kIG1vcmUuXG5cbiAgICB1cGRhdGVDcmFkbGVDb250ZW50IHJvbGxzIG92ZXIgdGhlIENyYWRsZSBjb250ZW50IGluIHJlc3BvbnNlIHRvIHVzZXIgc2Nyb2xsaW5nLiBXaGVuIHNjcm9sbGluZyBcbiAgICBkb3duIChvciByaWdodCksIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBDcmFkbGUgdGFpbCBhbmQgYWRkZWQgdG8gdGhlIENyYWRsZSBoZWFkICh0aHVzIG1vdmluZyB0aGUgXG4gICAgQ3JhZGxlIGF4aXMpLCB3aGlsZSBuZXcgY29udGVudCBpcyBhZGRlZCB0byB0aGUgdGFpbC4gV2hlbiBzY3JvbGxpbmcgdXAgKG9yIGxlZnQpLCB0aGUgcmV2ZXJzZSBvY2N1cnMuXG5cbiAgICBhZGp1c3RTY3JvbGxibG9ja0ZvclZhcmlhYmlsaXR5IHJlY29uZmlndXJlcyB0aGUgc2Nyb2xsYmxvY2sgdG8gYWNjb21tb2RhdGUgdmFyaWFibGUgc2l6ZWQgZ3JpZCByb3dzLlxuXG4gICAgVGhlIENyYWRsZSAodGhyb3VnaCB0aGUgY29udGVudGZ1bmN0aW9ucyBtb2R1bGUpIGRlbGVnYXRlcyBmZXRjaGluZyBjb250ZW50IGl0ZW1zIHRvIHRoZSBDZWxsRnJhbWUuXG5cbiAgICBUaGlzIG1vZHVsZSBpcyBzdXBwb3J0ZWQgcHJpbWFyaWx5IGJ5IHRoZSBjb250ZW50ZnVuY3Rpb25zIG1vZHVsZS5cblxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBcbiAgICBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50cyxcbiAgICBjYWxjdWxhdGVTaGlmdFNwZWNzLFxuICAgIGFsbG9jYXRlQ29udGVudExpc3QsXG4gICAgZGVsZXRlUG9ydGFscyxcbiAgICBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0LCBcblxufSBmcm9tICcuL2NvbnRlbnRmdW5jdGlvbnMnXG5cbmltcG9ydCB7IGlzU2FmYXJpSU9TIH0gZnJvbSAnLi4vSW5maW5pdGVHcmlkU2Nyb2xsZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRIYW5kbGVyIHtcblxuICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMgPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgIH1cblxuICAgcHVibGljIGNvbnRlbnQgPSB7XG5cbiAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50czogbnVsbCxcbiAgICAgIGhlYWRNb2RlbENvbXBvbmVudHM6IG51bGwsXG4gICAgICB0YWlsTW9kZWxDb21wb25lbnRzOiBudWxsLFxuICAgICAgLy8gdGhlIGZvbGxvd2luZyB0d28gb25seSB1c2VkIGluIGNyYWRsZSBmb3IgcmVuZGVyXG4gICAgICBoZWFkRGlzcGxheUNvbXBvbmVudHM6IFtdLFxuICAgICAgdGFpbERpc3BsYXlDb21wb25lbnRzOiBbXSxcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHJpdmF0ZSBpbnN0YW5jZUlkQ291bnRlclJlZiA9IHtcblxuICAgICAgIGN1cnJlbnQ6MFxuXG4gICAgfVxuICAgIC8vIFRocmVlIG1haW4gcHVibGljIG1ldGhvZHMgLSBzZXRDcmFkbGVDb250ZW50LCB1cGRhdGVDcmFkbGVDb250ZW50LCBhbmQgYWRqdXN0U2Nyb2xsYmxvY2tGb3JWYXJpYWJpbGl0eVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFVCBDT05URU5UIF09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHJlc2V0IHRoZSBjcmFkbGUgd2l0aCBuZXcgY29udGVudCwgaW5jbHVkaW5nIGFsbG9jYXRpb24gYmV0d2VlbiBoZWFkIGFuZCB0YWlsIHBhcnRzIG9mIHRoZSBjcmFkbGVcbiAgICAvLyAtIGNhbGxlZCBvbmx5IGZyb20gdGhlIENyYWRsZSBzdGF0ZSBoYW5kbGVyXG4gICAgcHVibGljIHVwZGF0ZVZpcnR1YWxMaXN0U3BlY3MgPSAobmV3bGlzdHNpemUpID0+IHtcblxuICAgICAgICBpZiAobmV3bGlzdHNpemUgPT0gMCkge1xuXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVDb250ZW50ID0gdGhpcy5jb250ZW50ICAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5jbGVhckNyYWRsZSgpXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50LmhlYWREaXNwbGF5Q29tcG9uZW50cyA9IFtdXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxEaXNwbGF5Q29tcG9uZW50cyA9IFtdXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC5zZXRWaXJ0dWFsTGlzdFNwZWNzKG5ld2xpc3RzaXplKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldENyYWRsZUNvbnRlbnQgPSAoIGNyYWRsZVN0YXRlICkgPT4geyAvLyBjcmFkbGVTdGF0ZSBpbmZsdWVuY2VzIHNvbWUgYmVoYXZpb3VyXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAxLiBpbml0aWFsaXplIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXNcblxuICAgICAgICBjb25zdFxuXG4gICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVIYW5kbGVycyA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFxuXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBjYWNoZUFQSSxcbiAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgIHNjcm9sbEhhbmRsZXIsXG5cbiAgICAgICAgICAgIH0gPSBjcmFkbGVIYW5kbGVycyxcblxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YSBcblxuICAgICAgICAgICAgfSA9IGxheW91dEhhbmRsZXIsXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbjpyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlUG9zaXRpb25cblxuICAgICAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YSxcblxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgICAgIGdhcCwgXG4gICAgICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCwgLy8gZGVidWdcblxuICAgICAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIHsgXG5cbiAgICAgICAgICAgICAgICB2aXJ0dWFsTGlzdFByb3BzLCBcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMsXG5cbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIGxvd2luZGV4Omxpc3Rsb3dpbmRleCwgXG4gICAgICAgICAgICAgICAgLy8gaGlnaGluZGV4Omxpc3RoaWdoaW5kZXgsIFxuICAgICAgICAgICAgICAgIHNpemU6bGlzdHNpemUsIFxuICAgICAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgICAgIHJvd2NvdW50Omxpc3RSb3djb3VudCxcbiAgICAgICAgICAgICAgICBiYXNlcm93YmxhbmtzLFxuICAgICAgICAgICAgICAgIC8vIGVuZHJvd2JsYW5rcyxcblxuICAgICAgICAgICAgfSA9IHZpcnR1YWxMaXN0UHJvcHNcblxuICAgICAgICBzY3JvbGxlcklEID09IDEgJiYgY29uc29sZS5sb2coJ3NldENyYWRsZUNvbnRlbnQ6IG9wZW5pbmcgY3JhZGxlUG9zaXRpb25EYXRhJywgey4uLmNyYWRsZVBvc2l0aW9uRGF0YX0pXG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGxldCB7IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IH0gPSAgY3JhZGxlUG9zaXRpb25EYXRhXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgMi4gbm9ybWFsaXplIGRhdGEgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gaW4gYm91bmRzXG4gICAgICAgIGxldCB3b3JraW5nQXhpc1JlZmVyZW5jZVBvc2l0aW9uID0gTWF0aC5taW4ocmVxdWVzdGVkQXhpc1JlZmVyZW5jZVBvc2l0aW9uLGxpc3RzaXplIC0gMSlcbiAgICAgICAgLy8gc2hpZnRlZCBieSB2aXJ0dWFsIGxpc3QgbG93IHJhbmdlXG4gICAgICAgIGxldCB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ICA9IHdvcmtpbmdBeGlzUmVmZXJlbmNlUG9zaXRpb24gKyBsaXN0bG93aW5kZXhcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmlyc3QgY2FsYzogd29ya2luZ0F4aXNSZWZlcmVuY2VJbmRleCwgd29ya2luZ0F4aXNSZWZlcmVuY2VQb3NpdGlvbiwgbGlzdGxvd2luZGV4LCB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudCwgY3Jvc3Njb3VudFxcbicsIFxuICAgICAgICAvLyAgICAgd29ya2luZ0F4aXNSZWZlcmVuY2VJbmRleCwgd29ya2luZ0F4aXNSZWZlcmVuY2VQb3NpdGlvbiwgbGlzdGxvd2luZGV4LCB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudCwgY3Jvc3Njb3VudClcblxuICAgICAgICAvLyBjYWxjdWxhdGUgYXhpcyByZWZlcmVuY2UgYmFzZSBpbmRleFxuICAgICAgICB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4IC09XG4gICAgICAgICAgICB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4IDwgMD8gXG4gICAgICAgICAgICAgICAgKHdvcmtpbmdBeGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50KT9cbiAgICAgICAgICAgICAgICAgICAgKGNyb3NzY291bnQgLSBNYXRoLmFicyh3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ICUgY3Jvc3Njb3VudCkpOlxuICAgICAgICAgICAgICAgICAgICAwOlxuICAgICAgICAgICAgICAgIHdvcmtpbmdBeGlzUmVmZXJlbmNlSW5kZXggJSBjcm9zc2NvdW50XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NlY29uZCBjYWxjOiB3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4LCBjcm9zc2NvdW50JyxcbiAgICAgICAgLy8gICAgIHdvcmtpbmdBeGlzUmVmZXJlbmNlSW5kZXgsIGNyb3NzY291bnQpXG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBhdCByb3cgYm91bmRhcnlcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdmaXJzdHJlbmRlcicsIFxuICAgICAgICAgICAgJ2ZpcnN0cmVuZGVyZnJvbWNhY2hlJyxcbiAgICAgICAgICAgICdmaW5pc2hyZXBvc2l0aW9uJywgXG4gICAgICAgICAgICAncmVjb25maWd1cmUnLCBcbiAgICAgICAgICAgICdzY3JvbGx0bycsIFxuICAgICAgICBdLmluY2x1ZGVzKGNyYWRsZVN0YXRlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IFxuICAgICAgICAgICAgICAgICh3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4ID09IDApP1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOlxuICAgICAgICAgICAgICAgICAgICBnYXAgLy8gZGVmYXVsdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3b3JraW5nQ29udGVudExpc3QgPSBbXVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDMuIGdldCBjb250ZW50IHJlcXVpcmVtZW50cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IGJhc2VSb3dQaXhlbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aClcbiAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgLy8gbm90ZSB0aGF0IHRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbiByZXBsYWNlcyByZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlSW5kZXggaGVyZVxuICAgICAgICBjb25zdCB7XG5cbiAgICAgICAgICAgIC8vIGJ5IGluZGV4XG4gICAgICAgICAgICB0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCwgXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgICAgIC8vIGNvdW50c1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50OmNyYWRsZUNvbnRlbnRDb3VudCwgXG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBzY3JvbGxQb3MgYnkgcGl4ZWxzXG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQ6c2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LFxuXG4gICAgICAgIH0gPSBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50cyh7XG5cbiAgICAgICAgICAgICAgICAvLyBwaXhlbFxuICAgICAgICAgICAgICAgIGJhc2VSb3dQaXhlbExlbmd0aCxcbiAgICAgICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCxcblxuICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4OndvcmtpbmdBeGlzUmVmZXJlbmNlSW5kZXgsXG5cbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyxcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJvbSBjYWxjdWxhdGVDb250ZW50TGlzdFJlcXVpcmVtZW50czogdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsIHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCwgc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0XFxuJyxcbiAgICAgICAgLy8gICAgIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4LCB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldClcblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IC8vIHNlbWFudGljc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDQuIGdldCBhbmQgY29uZmlnIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50OiBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0IGFyZ3MgLSBjcmFkbGVDb250ZW50Q291bnQsIHRhcmdldENyYWRsZVJlZmVyZW5jZUluZGV4JyxcbiAgICAgICAgLy8gICAgIGNyYWRsZUNvbnRlbnRDb3VudCwgdGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgpXG5cbiAgICAgICAgLy8gcmV0dXJucyBjb250ZW50IGNvbnN0cmFpbmVkIGJ5IGNyYWRsZVJvd2NvdW50XG4gICAgICAgIGNvbnN0IFtuZXdjb250ZW50bGlzdF0gPSBnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0KHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FjaGVBUEksICAgICAgICAgICAgXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSW5kZXg6dGFyZ2V0Q3JhZGxlUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudDowLFxuICAgICAgICAgICAgbGlzdEVuZENoYW5nZUNvdW50OmNyYWRsZUNvbnRlbnRDb3VudCxcbiAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdCxcbiAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdXBkYXRlIGNyYWRsZUNvbnRlbnRQcm9wcyBmcm9tIG5ld2NvbnRlbnRsaXNlXG4gICAgICAgIGNyYWRsZUNvbnRlbnRQcm9wcy5zaXplID0gbmV3Y29udGVudGxpc3QubGVuZ3RoXG4gICAgICAgIGlmIChjcmFkbGVDb250ZW50UHJvcHMuc2l6ZSkge1xuXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMubG93aW5kZXggPSBuZXdjb250ZW50bGlzdFswXS5wcm9wcy5pbmRleFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLmhpZ2hpbmRleCA9IGNyYWRsZUNvbnRlbnRQcm9wcy5sb3dpbmRleCArIGNyYWRsZUNvbnRlbnRQcm9wcy5zaXplIC0gMVxuICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLlNPTCA9ICh2aXJ0dWFsTGlzdFByb3BzLmxvd2luZGV4ID09IGNyYWRsZUNvbnRlbnRQcm9wcy5sb3dpbmRleClcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRQcm9wcy5FT0wgPSAodmlydHVhbExpc3RQcm9wcy5oaWdoaW5kZXggPT0gY3JhZGxlQ29udGVudFByb3BzLmhpZ2hpbmRleClcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMubG93aW5kZXggPSBudWxsXG4gICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMuaGlnaGluZGV4ID0gbnVsbFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLlNPTCA9IHRydWUgLy8gVE9ETyBoYXJtb25pemUgYWNyb3NzIGFwcFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLkVPTCA9IHRydWVcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldENyYWRsZUNvbnRlbnQ6IHZpcnR1YWxMaXN0UHJvcHMsIGNyYWRsZUNvbnRlbnRQcm9wcycsdmlydHVhbExpc3RQcm9wcywgY3JhZGxlQ29udGVudFByb3BzKVxuXG4gICAgICAgIC8vIHNldCBvciBjYW5jZWwgZmlyc3Qgcm93IG9mZnNldCBpZiB3aXRoaW4gY3JhZGxlXG4gICAgICAgIGxldCBncmlkc3RhcnRcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndmlydHVhbExpc3RQcm9wcywgY3JhZGxlQ29udGVudFByb3BzLCBuZXdjb250ZW50bGlzdCcsXG4gICAgICAgIC8vICAgICB2aXJ0dWFsTGlzdFByb3BzLCBjcmFkbGVDb250ZW50UHJvcHMsIG5ld2NvbnRlbnRsaXN0KVxuXG4gICAgICAgIGlmIChjcmFkbGVDb250ZW50UHJvcHMuU09MICYmIHZpcnR1YWxMaXN0UHJvcHMuYmFzZXJvd2JsYW5rcykge1xuICAgICAgICAgICAgZ3JpZHN0YXJ0ID0gYCR7dmlydHVhbExpc3RQcm9wcy5iYXNlcm93YmxhbmtzICsgMX1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkc3RhcnQgPSAndW5zZXQnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdGNvbXBvbmVudCA9IG5ld2NvbnRlbnRsaXN0WzBdXG5cbiAgICAgICAgaWYgKCFmaXJzdGNvbXBvbmVudCkgcmV0dXJuIC8vIHBvc3NpYmxlIGNoaWxkIGRpc21vdW50cyB3aXRoIG5lc3RlZCBzY3JvbGxlcnNcblxuICAgICAgICBsZXQgZ3JpZHN0YXJ0c3R5bGVcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGdyaWRzdGFydHN0eWxlID0ge2dyaWRDb2x1bW5TdGFydDpncmlkc3RhcnR9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkc3RhcnRzdHlsZSA9IHtncmlkUm93U3RhcnQ6Z3JpZHN0YXJ0fVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldmlzZWRjb21wb25lbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoZmlyc3Rjb21wb25lbnQse2dyaWRzdGFydHN0eWxlfSlcbiAgICAgICAgbmV3Y29udGVudGxpc3RbMF0gPSByZXZpc2VkY29tcG9uZW50XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dyaWRzdGFydHN0eWxlLHJldmlzZWRjb21wb25lbnQnLGdyaWRzdGFydHN0eWxlLHJldmlzZWRjb21wb25lbnQpXG5cbiAgICAgICAgY29uc3QgW2hlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0XSA9IGFsbG9jYXRlQ29udGVudExpc3Qoe1xuXG4gICAgICAgICAgICBjb250ZW50bGlzdDpuZXdjb250ZW50bGlzdCxcbiAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleDp0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgLy8gbGlzdGxvd2luZGV4LFxuICAgIFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgdGFyZ2V0QXhpc1JlZmVyZW5jZUluZGV4LCBoZWFkY29udGVudGxpc3QsIHRhaWxjb250ZW50bGlzdCcsXG4gICAgICAgIC8vICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgsIGhlYWRjb250ZW50bGlzdCwgdGFpbGNvbnRlbnRsaXN0KVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgY3JhZGxlQ29udGVudFByb3BzJyxjcmFkbGVDb250ZW50UHJvcHMpXG5cbiAgICAgICAgY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgPSBuZXdjb250ZW50bGlzdFxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBoZWFkY29udGVudGxpc3RcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gdGFpbGNvbnRlbnRsaXN0XG5cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbiA9IHRhcmdldEF4aXNSZWZlcmVuY2VJbmRleCAtIGxpc3Rsb3dpbmRleFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuXG4gICAgICAgIHNjcm9sbGVySUQgPT0gMSAmJiBjb25zb2xlLmxvZygnc2V0Q3JhZGxlQ29udGVudDogY2xvc2luZyBjcmFkbGVQb3NpdGlvbkRhdGEnLCB7Li4uY3JhZGxlUG9zaXRpb25EYXRhfSlcblxuICAgICAgICBpZiAoc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2spIHtcblxuICAgICAgICAgICAgY29uc3QgY3N0YXRlID0gY3JhZGxlU3RhdGVcblxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzLnJlZmVyZW5jZUluZGV4Q2FsbGJhY2soXG5cbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uLCdzZXRDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyA1LiBzZXQgQ1NTIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIHJlc2V0IHNjcm9sbGJsb2NrIE9mZnNldCBhbmQgbGVuZ3RoXG4gICAgICAgIGNvbnN0IHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgYmxvY2tiYXNlbGVuZ3RoID0gKGxpc3RSb3djb3VudCAqIGJhc2VSb3dQaXhlbExlbmd0aCkgLSBnYXAgLy8gZmluYWwgY2VsbCBoYXMgbm8gdHJhaWxpbmcgZ2FwXG4gICAgICAgICAgICArIChwYWRkaW5nICogMikgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgcGFkZGluZ1xuXG4gICAgICAgIGlmIChjcmFkbGVTdGF0ZSA9PSAncGl2b3QnKSB7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IG51bGxcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBibG9ja2Jhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSBudWxsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUud2lkdGggPSBibG9ja2Jhc2VsZW5ndGggKyAncHgnXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCBcbiAgICAgICAgLy8gYXZvaWQgYm9ndXMgY2FsbCB0byB1cGRhdGVDcmFkbGVDb250ZW50XG5cbiAgICAgICAgc2Nyb2xsZXJJRCA9PSAxICYmIGNvbnNvbGUubG9nKCdzZXRDcmFkbGVDb250ZW50LnJlc2V0U2Nyb2xsRGF0YTogc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0XFxuJywgXG4gICAgICAgICAgICBzY3JvbGxibG9ja1ZpZXdwb3J0UGl4ZWxPZmZzZXQpXG5cbiAgICAgICAgc2Nyb2xsSGFuZGxlci5yZXNldFNjcm9sbERhdGEoc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0KSBcblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnRbY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrU2Nyb2xsUHJvcGVydHldID1cbiAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyBcblxuICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IGxheW91dEhhbmRsZXIuZWxlbWVudHNcblxuICAgICAgICBjb25zdCBheGlzRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLmF4aXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGhlYWRFbGVtZW50ID0gY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Jsb2NrYmFzZWxlbmd0aCwgYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQsIHNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCwgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQnLFxuICAgICAgICAvLyAgICAgYmxvY2tiYXNlbGVuZ3RoLCBheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCwgc2Nyb2xsYmxvY2tWaWV3cG9ydFBpeGVsT2Zmc2V0LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldClcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBheGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCBcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnRsaXN0Lmxlbmd0aD9cbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4YDpcbiAgICAgICAgICAgICAgICAgICAgYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weGBcblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUudG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcblxuICAgICAgICAgICAgaGVhZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFxuICAgICAgICAgICAgICAgIGhlYWRjb250ZW50bGlzdC5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09WyBVUERBVEUgQ09OVEVOVCB0aHJvdWdoIHNjcm9sbCBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyB1cGRhdGVDcmFkbGVDb250ZW50IGRvZXMgbm90IHRvdWNoIHRoZSB2aWV3cG9ydCBlbGVtZW50J3Mgc2Nyb2xsIHBvc2l0aW9uIGZvciB0aGUgc2Nyb2xsYmxvY2tcbiAgICAvLyBpbnN0ZWFkIGl0IHJlY29uZmlndXJlcyBlbGVtZW50cyB3aXRoaW4gdGhlIGNyYWRsZS4gSXQgaXMgY2FsbGVkIHNvbGVseSBmcm9tXG4gICAgLy8gYXhpc1RyaWdnZXJsaW5lc09ic2VydmVyQ2FsbGJhY2sgb2YgaW50ZXJydXB0SGFuZGxlci5cbiAgICAvLyB0eXBpY2FsbHkgY2FsbGVkIGZvciBzY3JvbGwgYWN0aW9uLCBidXQgY2FuIGFsc28gYmUgY2FsbGVkIGlmIHRoZSB0cmlnZ2VyTGluZUNlbGwgY2hhbmdlc1xuICAgIC8vIHNpemUgd2l0aCB2YXJpYW50IGxheW91dC5cblxuICAgIHB1YmxpYyB1cGRhdGVDcmFkbGVDb250ZW50ID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdydW5uaW5nIHVwZGF0ZUNyYWRsZUNvbnRlbnQnKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIDEuIGluaXRpYWxpemUgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmFkbGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6Y3JhZGxlQ29udGVudCxcblxuICAgICAgICAgICAgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCBcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGNyYWRsZUludGVybmFsUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVIYW5kbGVycyA9IGNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVBUEksIFxuICAgICAgICAgICAgICAgIGxheW91dEhhbmRsZXIsIFxuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlciwgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0SGFuZGxlcixcbiAgICAgICAgICAgICAgICBzZXJ2aWNlSGFuZGxlcixcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gPSBjcmFkbGVIYW5kbGVycyxcblxuICAgICAgICAgICAgeyBcblxuICAgICAgICAgICAgICAgIHNoaWZ0aW5zdHJ1Y3Rpb24sIFxuICAgICAgICAgICAgICAgIHRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zIC8vIHRyaWdnZXIgQ2VsbEZyYW1lXG5cbiAgICAgICAgICAgIH0gPSBpbnRlcnJ1cHRIYW5kbGVyLFxuXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGNyYWRsZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YVxuXG4gICAgICAgICAgICB9ID0gbGF5b3V0SGFuZGxlcixcbiAgICAgICAgXG4gICAgICAgICAgICB7IFxuXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24sIFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIHN0eWxlcyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGxheW91dCwgXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgICAgICBwYWRkaW5nLCBcbiAgICAgICAgICAgICAgICBnYXAsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJJRCwgLy8gZGVidWdcblxuICAgICAgICAgICAgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHZpcnR1YWxMaXN0UHJvcHMsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLFxuXG4gICAgICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuXG4gICAgICAgICAgICB7IFxuXG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCxcbiAgICAgICAgICAgICAgICBsb3dpbmRleDpsaXN0bG93aW5kZXgsXG5cbiAgICAgICAgICAgIH0gPSB2aXJ0dWFsTGlzdFByb3BzXG5cbiAgICAgICAgLy8gaWYgKGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQpIHJldHVyblxuXG4gICAgICAgIC8vIG5ldyB2YXJzXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvcyA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICBjb25zdCBtb2RlbGNvbnRlbnRsaXN0ID0gY3JhZGxlQ29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMgfHwgW11cblxuICAgICAgICBjb25zdCBwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4ID0gKG1vZGVsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09Pj4gc2hpZnQgaW5zdHJ1Y3Rpb24nLCBzaGlmdGluc3RydWN0aW9uKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyAzLiBDYWxjdWxhdGUgc2hpZnRzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY3JhZGxlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qge1xuXG4gICAgICAgICAgICAvLyBieSBpbmRleFxuICAgICAgICAgICAgY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0OiBjcmFkbGVJdGVtU2hpZnQsIFxuICAgICAgICAgICAgbmV3QXhpc1JlZmVyZW5jZUluZGV4OiBheGlzUmVmZXJlbmNlSW5kZXgsIFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdDogYXhpc0l0ZW1TaGlmdCwgXG5cbiAgICAgICAgICAgIC8vIGNvdW50c1xuICAgICAgICAgICAgbmV3Q3JhZGxlQ29udGVudENvdW50OiBjcmFkbGVDb250ZW50Q291bnQsXG4gICAgICAgICAgICBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCxcblxuICAgICAgICAgICAgLy8gcGl4ZWxzXG4gICAgICAgICAgICBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCwgXG5cbiAgICAgICAgfSA9IGNhbGN1bGF0ZVNoaWZ0U3BlY3Moe1xuXG4gICAgICAgICAgICBzaGlmdGluc3RydWN0aW9uLFxuICAgICAgICAgICAgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUGl4ZWxQb3MsXG4gICAgICAgICAgICBzY3JvbGxQb3MsXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQ6IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkLFxuXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLFxuICAgICAgICAgICAgdmlydHVhbExpc3RQcm9wcyxcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnQsXG4gICAgICAgICAgICBjcmFkbGVFbGVtZW50cyxcblxuICAgICAgICB9KVxuXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFxuLy8gYFxuLy8gY3JhZGxlUmVmZXJlbmNlSXRlbVNoaWZ0OiBjcmFkbGVJdGVtU2hpZnQsIFxuLy8gbmV3QXhpc1JlZmVyZW5jZUluZGV4OiBheGlzUmVmZXJlbmNlSW5kZXgsIFxuLy8gYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdDogYXhpc0l0ZW1TaGlmdCwgXG5cbi8vIC8vIGNvdW50c1xuLy8gbmV3Q3JhZGxlQ29udGVudENvdW50OiBjcmFkbGVDb250ZW50Q291bnQsXG4vLyBsaXN0U3RhcnRDaGFuZ2VDb3VudCxcbi8vIGxpc3RFbmRDaGFuZ2VDb3VudCxcblxuLy8gLy8gcGl4ZWxzXG4vLyBuZXdBeGlzVmlld3BvcnRQaXhlbE9mZnNldCwgXG4vLyBgLFxuLy8gY3JhZGxlSXRlbVNoaWZ0LCBcbi8vIGF4aXNSZWZlcmVuY2VJbmRleCwgXG4vLyBheGlzSXRlbVNoaWZ0LCdcXG4nLCBcbi8vIGNyYWRsZUNvbnRlbnRDb3VudCxcbi8vIGxpc3RTdGFydENoYW5nZUNvdW50LFxuLy8gbGlzdEVuZENoYW5nZUNvdW50LCdcXG4nLFxuLy8gbmV3QXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbi8vIClcblxuICAgICAgICBjb25zdCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IG5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgY29uc3QgaXNTaGlmdCA9ICEoKGF4aXNJdGVtU2hpZnQgPT0gMCkgJiYgKGNyYWRsZUl0ZW1TaGlmdCA9PSAwKSlcbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgaGVhZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyB0aGUgdHJpZ2dlcmxpbmVzIHdpbGwgYmUgbW92ZWQsIHNvIGRpc2Nvbm5lY3QgdGhlbSBmcm9tIHRoZWlyIG9ic2VydmVyLlxuICAgICAgICAvLyB0aGV5IGFyZSByZWNvbm5lY3RlZCB3aXRoICdyZW5kZXJ1cGRhdGVkY29udGVudCcgc3RhdGUgaW4gY3JhZGxlLnRzeCwgb3IgYXQgJ2ZpbmlzaHVwZGF0ZWZvcnZhcmlhYmlsaXR5J1xuICAgICAgICAvLyAgICBmb3IgdmFyaWFibGUgY29udGVudFxuICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5kaXNjb25uZWN0KClcblxuICAgICAgICAvLyBhYmFuZG9uIG9wdGlvbjsgbm90aGluZyB0byBkbyBidXQgcmVwb3NpdGlvblxuICAgICAgICBpZiAoIWlzU2hpZnQpIHsgLy8gY2FuIGhhcHBlbiBmaXJzdCByb3c7IG92ZXJzaXplZCBsYXN0IHJvd1xuICAgIFxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsaW5nKHtcbiAgICAgICAgICAgICAgICBsYXlvdXQsIG9yaWVudGF0aW9uLCBwYWRkaW5nLCBnYXAsIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgXG4gICAgICAgICAgICAgICAgY3Jvc3Njb3VudCwgXG4gICAgICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgc2Nyb2xsUG9zLCBcbiAgICAgICAgICAgICAgICBoZWFkY29udGVudDpjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgYXhpc0VsZW1lbnQsIGhlYWRFbGVtZW50LCBsaXN0bG93aW5kZXgsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNC4gcmVjb25maWd1cmUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY29sbGVjdCBjaGFuZ2VkIGNvbnRlbnRcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50TGlzdCwgZGVsZXRlZENvbnRlbnRJdGVtcyA9IFtdXG5cbiAgICAgICAgaWYgKGxpc3RTdGFydENoYW5nZUNvdW50IHx8IGxpc3RFbmRDaGFuZ2VDb3VudCkgeyAvLyBpZiBlaXRoZXIgaXMgbm9uLTAgdGhlbiBtb2RpZnkgY29udGVudFxuXG4gICAgICAgICAgICBbIHVwZGF0ZWRDb250ZW50TGlzdCwgZGVsZXRlZENvbnRlbnRJdGVtcyBdID0gZ2V0Q2VsbEZyYW1lQ29tcG9uZW50TGlzdCh7XG4gICAgICAgICAgICAgICAgY2FjaGVBUEksXG4gICAgICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudENvdW50LFxuICAgICAgICAgICAgICAgIHdvcmtpbmdDb250ZW50TGlzdDptb2RlbGNvbnRlbnRsaXN0LFxuICAgICAgICAgICAgICAgIGxpc3RTdGFydENoYW5nZUNvdW50LFxuICAgICAgICAgICAgICAgIGxpc3RFbmRDaGFuZ2VDb3VudCxcbiAgICAgICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VJbmRleDpwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlSWRDb3VudGVyUmVmOnRoaXMuaW5zdGFuY2VJZENvdW50ZXJSZWYsXG4gICAgICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlZENvbnRlbnRMaXN0LCBkZWxldGVkQ29udGVudEl0ZW1zJyx1cGRhdGVkQ29udGVudExpc3QsIGRlbGV0ZWRDb250ZW50SXRlbXMpXG5cbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRQcm9wcy5zaXplID0gdXBkYXRlZENvbnRlbnRMaXN0Lmxlbmd0aFxuICAgICAgICAgICAgaWYgKGNyYWRsZUNvbnRlbnRQcm9wcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMubG93aW5kZXggPSB1cGRhdGVkQ29udGVudExpc3RbMF0ucHJvcHMuaW5kZXhcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMuaGlnaGluZGV4ID0gY3JhZGxlQ29udGVudFByb3BzLmxvd2luZGV4ICsgY3JhZGxlQ29udGVudFByb3BzLnNpemUgLSAxXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLlNPTCA9ICh2aXJ0dWFsTGlzdFByb3BzLmxvd2luZGV4ID09IGNyYWRsZUNvbnRlbnRQcm9wcy5sb3dpbmRleClcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMuRU9MID0gKHZpcnR1YWxMaXN0UHJvcHMuaGlnaGluZGV4ID09IGNyYWRsZUNvbnRlbnRQcm9wcy5oaWdoaW5kZXgpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMubG93aW5kZXggPSBudWxsXG4gICAgICAgICAgICAgICAgY3JhZGxlQ29udGVudFByb3BzLmhpZ2hpbmRleCA9IG51bGxcbiAgICAgICAgICAgICAgICBjcmFkbGVDb250ZW50UHJvcHMuU09MID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRQcm9wcy5FT0wgPSB0cnVlXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdyaWRzdGFydFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZpcnR1YWxMaXN0UHJvcHMsIGNyYWRsZUNvbnRlbnRQcm9wcywgbmV3Y29udGVudGxpc3QnLHZpcnR1YWxMaXN0UHJvcHMsIGNyYWRsZUNvbnRlbnRQcm9wcywgbmV3Y29udGVudGxpc3QpXG4gICAgICAgICAgICBpZiAoY3JhZGxlQ29udGVudFByb3BzLlNPTCAmJiB2aXJ0dWFsTGlzdFByb3BzLmJhc2Vyb3dibGFua3MpIHtcbiAgICAgICAgICAgICAgICBncmlkc3RhcnQgPSBgJHt2aXJ0dWFsTGlzdFByb3BzLmJhc2Vyb3dibGFua3MgKyAxfWBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZHN0YXJ0ID0gJ3Vuc2V0J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmaXJzdGNvbXBvbmVudCA9IHVwZGF0ZWRDb250ZW50TGlzdFswXVxuXG4gICAgICAgICAgICBsZXQgZ3JpZHN0YXJ0c3R5bGVcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgZ3JpZHN0YXJ0c3R5bGUgPSB7Z3JpZENvbHVtblN0YXJ0OmdyaWRzdGFydH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZHN0YXJ0c3R5bGUgPSB7Z3JpZFJvd1N0YXJ0OmdyaWRzdGFydH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldmlzZWRjb21wb25lbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoZmlyc3Rjb21wb25lbnQse2dyaWRzdGFydHN0eWxlfSlcbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50TGlzdFswXSA9IHJldmlzZWRjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdncmlkc3RhcnRzdHlsZSxyZXZpc2VkY29tcG9uZW50Jyxncmlkc3RhcnRzdHlsZSxyZXZpc2VkY29tcG9uZW50KVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFIGNyYWRsZUNvbnRlbnRQcm9wcycsY3JhZGxlQ29udGVudFByb3BzKVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50TGlzdCA9IG1vZGVsY29udGVudGxpc3RcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGV0ZWRDb250ZW50SXRlbXMubGVuZ3RoICYmIChjYWNoZSA9PSAnY3JhZGxlJykpIHtcblxuICAgICAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxpc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRMaXN0Q2FsbGJhY2sgPSAoZGVsZXRlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygncGFyZSBjYWNoZSB0byBjcmFkbGUnLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlUG9ydGFscyhjYWNoZUFQSSwgZGVsZXRlZENvbnRlbnRJdGVtcywgZExpc3RDYWxsYmFjaylcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNS4gYWxsb2NhdGUgY3JhZGxlIGNvbnRlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgWyBoZWFkY29udGVudCwgdGFpbGNvbnRlbnQgXSA9IGFsbG9jYXRlQ29udGVudExpc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudGxpc3Q6dXBkYXRlZENvbnRlbnRMaXN0LFxuICAgICAgICAgICAgICAgIGF4aXNSZWZlcmVuY2VJbmRleCxcbiAgICAgICAgICAgICAgICBsYXlvdXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgIC8vIGxpc3Rsb3dpbmRleCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT4+IGhlYWRjb250ZW50LCB0YWlsY29udGVudCcsaGVhZGNvbnRlbnQsIHRhaWxjb250ZW50KVxuXG4gICAgICAgIC8vIHJldHVyblxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzID0gdXBkYXRlZENvbnRlbnRMaXN0XG4gICAgICAgIGNyYWRsZUNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGhlYWRjb250ZW50XG4gICAgICAgIGNyYWRsZUNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50cyA9IHRhaWxjb250ZW50XG5cbiAgICAgICAgaWYgKHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNzdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrcy5yZWZlcmVuY2VJbmRleENhbGxiYWNrKFxuXG4gICAgICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCd1cGRhdGVDcmFkbGVDb250ZW50JywgY3N0YXRlKVxuICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGVDcmFkbGVDb250ZW50OiBheGlzUmVmZXJlbmNlSW5kZXgnLCBheGlzUmVmZXJlbmNlSW5kZXgpXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgNi4gY3NzIGNoYW5nZXMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEudGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uID0gYXhpc1JlZmVyZW5jZUluZGV4IC0gbGlzdGxvd2luZGV4XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgc2Nyb2xsZXJJRCA9PSAxICYmIGNvbnNvbGUubG9nKCd1cGRhdGVDcmFkbGVDb250ZW50OiBzaGlmdGluc3RydWN0aW9uLCBlbmRpbmcgY3JhZGxlUG9zaXRpb25EYXRhJywgc2hpZnRpbnN0cnVjdGlvbiwgey4uLmNyYWRsZVBvc2l0aW9uRGF0YX0pXG5cbiAgICAgICAgaWYgKGlzU2hpZnQpIGNhY2hlQVBJLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY2FsbGluZyBhcHBseVN0eWxpbmc6YXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQnLGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0KVxuXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsaW5nKHtcbiAgICAgICAgICAgIGxheW91dCwgb3JpZW50YXRpb24sIHBhZGRpbmcsIGdhcCwgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBcbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgc2Nyb2xsUG9zLCBcbiAgICAgICAgICAgIGhlYWRjb250ZW50LFxuICAgICAgICAgICAgYXhpc0VsZW1lbnQsIGhlYWRFbGVtZW50LCBsaXN0bG93aW5kZXhcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBsb2FkIG5ldyBkaXNwbGF5IGRhdGFcbiAgICAgICAgY3JhZGxlQ29udGVudC5oZWFkRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHNcbiAgICAgICAgY3JhZGxlQ29udGVudC50YWlsRGlzcGxheUNvbXBvbmVudHMgPSBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHNcblxuICAgIH1cblxuICAgIC8vIG1vdmUgdGhlIG9mZnNldCBvZiB0aGUgYXhpc1xuICAgIHByaXZhdGUgYXBwbHlTdHlsaW5nID0gKHtcbiAgICAgICAgbGF5b3V0LCBvcmllbnRhdGlvbiwgcGFkZGluZywgZ2FwLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIFxuICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgYXhpc1JlZmVyZW5jZUluZGV4LCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgc2Nyb2xsUG9zLCBcbiAgICAgICAgaGVhZGNvbnRlbnQsXG4gICAgICAgIGF4aXNFbGVtZW50LCBoZWFkRWxlbWVudCwgbGlzdGxvd2luZGV4XG4gICAgfSkgPT4ge1xuICAgICAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09Pj4gYXBwbHlTdHlsaW5nOiBheGlzUmVmZXJlbmNlSW5kZXgsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBsaXN0bG93aW5kZXgnLCBcbiAgICAgICAgLy8gICAgIGF4aXNSZWZlcmVuY2VJbmRleCwgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsIGxpc3Rsb3dpbmRleClcblxuICAgICAgICBpZiAobGF5b3V0ID09ICd2YXJpYWJsZScpIHJldHVybiAvLyB0aGVyZSdzIGEgc2VwYXJhdGUgcm91dGluZSBmb3IgdmFyaWFibGUgYWRqdXN0bWVudHMgYW5kIGNzc1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2FmYXJpIHdoZW4gem9vbWVkIGRyaWZ0cyAoY2FsYyBwcmVjaXNpb24gb25lIHByZXN1bWVzKS4gVGhpcyBpcyBhIGhhY2sgdG8gY29ycmVjdCB0aGF0LlxuICAgICAgICBjb25zdCBwcmVBeGlzVmlydHVhbFJvd3MgPSBNYXRoLmNlaWwoICggYXhpc1JlZmVyZW5jZUluZGV4IC0gbGlzdGxvd2luZGV4ICkvY3Jvc3Njb3VudCApXG4gICAgXG4gICAgICAgIGNvbnN0IGJhc2VDZWxsTGVuZ3RoID0gXG4gICAgICAgICAgICAoKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoKVxuICAgICAgICAgICAgKyBnYXBcblxuICAgICAgICBjb25zdCB0ZXN0U2Nyb2xsUG9zID0gKGJhc2VDZWxsTGVuZ3RoICogcHJlQXhpc1ZpcnR1YWxSb3dzKSArIHBhZGRpbmcgLSBheGlzVmlld3BvcnRQaXhlbE9mZnNldFxuICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gdGVzdFNjcm9sbFBvcyAtIHNjcm9sbFBvc1xuXG4gICAgICAgIGlmIChzY3JvbGxEaWZmKSB7XG4gICAgICAgICAgICBheGlzVmlld3BvcnRQaXhlbE9mZnNldCArPSBzY3JvbGxEaWZmXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9wQXhpc1BvcywgbGVmdEF4aXNQb3MgLy8gYXZhaWxhYmxlIGZvciBkZWJ1Z1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICB0b3BBeGlzUG9zID0gc2Nyb2xsUG9zICsgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RvcEF4aXNQb3MsIGJhc2VDZWxsTGVuZ3RoLCBwcmVBeGlzVmlydHVhbFJvd3MsIHRlc3RTY3JvbGxQb3MsIHNjcm9sbFBvcywgc2Nyb2xsRGlmZiwgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcXG4nLCBcbiAgICAgICAgICAgIC8vICAgICB0b3BBeGlzUG9zLCBiYXNlQ2VsbExlbmd0aCwgcHJlQXhpc1ZpcnR1YWxSb3dzLCB0ZXN0U2Nyb2xsUG9zLCBzY3JvbGxQb3MsIHNjcm9sbERpZmYsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0KVxuXG4gICAgICAgICAgICBheGlzRWxlbWVudC5zdHlsZS50b3AgPSB0b3BBeGlzUG9zICsgJ3B4J1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9ICdhdXRvJ1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnQubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAke2dhcH1weCAke3BhZGRpbmd9cHhgOlxuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weCAwcHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgIH0gZWxzZSB7IC8vICdob3Jpem9udGFsJ1xuXG4gICAgICAgICAgICBsZWZ0QXhpc1BvcyA9IHNjcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgICAgYXhpc0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRBeGlzUG9zICsgJ3B4J1xuXG4gICAgICAgICAgICBoZWFkRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXG4gICAgICAgICAgICAgICAgaGVhZGNvbnRlbnQubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4ICR7Z2FwfXB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgOlxuICAgICAgICAgICAgICAgICAgICBgJHtwYWRkaW5nfXB4IDBweCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09WyBSRUNPTkZJR1VSRSBUSEUgU0NST0xMQkxPQ0sgRk9SIFZBUklBQkxFIENPTlRFTlQgXT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qICBcbiAgICBibG9ja1Njcm9sbFBvcyBpcyB0aGUgYW1vdW50IHRoZSBzY3JvbGxCbG9jayBpcyBzY3JvbGxlZCB0byByZXZlYWwgdGhlIGNlbnRyZSBvZiB0aGUgQ3JhZGxlXG4gICAgICAgIGF0IHRoZSBlZGdlIG9mIHRoZSBWaWV3cG9ydFxuICAgIFxuICAgIG5ld0F4aXNTY3JvbGxibG9ja09mZnNldCBpcyB0aGUgZXhhY3Qgb2Zmc2V0IG9mIGJsb2NrU2Nyb2xsUG9zLCBwbHVzIHRoZSBheGlzVmlld3BvcnRPZmZzZXRcbiAgICBcbiAgICBheGlzVmlld3BvcnRPZmZzZXQgaXMgdGhlIGFtb3VudCB0aGUgYXhpcyBpcyBhaGVhZCBvZiB0aGUgVmlld3BvcnQgZWRnZVxuICAgIFxuICAgIHRoZSBsZW5ndGggb2YgdGhlIFNjcm9sbGJsb2NrIGlzIHNob3J0ZW5lZCBieSB0aGUgYW1vdW50IHRoZSBtZWFzdXJlZCB0YWlsIGxlbmd0aCBkaWZmZXJzIGZyb20gdGhlIFxuICAgICAgICBiYXNlIHRhaWwgbGVuZ3RoXG5cbiAgICBDYWxsZWQgZm9yIHZhcmlhYmxlIGxheW91dCBvbmx5LiBBbGwgRE9NIGVsZW1lbnRzIHNob3VsZCBoYXZlIGJlZW4gcmVuZGVyZWQgYXQgdGhpcyBwb2ludFxuICAgIHNldHMgQ1NTOiBzY3JvbGxibG9ja0VsZW1lbnQgdG9wIGFuZCBoZWlnaHQgKG9yIGxlZnQgYW5kIHdpZHRoKSwgYW5kIGF4aXNFbGVtZW50IHRvcCAob3IgbGVmdClcbiAgICB0byBnZXQgY2xvc2VyIHRvIG5hdHVyYWwgcHJvcG9ydGlvbnMgdG8gbWluaW1pemUgamFua3kgc2Nyb2xsIHRodW1iXG4qL1xuXG4gICAgcHVibGljIGFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkgPSAoc291cmNlKSA9PiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHk6IHNvdXJjZScsc291cmNlKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNldHVwIGJhc2UgdmFsdWVzIGFuZCByZWZlcmVuY2VzIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXNvdXJjZXMuLi5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHsgY3JhZGxlUGFyYW1ldGVycyB9ID0gdGhpcyxcbiAgICAgICAgICAgIGNyYWRsZUhhbmRsZXJzID0gY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudCxcblxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyIFxuXG4gICAgICAgIH0gPSBjcmFkbGVIYW5kbGVycyxcblxuICAgICAgICB7IFxuXG4gICAgICAgICAgICBlbGVtZW50czogY3JhZGxlRWxlbWVudHMsIFxuICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhIFxuXG4gICAgICAgIH0gPSBsYXlvdXRIYW5kbGVyLFxuXG4gICAgICAgIC8vIGN1cnJlbnQgY29uZmlndXJhdGlvbnMuLi5cbiAgICAgICAgeyBcblxuICAgICAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uOiBheGlzUmVmZXJlbmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDogYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQsXG5cbiAgICAgICAgfSA9IGNyYWRsZVBvc2l0aW9uRGF0YSxcblxuICAgICAgICAvLyBlbGVtZW50IHJlZmVyZW5jZXMuLi5cbiAgICAgICAgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgICBoZWFkR3JpZEVsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5oZWFkUmVmLmN1cnJlbnQsXG4gICAgICAgIHRhaWxHcmlkRWxlbWVudCA9IGNyYWRsZUVsZW1lbnRzLnRhaWxSZWYuY3VycmVudCxcbiAgICAgICAgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG5cbiAgICAgICAge1xuXG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICBnYXAsIFxuICAgICAgICAgICAgcGFkZGluZywgXG4gICAgICAgICAgICBjZWxsSGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFdpZHRoLFxuXG4gICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLFxuXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmlydHVhbExpc3RQcm9wcyxcbiAgICAgICAgICAgIGNyYWRsZUNvbnRlbnRQcm9wcyxcblxuICAgICAgICB9ID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLFxuXG4gICAgICAgIHsgXG5cbiAgICAgICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAgICAgcm93Y291bnQ6bGlzdFJvd2NvdW50LFxuICAgICAgICAgICAgbG93aW5kZXg6bGlzdGxvd2luZGV4LFxuICAgICAgICAgICAgcm93c2hpZnQ6bGlzdHJvd3NoaWZ0LFxuXG5cbiAgICAgICAgfSA9IHZpcnR1YWxMaXN0UHJvcHNcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGNhbGN1bGF0aW9ucyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgYXhpc1JlZmVyZW5jZUluZGV4ID0gYXhpc1JlZmVyZW5jZVBvc2l0aW9uICsgbGlzdGxvd2luZGV4XG4gICAgICAgIC8vIHJvd2NvdW50cyBhbmQgcm93IG9mZnNldHMgZm9yIHBvc2l0aW9uaW5nXG4gICAgICAgIC8vIGxpc3RSb3djb3VudCB0YWtlbiBmcm9tIGludGVybmFsIHByb3BlcnRpZXMgYWJvdmVcbiAgICAgICAgY29uc3QgaGVhZFJvd0NvdW50ID0gTWF0aC5jZWlsKGhlYWRHcmlkRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aC9jcm9zc2NvdW50KSxcbiAgICAgICAgICAgIHRhaWxSb3dDb3VudCA9IE1hdGguY2VpbCh0YWlsR3JpZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgvY3Jvc3Njb3VudClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLS0tXFxuJywnaGVhZFJvd0NvdW50LCBoZWFkR3JpZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgsIHRhaWxSb3dDb3VudCwgYXhpc1JlZmVyZW5jZUluZGV4XFxuJyxcbiAgICAgICAgLy8gICAgIGhlYWRSb3dDb3VudCwgaGVhZEdyaWRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoLCB0YWlsUm93Q291bnQsIGF4aXNSZWZlcmVuY2VJbmRleCApXG5cbiAgICAgICAgLy8gcmVmZXJlbmNlIHJvd3MgLSBjcmFkbGUgZmlyc3QvbGFzdDsgYXhpczsgbGlzdCBlbmRcbiAgICAgICAgY29uc3QgYXhpc1JlZmVyZW5jZVJvdyA9IE1hdGguZmxvb3IoYXhpc1JlZmVyZW5jZUluZGV4L2Nyb3NzY291bnQpXG4gICAgICAgICAgICAvLyAoYXhpc1JlZmVyZW5jZUluZGV4IDwgMCk/XG4gICAgICAgICAgICAvLyAgICAgTWF0aC5mbG9vcihheGlzUmVmZXJlbmNlSW5kZXgvY3Jvc3Njb3VudCk6XG4gICAgICAgICAgICAvLyAgICAgTWF0aC5jZWlsKGF4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjcmFkbGVSZWZlcmVuY2VSb3cgPSBheGlzUmVmZXJlbmNlUm93IC0gaGVhZFJvd0NvdW50LFxuICAgICAgICAgICAgY3JhZGxlTGFzdFJvdyA9IGF4aXNSZWZlcmVuY2VSb3cgKyAodGFpbFJvd0NvdW50IC0gMSksXG4gICAgICAgICAgICBsaXN0TGFzdFJvdyA9IGxpc3RSb3djb3VudCAtIDEgKyBsaXN0cm93c2hpZnRcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYXhpc1JlZmVyZW5jZVJvdywgY3JhZGxlUmVmZXJlbmNlUm93LCBoZWFkUm93Q291bnRcXG4nLFxuICAgICAgICAvLyAgICAgYXhpc1JlZmVyZW5jZVJvdywgY3JhZGxlUmVmZXJlbmNlUm93LCBoZWFkUm93Q291bnQpXG5cbiAgICAgICAgY29uc3QgcHJlQ3JhZGxlUm93Q291bnQgPSBjcmFkbGVSZWZlcmVuY2VSb3cgLSBsaXN0cm93c2hpZnQsXG4gICAgICAgICAgICBwb3N0Q3JhZGxlUm93Q291bnQgPSBsaXN0TGFzdFJvdyAtIGNyYWRsZUxhc3RSb3dcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncHJlQ3JhZGxlUm93Q291bnQsIGNyYWRsZVJlZmVyZW5jZVJvdywgbGlzdHJvd3NoaWZ0XFxuJyxcbiAgICAgICAgLy8gICAgIHByZUNyYWRsZVJvd0NvdW50LCBjcmFkbGVSZWZlcmVuY2VSb3csIGxpc3Ryb3dzaGlmdClcblxuICAgICAgICAvLyBiYXNlIHBpeGVsIHZhbHVlc1xuICAgICAgICBjb25zdCBiYXNlQ2VsbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aFxuICAgICAgICAgICAgKSArIGdhcFxuXG4gICAgICAgIGNvbnN0IG1lYXN1cmVkVGFpbFBpeGVsTGVuZ3RoID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdGFpbEdyaWRFbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICB0YWlsR3JpZEVsZW1lbnQub2Zmc2V0V2lkdGhcblxuICAgICAgICBjb25zdCBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoID0gcG9zdENyYWRsZVJvd0NvdW50ICogYmFzZUNlbGxMZW5ndGhcblxuICAgICAgICBjb25zdCBjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGggPSBiYXNlUG9zdENyYWRsZVBpeGVsTGVuZ3RoICsgbWVhc3VyZWRUYWlsUGl4ZWxMZW5ndGhcblxuICAgICAgICAvLyBiYXNlIGZpZ3VyZXMgdXNlZCBmb3IgcHJlQXhpcyAjcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHJlcG9zaXRpb25pbmcsIHdoaWNoIHVzZXMgYmFzZSBmaWd1cmVzXG4gICAgICAgIGNvbnN0IGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGggPSAoKHByZUNyYWRsZVJvd0NvdW50ICsgaGVhZFJvd0NvdW50KSAqIGJhc2VDZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGxheW91dCBhZGp1c3RtZW50cyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIuc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU2Nyb2xsYmxvY2tQaXhlbExlbmd0aCA9IGJhc2VQcmVBeGlzUGl4ZWxMZW5ndGggKyBjb21wdXRlZFBvc3RBeGlzUGl4ZWxMZW5ndGhcbiAgICAgICAgY29uc3QgYmxvY2tTY3JvbGxQb3MgPSBiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoIC0gYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXRcbiAgICAgICAgY29uc3QgbmV3QXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQgPSBibG9ja1Njcm9sbFBvcyArIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IC8vIGllLiBiYXNlUHJlQXhpc1BpeGVsTGVuZ3RoLCBidXQgc2VtYW50aWNzXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ25ld0F4aXNTY3JvbGxibG9ja09mZnNldCwgYmxvY2tTY3JvbGxQb3MsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XFxuJyxcbiAgICAgICAgLy8gICAgIG5ld0F4aXNTY3JvbGxibG9ja09mZnNldCwgYmxvY2tTY3JvbGxQb3MsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0KVxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLnRvcCA9IG5ld0F4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0ICsgJ3B4J1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGNvbXB1dGVkU2Nyb2xsYmxvY2tQaXhlbExlbmd0aCkgKyAncHgnXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gJ2hvcml6b250YWwnXG5cbiAgICAgICAgICAgIGF4aXNFbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdBeGlzU2Nyb2xsYmxvY2tQaXhlbE9mZnNldCArICdweCdcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLndpZHRoID0gY29tcHV0ZWRTY3JvbGxibG9ja1BpeGVsTGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIHNjcm9sbFBvcyBhZGp1c3RtZW50IF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkUm93Q291bnQ/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4ICR7Z2FwfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBweCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaGVhZEdyaWRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcbiAgICAgICAgICAgICAgICBoZWFkUm93Q291bnQ/XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggJHtnYXB9cHggJHtwYWRkaW5nfXB4ICR7cGFkZGluZ31weGA6XG4gICAgICAgICAgICAgICAgICAgIGAke3BhZGRpbmd9cHggMHB4ICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHhgXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTYWZhcmlJT1MoKSkgeyAvLyBhZGp1c3QgYmxvY2tTY3JvbGxQb3MgZGlyZWN0bHkgLSBtb3N0IGJyb3dzZXJzIGluY2x1ZGluZyBTYWZhcmkgZGVza3RvcFxuXG4gICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSBibG9ja1Njcm9sbFBvc1xuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50W2NyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFByb3BlcnR5XSA9IGJsb2NrU2Nyb2xsUG9zXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YShibG9ja1Njcm9sbFBvcylcblxuICAgICAgICB9IGVsc2UgeyAvLyBmb3IgU2FmYXJpIGlPU1xuXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBhZGp1c3Qgc2Nyb2xsYmxvY2tFbGVtZW50IG9mZnNldDsgaU9Tb25BZnRlclNjcm9sbCB0cmFuc2ZlcnMgc2hpZnQgdG8gYmxvY2tTY3JvbGxQb3NcbiAgICAgICAgICAgIC8vIC0gZGlyZWN0IGNoYW5nZSBvZiBzY3JvbGxUb3AvU2Nyb2xsTGVmdCBpbiBTYWZhcmkgaU9TIGlzIGlnbm9yZWQgYnkgdGhlIGJyb3dzZXIgbW9tZW50dW0gZW5naW5lXG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nU2Nyb2xsUG9zID0gXG4gICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gYmxvY2tTY3JvbGxQb3MgLSBzdGFydGluZ1Njcm9sbFBvc1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IC1zY3JvbGxEaWZmICsgJ3B4J1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsRGlmZiArICdweCdcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgZ290b0luZGV4IG9yIHJlc2l6ZSBvdmVyc2hvb3RcbiAgICAgICAgaWYgKChzb3VyY2UgPT0gJ3NldGNyYWRsZScpICYmICFwb3N0Q3JhZGxlUm93Q291bnQpIHsgXG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0UGl4ZWxMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aFxuXG4gICAgICAgICAgICBjb25zdCBhbGlnbmVkRW5kUG9zRGlmZiA9IFxuICAgICAgICAgICAgICAgIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ICsgbWVhc3VyZWRUYWlsUGl4ZWxMZW5ndGggLSB2aWV3cG9ydFBpeGVsTGVuZ3RoXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzb3VyY2UsIGFsaWduZWRFbmRQb3NEaWZmLCBheGlzVmlld3BvcnRQaXhlbE9mZnNldCwgbWVhc3VyZWRUYWlsUGl4ZWxMZW5ndGgsIHZpZXdwb3J0UGl4ZWxMZW5ndGhcXG4nLFxuICAgICAgICAgICAgLy8gICAgIHNvdXJjZSwgYWxpZ25lZEVuZFBvc0RpZmYsIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0LCBtZWFzdXJlZFRhaWxQaXhlbExlbmd0aCwgdmlld3BvcnRQaXhlbExlbmd0aClcblxuICAgICAgICAgICAgaWYgKGFsaWduZWRFbmRQb3NEaWZmIDwgMCkgeyAvLyBmaWxsIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0IHVzaW5nIHNjcm9sbEJ5XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxCeVkgPSBcbiAgICAgICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25lZEVuZFBvc0RpZmY6XG4gICAgICAgICAgICAgICAgICAgICAgICAwXG5cbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxCeVggPVxuICAgICAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgICAgICAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25lZEVuZFBvc0RpZmZcblxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxCeShzY3JvbGxCeVgsIHNjcm9sbEJ5WSlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gWyBJTlRFUk5BTCBDT05URU5UIE1BTkFHRU1FTlQgU0VSVklDRVMgXT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHVibGljIGd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nID0gKCkgPT4geyBcblxuICAgICAgICBjb25zdCB7IGNhY2hlTWF4LCBNQVhfQ0FDSEVfT1ZFUl9SVU4gfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlQVBJIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IG1vZGVsQ29tcG9uZW50TGlzdCA9IHRoaXMuY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHNcbiBcbiAgICAgICAgaWYgKGNhY2hlQVBJLmd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nKGNhY2hlTWF4LCBtb2RlbENvbXBvbmVudExpc3QubGVuZ3RoLCBNQVhfQ0FDSEVfT1ZFUl9SVU4gKSkge1xuXG4gICAgICAgICAgICB0aGlzLnBhcmVDYWNoZVRvTWF4KClcblxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBwYXJlQ2FjaGVUb01heCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIHNjcm9sbGVySUQgfSA9IGNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNcbiAgICAgICAgXG4gICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZUhhbmRsZXJzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVBUEksIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVIYW5kbGVyc1xuXG4gICAgICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IHRoaXMuZ2V0TW9kZWxJbmRleExpc3QoKVxuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZUxpc3RDYWxsYmFjayB9ID0gc2VydmljZUhhbmRsZXIuY2FsbGJhY2tzXG5cbiAgICAgICAgICAgIGxldCBkTGlzdENhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZExpc3RDYWxsYmFjayA9IChkZWxldGVMaXN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrKCdwYXJlIGNhY2hlIHRvIGNhY2hlTWF4JyxkZWxldGVMaXN0KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWNoZUFQSS5wYXJlQ2FjaGVUb01heChcbiAgICAgICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLmNhY2hlTWF4LCBtb2RlbEluZGV4TGlzdCwgZExpc3RDYWxsYmFjaykpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhY2hlQVBJLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIEVYVEVSTkFMIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN1cHBvcnRzIGNsZWFyQ2FjaGVcbiAgICBwdWJsaWMgY2xlYXJDcmFkbGUgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlQ29udGVudCA9IHRoaXMuY29udGVudFxuICAgICAgICAvLyBjb25zdCB7IGNhY2hlQVBJIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNyYWRsZUNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzID0gW11cblxuICAgICAgICBjcmFkbGVDb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBbXVxuICAgICAgICBjcmFkbGVDb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBbXVxuXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gc2VydmljZUhhbmRsZXIgZ2V0Q3JhZGxlSW5kZXhNYXBcbiAgICAvLyBhbHNvIHN1cHBvcnRzIHBhcmVDYWNoZVRvTWF4LCBtYXRjaENhY2hlVG9DcmFkbGVcbiAgICBwdWJsaWMgZ2V0TW9kZWxJbmRleExpc3QoKSB7XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVNb2RlbENvbXBvbmVudHMgfSA9IHRoaXMuY29udGVudFxuXG4gICAgICAgIGlmICghY3JhZGxlTW9kZWxDb21wb25lbnRzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbXSBcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gY3JhZGxlTW9kZWxDb21wb25lbnRzLm1hcCgoaXRlbSk9Pml0ZW0ucHJvcHMuaW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZ2V0IGluZGV4U3BhbigpIHtcblxuICAgIC8vICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG4gICAgICAgIFxuICAgIC8vICAgICBpZiAoY3JhZGxlTW9kZWxDb21wb25lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gW11cblxuICAgIC8vICAgICBjb25zdCBsb3dJbmRleCA9ICBjcmFkbGVNb2RlbENvbXBvbmVudHNbMF0ucHJvcHMuaW5kZXhcbiAgICAvLyAgICAgY29uc3QgaGlnaEluZGV4ID0gbG93SW5kZXggKyAoY3JhZGxlTW9kZWxDb21wb25lbnRzLmxlbmd0aCAtIDEpXG4gICAgLy8gICAgIHJldHVybiBbbG93SW5kZXgsIGhpZ2hJbmRleF1cblxuICAgIC8vIH1cblxuICAgIC8vIGNhbGxlZCBmcm9tIHNlcnZpY2UgaGFuZGxlcidzIHJlbWFwSW5kZXhlcywgYXMgbGFzdCBzdGVwXG4gICAgcHVibGljIHJlY29uY2lsZUNlbGxGcmFtZXMobW9kaWZpZWRJbmRleGVzTGlzdCkge1xuXG4gICAgICAgIGlmICghbW9kaWZpZWRJbmRleGVzTGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBjb25zdCB7IGNhY2hlQVBJIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gY2FjaGVBUEkuY2FjaGVQcm9wc1xuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAgfSA9IGNhY2hlQVBJXG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudEZuIChjb21wb25lbnQsIGksIGFycmF5ICkge1xuICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgaXRlbUlEIH0gPSBjb21wb25lbnQucHJvcHNcbiAgICAgICAgICAgIGlmIChtb2RpZmllZEluZGV4ZXNMaXN0LmluY2x1ZGVzKGluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gXG4gICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQVBJLmdldE5ld0l0ZW1JRCgpXG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbUlEICE9IGl0ZW1JRCkgeyAvLyBkZWZlbnNpdmU7IHNob3VsZG4ndCBoYXBwZW5cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IFJlYWN0LmNsb25lRWxlbWVudChjb21wb25lbnQsIHtpdGVtSUQ6bmV3SXRlbUlEfSlcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5mb3JFYWNoKHByb2Nlc3NDb21wb25lbnRGbilcblxuICAgICAgICB0aGlzLmNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLHRoaXMuY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5jb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UodGhpcy5jb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgbW92ZUluZGV4IGFuZCBpbnNlcnRSZW1vdmVJbmRleCwgdXBkYXRlcyBjcmFkbGUgY29udGlndW91cyBpdGVtcyBmcm9tIHN0YXJ0Q2hhbmdlSW5kZXggb3Igc3RhcnQgb2YgY3JhZGxlXG4gICAgcHVibGljIHN5bmNocm9uaXplQ3JhZGxlSXRlbUlEc1RvQ2FjaGUodXBkYXRlZEluZGV4TGlzdCwgaXNJbnNlcnRSZW1vdmUgPSAwLCBzdGFydENoYW5nZUluZGV4ID0gbnVsbCkgeyAvLyAwID0gbW92ZVxuXG4gICAgICAgIC8vIGFzc3NlbWJsZSByZXNvdXJjZXNcbiAgICAgICAgY29uc3QgeyBjYWNoZUFQSSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgLy8gY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSBjYWNoZUFQSS5jYWNoZVByb3BzXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCB9ID0gY2FjaGVBUElcblxuICAgICAgICBjb25zdCB7IGNyYWRsZU1vZGVsQ29tcG9uZW50cyB9ID0gdGhpcy5jb250ZW50XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVDb250ZW50UHJvcHMgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBhc3NlbWJsZSBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIGNvbnN0IGluZGV4U3BhbiA9IHRoaXMuaW5kZXhTcGFuXG5cbiAgICAgICAgLy8gaWYgKGluZGV4U3Bhbi5sZW5ndGggPT0gMCkgcmV0dXJuIC8vIGRlZmVuc2l2ZTsgc2hvdWxkbid0IGJlIGhlcmVcblxuICAgICAgICAvLyBjb25zdCBbbG93U3BhbixoaWdoU3Bhbl0gPSBpbmRleFNwYW5cblxuICAgICAgICBpZiAoY3JhZGxlQ29udGVudFByb3BzLnNpemUgPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgeyBsb3dpbmRleDpsb3dTcGFuLCBoaWdoaW5kZXg6aGlnaFNwYW4gfSA9IGNyYWRsZUNvbnRlbnRQcm9wc1xuXG4gICAgICAgIGxldCBzdGFydEluZGV4LCBlbmRJbmRleFxuICAgICAgICBpZiAoaXNJbnNlcnRSZW1vdmUpIHtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0Q2hhbmdlSW5kZXggPiBoaWdoU3BhbikgcmV0dXJuXG5cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydENoYW5nZUluZGV4XG4gICAgICAgICAgICBlbmRJbmRleCA9IGhpZ2hTcGFuXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gbW92ZVxuXG4gICAgICAgICAgICBpZiAodXBkYXRlZEluZGV4TGlzdC5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSB1cGRhdGVkSW5kZXhMaXN0WzBdXG4gICAgICAgICAgICBlbmRJbmRleCA9IHVwZGF0ZWRJbmRleExpc3QuYXQoLTEpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTcGFuID0gZW5kSW5kZXggLSBzdGFydEluZGV4ICsgMVxuXG4gICAgICAgIGxldCBmaXJzdEluZGV4ID0gc3RhcnRJbmRleFxuXG4gICAgICAgIGlmIChmaXJzdEluZGV4ID4gaGlnaFNwYW4pIHJldHVyblxuXG4gICAgICAgIGlmIChmaXJzdEluZGV4IDwgbG93U3BhbikgZmlyc3RJbmRleCA9IGxvd1NwYW5cblxuICAgICAgICBjb25zdCBsb3dQdHIgPSBmaXJzdEluZGV4IC0gbG93U3BhblxuXG4gICAgICAgIGNvbnN0IGhpZ2hQdHIgPSBpc0luc2VydFJlbW92ZT9cbiAgICAgICAgICAgIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5sZW5ndGggLSAxOlxuICAgICAgICAgICAgTWF0aC5taW4oY3JhZGxlTW9kZWxDb21wb25lbnRzLmxlbmd0aCAtIDEsbG93UHRyICsgdXBkYXRlZFNwYW4gLSAxKVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHVwZGF0ZSBpbmRpdmlkdWFsIGNyYWRsZSBjb21wb25lbnRzIHRvIGNhY2hlIGNoYW5nZXNcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc2NvbXBvbmVudEZuKGNvbXBvbmVudCwgY29tcG9uZW50cHRyLCBjb21wb25lbnRhcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC5wcm9wcy5pbmRleFxuXG4gICAgICAgICAgICBjb25zdCBjYWNoZUl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAvLyBpZiBjYWNoZSBoYXMgbm8gY29tcG9uZW50IGZvciBjcmFkbGUgaXRlbSwgdGhlbiBnZXQgb25lXG4gICAgICAgICAgICBpZiAoY2FjaGVJdGVtSUQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gY2FjaGVBUEkuZ2V0TmV3SXRlbUlEKClcbiAgICAgICAgICAgICAgICBjb21wb25lbnRhcnJheVtjb21wb25lbnRwdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpuZXdJdGVtSUR9KVxuICAgICAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtYXRjaCBjYWNoZSBpdGVtSUQgdG8gY3JhZGxlIGNvbXBvbmVudCBpdGVtSURcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyYWRsZUl0ZW1JRCA9IGNvbXBvbmVudC5wcm9wcy5pdGVtSURcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXB0ciA9IHVwZGF0ZWRJbmRleExpc3QuaW5kZXhPZihpbmRleCkgLy8gVE9ETyB2ZXJpZnkgbmVlZCBmb3IgdXBkYXRlbGlzdFxuXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXB0ciAhPSAtMSkgeyAvLyB1cGRhdGUgbGlzdCBjb25maXJtcyB0aGVyZSBpcyBhIGNhY2hlIGl0ZW0gZm9yIHRoaXMgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVJdGVtSUQgPT0gY3JhZGxlSXRlbUlEKSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRhcnJheVtjb21wb25lbnRwdHJdID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge2l0ZW1JRDpjYWNoZUl0ZW1JRH0pXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1JRCA9IGNhY2hlQVBJLmdldE5ld0l0ZW1JRCgpXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudGFycmF5W2NvbXBvbmVudHB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcHRyID0gbG93UHRyOyBwdHIgPD0gaGlnaFB0cjsgcHRyKyspIHtcbiAgICAgICAgICAgIHByb2Nlc3Njb21wb25lbnRGbihjcmFkbGVNb2RlbENvbXBvbmVudHNbcHRyXSwgcHRyLCBjcmFkbGVNb2RlbENvbXBvbmVudHMpXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIGluc2VydFJlbW92ZUluZGV4XG4gICAgcHVibGljIGNyZWF0ZU5ld0l0ZW1JRHMobmV3TGlzdCkge1xuXG4gICAgICAgIGlmICghbmV3TGlzdC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVBUEkgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG4gICAgICAgIGNvbnN0IHsgY3JhZGxlTW9kZWxDb21wb25lbnRzIH0gPSB0aGlzLmNvbnRlbnRcblxuICAgICAgICBjb25zdCB7IGNyYWRsZUNvbnRlbnRQcm9wcyB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGNvbnN0IGluZGV4U3BhbiA9IHRoaXMuaW5kZXhTcGFuXG4gICAgICAgIC8vIGlmIChpbmRleFNwYW4ubGVuZ3RoID09IDApIHJldHVybiAvLyBkZWZlbnNpdmVcblxuICAgICAgICAvLyBjb25zdCBbbG93U3BhbiwgaGlnaFNwYW5dID0gaW5kZXhTcGFuXG5cbiAgICAgICAgaWYgKGNyYWRsZUNvbnRlbnRQcm9wcy5zaXplID09IDApIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHsgbG93aW5kZXg6bG93U3BhbiwgaGlnaGluZGV4OmhpZ2hTcGFuIH0gPSBjcmFkbGVDb250ZW50UHJvcHNcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzY29tcG9uZW50Rm4obmV3bGlzdGluZGV4KSB7XG5cbiAgICAgICAgICAgIGlmIChuZXdsaXN0aW5kZXggPCBsb3dTcGFuIHx8IG5ld2xpc3RpbmRleCA+IGhpZ2hTcGFuKSByZXR1cm4gLy8gZGVmZW5zaXZlXG5cbiAgICAgICAgICAgIGNvbnN0IGNyYWRsZVB0ciA9IG5ld2xpc3RpbmRleCAtIGxvd1NwYW5cblxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY3JhZGxlTW9kZWxDb21wb25lbnRzW2NyYWRsZVB0cl1cblxuICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlEID0gY2FjaGVBUEkuZ2V0TmV3SXRlbUlEKClcblxuICAgICAgICAgICAgY3JhZGxlTW9kZWxDb21wb25lbnRzW2NyYWRsZVB0cl0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7aXRlbUlEOm5ld0l0ZW1JRH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyYWRsZU1vZGVsQ29tcG9uZW50cy5mb3JFYWNoKHByb2Nlc3Njb21wb25lbnRGbilcblxuICAgICAgICBuZXdMaXN0LmZvckVhY2gocHJvY2Vzc2NvbXBvbmVudEZuKVxuXG4gICAgfVxuXG59Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIl9pIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJOdW1iZXIiLCJyZWFjdF8xIiwiX19pbXBvcnREZWZhdWx0IiwicmVxdWlyZSIsImNvbnRlbnRmdW5jdGlvbnNfMSIsIkluZmluaXRlR3JpZFNjcm9sbGVyXzEiLCJDb250ZW50SGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJfdGhpcyIsImNvbnRlbnQiLCJjcmFkbGVNb2RlbENvbXBvbmVudHMiLCJoZWFkTW9kZWxDb21wb25lbnRzIiwidGFpbE1vZGVsQ29tcG9uZW50cyIsImhlYWREaXNwbGF5Q29tcG9uZW50cyIsInRhaWxEaXNwbGF5Q29tcG9uZW50cyIsImluc3RhbmNlSWRDb3VudGVyUmVmIiwiY3VycmVudCIsInVwZGF0ZVZpcnR1YWxMaXN0U3BlY3MiLCJuZXdsaXN0c2l6ZSIsImNyYWRsZUNvbnRlbnQiLCJjbGVhckNyYWRsZSIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsInNldFZpcnR1YWxMaXN0U3BlY3MiLCJzZXRDcmFkbGVDb250ZW50IiwiY3JhZGxlU3RhdGUiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzIiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZiIsImNyYWRsZUhhbmRsZXJzIiwiaGFuZGxlcnNSZWYiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJjYWNoZUFQSSIsImxheW91dEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsInNjcm9sbEhhbmRsZXIiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJyZXF1ZXN0ZWRBeGlzUmVmZXJlbmNlUG9zaXRpb24iLCJ0YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24iLCJvcmllbnRhdGlvbiIsImdhcCIsInBhZGRpbmciLCJjZWxsSGVpZ2h0IiwiY2VsbFdpZHRoIiwic3R5bGVzIiwicGxhY2Vob2xkZXJNZXNzYWdlcyIsInNjcm9sbGVySUQiLCJ2aXJ0dWFsTGlzdFByb3BzIiwiY3JhZGxlQ29udGVudFByb3BzIiwibGlzdGxvd2luZGV4IiwibG93aW5kZXgiLCJsaXN0c2l6ZSIsInNpemUiLCJjcm9zc2NvdW50IiwibGlzdFJvd2NvdW50Iiwicm93Y291bnQiLCJiYXNlcm93YmxhbmtzIiwiY29uc29sZSIsImxvZyIsImFzc2lnbiIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwid29ya2luZ0F4aXNSZWZlcmVuY2VQb3NpdGlvbiIsIk1hdGgiLCJtaW4iLCJ3b3JraW5nQXhpc1JlZmVyZW5jZUluZGV4IiwiYWJzIiwiaW5jbHVkZXMiLCJ3b3JraW5nQ29udGVudExpc3QiLCJiYXNlUm93UGl4ZWxMZW5ndGgiLCJfcmVmIiwiY2FsY3VsYXRlQ29udGVudExpc3RSZXF1aXJlbWVudHMiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlSW5kZXgiLCJ0YXJnZXRDcmFkbGVSZWZlcmVuY2VJbmRleCIsImNyYWRsZUNvbnRlbnRDb3VudCIsIm5ld0NyYWRsZUNvbnRlbnRDb3VudCIsInNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsInRhcmdldFNjcm9sbGJsb2NrVmlld3BvcnRQaXhlbE9mZnNldCIsImF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiX3JlZjIiLCJnZXRDZWxsRnJhbWVDb21wb25lbnRMaXN0IiwiY3JhZGxlUmVmZXJlbmNlSW5kZXgiLCJsaXN0U3RhcnRDaGFuZ2VDb3VudCIsImxpc3RFbmRDaGFuZ2VDb3VudCIsIl9yZWYzIiwibmV3Y29udGVudGxpc3QiLCJpbmRleCIsImhpZ2hpbmRleCIsIlNPTCIsIkVPTCIsImdyaWRzdGFydCIsImNvbmNhdCIsImZpcnN0Y29tcG9uZW50IiwiZ3JpZHN0YXJ0c3R5bGUiLCJncmlkQ29sdW1uU3RhcnQiLCJncmlkUm93U3RhcnQiLCJyZXZpc2VkY29tcG9uZW50IiwiY2xvbmVFbGVtZW50IiwiX3JlZjQiLCJhbGxvY2F0ZUNvbnRlbnRMaXN0IiwiY29udGVudGxpc3QiLCJheGlzUmVmZXJlbmNlSW5kZXgiLCJfcmVmNSIsImhlYWRjb250ZW50bGlzdCIsInRhaWxjb250ZW50bGlzdCIsImNhbGxiYWNrcyIsInJlZmVyZW5jZUluZGV4Q2FsbGJhY2siLCJjc3RhdGUiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiYmxvY2tiYXNlbGVuZ3RoIiwic3R5bGUiLCJsZWZ0IiwidG9wIiwiaGVpZ2h0Iiwid2lkdGgiLCJibG9ja1Njcm9sbFBvcyIsInJlc2V0U2Nyb2xsRGF0YSIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJjcmFkbGVFbGVtZW50cyIsImVsZW1lbnRzIiwiYXhpc0VsZW1lbnQiLCJheGlzUmVmIiwiaGVhZEVsZW1lbnQiLCJoZWFkUmVmIiwiYXhpc1Njcm9sbGJsb2NrUGl4ZWxPZmZzZXQiLCJ1cGRhdGVDcmFkbGVDb250ZW50Iiwic3RhdGVIYW5kbGVyIiwiaW50ZXJydXB0SGFuZGxlciIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcyIsImNhY2hlIiwibGF5b3V0Iiwic2Nyb2xsUG9zIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIm1vZGVsY29udGVudGxpc3QiLCJwcmV2aW91c0NyYWRsZVJlZmVyZW5jZUluZGV4IiwiX2EiLCJfcmVmNiIsImNhbGN1bGF0ZVNoaWZ0U3BlY3MiLCJjcmFkbGVJdGVtU2hpZnQiLCJjcmFkbGVSZWZlcmVuY2VJdGVtU2hpZnQiLCJuZXdBeGlzUmVmZXJlbmNlSW5kZXgiLCJheGlzSXRlbVNoaWZ0IiwiYXhpc1JlZmVyZW5jZUl0ZW1TaGlmdCIsIm5ld0F4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwiaXNTaGlmdCIsInRyaWdnZXJsaW5lc0ludGVyc2VjdCIsImRpc2Nvbm5lY3QiLCJhcHBseVN0eWxpbmciLCJoZWFkY29udGVudCIsInVwZGF0ZWRDb250ZW50TGlzdCIsImRlbGV0ZWRDb250ZW50SXRlbXMiLCJfcmVmNyIsIl9yZWY4IiwiZGVsZXRlTGlzdENhbGxiYWNrIiwiZExpc3RDYWxsYmFjayIsImRlbGV0ZUxpc3QiLCJkZWxldGVQb3J0YWxzIiwiX3JlZjkiLCJfcmVmMTAiLCJ0YWlsY29udGVudCIsImNyYWRsZVN0YXRlUmVmIiwicmVuZGVyUG9ydGFsTGlzdHMiLCJfcmVmMTEiLCJwcmVBeGlzVmlydHVhbFJvd3MiLCJjZWlsIiwiYmFzZUNlbGxMZW5ndGgiLCJ0ZXN0U2Nyb2xsUG9zIiwic2Nyb2xsRGlmZiIsInRvcEF4aXNQb3MiLCJsZWZ0QXhpc1BvcyIsImFkanVzdFNjcm9sbGJsb2NrRm9yVmFyaWFiaWxpdHkiLCJzb3VyY2UiLCJheGlzUmVmZXJlbmNlUG9zaXRpb24iLCJoZWFkR3JpZEVsZW1lbnQiLCJ0YWlsR3JpZEVsZW1lbnQiLCJ0YWlsUmVmIiwibGlzdHJvd3NoaWZ0Iiwicm93c2hpZnQiLCJoZWFkUm93Q291bnQiLCJjaGlsZE5vZGVzIiwidGFpbFJvd0NvdW50IiwiYXhpc1JlZmVyZW5jZVJvdyIsImZsb29yIiwiY3JhZGxlUmVmZXJlbmNlUm93IiwiY3JhZGxlTGFzdFJvdyIsImxpc3RMYXN0Um93IiwicHJlQ3JhZGxlUm93Q291bnQiLCJwb3N0Q3JhZGxlUm93Q291bnQiLCJtZWFzdXJlZFRhaWxQaXhlbExlbmd0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwiYmFzZVBvc3RDcmFkbGVQaXhlbExlbmd0aCIsImNvbXB1dGVkUG9zdEF4aXNQaXhlbExlbmd0aCIsImJhc2VQcmVBeGlzUGl4ZWxMZW5ndGgiLCJzaWduYWxzIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImNvbXB1dGVkU2Nyb2xsYmxvY2tQaXhlbExlbmd0aCIsIm5ld0F4aXNTY3JvbGxibG9ja1BpeGVsT2Zmc2V0IiwiaXNTYWZhcmlJT1MiLCJzdGFydGluZ1Njcm9sbFBvcyIsInZpZXdwb3J0UGl4ZWxMZW5ndGgiLCJhbGlnbmVkRW5kUG9zRGlmZiIsInNjcm9sbEJ5WSIsInNjcm9sbEJ5WCIsInNjcm9sbEJ5IiwiZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmciLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIiLCJjYWNoZU1heCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsIm1vZGVsQ29tcG9uZW50TGlzdCIsInBhcmVDYWNoZVRvTWF4IiwibW9kZWxJbmRleExpc3QiLCJnZXRNb2RlbEluZGV4TGlzdCIsIm1hcCIsIml0ZW0iLCJyZWNvbmNpbGVDZWxsRnJhbWVzIiwibW9kaWZpZWRJbmRleGVzTGlzdCIsImluZGV4VG9JdGVtSURNYXAiLCJwcm9jZXNzQ29tcG9uZW50Rm4iLCJjb21wb25lbnQiLCJhcnJheSIsIl9jb21wb25lbnQkcHJvcHMiLCJpdGVtSUQiLCJuZXdJdGVtSUQiLCJoYXMiLCJnZXQiLCJnZXROZXdJdGVtSUQiLCJmb3JFYWNoIiwic3luY2hyb25pemVDcmFkbGVJdGVtSURzVG9DYWNoZSIsInVwZGF0ZWRJbmRleExpc3QiLCJpc0luc2VydFJlbW92ZSIsImFyZ3VtZW50cyIsInN0YXJ0Q2hhbmdlSW5kZXgiLCJsb3dTcGFuIiwiaGlnaFNwYW4iLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJhdCIsInVwZGF0ZWRTcGFuIiwiZmlyc3RJbmRleCIsImxvd1B0ciIsImhpZ2hQdHIiLCJwcm9jZXNzY29tcG9uZW50Rm4iLCJjb21wb25lbnRwdHIiLCJjb21wb25lbnRhcnJheSIsImNhY2hlSXRlbUlEIiwiY3JhZGxlSXRlbUlEIiwidXBkYXRlcHRyIiwiaW5kZXhPZiIsInB0ciIsImNyZWF0ZU5ld0l0ZW1JRHMiLCJuZXdMaXN0IiwibmV3bGlzdGluZGV4IiwiY3JhZGxlUHRyIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/contenthandler.tsx\n')},"./src/cradle/interrupthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\n// interrupthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds the callbacks for the Cradle structure listeners:\n    - cradleIntersectionObserverCallback: responds to the move of both cradle grids outside viewport\n        this initiates the repositioning protocol\n    - axisTriggerlinesObserverCallback: responds to crossing of tailward or headward triggerlines\n        in relation to the viewport, and triggers rollover and re-allocation of cradle content\n\n    viewportResizing interrupts are handled by viewport\n*/\nvar contentfunctions_1 = __webpack_require__(/*! ./contentfunctions */ "./src/cradle/contentfunctions.tsx");\nvar InterruptHandler = /*#__PURE__*/_createClass(function InterruptHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, InterruptHandler);\n  this.isHeadCradleInView = true;\n  this.isTailCradleInView = true;\n  this.axisTriggerlinesObserverCallback = function (entries) {\n    var _a;\n    if (_this.signals.pauseTriggerlinesObserver) {\n      return;\n    }\n    var testrootbounds = entries[0].rootBounds;\n    if (testrootbounds.width == 0 && testrootbounds.height == 0) {\n      // reparenting\n      return;\n    }\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      contentHandler = _this$cradleParameter.contentHandler,\n      stateHandler = _this$cradleParameter.stateHandler,\n      scrollHandler = _this$cradleParameter.scrollHandler,\n      layoutHandler = _this$cradleParameter.layoutHandler;\n    if (stateHandler.isMountedRef.current) {\n      var scrollData = scrollHandler.scrollData;\n      scrollData.previousupdate = scrollData.currentupdate;\n      scrollData.currentupdate = scrollData.current;\n      var viewportElement = _this.cradleParameters.ViewportContextPropertiesRef.current.elementRef.current;\n      var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n      var orientation = cradleInheritedProperties.orientation;\n      var triggerHistoryRef = cradleInternalProperties.triggerHistoryRef,\n        virtualListProps = cradleInternalProperties.virtualListProps,\n        crosscount = virtualListProps.crosscount,\n        listsize = virtualListProps.size,\n        rowshift = virtualListProps.rowshift;\n      var scrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n      var contentLength = orientation == \'vertical\' ? viewportElement.scrollHeight : viewportElement.scrollWidth;\n      var viewportLength = orientation == \'vertical\' ? viewportElement.offsetHeight : viewportElement.offsetWidth;\n      // for browser top or bottom bounce\n      // fractional pixels can cause this to fail, hence Math.floor)\n      // console.log(\'==>> axisTriggerlinesObserverCallback: scrollPos, viewportLength, contentLength, Math.floor(scrollPos + viewportLength)\\n\',\n      //     scrollPos, viewportLength, contentLength, Math.floor(scrollPos + viewportLength))\n      if (scrollPos >= 0 || Math.floor(scrollPos + viewportLength) <= contentLength) {\n        var viewportBoundingRect = viewportElement.getBoundingClientRect();\n        var _ref = (0, contentfunctions_1.generateShiftInstruction)({\n            scrollerID: cradleInheritedProperties.scrollerID,\n            orientation: orientation,\n            triggerlineEntries: entries,\n            triggerlineSpan: layoutHandler.triggerlineSpan,\n            isFirstRowTriggerConfig: layoutHandler.triggercellIsInTail,\n            viewportBoundingRect: viewportBoundingRect,\n            triggerHistoryRef: triggerHistoryRef\n          }),\n          _ref2 = _slicedToArray(_ref, 2),\n          shiftinstruction = _ref2[0],\n          triggerViewportReferencePixelPos = _ref2[1];\n        if (shiftinstruction == \'moveaxistailward\') {\n          // filter out oversize last row\n          var lastListRowOffset = Math.ceil(listsize / crosscount) - 1 + rowshift;\n          var tailcontentlist = contentHandler.content.tailModelComponents;\n          var previousAxisReferenceIndex = ((_a = tailcontentlist[0]) === null || _a === void 0 ? void 0 : _a.props.index) || 0;\n          var previousAxisRowOffset = Math.ceil(previousAxisReferenceIndex / crosscount);\n          // console.log(\'lastListRowOffset, previousAxisRowOffset\\n\',\n          //     lastListRowOffset, previousAxisRowOffset)\n          if (lastListRowOffset == previousAxisRowOffset) return;\n        }\n        // none == nothing to do\n        if (shiftinstruction != \'none\') {\n          _this.shiftinstruction = shiftinstruction;\n          _this.triggerViewportReferencePixelPos = triggerViewportReferencePixelPos;\n          stateHandler.setCradleState(\'renderupdatedcontent\');\n        }\n      }\n    }\n  };\n  this.cradleIntersectionObserverCallback = function (entries) {\n    var signals = _this.signals;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler,\n      scrollHandler = _this$cradleParameter2.scrollHandler,\n      layoutHandler = _this$cradleParameter2.layoutHandler;\n    if (signals.pauseCradleIntersectionObserver) {\n      return;\n    }\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (entry.target.dataset.type == \'head\') {\n        _this.isHeadCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      } else {\n        _this.isTailCradleInView = entry.isIntersecting || entry.rootBounds.width == 0 && entry.rootBounds.height == 0 // reparenting\n        ;\n      }\n    }\n\n    _this.signals.repositioningRequired = !_this.isHeadCradleInView && !_this.isTailCradleInView;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (_this.signals.repositioningRequired)\n      // start reposition if no other interrupts are underway\n      {\n        _this.isHeadCradleInView = true;\n        _this.isTailCradleInView = true;\n        var cradleState = stateHandler.cradleStateRef.current;\n        if (![\'repositioningRender\', \'repositioningContinuation\', \'finishreposition\', \'renderupdatedcontent\', \'finishupdatedcontent\', \'finishviewportresize\'].includes(cradleState) && !ViewportContextProperties.isResizing) {\n          var viewportElement = ViewportContextProperties.elementRef.current;\n          var _this$cradleParameter3 = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n            scrollerID = _this$cradleParameter3.scrollerID,\n            layout = _this$cradleParameter3.layout;\n          if (!viewportElement) {\n            console.log(\'SYSTEM: viewport element not set in cradleIntersectionObserverCallback\', scrollerID, ViewportContextProperties);\n            return;\n          }\n          // update dimensions with cradle intersection. See also dimension update in viewport.tsx for resize\n          // and getViewportDimensions in Cradle for width/height\n          var rect = viewportElement.getBoundingClientRect();\n          var top = rect.top,\n            right = rect.right,\n            bottom = rect.bottom,\n            left = rect.left;\n          var width = right - left,\n            height = bottom - top;\n          // update for scrolltracker\n          ViewportContextProperties.viewportDimensions = {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left,\n            width: width,\n            height: height\n          };\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(true);\n          if (layout == \'variable\') {\n            // restore base config to scrollblock\n            layoutHandler.restoreBaseScrollblockConfig();\n            scrollHandler.calcImpliedRepositioningData(\'restoreBaseScrollblockConfig\');\n          }\n          _this.signals.pauseTriggerlinesObserver = true;\n          console.log(\'cradleIntersectionObserverCallback: starting reposition\');\n          if (stateHandler.isMountedRef.current) stateHandler.setCradleState(\'startreposition\');\n        } else {\n          _this.signals.repositioningRequired = false;\n        }\n      }\n  };\n  this.cradleIntersect = {\n    observer: null,\n    callback: this.cradleIntersectionObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.cradleIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.cradleIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      observer.observe(cradleElements.headRef.current);\n      observer.observe(cradleElements.tailRef.current);\n      _this.cradleIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.cradleIntersect.observer.disconnect();\n      _this.cradleIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.cradleIntersect.observer = new IntersectionObserver(_this.cradleIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.cradleIntersect.observer;\n    }\n  };\n  this.triggerlinesIntersect = {\n    observer: null,\n    callback: this.axisTriggerlinesObserverCallback,\n    disconnected: true,\n    connectElements: function connectElements() {\n      if (!_this.triggerlinesIntersect.disconnected) {\n        return;\n      }\n      var observer = _this.triggerlinesIntersect.observer;\n      var cradleElements = _this.cradleParameters.handlersRef.current.layoutHandler.elements;\n      if (cradleElements.triggercellTriggerlineHeadRef.current && cradleElements.triggercellTriggerlineTailRef.current) {\n        observer.observe(cradleElements.triggercellTriggerlineHeadRef.current);\n        observer.observe(cradleElements.triggercellTriggerlineTailRef.current);\n      }\n      _this.triggerlinesIntersect.disconnected = false;\n    },\n    disconnect: function disconnect() {\n      _this.triggerlinesIntersect.observer.disconnect();\n      _this.triggerlinesIntersect.disconnected = true;\n    },\n    createObserver: function createObserver() {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      _this.triggerlinesIntersect.observer = new IntersectionObserver(_this.triggerlinesIntersect.callback, {\n        root: ViewportContextProperties.elementRef.current,\n        threshold: 0\n      });\n      return _this.triggerlinesIntersect.observer;\n    }\n  };\n  this.signals = {\n    repositioningRequired: false,\n    pauseTriggerlinesObserver: false,\n    pauseCradleIntersectionObserver: false,\n    pauseCradleResizeObserver: false,\n    pauseScrollingEffects: false\n  };\n  /*\n      invoked for\n      cradle:\n      - change into cache\n      - trigger cradleresizing\n      - trigger reconfiguration\n      - trigger pivot\n      servicehandler:\n      - call reload\n  */\n  this.pauseInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = true;\n    signals.pauseCradleIntersectionObserver = true;\n    signals.pauseCradleResizeObserver = true;\n    signals.pauseScrollingEffects = true;\n  };\n  /*\n      invoked for\n      cradle:\n      - restoreinterrupts\n  */\n  this.restoreInterrupts = function () {\n    var signals = _this.signals;\n    signals.pauseTriggerlinesObserver = false;\n    signals.pauseCradleIntersectionObserver = false;\n    signals.pauseCradleResizeObserver = false;\n    signals.pauseScrollingEffects = false;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports["default"] = InterruptHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9pbnRlcnJ1cHRoYW5kbGVyLnRzeD9hOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVycnVwdGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBDcmFkbGUgc3RydWN0dXJlIGxpc3RlbmVyczpcbiAgICAtIGNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2s6IHJlc3BvbmRzIHRvIHRoZSBtb3ZlIG9mIGJvdGggY3JhZGxlIGdyaWRzIG91dHNpZGUgdmlld3BvcnRcbiAgICAgICAgdGhpcyBpbml0aWF0ZXMgdGhlIHJlcG9zaXRpb25pbmcgcHJvdG9jb2xcbiAgICAtIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrOiByZXNwb25kcyB0byBjcm9zc2luZyBvZiB0YWlsd2FyZCBvciBoZWFkd2FyZCB0cmlnZ2VybGluZXNcbiAgICAgICAgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0LCBhbmQgdHJpZ2dlcnMgcm9sbG92ZXIgYW5kIHJlLWFsbG9jYXRpb24gb2YgY3JhZGxlIGNvbnRlbnRcblxuICAgIHZpZXdwb3J0UmVzaXppbmcgaW50ZXJydXB0cyBhcmUgaGFuZGxlZCBieSB2aWV3cG9ydFxuKi9cblxuaW1wb3J0IHsgZ2VuZXJhdGVTaGlmdEluc3RydWN0aW9uIH0gZnJvbSAnLi9jb250ZW50ZnVuY3Rpb25zJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnJ1cHRIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIH1cblxuICAgIHByaXZhdGUgY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgcHJpdmF0ZSBpc0hlYWRDcmFkbGVJblZpZXcgPSB0cnVlXG4gICAgcHJpdmF0ZSBpc1RhaWxDcmFkbGVJblZpZXcgPSB0cnVlXG5cbiAgICBwcml2YXRlIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnBhdXNlVHJpZ2dlcmxpbmVzT2JzZXJ2ZXIpIHsgXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0cm9vdGJvdW5kcyA9IGVudHJpZXNbMF0ucm9vdEJvdW5kc1xuICAgICAgICBpZiAoKHRlc3Ryb290Ym91bmRzLndpZHRoID09IDApICYmICh0ZXN0cm9vdGJvdW5kcy5oZWlnaHQgPT0gMCkpIHsgLy8gcmVwYXJlbnRpbmdcblxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyLFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlcixcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsRGF0YSB9ID0gc2Nyb2xsSGFuZGxlclxuXG4gICAgICAgICAgICBzY3JvbGxEYXRhLnByZXZpb3VzdXBkYXRlID0gc2Nyb2xsRGF0YS5jdXJyZW50dXBkYXRlXG4gICAgICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxEYXRhLmN1cnJlbnRcblxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudC5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiwgXG5cbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgIGNvbnN0IFxuICAgICAgICAgICAgeyBcblxuICAgICAgICAgICAgICAgIHRyaWdnZXJIaXN0b3J5UmVmLFxuICAgICAgICAgICAgICAgIHZpcnR1YWxMaXN0UHJvcHMsXG5cbiAgICAgICAgICAgIH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMsXG5cbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjcm9zc2NvdW50LCBcbiAgICAgICAgICAgICAgICBzaXplOmxpc3RzaXplLFxuICAgICAgICAgICAgICAgIHJvd3NoaWZ0LFxuXG4gICAgICAgICAgICB9ID0gdmlydHVhbExpc3RQcm9wc1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxQb3MgPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxIZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxXaWR0aFxuXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydExlbmd0aCA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG5cbiAgICAgICAgICAgIC8vIGZvciBicm93c2VyIHRvcCBvciBib3R0b20gYm91bmNlXG4gICAgICAgICAgICAvLyBmcmFjdGlvbmFsIHBpeGVscyBjYW4gY2F1c2UgdGhpcyB0byBmYWlsLCBoZW5jZSBNYXRoLmZsb29yKVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPT0+PiBheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjazogc2Nyb2xsUG9zLCB2aWV3cG9ydExlbmd0aCwgY29udGVudExlbmd0aCwgTWF0aC5mbG9vcihzY3JvbGxQb3MgKyB2aWV3cG9ydExlbmd0aClcXG4nLFxuICAgICAgICAgICAgLy8gICAgIHNjcm9sbFBvcywgdmlld3BvcnRMZW5ndGgsIGNvbnRlbnRMZW5ndGgsIE1hdGguZmxvb3Ioc2Nyb2xsUG9zICsgdmlld3BvcnRMZW5ndGgpKVxuXG4gICAgICAgICAgICBpZiAoIChzY3JvbGxQb3MgPj0gMCkgfHwgKE1hdGguZmxvb3Ioc2Nyb2xsUG9zICsgdmlld3BvcnRMZW5ndGgpIDw9IGNvbnRlbnRMZW5ndGgpKSB7IFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRCb3VuZGluZ1JlY3QgPSB2aWV3cG9ydEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgICAgICAgICAgIGNvbnN0IFtzaGlmdGluc3RydWN0aW9uLCB0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvc10gPSBnZW5lcmF0ZVNoaWZ0SW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklEOiBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzLnNjcm9sbGVySUQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VybGluZUVudHJpZXM6ZW50cmllcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmxpbmVTcGFuOiBsYXlvdXRIYW5kbGVyLnRyaWdnZXJsaW5lU3BhbixcblxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZzpsYXlvdXRIYW5kbGVyLnRyaWdnZXJjZWxsSXNJblRhaWwsXG5cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRCb3VuZGluZ1JlY3QsIC8vIFNhZmFyaSBkb2Vzbid0IGNvcnJlY3RseSBtZWFzdXJlIHpvb20gZm9yIHJvb3Rib3VuZHMgaW4gdHJpZ2dlcmxpbmVFbnRyaWVzXG5cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckhpc3RvcnlSZWYsXG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgaWYgKHNoaWZ0aW5zdHJ1Y3Rpb24gPT0gJ21vdmVheGlzdGFpbHdhcmQnKSB7IC8vIGZpbHRlciBvdXQgb3ZlcnNpemUgbGFzdCByb3dcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TGlzdFJvd09mZnNldCA9IE1hdGguY2VpbChsaXN0c2l6ZS9jcm9zc2NvdW50KSAtIDEgKyByb3dzaGlmdFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhaWxjb250ZW50bGlzdCA9IGNvbnRlbnRIYW5kbGVyLmNvbnRlbnQudGFpbE1vZGVsQ29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleCA9ICh0YWlsY29udGVudGxpc3RbMF0/LnByb3BzLmluZGV4IHx8IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQXhpc1Jvd09mZnNldCA9IE1hdGguY2VpbChwcmV2aW91c0F4aXNSZWZlcmVuY2VJbmRleC9jcm9zc2NvdW50KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsYXN0TGlzdFJvd09mZnNldCwgcHJldmlvdXNBeGlzUm93T2Zmc2V0XFxuJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxhc3RMaXN0Um93T2Zmc2V0LCBwcmV2aW91c0F4aXNSb3dPZmZzZXQpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMaXN0Um93T2Zmc2V0ID09IHByZXZpb3VzQXhpc1Jvd09mZnNldCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub25lID09IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRpbnN0cnVjdGlvbiAhPSAnbm9uZScpIHsgXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdGluc3RydWN0aW9uID0gc2hpZnRpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJWaWV3cG9ydFJlZmVyZW5jZVBpeGVsUG9zID0gdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUGl4ZWxQb3NcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlbmRlcnVwZGF0ZWRjb250ZW50JylcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0YSB0cmFuc2ZlciB0byB1cGRhdGVDcmFkbGVDb250ZW50IHRyaWdnZXJlZCBieSBjbG9zaW5nIGF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrIHNldENyYWRsZVN0YXRlIGNhbGxcbiAgICBzaGlmdGluc3RydWN0aW9uXG4gICAgdHJpZ2dlclZpZXdwb3J0UmVmZXJlbmNlUGl4ZWxQb3NcblxuICAgIHByaXZhdGUgY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc2lnbmFscyA9IHRoaXMuc2lnbmFsc1xuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2VydmljZUhhbmRsZXIsIFxuICAgICAgICAgICAgc2Nyb2xsSGFuZGxlciwgXG4gICAgICAgICAgICBsYXlvdXRIYW5kbGVyIFxuXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmIChzaWduYWxzLnBhdXNlQ3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQuZGF0YXNldC50eXBlID09ICdoZWFkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ID0gXG4gICAgICAgICAgICAgICAgICAgIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICgoZW50cnkucm9vdEJvdW5kcy53aWR0aCA9PSAwKSAmJiAoZW50cnkucm9vdEJvdW5kcy5oZWlnaHQgPT0gMCkpIC8vIHJlcGFyZW50aW5nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVGFpbENyYWRsZUluVmlldyA9IFxuICAgICAgICAgICAgICAgICAgICAoZW50cnkuaXNJbnRlcnNlY3RpbmcgIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKChlbnRyeS5yb290Qm91bmRzLndpZHRoID09IDApICYmIChlbnRyeS5yb290Qm91bmRzLmhlaWdodCA9PSAwKSkgLy8gcmVwYXJlbnRpbmdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpZ25hbHMucmVwb3NpdGlvbmluZ1JlcXVpcmVkID0gKCF0aGlzLmlzSGVhZENyYWRsZUluVmlldyAmJiAhdGhpcy5pc1RhaWxDcmFkbGVJblZpZXcpXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAodGhpcy5zaWduYWxzLnJlcG9zaXRpb25pbmdSZXF1aXJlZCkgLy8gc3RhcnQgcmVwb3NpdGlvbiBpZiBubyBvdGhlciBpbnRlcnJ1cHRzIGFyZSB1bmRlcndheVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNIZWFkQ3JhZGxlSW5WaWV3ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5pc1RhaWxDcmFkbGVJblZpZXcgPSB0cnVlXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgICAgIGlmIChcblxuICAgICAgICAgICAgICAgICAgICAhWydyZXBvc2l0aW9uaW5nUmVuZGVyJywncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicsJ2ZpbmlzaHJlcG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbmRlcnVwZGF0ZWRjb250ZW50JywnZmluaXNodXBkYXRlZGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbmlzaHZpZXdwb3J0cmVzaXplJ10uaW5jbHVkZXMoY3JhZGxlU3RhdGUpICYmXG5cbiAgICAgICAgICAgICAgICAgICAgIVZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuaXNSZXNpemluZ1xuXG4gICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELCBcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LCAvLyBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZGRpbmcsIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VsbEhlaWdodCwgY2VsbFdpZHRoLFxuXG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU1lTVEVNOiB2aWV3cG9ydCBlbGVtZW50IG5vdCBzZXQgaW4gY3JhZGxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zIHdpdGggY3JhZGxlIGludGVyc2VjdGlvbi4gU2VlIGFsc28gZGltZW5zaW9uIHVwZGF0ZSBpbiB2aWV3cG9ydC50c3ggZm9yIHJlc2l6ZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBnZXRWaWV3cG9ydERpbWVuc2lvbnMgaW4gQ3JhZGxlIGZvciB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gdmlld3BvcnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IHJlY3RcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdCwgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZm9yIHNjcm9sbHRyYWNrZXJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLnZpZXdwb3J0RGltZW5zaW9ucyA9IHt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHR9IFxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2sodHJ1ZSlcblxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT0gJ3ZhcmlhYmxlJykgeyAvLyByZXN0b3JlIGJhc2UgY29uZmlnIHRvIHNjcm9sbGJsb2NrXG5cbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0SGFuZGxlci5yZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnKClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGFuZGxlci5jYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhKCdyZXN0b3JlQmFzZVNjcm9sbGJsb2NrQ29uZmlnJylcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrOiBzdGFydGluZyByZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuaXNNb3VudGVkUmVmLmN1cnJlbnQpIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFscy5yZXBvc2l0aW9uaW5nUmVxdWlyZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgIHB1YmxpYyBjcmFkbGVJbnRlcnNlY3QgPSB7ICAgIFxuICAgICAgICBvYnNlcnZlcjpudWxsLCAgICBcbiAgICAgICAgY2FsbGJhY2s6dGhpcy5jcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6dHJ1ZSxcbiAgICAgICAgY29ubmVjdEVsZW1lbnRzOigpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMuaGVhZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjcmFkbGVFbGVtZW50cy50YWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB0aGlzLmNyYWRsZUludGVyc2VjdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OigpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JhZGxlSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5jcmFkbGVJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKSAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyYWRsZUludGVyc2VjdC5vYnNlcnZlclxuICAgICAgICB9XG4gICAgfVxuXG4gICBwdWJsaWMgdHJpZ2dlcmxpbmVzSW50ZXJzZWN0ID0ge1xuICAgICAgICBvYnNlcnZlcjpudWxsLFxuICAgICAgICBjYWxsYmFjazp0aGlzLmF4aXNUcmlnZ2VybGluZXNPYnNlcnZlckNhbGxiYWNrLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6dHJ1ZSxcbiAgICAgICAgY29ubmVjdEVsZW1lbnRzOigpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgICAgICBjb25zdCBjcmFkbGVFbGVtZW50cyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmxheW91dEhhbmRsZXIuZWxlbWVudHNcbiAgICAgICAgICAgIGlmIChjcmFkbGVFbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoY3JhZGxlRWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNyYWRsZUVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJsaW5lc0ludGVyc2VjdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OigpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuZGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYnNlcnZlcjooKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3Qub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VybGluZXNJbnRlcnNlY3QuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAge3Jvb3Q6Vmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnQsIHRocmVzaG9sZDowfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcmxpbmVzSW50ZXJzZWN0Lm9ic2VydmVyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2lnbmFscyA9IHtcbiAgICAgICAgcmVwb3NpdGlvbmluZ1JlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlcjogZmFsc2UsIFxuICAgICAgICBwYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyOmZhbHNlLFxuICAgICAgICBwYXVzZUNyYWRsZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgcGF1c2VTY3JvbGxpbmdFZmZlY3RzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvciBcbiAgICAgICAgY3JhZGxlOlxuICAgICAgICAtIGNoYW5nZSBpbnRvIGNhY2hlXG4gICAgICAgIC0gdHJpZ2dlciBjcmFkbGVyZXNpemluZ1xuICAgICAgICAtIHRyaWdnZXIgcmVjb25maWd1cmF0aW9uXG4gICAgICAgIC0gdHJpZ2dlciBwaXZvdFxuICAgICAgICBzZXJ2aWNlaGFuZGxlcjpcbiAgICAgICAgLSBjYWxsIHJlbG9hZFxuICAgICovXG4gICAgcHVibGljIHBhdXNlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IHRydWVcbiAgICAgICAgc2lnbmFscy5wYXVzZUNyYWRsZUludGVyc2VjdGlvbk9ic2VydmVyID0gdHJ1ZVxuICAgICAgICBzaWduYWxzLnBhdXNlQ3JhZGxlUmVzaXplT2JzZXJ2ZXIgPSB0cnVlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gdHJ1ZVxuICAgIH1cbiAgICAvKlxuICAgICAgICBpbnZva2VkIGZvclxuICAgICAgICBjcmFkbGU6XG4gICAgICAgIC0gcmVzdG9yZWludGVycnVwdHNcbiAgICAqL1xuICAgIHB1YmxpYyByZXN0b3JlSW50ZXJydXB0cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzXG4gICAgICAgIHNpZ25hbHMucGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciA9IGZhbHNlXG4gICAgICAgIHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzID0gZmFsc2VcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiY29udGVudGZ1bmN0aW9uc18xIiwicmVxdWlyZSIsIkludGVycnVwdEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJpc0hlYWRDcmFkbGVJblZpZXciLCJpc1RhaWxDcmFkbGVJblZpZXciLCJheGlzVHJpZ2dlcmxpbmVzT2JzZXJ2ZXJDYWxsYmFjayIsImVudHJpZXMiLCJzaWduYWxzIiwicGF1c2VUcmlnZ2VybGluZXNPYnNlcnZlciIsInRlc3Ryb290Ym91bmRzIiwicm9vdEJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyIiwiaGFuZGxlcnNSZWYiLCJjdXJyZW50IiwiY29udGVudEhhbmRsZXIiLCJzdGF0ZUhhbmRsZXIiLCJzY3JvbGxIYW5kbGVyIiwibGF5b3V0SGFuZGxlciIsImlzTW91bnRlZFJlZiIsInNjcm9sbERhdGEiLCJwcmV2aW91c3VwZGF0ZSIsImN1cnJlbnR1cGRhdGUiLCJ2aWV3cG9ydEVsZW1lbnQiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiZWxlbWVudFJlZiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwib3JpZW50YXRpb24iLCJ0cmlnZ2VySGlzdG9yeVJlZiIsInZpcnR1YWxMaXN0UHJvcHMiLCJjcm9zc2NvdW50IiwibGlzdHNpemUiLCJzaXplIiwicm93c2hpZnQiLCJzY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiY29udGVudExlbmd0aCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIiwidmlld3BvcnRMZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIk1hdGgiLCJmbG9vciIsInZpZXdwb3J0Qm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX3JlZiIsImdlbmVyYXRlU2hpZnRJbnN0cnVjdGlvbiIsInNjcm9sbGVySUQiLCJ0cmlnZ2VybGluZUVudHJpZXMiLCJ0cmlnZ2VybGluZVNwYW4iLCJpc0ZpcnN0Um93VHJpZ2dlckNvbmZpZyIsInRyaWdnZXJjZWxsSXNJblRhaWwiLCJfcmVmMiIsInNoaWZ0aW5zdHJ1Y3Rpb24iLCJ0cmlnZ2VyVmlld3BvcnRSZWZlcmVuY2VQaXhlbFBvcyIsImxhc3RMaXN0Um93T2Zmc2V0IiwiY2VpbCIsInRhaWxjb250ZW50bGlzdCIsImNvbnRlbnQiLCJ0YWlsTW9kZWxDb21wb25lbnRzIiwicHJldmlvdXNBeGlzUmVmZXJlbmNlSW5kZXgiLCJfYSIsImluZGV4IiwicHJldmlvdXNBeGlzUm93T2Zmc2V0Iiwic2V0Q3JhZGxlU3RhdGUiLCJjcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyMiIsInNlcnZpY2VIYW5kbGVyIiwicGF1c2VDcmFkbGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJ5IiwiZGF0YXNldCIsInR5cGUiLCJpc0ludGVyc2VjdGluZyIsInJlcG9zaXRpb25pbmdSZXF1aXJlZCIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJjcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaW5jbHVkZXMiLCJpc1Jlc2l6aW5nIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyMyIsImxheW91dCIsImNvbnNvbGUiLCJsb2ciLCJyZWN0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwidmlld3BvcnREaW1lbnNpb25zIiwicmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayIsImNhbGxiYWNrcyIsInJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWciLCJjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhIiwiY3JhZGxlSW50ZXJzZWN0Iiwib2JzZXJ2ZXIiLCJjYWxsYmFjayIsImRpc2Nvbm5lY3RlZCIsImNvbm5lY3RFbGVtZW50cyIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJvYnNlcnZlIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJkaXNjb25uZWN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3QiLCJ0aHJlc2hvbGQiLCJ0cmlnZ2VybGluZXNJbnRlcnNlY3QiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmIiwicGF1c2VDcmFkbGVSZXNpemVPYnNlcnZlciIsInBhdXNlU2Nyb2xsaW5nRWZmZWN0cyIsInBhdXNlSW50ZXJydXB0cyIsInJlc3RvcmVJbnRlcnJ1cHRzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/interrupthandler.tsx\n')},"./src/cradle/layouthandler.tsx":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\n// layouthandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module holds references to\n    - the structural elements of the cradle\n    - the key control values of the cradle\n\n    The structural elements are the axis, head (grid), tail (grid),\n        and the head and tail triggerlines\n    The key control values are the blockScrollPos & blockXScrollPos (scrollTop or scrollLeft), the block scroll\n        property ("scrollTop" or "scrollLeft"), the targetAxisReferencePosition (first index of the\n        tail block), and the targetAxisViewportPixelOffset (pixels offset from the edge of the\n        viewport)\n*/\nvar InfiniteGridScroller_1 = __webpack_require__(/*! ../InfiniteGridScroller */ "./src/InfiniteGridScroller.tsx");\nvar LayoutHandler = /*#__PURE__*/function () {\n  function LayoutHandler(cradleParameters) {\n    var _this = this;\n    _classCallCheck(this, LayoutHandler);\n    // cradlePositionData controls the relative positions of the scaffold elements\n    this.cradlePositionData = {\n      /*\n          "block" = cradleblock, which is the element that is scrolled\n               blockScrollPos is set by scrollHandler during and after scrolling,\n          and by setCradleContent in contentHandler, which repositions the cradle.\n               blockScrollPos is used by\n              - cradle initialization in response to reparenting interrupt\n              - setCradleContent\n           */\n      blockScrollPos: null,\n      blockXScrollPos: null,\n      /*\n          values can be "scrollTop" or "scrollLeft" (of the viewport element) depending on orientation\n               blockScrollProperty is set by the orientation reconfiguration effect in cradle module.\n               it is used where blockScrollPos is used above.\n      */\n      blockScrollProperty: null,\n      blockXScrollProperty: null,\n      /*\n          targetAxisReferencePosition is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - host scrollToIndex call\n               targetAxisReferencePosition is used by\n              - scrollTrackerArgs in cradle module\n              - requestedAxisReferenceIndex in setCradleContent\n      */\n      targetAxisReferencePosition: null,\n      /*\n          targetAxisViewportPixelOffset is set by\n              - setCradleContent\n              - updateCradleContent\n              - layoutHandler (initialization)\n              - scrollHandler (during and after scroll)\n              - pivot effect (change of orientation) in cradle module\n               targetAxisViewportPixelOffset is used by\n              - previousAxisOffset in pivot effect\n              - setCradleContent\n           */\n      targetAxisViewportPixelOffset: null // pixels into the viewport\n    };\n    // called by interruptHandler\n    this.restoreBaseScrollblockConfig = function () {\n      var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n      var viewportElement = ViewportContextProperties.elementRef.current;\n      var scrollblockElement = viewportElement.firstChild;\n      var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n        orientation = _this$cradleParameter.orientation,\n        padding = _this$cradleParameter.padding,\n        gap = _this$cradleParameter.gap,\n        cellHeight = _this$cradleParameter.cellHeight,\n        cellWidth = _this$cradleParameter.cellWidth;\n      var _this$cradleParameter2 = _this.cradleParameters.cradleInternalPropertiesRef.current.virtualListProps,\n        listRowcount = _this$cradleParameter2.rowcount,\n        crosscount = _this$cradleParameter2.crosscount;\n      var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n        scrollHandler = _this$cradleParameter3.scrollHandler,\n        layoutHandler = _this$cradleParameter3.layoutHandler;\n      var cellLength = (orientation == \'vertical\' ? cellHeight : cellWidth) + gap;\n      var baselength = listRowcount * cellLength - gap // final cell has no trailing gap\n      + padding * 2; // leading and trailing padding\n      if (orientation == \'vertical\') {\n        scrollblockElement.style.top = null;\n        scrollblockElement.style.height = baselength + \'px\';\n      } else {\n        scrollblockElement.style.left = null;\n        scrollblockElement.style.width = baselength + \'px\';\n      }\n      var cradlePositionData = layoutHandler.cradlePositionData;\n      var axisReferencePosition = cradlePositionData.targetAxisReferencePosition;\n      var rowReferencePosition = Math.ceil(axisReferencePosition / crosscount);\n      var calculatedBlockScrollPos = rowReferencePosition * cellLength + padding;\n      if ((0, InfiniteGridScroller_1.isSafariIOS)()) {\n        // scrollPos overwritten by Safari iOS momentum engine\n        var originalScrollPos = orientation == \'vertical\' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n        var scrollShift = calculatedBlockScrollPos - originalScrollPos;\n        if (orientation == \'vertical\') {\n          scrollblockElement.style.top = scrollShift;\n        } else {\n          scrollblockElement.style.left = scrollShift;\n        }\n      } else {\n        viewportElement[cradlePositionData.blockScrollProperty] = calculatedBlockScrollPos;\n      }\n      cradlePositionData.blockScrollPos = calculatedBlockScrollPos;\n      scrollHandler.resetScrollData(calculatedBlockScrollPos);\n    };\n    this.cradleParameters = cradleParameters;\n    var _cradleParameters$cra = cradleParameters.cradleInternalPropertiesRef.current.cradleElementsRef.current,\n      axisRef = _cradleParameters$cra.axisRef,\n      headRef = _cradleParameters$cra.headRef,\n      tailRef = _cradleParameters$cra.tailRef,\n      triggercellTriggerlineHeadRef = _cradleParameters$cra.triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef = _cradleParameters$cra.triggercellTriggerlineTailRef;\n    this.elements = {\n      axisRef: axisRef,\n      headRef: headRef,\n      tailRef: tailRef,\n      triggercellTriggerlineHeadRef: triggercellTriggerlineHeadRef,\n      triggercellTriggerlineTailRef: triggercellTriggerlineTailRef\n    };\n    var startingIndex = this.cradleParameters.cradleInheritedPropertiesRef.current.startingIndex;\n    var listsize = this.cradleParameters.cradleInternalPropertiesRef.current.virtualListProps.size;\n    // TODO: recalculate\n    this.cradlePositionData.targetAxisReferencePosition = Math.min(startingIndex, listsize - 1) || 0;\n    this.cradlePositionData.targetAxisViewportPixelOffset = 0;\n  }\n  _createClass(LayoutHandler, [{\n    key: "triggerlineSpan",\n    get: function get() {\n      var orientation = this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n      var span = orientation == \'vertical\' ? this.elements.triggercellTriggerlineTailRef.current.offsetTop - this.elements.triggercellTriggerlineHeadRef.current.offsetTop :\n      // horizontal\n      this.elements.triggercellTriggerlineTailRef.current.offsetLeft - this.elements.triggercellTriggerlineHeadRef.current.offsetLeft;\n      return span;\n    }\n  }]);\n  return LayoutHandler;\n}();\nexports["default"] = LayoutHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNELDZCQUE2QixDQUFDOUMsT0FBTyxDQUFDc0QsU0FBUyxHQUM3RCxJQUFJLENBQUNQLFFBQVEsQ0FBQ0YsNkJBQTZCLENBQUM3QyxPQUFPLENBQUNzRCxTQUFTO01BQzdEO01BQ0EsSUFBSSxDQUFDUCxRQUFRLENBQUNELDZCQUE2QixDQUFDOUMsT0FBTyxDQUFDdUQsVUFBVSxHQUM5RCxJQUFJLENBQUNSLFFBQVEsQ0FBQ0YsNkJBQTZCLENBQUM3QyxPQUFPLENBQUN1RCxVQUFVO01BRWxFLE9BQU9GLElBQUk7SUFDZjtFQUFDO0VBQUEsT0FBQWxFLGFBQUE7QUFBQTtBQXRETHFFLGtCQUFBLEdBQUFyRSxhQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvbGF5b3V0aGFuZGxlci50c3g/MDdiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsYXlvdXRoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBob2xkcyByZWZlcmVuY2VzIHRvIFxuICAgIC0gdGhlIHN0cnVjdHVyYWwgZWxlbWVudHMgb2YgdGhlIGNyYWRsZVxuICAgIC0gdGhlIGtleSBjb250cm9sIHZhbHVlcyBvZiB0aGUgY3JhZGxlXG5cbiAgICBUaGUgc3RydWN0dXJhbCBlbGVtZW50cyBhcmUgdGhlIGF4aXMsIGhlYWQgKGdyaWQpLCB0YWlsIChncmlkKSwgXG4gICAgICAgIGFuZCB0aGUgaGVhZCBhbmQgdGFpbCB0cmlnZ2VybGluZXNcbiAgICBUaGUga2V5IGNvbnRyb2wgdmFsdWVzIGFyZSB0aGUgYmxvY2tTY3JvbGxQb3MgJiBibG9ja1hTY3JvbGxQb3MgKHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0KSwgdGhlIGJsb2NrIHNjcm9sbFxuICAgICAgICBwcm9wZXJ0eSAoXCJzY3JvbGxUb3BcIiBvciBcInNjcm9sbExlZnRcIiksIHRoZSB0YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24gKGZpcnN0IGluZGV4IG9mIHRoZVxuICAgICAgICB0YWlsIGJsb2NrKSwgYW5kIHRoZSB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCAocGl4ZWxzIG9mZnNldCBmcm9tIHRoZSBlZGdlIG9mIHRoZSBcbiAgICAgICAgdmlld3BvcnQpXG4qL1xuXG5pbXBvcnQgeyBpc1NhZmFyaUlPUyB9IGZyb20gJy4uL0luZmluaXRlR3JpZFNjcm9sbGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXlvdXRIYW5kbGVyIHsgXG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGF4aXNSZWYsIFxuICAgICAgICAgICAgaGVhZFJlZiwgXG4gICAgICAgICAgICB0YWlsUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFJlZixcbiAgICAgICAgfSA9IGNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQuY3JhZGxlRWxlbWVudHNSZWYuY3VycmVudFxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHtcbiAgICAgICAgICAgIGF4aXNSZWYsXG4gICAgICAgICAgICBoZWFkUmVmLFxuICAgICAgICAgICAgdGFpbFJlZixcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkUmVmLFxuICAgICAgICAgICAgdHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4LCBcbiAgICAgICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBsaXN0c2l6ZSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudC52aXJ0dWFsTGlzdFByb3BzLnNpemVcblxuICAgICAgICAvLyBUT0RPOiByZWNhbGN1bGF0ZVxuICAgICAgICB0aGlzLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24gPSBcbiAgICAgICAgICAgIChNYXRoLm1pbihzdGFydGluZ0luZGV4LChsaXN0c2l6ZSAtIDEpKSB8fCAwKVxuXG4gICAgICAgIHRoaXMuY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gMFxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0IHRyaWdnZXJsaW5lU3BhbigpIHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZVRhaWxSZWYuY3VycmVudC5vZmZzZXRUb3AgLSBcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudHJpZ2dlcmNlbGxUcmlnZ2VybGluZUhlYWRSZWYuY3VycmVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmLmN1cnJlbnQub2Zmc2V0TGVmdCAtIFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy50cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZi5jdXJyZW50Lm9mZnNldExlZnRcblxuICAgICAgICByZXR1cm4gc3BhblxuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyY2VsbEluZGV4XG4gICAgcHVibGljIHRyaWdnZXJjZWxsSXNJblRhaWwgLy8gPSBmYWxzZVxuXG4gICAgLy8gY3JhZGxlUG9zaXRpb25EYXRhIGNvbnRyb2xzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgdGhlIHNjYWZmb2xkIGVsZW1lbnRzXG4gICAgcHVibGljIGNyYWRsZVBvc2l0aW9uRGF0YSA9IHtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgXCJibG9ja1wiID0gY3JhZGxlYmxvY2ssIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRoYXQgaXMgc2Nyb2xsZWRcblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgc2V0IGJ5IHNjcm9sbEhhbmRsZXIgZHVyaW5nIGFuZCBhZnRlciBzY3JvbGxpbmcsXG4gICAgICAgICAgICBhbmQgYnkgc2V0Q3JhZGxlQ29udGVudCBpbiBjb250ZW50SGFuZGxlciwgd2hpY2ggcmVwb3NpdGlvbnMgdGhlIGNyYWRsZS5cblxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gY3JhZGxlIGluaXRpYWxpemF0aW9uIGluIHJlc3BvbnNlIHRvIHJlcGFyZW50aW5nIGludGVycnVwdFxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuXG4gICAgICAgICovXG4gICAgICAgIGJsb2NrU2Nyb2xsUG9zOm51bGwsIC8vIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICBibG9ja1hTY3JvbGxQb3M6bnVsbCwgLy8gdGhlIGNyb3NzIHBvc2l0aW9uIGZvciBvdmVyc2l6ZWQgc2Nyb2xsQmxvY2tcblxuICAgICAgICAvKlxuICAgICAgICAgICAgdmFsdWVzIGNhbiBiZSBcInNjcm9sbFRvcFwiIG9yIFwic2Nyb2xsTGVmdFwiIChvZiB0aGUgdmlld3BvcnQgZWxlbWVudCkgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG5cbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsUHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBvcmllbnRhdGlvbiByZWNvbmZpZ3VyYXRpb24gZWZmZWN0IGluIGNyYWRsZSBtb2R1bGUuXG5cbiAgICAgICAgICAgIGl0IGlzIHVzZWQgd2hlcmUgYmxvY2tTY3JvbGxQb3MgaXMgdXNlZCBhYm92ZS5cbiAgICAgICAgKi9cbiAgICAgICAgYmxvY2tTY3JvbGxQcm9wZXJ0eTogbnVsbCxcbiAgICAgICAgYmxvY2tYU2Nyb2xsUHJvcGVydHk6IG51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbiBpcyBzZXQgYnlcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgICAgICAgICAtIGxheW91dEhhbmRsZXIgKGluaXRpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsSGFuZGxlciAoZHVyaW5nIGFuZCBhZnRlciBzY3JvbGwpXG4gICAgICAgICAgICAgICAgLSBob3N0IHNjcm9sbFRvSW5kZXggY2FsbFxuXG4gICAgICAgICAgICB0YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24gaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC0gc2Nyb2xsVHJhY2tlckFyZ3MgaW4gY3JhZGxlIG1vZHVsZVxuICAgICAgICAgICAgICAgIC0gcmVxdWVzdGVkQXhpc1JlZmVyZW5jZUluZGV4IGluIHNldENyYWRsZUNvbnRlbnRcbiAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uOm51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHNldCBieVxuICAgICAgICAgICAgICAgIC0gc2V0Q3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gdXBkYXRlQ3JhZGxlQ29udGVudFxuICAgICAgICAgICAgICAgIC0gbGF5b3V0SGFuZGxlciAoaW5pdGlhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgLSBzY3JvbGxIYW5kbGVyIChkdXJpbmcgYW5kIGFmdGVyIHNjcm9sbClcbiAgICAgICAgICAgICAgICAtIHBpdm90IGVmZmVjdCAoY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBpbiBjcmFkbGUgbW9kdWxlXG5cbiAgICAgICAgICAgIHRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IGlzIHVzZWQgYnlcbiAgICAgICAgICAgICAgICAtIHByZXZpb3VzQXhpc09mZnNldCBpbiBwaXZvdCBlZmZlY3RcbiAgICAgICAgICAgICAgICAtIHNldENyYWRsZUNvbnRlbnRcblxuICAgICAgICAqL1xuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldDpudWxsLCAvLyBwaXhlbHMgaW50byB0aGUgdmlld3BvcnRcblxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBieSBpbnRlcnJ1cHRIYW5kbGVyXG4gICAgcHVibGljIHJlc3RvcmVCYXNlU2Nyb2xsYmxvY2tDb25maWcgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCB7IFxuXG4gICAgICAgICAgICAvLyBzY3JvbGxlcklELCBcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLCBcbiAgICAgICAgICAgIHBhZGRpbmcsIFxuICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgY2VsbEhlaWdodCxcbiAgICAgICAgICAgIGNlbGxXaWR0aCxcbiAgICAgICAgICAgIC8vIGxheW91dCBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJvd2NvdW50Omxpc3RSb3djb3VudCxcbiAgICAgICAgICAgIGNyb3NzY291bnQsXG4gICAgICAgIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQudmlydHVhbExpc3RQcm9wc1xuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIC8vIHN0YXRlSGFuZGxlciwgXG4gICAgICAgICAgICAvLyBzZXJ2aWNlSGFuZGxlciwgXG4gICAgICAgICAgICBzY3JvbGxIYW5kbGVyLCBcbiAgICAgICAgICAgIGxheW91dEhhbmRsZXIgXG5cbiAgICAgICAgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY2VsbExlbmd0aCA9IFxuICAgICAgICAgICAgKChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0OlxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aClcbiAgICAgICAgICAgICsgZ2FwXG5cbiAgICAgICAgY29uc3QgYmFzZWxlbmd0aCA9IChsaXN0Um93Y291bnQgKiBjZWxsTGVuZ3RoKSAtIGdhcCAvLyBmaW5hbCBjZWxsIGhhcyBubyB0cmFpbGluZyBnYXBcbiAgICAgICAgICAgICsgKHBhZGRpbmcgKiAyKSAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBwYWRkaW5nXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IG51bGxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBiYXNlbGVuZ3RoICsgJ3B4J1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLndpZHRoID0gYmFzZWxlbmd0aCArICdweCdcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjcmFkbGVQb3NpdGlvbkRhdGEgfSA9IGxheW91dEhhbmRsZXJcbiAgICAgICAgY29uc3QgYXhpc1JlZmVyZW5jZVBvc2l0aW9uID0gY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvblxuICAgICAgICBjb25zdCByb3dSZWZlcmVuY2VQb3NpdGlvbiA9IE1hdGguY2VpbChheGlzUmVmZXJlbmNlUG9zaXRpb24vY3Jvc3Njb3VudClcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZEJsb2NrU2Nyb2xsUG9zID0gXG4gICAgICAgICAgICAocm93UmVmZXJlbmNlUG9zaXRpb24gKiBjZWxsTGVuZ3RoKSArIHBhZGRpbmdcblxuXG4gICAgICAgIGlmIChpc1NhZmFyaUlPUygpKSB7IC8vIHNjcm9sbFBvcyBvdmVyd3JpdHRlbiBieSBTYWZhcmkgaU9TIG1vbWVudHVtIGVuZ2luZVxuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbFBvcyA9IFxuICAgICAgICAgICAgICAgIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKT9cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsU2hpZnQgPSBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MgLSBvcmlnaW5hbFNjcm9sbFBvc1xuXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50LnN0eWxlLnRvcCA9IHNjcm9sbFNoaWZ0XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxibG9ja0VsZW1lbnQuc3R5bGUubGVmdCA9IHNjcm9sbFNoaWZ0XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFtjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQcm9wZXJ0eV0gPSBjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3NcblxuICAgICAgICB9XG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IGNhbGN1bGF0ZWRCbG9ja1Njcm9sbFBvc1xuICAgICAgICBzY3JvbGxIYW5kbGVyLnJlc2V0U2Nyb2xsRGF0YShjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZWxlbWVudHNcblxufVxuXG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJOdW1iZXIiLCJJbmZpbml0ZUdyaWRTY3JvbGxlcl8xIiwicmVxdWlyZSIsIkxheW91dEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJjcmFkbGVQb3NpdGlvbkRhdGEiLCJibG9ja1Njcm9sbFBvcyIsImJsb2NrWFNjcm9sbFBvcyIsImJsb2NrU2Nyb2xsUHJvcGVydHkiLCJibG9ja1hTY3JvbGxQcm9wZXJ0eSIsInRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbiIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0IiwicmVzdG9yZUJhc2VTY3JvbGxibG9ja0NvbmZpZyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMiLCJWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmIiwiY3VycmVudCIsInZpZXdwb3J0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsIm9yaWVudGF0aW9uIiwicGFkZGluZyIsImdhcCIsImNlbGxIZWlnaHQiLCJjZWxsV2lkdGgiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwidmlydHVhbExpc3RQcm9wcyIsImxpc3RSb3djb3VudCIsInJvd2NvdW50IiwiY3Jvc3Njb3VudCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJoYW5kbGVyc1JlZiIsInNjcm9sbEhhbmRsZXIiLCJsYXlvdXRIYW5kbGVyIiwiY2VsbExlbmd0aCIsImJhc2VsZW5ndGgiLCJzdHlsZSIsInRvcCIsImhlaWdodCIsImxlZnQiLCJ3aWR0aCIsImF4aXNSZWZlcmVuY2VQb3NpdGlvbiIsInJvd1JlZmVyZW5jZVBvc2l0aW9uIiwiTWF0aCIsImNlaWwiLCJjYWxjdWxhdGVkQmxvY2tTY3JvbGxQb3MiLCJpc1NhZmFyaUlPUyIsIm9yaWdpbmFsU2Nyb2xsUG9zIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNjcm9sbFNoaWZ0IiwicmVzZXRTY3JvbGxEYXRhIiwiX2NyYWRsZVBhcmFtZXRlcnMkY3JhIiwiY3JhZGxlRWxlbWVudHNSZWYiLCJheGlzUmVmIiwiaGVhZFJlZiIsInRhaWxSZWYiLCJ0cmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFJlZiIsInRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsUmVmIiwiZWxlbWVudHMiLCJzdGFydGluZ0luZGV4IiwibGlzdHNpemUiLCJzaXplIiwibWluIiwiZ2V0Iiwic3BhbiIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/layouthandler.tsx\n')},"./src/cradle/scrollhandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// scrollhandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module holds the response to scrolling. It also triggers an onAfterScroll event (after a timeout)\n    It's main job is to maintain records of scrollPos, targetAxisReferencePosition, and\n        targetAxisViewportPixelOffset\n*/\nvar ScrollHandler = /*#__PURE__*/_createClass(function ScrollHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ScrollHandler);\n  this._isIOSscrolling = false;\n  this.iOSonScroll = function () {\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this._isIOSscrolling) {\n      _this._isIOSscrolling = true;\n      _this._onIOSonAfterScrollTimeout = 1000; // iOS sometimes likes to pause before commencing scrolling\n      clearTimeout(_this._onIOSonAfterScrollTimeout);\n      _this._iOSsetTimeoutTimerid = setTimeout(function () {\n        _this._onIOSonAfterScrollTimeout = 250; // back to more responsive once underway\n      }, 900);\n    }\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    clearTimeout(_this._iOSscrolltimerid);\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockElement = viewportElement.firstChild;\n    var scrollblockLength, viewportLength, blockScrollPos, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollblockLength = viewportElement.scrollHeight;\n      viewportLength = viewportElement.offsetHeight;\n      blockScrollPos = viewportElement.scrollTop;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollblockLength = viewportElement.scrollWidth;\n      viewportLength = viewportElement.offsetWidth;\n      blockScrollPos = viewportElement.scrollLeft;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    if (blockScrollPos - scrollblockOffset < 0 ||\n    // overshoot start\n    scrollblockLength < blockScrollPos - scrollblockOffset + viewportLength) {\n      // overshoot end\n      _this.iOSonAfterScroll(); // immediate halt and adjust\n    } else {\n      _this._iOSscrolltimerid = setTimeout(function () {\n        _this.iOSonAfterScroll(); // deferred halt and adjust\n      }, _this._onIOSonAfterScrollTimeout);\n    }\n  };\n  this.iOSonAfterScroll = function () {\n    _this._isIOSscrolling = false;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    var scrollblockElement = viewportElement.firstChild;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollblockOffset = orientation == 'vertical' ? scrollblockElement.offsetTop : scrollblockElement.offsetLeft;\n    var blockScrollPos = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    viewportElement.style.overflow = 'hidden';\n    if (orientation == 'vertical') {\n      viewportElement.scrollTop = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.top = null;\n    } else {\n      // orientation == horizontal\n      viewportElement.scrollLeft = blockScrollPos - scrollblockOffset;\n      scrollblockElement.style.left = null;\n    }\n    viewportElement.style.overflow = 'scroll';\n  };\n  this.scrollData = {\n    start: 0,\n    current: 0,\n    previous: 0,\n    previousupdate: 0,\n    currentupdate: 0\n  };\n  this._scrolltimerid = null;\n  this.isScrolling = false;\n  this.resetScrollData = function (scrollPosition) {\n    var scrollData = _this.scrollData;\n    scrollData.start = scrollData.current = scrollData.previous = scrollData.previousupdate = scrollData.currentupdate = scrollPosition;\n  };\n  this.onScroll = function (e) {\n    var _this$cradleParameter = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      scrollerID = _this$cradleParameter.scrollerID,\n      ONAFTERSCROLL_TIMEOUT = _this$cradleParameter.ONAFTERSCROLL_TIMEOUT;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    // const viewportElement = ViewportContextProperties.elementRef.current\n    var viewportElement = e.currentTarget;\n    var orientation = _this.cradleParameters.cradleInheritedPropertiesRef.current.orientation;\n    var scrollPositionCurrent = orientation == 'vertical' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    var scrollXPositionCurrent = orientation == 'horizontal' ? viewportElement.scrollTop : viewportElement.scrollLeft;\n    clearTimeout(_this._scrolltimerid);\n    if (viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0) {\n      // in cache\n      return;\n    }\n    if (scrollPositionCurrent < 0) {\n      // for Safari\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    if (signals.pauseScrollingEffects) {\n      return;\n    }\n    if (!_this.isScrolling) {\n      _this.isScrolling = true;\n      _this.scrollData.start = scrollPositionCurrent;\n      _this.scrollData.currentupdate = scrollPositionCurrent;\n    }\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    // keep up to date in case of reparenting interrupt\n    cradlePositionData.blockScrollPos = scrollPositionCurrent;\n    cradlePositionData.blockXScrollPos = scrollXPositionCurrent;\n    _this.scrollData.previous = _this.scrollData.current;\n    _this.scrollData.current = scrollPositionCurrent;\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var cradleState = stateHandler.cradleStateRef.current;\n    // const { contentHandler, serviceHandler } = this.cradleParameters.handlersRef.current\n    if (!ViewportContextProperties.isResizing) {\n      if (cradleState == 'repositioningRender' || cradleState == 'repositioningContinuation') {\n        // if (['repositioningContinuation','repositioningRender','finishreposition'].includes(cradleState)) {\n        scrollerID == 1 && console.log('onScroll.calcImpliedRepositioningData: cradleState', cradleState);\n        _this.calcImpliedRepositioningData('onScroll');\n        if (cradleState == 'repositioningRender') stateHandler.setCradleState('repositioningContinuation');\n      }\n    }\n    _this._scrolltimerid = setTimeout(function () {\n      _this.onAfterScroll();\n    }, ONAFTERSCROLL_TIMEOUT);\n    return false;\n  };\n  this.onAfterScroll = function () {\n    _this.isScrolling = false;\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter2.stateHandler,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      serviceHandler = _this$cradleParameter2.serviceHandler;\n    // const ViewportContextProperties = this.cradleParameters.ViewportContextPropertiesRef.current,\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var cradleState = stateHandler.cradleStateRef.current;\n    switch (cradleState) {\n      case 'repositioningRender':\n      case 'repositioningContinuation':\n        {\n          _this.updateBlockScrollPos();\n          var repositioningFlagCallback = serviceHandler.callbacks.repositioningFlagCallback;\n          repositioningFlagCallback && repositioningFlagCallback(false);\n          stateHandler.setCradleState('finishreposition');\n          break;\n        }\n      default:\n        {\n          if (_this.scrollData.start != _this.scrollData.current || _this.scrollData.current != _this.scrollData.previous) {\n            if (stateHandler.isMountedRef.current) {\n              _this.updateReferenceData();\n            }\n          }\n          break;\n        }\n    }\n    var cache = cradleInheritedProperties.cache;\n    if (cache == 'keepload') {\n      contentHandler.pareCacheToMax();\n    }\n  };\n  // after scroll, but not after repositioning\n  this.updateReferenceData = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      stateHandler = _this$cradleParameter3.stateHandler,\n      layoutHandler = _this$cradleParameter3.layoutHandler;\n    var cradleSpecs = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    if (!stateHandler.isMountedRef.current) return;\n    var cradleElements = layoutHandler.elements;\n    var axisElement = cradleElements.axisRef.current,\n      viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var axisViewportPixelOffset;\n    if (cradleSpecs.orientation == 'vertical') {\n      axisViewportPixelOffset = axisElement.offsetTop + scrollblockElement.offsetTop - viewportElement.scrollTop;\n    } else {\n      axisViewportPixelOffset = axisElement.offsetLeft + scrollblockElement.offsetLeft - viewportElement.scrollLeft;\n    }\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisViewportPixelOffset = axisViewportPixelOffset;\n    if (!ViewportContextProperties.isResizing) {\n      _this.updateBlockScrollPos();\n    }\n  };\n  // called from finishreposition state change call above\n  // called from updateReferenceData\n  this.updateBlockScrollPos = function () {\n    var cradleSpecs = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current;\n    var layoutHandler = _this.cradleParameters.handlersRef.current.layoutHandler;\n    var cradlePositionData = layoutHandler.cradlePositionData;\n    var viewportElement = ViewportContextProperties.elementRef.current;\n    if (!(viewportElement.clientWidth == 0 && viewportElement.clientHeight == 0)) {\n      // in cache\n      if (cradleSpecs.orientation == 'vertical') {\n        cradlePositionData.blockScrollPos = viewportElement.scrollTop;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollLeft;\n      } else {\n        cradlePositionData.blockScrollPos = viewportElement.scrollLeft;\n        cradlePositionData.blockXScrollPos = viewportElement.scrollTop;\n      }\n    }\n  };\n  this.calcImpliedRepositioningData = function (source) {\n    var ViewportContextProperties = _this.cradleParameters.ViewportContextPropertiesRef.current,\n      cradleSpecs = _this.cradleParameters.cradleInheritedPropertiesRef.current,\n      virtualListProps = _this.cradleParameters.cradleInternalPropertiesRef.current.virtualListProps;\n    var viewportElement = ViewportContextProperties.elementRef.current,\n      scrollblockElement = viewportElement.firstChild;\n    var orientation = cradleSpecs.orientation;\n    var crosscount = virtualListProps.crosscount,\n      listsize = virtualListProps.size;\n    var scrollPos, cellLength, scrollblockOffset;\n    if (orientation == 'vertical') {\n      scrollPos = viewportElement.scrollTop;\n      cellLength = cradleSpecs.cellHeight + cradleSpecs.gap;\n      scrollblockOffset = scrollblockElement.offsetTop;\n    } else {\n      scrollPos = viewportElement.scrollLeft;\n      cellLength = cradleSpecs.cellWidth + cradleSpecs.gap;\n      scrollblockOffset = scrollblockElement.offsetLeft;\n    }\n    // console.log('running calcImpliedRepositioningData: source, scrollPos, scrollblockOffset\\n',\n    //     source, scrollPos, scrollblockOffset)\n    var axisPixelOffset = cellLength - (scrollPos + scrollblockOffset) % cellLength;\n    if (axisPixelOffset == cellLength + cradleSpecs.padding) {\n      axisPixelOffset = 0;\n    }\n    var axisRowPosition = Math.ceil((scrollPos - cradleSpecs.padding) / cellLength);\n    var axisReferencePosition = axisRowPosition * crosscount;\n    axisReferencePosition = Math.min(axisReferencePosition, listsize - 1);\n    var diff = axisReferencePosition % crosscount;\n    axisReferencePosition -= diff;\n    if (axisReferencePosition == 0) axisPixelOffset = 0; // defensive\n    var cradlePositionData = _this.cradleParameters.handlersRef.current.layoutHandler.cradlePositionData;\n    cradlePositionData.targetAxisReferencePosition = axisReferencePosition;\n    cradlePositionData.targetAxisViewportPixelOffset = axisPixelOffset;\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = ScrollHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBQ29ELGFBQWEsQ0FBOUVDLGtCQUFrQjtJQUUxQkEsa0JBQWtCLENBQUNpRCwyQkFBMkIsR0FBR0gscUJBQXFCO0lBQ3RFOUMsa0JBQWtCLENBQUM2Qiw2QkFBNkIsR0FBR1ksZUFBZTtFQUV0RSxDQUFDO0VBbFpHLElBQUksQ0FBQ3BHLGdCQUFnQixHQUFHQSxnQkFBZ0I7QUFFNUMsQ0FBQztBQU5MNkcsa0JBQUEsR0FBQTlHLGFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zY3JvbGxoYW5kbGVyLnRzeD9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjcm9sbGhhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSByZXNwb25zZSB0byBzY3JvbGxpbmcuIEl0IGFsc28gdHJpZ2dlcnMgYW4gb25BZnRlclNjcm9sbCBldmVudCAoYWZ0ZXIgYSB0aW1lb3V0KVxuICAgIEl0J3MgbWFpbiBqb2IgaXMgdG8gbWFpbnRhaW4gcmVjb3JkcyBvZiBzY3JvbGxQb3MsIHRhcmdldEF4aXNSZWZlcmVuY2VQb3NpdGlvbiwgYW5kIFxuICAgICAgICB0YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldFxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjcmFkbGVQYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaU9Tc2Nyb2xsdGltZXJpZFxuICAgIHByaXZhdGUgX2lPU3NldFRpbWVvdXRUaW1lcmlkXG5cbiAgICBwcml2YXRlIF9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0XG5cbiAgICBwcml2YXRlIF9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICBwdWJsaWMgaU9Tb25TY3JvbGwgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5pbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzSU9Tc2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lzSU9Tc2Nyb2xsaW5nID0gdHJ1ZVxuXG4gICAgICAgICAgICB0aGlzLl9vbklPU29uQWZ0ZXJTY3JvbGxUaW1lb3V0ID0gMTAwMCAvLyBpT1Mgc29tZXRpbWVzIGxpa2VzIHRvIHBhdXNlIGJlZm9yZSBjb21tZW5jaW5nIHNjcm9sbGluZ1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dClcblxuICAgICAgICAgICAgdGhpcy5faU9Tc2V0VGltZW91dFRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fb25JT1NvbkFmdGVyU2Nyb2xsVGltZW91dCA9IDI1MCAvLyBiYWNrIHRvIG1vcmUgcmVzcG9uc2l2ZSBvbmNlIHVuZGVyd2F5XG4gICAgICAgICAgICB9LDkwMClcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faU9Tc2Nyb2xsdGltZXJpZClcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBsZXQgc2Nyb2xsYmxvY2tMZW5ndGgsIHZpZXdwb3J0TGVuZ3RoLCBibG9ja1Njcm9sbFBvcywgc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHNjcm9sbGJsb2NrTGVuZ3RoID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgICAgICAgYmxvY2tTY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3BcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzY3JvbGxibG9ja0xlbmd0aCA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxXaWR0aFxuICAgICAgICAgICAgdmlld3BvcnRMZW5ndGggPSAgdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICBibG9ja1Njcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICBzY3JvbGxibG9ja09mZnNldCA9IHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRMZWZ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoKCBibG9ja1Njcm9sbFBvcyAtIHNjcm9sbGJsb2NrT2Zmc2V0KSA8IDApIHx8IC8vIG92ZXJzaG9vdCBzdGFydFxuICAgICAgICAgICAgKHNjcm9sbGJsb2NrTGVuZ3RoIDwgKGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXQgKyB2aWV3cG9ydExlbmd0aCkpKSB7IC8vIG92ZXJzaG9vdCBlbmRcblxuICAgICAgICAgICAgdGhpcy5pT1NvbkFmdGVyU2Nyb2xsKCkgLy8gaW1tZWRpYXRlIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2lPU3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaU9Tb25BZnRlclNjcm9sbCgpIC8vIGRlZmVycmVkIGhhbHQgYW5kIGFkanVzdFxuXG4gICAgICAgICAgICB9LHRoaXMuX29uSU9Tb25BZnRlclNjcm9sbFRpbWVvdXQpXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaU9Tb25BZnRlclNjcm9sbCA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLl9pc0lPU3Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5lbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmxvY2tFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50LmZpcnN0Q2hpbGRcblxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQub3JpZW50YXRpb25cblxuICAgICAgICBjb25zdCBzY3JvbGxibG9ja09mZnNldCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5vZmZzZXRUb3A6XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICBjb25zdCBibG9ja1Njcm9sbFBvcyA9XG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyk/XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDpcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS50b3AgPSBudWxsXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3JpZW50YXRpb24gPT0gaG9yaXpvbnRhbFxuXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdCA9IGJsb2NrU2Nyb2xsUG9zIC0gc2Nyb2xsYmxvY2tPZmZzZXRcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudC5zdHlsZS5sZWZ0ID0gbnVsbFxuXG4gICAgICAgIH1cblxuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgc2Nyb2xsRGF0YSA9IHtzdGFydDowLCBjdXJyZW50OjAsIHByZXZpb3VzOjAsIHByZXZpb3VzdXBkYXRlOjAsIGN1cnJlbnR1cGRhdGU6MH1cblxuICAgIHByaXZhdGUgX3Njcm9sbHRpbWVyaWQgPSBudWxsXG5cbiAgICBwcml2YXRlIGlzU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgIHB1YmxpYyByZXNldFNjcm9sbERhdGEgPSAoc2Nyb2xsUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxEYXRhIH0gPSB0aGlzXG4gICAgICAgIHNjcm9sbERhdGEuc3RhcnQgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5jdXJyZW50ID0gXG4gICAgICAgIHNjcm9sbERhdGEucHJldmlvdXMgPSBcbiAgICAgICAgc2Nyb2xsRGF0YS5wcmV2aW91c3VwZGF0ZSA9IFxuICAgICAgICBzY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNjcm9sbCA9IChlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBcblxuICAgICAgICAgICAgc2Nyb2xsZXJJRCwgLy8gZGVidWdcbiAgICAgICAgICAgIE9OQUZURVJTQ1JPTExfVElNRU9VVCBcblxuICAgICAgICB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50XG4gICAgICAgIC8vIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50Lm9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uQ3VycmVudCA9IFxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpP1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A6XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICBjb25zdCBzY3JvbGxYUG9zaXRpb25DdXJyZW50ID0gXG4gICAgICAgICAgICAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKT9cbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wOlxuICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Njcm9sbHRpbWVyaWQpXG5cbiAgICAgICAgaWYgKCh2aWV3cG9ydEVsZW1lbnQuY2xpZW50V2lkdGggPT0gMCAgJiYgdmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA9PSAwKSkgey8vIGluIGNhY2hlXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsUG9zaXRpb25DdXJyZW50IDwgMCkgeyAvLyBmb3IgU2FmYXJpXG5cbiAgICAgICAgICAgIHJldHVybiBcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzaWduYWxzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudC5pbnRlcnJ1cHRIYW5kbGVyXG5cbiAgICAgICAgaWYgKHNpZ25hbHMucGF1c2VTY3JvbGxpbmdFZmZlY3RzKSB7XG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNTY3JvbGxpbmcpIHtcblxuICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGF0YS5zdGFydCA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxEYXRhLmN1cnJlbnR1cGRhdGUgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBsYXlvdXRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIC8vIGtlZXAgdXAgdG8gZGF0ZSBpbiBjYXNlIG9mIHJlcGFyZW50aW5nIGludGVycnVwdFxuICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tTY3JvbGxQb3MgPSBzY3JvbGxQb3NpdGlvbkN1cnJlbnRcbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFBvcyA9IHNjcm9sbFhQb3NpdGlvbkN1cnJlbnRcblxuICAgICAgICB0aGlzLnNjcm9sbERhdGEucHJldmlvdXMgPSB0aGlzLnNjcm9sbERhdGEuY3VycmVudFxuICAgICAgICB0aGlzLnNjcm9sbERhdGEuY3VycmVudCA9IHNjcm9sbFBvc2l0aW9uQ3VycmVudFxuXG4gICAgICAgIGNvbnN0IHtzdGF0ZUhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlU3RhdGUgPSBzdGF0ZUhhbmRsZXIuY3JhZGxlU3RhdGVSZWYuY3VycmVudFxuXG4gICAgICAgIC8vIGNvbnN0IHsgY29udGVudEhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGlmICghVmlld3BvcnRDb250ZXh0UHJvcGVydGllcy5pc1Jlc2l6aW5nKSB7XG5cbiAgICAgICAgICAgIGlmICgoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSB8fCAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKSkge1xuICAgICAgICAgICAgLy8gaWYgKFsncmVwb3NpdGlvbmluZ0NvbnRpbnVhdGlvbicsJ3JlcG9zaXRpb25pbmdSZW5kZXInLCdmaW5pc2hyZXBvc2l0aW9uJ10uaW5jbHVkZXMoY3JhZGxlU3RhdGUpKSB7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxlcklEID09IDEgJiYgY29uc29sZS5sb2coJ29uU2Nyb2xsLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGE6IGNyYWRsZVN0YXRlJywgY3JhZGxlU3RhdGUpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEoJ29uU2Nyb2xsJylcbiAgICAgICAgICAgICAgICBpZiAoY3JhZGxlU3RhdGUgPT0gJ3JlcG9zaXRpb25pbmdSZW5kZXInKSBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlcG9zaXRpb25pbmdDb250aW51YXRpb24nKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbHRpbWVyaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5vbkFmdGVyU2Nyb2xsKClcblxuICAgICAgICB9LE9OQUZURVJTQ1JPTExfVElNRU9VVClcblxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBvbkFmdGVyU2Nyb2xsID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBjb250ZW50SGFuZGxlciwgc2VydmljZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudCxcbiAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVTdGF0ZSA9IHN0YXRlSGFuZGxlci5jcmFkbGVTdGF0ZVJlZi5jdXJyZW50XG5cbiAgICAgICAgc3dpdGNoIChjcmFkbGVTdGF0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nUmVuZGVyJzogXG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uaW5nQ29udGludWF0aW9uJzpcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQmxvY2tTY3JvbGxQb3MoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIH0gPSBzZXJ2aWNlSGFuZGxlci5jYWxsYmFja3NcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrICYmIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2soZmFsc2UpXG4gICAgICAgICAgICAgICAgc3RhdGVIYW5kbGVyLnNldENyYWRsZVN0YXRlKCdmaW5pc2hyZXBvc2l0aW9uJylcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcblxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5zY3JvbGxEYXRhLnN0YXJ0ICE9IHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50KSB8fCBcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Nyb2xsRGF0YS5jdXJyZW50ICE9IHRoaXMuc2Nyb2xsRGF0YS5wcmV2aW91cykpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVmZXJlbmNlRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1xuXG4gICAgICAgIGlmIChjYWNoZSA9PSAna2VlcGxvYWQnKSB7XG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5wYXJlQ2FjaGVUb01heCgpXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGFmdGVyIHNjcm9sbCwgYnV0IG5vdCBhZnRlciByZXBvc2l0aW9uaW5nXG4gICAgcHJpdmF0ZSB1cGRhdGVSZWZlcmVuY2VEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyLCBsYXlvdXRIYW5kbGVyIH0gXG4gICAgICAgICAgICA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgY3JhZGxlU3BlY3MgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5WaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBpZiAoIXN0YXRlSGFuZGxlci5pc01vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgY3JhZGxlRWxlbWVudHMgPSBsYXlvdXRIYW5kbGVyLmVsZW1lbnRzXG5cbiAgICAgICAgY29uc3QgYXhpc0VsZW1lbnQgPSBjcmFkbGVFbGVtZW50cy5heGlzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgbGV0IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG4gICAgICAgIGlmIChjcmFkbGVTcGVjcy5vcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gXG4gICAgICAgICAgICAgICAgYXhpc0VsZW1lbnQub2Zmc2V0VG9wICsgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldFRvcCAtIHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYXhpc1ZpZXdwb3J0UGl4ZWxPZmZzZXQgPSBcbiAgICAgICAgICAgICAgICBheGlzRWxlbWVudC5vZmZzZXRMZWZ0ICsgc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnQgLSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsTGVmdFxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzVmlld3BvcnRQaXhlbE9mZnNldCA9IGF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0XG5cbiAgICAgICAgaWYgKCFWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmlzUmVzaXppbmcpIHtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Njcm9sbFBvcygpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gZmluaXNocmVwb3NpdGlvbiBzdGF0ZSBjaGFuZ2UgY2FsbCBhYm92ZVxuICAgIC8vIGNhbGxlZCBmcm9tIHVwZGF0ZVJlZmVyZW5jZURhdGFcbiAgICBwcml2YXRlIHVwZGF0ZUJsb2NrU2Nyb2xsUG9zID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNyYWRsZVNwZWNzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7bGF5b3V0SGFuZGxlcn0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gbGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMuZWxlbWVudFJlZi5jdXJyZW50XG5cbiAgICAgICAgaWYgKCEoKHZpZXdwb3J0RWxlbWVudC5jbGllbnRXaWR0aCA9PSAwKSAgJiYgKHZpZXdwb3J0RWxlbWVudC5jbGllbnRIZWlnaHQgPT0gMCkpKSB7Ly8gaW4gY2FjaGVcblxuICAgICAgICAgICAgaWYgKGNyYWRsZVNwZWNzLm9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICBjcmFkbGVQb3NpdGlvbkRhdGEuYmxvY2tYU2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS5ibG9ja1Njcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLmJsb2NrWFNjcm9sbFBvcyA9IHZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3BcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBjYWxjSW1wbGllZFJlcG9zaXRpb25pbmdEYXRhID0gKHNvdXJjZSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IFZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuVmlld3BvcnRDb250ZXh0UHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgY3JhZGxlU3BlY3MgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgeyB2aXJ0dWFsTGlzdFByb3BzIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydENvbnRleHRQcm9wZXJ0aWVzLmVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrRWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudC5maXJzdENoaWxkXG5cbiAgICAgICAgY29uc3QgeyBvcmllbnRhdGlvbiB9ID0gY3JhZGxlU3BlY3NcblxuICAgICAgICBjb25zdCB7IGNyb3NzY291bnQsIHNpemU6bGlzdHNpemUgfSA9IHZpcnR1YWxMaXN0UHJvcHNcblxuICAgICAgICBsZXQgc2Nyb2xsUG9zLCBjZWxsTGVuZ3RoLCBzY3JvbGxibG9ja09mZnNldFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSB2aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBjZWxsTGVuZ3RoID0gY3JhZGxlU3BlY3MuY2VsbEhlaWdodCArIGNyYWRsZVNwZWNzLmdhcFxuICAgICAgICAgICAgc2Nyb2xsYmxvY2tPZmZzZXQgPSBzY3JvbGxibG9ja0VsZW1lbnQub2Zmc2V0VG9wXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gdmlld3BvcnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIGNlbGxMZW5ndGggPSBjcmFkbGVTcGVjcy5jZWxsV2lkdGggKyBjcmFkbGVTcGVjcy5nYXBcbiAgICAgICAgICAgIHNjcm9sbGJsb2NrT2Zmc2V0ID0gc2Nyb2xsYmxvY2tFbGVtZW50Lm9mZnNldExlZnRcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3J1bm5pbmcgY2FsY0ltcGxpZWRSZXBvc2l0aW9uaW5nRGF0YTogc291cmNlLCBzY3JvbGxQb3MsIHNjcm9sbGJsb2NrT2Zmc2V0XFxuJyxcbiAgICAgICAgLy8gICAgIHNvdXJjZSwgc2Nyb2xsUG9zLCBzY3JvbGxibG9ja09mZnNldClcblxuICAgICAgICBsZXQgYXhpc1BpeGVsT2Zmc2V0ID0gY2VsbExlbmd0aCAtICgoc2Nyb2xsUG9zICsgc2Nyb2xsYmxvY2tPZmZzZXQpICUgY2VsbExlbmd0aClcbiAgICAgICAgaWYgKGF4aXNQaXhlbE9mZnNldCA9PSAoY2VsbExlbmd0aCArIGNyYWRsZVNwZWNzLnBhZGRpbmcpKSB7XG4gICAgICAgICAgICBheGlzUGl4ZWxPZmZzZXQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBheGlzUm93UG9zaXRpb24gPSBNYXRoLmNlaWwoKHNjcm9sbFBvcyAtIGNyYWRsZVNwZWNzLnBhZGRpbmcpL2NlbGxMZW5ndGgpXG5cbiAgICAgICAgbGV0IGF4aXNSZWZlcmVuY2VQb3NpdGlvbiA9IGF4aXNSb3dQb3NpdGlvbiAqIGNyb3NzY291bnRcbiAgICAgICAgYXhpc1JlZmVyZW5jZVBvc2l0aW9uID0gTWF0aC5taW4oYXhpc1JlZmVyZW5jZVBvc2l0aW9uLGxpc3RzaXplIC0gMSlcblxuICAgICAgICBjb25zdCBkaWZmID0gYXhpc1JlZmVyZW5jZVBvc2l0aW9uICUgY3Jvc3Njb3VudFxuICAgICAgICBheGlzUmVmZXJlbmNlUG9zaXRpb24gLT0gZGlmZlxuXG4gICAgICAgIGlmIChheGlzUmVmZXJlbmNlUG9zaXRpb24gPT0gMCkgYXhpc1BpeGVsT2Zmc2V0ID0gMCAvLyBkZWZlbnNpdmVcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBvc2l0aW9uRGF0YSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQubGF5b3V0SGFuZGxlclxuXG4gICAgICAgIGNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24gPSBheGlzUmVmZXJlbmNlUG9zaXRpb25cbiAgICAgICAgY3JhZGxlUG9zaXRpb25EYXRhLnRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0ID0gYXhpc1BpeGVsT2Zmc2V0XG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlNjcm9sbEhhbmRsZXIiLCJjcmFkbGVQYXJhbWV0ZXJzIiwiX3RoaXMiLCJfaXNJT1NzY3JvbGxpbmciLCJpT1NvblNjcm9sbCIsInNpZ25hbHMiLCJoYW5kbGVyc1JlZiIsImN1cnJlbnQiLCJpbnRlcnJ1cHRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiX29uSU9Tb25BZnRlclNjcm9sbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfaU9Tc2V0VGltZW91dFRpbWVyaWQiLCJzZXRUaW1lb3V0IiwiVmlld3BvcnRDb250ZXh0UHJvcGVydGllcyIsIlZpZXdwb3J0Q29udGV4dFByb3BlcnRpZXNSZWYiLCJ2aWV3cG9ydEVsZW1lbnQiLCJlbGVtZW50UmVmIiwiX2lPU3Njcm9sbHRpbWVyaWQiLCJvcmllbnRhdGlvbiIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYiLCJzY3JvbGxibG9ja0VsZW1lbnQiLCJmaXJzdENoaWxkIiwic2Nyb2xsYmxvY2tMZW5ndGgiLCJ2aWV3cG9ydExlbmd0aCIsImJsb2NrU2Nyb2xsUG9zIiwic2Nyb2xsYmxvY2tPZmZzZXQiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxUb3AiLCJvZmZzZXRUb3AiLCJzY3JvbGxXaWR0aCIsIm9mZnNldFdpZHRoIiwic2Nyb2xsTGVmdCIsIm9mZnNldExlZnQiLCJpT1NvbkFmdGVyU2Nyb2xsIiwic3R5bGUiLCJvdmVyZmxvdyIsInRvcCIsImxlZnQiLCJzY3JvbGxEYXRhIiwic3RhcnQiLCJwcmV2aW91cyIsInByZXZpb3VzdXBkYXRlIiwiY3VycmVudHVwZGF0ZSIsIl9zY3JvbGx0aW1lcmlkIiwiaXNTY3JvbGxpbmciLCJyZXNldFNjcm9sbERhdGEiLCJzY3JvbGxQb3NpdGlvbiIsIm9uU2Nyb2xsIiwiZSIsIl90aGlzJGNyYWRsZVBhcmFtZXRlciIsInNjcm9sbGVySUQiLCJPTkFGVEVSU0NST0xMX1RJTUVPVVQiLCJjdXJyZW50VGFyZ2V0Iiwic2Nyb2xsUG9zaXRpb25DdXJyZW50Iiwic2Nyb2xsWFBvc2l0aW9uQ3VycmVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibGF5b3V0SGFuZGxlciIsImNyYWRsZVBvc2l0aW9uRGF0YSIsImJsb2NrWFNjcm9sbFBvcyIsInN0YXRlSGFuZGxlciIsImNyYWRsZVN0YXRlIiwiY3JhZGxlU3RhdGVSZWYiLCJpc1Jlc2l6aW5nIiwiY29uc29sZSIsImxvZyIsImNhbGNJbXBsaWVkUmVwb3NpdGlvbmluZ0RhdGEiLCJzZXRDcmFkbGVTdGF0ZSIsIm9uQWZ0ZXJTY3JvbGwiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY29udGVudEhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJ1cGRhdGVCbG9ja1Njcm9sbFBvcyIsInJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJpc01vdW50ZWRSZWYiLCJ1cGRhdGVSZWZlcmVuY2VEYXRhIiwiY2FjaGUiLCJwYXJlQ2FjaGVUb01heCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJjcmFkbGVTcGVjcyIsImNyYWRsZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJheGlzRWxlbWVudCIsImF4aXNSZWYiLCJheGlzVmlld3BvcnRQaXhlbE9mZnNldCIsInRhcmdldEF4aXNWaWV3cG9ydFBpeGVsT2Zmc2V0Iiwic291cmNlIiwidmlydHVhbExpc3RQcm9wcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImNyb3NzY291bnQiLCJsaXN0c2l6ZSIsInNpemUiLCJzY3JvbGxQb3MiLCJjZWxsTGVuZ3RoIiwiY2VsbEhlaWdodCIsImdhcCIsImNlbGxXaWR0aCIsImF4aXNQaXhlbE9mZnNldCIsInBhZGRpbmciLCJheGlzUm93UG9zaXRpb24iLCJNYXRoIiwiY2VpbCIsImF4aXNSZWZlcmVuY2VQb3NpdGlvbiIsIm1pbiIsImRpZmYiLCJ0YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/scrollhandler.tsx\n")},"./src/cradle/servicehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// servicehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module fields service requests from the host. There are two forms\n    - streaming from the scroller to the host\n    - function calls from the user to the scroller\n\n    For the list of data streams, see the constructor.\n\n    The function calls avaiable to the host are:\n\n        scrollToIndex,\n        reload,\n        setListsize,\n        clearCache,\n\n        getCacheIndexMap,\n        getCacheItemMap,\n        getCradleIndexMap,\n\n        insertIndex,\n        removeIndex,\n        moveIndex,\n        remapIndexes,\n    \n    The functions listed are defined in this module.\n\n    There are important supporting functions for these in cacheAPI and contentHandler. stateHandler is\n    often invoked by service functions to change Cradle state upon servicing requests.\n*/\nvar isBlank = function isBlank(value) {\n  var testvalue = value !== null && value !== void 0 ? value : \'\';\n  return testvalue === \'\';\n};\nvar isNumber = function isNumber(value) {\n  return !isNaN(Number(value)) && !isNaN(parseInt(value));\n};\nvar isInteger = function isInteger(value) {\n  var test = +value;\n  return isNumber(value) && Math.floor(test) == test;\n};\nvar minValue = function minValue(value, _minValue) {\n  if (!isInteger(value) || !isInteger(_minValue)) return false;\n  var testvalue = +value;\n  var testMinValue = +_minValue;\n  return testvalue >= testMinValue;\n};\nvar maxValue = function maxValue(value, _maxValue) {\n  if (!isInteger(value) || !isInteger(_maxValue)) return false;\n  var testvalue = +value;\n  var testMaxValue = +_maxValue;\n  return testvalue <= testMaxValue;\n};\nvar errorMessages = {\n  scrollToIndex: \'integer: required, greater than or equal to 0\',\n  setListsize: \'integer: required, greater than or equal to 0\',\n  insertFrom: \'insertFrom - integer: required, greater than or equal to 0\',\n  insertRange: \'insertRange - blank, or integer greater than or equal to the "from" index\',\n  removeFrom: \'removeFrom - integer: required, greater than or equal to 0\',\n  removeRange: \'removeRange - blank, or integer greater than or equal to the "from" index\',\n  moveFrom: \'moveFrom - integer: required, greater than or equal to 0\',\n  moveRange: \'moveRange - blank, or integer greater than or equal to the "from" index\',\n  moveTo: \'moveTo - integer: required, greater than or equal to 0\'\n};\nvar ServiceHandler = /*#__PURE__*/_createClass(function ServiceHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, ServiceHandler);\n  // ========================[ GENERAL ]============================\n  this.reload = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    var interruptHandler = _this.cradleParameters.handlersRef.current.interruptHandler;\n    interruptHandler.pauseInterrupts();\n    stateHandler.setCradleState(\'reload\');\n  };\n  this.scrollToIndex = function (index) {\n    var isInvalid = !isInteger(index) || !minValue(index, 0);\n    index = +index;\n    if (isInvalid) {\n      console.log(\'RIGS ERROR scrollToIndex(index)):\', index, errorMessages.scrollToIndex);\n      return;\n    }\n    var signals = _this.cradleParameters.handlersRef.current.interruptHandler.signals;\n    var _this$cradleParameter = _this.cradleParameters.handlersRef.current,\n      layoutHandler = _this$cradleParameter.layoutHandler,\n      stateHandler = _this$cradleParameter.stateHandler;\n    signals.pauseScrollingEffects = true;\n    layoutHandler.cradlePositionData.targetAxisReferencePosition = index;\n    stateHandler.setCradleState(\'scrollto\');\n  };\n  this.setListsize = function (newlistsize) {\n    var isInvalid = !isInteger(newlistsize) || !minValue(newlistsize, 0);\n    newlistsize = +newlistsize;\n    if (isInvalid) {\n      console.log(\'RIGS ERROR setListsize(newlistsize)\', newlistsize, errorMessages.setListsize);\n      return;\n    }\n    var _this$cradleParameter2 = _this.cradleParameters.handlersRef.current,\n      cacheAPI = _this$cradleParameter2.cacheAPI,\n      contentHandler = _this$cradleParameter2.contentHandler,\n      stateHandler = _this$cradleParameter2.stateHandler;\n    var _this$callbacks = _this.callbacks,\n      deleteListCallback = _this$callbacks.deleteListCallback,\n      changeListsizeCallback = _this$callbacks.changeListsizeCallback;\n    var currentlistsize = _this.cradleParameters.cradleInternalPropertiesRef.current.virtualListProps.size;\n    var cache = _this.cradleParameters.cradleInheritedPropertiesRef.current.cache;\n    var dListCallback;\n    if (deleteListCallback) {\n      dListCallback = function dListCallback(deleteList) {\n        deleteListCallback(\'change list size intervention\', deleteList);\n      };\n    }\n    contentHandler.updateVirtualListSpecs(newlistsize);\n    cacheAPI.changeCacheListsize(newlistsize, dListCallback, changeListsizeCallback);\n    cacheAPI.renderPortalLists();\n    if (cache == \'preload\' && newlistsize > currentlistsize) {\n      stateHandler.setCradleState(\'startpreload\');\n    }\n  };\n  // ======================[ GET SNAPSHOTS ]========================\n  this.getCacheIndexMap = function () {\n    var cacheAPI = _this.cradleParameters.handlersRef.current.cacheAPI;\n    return cacheAPI.getCacheIndexMap();\n  };\n  this.getCacheItemMap = function () {\n    var cacheAPI = _this.cradleParameters.handlersRef.current.cacheAPI;\n    return cacheAPI.getCacheItemMap();\n  };\n  this.getCradleIndexMap = function () {\n    var _this$cradleParameter3 = _this.cradleParameters.handlersRef.current,\n      cacheAPI = _this$cradleParameter3.cacheAPI,\n      contentHandler = _this$cradleParameter3.contentHandler;\n    var modelIndexList = contentHandler.getModelIndexList();\n    return cacheAPI.getCradleIndexMap(modelIndexList);\n  };\n  // =================[ CACHE MANAGEMENT REQUESTS ]==================\n  this.clearCache = function () {\n    var stateHandler = _this.cradleParameters.handlersRef.current.stateHandler;\n    stateHandler.setCradleState(\'clearcache\');\n  };\n  // itemID set to null deletes the indexed item\n  // itemID set to undefined replaces the indexed item\n  // the main purpose is to allow itemsIDs to be remapped to new indexes\n  // operations are on existing cache items only\n  this.remapIndexes = function (changeMap) {\n    if (changeMap.size == 0) return []; // nothing to do\n    var _this$cradleParameter4 = _this.cradleParameters.handlersRef.current,\n      cacheAPI = _this$cradleParameter4.cacheAPI,\n      contentHandler = _this$cradleParameter4.contentHandler,\n      stateHandler = _this$cradleParameter4.stateHandler;\n    var itemMetadataMap = cacheAPI.itemMetadataMap,\n      indexToItemIDMap = cacheAPI.indexToItemIDMap,\n      itemSet = cacheAPI.itemSet;\n    var indexesToDeleteList = [];\n    var indexesToReplaceItemIDList = [];\n    var partitionItemsToReplaceList = [];\n    var changeIndexToItemIDMap = new Map();\n    var errorEntriesMap = new Map();\n    // =====================[ PREPARE ]======================\n    // -----------------------[ isolate indexes for which items should be replaced ]--------------\n    var workingChangeMap = new Map();\n    changeMap.forEach(function (itemID, index) {\n      if (itemID === undefined) {\n        if (indexToItemIDMap.has(index)) {\n          var cacheItemID = indexToItemIDMap.get(index);\n          indexesToReplaceItemIDList.push(index);\n          if (!(cacheItemID === undefined)) {\n            // ignore non-existent indexes\n            var _itemMetadataMap$get = itemMetadataMap.get(cacheItemID),\n              partitionID = _itemMetadataMap$get.partitionID;\n            partitionItemsToReplaceList.push({\n              partitionID: partitionID,\n              itemID: cacheItemID\n            });\n          }\n        } else {\n          errorEntriesMap.set(index, \'index to replace is not in cache\');\n        }\n      } else {\n        workingChangeMap.set(index, itemID);\n      }\n    });\n    indexesToReplaceItemIDList.forEach(function (index) {\n      indexToItemIDMap["delete"](index);\n    });\n    // ------------ filter out inoperable indexes and itemIDs ------------\n    var itemsToReplaceSet = new Set();\n    partitionItemsToReplaceList.forEach(function (obj) {\n      itemsToReplaceSet.add(obj.itemID);\n    });\n    // const itemsToReplaceList = Array.from(itemsToReplaceSet)\n    workingChangeMap.forEach(function (itemID, index) {\n      if (itemID === null || itemID === undefined) {\n        indexesToDeleteList.push(index);\n      } else {\n        if (typeof itemID == \'string\') {\n          errorEntriesMap.set(index, \'itemID is a string\');\n        } else if (!Number.isInteger(itemID)) {\n          errorEntriesMap.set(index, \'itemID is not an integer\');\n        } else if (!indexToItemIDMap.has(index)) {\n          errorEntriesMap.set(index, \'index not in cache\');\n        } else if (indexToItemIDMap.get(index) == itemID) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " has not changed"));\n        } else if (!itemMetadataMap.has(itemID) || itemsToReplaceSet.has(itemID)) {\n          errorEntriesMap.set(index, "target itemID ".concat(itemID, " not in cache, or has been removed"));\n        } else {\n          changeIndexToItemIDMap.set(index, itemID);\n        }\n      }\n    });\n    // -------------- filter out duplicate itemIDs ------------\n    var mapsize = changeIndexToItemIDMap.size;\n    var itemIDSet = new Set(changeIndexToItemIDMap.values());\n    var itemsetsize = itemIDSet.size;\n    if (mapsize != itemsetsize) {\n      // there must be duplicate itemIDs\n      var itemIDCountMap = new Map();\n      changeIndexToItemIDMap.forEach(function (itemID) {\n        if (!itemIDCountMap.has(itemID)) {\n          itemIDCountMap.set(itemID, 1);\n        } else {\n          var count = itemIDCountMap.get(itemID);\n          itemIDCountMap.set(itemID, ++count);\n        }\n      });\n      var duplicateItemsMap = new Map();\n      itemIDCountMap.forEach(function (count, itemID) {\n        if (count > 1) {\n          duplicateItemsMap.set(itemID, count);\n        }\n      });\n      var duplicatesToRemoveList = [];\n      changeIndexToItemIDMap.forEach(function (itemID, index) {\n        if (duplicateItemsMap.has(itemID)) {\n          duplicatesToRemoveList.push(index);\n        }\n      });\n      duplicatesToRemoveList.forEach(function (index) {\n        var itemID = changeIndexToItemIDMap.get(index);\n        var count = duplicateItemsMap.get(itemID);\n        errorEntriesMap.set(index, "target itemID ".concat(itemID, " has duplicates (").concat(count, ")"));\n        changeIndexToItemIDMap["delete"](index);\n      });\n    }\n    // ------------ capture map before changes ----------\n    // ... this map is used later to identify orphaned item and index cache records for deletion\n    // from the list of changes\n    // both sides of change map...\n    var originalMap = new Map(); // index => itemID; before change\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      originalMap.set(index, indexToItemIDMap.get(index)); // index to be mapped\n      originalMap.set(itemMetadataMap.get(itemID).index, itemID); // target itemID\n    });\n    // ... and from the list of indexes to be deleted\n    indexesToDeleteList.forEach(function (index) {\n      originalMap.set(index, indexToItemIDMap.get(index));\n    });\n    // ======================[ CACHE OPERATIONS ]================\n    // --------------- delete listed indexes ---------\n    // for indexes set to null or undefined\n    // associated itemID\'s will be orphaned, but could be remapped.\n    // orphans are resolved below\n    if (indexesToDeleteList.length) {\n      indexesToDeleteList.forEach(function (index) {\n        indexToItemIDMap["delete"](index);\n      });\n    }\n    // ----------- apply filtered changes to cache index map and itemID map ----------\n    // at this point every remaining index listed will change its mapping\n    // const processedMap = new Map() // index => itemID; change has been applied\n    var processedIndexList = [];\n    // make changes\n    changeIndexToItemIDMap.forEach(function (itemID, index) {\n      indexToItemIDMap.set(index, itemID); // modiication applied, part 1\n      var itemdata = itemMetadataMap.get(itemID);\n      itemdata.index = index; // modification applied, part 2\n      // processedMap.set(index,itemID)\n      processedIndexList.push(index);\n    });\n    // -------------- look for and delete item and index orphans --------------------\n    // if the original item\'s index has not changed, then it has not been remapped, \n    //     it is orphaned, and the item is deleted\n    // if the item\'s index has changed, but the original item index map still points to the item,\n    //     then the index is orphaned (duplicate), and deleted\n    var deletedItemIDToIndexMap = new Map(); // index => itemID; orphaned index\n    var deletedIndexToItemIDMap = new Map();\n    var portalPartitionItemsForDeleteList = []; // hold deleted portals for deletion until after cradle synch\n    originalMap.forEach(function (originalItemID, originalItemIDIndex) {\n      var finalItemIDIndex = itemMetadataMap.get(originalItemID).index;\n      if (originalItemIDIndex == finalItemIDIndex) {\n        // not remapped, therefore orphaned\n        deletedItemIDToIndexMap.set(originalItemID, originalItemIDIndex);\n        var _itemMetadataMap$get2 = itemMetadataMap.get(originalItemID),\n          partitionID = _itemMetadataMap$get2.partitionID;\n        portalPartitionItemsForDeleteList.push({\n          itemID: originalItemID,\n          partitionID: partitionID\n        });\n        itemMetadataMap["delete"](originalItemID);\n        itemSet["delete"](originalItemID);\n      } else {\n        // remapped, check for orphaned index\n        if (indexToItemIDMap.has(originalItemIDIndex)) {\n          var finalItemID = indexToItemIDMap.get(originalItemIDIndex);\n          if (finalItemID == originalItemID) {\n            // the index has not been remapped, therefore orphaned\n            deletedIndexToItemIDMap.set(originalItemIDIndex, originalItemID);\n            indexToItemIDMap["delete"](originalItemIDIndex);\n          }\n        }\n      }\n    });\n    // refresh the changed cache\n    // cacheAPI.cacheProps.partitionModified = true\n    // cacheAPI.renderPortalLists()\n    // ------------- apply changes to extant cellFrames ------------\n    // these are used to reconcile cradle cellFrames, and also for return information\n    // const processedIndexList = Array.from(processedMap.keys())\n    var deletedOrphanedItemIndexList = Array.from(deletedItemIDToIndexMap.values());\n    var deletedOrphanedIndexList = Array.from(deletedIndexToItemIDMap.keys());\n    // for return information...\n    var deletedOrphanedItemIDList = Array.from(deletedItemIDToIndexMap.keys());\n    var modifiedIndexList = [].concat(processedIndexList, indexesToDeleteList, deletedOrphanedItemIndexList, deletedOrphanedIndexList);\n    modifiedIndexList = Array.from(new Set(modifiedIndexList.values())); // remove duplicates\n    contentHandler.createNewItemIDs(indexesToReplaceItemIDList);\n    contentHandler.reconcileCellFrames(modifiedIndexList);\n    modifiedIndexList = modifiedIndexList.concat(indexesToReplaceItemIDList);\n    cacheAPI.portalPartitionItemsForDeleteList = portalPartitionItemsForDeleteList.concat(partitionItemsToReplaceList);\n    stateHandler.setCradleState(\'applyremapchanges\');\n    // ---------- returns for user information --------------------\n    return [modifiedIndexList, processedIndexList, indexesToDeleteList, indexesToReplaceItemIDList, deletedOrphanedItemIDList, deletedOrphanedIndexList, errorEntriesMap, changeMap];\n  };\n  // move must be entirely within list bounds\n  // returns list of processed indexes\n  this.moveIndex = function (tolowindex, fromlowindex) {\n    var fromhighindex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // ------------ confirm validity of arguments -------------\n    var isToindexInvalid = !isInteger(tolowindex) || !minValue(tolowindex, 0);\n    var isFromindexInvalid = !isInteger(fromlowindex) || !minValue(fromlowindex, 0);\n    var isHighrangeInvalid = false;\n    if (!isFromindexInvalid) {\n      if (!isBlank(fromhighindex)) {\n        isHighrangeInvalid = !minValue(fromhighindex, fromlowindex);\n      } else {\n        fromhighindex = fromlowindex;\n      }\n    }\n    tolowindex = +tolowindex;\n    fromlowindex = +fromlowindex;\n    fromhighindex = +fromhighindex;\n    // TODO return error array instead\n    if (isToindexInvalid || isFromindexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR moveIndex(toindex, fromindex, fromhighrange)\');\n      isToindexInvalid && console.log(tolowindex, errorMessages.moveTo);\n      isFromindexInvalid && console.log(fromlowindex, errorMessages.moveFrom);\n      isHighrangeInvalid && console.log(fromhighindex, errorMessages.moveRange);\n      return [];\n    }\n    tolowindex = Math.max(0, tolowindex);\n    fromlowindex = Math.max(0, fromlowindex);\n    fromhighindex = Math.max(0, fromhighindex);\n    var fromspan = fromhighindex - fromlowindex + 1;\n    var tohighindex = tolowindex + fromspan - 1;\n    // ------------- coerce parameters to list bounds ---------------\n    var listsize = _this.cradleParameters.cradleInternalPropertiesRef.current.virtualListProps.size;\n    // keep within current list size\n    var listhighindex = listsize - 1;\n    if (tohighindex > listhighindex) {\n      var diff = tohighindex - listhighindex;\n      tohighindex = Math.max(0, tohighindex - diff);\n      tolowindex = Math.max(0, tolowindex - diff);\n    }\n    if (fromhighindex > listhighindex) {\n      var _diff = fromhighindex - listhighindex;\n      fromhighindex = Math.max(0, fromhighindex - _diff);\n      fromlowindex = Math.max(0, fromlowindex - _diff);\n    }\n    // ---------- constrain parameters --------------\n    // nothing to do; no displacement\n    if (fromlowindex == tolowindex) return [];\n    // ----------- perform cache and cradle operations -----------\n    var _this$cradleParameter5 = _this.cradleParameters.handlersRef.current,\n      cacheAPI = _this$cradleParameter5.cacheAPI,\n      contentHandler = _this$cradleParameter5.contentHandler,\n      stateHandler = _this$cradleParameter5.stateHandler;\n    var processedIndexList =\n    // both displaced and moved indexes\n    cacheAPI.moveIndex(tolowindex, fromlowindex, fromhighindex);\n    if (processedIndexList.length) {\n      contentHandler.synchronizeCradleItemIDsToCache(processedIndexList);\n      var content = contentHandler.content;\n      content.headModelComponents = content.cradleModelComponents.slice(0, content.headModelComponents.length);\n      content.tailModelComponents = content.cradleModelComponents.slice(content.headModelComponents.length);\n      stateHandler.setCradleState(\'applymovechanges\');\n    }\n    return processedIndexList;\n  };\n  this.insertIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isIndexInvalid) {\n      if (!isBlank(rangehighindex)) {\n        isHighrangeInvalid = !minValue(rangehighindex, index);\n      } else {\n        rangehighindex = index;\n      }\n    }\n    index = +index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR insertIndex(index, rangehighindex)\');\n      isIndexInvalid && console.log(index, errorMessages.insertFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.insertRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, +1);\n  };\n  this.removeIndex = function (index) {\n    var rangehighindex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isIndexInvalid = !isInteger(index) || !minValue(index, 0);\n    var isHighrangeInvalid = false;\n    if (!isIndexInvalid) {\n      if (!isBlank(rangehighindex)) {\n        isHighrangeInvalid = !minValue(rangehighindex, index);\n      } else {\n        rangehighindex = index;\n      }\n    }\n    index = +index;\n    rangehighindex = +rangehighindex;\n    if (isIndexInvalid || isHighrangeInvalid) {\n      console.log(\'RIGS ERROR moveIndex(index, rangehighindex)\');\n      isIndexInvalid && console.log(index, errorMessages.removeFrom);\n      isHighrangeInvalid && console.log(rangehighindex, errorMessages.removeRange);\n      return null;\n    }\n    return _this.insertRemoveIndex(index, rangehighindex, -1);\n  };\n  // shared logic for insert and remove. Returns lists of indexes shifted, replaced, and removed\n  // this operation changes the listsize\n  this.insertRemoveIndex = function (index, rangehighindex, increment) {\n    // basic assertions\n    index = Math.max(0, index);\n    rangehighindex = Math.max(rangehighindex, index);\n    // ---------------- assemble resources --------------------\n    var _this$cradleParameter6 = _this.cradleParameters.handlersRef.current,\n      cacheAPI = _this$cradleParameter6.cacheAPI,\n      contentHandler = _this$cradleParameter6.contentHandler,\n      stateHandler = _this$cradleParameter6.stateHandler;\n    var cradleInternalProperties = _this.cradleParameters.cradleInternalPropertiesRef.current;\n    var cradleInheritedProperties = _this.cradleParameters.cradleInheritedPropertiesRef.current;\n    // ------------------- process cache ----------------\n    var listsize = cradleInternalProperties.virtualListProps.size;\n    if (listsize == 0) {\n      if (increment > 0) {\n        return _this.setListsize(rangehighindex - index + 1);\n      }\n      return [[], [], []];\n    }\n    var _cacheAPI$insertRemov = cacheAPI.insertRemoveIndex(index, rangehighindex, increment, listsize),\n      _cacheAPI$insertRemov2 = _slicedToArray(_cacheAPI$insertRemov, 6),\n      startChangeIndex = _cacheAPI$insertRemov2[0],\n      rangeincrement = _cacheAPI$insertRemov2[1],\n      shiftedList = _cacheAPI$insertRemov2[2],\n      removedList = _cacheAPI$insertRemov2[3],\n      replaceList = _cacheAPI$insertRemov2[4],\n      portalPartitionItemsForDeleteList = _cacheAPI$insertRemov2[5]; //, cradleIndexSpan)\n    if (rangeincrement === null) return [[], [], []]; // no action\n    // partitionItems to delete with followup state changes - must happen after cradle update\n    cacheAPI.portalPartitionItemsForDeleteList = portalPartitionItemsForDeleteList;\n    // ------------- synchronize cradle to cache changes -------------\n    // determine if cradle must be reset or simply adjusted\n    var changecount = rangeincrement; // semantics\n    var newlistsize = _this.newlistsize = listsize + changecount;\n    // const { viewportRowcount } = cradleInternalProperties\n    var cradleContentProps = cradleInternalProperties.cradleContentProps,\n      virtualListProps = cradleInternalProperties.virtualListProps;\n    // const { crosscount } = cradleInternalProperties.virtualListProps\n    var viewportRowcount = cradleContentProps.viewportRowcount;\n    var crosscount = virtualListProps.crosscount;\n    // const { runwaySize } =  cradleInheritedProperties\n    var lowCradleIndex = cradleContentProps.lowindex,\n      highCradleIndex = cradleContentProps.highindex,\n      cradleSize = cradleContentProps.size,\n      runwaySize = cradleContentProps.runwayRowcount;\n    var calculatedCradleRowcount = viewportRowcount + runwaySize * 2;\n    var calculatedCradleItemcount = calculatedCradleRowcount * crosscount;\n    // const indexSpan = contentHandler.indexSpan\n    // const [lowCradleIndex,highCradleIndex] = indexSpan\n    // const measuredCradleItemCount = (indexSpan.length == 0)?0:highCradleIndex - lowCradleIndex + 1\n    var measuredCradleItemCount = cradleSize == 0 ? 0 : highCradleIndex - lowCradleIndex + 1;\n    var resetCradle = measuredCradleItemCount < calculatedCradleItemcount ||\n    // (contentHandler.indexSpan[1] >= (newlistsize - 1)))\n    highCradleIndex >= newlistsize - 1;\n    if (!resetCradle) {\n      // synchronize cradle contents to changes\n      contentHandler.synchronizeCradleItemIDsToCache(shiftedList, increment, startChangeIndex); // non-zero communications isInsertRemove\n      // if (increment == +1) contentHandler.createNewItemIDs(replaceList)\n      var content = contentHandler.content;\n      // const requestedSet = cacheAPI.cacheProps.requestedSet\n      var requestedSet = cacheAPI.requestedSet;\n      var timeout = setInterval(function () {\n        if (!requestedSet.size) {\n          // finished collecting new cache entries\n          clearInterval(timeout);\n          content.headModelComponents = content.cradleModelComponents.slice(0, content.headModelComponents.length);\n          content.tailModelComponents = content.cradleModelComponents.slice(content.headModelComponents.length);\n          stateHandler.setCradleState(\'applyinsertremovechanges\');\n        }\n      }, 100);\n    } else {\n      // cradle to be completely reset if listsize change encroaches on cradle\n      stateHandler.setCradleState(\'channelcradleresetafterinsertremove\');\n    }\n    var replacedList = replaceList; // semantics\n    return [shiftedList, replacedList, removedList]; // inform caller\n  };\n\n  this.cradleParameters = cradleParameters;\n  // doing this explicitly here for documentation\n  var _cradleParameters$ext = cradleParameters.externalCallbacksRef.current,\n    referenceIndexCallback = _cradleParameters$ext.referenceIndexCallback,\n    preloadIndexCallback = _cradleParameters$ext.preloadIndexCallback,\n    deleteListCallback = _cradleParameters$ext.deleteListCallback,\n    changeListsizeCallback = _cradleParameters$ext.changeListsizeCallback,\n    itemExceptionCallback = _cradleParameters$ext.itemExceptionCallback,\n    repositioningFlagCallback = _cradleParameters$ext.repositioningFlagCallback,\n    repositioningIndexCallback = _cradleParameters$ext.repositioningIndexCallback;\n  var callbacks = {\n    referenceIndexCallback: referenceIndexCallback,\n    preloadIndexCallback: preloadIndexCallback,\n    deleteListCallback: deleteListCallback,\n    changeListsizeCallback: changeListsizeCallback,\n    itemExceptionCallback: itemExceptionCallback,\n    repositioningFlagCallback: repositioningFlagCallback,\n    repositioningIndexCallback: repositioningIndexCallback\n  };\n  this.callbacks = callbacks;\n});\nexports["default"] = ServiceHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixFQUFyQkEscUJBQXFCO0lBQ3JCQyx5QkFBeUIsRUFBekJBLHlCQUF5QjtJQUN6QkMsMEJBQTBCLEVBQTFCQTtHQUNIO0VBRUQsSUFBSSxDQUFDdEksU0FBUyxHQUFHQSxTQUFTO0FBRTdCLENBQUM7QUE5Qkx1SSxrQkFBQSxHQUFBaEssY0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWluZmluaXRlLWdyaWQtc2Nyb2xsZXIvLi9zcmMvY3JhZGxlL3NlcnZpY2VoYW5kbGVyLnRzeD85Y2IwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZpY2VoYW5kbGVyLnRzeFxuLy8gY29weXJpZ2h0IChjKSAyMDE5LTIwMjMgSGVucmlrIEJlY2htYW5uLCBUb3JvbnRvLCBMaWNlbmNlOiBNSVRcblxuLypcbiAgICBUaGlzIG1vZHVsZSBmaWVsZHMgc2VydmljZSByZXF1ZXN0cyBmcm9tIHRoZSBob3N0LiBUaGVyZSBhcmUgdHdvIGZvcm1zXG4gICAgLSBzdHJlYW1pbmcgZnJvbSB0aGUgc2Nyb2xsZXIgdG8gdGhlIGhvc3RcbiAgICAtIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIHVzZXIgdG8gdGhlIHNjcm9sbGVyXG5cbiAgICBGb3IgdGhlIGxpc3Qgb2YgZGF0YSBzdHJlYW1zLCBzZWUgdGhlIGNvbnN0cnVjdG9yLlxuXG4gICAgVGhlIGZ1bmN0aW9uIGNhbGxzIGF2YWlhYmxlIHRvIHRoZSBob3N0IGFyZTpcblxuICAgICAgICBzY3JvbGxUb0luZGV4LCBcbiAgICAgICAgcmVsb2FkLCBcbiAgICAgICAgc2V0TGlzdHNpemUsXG4gICAgICAgIGNsZWFyQ2FjaGUsIFxuXG4gICAgICAgIGdldENhY2hlSW5kZXhNYXAsIFxuICAgICAgICBnZXRDYWNoZUl0ZW1NYXAsXG4gICAgICAgIGdldENyYWRsZUluZGV4TWFwLFxuXG4gICAgICAgIGluc2VydEluZGV4LFxuICAgICAgICByZW1vdmVJbmRleCxcbiAgICAgICAgbW92ZUluZGV4LFxuICAgICAgICByZW1hcEluZGV4ZXMsXG4gICAgXG4gICAgVGhlIGZ1bmN0aW9ucyBsaXN0ZWQgYXJlIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUuXG5cbiAgICBUaGVyZSBhcmUgaW1wb3J0YW50IHN1cHBvcnRpbmcgZnVuY3Rpb25zIGZvciB0aGVzZSBpbiBjYWNoZUFQSSBhbmQgY29udGVudEhhbmRsZXIuIHN0YXRlSGFuZGxlciBpc1xuICAgIG9mdGVuIGludm9rZWQgYnkgc2VydmljZSBmdW5jdGlvbnMgdG8gY2hhbmdlIENyYWRsZSBzdGF0ZSB1cG9uIHNlcnZpY2luZyByZXF1ZXN0cy5cbiovXG5cbmNvbnN0IGlzQmxhbmsgPSAodmFsdWU6YW55KSA9PiB7XG4gICAgY29uc3QgdGVzdHZhbHVlID0gdmFsdWUgPz8gJydcbiAgICByZXR1cm4gdGVzdHZhbHVlID09PSAnJ1xufVxuXG5jb25zdCBpc051bWJlciA9ICh2YWx1ZTphbnkpID0+IHtcblxuICAgIHJldHVybiAoIFxuICAgICAgICAoIWlzTmFOKE51bWJlcih2YWx1ZSkpKSAmJiBcbiAgICAgICAgKCFpc05hTihwYXJzZUludCh2YWx1ZSkpKSBcbiAgICApXG5cbn1cblxuY29uc3QgaXNJbnRlZ2VyID0gKHZhbHVlOmFueSkgPT4ge1xuXG4gICAgY29uc3QgdGVzdCA9ICt2YWx1ZVxuXG4gICAgcmV0dXJuIChpc051bWJlcih2YWx1ZSkgJiYgKE1hdGguZmxvb3IodGVzdCkgPT0gdGVzdCkpXG5cbn1cblxuY29uc3QgbWluVmFsdWUgPSAodmFsdWU6YW55LCBtaW5WYWx1ZTphbnkpID0+IHtcblxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlKSB8fCAhaXNJbnRlZ2VyKG1pblZhbHVlKSkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCB0ZXN0dmFsdWUgPSArdmFsdWVcbiAgICBjb25zdCB0ZXN0TWluVmFsdWUgPSArbWluVmFsdWVcblxuICAgIHJldHVybiB0ZXN0dmFsdWUgPj0gdGVzdE1pblZhbHVlXG5cbn1cblxuY29uc3QgbWF4VmFsdWUgPSAodmFsdWU6YW55LCBtYXhWYWx1ZTphbnkpID0+IHtcblxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlKSB8fCAhaXNJbnRlZ2VyKG1heFZhbHVlKSkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCB0ZXN0dmFsdWUgPSArdmFsdWVcbiAgICBjb25zdCB0ZXN0TWF4VmFsdWUgPSArbWF4VmFsdWVcblxuICAgIHJldHVybiB0ZXN0dmFsdWUgPD0gdGVzdE1heFZhbHVlXG5cbn1cblxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBzY3JvbGxUb0luZGV4OidpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxuICAgIHNldExpc3RzaXplOidpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxuICAgIGluc2VydEZyb206J2luc2VydEZyb20gLSBpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxuICAgIGluc2VydFJhbmdlOidpbnNlcnRSYW5nZSAtIGJsYW5rLCBvciBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgXCJmcm9tXCIgaW5kZXgnLFxuICAgIHJlbW92ZUZyb206J3JlbW92ZUZyb20gLSBpbnRlZ2VyOiByZXF1aXJlZCwgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnLFxuICAgIHJlbW92ZVJhbmdlOidyZW1vdmVSYW5nZSAtIGJsYW5rLCBvciBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgXCJmcm9tXCIgaW5kZXgnLFxuICAgIG1vdmVGcm9tOidtb3ZlRnJvbSAtIGludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG4gICAgbW92ZVJhbmdlOidtb3ZlUmFuZ2UgLSBibGFuaywgb3IgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIFwiZnJvbVwiIGluZGV4JyxcbiAgICBtb3ZlVG86J21vdmVUbyAtIGludGVnZXI6IHJlcXVpcmVkLCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcnZpY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgIHRoaXMuY3JhZGxlUGFyYW1ldGVycyA9IGNyYWRsZVBhcmFtZXRlcnNcblxuICAgICAgIC8vIGRvaW5nIHRoaXMgZXhwbGljaXRseSBoZXJlIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICAgY29uc3Qge1xuICAgICAgICAgICByZWZlcmVuY2VJbmRleENhbGxiYWNrLCAvLyAoaW5kZXgsIGxvY2F0aW9uLCBjcmFkbGVTdGF0ZSlcbiAgICAgICAgICAgcHJlbG9hZEluZGV4Q2FsbGJhY2ssIC8vIChpbmRleClcbiAgICAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrLCAvLyAocmVhc29uLCBkZWxldGVMaXN0KVxuICAgICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrLCAvLyAobmV3bGlzdHNpemUpXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjaywgLy8gKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCBsb2NhdGlvbiwgZXJyb3IpXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdGbGFnQ2FsbGJhY2ssIC8vIChmbGFnKSAvLyBib29sZWFuXG4gICAgICAgICAgIHJlcG9zaXRpb25pbmdJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBcbiAgICAgICB9ID0gY3JhZGxlUGFyYW1ldGVycy5leHRlcm5hbENhbGxiYWNrc1JlZi5jdXJyZW50XG5cbiAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgIHJlZmVyZW5jZUluZGV4Q2FsbGJhY2ssXG4gICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrLFxuICAgICAgICAgICBkZWxldGVMaXN0Q2FsbGJhY2ssXG4gICAgICAgICAgIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2ssXG4gICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayxcbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0ZsYWdDYWxsYmFjayxcbiAgICAgICAgICAgcmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2tcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAvLyBzZWUgYWJvdmUgZm9yIGxpc3RcbiAgICBwdWJsaWMgY2FsbGJhY2tzXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1bIEdFTkVSQUwgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyByZWxvYWQgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBpbnRlcnJ1cHRIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGludGVycnVwdEhhbmRsZXIucGF1c2VJbnRlcnJ1cHRzKClcblxuICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ3JlbG9hZCcpXG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2Nyb2xsVG9JbmRleCA9IChpbmRleCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW52YWxpZCA9ICghaXNJbnRlZ2VyKGluZGV4KSB8fCAhbWluVmFsdWUoaW5kZXgsIDApKVxuXG4gICAgICAgIGluZGV4ID0gK2luZGV4XG5cbiAgICAgICAgaWYgKGlzSW52YWxpZCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUklHUyBFUlJPUiBzY3JvbGxUb0luZGV4KGluZGV4KSk6JywgaW5kZXgsIGVycm9yTWVzc2FnZXMuc2Nyb2xsVG9JbmRleClcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNpZ25hbHMgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50LmludGVycnVwdEhhbmRsZXJcbiAgICAgICAgY29uc3QgeyBsYXlvdXRIYW5kbGVyLCBzdGF0ZUhhbmRsZXJ9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBzaWduYWxzLnBhdXNlU2Nyb2xsaW5nRWZmZWN0cyA9IHRydWVcblxuICAgICAgICBsYXlvdXRIYW5kbGVyLmNyYWRsZVBvc2l0aW9uRGF0YS50YXJnZXRBeGlzUmVmZXJlbmNlUG9zaXRpb24gPSBpbmRleFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc2Nyb2xsdG8nKVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNldExpc3RzaXplID0gKG5ld2xpc3RzaXplKSA9PiB7XG5cbiAgICAgICAgY29uc3QgaXNJbnZhbGlkID0gKCFpc0ludGVnZXIobmV3bGlzdHNpemUpIHx8ICFtaW5WYWx1ZShuZXdsaXN0c2l6ZSwgMCkpXG5cbiAgICAgICAgbmV3bGlzdHNpemUgPSArbmV3bGlzdHNpemVcblxuICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSSUdTIEVSUk9SIHNldExpc3RzaXplKG5ld2xpc3RzaXplKScsIG5ld2xpc3RzaXplLCBlcnJvck1lc3NhZ2VzLnNldExpc3RzaXplKVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVBUEksIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5oYW5kbGVyc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sgfSA9IHRoaXMuY2FsbGJhY2tzXG5cbiAgICAgICAgY29uc3QgY3VycmVudGxpc3RzaXplID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50LnZpcnR1YWxMaXN0UHJvcHMuc2l6ZVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICBsZXQgZExpc3RDYWxsYmFja1xuICAgICAgICBpZiAoZGVsZXRlTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrID0gKGRlbGV0ZUxpc3QpID0+IHtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZUxpc3RDYWxsYmFjaygnY2hhbmdlIGxpc3Qgc2l6ZSBpbnRlcnZlbnRpb24nLGRlbGV0ZUxpc3QpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudEhhbmRsZXIudXBkYXRlVmlydHVhbExpc3RTcGVjcyhuZXdsaXN0c2l6ZSlcbiAgICAgICAgY2FjaGVBUEkuY2hhbmdlQ2FjaGVMaXN0c2l6ZShuZXdsaXN0c2l6ZSwgXG4gICAgICAgICAgICBkTGlzdENhbGxiYWNrLFxuICAgICAgICAgICAgY2hhbmdlTGlzdHNpemVDYWxsYmFja1xuICAgICAgICApXG5cbiAgICAgICAgY2FjaGVBUEkucmVuZGVyUG9ydGFsTGlzdHMoKVxuXG5cbiAgICAgICAgaWYgKChjYWNoZSA9PSAncHJlbG9hZCcpICYmIChuZXdsaXN0c2l6ZSA+IGN1cnJlbnRsaXN0c2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnc3RhcnRwcmVsb2FkJylcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVsgR0VUIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwdWJsaWMgZ2V0Q2FjaGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlQVBJIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHJldHVybiBjYWNoZUFQSS5nZXRDYWNoZUluZGV4TWFwKClcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDYWNoZUl0ZW1NYXAgPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUFQSSB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICByZXR1cm4gY2FjaGVBUEkuZ2V0Q2FjaGVJdGVtTWFwKClcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDcmFkbGVJbmRleE1hcCA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNhY2hlQVBJLCBjb250ZW50SGFuZGxlciB9ID0gdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBtb2RlbEluZGV4TGlzdCA9IGNvbnRlbnRIYW5kbGVyLmdldE1vZGVsSW5kZXhMaXN0KClcbiAgICAgICAgcmV0dXJuIGNhY2hlQVBJLmdldENyYWRsZUluZGV4TWFwKG1vZGVsSW5kZXhMaXN0KVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09WyBDQUNIRSBNQU5BR0VNRU5UIFJFUVVFU1RTIF09PT09PT09PT09PT09PT09PT1cblxuICAgIHB1YmxpYyBjbGVhckNhY2hlID0gKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RhdGVIYW5kbGVyIH0gPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2xlYXJjYWNoZScpXG5cbiAgICB9XG5cbiAgICAvLyBpdGVtSUQgc2V0IHRvIG51bGwgZGVsZXRlcyB0aGUgaW5kZXhlZCBpdGVtXG4gICAgLy8gaXRlbUlEIHNldCB0byB1bmRlZmluZWQgcmVwbGFjZXMgdGhlIGluZGV4ZWQgaXRlbVxuICAgIC8vIHRoZSBtYWluIHB1cnBvc2UgaXMgdG8gYWxsb3cgaXRlbXNJRHMgdG8gYmUgcmVtYXBwZWQgdG8gbmV3IGluZGV4ZXNcbiAgICAvLyBvcGVyYXRpb25zIGFyZSBvbiBleGlzdGluZyBjYWNoZSBpdGVtcyBvbmx5XG4gICAgcHVibGljIHJlbWFwSW5kZXhlcyA9IChjaGFuZ2VNYXApID0+IHsgLy8gaW5kZXggPT4gaXRlbUlEXG5cbiAgICAgICAgaWYgKGNoYW5nZU1hcC5zaXplID09IDApIHJldHVybiBbXSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgY29uc3QgeyBjYWNoZUFQSSwgY29udGVudEhhbmRsZXIsIHN0YXRlSGFuZGxlciB9ID0gXG4gICAgICAgICAgICB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuaGFuZGxlcnNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHsgXG5cbiAgICAgICAgICAgIGl0ZW1NZXRhZGF0YU1hcCwgLy8gaXRlbUlEIHRvIGNvbXBvbmVudCBkYXRhLCBpbmNsdWRpbmcgaW5kZXhcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAsIC8vIGluZGV4IHRvIGl0ZW1JRFxuICAgICAgICAgICAgaXRlbVNldCxcblxuICAgICAgICB9ID0gY2FjaGVBUEkgXG5cbiAgICAgICAgY29uc3QgaW5kZXhlc1RvRGVsZXRlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0ID0gW11cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0ID0gW11cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBlcnJvckVudHJpZXNNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1bIFBSRVBBUkUgXT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgaXNvbGF0ZSBpbmRleGVzIGZvciB3aGljaCBpdGVtcyBzaG91bGQgYmUgcmVwbGFjZWQgXS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3Qgd29ya2luZ0NoYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjaGFuZ2VNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9JdGVtSURNYXAuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVJdGVtSUQgPT09IHVuZGVmaW5lZCkpIHsgLy8gaWdub3JlIG5vbi1leGlzdGVudCBpbmRleGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IGl0ZW1NZXRhZGF0YU1hcC5nZXQoY2FjaGVJdGVtSUQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpdGlvbkl0ZW1zVG9SZXBsYWNlTGlzdC5wdXNoKHtwYXJ0aXRpb25JRCwgaXRlbUlEOmNhY2hlSXRlbUlEfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgJ2luZGV4IHRvIHJlcGxhY2UgaXMgbm90IGluIGNhY2hlJylcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB3b3JraW5nQ2hhbmdlTWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgaW5kZXhlc1RvUmVwbGFjZUl0ZW1JRExpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSBmaWx0ZXIgb3V0IGlub3BlcmFibGUgaW5kZXhlcyBhbmQgaXRlbUlEcyAtLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBpdGVtc1RvUmVwbGFjZVNldCA9IG5ldyBTZXQoKVxuICAgICAgICBwYXJ0aXRpb25JdGVtc1RvUmVwbGFjZUxpc3QuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgICAgICAgICBpdGVtc1RvUmVwbGFjZVNldC5hZGQob2JqLml0ZW1JRClcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBjb25zdCBpdGVtc1RvUmVwbGFjZUxpc3QgPSBBcnJheS5mcm9tKGl0ZW1zVG9SZXBsYWNlU2V0KVxuXG4gICAgICAgIHdvcmtpbmdDaGFuZ2VNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCkgPT57XG5cbiAgICAgICAgICAgIGlmICgoaXRlbUlEID09PSBudWxsKSB8fCAoaXRlbUlEID09PSB1bmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBpdGVtSUQpID09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwnaXRlbUlEIGlzIGEgc3RyaW5nJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsJ2l0ZW1JRCBpcyBub3QgYW4gaW50ZWdlcicpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCAnaW5kZXggbm90IGluIGNhY2hlJylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpID09IGl0ZW1JRCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRW50cmllc01hcC5zZXQoaW5kZXgsIGB0YXJnZXQgaXRlbUlEICR7aXRlbUlEfSBoYXMgbm90IGNoYW5nZWRgKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbU1ldGFkYXRhTWFwLmhhcyhpdGVtSUQpIHx8IGl0ZW1zVG9SZXBsYWNlU2V0LmhhcyhpdGVtSUQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbnRyaWVzTWFwLnNldChpbmRleCwgYHRhcmdldCBpdGVtSUQgJHtpdGVtSUR9IG5vdCBpbiBjYWNoZSwgb3IgaGFzIGJlZW4gcmVtb3ZlZGApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2V0KGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIGZpbHRlciBvdXQgZHVwbGljYXRlIGl0ZW1JRHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgbWFwc2l6ZSA9IGNoYW5nZUluZGV4VG9JdGVtSURNYXAuc2l6ZVxuXG4gICAgICAgIGNvbnN0IGl0ZW1JRFNldCA9IG5ldyBTZXQoY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC52YWx1ZXMoKSlcblxuICAgICAgICBjb25zdCBpdGVtc2V0c2l6ZSA9IGl0ZW1JRFNldC5zaXplXG5cbiAgICAgICAgaWYgKG1hcHNpemUgIT0gaXRlbXNldHNpemUpIHsgLy8gdGhlcmUgbXVzdCBiZSBkdXBsaWNhdGUgaXRlbUlEc1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSURDb3VudE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtSURDb3VudE1hcC5oYXMoaXRlbUlEKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JRENvdW50TWFwLnNldChpdGVtSUQsIDEpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IGl0ZW1JRENvdW50TWFwLmdldChpdGVtSUQpXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JRENvdW50TWFwLnNldChpdGVtSUQsICsrY291bnQgKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlSXRlbXNNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgICAgIGl0ZW1JRENvdW50TWFwLmZvckVhY2goKGNvdW50LGl0ZW1JRCk9PntcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVJdGVtc01hcC5zZXQoaXRlbUlELCBjb3VudClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVzVG9SZW1vdmVMaXN0ID0gW11cbiAgICAgICAgICAgIGNoYW5nZUluZGV4VG9JdGVtSURNYXAuZm9yRWFjaCgoaXRlbUlELCBpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZUl0ZW1zTWFwLmhhcyhpdGVtSUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QucHVzaChpbmRleClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGR1cGxpY2F0ZXNUb1JlbW92ZUxpc3QuZm9yRWFjaCgoaW5kZXgpPT57XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGR1cGxpY2F0ZUl0ZW1zTWFwLmdldChpdGVtSUQpXG5cbiAgICAgICAgICAgICAgICBlcnJvckVudHJpZXNNYXAuc2V0KGluZGV4LCBgdGFyZ2V0IGl0ZW1JRCAke2l0ZW1JRH0gaGFzIGR1cGxpY2F0ZXMgKCR7Y291bnR9KWApXG4gICAgICAgICAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUoaW5kZXgpXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSBjYXB0dXJlIG1hcCBiZWZvcmUgY2hhbmdlcyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIC4uLiB0aGlzIG1hcCBpcyB1c2VkIGxhdGVyIHRvIGlkZW50aWZ5IG9ycGhhbmVkIGl0ZW0gYW5kIGluZGV4IGNhY2hlIHJlY29yZHMgZm9yIGRlbGV0aW9uXG5cbiAgICAgICAgLy8gZnJvbSB0aGUgbGlzdCBvZiBjaGFuZ2VzXG4gICAgICAgIC8vIGJvdGggc2lkZXMgb2YgY2hhbmdlIG1hcC4uLlxuICAgICAgICBjb25zdCBvcmlnaW5hbE1hcCA9IG5ldyBNYXAoKSAvLyBpbmRleCA9PiBpdGVtSUQ7IGJlZm9yZSBjaGFuZ2VcbiAgICAgICAgY2hhbmdlSW5kZXhUb0l0ZW1JRE1hcC5mb3JFYWNoKChpdGVtSUQsIGluZGV4KT0+e1xuXG4gICAgICAgICAgICBvcmlnaW5hbE1hcC5zZXQoaW5kZXgsaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpKSAvLyBpbmRleCB0byBiZSBtYXBwZWRcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwLnNldChpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXgsaXRlbUlEKSAvLyB0YXJnZXQgaXRlbUlEXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAuLi4gYW5kIGZyb20gdGhlIGxpc3Qgb2YgaW5kZXhlcyB0byBiZSBkZWxldGVkXG4gICAgICAgIGluZGV4ZXNUb0RlbGV0ZUxpc3QuZm9yRWFjaCgoaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgb3JpZ2luYWxNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09WyBDQUNIRSBPUEVSQVRJT05TIF09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRlbGV0ZSBsaXN0ZWQgaW5kZXhlcyAtLS0tLS0tLS1cbiAgICAgICAgLy8gZm9yIGluZGV4ZXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgaXRlbUlEJ3Mgd2lsbCBiZSBvcnBoYW5lZCwgYnV0IGNvdWxkIGJlIHJlbWFwcGVkLlxuICAgICAgICAvLyBvcnBoYW5zIGFyZSByZXNvbHZlZCBiZWxvd1xuXG4gICAgICAgIGlmIChpbmRleGVzVG9EZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LmZvckVhY2goKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gYXBwbHkgZmlsdGVyZWQgY2hhbmdlcyB0byBjYWNoZSBpbmRleCBtYXAgYW5kIGl0ZW1JRCBtYXAgLS0tLS0tLS0tLVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGV2ZXJ5IHJlbWFpbmluZyBpbmRleCBsaXN0ZWQgd2lsbCBjaGFuZ2UgaXRzIG1hcHBpbmdcblxuICAgICAgICAvLyBjb25zdCBwcm9jZXNzZWRNYXAgPSBuZXcgTWFwKCkgLy8gaW5kZXggPT4gaXRlbUlEOyBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSBbXVxuXG4gICAgICAgIC8vIG1ha2UgY2hhbmdlc1xuICAgICAgICBjaGFuZ2VJbmRleFRvSXRlbUlETWFwLmZvckVhY2goKGl0ZW1JRCxpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChpbmRleCxpdGVtSUQpIC8vIG1vZGlpY2F0aW9uIGFwcGxpZWQsIHBhcnQgMVxuICAgICAgICAgICAgY29uc3QgaXRlbWRhdGEgPSBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgaXRlbWRhdGEuaW5kZXggPSBpbmRleCAvLyBtb2RpZmljYXRpb24gYXBwbGllZCwgcGFydCAyXG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZE1hcC5zZXQoaW5kZXgsaXRlbUlEKVxuICAgICAgICAgICAgcHJvY2Vzc2VkSW5kZXhMaXN0LnB1c2goaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBsb29rIGZvciBhbmQgZGVsZXRlIGl0ZW0gYW5kIGluZGV4IG9ycGhhbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbmFsIGl0ZW0ncyBpbmRleCBoYXMgbm90IGNoYW5nZWQsIHRoZW4gaXQgaGFzIG5vdCBiZWVuIHJlbWFwcGVkLCBcbiAgICAgICAgLy8gICAgIGl0IGlzIG9ycGhhbmVkLCBhbmQgdGhlIGl0ZW0gaXMgZGVsZXRlZFxuICAgICAgICAvLyBpZiB0aGUgaXRlbSdzIGluZGV4IGhhcyBjaGFuZ2VkLCBidXQgdGhlIG9yaWdpbmFsIGl0ZW0gaW5kZXggbWFwIHN0aWxsIHBvaW50cyB0byB0aGUgaXRlbSxcbiAgICAgICAgLy8gICAgIHRoZW4gdGhlIGluZGV4IGlzIG9ycGhhbmVkIChkdXBsaWNhdGUpLCBhbmQgZGVsZXRlZFxuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwID0gbmV3IE1hcCgpIC8vIGluZGV4ID0+IGl0ZW1JRDsgb3JwaGFuZWQgaW5kZXhcbiAgICAgICAgY29uc3QgZGVsZXRlZEluZGV4VG9JdGVtSURNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBjb25zdCBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QgPSBbXSAvLyBob2xkIGRlbGV0ZWQgcG9ydGFscyBmb3IgZGVsZXRpb24gdW50aWwgYWZ0ZXIgY3JhZGxlIHN5bmNoXG5cbiAgICAgICAgb3JpZ2luYWxNYXAuZm9yRWFjaCgob3JpZ2luYWxJdGVtSUQsIG9yaWdpbmFsSXRlbUlESW5kZXgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmluYWxJdGVtSURJbmRleCA9IGl0ZW1NZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpLmluZGV4XG5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEl0ZW1JREluZGV4ID09IGZpbmFsSXRlbUlESW5kZXgpIHsgLy8gbm90IHJlbWFwcGVkLCB0aGVyZWZvcmUgb3JwaGFuZWRcblxuICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtSURUb0luZGV4TWFwLnNldChvcmlnaW5hbEl0ZW1JRCwgb3JpZ2luYWxJdGVtSURJbmRleClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IGl0ZW1NZXRhZGF0YU1hcC5nZXQob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0LnB1c2goe2l0ZW1JRDpvcmlnaW5hbEl0ZW1JRCwgcGFydGl0aW9uSUR9KVxuICAgICAgICAgICAgICAgIGl0ZW1NZXRhZGF0YU1hcC5kZWxldGUob3JpZ2luYWxJdGVtSUQpXG4gICAgICAgICAgICAgICAgaXRlbVNldC5kZWxldGUob3JpZ2luYWxJdGVtSUQpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHJlbWFwcGVkLCBjaGVjayBmb3Igb3JwaGFuZWQgaW5kZXhcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleFRvSXRlbUlETWFwLmhhcyhvcmlnaW5hbEl0ZW1JREluZGV4KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsSXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQob3JpZ2luYWxJdGVtSURJbmRleClcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxJdGVtSUQgPT0gb3JpZ2luYWxJdGVtSUQpIHsgLy8gdGhlIGluZGV4IGhhcyBub3QgYmVlbiByZW1hcHBlZCwgdGhlcmVmb3JlIG9ycGhhbmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJbmRleFRvSXRlbUlETWFwLnNldChvcmlnaW5hbEl0ZW1JREluZGV4LCBvcmlnaW5hbEl0ZW1JRClcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5kZWxldGUob3JpZ2luYWxJdGVtSURJbmRleClcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHJlZnJlc2ggdGhlIGNoYW5nZWQgY2FjaGVcbiAgICAgICAgLy8gY2FjaGVBUEkuY2FjaGVQcm9wcy5wYXJ0aXRpb25Nb2RpZmllZCA9IHRydWVcbiAgICAgICAgLy8gY2FjaGVBUEkucmVuZGVyUG9ydGFsTGlzdHMoKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gYXBwbHkgY2hhbmdlcyB0byBleHRhbnQgY2VsbEZyYW1lcyAtLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyB0aGVzZSBhcmUgdXNlZCB0byByZWNvbmNpbGUgY3JhZGxlIGNlbGxGcmFtZXMsIGFuZCBhbHNvIGZvciByZXR1cm4gaW5mb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3QgcHJvY2Vzc2VkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNYXAua2V5cygpKVxuICAgICAgICBjb25zdCBkZWxldGVkT3JwaGFuZWRJdGVtSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSXRlbUlEVG9JbmRleE1hcC52YWx1ZXMoKSlcbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShkZWxldGVkSW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG4gICAgICAgIC8vIGZvciByZXR1cm4gaW5mb3JtYXRpb24uLi5cbiAgICAgICAgY29uc3QgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCA9IEFycmF5LmZyb20oZGVsZXRlZEl0ZW1JRFRvSW5kZXhNYXAua2V5cygpKSBcblxuICAgICAgICBsZXQgbW9kaWZpZWRJbmRleExpc3QgPSBbXG4gICAgICAgICAgICAuLi5wcm9jZXNzZWRJbmRleExpc3QsXG4gICAgICAgICAgICAuLi5pbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIC4uLmRlbGV0ZWRPcnBoYW5lZEl0ZW1JbmRleExpc3QsIFxuICAgICAgICAgICAgLi4uZGVsZXRlZE9ycGhhbmVkSW5kZXhMaXN0XG4gICAgICAgIF1cblxuICAgICAgICBtb2RpZmllZEluZGV4TGlzdCA9IEFycmF5LmZyb20obmV3IFNldChtb2RpZmllZEluZGV4TGlzdC52YWx1ZXMoKSkpIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG5cbiAgICAgICAgY29udGVudEhhbmRsZXIuY3JlYXRlTmV3SXRlbUlEcyhpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdClcblxuICAgICAgICBjb250ZW50SGFuZGxlci5yZWNvbmNpbGVDZWxsRnJhbWVzKG1vZGlmaWVkSW5kZXhMaXN0KVxuXG4gICAgICAgIG1vZGlmaWVkSW5kZXhMaXN0ID0gbW9kaWZpZWRJbmRleExpc3QuY29uY2F0KGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0KVxuXG4gICAgICAgIGNhY2hlQVBJLnBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdC5jb25jYXQocGFydGl0aW9uSXRlbXNUb1JlcGxhY2VMaXN0KVxuXG4gICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnYXBwbHlyZW1hcGNoYW5nZXMnKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gcmV0dXJucyBmb3IgdXNlciBpbmZvcm1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBbXG5cbiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXhMaXN0LCBcbiAgICAgICAgICAgIHByb2Nlc3NlZEluZGV4TGlzdCwgXG4gICAgICAgICAgICBpbmRleGVzVG9EZWxldGVMaXN0LCBcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlcGxhY2VJdGVtSURMaXN0LFxuICAgICAgICAgICAgZGVsZXRlZE9ycGhhbmVkSXRlbUlETGlzdCwgXG4gICAgICAgICAgICBkZWxldGVkT3JwaGFuZWRJbmRleExpc3QsXG4gICAgICAgICAgICBlcnJvckVudHJpZXNNYXAsIFxuICAgICAgICAgICAgY2hhbmdlTWFwXG5cbiAgICAgICAgXVxuXG4gICAgfVxuXG4gICAgLy8gbW92ZSBtdXN0IGJlIGVudGlyZWx5IHdpdGhpbiBsaXN0IGJvdW5kc1xuICAgIC8vIHJldHVybnMgbGlzdCBvZiBwcm9jZXNzZWQgaW5kZXhlc1xuICAgIHB1YmxpYyBtb3ZlSW5kZXggPSAodG9sb3dpbmRleCwgZnJvbWxvd2luZGV4LCBmcm9taGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSBjb25maXJtIHZhbGlkaXR5IG9mIGFyZ3VtZW50cyAtLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgaXNUb2luZGV4SW52YWxpZCA9ICghaXNJbnRlZ2VyKHRvbG93aW5kZXgpIHx8ICFtaW5WYWx1ZSh0b2xvd2luZGV4LCAwKSlcbiAgICAgICAgY29uc3QgaXNGcm9taW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIoZnJvbWxvd2luZGV4KSB8fCAhbWluVmFsdWUoZnJvbWxvd2luZGV4LCAwKSlcbiAgICAgICAgbGV0IGlzSGlnaHJhbmdlSW52YWxpZCA9IGZhbHNlXG5cbiAgICAgICAgaWYgKCghaXNGcm9taW5kZXhJbnZhbGlkKSkge1xuICAgICAgICAgICAgaWYgKCFpc0JsYW5rKGZyb21oaWdoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkID0gIW1pblZhbHVlKGZyb21oaWdoaW5kZXgsIGZyb21sb3dpbmRleClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbWhpZ2hpbmRleCA9IGZyb21sb3dpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB0b2xvd2luZGV4ID0gK3RvbG93aW5kZXhcbiAgICAgICAgZnJvbWxvd2luZGV4ID0gK2Zyb21sb3dpbmRleFxuICAgICAgICBmcm9taGlnaGluZGV4ID0gK2Zyb21oaWdoaW5kZXhcblxuICAgICAgICAvLyBUT0RPIHJldHVybiBlcnJvciBhcnJheSBpbnN0ZWFkXG4gICAgICAgIGlmIChpc1RvaW5kZXhJbnZhbGlkIHx8IGlzRnJvbWluZGV4SW52YWxpZCB8fCBpc0hpZ2hyYW5nZUludmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSSUdTIEVSUk9SIG1vdmVJbmRleCh0b2luZGV4LCBmcm9taW5kZXgsIGZyb21oaWdocmFuZ2UpJylcbiAgICAgICAgICAgIGlzVG9pbmRleEludmFsaWQgJiYgY29uc29sZS5sb2codG9sb3dpbmRleCwgZXJyb3JNZXNzYWdlcy5tb3ZlVG8pXG4gICAgICAgICAgICBpc0Zyb21pbmRleEludmFsaWQgJiYgY29uc29sZS5sb2coZnJvbWxvd2luZGV4LCBlcnJvck1lc3NhZ2VzLm1vdmVGcm9tKVxuICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkICYmIGNvbnNvbGUubG9nKGZyb21oaWdoaW5kZXgsIGVycm9yTWVzc2FnZXMubW92ZVJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICB0b2xvd2luZGV4ID0gTWF0aC5tYXgoMCx0b2xvd2luZGV4KVxuICAgICAgICBmcm9tbG93aW5kZXggPSBNYXRoLm1heCgwLGZyb21sb3dpbmRleClcbiAgICAgICAgZnJvbWhpZ2hpbmRleCA9IE1hdGgubWF4KDAsZnJvbWhpZ2hpbmRleClcblxuICAgICAgICBjb25zdCBmcm9tc3BhbiA9IGZyb21oaWdoaW5kZXggLSBmcm9tbG93aW5kZXggKyAxXG5cbiAgICAgICAgbGV0IHRvaGlnaGluZGV4ID0gdG9sb3dpbmRleCArIGZyb21zcGFuIC0gMVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gY29lcmNlIHBhcmFtZXRlcnMgdG8gbGlzdCBib3VuZHMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgbGlzdHNpemUgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnQudmlydHVhbExpc3RQcm9wcy5zaXplXG5cbiAgICAgICAgLy8ga2VlcCB3aXRoaW4gY3VycmVudCBsaXN0IHNpemVcbiAgICAgICAgY29uc3QgbGlzdGhpZ2hpbmRleCA9IGxpc3RzaXplIC0gMVxuXG4gICAgICAgIGlmICh0b2hpZ2hpbmRleCA+IGxpc3RoaWdoaW5kZXgpIHtcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHRvaGlnaGluZGV4IC0gbGlzdGhpZ2hpbmRleFxuICAgICAgICAgICAgdG9oaWdoaW5kZXggPSBNYXRoLm1heCgwLHRvaGlnaGluZGV4IC0gZGlmZilcbiAgICAgICAgICAgIHRvbG93aW5kZXggPSBNYXRoLm1heCgwLHRvbG93aW5kZXggLSBkaWZmKVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbWhpZ2hpbmRleCA+IGxpc3RoaWdoaW5kZXgpIHtcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGZyb21oaWdoaW5kZXggLSBsaXN0aGlnaGluZGV4XG4gICAgICAgICAgICBmcm9taGlnaGluZGV4ID0gTWF0aC5tYXgoMCxmcm9taGlnaGluZGV4IC0gZGlmZilcbiAgICAgICAgICAgIGZyb21sb3dpbmRleCA9IE1hdGgubWF4KDAsZnJvbWxvd2luZGV4IC0gZGlmZilcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBjb25zdHJhaW4gcGFyYW1ldGVycyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG87IG5vIGRpc3BsYWNlbWVudFxuICAgICAgICBpZiAoZnJvbWxvd2luZGV4ID09IHRvbG93aW5kZXgpIHJldHVybiBbXSBcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBwZXJmb3JtIGNhY2hlIGFuZCBjcmFkbGUgb3BlcmF0aW9ucyAtLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVBUEksIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJbmRleExpc3QgPSAvLyBib3RoIGRpc3BsYWNlZCBhbmQgbW92ZWQgaW5kZXhlc1xuICAgICAgICAgICAgY2FjaGVBUEkubW92ZUluZGV4KHRvbG93aW5kZXgsIGZyb21sb3dpbmRleCwgZnJvbWhpZ2hpbmRleClcblxuICAgICAgICBpZiAocHJvY2Vzc2VkSW5kZXhMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBjb250ZW50SGFuZGxlci5zeW5jaHJvbml6ZUNyYWRsZUl0ZW1JRHNUb0NhY2hlKHByb2Nlc3NlZEluZGV4TGlzdClcblxuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBjb250ZW50SGFuZGxlclxuXG4gICAgICAgICAgICBjb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMgPSBjb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZSgwLGNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgICAgICBjb250ZW50LnRhaWxNb2RlbENvbXBvbmVudHMgPSBjb250ZW50LmNyYWRsZU1vZGVsQ29tcG9uZW50cy5zbGljZShjb250ZW50LmhlYWRNb2RlbENvbXBvbmVudHMubGVuZ3RoKVxuXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5bW92ZWNoYW5nZXMnKVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkSW5kZXhMaXN0XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgaW5zZXJ0SW5kZXggPSAoaW5kZXgsIHJhbmdlaGlnaGluZGV4ID0gbnVsbCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGlzSW5kZXhJbnZhbGlkID0gKCFpc0ludGVnZXIoaW5kZXgpIHx8ICFtaW5WYWx1ZShpbmRleCwgMCkpXG4gICAgICAgIGxldCBpc0hpZ2hyYW5nZUludmFsaWQgPSBmYWxzZVxuXG4gICAgICAgIGlmICgoIWlzSW5kZXhJbnZhbGlkKSkge1xuICAgICAgICAgICAgaWYgKCFpc0JsYW5rKHJhbmdlaGlnaGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlzSGlnaHJhbmdlSW52YWxpZCA9ICFtaW5WYWx1ZShyYW5nZWhpZ2hpbmRleCwgaW5kZXgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlaGlnaGluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gK2luZGV4XG5cbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSArcmFuZ2VoaWdoaW5kZXhcblxuICAgICAgICBpZiAoaXNJbmRleEludmFsaWQgfHwgaXNIaWdocmFuZ2VJbnZhbGlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUklHUyBFUlJPUiBpbnNlcnRJbmRleChpbmRleCwgcmFuZ2VoaWdoaW5kZXgpJylcbiAgICAgICAgICAgIGlzSW5kZXhJbnZhbGlkICYmIGNvbnNvbGUubG9nKGluZGV4LCBlcnJvck1lc3NhZ2VzLmluc2VydEZyb20pXG4gICAgICAgICAgICBpc0hpZ2hyYW5nZUludmFsaWQgJiYgY29uc29sZS5sb2cocmFuZ2VoaWdoaW5kZXgsIGVycm9yTWVzc2FnZXMuaW5zZXJ0UmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCArMSlcblxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXggPSBudWxsKSA9PiB7XG5cbiAgICAgICAgY29uc3QgaXNJbmRleEludmFsaWQgPSAoIWlzSW50ZWdlcihpbmRleCkgfHwgIW1pblZhbHVlKGluZGV4LCAwKSlcbiAgICAgICAgbGV0IGlzSGlnaHJhbmdlSW52YWxpZCA9IGZhbHNlXG5cbiAgICAgICAgaWYgKCghaXNJbmRleEludmFsaWQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQmxhbmsocmFuZ2VoaWdoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkID0gIW1pblZhbHVlKHJhbmdlaGlnaGluZGV4LCBpbmRleClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSAraW5kZXhcbiAgICAgICAgcmFuZ2VoaWdoaW5kZXggPSArcmFuZ2VoaWdoaW5kZXhcblxuICAgICAgICBpZiAoaXNJbmRleEludmFsaWQgfHwgaXNIaWdocmFuZ2VJbnZhbGlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUklHUyBFUlJPUiBtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4KScpXG4gICAgICAgICAgICBpc0luZGV4SW52YWxpZCAmJiBjb25zb2xlLmxvZyhpbmRleCwgZXJyb3JNZXNzYWdlcy5yZW1vdmVGcm9tKVxuICAgICAgICAgICAgaXNIaWdocmFuZ2VJbnZhbGlkICYmIGNvbnNvbGUubG9nKHJhbmdlaGlnaGluZGV4LCBlcnJvck1lc3NhZ2VzLnJlbW92ZVJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlbW92ZUluZGV4KGluZGV4LCByYW5nZWhpZ2hpbmRleCwgLTEpXG5cbiAgICB9XG5cbiAgICBuZXdsaXN0c2l6ZVxuXG4gICAgLy8gc2hhcmVkIGxvZ2ljIGZvciBpbnNlcnQgYW5kIHJlbW92ZS4gUmV0dXJucyBsaXN0cyBvZiBpbmRleGVzIHNoaWZ0ZWQsIHJlcGxhY2VkLCBhbmQgcmVtb3ZlZFxuICAgIC8vIHRoaXMgb3BlcmF0aW9uIGNoYW5nZXMgdGhlIGxpc3RzaXplXG4gICAgcHJpdmF0ZSBpbnNlcnRSZW1vdmVJbmRleCA9IChpbmRleCwgcmFuZ2VoaWdoaW5kZXgsIGluY3JlbWVudCkgPT4ge1xuXG4gICAgICAgIC8vIGJhc2ljIGFzc2VydGlvbnNcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLGluZGV4KVxuICAgICAgICByYW5nZWhpZ2hpbmRleCA9IE1hdGgubWF4KHJhbmdlaGlnaGluZGV4LCBpbmRleClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIGFzc2VtYmxlIHJlc291cmNlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVBUEksIGNvbnRlbnRIYW5kbGVyLCBzdGF0ZUhhbmRsZXIgfSA9IFxuICAgICAgICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnRcblxuICAgICAgICBjb25zdCBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSB0aGlzLmNyYWRsZVBhcmFtZXRlcnMuY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcbiAgICAgICAgY29uc3QgY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyA9IHRoaXMuY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnRcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIHByb2Nlc3MgY2FjaGUgLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb25zdCBsaXN0c2l6ZSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllcy52aXJ0dWFsTGlzdFByb3BzLnNpemVcbiAgICAgICAgaWYgKGxpc3RzaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRMaXN0c2l6ZShyYW5nZWhpZ2hpbmRleCAtIGluZGV4ICsgMSlcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtbXSxbXSxbXV1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtzdGFydENoYW5nZUluZGV4LCByYW5nZWluY3JlbWVudCwgc2hpZnRlZExpc3QsIHJlbW92ZWRMaXN0LCByZXBsYWNlTGlzdCwgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0XSA9IFxuICAgICAgICAgICAgY2FjaGVBUEkuaW5zZXJ0UmVtb3ZlSW5kZXgoaW5kZXgsIHJhbmdlaGlnaGluZGV4LCBpbmNyZW1lbnQsIGxpc3RzaXplKSAvLywgY3JhZGxlSW5kZXhTcGFuKVxuXG4gICAgICAgIGlmIChyYW5nZWluY3JlbWVudCA9PT0gbnVsbCkgcmV0dXJuIFtbXSxbXSxbXV0gLy8gbm8gYWN0aW9uXG5cbiAgICAgICAgLy8gcGFydGl0aW9uSXRlbXMgdG8gZGVsZXRlIHdpdGggZm9sbG93dXAgc3RhdGUgY2hhbmdlcyAtIG11c3QgaGFwcGVuIGFmdGVyIGNyYWRsZSB1cGRhdGVcbiAgICAgICAgY2FjaGVBUEkucG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0ID0gcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBzeW5jaHJvbml6ZSBjcmFkbGUgdG8gY2FjaGUgY2hhbmdlcyAtLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGNyYWRsZSBtdXN0IGJlIHJlc2V0IG9yIHNpbXBseSBhZGp1c3RlZFxuICAgICAgICBjb25zdCBjaGFuZ2Vjb3VudCA9IHJhbmdlaW5jcmVtZW50IC8vIHNlbWFudGljc1xuICAgICAgICBjb25zdCBuZXdsaXN0c2l6ZSA9IHRoaXMubmV3bGlzdHNpemUgPSBsaXN0c2l6ZSArIGNoYW5nZWNvdW50XG5cbiAgICAgICAgLy8gY29uc3QgeyB2aWV3cG9ydFJvd2NvdW50IH0gPSBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgeyBjcmFkbGVDb250ZW50UHJvcHMsIHZpcnR1YWxMaXN0UHJvcHMgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllc1xuICAgICAgICAvLyBjb25zdCB7IGNyb3NzY291bnQgfSA9IGNyYWRsZUludGVybmFsUHJvcGVydGllcy52aXJ0dWFsTGlzdFByb3BzXG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnRSb3djb3VudCB9ID0gY3JhZGxlQ29udGVudFByb3BzXG4gICAgICAgIGNvbnN0IHsgY3Jvc3Njb3VudCB9ID0gdmlydHVhbExpc3RQcm9wc1xuICAgICAgICAvLyBjb25zdCB7IHJ1bndheVNpemUgfSA9ICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHsgbG93aW5kZXg6bG93Q3JhZGxlSW5kZXgsIGhpZ2hpbmRleDpoaWdoQ3JhZGxlSW5kZXgsIHNpemU6Y3JhZGxlU2l6ZSwgcnVud2F5Um93Y291bnQ6cnVud2F5U2l6ZSB9ID0gY3JhZGxlQ29udGVudFByb3BzXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVSb3djb3VudCA9IHZpZXdwb3J0Um93Y291bnQgKyAocnVud2F5U2l6ZSAqIDIpXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQgPSBjYWxjdWxhdGVkQ3JhZGxlUm93Y291bnQgKiBjcm9zc2NvdW50XG5cbiAgICAgICAgLy8gY29uc3QgaW5kZXhTcGFuID0gY29udGVudEhhbmRsZXIuaW5kZXhTcGFuXG4gICAgICAgIC8vIGNvbnN0IFtsb3dDcmFkbGVJbmRleCxoaWdoQ3JhZGxlSW5kZXhdID0gaW5kZXhTcGFuXG4gICAgICAgIC8vIGNvbnN0IG1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50ID0gKGluZGV4U3Bhbi5sZW5ndGggPT0gMCk/MDpoaWdoQ3JhZGxlSW5kZXggLSBsb3dDcmFkbGVJbmRleCArIDFcbiAgICAgICAgY29uc3QgbWVhc3VyZWRDcmFkbGVJdGVtQ291bnQgPSAoY3JhZGxlU2l6ZSA9PSAwKT8wOmhpZ2hDcmFkbGVJbmRleCAtIGxvd0NyYWRsZUluZGV4ICsgMVxuXG4gICAgICAgIGNvbnN0IHJlc2V0Q3JhZGxlID0gKChtZWFzdXJlZENyYWRsZUl0ZW1Db3VudCA8IGNhbGN1bGF0ZWRDcmFkbGVJdGVtY291bnQpIHx8IFxuICAgICAgICAgICAgLy8gKGNvbnRlbnRIYW5kbGVyLmluZGV4U3BhblsxXSA+PSAobmV3bGlzdHNpemUgLSAxKSkpXG4gICAgICAgICAgICAoaGlnaENyYWRsZUluZGV4ID49IChuZXdsaXN0c2l6ZSAtIDEpKSlcblxuICAgICAgICBpZiAoIXJlc2V0Q3JhZGxlKSB7IC8vIHN5bmNocm9uaXplIGNyYWRsZSBjb250ZW50cyB0byBjaGFuZ2VzXG5cbiAgICAgICAgICAgIGNvbnRlbnRIYW5kbGVyLnN5bmNocm9uaXplQ3JhZGxlSXRlbUlEc1RvQ2FjaGUoc2hpZnRlZExpc3QsIGluY3JlbWVudCwgc3RhcnRDaGFuZ2VJbmRleCkgLy8gbm9uLXplcm8gY29tbXVuaWNhdGlvbnMgaXNJbnNlcnRSZW1vdmVcblxuICAgICAgICAgICAgLy8gaWYgKGluY3JlbWVudCA9PSArMSkgY29udGVudEhhbmRsZXIuY3JlYXRlTmV3SXRlbUlEcyhyZXBsYWNlTGlzdClcblxuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBjb250ZW50SGFuZGxlclxuXG4gICAgICAgICAgICAvLyBjb25zdCByZXF1ZXN0ZWRTZXQgPSBjYWNoZUFQSS5jYWNoZVByb3BzLnJlcXVlc3RlZFNldFxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkU2V0ID0gY2FjaGVBUEkucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IC8vIHdhaXQgdW50aWwgY2hhbmdlZCBjYWNoZSBlbnRyaWVzIHVwZGF0ZSB0aGUgY3JhZGxlXG5cbiAgICAgICAgICAgICAgICBpZighcmVxdWVzdGVkU2V0LnNpemUpIHsgLy8gZmluaXNoZWQgY29sbGVjdGluZyBuZXcgY2FjaGUgZW50cmllc1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZW91dCk7IFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaGVhZE1vZGVsQ29tcG9uZW50cyA9IGNvbnRlbnQuY3JhZGxlTW9kZWxDb21wb25lbnRzLnNsaWNlKDAsY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC50YWlsTW9kZWxDb21wb25lbnRzID0gY29udGVudC5jcmFkbGVNb2RlbENvbXBvbmVudHMuc2xpY2UoY29udGVudC5oZWFkTW9kZWxDb21wb25lbnRzLmxlbmd0aClcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUhhbmRsZXIuc2V0Q3JhZGxlU3RhdGUoJ2FwcGx5aW5zZXJ0cmVtb3ZlY2hhbmdlcycpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gY3JhZGxlIHRvIGJlIGNvbXBsZXRlbHkgcmVzZXQgaWYgbGlzdHNpemUgY2hhbmdlIGVuY3JvYWNoZXMgb24gY3JhZGxlXG5cbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5zZXRDcmFkbGVTdGF0ZSgnY2hhbm5lbGNyYWRsZXJlc2V0YWZ0ZXJpbnNlcnRyZW1vdmUnKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXBsYWNlZExpc3QgPSByZXBsYWNlTGlzdCAvLyBzZW1hbnRpY3NcblxuICAgICAgICByZXR1cm4gW3NoaWZ0ZWRMaXN0LCByZXBsYWNlZExpc3QsIHJlbW92ZWRMaXN0XSAvLyBpbmZvcm0gY2FsbGVyXG5cbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiaXNCbGFuayIsInRlc3R2YWx1ZSIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUludCIsImlzSW50ZWdlciIsIk1hdGgiLCJmbG9vciIsIm1pblZhbHVlIiwidGVzdE1pblZhbHVlIiwibWF4VmFsdWUiLCJ0ZXN0TWF4VmFsdWUiLCJlcnJvck1lc3NhZ2VzIiwic2Nyb2xsVG9JbmRleCIsInNldExpc3RzaXplIiwiaW5zZXJ0RnJvbSIsImluc2VydFJhbmdlIiwicmVtb3ZlRnJvbSIsInJlbW92ZVJhbmdlIiwibW92ZUZyb20iLCJtb3ZlUmFuZ2UiLCJtb3ZlVG8iLCJTZXJ2aWNlSGFuZGxlciIsImNyYWRsZVBhcmFtZXRlcnMiLCJfdGhpcyIsInJlbG9hZCIsInN0YXRlSGFuZGxlciIsImhhbmRsZXJzUmVmIiwiY3VycmVudCIsImludGVycnVwdEhhbmRsZXIiLCJwYXVzZUludGVycnVwdHMiLCJzZXRDcmFkbGVTdGF0ZSIsImluZGV4IiwiaXNJbnZhbGlkIiwiY29uc29sZSIsImxvZyIsInNpZ25hbHMiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIiLCJsYXlvdXRIYW5kbGVyIiwicGF1c2VTY3JvbGxpbmdFZmZlY3RzIiwiY3JhZGxlUG9zaXRpb25EYXRhIiwidGFyZ2V0QXhpc1JlZmVyZW5jZVBvc2l0aW9uIiwibmV3bGlzdHNpemUiLCJfdGhpcyRjcmFkbGVQYXJhbWV0ZXIyIiwiY2FjaGVBUEkiLCJjb250ZW50SGFuZGxlciIsIl90aGlzJGNhbGxiYWNrcyIsImNhbGxiYWNrcyIsImRlbGV0ZUxpc3RDYWxsYmFjayIsImNoYW5nZUxpc3RzaXplQ2FsbGJhY2siLCJjdXJyZW50bGlzdHNpemUiLCJjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYiLCJ2aXJ0dWFsTGlzdFByb3BzIiwic2l6ZSIsImNhY2hlIiwiY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllc1JlZiIsImRMaXN0Q2FsbGJhY2siLCJkZWxldGVMaXN0IiwidXBkYXRlVmlydHVhbExpc3RTcGVjcyIsImNoYW5nZUNhY2hlTGlzdHNpemUiLCJyZW5kZXJQb3J0YWxMaXN0cyIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDYWNoZUl0ZW1NYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjMiLCJtb2RlbEluZGV4TGlzdCIsImdldE1vZGVsSW5kZXhMaXN0IiwiY2xlYXJDYWNoZSIsInJlbWFwSW5kZXhlcyIsImNoYW5nZU1hcCIsIl90aGlzJGNyYWRsZVBhcmFtZXRlcjQiLCJpdGVtTWV0YWRhdGFNYXAiLCJpbmRleFRvSXRlbUlETWFwIiwiaXRlbVNldCIsImluZGV4ZXNUb0RlbGV0ZUxpc3QiLCJpbmRleGVzVG9SZXBsYWNlSXRlbUlETGlzdCIsInBhcnRpdGlvbkl0ZW1zVG9SZXBsYWNlTGlzdCIsImNoYW5nZUluZGV4VG9JdGVtSURNYXAiLCJNYXAiLCJlcnJvckVudHJpZXNNYXAiLCJ3b3JraW5nQ2hhbmdlTWFwIiwiZm9yRWFjaCIsIml0ZW1JRCIsImhhcyIsImNhY2hlSXRlbUlEIiwiZ2V0IiwiX2l0ZW1NZXRhZGF0YU1hcCRnZXQiLCJwYXJ0aXRpb25JRCIsInNldCIsIml0ZW1zVG9SZXBsYWNlU2V0IiwiU2V0IiwiYWRkIiwiY29uY2F0IiwibWFwc2l6ZSIsIml0ZW1JRFNldCIsInZhbHVlcyIsIml0ZW1zZXRzaXplIiwiaXRlbUlEQ291bnRNYXAiLCJjb3VudCIsImR1cGxpY2F0ZUl0ZW1zTWFwIiwiZHVwbGljYXRlc1RvUmVtb3ZlTGlzdCIsIm9yaWdpbmFsTWFwIiwicHJvY2Vzc2VkSW5kZXhMaXN0IiwiaXRlbWRhdGEiLCJkZWxldGVkSXRlbUlEVG9JbmRleE1hcCIsImRlbGV0ZWRJbmRleFRvSXRlbUlETWFwIiwicG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0Iiwib3JpZ2luYWxJdGVtSUQiLCJvcmlnaW5hbEl0ZW1JREluZGV4IiwiZmluYWxJdGVtSURJbmRleCIsIl9pdGVtTWV0YWRhdGFNYXAkZ2V0MiIsImZpbmFsSXRlbUlEIiwiZGVsZXRlZE9ycGhhbmVkSXRlbUluZGV4TGlzdCIsImRlbGV0ZWRPcnBoYW5lZEluZGV4TGlzdCIsImtleXMiLCJkZWxldGVkT3JwaGFuZWRJdGVtSURMaXN0IiwibW9kaWZpZWRJbmRleExpc3QiLCJjcmVhdGVOZXdJdGVtSURzIiwicmVjb25jaWxlQ2VsbEZyYW1lcyIsIm1vdmVJbmRleCIsInRvbG93aW5kZXgiLCJmcm9tbG93aW5kZXgiLCJmcm9taGlnaGluZGV4IiwiYXJndW1lbnRzIiwiaXNUb2luZGV4SW52YWxpZCIsImlzRnJvbWluZGV4SW52YWxpZCIsImlzSGlnaHJhbmdlSW52YWxpZCIsIm1heCIsImZyb21zcGFuIiwidG9oaWdoaW5kZXgiLCJsaXN0c2l6ZSIsImxpc3RoaWdoaW5kZXgiLCJkaWZmIiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyNSIsInN5bmNocm9uaXplQ3JhZGxlSXRlbUlEc1RvQ2FjaGUiLCJjb250ZW50IiwiaGVhZE1vZGVsQ29tcG9uZW50cyIsImNyYWRsZU1vZGVsQ29tcG9uZW50cyIsInRhaWxNb2RlbENvbXBvbmVudHMiLCJpbnNlcnRJbmRleCIsInJhbmdlaGlnaGluZGV4IiwiaXNJbmRleEludmFsaWQiLCJpbnNlcnRSZW1vdmVJbmRleCIsInJlbW92ZUluZGV4IiwiaW5jcmVtZW50IiwiX3RoaXMkY3JhZGxlUGFyYW1ldGVyNiIsImNyYWRsZUludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJfY2FjaGVBUEkkaW5zZXJ0UmVtb3YiLCJfY2FjaGVBUEkkaW5zZXJ0UmVtb3YyIiwic3RhcnRDaGFuZ2VJbmRleCIsInJhbmdlaW5jcmVtZW50Iiwic2hpZnRlZExpc3QiLCJyZW1vdmVkTGlzdCIsInJlcGxhY2VMaXN0IiwiY2hhbmdlY291bnQiLCJjcmFkbGVDb250ZW50UHJvcHMiLCJ2aWV3cG9ydFJvd2NvdW50IiwiY3Jvc3Njb3VudCIsImxvd0NyYWRsZUluZGV4IiwibG93aW5kZXgiLCJoaWdoQ3JhZGxlSW5kZXgiLCJoaWdoaW5kZXgiLCJjcmFkbGVTaXplIiwicnVud2F5U2l6ZSIsInJ1bndheVJvd2NvdW50IiwiY2FsY3VsYXRlZENyYWRsZVJvd2NvdW50IiwiY2FsY3VsYXRlZENyYWRsZUl0ZW1jb3VudCIsIm1lYXN1cmVkQ3JhZGxlSXRlbUNvdW50IiwicmVzZXRDcmFkbGUiLCJyZXF1ZXN0ZWRTZXQiLCJ0aW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmVwbGFjZWRMaXN0IiwiX2NyYWRsZVBhcmFtZXRlcnMkZXh0IiwiZXh0ZXJuYWxDYWxsYmFja3NSZWYiLCJyZWZlcmVuY2VJbmRleENhbGxiYWNrIiwicHJlbG9hZEluZGV4Q2FsbGJhY2siLCJpdGVtRXhjZXB0aW9uQ2FsbGJhY2siLCJyZXBvc2l0aW9uaW5nRmxhZ0NhbGxiYWNrIiwicmVwb3NpdGlvbmluZ0luZGV4Q2FsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/servicehandler.tsx\n')},"./src/cradle/statehandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval('\n\n// statehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n   This module provides access to the cradle state and the state setting for other handlers.\n   It also provides access to the isMountedRef reference.\n*/\nvar StateHandler = /*#__PURE__*/_createClass(function StateHandler(cradleParameters) {\n  _classCallCheck(this, StateHandler);\n  this.cradleParameters = cradleParameters;\n  var internalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n  this.setCradleState = internalProperties.setCradleState;\n  this.cradleStateRef = internalProperties.cradleStateRef;\n  this.isMountedRef = internalProperties.isMountedRef;\n});\nexports["default"] = StateHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3JhZGxlL3N0YXRlaGFuZGxlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUEsU0FBQUEsUUFBQUMsR0FBQSxzQ0FBQUQsT0FBQSx3QkFBQUUsTUFBQSx1QkFBQUEsTUFBQSxDQUFBQyxRQUFBLGFBQUFGLEdBQUEsa0JBQUFBLEdBQUEsZ0JBQUFBLEdBQUEsV0FBQUEsR0FBQSx5QkFBQUMsTUFBQSxJQUFBRCxHQUFBLENBQUFHLFdBQUEsS0FBQUYsTUFBQSxJQUFBRCxHQUFBLEtBQUFDLE1BQUEsQ0FBQUcsU0FBQSxxQkFBQUosR0FBQSxLQUFBRCxPQUFBLENBQUFDLEdBQUE7QUFBQSxTQUFBSyxrQkFBQUMsTUFBQSxFQUFBQyxLQUFBLGFBQUFDLENBQUEsTUFBQUEsQ0FBQSxHQUFBRCxLQUFBLENBQUFFLE1BQUEsRUFBQUQsQ0FBQSxVQUFBRSxVQUFBLEdBQUFILEtBQUEsQ0FBQUMsQ0FBQSxHQUFBRSxVQUFBLENBQUFDLFVBQUEsR0FBQUQsVUFBQSxDQUFBQyxVQUFBLFdBQUFELFVBQUEsQ0FBQUUsWUFBQSx3QkFBQUYsVUFBQSxFQUFBQSxVQUFBLENBQUFHLFFBQUEsU0FBQUMsTUFBQSxDQUFBQyxjQUFBLENBQUFULE1BQUEsRUFBQVUsY0FBQSxDQUFBTixVQUFBLENBQUFPLEdBQUEsR0FBQVAsVUFBQTtBQUFBLFNBQUFRLGFBQUFDLFdBQUEsRUFBQUMsVUFBQSxFQUFBQyxXQUFBLFFBQUFELFVBQUEsRUFBQWYsaUJBQUEsQ0FBQWMsV0FBQSxDQUFBZixTQUFBLEVBQUFnQixVQUFBLE9BQUFDLFdBQUEsRUFBQWhCLGlCQUFBLENBQUFjLFdBQUEsRUFBQUUsV0FBQSxHQUFBUCxNQUFBLENBQUFDLGNBQUEsQ0FBQUksV0FBQSxpQkFBQU4sUUFBQSxtQkFBQU0sV0FBQTtBQUFBLFNBQUFILGVBQUFNLEdBQUEsUUFBQUwsR0FBQSxHQUFBTSxZQUFBLENBQUFELEdBQUEsb0JBQUF2QixPQUFBLENBQUFrQixHQUFBLGlCQUFBQSxHQUFBLEdBQUFPLE1BQUEsQ0FBQVAsR0FBQTtBQUFBLFNBQUFNLGFBQUFFLEtBQUEsRUFBQUMsSUFBQSxRQUFBM0IsT0FBQSxDQUFBMEIsS0FBQSxrQkFBQUEsS0FBQSxrQkFBQUEsS0FBQSxNQUFBRSxJQUFBLEdBQUFGLEtBQUEsQ0FBQXhCLE1BQUEsQ0FBQTJCLFdBQUEsT0FBQUQsSUFBQSxLQUFBRSxTQUFBLFFBQUFDLEdBQUEsR0FBQUgsSUFBQSxDQUFBSSxJQUFBLENBQUFOLEtBQUEsRUFBQUMsSUFBQSxvQkFBQTNCLE9BQUEsQ0FBQStCLEdBQUEsdUJBQUFBLEdBQUEsWUFBQUUsU0FBQSw0REFBQU4sSUFBQSxnQkFBQUYsTUFBQSxHQUFBUyxNQUFBLEVBQUFSLEtBQUE7QUFBQSxTQUFBUyxnQkFBQUMsUUFBQSxFQUFBaEIsV0FBQSxVQUFBZ0IsUUFBQSxZQUFBaEIsV0FBQSxlQUFBYSxTQUFBOzs7O0FBRUE7Ozs7QUFBQSxJQUtxQkksWUFBWSxnQkFBQWxCLFlBQUEsQ0FFN0IsU0FBQWtCLGFBQVlDLGdCQUFnQjtFQUFBSCxlQUFBLE9BQUFFLFlBQUE7RUFFekIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0EsZ0JBQWdCO0VBRXhDLElBQU1DLGtCQUFrQixHQUFHRCxnQkFBZ0IsQ0FBQ0UsMkJBQTJCLENBQUNDLE9BQU87RUFFL0UsSUFBSSxDQUFDQyxjQUFjLEdBQUdILGtCQUFrQixDQUFDRyxjQUFjO0VBQ3ZELElBQUksQ0FBQ0MsY0FBYyxHQUFHSixrQkFBa0IsQ0FBQ0ksY0FBYztFQUN2RCxJQUFJLENBQUNDLFlBQVksR0FBR0wsa0JBQWtCLENBQUNLLFlBQVk7QUFFdEQsQ0FBQztBQVpMQyxrQkFBQSxHQUFBUixZQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL3NyYy9jcmFkbGUvc3RhdGVoYW5kbGVyLnRzeD82Mzk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICBUaGlzIG1vZHVsZSBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGNyYWRsZSBzdGF0ZSBhbmQgdGhlIHN0YXRlIHNldHRpbmcgZm9yIG90aGVyIGhhbmRsZXJzLlxuICAgSXQgYWxzbyBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGlzTW91bnRlZFJlZiByZWZlcmVuY2UuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3JhZGxlUGFyYW1ldGVycykge1xuXG4gICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgICAgY29uc3QgaW50ZXJuYWxQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbnRlcm5hbFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgdGhpcy5zZXRDcmFkbGVTdGF0ZSA9IGludGVybmFsUHJvcGVydGllcy5zZXRDcmFkbGVTdGF0ZVxuICAgICAgIHRoaXMuY3JhZGxlU3RhdGVSZWYgPSBpbnRlcm5hbFByb3BlcnRpZXMuY3JhZGxlU3RhdGVSZWZcbiAgICAgICB0aGlzLmlzTW91bnRlZFJlZiA9IGludGVybmFsUHJvcGVydGllcy5pc01vdW50ZWRSZWZcbiAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyYWRsZVBhcmFtZXRlcnNcblxuICAgIHB1YmxpYyBjcmFkbGVTdGF0ZVJlZlxuICAgIHB1YmxpYyBzZXRDcmFkbGVTdGF0ZVxuICAgIHB1YmxpYyBpc01vdW50ZWRSZWZcblxufVxuIl0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiY2FsbCIsIlR5cGVFcnJvciIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiU3RhdGVIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsImludGVybmFsUHJvcGVydGllcyIsImNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZiIsImN1cnJlbnQiLCJzZXRDcmFkbGVTdGF0ZSIsImNyYWRsZVN0YXRlUmVmIiwiaXNNb3VudGVkUmVmIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/cradle/statehandler.tsx\n')},"./src/cradle/styleshandler.tsx":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n// styleshandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n/*\n    This module provides the Cradle component with one key function: getCradleStyles.\n    It returns an array of style objects for\n        headstyles,\n        tailstyles,\n        axisstyles,\n        cradledividerstyles\n        triggercelltriggerlineheadstyles,\n        triggercelltriggerlinetailstyles,\n*/\nvar StylesHandler = /*#__PURE__*/_createClass(function StylesHandler(cradleParameters) {\n  var _this = this;\n  _classCallCheck(this, StylesHandler);\n  this.getCradleStyles = function (_ref) {\n    var orientation = _ref.orientation,\n      cellHeight = _ref.cellHeight,\n      cellWidth = _ref.cellWidth,\n      gap = _ref.gap,\n      padding = _ref.padding,\n      crosscount = _ref.crosscount,\n      userstyles = _ref.userstyles,\n      triggerlineOffset = _ref.triggerlineOffset,\n      layout = _ref.layout;\n    var headstyles = _this.getBaseHeadStyles(gap, padding, orientation, userstyles.cradle);\n    var tailstyles = _this.getBaseTailStyles(gap, padding, orientation, userstyles.cradle);\n    var axisstyles = _this.getAxisStyles(gap, padding, orientation);\n    var triggercelltriggerlineheadstyles = _this.getTriggercellTriggerlineHeadStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var triggercelltriggerlinetailstyles = _this.getTriggercellTriggerlineTailStyles(orientation, cellHeight, cellWidth, triggerlineOffset, gap);\n    var cradledividerstyles = {\n      zIndex: 1,\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      boxShadow: '0 0 5px 3px red'\n    };\n    headstyles.gap = tailstyles.gap = gap + 'px';\n    // headstyles.padding set in contentHandler setCradleContent and updateCradleContent\n    if (orientation == 'vertical') {\n      // padding varies\n      tailstyles.padding = \"0 \".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px\");\n      // the following are identical for head and tail\n      headstyles.width = tailstyles.width = '100%';\n      headstyles.height = tailstyles.height = 'auto';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = null;\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellWidth, \"px, 1fr))\");\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'row';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = layout == 'uniform' ? null : 'max-content';\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = null;\n    } else {\n      // orientation == 'horizontal'\n      tailstyles.padding = \"\".concat(padding, \"px \").concat(padding, \"px \").concat(padding, \"px 0\");\n      headstyles.width = tailstyles.width = 'auto';\n      headstyles.height = tailstyles.height = '100%';\n      headstyles.gridTemplateRows = tailstyles.gridTemplateRows = \"repeat(\".concat(crosscount, \", minmax(\").concat(cellHeight, \"px, 1fr))\");\n      headstyles.gridTemplateColumns = tailstyles.gridTemplateColumns = null;\n      headstyles.gridAutoFlow = tailstyles.gridAutoFlow = 'column';\n      headstyles.gridAutoRows = tailstyles.gridAutoRows = null;\n      headstyles.gridAutoColumns = tailstyles.gridAutoColumns = layout == 'uniform' ? null : 'max-content';\n    }\n    return [headstyles, tailstyles, axisstyles, cradledividerstyles, triggercelltriggerlineheadstyles, triggercelltriggerlinetailstyles];\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseHeadStyles = function (gap, padding, orientation, userheadstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = 0;\n      left = null;\n      right = null;\n      top = null;\n    } else {\n      bottom = null;\n      left = null;\n      right = 0;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, userheadstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      bottom: bottom,\n      left: left,\n      right: right,\n      top: top\n    });\n  };\n  // the top, right, bottom, left setting determine the direction of expansion of the grid block\n  this.getBaseTailStyles = function (gap, padding, orientation, usertailstyles) {\n    var bottom, left, top, right;\n    if (orientation == 'vertical') {\n      bottom = null;\n      left = null;\n      right = null;\n      top = 0;\n    } else {\n      bottom = null;\n      left = 0;\n      right = null;\n      top = null;\n    }\n    return Object.assign(Object.assign({}, usertailstyles), {\n      position: 'absolute',\n      display: 'grid',\n      gridGap: gap + 'px',\n      padding: padding + 'px',\n      boxSizing: 'border-box',\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n  };\n  this.getAxisStyles = function (gap, padding, orientation) {\n    var top, left, width, height; // for axis\n    if (orientation == 'vertical') {\n      top = padding + 'px'; // default\n      left = 'auto';\n      width = '100%';\n      height = 0;\n    } else {\n      top = 'auto';\n      left = padding + 'px'; // default\n      width = 0;\n      height = '100%';\n    }\n    return {\n      position: 'relative',\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n  this.getTriggercellTriggerlineHeadStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = triggerlineOffset + 'px';\n      right = '0px';\n      bottom = null;\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = null;\n      bottom = '0px';\n      left = triggerlineOffset + 'px';\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.getTriggercellTriggerlineTailStyles = function (orientation, cellHeight, cellWidth, triggerlineOffset, gap) {\n    var position = 'absolute';\n    var width, height, top, right, bottom, left;\n    if (orientation == 'vertical') {\n      width = '100%';\n      height = 0;\n      top = null;\n      right = '0px';\n      bottom = -(triggerlineOffset + gap) + 'px';\n      left = '0px';\n    } else {\n      width = 0;\n      height = '100%';\n      top = '0px';\n      right = -(triggerlineOffset + gap) + 'px';\n      bottom = '0px';\n      left = null;\n    }\n    return {\n      position: position,\n      width: width,\n      height: height,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n  this.cradleParameters = cradleParameters;\n});\nexports[\"default\"] = StylesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVLLGlCQUFpQixFQUFFSixHQUFHLEVBQUk7SUFFL0QsSUFBTW1CLFFBQVEsR0FBRyxVQUFVO0lBRTNCLElBQUlDLEtBQUssRUFBRUMsTUFBTSxFQUFFVyxHQUFHLEVBQUVDLEtBQUssRUFBRUgsTUFBTSxFQUFFQyxJQUFJO0lBQzNDLElBQUlsQyxXQUFXLElBQUksVUFBVSxFQUFFO01BRTNCdUIsS0FBSyxHQUFHLE1BQU07TUFDZEMsTUFBTSxHQUFHLENBQUM7TUFDVlcsR0FBRyxHQUFHLElBQUk7TUFDVkMsS0FBSyxHQUFHLEtBQUs7TUFDYkgsTUFBTSxHQUFHLEVBQUUxQixpQkFBaUIsR0FBR0osR0FBRyxDQUFDLEdBQUcsSUFBSTtNQUMxQytCLElBQUksR0FBRyxLQUFLO0tBRWYsTUFBTTtNQUVIWCxLQUFLLEdBQUcsQ0FBQztNQUNUQyxNQUFNLEdBQUcsTUFBTTtNQUNmVyxHQUFHLEdBQUcsS0FBSztNQUNYQyxLQUFLLEdBQUcsRUFBRTdCLGlCQUFpQixHQUFHSixHQUFHLENBQUMsR0FBRyxJQUFJO01BQ3pDOEIsTUFBTSxHQUFHLEtBQUs7TUFDZEMsSUFBSSxHQUFHLElBQUk7O0lBSWYsT0FBTztNQUVIWixRQUFRLEVBQVJBLFFBQVE7TUFDUkMsS0FBSyxFQUFMQSxLQUFLO01BQ0xDLE1BQU0sRUFBTkEsTUFBTTtNQUNOVyxHQUFHLEVBQUhBLEdBQUc7TUFDSEMsS0FBSyxFQUFMQSxLQUFLO01BQ0xILE1BQU0sRUFBTkEsTUFBTTtNQUNOQyxJQUFJLEVBQUpBO0tBRUg7RUFDTCxDQUFDO0VBdlJDLElBQUksQ0FBQ3RDLGdCQUFnQixHQUFHQSxnQkFBZ0I7QUFFMUMsQ0FBQztBQU5MOEMsa0JBQUEsR0FBQS9DLGFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL2NyYWRsZS9zdHlsZXNoYW5kbGVyLnRzeD80NWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlc2hhbmRsZXIudHN4XG4vLyBjb3B5cmlnaHQgKGMpIDIwMTktMjAyMyBIZW5yaWsgQmVjaG1hbm4sIFRvcm9udG8sIExpY2VuY2U6IE1JVFxuXG4vKlxuICAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBDcmFkbGUgY29tcG9uZW50IHdpdGggb25lIGtleSBmdW5jdGlvbjogZ2V0Q3JhZGxlU3R5bGVzLlxuICAgIEl0IHJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyBmb3JcbiAgICAgICAgaGVhZHN0eWxlcyxcbiAgICAgICAgdGFpbHN0eWxlcyxcbiAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgY3JhZGxlZGl2aWRlcnN0eWxlc1xuICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMsXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZXNIYW5kbGVyIHsgXG5cbiAgIGNvbnN0cnVjdG9yKGNyYWRsZVBhcmFtZXRlcnMpIHtcblxuICAgICAgdGhpcy5jcmFkbGVQYXJhbWV0ZXJzID0gY3JhZGxlUGFyYW1ldGVyc1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICBwdWJsaWMgZ2V0Q3JhZGxlU3R5bGVzID0gKHtcblxuICAgICAgICBvcmllbnRhdGlvbiwgXG4gICAgICAgIGNlbGxIZWlnaHQsIFxuICAgICAgICBjZWxsV2lkdGgsIFxuICAgICAgICAvLyBjZWxsTWluSGVpZ2h0LFxuICAgICAgICAvLyBjZWxsTWluV2lkdGgsXG4gICAgICAgIGdhcCxcbiAgICAgICAgcGFkZGluZywgXG4gICAgICAgIGNyb3NzY291bnQsIFxuICAgICAgICAvLyB2aWV3cG9ydGhlaWdodCwgXG4gICAgICAgIC8vIHZpZXdwb3J0d2lkdGgsXG4gICAgICAgIHVzZXJzdHlsZXMsXG4gICAgICAgIHRyaWdnZXJsaW5lT2Zmc2V0LFxuICAgICAgICBsYXlvdXQsXG5cbiAgICB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgaGVhZHN0eWxlcyA9IHRoaXMuZ2V0QmFzZUhlYWRTdHlsZXMoZ2FwLCBwYWRkaW5nLCBvcmllbnRhdGlvbiwgdXNlcnN0eWxlcy5jcmFkbGUpXG4gICAgICAgIGNvbnN0IHRhaWxzdHlsZXMgPSB0aGlzLmdldEJhc2VUYWlsU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24sIHVzZXJzdHlsZXMuY3JhZGxlKVxuICAgICAgICBjb25zdCBheGlzc3R5bGVzID0gdGhpcy5nZXRBeGlzU3R5bGVzKGdhcCwgcGFkZGluZywgb3JpZW50YXRpb24pXG5cbiAgICAgICAgY29uc3QgdHJpZ2dlcmNlbGx0cmlnZ2VybGluZWhlYWRzdHlsZXMgPVxuICAgICAgICAgICAgdGhpcy5nZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyhcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbixjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHRyaWdnZXJsaW5lT2Zmc2V0LCBnYXApXG4gICAgICAgIGNvbnN0IHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzID0gXG4gICAgICAgICAgICB0aGlzLmdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVUYWlsU3R5bGVzKFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcClcblxuICAgICAgICBjb25zdCBjcmFkbGVkaXZpZGVyc3R5bGVzID0gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgekluZGV4OjEsIFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOidhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6JzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDonMTAwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OicwIDAgNXB4IDNweCByZWQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaGVhZHN0eWxlcy5nYXAgPSB0YWlsc3R5bGVzLmdhcCA9IGdhcCArICdweCdcblxuICAgICAgICAvLyBoZWFkc3R5bGVzLnBhZGRpbmcgc2V0IGluIGNvbnRlbnRIYW5kbGVyIHNldENyYWRsZUNvbnRlbnQgYW5kIHVwZGF0ZUNyYWRsZUNvbnRlbnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgLy8gcGFkZGluZyB2YXJpZXNcbiAgICAgICAgICAgIHRhaWxzdHlsZXMucGFkZGluZyA9IGAwICR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4YFxuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBpZGVudGljYWwgZm9yIGhlYWQgYW5kIHRhaWxcbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSB0YWlsc3R5bGVzLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9IHRhaWxzdHlsZXMuaGVpZ2h0ID0gJ2F1dG8nXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXG4gICAgICAgICAgICB0YWlsc3R5bGVzLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICAgICAgYHJlcGVhdCgke2Nyb3NzY291bnR9LCBtaW5tYXgoJHtjZWxsV2lkdGh9cHgsIDFmcikpYFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvRmxvdyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9GbG93ID0gJ3JvdydcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b1Jvd3MgPSBcbiAgICAgICAgICAgIHRhaWxzdHlsZXMuZ3JpZEF1dG9Sb3dzID1cbiAgICAgICAgICAgICAgICAobGF5b3V0ID09ICd1bmlmb3JtJyk/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICdtYXgtY29udGVudCdcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSB0YWlsc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IG51bGxcblxuICAgICAgICB9IGVsc2UgeyAvLyBvcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCdcblxuICAgICAgICAgICAgdGFpbHN0eWxlcy5wYWRkaW5nID0gYCR7cGFkZGluZ31weCAke3BhZGRpbmd9cHggJHtwYWRkaW5nfXB4IDBgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMud2lkdGggPSB0YWlsc3R5bGVzLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmhlaWdodCA9IHRhaWxzdHlsZXMuaGVpZ2h0ID0gJzEwMCUnXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlUm93cyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkVGVtcGxhdGVSb3dzID0gXG4gICAgICAgICAgICAgICAgICAgIGByZXBlYXQoJHtjcm9zc2NvdW50fSwgbWlubWF4KCR7Y2VsbEhlaWdodH1weCwgMWZyKSlgXG5cbiAgICAgICAgICAgIGhlYWRzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IHRhaWxzdHlsZXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IG51bGxcblxuICAgICAgICAgICAgaGVhZHN0eWxlcy5ncmlkQXV0b0Zsb3cgPSB0YWlsc3R5bGVzLmdyaWRBdXRvRmxvdyA9ICdjb2x1bW4nXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvUm93cyA9IHRhaWxzdHlsZXMuZ3JpZEF1dG9Sb3dzID0gbnVsbFxuXG4gICAgICAgICAgICBoZWFkc3R5bGVzLmdyaWRBdXRvQ29sdW1ucyA9IFxuICAgICAgICAgICAgdGFpbHN0eWxlcy5ncmlkQXV0b0NvbHVtbnMgPSBcbiAgICAgICAgICAgICAgICAobGF5b3V0ID09ICd1bmlmb3JtJyk/XG4gICAgICAgICAgICAgICAgICAgIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICdtYXgtY29udGVudCdcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhlYWRzdHlsZXMsXG4gICAgICAgICAgICB0YWlsc3R5bGVzLFxuICAgICAgICAgICAgYXhpc3N0eWxlcyxcbiAgICAgICAgICAgIGNyYWRsZWRpdmlkZXJzdHlsZXMsXG4gICAgICAgICAgICB0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyxcbiAgICAgICAgICAgIHRyaWdnZXJjZWxsdHJpZ2dlcmxpbmV0YWlsc3R5bGVzLFxuICAgICAgICBdXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIHRoZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgc2V0dGluZyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiBleHBhbnNpb24gb2YgdGhlIGdyaWQgYmxvY2tcbiAgICBwcml2YXRlIGdldEJhc2VIZWFkU3R5bGVzID0gXG4gICAgICAgIChnYXAscGFkZGluZyxvcmllbnRhdGlvbix1c2VyaGVhZHN0eWxlcykgPT4ge1xuXG4gICAgICAgIGxldCBib3R0b20sIGxlZnQsIHRvcCwgcmlnaHRcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgYm90dG9tID0gMFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgdG9wID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnVzZXJoZWFkc3R5bGVzLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkR2FwOiBnYXAgKyAncHgnLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyArICdweCcsXG4gICAgICAgICAgICBib3hTaXppbmc6J2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBzZXR0aW5nIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIGV4cGFuc2lvbiBvZiB0aGUgZ3JpZCBibG9ja1xuICAgIHByaXZhdGUgZ2V0QmFzZVRhaWxTdHlsZXMgPSBcbiAgICAgICAgKGdhcCxwYWRkaW5nLG9yaWVudGF0aW9uLHVzZXJ0YWlsc3R5bGVzKSA9PiB7XG5cbiAgICAgICAgbGV0IGJvdHRvbSwgbGVmdCwgdG9wLCByaWdodFxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3R0b20gPSBudWxsXG4gICAgICAgICAgICBsZWZ0ID0gMFxuICAgICAgICAgICAgcmlnaHQgPSBudWxsXG4gICAgICAgICAgICB0b3AgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udXNlcnRhaWxzdHlsZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRHYXA6IGdhcCArICdweCcsXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nICsgJ3B4JyxcbiAgICAgICAgICAgIGJveFNpemluZzonYm9yZGVyLWJveCcsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRBeGlzU3R5bGVzID0gXG4gICAgICAgIChnYXAsIHBhZGRpbmcsIG9yaWVudGF0aW9uKSA9PiB7XG5cbiAgICAgICAgbGV0IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCAvLyBmb3IgYXhpc1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSAndmVydGljYWwnKSB7XG5cbiAgICAgICAgICAgIHRvcCA9IHBhZGRpbmcgKyAncHgnIC8vIGRlZmF1bHRcbiAgICAgICAgICAgIGxlZnQgPSAnYXV0bydcbiAgICAgICAgICAgIHdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBoZWlnaHQgPSAwXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdG9wID0gJ2F1dG8nXG4gICAgICAgICAgICBsZWZ0ID0gcGFkZGluZyArICdweCcgLy8gZGVmYXVsdFxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lSGVhZFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IHRyaWdnZXJsaW5lT2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgcmlnaHQgPSAnMHB4J1xuICAgICAgICAgICAgYm90dG9tID0gbnVsbFxuICAgICAgICAgICAgbGVmdCA9ICcwcHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRvcCA9ICcwcHgnXG4gICAgICAgICAgICByaWdodCA9IG51bGxcbiAgICAgICAgICAgIGJvdHRvbSA9ICcwcHgnXG4gICAgICAgICAgICBsZWZ0ID0gdHJpZ2dlcmxpbmVPZmZzZXQgKyAncHgnXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyA9IFxuICAgICAgICAob3JpZW50YXRpb24sIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgdHJpZ2dlcmxpbmVPZmZzZXQsIGdhcCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuXG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0LCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcblxuICAgICAgICAgICAgd2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGhlaWdodCA9IDBcbiAgICAgICAgICAgIHRvcCA9IG51bGxcbiAgICAgICAgICAgIHJpZ2h0ID0gJzBweCdcbiAgICAgICAgICAgIGJvdHRvbSA9IC0odHJpZ2dlcmxpbmVPZmZzZXQgKyBnYXApICsgJ3B4J1xuICAgICAgICAgICAgbGVmdCA9ICcwcHgnXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgd2lkdGggPSAwXG4gICAgICAgICAgICBoZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgIHRvcCA9ICcwcHgnXG4gICAgICAgICAgICByaWdodCA9IC0odHJpZ2dlcmxpbmVPZmZzZXQgKyBnYXApICsgJ3B4J1xuICAgICAgICAgICAgYm90dG9tID0gJzBweCdcbiAgICAgICAgICAgIGxlZnQgPSBudWxsXG5cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJTdHlsZXNIYW5kbGVyIiwiY3JhZGxlUGFyYW1ldGVycyIsIl90aGlzIiwiZ2V0Q3JhZGxlU3R5bGVzIiwiX3JlZiIsIm9yaWVudGF0aW9uIiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsImdhcCIsInBhZGRpbmciLCJjcm9zc2NvdW50IiwidXNlcnN0eWxlcyIsInRyaWdnZXJsaW5lT2Zmc2V0IiwibGF5b3V0IiwiaGVhZHN0eWxlcyIsImdldEJhc2VIZWFkU3R5bGVzIiwiY3JhZGxlIiwidGFpbHN0eWxlcyIsImdldEJhc2VUYWlsU3R5bGVzIiwiYXhpc3N0eWxlcyIsImdldEF4aXNTdHlsZXMiLCJ0cmlnZ2VyY2VsbHRyaWdnZXJsaW5laGVhZHN0eWxlcyIsImdldFRyaWdnZXJjZWxsVHJpZ2dlcmxpbmVIZWFkU3R5bGVzIiwidHJpZ2dlcmNlbGx0cmlnZ2VybGluZXRhaWxzdHlsZXMiLCJnZXRUcmlnZ2VyY2VsbFRyaWdnZXJsaW5lVGFpbFN0eWxlcyIsImNyYWRsZWRpdmlkZXJzdHlsZXMiLCJ6SW5kZXgiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiYm94U2hhZG93IiwiY29uY2F0IiwiZ3JpZFRlbXBsYXRlUm93cyIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkQXV0b0Zsb3ciLCJncmlkQXV0b1Jvd3MiLCJncmlkQXV0b0NvbHVtbnMiLCJ1c2VyaGVhZHN0eWxlcyIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImFzc2lnbiIsImRpc3BsYXkiLCJncmlkR2FwIiwiYm94U2l6aW5nIiwidXNlcnRhaWxzdHlsZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cradle/styleshandler.tsx\n")},"./src/portalcache/CachePartition.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// CellFrame.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar react_1 = __importStar(__webpack_require__(/*! react */ "react"));\nvar CachePartition = function CachePartition(_ref) {\n  var partitionProps = _ref.partitionProps,\n    partitionID = _ref.partitionID,\n    callback = _ref.callback;\n  var _ref2 = (0, react_1.useState)(0),\n    _ref3 = _slicedToArray(_ref2, 2),\n    portalListCounter = _ref3[0],\n    setPortalListCounter = _ref3[1];\n  var _ref4 = (0, react_1.useState)(\'setup\'),\n    _ref5 = _slicedToArray(_ref4, 2),\n    partitionState = _ref5[0],\n    setPartitionState = _ref5[1];\n  var counterRef = (0, react_1.useRef)(portalListCounter);\n  var isMountedRef = (0, react_1.useRef)(true);\n  var portalArrayRef = (0, react_1.useRef)(null);\n  var partitionMetadata = partitionProps.partitionMetadataMap.get(partitionID);\n  var forceUpdate = (0, react_1.useCallback)(function (portalRenderList) {\n    portalArrayRef.current = portalRenderList;\n    isMountedRef.current && setPortalListCounter(++counterRef.current); // force render\n  }, []);\n  (0, react_1.useEffect)(function () {\n    isMountedRef.current = true;\n    partitionMetadata.forceUpdate = forceUpdate;\n    callback();\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  (0, react_1.useEffect)(function () {\n    switch (partitionState) {\n      case \'setup\':\n        {\n          setPartitionState(\'ready\');\n          break;\n        }\n    }\n  }, [partitionState]);\n  return react_1["default"].createElement("div", {\n    key: partitionID,\n    "data-type": \'cachepartition\',\n    "data-partitionid": partitionID\n  }, portalArrayRef.current);\n};\nexports["default"] = CachePartition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFFVixPQUFPLFlBQUs7TUFFUlksWUFBWSxDQUFDUSxPQUFPLEdBQUcsS0FBSztJQUVoQyxDQUFDO0VBRUwsQ0FBQyxFQUFDLEVBQUUsQ0FBQztFQUVMLElBQUEzQixPQUFBLENBQUE0QixTQUFTLEVBQUMsWUFBSTtJQUVWLFFBQVFiLGNBQWM7TUFDbEIsS0FBSyxPQUFPO1FBQUU7VUFDVkMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO1VBQzFCOzs7RUFJWixDQUFDLEVBQUMsQ0FBQ0QsY0FBYyxDQUFDLENBQUM7RUFFbkIsT0FBT2YsT0FBQSxZQUFBNkIsYUFBQTtJQUFLQyxHQUFHLEVBQUl4QixXQUFXO0lBQUEsYUFBYyxnQkFBZ0I7SUFBQSxvQkFBcUJBO0VBQVcsR0FDdkZjLGNBQWMsQ0FBQ08sT0FBTyxDQUNyQjtBQUVWLENBQUM7QUFFREksa0JBQUEsR0FBZTVCLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL3BvcnRhbGNhY2hlL0NhY2hlUGFydGl0aW9uLnRzeD81OTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbGxGcmFtZS50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbmltcG9ydCBSZWFjdCwge3VzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2t9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBDYWNoZVBhcnRpdGlvbiA9ICh7IHBhcnRpdGlvblByb3BzLCBwYXJ0aXRpb25JRCwgY2FsbGJhY2sgfSkgPT4ge1xuXG4gICAgY29uc3QgW3BvcnRhbExpc3RDb3VudGVyLCBzZXRQb3J0YWxMaXN0Q291bnRlcl0gPSB1c2VTdGF0ZSgwKVxuXG4gICAgY29uc3QgW3BhcnRpdGlvblN0YXRlLCBzZXRQYXJ0aXRpb25TdGF0ZV0gPSB1c2VTdGF0ZSgnc2V0dXAnKVxuXG4gICAgY29uc3QgY291bnRlclJlZiA9IHVzZVJlZihwb3J0YWxMaXN0Q291bnRlcilcblxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKVxuXG4gICAgY29uc3QgcG9ydGFsQXJyYXlSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gcGFydGl0aW9uUHJvcHMucGFydGl0aW9uTWV0YWRhdGFNYXAuZ2V0KHBhcnRpdGlvbklEKVxuXG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VDYWxsYmFjaygocG9ydGFsUmVuZGVyTGlzdCkgPT4ge1xuXG4gICAgICAgIHBvcnRhbEFycmF5UmVmLmN1cnJlbnQgPSBwb3J0YWxSZW5kZXJMaXN0XG5cbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgc2V0UG9ydGFsTGlzdENvdW50ZXIoKytjb3VudGVyUmVmLmN1cnJlbnQpIC8vIGZvcmNlIHJlbmRlclxuXG4gICAgfSxbXSlcblxuICAgIHVzZUVmZmVjdCgoKT0+e1xuXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxuXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLmZvcmNlVXBkYXRlID0gZm9yY2VVcGRhdGVcblxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcblxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH0sW10pIFxuXG4gICAgdXNlRWZmZWN0KCgpPT57XG5cbiAgICAgICAgc3dpdGNoIChwYXJ0aXRpb25TdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc2V0dXAnOiB7XG4gICAgICAgICAgICAgICAgc2V0UGFydGl0aW9uU3RhdGUoJ3JlYWR5JylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFtwYXJ0aXRpb25TdGF0ZV0pXG5cbiAgICByZXR1cm4gPGRpdiBrZXkgPSB7cGFydGl0aW9uSUR9IGRhdGEtdHlwZSA9ICdjYWNoZXBhcnRpdGlvbicgZGF0YS1wYXJ0aXRpb25pZCA9IHtwYXJ0aXRpb25JRH0+XG4gICAgICAgIHtwb3J0YWxBcnJheVJlZi5jdXJyZW50fVxuICAgIDwvZGl2PlxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhY2hlUGFydGl0aW9uIl0sIm5hbWVzIjpbIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJlcnIiLCJpc0FycmF5IiwicmVhY3RfMSIsIl9faW1wb3J0U3RhciIsInJlcXVpcmUiLCJDYWNoZVBhcnRpdGlvbiIsIl9yZWYiLCJwYXJ0aXRpb25Qcm9wcyIsInBhcnRpdGlvbklEIiwiY2FsbGJhY2siLCJfcmVmMiIsInVzZVN0YXRlIiwiX3JlZjMiLCJwb3J0YWxMaXN0Q291bnRlciIsInNldFBvcnRhbExpc3RDb3VudGVyIiwiX3JlZjQiLCJfcmVmNSIsInBhcnRpdGlvblN0YXRlIiwic2V0UGFydGl0aW9uU3RhdGUiLCJjb3VudGVyUmVmIiwidXNlUmVmIiwiaXNNb3VudGVkUmVmIiwicG9ydGFsQXJyYXlSZWYiLCJwYXJ0aXRpb25NZXRhZGF0YSIsInBhcnRpdGlvbk1ldGFkYXRhTWFwIiwiZ2V0IiwiZm9yY2VVcGRhdGUiLCJ1c2VDYWxsYmFjayIsInBvcnRhbFJlbmRlckxpc3QiLCJjdXJyZW50IiwidXNlRWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImtleSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/portalcache/CachePartition.tsx\n')},"./src/portalcache/cacheAPI.tsx":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n\n// cachehandler.tsx\n// copyright (c) 2019-2023 Henrik Bechmann, Toronto, Licence: MIT\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n/*\n    This module manages the InfiniteGridScroller limited (sparse) cache. It also provides support for\n    services which allow the host to actively manage many aspects of the cache. See documentation\n    about the user functionsCallback callback for details. The cacheMax property allows for control of the\n    maximum device memory consumption of the cache.\n\n    The infinite grid scroller stores user cell content (components) in a central hidden cache,\n    from whence the components are pulled into the relevant CellFrames for display. The user components are\n    stored in React portals, with each portal instantiated in a container div (data-type = \'portalwrapper\').\n    These container divs are part of a standard React component list in the real DOM. The contained portals\n    themselves are not part of the real DOM, but are part of React\'s virtual DOM.\n\n    See https://reactjs.org/docs/portals.html for general information about React portals.\n    See https://www.npmjs.com/package/react-reverse-portal for the utility that InfiniteGridScroller\n    uses to manage portals.\n\n    This caching has many advantages, notably the ability to move cells back and forth between the\n    head and tail grids of the Cradle without losing state, and the ability to maintain state for\n    complex components which move beyond the scope of the content of the Cradle.\n\n    There is an important side effect to consider. Instantiated components which are removed from the real DOM\n    into the portal of the virtual DOM have their scroll positions, width, and height set to zero. Therefore if\n    components rely on these values for configuration, they must have a way of storing those values in state\n    (notably the Scroll Pos - scrollLeft or scrollTop), recognizing when the component comes out of the portal cache\n    into the real DOM (width and height are typically no longer both 0), and responding to change in\n    cache state appropriately.\n\n    Tips:\n        - your component is in cache when both width and height = 0\n        - your component is out of cache when both width and height are back to normal\n        - if you create an empty \'scrollerProperties\' property for your component, CellFrame will\n            set it to an object containing scrollerPropertiesRef and cellFramePropertiesRef\n        - if your component does not scroll, there should be no issues.\n\n*/\n/*\n\n    TODO\n\n    - modify clear cache for scroller selection\n\n*/\nvar react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\nvar react_reverse_portal_1 = __webpack_require__(/*! react-reverse-portal */ "./node_modules/react-reverse-portal/dist/web/index.js");\nvar CachePartition_1 = __importDefault(__webpack_require__(/*! ./CachePartition */ "./src/portalcache/CachePartition.tsx"));\n// the cache itself is maintained in the root infinitegridscroller component\nvar CacheAPI = /*#__PURE__*/function () {\n  function CacheAPI(CACHE_PARTITION_SIZE) {\n    var _this = this;\n    _classCallCheck(this, CacheAPI);\n    this.globalItemID = 0;\n    this.globalPartitionID = 0;\n    this.itemMetadataMap = new Map();\n    this.scrollerDataMap = new Map();\n    this.partitionProps = {\n      partitionMetadataMap: new Map(),\n      partitionMap: new Map(),\n      partitionRenderList: null,\n      partitionRepoForceUpdate: null,\n      partitionModifiedSet: new Set(),\n      partitionPtr: null // active partition, for followup\n    };\n\n    this.getFacade = function (scrollerID) {\n      var facade = {\n        // get and set data\n        get indexToItemIDMap() {\n          return this.getIndexToItemIDMap();\n        },\n        getIndexToItemIDMap: function getIndexToItemIDMap() {\n          return _this.scrollerDataMap.get(scrollerID).indexToItemIDMap;\n        },\n        get itemSet() {\n          return this.getItemSet();\n        },\n        getItemSet: function getItemSet() {\n          return _this.scrollerDataMap.get(scrollerID).itemSet;\n        },\n        itemMetadataMap: _this.itemMetadataMap,\n        get requestedSet() {\n          return this.getRequestedSet();\n        },\n        getRequestedSet: function getRequestedSet() {\n          return _this.scrollerDataMap.get(scrollerID).requestedSet;\n        },\n        set partitionRepoForceUpdate(fn) {\n          this.setPartitionRepoForceUpdate(fn);\n        },\n        setPartitionRepoForceUpdate: function setPartitionRepoForceUpdate(fn) {\n          _this.partitionProps.partitionRepoForceUpdate = fn;\n        },\n        set cradleParameters(parms) {\n          this.setCradleParameters(parms);\n        },\n        setCradleParameters: function setCradleParameters(parms) {\n          _this.scrollerDataMap.get(scrollerID).cradleParameters = parms;\n        },\n        set portalPartitionItemsForDeleteList(list) {\n          this.setPortalPartitionItemsForDeleteList(list);\n        },\n        setPortalPartitionItemsForDeleteList: function setPortalPartitionItemsForDeleteList(list) {\n          _this.scrollerDataMap.get(scrollerID).portalPartitionItemsForDeleteList = list;\n        },\n        get instance() {\n          return this.getInstance();\n        },\n        getInstance: function getInstance() {\n          return _this;\n        },\n        // methods\n        unRegisterScroller: function unRegisterScroller(itemSet) {\n          return _this.unRegisterScroller(scrollerID, itemSet);\n        },\n        renderPartitionRepo: function renderPartitionRepo() {\n          return _this.renderPartitionRepo();\n        },\n        renderPortalLists: function renderPortalLists() {\n          return _this.renderPortalLists();\n        },\n        clearCache: function clearCache() {\n          return _this.clearCache(scrollerID);\n        },\n        changeCacheListsize: function changeCacheListsize(newlistsize, deleteListCallback, changeListsizeCallback) {\n          return _this.changeCacheListsize(scrollerID, newlistsize, deleteListCallback, changeListsizeCallback);\n        },\n        matchCacheToCradle: function matchCacheToCradle(cradleIndexList, deleteListCallback) {\n          return _this.matchCacheToCradle(scrollerID, cradleIndexList, deleteListCallback);\n        },\n        pareCacheToMax: function pareCacheToMax(cacheMax, cradleIndexList, deleteListCallback) {\n          return _this.pareCacheToMax(scrollerID, cacheMax, cradleIndexList, deleteListCallback);\n        },\n        guardAgainstRunawayCaching: function guardAgainstRunawayCaching(cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n          return _this.guardAgainstRunawayCaching(scrollerID, cacheMax, cradleListLength, MAX_CACHE_OVER_RUN);\n        },\n        preload: function preload(finalCallback, nullItemSetMaxListsize) {\n          return _this.preload(scrollerID, finalCallback, nullItemSetMaxListsize);\n        },\n        getCacheIndexMap: function getCacheIndexMap() {\n          return _this.getCacheIndexMap(scrollerID);\n        },\n        getCradleIndexMap: function getCradleIndexMap(cradleIndexList) {\n          return _this.getCradleIndexMap(scrollerID, cradleIndexList);\n        },\n        getCacheItemMap: function getCacheItemMap() {\n          return _this.getCacheItemMap(scrollerID);\n        },\n        moveIndex: function moveIndex(tolowindex, fromlowindex, fromhighindex) {\n          return _this.moveIndex(scrollerID, tolowindex, fromlowindex, fromhighindex);\n        },\n        insertRemoveIndex: function insertRemoveIndex(index, highrange, increment, listsize) {\n          return _this.insertRemoveIndex(scrollerID, index, highrange, increment, listsize);\n        },\n        registerPendingPortal: function registerPendingPortal(index) {\n          return _this.registerPendingPortal(scrollerID, index);\n        },\n        unregisterPendingPortal: function unregisterPendingPortal(index) {\n          return _this.unregisterPendingPortal(scrollerID, index);\n        },\n        getNewItemID: function getNewItemID() {\n          return _this.getNewItemID();\n        },\n        getNewOrExistingItemID: function getNewOrExistingItemID(index) {\n          return _this.getNewOrExistingItemID(scrollerID, index);\n        },\n        createPortal: function createPortal(component, index, itemID, scrollerProperties) {\n          var isPreload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n          return _this.createPortal(scrollerID, component, index, itemID, scrollerProperties, isPreload = false);\n        },\n        deletePortalByIndex: function deletePortalByIndex(index, deleteListCallback) {\n          return _this.deletePortalByIndex(scrollerID, index, deleteListCallback);\n        },\n        applyPortalPartitionItemsForDeleteList: function applyPortalPartitionItemsForDeleteList() {\n          return _this.applyPortalPartitionItemsForDeleteList(scrollerID);\n        },\n        hasPortal: function hasPortal(itemID) {\n          return _this.hasPortal(itemID);\n        },\n        getPortalMetadata: function getPortalMetadata(itemID) {\n          return _this.getPortalMetadata(itemID);\n        }\n      };\n      return facade;\n    };\n    this.unRegisterScroller = function (scrollerID, itemSet) {\n      var scrollerDataMap = _this.scrollerDataMap,\n        itemMetadataMap = _this.itemMetadataMap;\n      if (scrollerDataMap.size == 1) return; // already getting dismantled; avoid conflict\n      // console.log(\'unregister scrollerID, itemSet\',scrollerID, itemSet)\n      scrollerDataMap["delete"](scrollerID);\n      itemSet.forEach(function (itemID) {\n        var _itemMetadataMap$get = itemMetadataMap.get(itemID),\n          partitionID = _itemMetadataMap$get.partitionID;\n        _this.removePartitionPortal(partitionID, itemID);\n        itemMetadataMap["delete"](itemID);\n      });\n      _this.renderPortalLists();\n      // this.measureMemory(\'UNREGISTER\')\n    };\n    // ===========================[ CACHE PARTITION MANAGEMENT ]===============================\n    // partitions are added but not removed\n    this.renderPartitionRepo = function () {\n      _this.partitionProps.partitionRenderList = Array.from(_this.partitionProps.partitionMap.values());\n      _this.partitionProps.partitionRepoForceUpdate(_this.partitionProps.partitionRenderList);\n    };\n    this.addPartition = function () {\n      var partitionID = _this.globalPartitionID++;\n      _this.partitionProps.partitionMetadataMap.set(partitionID, {\n        portalMap: new Map(),\n        mapcount: 0,\n        portalRenderList: null,\n        modified: false,\n        forceUpdate: null,\n        partitionID: partitionID\n      });\n      var resolvefunc = {\n        current: null\n      };\n      var promise = new Promise(function (resolve) {\n        resolvefunc.current = resolve;\n      });\n      var callback = function callback() {\n        resolvefunc.current(partitionID);\n      };\n      _this.partitionProps.partitionMap.set(partitionID, react_1["default"].createElement(CachePartition_1["default"], {\n        key: partitionID,\n        partitionProps: _this.partitionProps,\n        partitionID: partitionID,\n        callback: callback\n      }));\n      _this.renderPartitionRepo();\n      return promise;\n    };\n    this.addPartitionPortal = function (partitionID, itemID, portal) {\n      var partitionMetadata = _this.partitionProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap.set(itemID, portal);\n      _this.partitionProps.partitionModifiedSet.add(partitionID);\n    };\n    this.removePartitionPortal = function (partitionID, itemID) {\n      var partitionMetadata = _this.partitionProps.partitionMetadataMap.get(partitionID);\n      partitionMetadata.portalMap["delete"](itemID);\n      partitionMetadata.mapcount -= 1;\n      _this.partitionProps.partitionModifiedSet.add(partitionID);\n    };\n    this.renderPartition = function (partitionID) {\n      var partitionMetadata = _this.partitionProps.partitionMetadataMap.get(partitionID);\n      if (!partitionMetadata) return;\n      partitionMetadata.portalRenderList = Array.from(partitionMetadata.portalMap.values());\n      // if forceUpdate has not yet been assigned, it is in the works from first call of partition\n      partitionMetadata.forceUpdate && partitionMetadata.forceUpdate(partitionMetadata.portalRenderList);\n    };\n    // set state of the CachePartition component of the scroller to trigger render\n    this.renderPortalLists = function () {\n      var partitionModifiedSet = _this.partitionProps.partitionModifiedSet;\n      if (partitionModifiedSet.size) {\n        partitionModifiedSet.forEach(function (partitionID) {\n          _this.renderPartition(partitionID);\n        });\n        _this.partitionProps.partitionModifiedSet.clear();\n      }\n    };\n    this.clearCache = function (scrollerID) {\n      var scrollerDataMap = _this.scrollerDataMap,\n        itemMetadataMap = _this.itemMetadataMap;\n      var datamap = scrollerDataMap.get(scrollerID);\n      var indexToItemIDMap = datamap.indexToItemIDMap,\n        itemSet = datamap.itemSet,\n        requestedSet = datamap.requestedSet;\n      if (scrollerDataMap.size == 1) {\n        // clear base data\n        itemMetadataMap.clear();\n        // clear cache partitions\n        _this.partitionProps.partitionMetadataMap.clear();\n        _this.partitionProps.partitionMap.clear();\n        _this.partitionProps.partitionRenderList = [];\n        _this.partitionProps.partitionModifiedSet.clear();\n        _this.partitionProps.partitionPtr = null;\n        _this.partitionProps.partitionRepoForceUpdate(null);\n      } else {\n        itemSet.forEach(function (itemID) {\n          var _itemMetadataMap$get2 = itemMetadataMap.get(itemID),\n            partitionID = _itemMetadataMap$get2.partitionID;\n          _this.removePartitionPortal(partitionID, itemID);\n        });\n        _this.renderPortalLists();\n      }\n      indexToItemIDMap.clear();\n      itemSet.clear();\n      requestedSet.clear();\n    };\n    //===========================[ REPOSITORY AND LIST MANAGEMENT ]==================================\n    // ----------------------------[ basic operations ]--------------------------\n    // called from Cradle.nullItemSetMaxListsize, and serviceHandler.setListsize\n    this.changeCacheListsize = function (scrollerID, newlistsize, deleteListCallback, changeListsizeCallback) {\n      // match cache to newlistsize\n      var portalIndexMap = _this.scrollerDataMap.get(scrollerID).indexToItemIDMap;\n      var mapkeysList = Array.from(portalIndexMap.keys());\n      mapkeysList.sort(function (a, b) {\n        return a - b;\n      });\n      var highestindex = mapkeysList.at(-1);\n      if (highestindex > newlistsize - 1) {\n        // pare the cache\n        var parelist = mapkeysList.filter(function (index) {\n          return index > newlistsize - 1;\n        });\n        _this.deletePortalByIndex(scrollerID, parelist, deleteListCallback);\n      }\n      changeListsizeCallback && changeListsizeCallback(newlistsize);\n    };\n    // ----------------------[ cache size limit enforceent ]------------------\n    this.matchCacheToCradle = function (scrollerID, cradleIndexList, deleteListCallback) {\n      var mapkeys = Array.from(_this.scrollerDataMap.get(scrollerID).indexToItemIDMap.keys());\n      var delkeys = mapkeys.filter(function (key) {\n        return !cradleIndexList.includes(key);\n      });\n      if (delkeys.length) {\n        _this.deletePortalByIndex(scrollerID, delkeys, deleteListCallback);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    this.pareCacheToMax = function (scrollerID, cacheMax, cradleIndexList, deleteListCallback) {\n      var modelLength = cradleIndexList.length;\n      // determine need for paring\n      if (!cacheMax || !modelLength) return false;\n      var max = Math.max(modelLength, cacheMax);\n      var portalIndexMap = _this.scrollerDataMap.get(scrollerID).indexToItemIDMap,\n        requestedSet = _this.scrollerDataMap.get(scrollerID).requestedSet;\n      if (portalIndexMap.size + requestedSet.size <= max) return false;\n      // sort the map keys\n      var mapkeyslist = Array.from(portalIndexMap.keys()),\n        requestedkeys = Array.from(requestedSet.keys());\n      var mapkeys = [].concat(mapkeyslist, requestedkeys);\n      mapkeys.sort(function (a, b) {\n        return a - b;\n      });\n      // get number to pare\n      var mapLength = mapkeys.length,\n        parecount = mapLength - max;\n      // distribute paring proportionally at front and back\n      var headindex = cradleIndexList[0],\n        tailindex = cradleIndexList[modelLength - 1],\n        headpos = mapkeys.indexOf(headindex),\n        tailpos = mapkeys.indexOf(tailindex);\n      var headroom = headpos,\n        tailroom = mapLength - (tailpos + 1),\n        pareroom = headroom + tailroom;\n      var headparecount = Math.floor(headroom / pareroom * parecount),\n        tailparecount = parecount - headparecount;\n      // collect indexes to pare\n      var headlist = mapkeys.slice(0, headparecount),\n        taillist = mapkeys.slice(mapLength - tailparecount);\n      var delList = [].concat(_toConsumableArray(headlist), _toConsumableArray(taillist));\n      _this.deletePortalByIndex(scrollerID, delList, deleteListCallback);\n      return true;\n    };\n    this.guardAgainstRunawayCaching = function (scrollerID, cacheMax, cradleListLength, MAX_CACHE_OVER_RUN) {\n      if (!cacheMax) return false;\n      var _this$scrollerDataMap = _this.scrollerDataMap.get(scrollerID),\n        indexToItemIDMap = _this$scrollerDataMap.indexToItemIDMap,\n        requestedSet = _this$scrollerDataMap.requestedSet;\n      var max = Math.max(cradleListLength, cacheMax);\n      if (indexToItemIDMap.size + requestedSet.size <= max * MAX_CACHE_OVER_RUN) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n    // --------------------------------[ preload ]--------------------------------\n    this.preload = function (scrollerID, finalCallback, nullItemSetMaxListsize) {\n      var _this$scrollerDataMap2 = _this.scrollerDataMap.get(scrollerID),\n        cradleParameters = _this$scrollerDataMap2.cradleParameters;\n      var scrollerPropertiesRef = cradleParameters.scrollerPropertiesRef;\n      var _cradleParameters$han = cradleParameters.handlersRef.current,\n        stateHandler = _cradleParameters$han.stateHandler,\n        serviceHandler = _cradleParameters$han.serviceHandler,\n        cradleInheritedProperties = cradleParameters.cradleInheritedPropertiesRef.current,\n        cradleInternalProperties = cradleParameters.cradleInternalPropertiesRef.current;\n      var getItem = cradleInheritedProperties.getItem,\n        cacheMax = cradleInheritedProperties.cacheMax,\n        listsize = cradleInternalProperties.virtualListProperties.size;\n      var promises = [];\n      var cacheSize = cacheMax !== null && cacheMax !== void 0 ? cacheMax : 0;\n      cacheSize = Math.min(cacheSize, listsize);\n      var preloadsize = cacheSize ? cacheSize : listsize;\n      var breakloop = {\n        current: false\n      };\n      var maxListsizeInterrupt = function maxListsizeInterrupt(index) {\n        breakloop.current = true;\n        nullItemSetMaxListsize(index);\n      };\n      if (stateHandler.isMountedRef.current) {\n        var indexToItemIDMap = _this.scrollerDataMap.get(scrollerID).indexToItemIDMap;\n        var _serviceHandler$callb = serviceHandler.callbacks,\n          preloadIndexCallback = _serviceHandler$callb.preloadIndexCallback,\n          itemExceptionCallback = _serviceHandler$callb.itemExceptionCallback;\n        for (var index = 0; index < preloadsize; index++) {\n          preloadIndexCallback && preloadIndexCallback(index);\n          if (!indexToItemIDMap.has(index)) {\n            var promise = _this.preloadItem(scrollerID, index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt);\n            promises.push(promise);\n          }\n          if (breakloop.current) break;\n        }\n      }\n      Promise.allSettled(promises).then(function () {\n        _this.renderPortalLists();\n        finalCallback();\n      });\n    };\n    this.applyPortalPartitionItemsForDeleteList = function (scrollerID) {\n      var _this$scrollerDataMap3 = _this.scrollerDataMap.get(scrollerID),\n        portalPartitionItemsForDeleteList = _this$scrollerDataMap3.portalPartitionItemsForDeleteList;\n      if (portalPartitionItemsForDeleteList && portalPartitionItemsForDeleteList.length) {\n        var _iterator = _createForOfIteratorHelper(portalPartitionItemsForDeleteList),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n            _this.removePartitionPortal(item.partitionID, item.itemID);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _this.scrollerDataMap.get(scrollerID).portalPartitionItemsForDeleteList = [];\n        _this.renderPortalLists();\n      }\n    };\n    this.CACHE_PARTITION_SIZE = CACHE_PARTITION_SIZE;\n  }\n  // private measureMemory(source) {\n  //   console.log(\'usedJSHeapSize\',source, performance[\'memory\'][\'usedJSHeapSize\'])\n  // }\n  // ===========================[ Scroller Registration & Maintenance ]===============================\n  // the only member accessed directly. All other access is through the facade\n  _createClass(CacheAPI, [{\n    key: "registerScroller",\n    value: function registerScroller(scrollerID) {\n      this.scrollerDataMap.set(scrollerID, {\n        cradleParameters: null,\n        indexToItemIDMap: new Map(),\n        // some portals may have been requested by requestidlecallback, not yet created\n        itemSet: new Set(),\n        requestedSet: new Set(),\n        portalPartitionItemsForDeleteList: null\n      });\n      // this.measureMemory(\'REGISTER\')\n      return this.getFacade(scrollerID);\n    }\n  }, {\n    key: "findPartitionWithRoom",\n    value: function findPartitionWithRoom() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var CACHE_PARTITION_SIZE, partitionMetadataMap, partitionPtr, partitionMetadata, _iterator2, _step2, _step2$value, partitionID, _partitionMetadata;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              CACHE_PARTITION_SIZE = this.CACHE_PARTITION_SIZE;\n              partitionMetadataMap = this.partitionProps.partitionMetadataMap;\n              partitionPtr = this.partitionProps.partitionPtr;\n              if (!(partitionPtr !== null)) {\n                _context.next = 8;\n                break;\n              }\n              partitionMetadata = partitionMetadataMap.get(partitionPtr);\n              if (!(partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                _context.next = 8;\n                break;\n              }\n              partitionMetadata.mapcount += 1;\n              return _context.abrupt("return", partitionPtr);\n            case 8:\n              partitionPtr = null;\n              _iterator2 = _createForOfIteratorHelper(partitionMetadataMap);\n              _context.prev = 10;\n              _iterator2.s();\n            case 12:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 20;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), partitionID = _step2$value[0], _partitionMetadata = _step2$value[1];\n              if (!(_partitionMetadata.mapcount < CACHE_PARTITION_SIZE)) {\n                _context.next = 18;\n                break;\n              }\n              _partitionMetadata.mapcount += 1;\n              partitionPtr = partitionID;\n              return _context.abrupt("break", 20);\n            case 18:\n              _context.next = 12;\n              break;\n            case 20:\n              _context.next = 25;\n              break;\n            case 22:\n              _context.prev = 22;\n              _context.t0 = _context["catch"](10);\n              _iterator2.e(_context.t0);\n            case 25:\n              _context.prev = 25;\n              _iterator2.f();\n              return _context.finish(25);\n            case 28:\n              if (!(partitionPtr === null)) {\n                _context.next = 34;\n                break;\n              }\n              _context.next = 31;\n              return this.addPartition();\n            case 31:\n              partitionPtr = _context.sent;\n              partitionMetadata = partitionMetadataMap.get(partitionPtr);\n              partitionMetadata.mapcount += 1;\n            case 34:\n              this.partitionProps.partitionPtr = partitionPtr;\n              return _context.abrupt("return", partitionPtr);\n            case 36:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this, [[10, 22, 25, 28]]);\n      }));\n    }\n    // =========================[ SNAPSHOTS ]=========================\n  }, {\n    key: "getCacheIndexMap",\n    value: function getCacheIndexMap(scrollerID) {\n      return new Map(this.scrollerDataMap.get(scrollerID).indexToItemIDMap);\n    }\n  }, {\n    key: "getCradleIndexMap",\n    value: function getCradleIndexMap(scrollerID, cradleIndexList) {\n      var cradleMap = new Map(),\n        _this$scrollerDataMap4 = this.scrollerDataMap.get(scrollerID),\n        indexToItemIDMap = _this$scrollerDataMap4.indexToItemIDMap;\n      var _iterator3 = _createForOfIteratorHelper(cradleIndexList),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var index = _step3.value;\n          cradleMap.set(index, indexToItemIDMap.get(index));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return cradleMap;\n    }\n  }, {\n    key: "getCacheItemMap",\n    value: function getCacheItemMap(scrollerID) {\n      var cachelist = new Map();\n      var _this$scrollerDataMap5 = this.scrollerDataMap.get(scrollerID),\n        itemSet = _this$scrollerDataMap5.itemSet;\n      var itemMetadataMap = this.itemMetadataMap;\n      // for (const [key, value] of this.itemMetadataMap) {\n      var _iterator4 = _createForOfIteratorHelper(itemSet),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var itemID = _step4.value;\n          var metadata = itemMetadataMap.get(itemID);\n          var index = metadata.index,\n            component = metadata.component;\n          cachelist.set(itemID, {\n            index: index,\n            component: component\n          });\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return cachelist;\n    }\n    // ==========================[ SERVICE SUPPORT ]=========================\n    // --------------------------[ move indexes ]-------------------------------\n    // move is coerced by servicehandler to be within current list bounds\n  }, {\n    key: "moveIndex",\n    value: function moveIndex(scrollerID, tolowindex, fromlowindex, fromhighindex) {\n      var indexToItemIDMap = this.scrollerDataMap.get(scrollerID).indexToItemIDMap;\n      var itemMetadataMap = this.itemMetadataMap;\n      // ----------- define parameters ---------------\n      var moveblocksize = fromhighindex - fromlowindex + 1,\n        moveincrement = tolowindex - fromlowindex,\n        tohighindex = tolowindex + (moveblocksize - 1);\n      var movedirection = moveincrement > 0 ?\n      // move block up in list\n      \'up\' :\n      // shift down, make room for shiftingindex above\n      \'down\'; // shift up, make room for shiftingindex below\n      // ------------ find bounds of from and to blocks in cache -------------\n      var orderedindexlist = Array.from(indexToItemIDMap.keys()).sort(function (a, b) {\n        return a - b;\n      });\n      var reverseorderedindexlist = orderedindexlist.slice().reverse();\n      var tolowindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= tolowindex;\n        }),\n        fromlowindexptr = orderedindexlist.findIndex(function (value) {\n          return value >= fromlowindex;\n        });\n      var tohighindexptr = reverseorderedindexlist.findIndex(function (value) {\n          return value <= tohighindex;\n        }),\n        fromhighindexptr = reverseorderedindexlist.findIndex(function (value) {\n          return value <= fromhighindex;\n        });\n      // get required inverse\n      {\n        var cachelistcount = orderedindexlist.length;\n        if (tohighindexptr != -1) tohighindexptr = cachelistcount - 1 - tohighindexptr;\n        if (fromhighindexptr != -1) fromhighindexptr = cachelistcount - 1 - fromhighindexptr;\n      }\n      // ---------------- capture index data to move ----------------\n      var listtoprocessformove;\n      if (fromlowindexptr == -1 && fromhighindexptr == -1) {\n        // scope is out of view\n        listtoprocessformove = [];\n      } else if (fromhighindexptr == -1) {\n        // scope is partially in view\n        listtoprocessformove = orderedindexlist.slice(fromlowindexptr);\n      } else {\n        // scope is entirely in view\n        listtoprocessformove = orderedindexlist.slice(fromlowindexptr, fromhighindexptr + 1);\n      }\n      var processtomoveMap = new Map();\n      var capturemoveindexFn = function capturemoveindexFn(index) {\n        processtomoveMap.set(index, indexToItemIDMap.get(index));\n      };\n      listtoprocessformove.forEach(capturemoveindexFn);\n      // ------------- get list of indexes to shift out of the way ---------------\n      var listtoprocessfordisplace;\n      if (movedirection == \'down\') {\n        // block is moving down, shift is up; toindex < fromindex\n        if (tolowindexptr == -1 && fromlowindexptr == -1) {\n          listtoprocessfordisplace = [];\n        } else if (fromlowindexptr == -1) {\n          listtoprocessfordisplace = orderedindexlist.slice(tolowindexptr);\n        } else {\n          listtoprocessfordisplace = orderedindexlist.slice(tolowindexptr, fromlowindexptr);\n        }\n      } else {\n        // shiftdirection == -1; block is moving up, shift is down; fromindex < toindex\n        if (tohighindexptr == -1 && fromhighindexptr == -1) {\n          listtoprocessfordisplace = [];\n        } else if (tohighindexptr == -1) {\n          listtoprocessfordisplace = orderedindexlist.slice(fromhighindexptr + 1);\n        } else {\n          listtoprocessfordisplace = orderedindexlist.slice(fromhighindexptr + 1, tohighindexptr + 1);\n        }\n      }\n      if (movedirection == \'down\') listtoprocessfordisplace.reverse();\n      // -------------- move indexes out of the way --------------\n      var processeddisplaceList = [];\n      var processsdisplaceindexFn = function processsdisplaceindexFn(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = movedirection == \'up\' ? index - moveblocksize : index + moveblocksize;\n        indexToItemIDMap.set(newIndex, itemID);\n        itemMetadataMap.get(itemID).index = newIndex;\n        processeddisplaceList.push(newIndex);\n      };\n      listtoprocessfordisplace.forEach(processsdisplaceindexFn);\n      // ------------ replace shifted index space with moved indexes ----------\n      var processedmoveList = [];\n      var processmoveindexFn = function processmoveindexFn(itemID, index) {\n        var newIndex = index + moveincrement; // swap\n        indexToItemIDMap.set(newIndex, itemID);\n        itemMetadataMap.get(itemID).index = newIndex;\n        processedmoveList.push(newIndex);\n      };\n      processtomoveMap.forEach(processmoveindexFn);\n      // -----------return list of processed indexes to caller --------\n      // for synchrnization with cradle cellFrames\n      var processedIndexes = [].concat(processeddisplaceList, processedmoveList).sort(function (a, b) {\n        return a - b;\n      });\n      return processedIndexes;\n    }\n    // ----------------------------[ insert/remove indexes ]------------------------------\n    // insert or remove indexes: much of this deals with the fact that the cache is sparse.\n  }, {\n    key: "insertRemoveIndex",\n    value: function insertRemoveIndex(scrollerID, index, highrange, increment, listsize) {\n      // clarity\n      var isInserting = increment == 1;\n      var isRemoving = increment == -1;\n      var emptyreturn = [null, null, [], [], [], []]; // no action return value\n      // cache resources\n      var indexToItemIDMap = this.scrollerDataMap.get(scrollerID).indexToItemIDMap;\n      var itemMetadataMap = this.itemMetadataMap;\n      var orderedCacheIndexList = Array.from(indexToItemIDMap.keys()).sort(function (a, b) {\n        return a - b;\n      }); // ascending order\n      var itemSet = this.scrollerDataMap.get(scrollerID).itemSet;\n      // ---------- define contiguous range parameters; add sentinels ---------------\n      // high range is the highest index number of the insert/remove range\n      var highrangeindex = highrange;\n      var lowrangeindex = index; // semantics - name symmetry\n      if (isRemoving) {\n        // removal must be entirely within scope of the list\n        if (highrangeindex > listsize - 1) {\n          highrangeindex = listsize - 1;\n          if (highrangeindex < lowrangeindex) return emptyreturn;\n        }\n      } else {\n        // isInserting\n        // addition can at most start at the next lowrangeindex above the current list; aka append\n        if (lowrangeindex > listsize) {\n          var diff = lowrangeindex - listsize;\n          lowrangeindex -= diff;\n          highrangeindex -= diff;\n          // return emptyreturn\n        }\n      }\n      // rangecount is the absolute number in the insert/remove contiguous range\n      var rangecount = highrangeindex - lowrangeindex + 1;\n      // range increment adds sign to rangecount to indicate add/remove\n      var rangeincrement = rangecount * increment;\n      var startChangeIndex = increment == 1 ? lowrangeindex : highrangeindex + (rangeincrement + 1);\n      var toShiftStartIndex; // start of indexes to shift up (insert) or down (remove)\n      if (isInserting) {\n        toShiftStartIndex = lowrangeindex;\n      } else {\n        // isRemoving\n        toShiftStartIndex = highrangeindex + 1;\n      }\n      // ---------- define range boundaries within ordered cache index list ------------\n      // obtain starptr for indexes to shift\n      var toShiftStartCachePtr = orderedCacheIndexList.findIndex(function (value) {\n        return value >= toShiftStartIndex;\n      });\n      // obtain lowCacheRangePtr...\n      var lowCacheRangePtr = orderedCacheIndexList.findIndex(function (value) {\n        return value >= lowrangeindex && value <= highrangeindex;\n      });\n      // obtain highCacheRangePtr...\n      var reverseCacheIndexList = Array.from(orderedCacheIndexList).reverse();\n      var highCacheRangePtr = reverseCacheIndexList.findIndex(function (value) {\n        return value <= highrangeindex && value >= lowrangeindex;\n      });\n      // take inverse of highCacheRangePtr for non-reverse sort\n      if (highCacheRangePtr != -1) {\n        highCacheRangePtr = orderedCacheIndexList.length - 1 - highCacheRangePtr;\n        if (highCacheRangePtr < lowCacheRangePtr) highCacheRangePtr = -1;\n      }\n      // ----------- isolate index range list and shift list ------------\n      // cache inputs\n      var cacheRangeIndexesList,\n        // for either insert or remove\n        cacheToShiftIndexesList; // for either insert or remove\n      // get inputs\n      if (lowCacheRangePtr == -1) {\n        // core scope is out of view\n        cacheRangeIndexesList = [];\n        cacheToShiftIndexesList = [];\n      } else if (highCacheRangePtr == -1) {\n        // core scope is partially in view; lowCacheRangePtr is available\n        // all items above lowCacheRangePtr must have indexes reset\n        cacheRangeIndexesList = orderedCacheIndexList.slice(lowCacheRangePtr);\n        if (isInserting) {\n          cacheToShiftIndexesList = cacheRangeIndexesList.slice();\n        } else {\n          if (toShiftStartCachePtr == -1) {\n            cacheToShiftIndexesList = [];\n          } else {\n            cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n          }\n        }\n      } else {\n        // range fully in view\n        cacheRangeIndexesList = orderedCacheIndexList.slice(lowCacheRangePtr, highCacheRangePtr + 1);\n        if (isInserting) {\n          cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n        } else {\n          if (toShiftStartCachePtr == -1) {\n            cacheToShiftIndexesList = [];\n          } else {\n            cacheToShiftIndexesList = orderedCacheIndexList.slice(toShiftStartCachePtr);\n          }\n        }\n      }\n      // ----------- list cache indexes and items to replace or remove -----------\n      // cache outputs\n      // for insert, the range being inserted; for remove, any tail cradle items abandoned\n      var cacheIndexesToReplaceList = [],\n        // for insert, the range being inserted\n        cacheIndexesToRemoveList = [],\n        // for remove, the range being removed\n        cacheItemsToRemoveList = []; // for remove, derived from the previous\n      if (isInserting) {\n        cacheIndexesToReplaceList = cacheRangeIndexesList;\n      } else {\n        // isRemoving\n        cacheIndexesToRemoveList = cacheRangeIndexesList;\n        // get cacheItemsToRemoveList\n        var _iterator5 = _createForOfIteratorHelper(cacheIndexesToRemoveList),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _index = _step5.value;\n            cacheItemsToRemoveList.push(indexToItemIDMap.get(_index));\n            indexToItemIDMap["delete"](_index);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n      // ----------- conduct cache operations; capture list of shifted indexes ----------\n      // increment higher from top of list to preserve lower values for subsequent increment\n      if (isInserting) cacheToShiftIndexesList.reverse();\n      var cacheIndexesShiftedList = []; // track shifted indexes\n      var cacheIndexesTransferredSet = new Set(); // obtain list of orphaned indexes\n      // function modify index-to-itemid map, and metadata map, for index shifts\n      var processIndexFn = function processIndexFn(index) {\n        var itemID = indexToItemIDMap.get(index);\n        var newIndex = index + rangeincrement;\n        if (isRemoving) {\n          cacheIndexesTransferredSet.add(index);\n          cacheIndexesTransferredSet["delete"](newIndex);\n        }\n        indexToItemIDMap.set(newIndex, itemID);\n        itemMetadataMap.get(itemID).index = newIndex;\n        cacheIndexesShiftedList.push(newIndex);\n      };\n      // walk through items to shift\n      cacheToShiftIndexesList.forEach(processIndexFn);\n      // delete remaining indexes and items now duplicates; track portal data to remove after cradle updated\n      var portalPartitionItemsForDeleteList = []; // hold portals for deletion until after after cradle synch\n      var cacheIndexesRemovedList = [];\n      if (isInserting) {\n        var _iterator6 = _createForOfIteratorHelper(cacheIndexesToReplaceList),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _index2 = _step6.value;\n            indexToItemIDMap["delete"](_index2);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } else {\n        // isRemoving\n        var _iterator7 = _createForOfIteratorHelper(cacheItemsToRemoveList),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var itemID = _step7.value;\n            var _itemMetadataMap$get3 = itemMetadataMap.get(itemID),\n              partitionID = _itemMetadataMap$get3.partitionID;\n            portalPartitionItemsForDeleteList.push({\n              itemID: itemID,\n              partitionID: partitionID\n            });\n            itemMetadataMap["delete"](itemID);\n            itemSet["delete"](itemID);\n          }\n          // abandoned indexes from remove process\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        var orphanedIndexesTransferredList = Array.from(cacheIndexesTransferredSet);\n        for (var _i2 = 0, _orphanedIndexesTrans = orphanedIndexesTransferredList; _i2 < _orphanedIndexesTrans.length; _i2++) {\n          var _index3 = _orphanedIndexesTrans[_i2];\n          indexToItemIDMap["delete"](_index3);\n        }\n        cacheIndexesRemovedList = cacheIndexesToRemoveList.concat(orphanedIndexesTransferredList);\n      }\n      if (isInserting) cacheIndexesShiftedList.reverse(); // return to ascending order\n      // --------------- returns ---------------\n      // return values for caller to send to contenthandler for cradle synchronization\n      return [startChangeIndex, rangeincrement, cacheIndexesShiftedList, cacheIndexesRemovedList, cacheIndexesToReplaceList, portalPartitionItemsForDeleteList];\n    }\n    // ==========================[ INDIVIDUAL PORTAL MANAGEMENT ]============================\n    // used for size calculation in pareCacheToMax\n    // registers indexes when requested but before retrieved and entered into cache\n  }, {\n    key: "registerPendingPortal",\n    value: function registerPendingPortal(scrollerID, index) {\n      this.scrollerDataMap.get(scrollerID).requestedSet.add(index);\n    }\n  }, {\n    key: "unregisterPendingPortal",\n    value: function unregisterPendingPortal(scrollerID, index) {\n      var scrollerDataMap = this.scrollerDataMap.get(scrollerID);\n      if (scrollerDataMap) {\n        // otherwise scroller has been deleted\n        scrollerDataMap.requestedSet["delete"](index);\n      }\n    }\n  }, {\n    key: "getNewItemID",\n    value: function getNewItemID() {\n      return this.globalItemID++;\n    }\n    // get new or existing itemID for contentfunctions.createCellFrame\n  }, {\n    key: "getNewOrExistingItemID",\n    value: function getNewOrExistingItemID(scrollerID, index) {\n      var _this$scrollerDataMap6 = this.scrollerDataMap.get(scrollerID),\n        indexToItemIDMap = _this$scrollerDataMap6.indexToItemIDMap;\n      var itemID = indexToItemIDMap.has(index) ? indexToItemIDMap.get(index) : this.getNewItemID();\n      return itemID;\n    }\n    // create new portal\n  }, {\n    key: "createPortal",\n    value: function createPortal(scrollerID, component, index, itemID, scrollerProperties) {\n      var isPreload = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var scrollerDataMap, _this$scrollerDataMap7, layout, cellHeight, cellWidth, orientation, portalNode, partitionID, portal, portalMetadata;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.unregisterPendingPortal(scrollerID, index);\n              scrollerDataMap = this.scrollerDataMap.get(scrollerID);\n              if (scrollerDataMap) {\n                _context2.next = 4;\n                break;\n              }\n              return _context2.abrupt("return", null);\n            case 4:\n              _this$scrollerDataMap7 = this.scrollerDataMap.get(scrollerID).cradleParameters.cradleInheritedPropertiesRef.current, layout = _this$scrollerDataMap7.layout, cellHeight = _this$scrollerDataMap7.cellHeight, cellWidth = _this$scrollerDataMap7.cellWidth, orientation = _this$scrollerDataMap7.orientation;\n              portalNode = createPortalNode(index, itemID);\n              _context2.next = 8;\n              return this.findPartitionWithRoom();\n            case 8:\n              partitionID = _context2.sent;\n              portal = react_1["default"].createElement("div", {\n                "data-type": \'portalwrapper\',\n                key: itemID,\n                "data-itemid": itemID,\n                "data-index": index\n              }, react_1["default"].createElement(react_reverse_portal_1.InPortal, {\n                key: itemID,\n                node: portalNode\n              }, " ", component, " "));\n              this.addPartitionPortal(partitionID, itemID, portal);\n              portalMetadata = {\n                portalNode: portalNode,\n                index: index,\n                itemID: itemID,\n                scrollerID: scrollerID,\n                scrollerProperties: scrollerProperties,\n                component: component,\n                partitionID: partitionID\n              };\n              this.itemMetadataMap.set(itemID, portalMetadata);\n              scrollerDataMap.itemSet.add(itemID);\n              scrollerDataMap.indexToItemIDMap.set(index, itemID);\n              if (!isPreload) this.renderPortalLists();\n              return _context2.abrupt("return", portalMetadata);\n            case 17:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    // used for preloading new item\n  }, {\n    key: "preloadItem",\n    value: function preloadItem(scrollerID, index, getItem, scrollerPropertiesRef, itemExceptionCallback, maxListsizeInterrupt) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var itemID, returnvalue, usercontent, error, content, scrollerProperties;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              itemID = this.getNewItemID();\n              _context3.prev = 1;\n              _context3.next = 4;\n              return getItem(index, itemID);\n            case 4:\n              usercontent = _context3.sent;\n              if (usercontent === null) returnvalue = usercontent;\n              _context3.next = 12;\n              break;\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3["catch"](1);\n              returnvalue = usercontent = undefined;\n              error = _context3.t0;\n            case 12:\n              if (usercontent !== null && usercontent !== undefined) {\n                if (!react_1["default"].isValidElement(usercontent)) {\n                  returnvalue = usercontent;\n                  usercontent = undefined;\n                  error = new Error(\'invalid React element\');\n                }\n              }\n              if (!(usercontent !== null && usercontent !== undefined)) {\n                _context3.next = 20;\n                break;\n              }\n              scrollerProperties = {\n                scrollerPropertiesRef: scrollerPropertiesRef\n              };\n              if (usercontent.props.hasOwnProperty(\'scrollerProperties\')) {\n                content = react_1["default"].cloneElement(usercontent, {\n                  scrollerProperties: scrollerProperties\n                });\n              } else {\n                content = usercontent;\n              }\n              // const portalData = \n              _context3.next = 18;\n              return this.createPortal(scrollerID, content, index, itemID, scrollerProperties, true);\n            case 18:\n              _context3.next = 21;\n              break;\n            case 20:\n              if (usercontent === undefined) {\n                itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', error);\n              } else {\n                // usercontent === null; last item in list\n                itemExceptionCallback && itemExceptionCallback(index, itemID, returnvalue, \'preload\', new Error(\'end of list\'));\n                maxListsizeInterrupt(index);\n              }\n            case 21:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 8]]);\n      }));\n    }\n    // delete a portal list item\n    // accepts an array of indexes\n  }, {\n    key: "deletePortalByIndex",\n    value: function deletePortalByIndex(scrollerID, index, deleteListCallback) {\n      var indexArray = !Array.isArray(index) ? [index] : index;\n      var _this$scrollerDataMap8 = this.scrollerDataMap.get(scrollerID),\n        indexToItemIDMap = _this$scrollerDataMap8.indexToItemIDMap,\n        itemSet = _this$scrollerDataMap8.itemSet;\n      var itemMetadataMap = this.itemMetadataMap;\n      var removePartitionPortal = this.removePartitionPortal;\n      var deleteList = [];\n      var _iterator8 = _createForOfIteratorHelper(indexArray),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _index4 = _step8.value;\n          var itemID = indexToItemIDMap.get(_index4);\n          if (itemID === undefined) continue; // async mismatch\n          deleteList.push({\n            index: _index4,\n            itemID: itemID\n          });\n          var _itemMetadataMap$get4 = itemMetadataMap.get(itemID),\n            partitionID = _itemMetadataMap$get4.partitionID;\n          removePartitionPortal(partitionID, itemID);\n          itemMetadataMap["delete"](itemID);\n          itemSet["delete"](itemID);\n          indexToItemIDMap["delete"](_index4);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      deleteListCallback && deleteListCallback(deleteList);\n    }\n    // query existence of a portal list item\n  }, {\n    key: "hasPortal",\n    value: function hasPortal(itemID) {\n      return this.itemMetadataMap.has(itemID);\n    }\n  }, {\n    key: "getPortalMetadata",\n    value: function getPortalMetadata(itemID) {\n      if (this.hasPortal(itemID)) {\n        return this.itemMetadataMap.get(itemID);\n      }\n    }\n  }]);\n  return CacheAPI;\n}();\nexports["default"] = CacheAPI;\n// ==========================[ Utility function ]============================\n// get a react-reverse-portal InPortal component, with its metadata\n// with user content and container\n// see also some styles set in CellFrame\nvar createPortalNode = function createPortalNode(index, itemID) {\n  var portalNode = (0, react_reverse_portal_1.createHtmlPortalNode)();\n  var container = portalNode.element;\n  container.style.overflow = \'hidden\';\n  container.dataset.type = \'contentenvelope\';\n  container.dataset.index = index;\n  container.dataset.cacheitemid = itemID;\n  return portalNode;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcG9ydGFsY2FjaGUvY2FjaGVBUEkudHN4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBLFNBQUFBLFFBQUFDLEdBQUEsc0NBQUFELE9BQUEsd0JBQUFFLE1BQUEsdUJBQUFBLE1BQUEsQ0FBQUMsUUFBQSxhQUFBRixHQUFBLGtCQUFBQSxHQUFBLGdCQUFBQSxHQUFBLFdBQUFBLEdBQUEseUJBQUFDLE1BQUEsSUFBQUQsR0FBQSxDQUFBRyxXQUFBLEtBQUFGLE1BQUEsSUFBQUQsR0FBQSxLQUFBQyxNQUFBLENBQUFHLFNBQUEscUJBQUFKLEdBQUEsS0FBQUQsT0FBQSxDQUFBQyxHQUFBO0FBQUEsU0FBQUssb0JBQUEsa0JBREEscUpBQUFBLG1CQUFBLFlBQUFBLG9CQUFBLFdBQUFDLE9BQUEsU0FBQUEsT0FBQSxPQUFBQyxFQUFBLEdBQUFDLE1BQUEsQ0FBQUosU0FBQSxFQUFBSyxNQUFBLEdBQUFGLEVBQUEsQ0FBQUcsY0FBQSxFQUFBQyxjQUFBLEdBQUFILE1BQUEsQ0FBQUcsY0FBQSxjQUFBWCxHQUFBLEVBQUFZLEdBQUEsRUFBQUMsSUFBQSxJQUFBYixHQUFBLENBQUFZLEdBQUEsSUFBQUMsSUFBQSxDQUFBQyxLQUFBLEtBQUFDLE9BQUEsd0JBQUFkLE1BQUEsR0FBQUEsTUFBQSxPQUFBZSxjQUFBLEdBQUFELE9BQUEsQ0FBQWIsUUFBQSxrQkFBQWUsbUJBQUEsR0FBQUYsT0FBQSxDQUFBRyxhQUFBLHVCQUFBQyxpQkFBQSxHQUFBSixPQUFBLENBQUFLLFdBQUEsOEJBQUFDLE9BQUFyQixHQUFBLEVBQUFZLEdBQUEsRUFBQUUsS0FBQSxXQUFBTixNQUFBLENBQUFHLGNBQUEsQ0FBQVgsR0FBQSxFQUFBWSxHQUFBLElBQUFFLEtBQUEsRUFBQUEsS0FBQSxFQUFBUSxVQUFBLE1BQUFDLFlBQUEsTUFBQUMsUUFBQSxTQUFBeEIsR0FBQSxDQUFBWSxHQUFBLFdBQUFTLE1BQUEsbUJBQUFJLEdBQUEsSUFBQUosTUFBQSxZQUFBQSxPQUFBckIsR0FBQSxFQUFBWSxHQUFBLEVBQUFFLEtBQUEsV0FBQWQsR0FBQSxDQUFBWSxHQUFBLElBQUFFLEtBQUEsZ0JBQUFZLEtBQUFDLE9BQUEsRUFBQUMsT0FBQSxFQUFBQyxJQUFBLEVBQUFDLFdBQUEsUUFBQUMsY0FBQSxHQUFBSCxPQUFBLElBQUFBLE9BQUEsQ0FBQXhCLFNBQUEsWUFBQTRCLFNBQUEsR0FBQUosT0FBQSxHQUFBSSxTQUFBLEVBQUFDLFNBQUEsR0FBQXpCLE1BQUEsQ0FBQTBCLE1BQUEsQ0FBQUgsY0FBQSxDQUFBM0IsU0FBQSxHQUFBK0IsT0FBQSxPQUFBQyxPQUFBLENBQUFOLFdBQUEsZ0JBQUFuQixjQUFBLENBQUFzQixTQUFBLGVBQUFuQixLQUFBLEVBQUF1QixnQkFBQSxDQUFBVixPQUFBLEVBQUFFLElBQUEsRUFBQU0sT0FBQSxNQUFBRixTQUFBLGFBQUFLLFNBQUFDLEVBQUEsRUFBQXZDLEdBQUEsRUFBQXdDLEdBQUEsbUJBQUFDLElBQUEsWUFBQUQsR0FBQSxFQUFBRCxFQUFBLENBQUFHLElBQUEsQ0FBQTFDLEdBQUEsRUFBQXdDLEdBQUEsY0FBQWYsR0FBQSxhQUFBZ0IsSUFBQSxXQUFBRCxHQUFBLEVBQUFmLEdBQUEsUUFBQW5CLE9BQUEsQ0FBQW9CLElBQUEsR0FBQUEsSUFBQSxNQUFBaUIsZ0JBQUEsZ0JBQUFYLFVBQUEsY0FBQVksa0JBQUEsY0FBQUMsMkJBQUEsU0FBQUMsaUJBQUEsT0FBQXpCLE1BQUEsQ0FBQXlCLGlCQUFBLEVBQUE5QixjQUFBLHFDQUFBK0IsUUFBQSxHQUFBdkMsTUFBQSxDQUFBd0MsY0FBQSxFQUFBQyx1QkFBQSxHQUFBRixRQUFBLElBQUFBLFFBQUEsQ0FBQUEsUUFBQSxDQUFBRyxNQUFBLFFBQUFELHVCQUFBLElBQUFBLHVCQUFBLEtBQUExQyxFQUFBLElBQUFFLE1BQUEsQ0FBQWlDLElBQUEsQ0FBQU8sdUJBQUEsRUFBQWpDLGNBQUEsTUFBQThCLGlCQUFBLEdBQUFHLHVCQUFBLE9BQUFFLEVBQUEsR0FBQU4sMEJBQUEsQ0FBQXpDLFNBQUEsR0FBQTRCLFNBQUEsQ0FBQTVCLFNBQUEsR0FBQUksTUFBQSxDQUFBMEIsTUFBQSxDQUFBWSxpQkFBQSxZQUFBTSxzQkFBQWhELFNBQUEsZ0NBQUFpRCxPQUFBLFdBQUFDLE1BQUEsSUFBQWpDLE1BQUEsQ0FBQWpCLFNBQUEsRUFBQWtELE1BQUEsWUFBQWQsR0FBQSxnQkFBQWUsT0FBQSxDQUFBRCxNQUFBLEVBQUFkLEdBQUEsc0JBQUFnQixjQUFBdkIsU0FBQSxFQUFBd0IsV0FBQSxhQUFBQyxPQUFBSixNQUFBLEVBQUFkLEdBQUEsRUFBQW1CLE9BQUEsRUFBQUMsTUFBQSxRQUFBQyxNQUFBLEdBQUF2QixRQUFBLENBQUFMLFNBQUEsQ0FBQXFCLE1BQUEsR0FBQXJCLFNBQUEsRUFBQU8sR0FBQSxtQkFBQXFCLE1BQUEsQ0FBQXBCLElBQUEsUUFBQXFCLE1BQUEsR0FBQUQsTUFBQSxDQUFBckIsR0FBQSxFQUFBMUIsS0FBQSxHQUFBZ0QsTUFBQSxDQUFBaEQsS0FBQSxTQUFBQSxLQUFBLGdCQUFBZixPQUFBLENBQUFlLEtBQUEsS0FBQUwsTUFBQSxDQUFBaUMsSUFBQSxDQUFBNUIsS0FBQSxlQUFBMkMsV0FBQSxDQUFBRSxPQUFBLENBQUE3QyxLQUFBLENBQUFpRCxPQUFBLEVBQUFDLElBQUEsV0FBQWxELEtBQUEsSUFBQTRDLE1BQUEsU0FBQTVDLEtBQUEsRUFBQTZDLE9BQUEsRUFBQUMsTUFBQSxnQkFBQW5DLEdBQUEsSUFBQWlDLE1BQUEsVUFBQWpDLEdBQUEsRUFBQWtDLE9BQUEsRUFBQUMsTUFBQSxRQUFBSCxXQUFBLENBQUFFLE9BQUEsQ0FBQTdDLEtBQUEsRUFBQWtELElBQUEsV0FBQUMsU0FBQSxJQUFBSCxNQUFBLENBQUFoRCxLQUFBLEdBQUFtRCxTQUFBLEVBQUFOLE9BQUEsQ0FBQUcsTUFBQSxnQkFBQUksS0FBQSxXQUFBUixNQUFBLFVBQUFRLEtBQUEsRUFBQVAsT0FBQSxFQUFBQyxNQUFBLFNBQUFBLE1BQUEsQ0FBQUMsTUFBQSxDQUFBckIsR0FBQSxTQUFBMkIsZUFBQSxFQUFBeEQsY0FBQSxvQkFBQUcsS0FBQSxXQUFBQSxNQUFBd0MsTUFBQSxFQUFBZCxHQUFBLGFBQUE0QiwyQkFBQSxlQUFBWCxXQUFBLFdBQUFFLE9BQUEsRUFBQUMsTUFBQSxJQUFBRixNQUFBLENBQUFKLE1BQUEsRUFBQWQsR0FBQSxFQUFBbUIsT0FBQSxFQUFBQyxNQUFBLGdCQUFBTyxlQUFBLEdBQUFBLGVBQUEsR0FBQUEsZUFBQSxDQUFBSCxJQUFBLENBQUFJLDBCQUFBLEVBQUFBLDBCQUFBLElBQUFBLDBCQUFBLHFCQUFBL0IsaUJBQUFWLE9BQUEsRUFBQUUsSUFBQSxFQUFBTSxPQUFBLFFBQUFrQyxLQUFBLHNDQUFBZixNQUFBLEVBQUFkLEdBQUEsd0JBQUE2QixLQUFBLFlBQUFDLEtBQUEsc0RBQUFELEtBQUEsb0JBQUFmLE1BQUEsUUFBQWQsR0FBQSxTQUFBK0IsVUFBQSxXQUFBcEMsT0FBQSxDQUFBbUIsTUFBQSxHQUFBQSxNQUFBLEVBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQUEsR0FBQSxVQUFBZ0MsUUFBQSxHQUFBckMsT0FBQSxDQUFBcUMsUUFBQSxNQUFBQSxRQUFBLFFBQUFDLGNBQUEsR0FBQUMsbUJBQUEsQ0FBQUYsUUFBQSxFQUFBckMsT0FBQSxPQUFBc0MsY0FBQSxRQUFBQSxjQUFBLEtBQUE5QixnQkFBQSxtQkFBQThCLGNBQUEscUJBQUF0QyxPQUFBLENBQUFtQixNQUFBLEVBQUFuQixPQUFBLENBQUF3QyxJQUFBLEdBQUF4QyxPQUFBLENBQUF5QyxLQUFBLEdBQUF6QyxPQUFBLENBQUFLLEdBQUEsc0JBQUFMLE9BQUEsQ0FBQW1CLE1BQUEsNkJBQUFlLEtBQUEsUUFBQUEsS0FBQSxnQkFBQWxDLE9BQUEsQ0FBQUssR0FBQSxFQUFBTCxPQUFBLENBQUEwQyxpQkFBQSxDQUFBMUMsT0FBQSxDQUFBSyxHQUFBLHVCQUFBTCxPQUFBLENBQUFtQixNQUFBLElBQUFuQixPQUFBLENBQUEyQyxNQUFBLFdBQUEzQyxPQUFBLENBQUFLLEdBQUEsR0FBQTZCLEtBQUEsb0JBQUFSLE1BQUEsR0FBQXZCLFFBQUEsQ0FBQVgsT0FBQSxFQUFBRSxJQUFBLEVBQUFNLE9BQUEsb0JBQUEwQixNQUFBLENBQUFwQixJQUFBLFFBQUE0QixLQUFBLEdBQUFsQyxPQUFBLENBQUE0QyxJQUFBLG1DQUFBbEIsTUFBQSxDQUFBckIsR0FBQSxLQUFBRyxnQkFBQSxxQkFBQTdCLEtBQUEsRUFBQStDLE1BQUEsQ0FBQXJCLEdBQUEsRUFBQXVDLElBQUEsRUFBQTVDLE9BQUEsQ0FBQTRDLElBQUEsa0JBQUFsQixNQUFBLENBQUFwQixJQUFBLEtBQUE0QixLQUFBLGdCQUFBbEMsT0FBQSxDQUFBbUIsTUFBQSxZQUFBbkIsT0FBQSxDQUFBSyxHQUFBLEdBQUFxQixNQUFBLENBQUFyQixHQUFBLG1CQUFBa0Msb0JBQUFGLFFBQUEsRUFBQXJDLE9BQUEsUUFBQTZDLFVBQUEsR0FBQTdDLE9BQUEsQ0FBQW1CLE1BQUEsRUFBQUEsTUFBQSxHQUFBa0IsUUFBQSxDQUFBdEUsUUFBQSxDQUFBOEUsVUFBQSxPQUFBQyxTQUFBLEtBQUEzQixNQUFBLFNBQUFuQixPQUFBLENBQUFxQyxRQUFBLHFCQUFBUSxVQUFBLElBQUFSLFFBQUEsQ0FBQXRFLFFBQUEsZUFBQWlDLE9BQUEsQ0FBQW1CLE1BQUEsYUFBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxFQUFBUCxtQkFBQSxDQUFBRixRQUFBLEVBQUFyQyxPQUFBLGVBQUFBLE9BQUEsQ0FBQW1CLE1BQUEsa0JBQUEwQixVQUFBLEtBQUE3QyxPQUFBLENBQUFtQixNQUFBLFlBQUFuQixPQUFBLENBQUFLLEdBQUEsT0FBQTBDLFNBQUEsdUNBQUFGLFVBQUEsaUJBQUFyQyxnQkFBQSxNQUFBa0IsTUFBQSxHQUFBdkIsUUFBQSxDQUFBZ0IsTUFBQSxFQUFBa0IsUUFBQSxDQUFBdEUsUUFBQSxFQUFBaUMsT0FBQSxDQUFBSyxHQUFBLG1CQUFBcUIsTUFBQSxDQUFBcEIsSUFBQSxTQUFBTixPQUFBLENBQUFtQixNQUFBLFlBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQXFCLE1BQUEsQ0FBQXJCLEdBQUEsRUFBQUwsT0FBQSxDQUFBcUMsUUFBQSxTQUFBN0IsZ0JBQUEsTUFBQXdDLElBQUEsR0FBQXRCLE1BQUEsQ0FBQXJCLEdBQUEsU0FBQTJDLElBQUEsR0FBQUEsSUFBQSxDQUFBSixJQUFBLElBQUE1QyxPQUFBLENBQUFxQyxRQUFBLENBQUFZLFVBQUEsSUFBQUQsSUFBQSxDQUFBckUsS0FBQSxFQUFBcUIsT0FBQSxDQUFBa0QsSUFBQSxHQUFBYixRQUFBLENBQUFjLE9BQUEsZUFBQW5ELE9BQUEsQ0FBQW1CLE1BQUEsS0FBQW5CLE9BQUEsQ0FBQW1CLE1BQUEsV0FBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxHQUFBOUMsT0FBQSxDQUFBcUMsUUFBQSxTQUFBN0IsZ0JBQUEsSUFBQXdDLElBQUEsSUFBQWhELE9BQUEsQ0FBQW1CLE1BQUEsWUFBQW5CLE9BQUEsQ0FBQUssR0FBQSxPQUFBMEMsU0FBQSxzQ0FBQS9DLE9BQUEsQ0FBQXFDLFFBQUEsU0FBQTdCLGdCQUFBLGNBQUE0QyxhQUFBQyxJQUFBLFFBQUFDLEtBQUEsS0FBQUMsTUFBQSxFQUFBRixJQUFBLFlBQUFBLElBQUEsS0FBQUMsS0FBQSxDQUFBRSxRQUFBLEdBQUFILElBQUEsV0FBQUEsSUFBQSxLQUFBQyxLQUFBLENBQUFHLFVBQUEsR0FBQUosSUFBQSxLQUFBQyxLQUFBLENBQUFJLFFBQUEsR0FBQUwsSUFBQSxXQUFBTSxVQUFBLENBQUFDLElBQUEsQ0FBQU4sS0FBQSxjQUFBTyxjQUFBUCxLQUFBLFFBQUE1QixNQUFBLEdBQUE0QixLQUFBLENBQUFRLFVBQUEsUUFBQXBDLE1BQUEsQ0FBQXBCLElBQUEsb0JBQUFvQixNQUFBLENBQUFyQixHQUFBLEVBQUFpRCxLQUFBLENBQUFRLFVBQUEsR0FBQXBDLE1BQUEsYUFBQXpCLFFBQUFOLFdBQUEsU0FBQWdFLFVBQUEsTUFBQUosTUFBQSxhQUFBNUQsV0FBQSxDQUFBdUIsT0FBQSxDQUFBa0MsWUFBQSxjQUFBVyxLQUFBLGlCQUFBaEQsT0FBQWlELFFBQUEsUUFBQUEsUUFBQSxRQUFBQyxjQUFBLEdBQUFELFFBQUEsQ0FBQW5GLGNBQUEsT0FBQW9GLGNBQUEsU0FBQUEsY0FBQSxDQUFBMUQsSUFBQSxDQUFBeUQsUUFBQSw0QkFBQUEsUUFBQSxDQUFBZCxJQUFBLFNBQUFjLFFBQUEsT0FBQUUsS0FBQSxDQUFBRixRQUFBLENBQUFHLE1BQUEsU0FBQUMsQ0FBQSxPQUFBbEIsSUFBQSxZQUFBQSxLQUFBLGFBQUFrQixDQUFBLEdBQUFKLFFBQUEsQ0FBQUcsTUFBQSxPQUFBN0YsTUFBQSxDQUFBaUMsSUFBQSxDQUFBeUQsUUFBQSxFQUFBSSxDQUFBLFVBQUFsQixJQUFBLENBQUF2RSxLQUFBLEdBQUFxRixRQUFBLENBQUFJLENBQUEsR0FBQWxCLElBQUEsQ0FBQU4sSUFBQSxPQUFBTSxJQUFBLFNBQUFBLElBQUEsQ0FBQXZFLEtBQUEsR0FBQW1FLFNBQUEsRUFBQUksSUFBQSxDQUFBTixJQUFBLE9BQUFNLElBQUEsWUFBQUEsSUFBQSxDQUFBQSxJQUFBLEdBQUFBLElBQUEsZUFBQUEsSUFBQSxFQUFBZCxVQUFBLGVBQUFBLFdBQUEsYUFBQXpELEtBQUEsRUFBQW1FLFNBQUEsRUFBQUYsSUFBQSxpQkFBQW5DLGlCQUFBLENBQUF4QyxTQUFBLEdBQUF5QywwQkFBQSxFQUFBbEMsY0FBQSxDQUFBd0MsRUFBQSxtQkFBQXJDLEtBQUEsRUFBQStCLDBCQUFBLEVBQUF0QixZQUFBLFNBQUFaLGNBQUEsQ0FBQWtDLDBCQUFBLG1CQUFBL0IsS0FBQSxFQUFBOEIsaUJBQUEsRUFBQXJCLFlBQUEsU0FBQXFCLGlCQUFBLENBQUE0RCxXQUFBLEdBQUFuRixNQUFBLENBQUF3QiwwQkFBQSxFQUFBMUIsaUJBQUEsd0JBQUFiLE9BQUEsQ0FBQW1HLG1CQUFBLGFBQUFDLE1BQUEsUUFBQUMsSUFBQSx3QkFBQUQsTUFBQSxJQUFBQSxNQUFBLENBQUF2RyxXQUFBLFdBQUF3RyxJQUFBLEtBQUFBLElBQUEsS0FBQS9ELGlCQUFBLDZCQUFBK0QsSUFBQSxDQUFBSCxXQUFBLElBQUFHLElBQUEsQ0FBQUMsSUFBQSxPQUFBdEcsT0FBQSxDQUFBdUcsSUFBQSxhQUFBSCxNQUFBLFdBQUFsRyxNQUFBLENBQUFzRyxjQUFBLEdBQUF0RyxNQUFBLENBQUFzRyxjQUFBLENBQUFKLE1BQUEsRUFBQTdELDBCQUFBLEtBQUE2RCxNQUFBLENBQUFLLFNBQUEsR0FBQWxFLDBCQUFBLEVBQUF4QixNQUFBLENBQUFxRixNQUFBLEVBQUF2RixpQkFBQSx5QkFBQXVGLE1BQUEsQ0FBQXRHLFNBQUEsR0FBQUksTUFBQSxDQUFBMEIsTUFBQSxDQUFBaUIsRUFBQSxHQUFBdUQsTUFBQSxLQUFBcEcsT0FBQSxDQUFBMEcsS0FBQSxhQUFBeEUsR0FBQSxhQUFBdUIsT0FBQSxFQUFBdkIsR0FBQSxPQUFBWSxxQkFBQSxDQUFBSSxhQUFBLENBQUFwRCxTQUFBLEdBQUFpQixNQUFBLENBQUFtQyxhQUFBLENBQUFwRCxTQUFBLEVBQUFhLG1CQUFBLGlDQUFBWCxPQUFBLENBQUFrRCxhQUFBLEdBQUFBLGFBQUEsRUFBQWxELE9BQUEsQ0FBQTJHLEtBQUEsYUFBQXRGLE9BQUEsRUFBQUMsT0FBQSxFQUFBQyxJQUFBLEVBQUFDLFdBQUEsRUFBQTJCLFdBQUEsZUFBQUEsV0FBQSxLQUFBQSxXQUFBLEdBQUF5RCxPQUFBLE9BQUFDLElBQUEsT0FBQTNELGFBQUEsQ0FBQTlCLElBQUEsQ0FBQUMsT0FBQSxFQUFBQyxPQUFBLEVBQUFDLElBQUEsRUFBQUMsV0FBQSxHQUFBMkIsV0FBQSxVQUFBbkQsT0FBQSxDQUFBbUcsbUJBQUEsQ0FBQTdFLE9BQUEsSUFBQXVGLElBQUEsR0FBQUEsSUFBQSxDQUFBOUIsSUFBQSxHQUFBckIsSUFBQSxXQUFBRixNQUFBLFdBQUFBLE1BQUEsQ0FBQWlCLElBQUEsR0FBQWpCLE1BQUEsQ0FBQWhELEtBQUEsR0FBQXFHLElBQUEsQ0FBQTlCLElBQUEsV0FBQWpDLHFCQUFBLENBQUFELEVBQUEsR0FBQTlCLE1BQUEsQ0FBQThCLEVBQUEsRUFBQWhDLGlCQUFBLGdCQUFBRSxNQUFBLENBQUE4QixFQUFBLEVBQUFuQyxjQUFBLGlDQUFBSyxNQUFBLENBQUE4QixFQUFBLDZEQUFBN0MsT0FBQSxDQUFBOEcsSUFBQSxhQUFBQyxHQUFBLFFBQUFDLE1BQUEsR0FBQTlHLE1BQUEsQ0FBQTZHLEdBQUEsR0FBQUQsSUFBQSxnQkFBQXhHLEdBQUEsSUFBQTBHLE1BQUEsRUFBQUYsSUFBQSxDQUFBckIsSUFBQSxDQUFBbkYsR0FBQSxVQUFBd0csSUFBQSxDQUFBRyxPQUFBLGFBQUFsQyxLQUFBLFdBQUErQixJQUFBLENBQUFkLE1BQUEsU0FBQTFGLEdBQUEsR0FBQXdHLElBQUEsQ0FBQUksR0FBQSxRQUFBNUcsR0FBQSxJQUFBMEcsTUFBQSxTQUFBakMsSUFBQSxDQUFBdkUsS0FBQSxHQUFBRixHQUFBLEVBQUF5RSxJQUFBLENBQUFOLElBQUEsT0FBQU0sSUFBQSxXQUFBQSxJQUFBLENBQUFOLElBQUEsT0FBQU0sSUFBQSxRQUFBL0UsT0FBQSxDQUFBNEMsTUFBQSxHQUFBQSxNQUFBLEVBQUFkLE9BQUEsQ0FBQWhDLFNBQUEsS0FBQUQsV0FBQSxFQUFBaUMsT0FBQSxFQUFBOEQsS0FBQSxXQUFBQSxNQUFBdUIsYUFBQSxhQUFBQyxJQUFBLFdBQUFyQyxJQUFBLFdBQUFWLElBQUEsUUFBQUMsS0FBQSxHQUFBSyxTQUFBLE9BQUFGLElBQUEsWUFBQVAsUUFBQSxjQUFBbEIsTUFBQSxnQkFBQWQsR0FBQSxHQUFBeUMsU0FBQSxPQUFBYSxVQUFBLENBQUF6QyxPQUFBLENBQUEyQyxhQUFBLElBQUF5QixhQUFBLFdBQUFiLElBQUEsa0JBQUFBLElBQUEsQ0FBQWUsTUFBQSxPQUFBbEgsTUFBQSxDQUFBaUMsSUFBQSxPQUFBa0UsSUFBQSxNQUFBUCxLQUFBLEVBQUFPLElBQUEsQ0FBQWdCLEtBQUEsY0FBQWhCLElBQUEsSUFBQTNCLFNBQUEsTUFBQTRDLElBQUEsV0FBQUEsS0FBQSxTQUFBOUMsSUFBQSxXQUFBK0MsVUFBQSxRQUFBaEMsVUFBQSxJQUFBRyxVQUFBLGtCQUFBNkIsVUFBQSxDQUFBckYsSUFBQSxRQUFBcUYsVUFBQSxDQUFBdEYsR0FBQSxjQUFBdUYsSUFBQSxLQUFBbEQsaUJBQUEsV0FBQUEsa0JBQUFtRCxTQUFBLGFBQUFqRCxJQUFBLFFBQUFpRCxTQUFBLE1BQUE3RixPQUFBLGtCQUFBOEYsT0FBQUMsR0FBQSxFQUFBQyxNQUFBLFdBQUF0RSxNQUFBLENBQUFwQixJQUFBLFlBQUFvQixNQUFBLENBQUFyQixHQUFBLEdBQUF3RixTQUFBLEVBQUE3RixPQUFBLENBQUFrRCxJQUFBLEdBQUE2QyxHQUFBLEVBQUFDLE1BQUEsS0FBQWhHLE9BQUEsQ0FBQW1CLE1BQUEsV0FBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxLQUFBa0QsTUFBQSxhQUFBNUIsQ0FBQSxRQUFBVCxVQUFBLENBQUFRLE1BQUEsTUFBQUMsQ0FBQSxTQUFBQSxDQUFBLFFBQUFkLEtBQUEsUUFBQUssVUFBQSxDQUFBUyxDQUFBLEdBQUExQyxNQUFBLEdBQUE0QixLQUFBLENBQUFRLFVBQUEsaUJBQUFSLEtBQUEsQ0FBQUMsTUFBQSxTQUFBdUMsTUFBQSxhQUFBeEMsS0FBQSxDQUFBQyxNQUFBLFNBQUFnQyxJQUFBLFFBQUFVLFFBQUEsR0FBQTNILE1BQUEsQ0FBQWlDLElBQUEsQ0FBQStDLEtBQUEsZUFBQTRDLFVBQUEsR0FBQTVILE1BQUEsQ0FBQWlDLElBQUEsQ0FBQStDLEtBQUEscUJBQUEyQyxRQUFBLElBQUFDLFVBQUEsYUFBQVgsSUFBQSxHQUFBakMsS0FBQSxDQUFBRSxRQUFBLFNBQUFzQyxNQUFBLENBQUF4QyxLQUFBLENBQUFFLFFBQUEsZ0JBQUErQixJQUFBLEdBQUFqQyxLQUFBLENBQUFHLFVBQUEsU0FBQXFDLE1BQUEsQ0FBQXhDLEtBQUEsQ0FBQUcsVUFBQSxjQUFBd0MsUUFBQSxhQUFBVixJQUFBLEdBQUFqQyxLQUFBLENBQUFFLFFBQUEsU0FBQXNDLE1BQUEsQ0FBQXhDLEtBQUEsQ0FBQUUsUUFBQSxxQkFBQTBDLFVBQUEsWUFBQS9ELEtBQUEscURBQUFvRCxJQUFBLEdBQUFqQyxLQUFBLENBQUFHLFVBQUEsU0FBQXFDLE1BQUEsQ0FBQXhDLEtBQUEsQ0FBQUcsVUFBQSxZQUFBZCxNQUFBLFdBQUFBLE9BQUFyQyxJQUFBLEVBQUFELEdBQUEsYUFBQStELENBQUEsUUFBQVQsVUFBQSxDQUFBUSxNQUFBLE1BQUFDLENBQUEsU0FBQUEsQ0FBQSxRQUFBZCxLQUFBLFFBQUFLLFVBQUEsQ0FBQVMsQ0FBQSxPQUFBZCxLQUFBLENBQUFDLE1BQUEsU0FBQWdDLElBQUEsSUFBQWpILE1BQUEsQ0FBQWlDLElBQUEsQ0FBQStDLEtBQUEsd0JBQUFpQyxJQUFBLEdBQUFqQyxLQUFBLENBQUFHLFVBQUEsUUFBQTBDLFlBQUEsR0FBQTdDLEtBQUEsYUFBQTZDLFlBQUEsaUJBQUE3RixJQUFBLG1CQUFBQSxJQUFBLEtBQUE2RixZQUFBLENBQUE1QyxNQUFBLElBQUFsRCxHQUFBLElBQUFBLEdBQUEsSUFBQThGLFlBQUEsQ0FBQTFDLFVBQUEsS0FBQTBDLFlBQUEsY0FBQXpFLE1BQUEsR0FBQXlFLFlBQUEsR0FBQUEsWUFBQSxDQUFBckMsVUFBQSxjQUFBcEMsTUFBQSxDQUFBcEIsSUFBQSxHQUFBQSxJQUFBLEVBQUFvQixNQUFBLENBQUFyQixHQUFBLEdBQUFBLEdBQUEsRUFBQThGLFlBQUEsU0FBQWhGLE1BQUEsZ0JBQUErQixJQUFBLEdBQUFpRCxZQUFBLENBQUExQyxVQUFBLEVBQUFqRCxnQkFBQSxTQUFBNEYsUUFBQSxDQUFBMUUsTUFBQSxNQUFBMEUsUUFBQSxXQUFBQSxTQUFBMUUsTUFBQSxFQUFBZ0MsUUFBQSxvQkFBQWhDLE1BQUEsQ0FBQXBCLElBQUEsUUFBQW9CLE1BQUEsQ0FBQXJCLEdBQUEscUJBQUFxQixNQUFBLENBQUFwQixJQUFBLG1CQUFBb0IsTUFBQSxDQUFBcEIsSUFBQSxRQUFBNEMsSUFBQSxHQUFBeEIsTUFBQSxDQUFBckIsR0FBQSxnQkFBQXFCLE1BQUEsQ0FBQXBCLElBQUEsU0FBQXNGLElBQUEsUUFBQXZGLEdBQUEsR0FBQXFCLE1BQUEsQ0FBQXJCLEdBQUEsT0FBQWMsTUFBQSxrQkFBQStCLElBQUEseUJBQUF4QixNQUFBLENBQUFwQixJQUFBLElBQUFvRCxRQUFBLFVBQUFSLElBQUEsR0FBQVEsUUFBQSxHQUFBbEQsZ0JBQUEsS0FBQTZGLE1BQUEsV0FBQUEsT0FBQTVDLFVBQUEsYUFBQVcsQ0FBQSxRQUFBVCxVQUFBLENBQUFRLE1BQUEsTUFBQUMsQ0FBQSxTQUFBQSxDQUFBLFFBQUFkLEtBQUEsUUFBQUssVUFBQSxDQUFBUyxDQUFBLE9BQUFkLEtBQUEsQ0FBQUcsVUFBQSxLQUFBQSxVQUFBLGNBQUEyQyxRQUFBLENBQUE5QyxLQUFBLENBQUFRLFVBQUEsRUFBQVIsS0FBQSxDQUFBSSxRQUFBLEdBQUFHLGFBQUEsQ0FBQVAsS0FBQSxHQUFBOUMsZ0JBQUEseUJBQUE4RixPQUFBL0MsTUFBQSxhQUFBYSxDQUFBLFFBQUFULFVBQUEsQ0FBQVEsTUFBQSxNQUFBQyxDQUFBLFNBQUFBLENBQUEsUUFBQWQsS0FBQSxRQUFBSyxVQUFBLENBQUFTLENBQUEsT0FBQWQsS0FBQSxDQUFBQyxNQUFBLEtBQUFBLE1BQUEsUUFBQTdCLE1BQUEsR0FBQTRCLEtBQUEsQ0FBQVEsVUFBQSxrQkFBQXBDLE1BQUEsQ0FBQXBCLElBQUEsUUFBQWlHLE1BQUEsR0FBQTdFLE1BQUEsQ0FBQXJCLEdBQUEsRUFBQXdELGFBQUEsQ0FBQVAsS0FBQSxZQUFBaUQsTUFBQSxnQkFBQXBFLEtBQUEsOEJBQUFxRSxhQUFBLFdBQUFBLGNBQUF4QyxRQUFBLEVBQUFmLFVBQUEsRUFBQUUsT0FBQSxnQkFBQWQsUUFBQSxLQUFBdEUsUUFBQSxFQUFBZ0QsTUFBQSxDQUFBaUQsUUFBQSxHQUFBZixVQUFBLEVBQUFBLFVBQUEsRUFBQUUsT0FBQSxFQUFBQSxPQUFBLG9CQUFBaEMsTUFBQSxVQUFBZCxHQUFBLEdBQUF5QyxTQUFBLEdBQUF0QyxnQkFBQSxPQUFBckMsT0FBQTtBQUFBLFNBQUFzSSxlQUFBQyxHQUFBLEVBQUF0QyxDQUFBLFdBQUF1QyxlQUFBLENBQUFELEdBQUEsS0FBQUUscUJBQUEsQ0FBQUYsR0FBQSxFQUFBdEMsQ0FBQSxLQUFBeUMsMkJBQUEsQ0FBQUgsR0FBQSxFQUFBdEMsQ0FBQSxLQUFBMEMsZ0JBQUE7QUFBQSxTQUFBQSxpQkFBQSxjQUFBL0QsU0FBQTtBQUFBLFNBQUE2RCxzQkFBQUYsR0FBQSxFQUFBdEMsQ0FBQSxRQUFBMkMsRUFBQSxXQUFBTCxHQUFBLGdDQUFBNUksTUFBQSxJQUFBNEksR0FBQSxDQUFBNUksTUFBQSxDQUFBQyxRQUFBLEtBQUEySSxHQUFBLDRCQUFBSyxFQUFBLFFBQUFDLEVBQUEsRUFBQUMsRUFBQSxFQUFBQyxFQUFBLEVBQUFDLEVBQUEsRUFBQUMsSUFBQSxPQUFBQyxFQUFBLE9BQUFDLEVBQUEsaUJBQUFKLEVBQUEsSUFBQUgsRUFBQSxHQUFBQSxFQUFBLENBQUF4RyxJQUFBLENBQUFtRyxHQUFBLEdBQUF4RCxJQUFBLFFBQUFrQixDQUFBLFFBQUEvRixNQUFBLENBQUEwSSxFQUFBLE1BQUFBLEVBQUEsVUFBQU0sRUFBQSx1QkFBQUEsRUFBQSxJQUFBTCxFQUFBLEdBQUFFLEVBQUEsQ0FBQTNHLElBQUEsQ0FBQXdHLEVBQUEsR0FBQW5FLElBQUEsTUFBQXdFLElBQUEsQ0FBQXhELElBQUEsQ0FBQW9ELEVBQUEsQ0FBQXJJLEtBQUEsR0FBQXlJLElBQUEsQ0FBQWpELE1BQUEsS0FBQUMsQ0FBQSxHQUFBaUQsRUFBQSxpQkFBQS9ILEdBQUEsSUFBQWdJLEVBQUEsT0FBQUwsRUFBQSxHQUFBM0gsR0FBQSx5QkFBQStILEVBQUEsWUFBQU4sRUFBQSxlQUFBSSxFQUFBLEdBQUFKLEVBQUEsY0FBQTFJLE1BQUEsQ0FBQThJLEVBQUEsTUFBQUEsRUFBQSwyQkFBQUcsRUFBQSxRQUFBTCxFQUFBLGFBQUFHLElBQUE7QUFBQSxTQUFBVCxnQkFBQUQsR0FBQSxRQUFBYSxLQUFBLENBQUFDLE9BQUEsQ0FBQWQsR0FBQSxVQUFBQSxHQUFBO0FBQUEsU0FBQWUsMkJBQUFDLENBQUEsRUFBQUMsY0FBQSxRQUFBQyxFQUFBLFVBQUE5SixNQUFBLG9CQUFBNEosQ0FBQSxDQUFBNUosTUFBQSxDQUFBQyxRQUFBLEtBQUEySixDQUFBLHFCQUFBRSxFQUFBLFFBQUFMLEtBQUEsQ0FBQUMsT0FBQSxDQUFBRSxDQUFBLE1BQUFFLEVBQUEsR0FBQWYsMkJBQUEsQ0FBQWEsQ0FBQSxNQUFBQyxjQUFBLElBQUFELENBQUEsV0FBQUEsQ0FBQSxDQUFBdkQsTUFBQSxxQkFBQXlELEVBQUEsRUFBQUYsQ0FBQSxHQUFBRSxFQUFBLE1BQUF4RCxDQUFBLFVBQUF5RCxDQUFBLFlBQUFBLEVBQUEsZUFBQUMsQ0FBQSxFQUFBRCxDQUFBLEVBQUFFLENBQUEsV0FBQUEsRUFBQSxRQUFBM0QsQ0FBQSxJQUFBc0QsQ0FBQSxDQUFBdkQsTUFBQSxXQUFBdkIsSUFBQSxtQkFBQUEsSUFBQSxTQUFBakUsS0FBQSxFQUFBK0ksQ0FBQSxDQUFBdEQsQ0FBQSxVQUFBNEQsQ0FBQSxXQUFBQSxFQUFBQyxHQUFBLFVBQUFBLEdBQUEsS0FBQUMsQ0FBQSxFQUFBTCxDQUFBLGdCQUFBOUUsU0FBQSxpSkFBQW9GLGdCQUFBLFNBQUFDLE1BQUEsVUFBQTlJLEdBQUEsV0FBQXdJLENBQUEsV0FBQUEsRUFBQSxJQUFBRixFQUFBLEdBQUFBLEVBQUEsQ0FBQXJILElBQUEsQ0FBQW1ILENBQUEsTUFBQUssQ0FBQSxXQUFBQSxFQUFBLFFBQUFNLElBQUEsR0FBQVQsRUFBQSxDQUFBMUUsSUFBQSxJQUFBaUYsZ0JBQUEsR0FBQUUsSUFBQSxDQUFBekYsSUFBQSxTQUFBeUYsSUFBQSxLQUFBTCxDQUFBLFdBQUFBLEVBQUFNLEdBQUEsSUFBQUYsTUFBQSxTQUFBOUksR0FBQSxHQUFBZ0osR0FBQSxLQUFBSixDQUFBLFdBQUFBLEVBQUEsZUFBQUMsZ0JBQUEsSUFBQVAsRUFBQSxvQkFBQUEsRUFBQSw4QkFBQVEsTUFBQSxRQUFBOUksR0FBQTtBQUFBLFNBQUFpSixtQkFBQTdCLEdBQUEsV0FBQThCLGtCQUFBLENBQUE5QixHQUFBLEtBQUErQixnQkFBQSxDQUFBL0IsR0FBQSxLQUFBRywyQkFBQSxDQUFBSCxHQUFBLEtBQUFnQyxrQkFBQTtBQUFBLFNBQUFBLG1CQUFBLGNBQUEzRixTQUFBO0FBQUEsU0FBQThELDRCQUFBYSxDQUFBLEVBQUFpQixNQUFBLFNBQUFqQixDQUFBLHFCQUFBQSxDQUFBLHNCQUFBa0IsaUJBQUEsQ0FBQWxCLENBQUEsRUFBQWlCLE1BQUEsT0FBQVosQ0FBQSxHQUFBMUosTUFBQSxDQUFBSixTQUFBLENBQUE0SyxRQUFBLENBQUF0SSxJQUFBLENBQUFtSCxDQUFBLEVBQUFqQyxLQUFBLGFBQUFzQyxDQUFBLGlCQUFBTCxDQUFBLENBQUExSixXQUFBLEVBQUErSixDQUFBLEdBQUFMLENBQUEsQ0FBQTFKLFdBQUEsQ0FBQXlHLElBQUEsTUFBQXNELENBQUEsY0FBQUEsQ0FBQSxtQkFBQVIsS0FBQSxDQUFBdUIsSUFBQSxDQUFBcEIsQ0FBQSxPQUFBSyxDQUFBLCtEQUFBZ0IsSUFBQSxDQUFBaEIsQ0FBQSxVQUFBYSxpQkFBQSxDQUFBbEIsQ0FBQSxFQUFBaUIsTUFBQTtBQUFBLFNBQUFGLGlCQUFBekQsSUFBQSxlQUFBbEgsTUFBQSxvQkFBQWtILElBQUEsQ0FBQWxILE1BQUEsQ0FBQUMsUUFBQSxhQUFBaUgsSUFBQSwrQkFBQXVDLEtBQUEsQ0FBQXVCLElBQUEsQ0FBQTlELElBQUE7QUFBQSxTQUFBd0QsbUJBQUE5QixHQUFBLFFBQUFhLEtBQUEsQ0FBQUMsT0FBQSxDQUFBZCxHQUFBLFVBQUFrQyxpQkFBQSxDQUFBbEMsR0FBQTtBQUFBLFNBQUFrQyxrQkFBQWxDLEdBQUEsRUFBQXNDLEdBQUEsUUFBQUEsR0FBQSxZQUFBQSxHQUFBLEdBQUF0QyxHQUFBLENBQUF2QyxNQUFBLEVBQUE2RSxHQUFBLEdBQUF0QyxHQUFBLENBQUF2QyxNQUFBLFdBQUFDLENBQUEsTUFBQTZFLElBQUEsT0FBQTFCLEtBQUEsQ0FBQXlCLEdBQUEsR0FBQTVFLENBQUEsR0FBQTRFLEdBQUEsRUFBQTVFLENBQUEsSUFBQTZFLElBQUEsQ0FBQTdFLENBQUEsSUFBQXNDLEdBQUEsQ0FBQXRDLENBQUEsVUFBQTZFLElBQUE7QUFBQSxTQUFBQyxnQkFBQUMsUUFBQSxFQUFBQyxXQUFBLFVBQUFELFFBQUEsWUFBQUMsV0FBQSxlQUFBckcsU0FBQTtBQUFBLFNBQUFzRyxrQkFBQUMsTUFBQSxFQUFBQyxLQUFBLGFBQUFuRixDQUFBLE1BQUFBLENBQUEsR0FBQW1GLEtBQUEsQ0FBQXBGLE1BQUEsRUFBQUMsQ0FBQSxVQUFBb0YsVUFBQSxHQUFBRCxLQUFBLENBQUFuRixDQUFBLEdBQUFvRixVQUFBLENBQUFySyxVQUFBLEdBQUFxSyxVQUFBLENBQUFySyxVQUFBLFdBQUFxSyxVQUFBLENBQUFwSyxZQUFBLHdCQUFBb0ssVUFBQSxFQUFBQSxVQUFBLENBQUFuSyxRQUFBLFNBQUFoQixNQUFBLENBQUFHLGNBQUEsQ0FBQThLLE1BQUEsRUFBQUcsY0FBQSxDQUFBRCxVQUFBLENBQUEvSyxHQUFBLEdBQUErSyxVQUFBO0FBQUEsU0FBQUUsYUFBQU4sV0FBQSxFQUFBTyxVQUFBLEVBQUFDLFdBQUEsUUFBQUQsVUFBQSxFQUFBTixpQkFBQSxDQUFBRCxXQUFBLENBQUFuTCxTQUFBLEVBQUEwTCxVQUFBLE9BQUFDLFdBQUEsRUFBQVAsaUJBQUEsQ0FBQUQsV0FBQSxFQUFBUSxXQUFBLEdBQUF2TCxNQUFBLENBQUFHLGNBQUEsQ0FBQTRLLFdBQUEsaUJBQUEvSixRQUFBLG1CQUFBK0osV0FBQTtBQUFBLFNBQUFLLGVBQUFwSixHQUFBLFFBQUE1QixHQUFBLEdBQUFvTCxZQUFBLENBQUF4SixHQUFBLG9CQUFBekMsT0FBQSxDQUFBYSxHQUFBLGlCQUFBQSxHQUFBLEdBQUFxTCxNQUFBLENBQUFyTCxHQUFBO0FBQUEsU0FBQW9MLGFBQUFFLEtBQUEsRUFBQUMsSUFBQSxRQUFBcE0sT0FBQSxDQUFBbU0sS0FBQSxrQkFBQUEsS0FBQSxrQkFBQUEsS0FBQSxNQUFBRSxJQUFBLEdBQUFGLEtBQUEsQ0FBQWpNLE1BQUEsQ0FBQW9NLFdBQUEsT0FBQUQsSUFBQSxLQUFBbkgsU0FBQSxRQUFBcUgsR0FBQSxHQUFBRixJQUFBLENBQUExSixJQUFBLENBQUF3SixLQUFBLEVBQUFDLElBQUEsb0JBQUFwTSxPQUFBLENBQUF1TSxHQUFBLHVCQUFBQSxHQUFBLFlBQUFwSCxTQUFBLDREQUFBaUgsSUFBQSxnQkFBQUYsTUFBQSxHQUFBTSxNQUFBLEVBQUFMLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7Ozs7OztBQVFBLElBQUFNLE9BQUEsR0FBQUMsZUFBQSxDQUFBQyxtQkFBQTtBQUVBLElBQUFDLHNCQUFBLEdBQUFELG1CQUFBO0FBRUEsSUFBQUUsZ0JBQUEsR0FBQUgsZUFBQSxDQUFBQyxtQkFBQTtBQUVBO0FBQUEsSUFDcUJHLFFBQVE7RUFFekIsU0FBQUEsU0FBWUMsb0JBQW9CO0lBQUEsSUFBQUMsS0FBQTtJQUFBMUIsZUFBQSxPQUFBd0IsUUFBQTtJQU14QixLQUFBRyxZQUFZLEdBQUcsQ0FBQztJQUNoQixLQUFBQyxpQkFBaUIsR0FBRyxDQUFDO0lBRXJCLEtBQUFDLGVBQWUsR0FBRyxJQUFJQyxHQUFHLEVBQUU7SUFFM0IsS0FBQUMsZUFBZSxHQUFHLElBQUlELEdBQUcsRUFBRTtJQUUzQixLQUFBRSxjQUFjLEdBQUc7TUFFckJDLG9CQUFvQixFQUFDLElBQUlILEdBQUcsRUFBRTtNQUM5QkksWUFBWSxFQUFFLElBQUlKLEdBQUcsRUFBRTtNQUN2QkssbUJBQW1CLEVBQUMsSUFBSTtNQUN4QkMsd0JBQXdCLEVBQUMsSUFBSTtNQUM3QkMsb0JBQW9CLEVBQUUsSUFBSUMsR0FBRyxFQUFFO01BRS9CQyxZQUFZLEVBQUMsSUFBSSxDQUFFO0tBRXRCOztJQThCTyxLQUFBQyxTQUFTLEdBQUcsVUFBQ0MsVUFBVSxFQUFJO01BQy9CLElBQU1DLE1BQU0sR0FBRztRQUVYO1FBQ0EsSUFBSUMsZ0JBQWdCQSxDQUFBO1VBQ2hCLE9BQU8sSUFBSSxDQUFDQyxtQkFBbUIsRUFBRTtRQUNyQyxDQUFDO1FBQ0RBLG1CQUFtQixFQUFDLFNBQUFBLG9CQUFBLEVBQUs7VUFDckIsT0FBUWxCLEtBQUksQ0FBQ0ssZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQyxDQUFDRSxnQkFBZ0I7UUFDakUsQ0FBQztRQUNELElBQUlHLE9BQU9BLENBQUE7VUFDUCxPQUFPLElBQUksQ0FBQ0MsVUFBVSxFQUFFO1FBQzVCLENBQUM7UUFDREEsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBSztVQUNaLE9BQVFyQixLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUMsQ0FBQ0ssT0FBTztRQUN4RCxDQUFDO1FBQ0RqQixlQUFlLEVBQUNILEtBQUksQ0FBQ0csZUFBZTtRQUNwQyxJQUFJbUIsWUFBWUEsQ0FBQTtVQUNaLE9BQU8sSUFBSSxDQUFDQyxlQUFlLEVBQUU7UUFDakMsQ0FBQztRQUNEQSxlQUFlLEVBQUMsU0FBQUEsZ0JBQUEsRUFBSztVQUNqQixPQUFPdkIsS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNPLFlBQVk7UUFDNUQsQ0FBQztRQUNELElBQUlaLHdCQUF3QkEsQ0FBQ2xMLEVBQUU7VUFDM0IsSUFBSSxDQUFDZ00sMkJBQTJCLENBQUNoTSxFQUFFLENBQUM7UUFDeEMsQ0FBQztRQUNEZ00sMkJBQTJCLEVBQUMsU0FBQUEsNEJBQUNoTSxFQUFFLEVBQUk7VUFDL0J3SyxLQUFJLENBQUNNLGNBQWMsQ0FBQ0ksd0JBQXdCLEdBQUdsTCxFQUFFO1FBQ3JELENBQUM7UUFDRCxJQUFJaU0sZ0JBQWdCQSxDQUFDQyxLQUFLO1VBQ3RCLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNELEtBQUssQ0FBQztRQUNuQyxDQUFDO1FBQ0RDLG1CQUFtQixFQUFDLFNBQUFBLG9CQUFDRCxLQUFLLEVBQUk7VUFDMUIxQixLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUMsQ0FBQ1UsZ0JBQWdCLEdBQUdDLEtBQUs7UUFDakUsQ0FBQztRQUNELElBQUlFLGlDQUFpQ0EsQ0FBQ0MsSUFBSTtVQUN0QyxJQUFJLENBQUNDLG9DQUFvQyxDQUFDRCxJQUFJLENBQUM7UUFDbkQsQ0FBQztRQUNEQyxvQ0FBb0MsRUFBQyxTQUFBQSxxQ0FBQ0QsSUFBSSxFQUFJO1VBQzFDN0IsS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNhLGlDQUFpQyxHQUFHQyxJQUFJO1FBQ2pGLENBQUM7UUFDRCxJQUFJdEQsUUFBUUEsQ0FBQTtVQUNSLE9BQU8sSUFBSSxDQUFDd0QsV0FBVyxFQUFFO1FBQzdCLENBQUM7UUFDREEsV0FBVyxFQUFDLFNBQUFBLFlBQUEsRUFBSztVQUNiLE9BQU8vQixLQUFJO1FBQ2YsQ0FBQztRQUVEO1FBQ0FnQyxrQkFBa0IsRUFBQyxTQUFBQSxtQkFBQ1osT0FBTyxFQUFJO1VBQzNCLE9BQU9wQixLQUFJLENBQUNnQyxrQkFBa0IsQ0FBQ2pCLFVBQVUsRUFBRUssT0FBTyxDQUFDO1FBQ3ZELENBQUM7UUFDRGEsbUJBQW1CLEVBQUMsU0FBQUEsb0JBQUEsRUFBSztVQUNyQixPQUFPakMsS0FBSSxDQUFDaUMsbUJBQW1CLEVBQUU7UUFDckMsQ0FBQztRQUNEQyxpQkFBaUIsRUFBQyxTQUFBQSxrQkFBQSxFQUFLO1VBQ25CLE9BQU9sQyxLQUFJLENBQUNrQyxpQkFBaUIsRUFBRTtRQUNuQyxDQUFDO1FBQ0RDLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQUs7VUFDWixPQUFPbkMsS0FBSSxDQUFDbUMsVUFBVSxDQUFDcEIsVUFBVSxDQUFDO1FBQ3RDLENBQUM7UUFDRHFCLG1CQUFtQixFQUFDLFNBQUFBLG9CQUFDQyxXQUFXLEVBQUVDLGtCQUFrQixFQUFFQyxzQkFBc0IsRUFBSTtVQUM1RSxPQUFPdkMsS0FBSSxDQUFDb0MsbUJBQW1CLENBQUNyQixVQUFVLEVBQUVzQixXQUFXLEVBQUVDLGtCQUFrQixFQUFFQyxzQkFBc0IsQ0FBQztRQUN4RyxDQUFDO1FBQ0RDLGtCQUFrQixFQUFDLFNBQUFBLG1CQUFDQyxlQUFlLEVBQUVILGtCQUFrQixFQUFJO1VBQ3ZELE9BQU90QyxLQUFJLENBQUN3QyxrQkFBa0IsQ0FBQ3pCLFVBQVUsRUFBRTBCLGVBQWUsRUFBRUgsa0JBQWtCLENBQUM7UUFDbkYsQ0FBQztRQUNESSxjQUFjLEVBQUMsU0FBQUEsZUFBQ0MsUUFBUSxFQUFFRixlQUFlLEVBQUVILGtCQUFrQixFQUFJO1VBQzdELE9BQU90QyxLQUFJLENBQUMwQyxjQUFjLENBQUMzQixVQUFVLEVBQUU0QixRQUFRLEVBQUVGLGVBQWUsRUFBRUgsa0JBQWtCLENBQUM7UUFDekYsQ0FBQztRQUNETSwwQkFBMEIsRUFBQyxTQUFBQSwyQkFBQ0QsUUFBUSxFQUFFRSxnQkFBZ0IsRUFBRUMsa0JBQWtCLEVBQUk7VUFDMUUsT0FBTzlDLEtBQUksQ0FBQzRDLDBCQUEwQixDQUFDN0IsVUFBVSxFQUFFNEIsUUFBUSxFQUFFRSxnQkFBZ0IsRUFBRUMsa0JBQWtCLENBQUM7UUFDdEcsQ0FBQztRQUNEQyxPQUFPLEVBQUMsU0FBQUEsUUFBQ0MsYUFBYSxFQUFFQyxzQkFBc0IsRUFBSTtVQUM5QyxPQUFPakQsS0FBSSxDQUFDK0MsT0FBTyxDQUFDaEMsVUFBVSxFQUFFaUMsYUFBYSxFQUFFQyxzQkFBc0IsQ0FBQztRQUMxRSxDQUFDO1FBQ0RDLGdCQUFnQixFQUFDLFNBQUFBLGlCQUFBLEVBQUs7VUFDbEIsT0FBT2xELEtBQUksQ0FBQ2tELGdCQUFnQixDQUFDbkMsVUFBVSxDQUFDO1FBQzVDLENBQUM7UUFDRG9DLGlCQUFpQixFQUFDLFNBQUFBLGtCQUFDVixlQUFlLEVBQUk7VUFDbEMsT0FBT3pDLEtBQUksQ0FBQ21ELGlCQUFpQixDQUFDcEMsVUFBVSxFQUFFMEIsZUFBZSxDQUFDO1FBQzlELENBQUM7UUFDRFcsZUFBZSxFQUFDLFNBQUFBLGdCQUFBLEVBQUs7VUFDakIsT0FBT3BELEtBQUksQ0FBQ29ELGVBQWUsQ0FBQ3JDLFVBQVUsQ0FBQztRQUMzQyxDQUFDO1FBQ0RzQyxTQUFTLEVBQUMsU0FBQUEsVUFBQ0MsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBSztVQUNuRCxPQUFPeEQsS0FBSSxDQUFDcUQsU0FBUyxDQUFDdEMsVUFBVSxFQUFFdUMsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsQ0FBQztRQUM5RSxDQUFDO1FBQ0RDLGlCQUFpQixFQUFDLFNBQUFBLGtCQUFDQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUs7VUFDekQsT0FBTzdELEtBQUksQ0FBQ3lELGlCQUFpQixDQUFDMUMsVUFBVSxFQUFFMkMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxDQUFFO1FBQ3JGLENBQUM7UUFDREMscUJBQXFCLEVBQUMsU0FBQUEsc0JBQUNKLEtBQUssRUFBSTtVQUM1QixPQUFPMUQsS0FBSSxDQUFDOEQscUJBQXFCLENBQUMvQyxVQUFVLEVBQUUyQyxLQUFLLENBQUM7UUFDeEQsQ0FBQztRQUNESyx1QkFBdUIsRUFBQyxTQUFBQSx3QkFBQ0wsS0FBSyxFQUFJO1VBQzlCLE9BQU8xRCxLQUFJLENBQUMrRCx1QkFBdUIsQ0FBQ2hELFVBQVUsRUFBRTJDLEtBQUssQ0FBQztRQUMxRCxDQUFDO1FBQ0RNLFlBQVksRUFBQyxTQUFBQSxhQUFBLEVBQUs7VUFDZCxPQUFPaEUsS0FBSSxDQUFDZ0UsWUFBWSxFQUFFO1FBQzlCLENBQUM7UUFDREMsc0JBQXNCLEVBQUMsU0FBQUEsdUJBQUNQLEtBQUssRUFBSTtVQUM3QixPQUFPMUQsS0FBSSxDQUFDaUUsc0JBQXNCLENBQUNsRCxVQUFVLEVBQUUyQyxLQUFLLENBQUM7UUFDekQsQ0FBQztRQUNEUSxZQUFZLEVBQUMsU0FBQUEsYUFBQ0MsU0FBUyxFQUFFVCxLQUFLLEVBQUVVLE1BQU0sRUFBRUMsa0JBQWtCLEVBQXVCO1VBQUEsSUFBckJDLFNBQVMsR0FBQUMsU0FBQSxDQUFBaEwsTUFBQSxRQUFBZ0wsU0FBQSxRQUFBck0sU0FBQSxHQUFBcU0sU0FBQSxNQUFHLEtBQUs7VUFDekUsT0FBT3ZFLEtBQUksQ0FBQ2tFLFlBQVksQ0FBQ25ELFVBQVUsRUFBRW9ELFNBQVMsRUFBRVQsS0FBSyxFQUFFVSxNQUFNLEVBQUVDLGtCQUFrQixFQUFFQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3pHLENBQUM7UUFDREUsbUJBQW1CLEVBQUMsU0FBQUEsb0JBQUNkLEtBQUssRUFBRXBCLGtCQUFrQixFQUFJO1VBQzlDLE9BQU90QyxLQUFJLENBQUN3RSxtQkFBbUIsQ0FBQ3pELFVBQVUsRUFBRTJDLEtBQUssRUFBRXBCLGtCQUFrQixDQUFDO1FBQzFFLENBQUM7UUFDRG1DLHNDQUFzQyxFQUFDLFNBQUFBLHVDQUFBLEVBQUs7VUFDeEMsT0FBT3pFLEtBQUksQ0FBQ3lFLHNDQUFzQyxDQUFDMUQsVUFBVSxDQUFDO1FBQ2xFLENBQUM7UUFDRDJELFNBQVMsRUFBQyxTQUFBQSxVQUFDTixNQUFNLEVBQUk7VUFDakIsT0FBT3BFLEtBQUksQ0FBQzBFLFNBQVMsQ0FBQ04sTUFBTSxDQUFDO1FBQ2pDLENBQUM7UUFDRE8saUJBQWlCLEVBQUMsU0FBQUEsa0JBQUNQLE1BQU0sRUFBSTtVQUN6QixPQUFPcEUsS0FBSSxDQUFDMkUsaUJBQWlCLENBQUNQLE1BQU0sQ0FBQztRQUN6QztPQUNIO01BRUQsT0FBT3BELE1BQU07SUFDakIsQ0FBQztJQUVPLEtBQUFnQixrQkFBa0IsR0FBRyxVQUFDakIsVUFBVSxFQUFFSyxPQUFPLEVBQUk7TUFFakQsSUFBUWYsZUFBZSxHQUFzQkwsS0FBSSxDQUF6Q0ssZUFBZTtRQUFFRixlQUFlLEdBQUtILEtBQUksQ0FBeEJHLGVBQWU7TUFFeEMsSUFBS0UsZUFBZSxDQUFDdUUsSUFBSSxJQUFJLENBQUMsRUFBRyxPQUFNLENBQUM7TUFFeEM7TUFFQXZFLGVBQWUsVUFBTyxDQUFDVSxVQUFVLENBQUM7TUFDbENLLE9BQU8sQ0FBQzlLLE9BQU8sQ0FBQyxVQUFDOE4sTUFBTSxFQUFJO1FBQ3ZCLElBQUFTLG9CQUFBLEdBQXdCMUUsZUFBZSxDQUFDZ0IsR0FBRyxDQUFDaUQsTUFBTSxDQUFDO1VBQTNDVSxXQUFXLEdBQUFELG9CQUFBLENBQVhDLFdBQVc7UUFDbkI5RSxLQUFJLENBQUMrRSxxQkFBcUIsQ0FBQ0QsV0FBVyxFQUFDVixNQUFNLENBQUM7UUFDOUNqRSxlQUFlLFVBQU8sQ0FBQ2lFLE1BQU0sQ0FBQztNQUNsQyxDQUFDLENBQUM7TUFDRnBFLEtBQUksQ0FBQ2tDLGlCQUFpQixFQUFFO01BQ3hCO0lBRUosQ0FBQztJQUVEO0lBRUE7SUFFUSxLQUFBRCxtQkFBbUIsR0FBRyxZQUFLO01BRS9CakMsS0FBSSxDQUFDTSxjQUFjLENBQUNHLG1CQUFtQixHQUFHOUQsS0FBSyxDQUFDdUIsSUFBSSxDQUFDOEIsS0FBSSxDQUFDTSxjQUFjLENBQUNFLFlBQVksQ0FBQ3JLLE1BQU0sRUFBRSxDQUFDO01BRS9GNkosS0FBSSxDQUFDTSxjQUFjLENBQUNJLHdCQUF3QixDQUFDVixLQUFJLENBQUNNLGNBQWMsQ0FBQ0csbUJBQW1CLENBQUM7SUFFekYsQ0FBQztJQUVPLEtBQUF1RSxZQUFZLEdBQUcsWUFBSztNQUV4QixJQUFNRixXQUFXLEdBQUc5RSxLQUFJLENBQUNFLGlCQUFpQixFQUFFO01BQzVDRixLQUFJLENBQUNNLGNBQWMsQ0FBQ0Msb0JBQW9CLENBQUMwRSxHQUFHLENBQUNILFdBQVcsRUFDcEQ7UUFDSUksU0FBUyxFQUFDLElBQUk5RSxHQUFHLEVBQUU7UUFDbkIrRSxRQUFRLEVBQUMsQ0FBQztRQUNWQyxnQkFBZ0IsRUFBQyxJQUFJO1FBQ3JCQyxRQUFRLEVBQUMsS0FBSztRQUNkQyxXQUFXLEVBQUMsSUFBSTtRQUNoQlIsV0FBVyxFQUFYQTtPQUNILENBQUM7TUFFTixJQUFNUyxXQUFXLEdBQUc7UUFDaEJDLE9BQU8sRUFBQztPQUNYO01BRUQsSUFBTUMsT0FBTyxHQUFHLElBQUl0TCxPQUFPLENBQUMsVUFBQ3ZELE9BQU8sRUFBSTtRQUNwQzJPLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHNU8sT0FBTztNQUNqQyxDQUFDLENBQUM7TUFFRixJQUFNOE8sUUFBUSxHQUFHLFNBQVhBLFFBQVFBLENBQUEsRUFBUTtRQUVsQkgsV0FBVyxDQUFDQyxPQUFPLENBQUNWLFdBQVcsQ0FBQztNQUVwQyxDQUFDO01BRUQ5RSxLQUFJLENBQUNNLGNBQWMsQ0FBQ0UsWUFBWSxDQUFDeUUsR0FBRyxDQUFDSCxXQUFXLEVBQzVDckYsT0FBQSxZQUFBa0csYUFBQSxDQUFDOUYsZ0JBQUEsV0FBYztRQUNYaE0sR0FBRyxFQUFJaVIsV0FBVztRQUNsQnhFLGNBQWMsRUFBSU4sS0FBSSxDQUFDTSxjQUFjO1FBQ3JDd0UsV0FBVyxFQUFJQSxXQUFXO1FBQzFCWSxRQUFRLEVBQUtBO01BQVEsRUFBSyxDQUFDO01BRW5DMUYsS0FBSSxDQUFDaUMsbUJBQW1CLEVBQUU7TUFFMUIsT0FBT3dELE9BQU87SUFFbEIsQ0FBQztJQWdETyxLQUFBRyxrQkFBa0IsR0FBRyxVQUFDZCxXQUFXLEVBQUVWLE1BQU0sRUFBRXlCLE1BQU0sRUFBSTtNQUV6RCxJQUFNQyxpQkFBaUIsR0FBRzlGLEtBQUksQ0FBQ00sY0FBYyxDQUFDQyxvQkFBb0IsQ0FBQ1ksR0FBRyxDQUFDMkQsV0FBVyxDQUFDO01BRW5GZ0IsaUJBQWlCLENBQUNaLFNBQVMsQ0FBQ0QsR0FBRyxDQUFDYixNQUFNLEVBQUN5QixNQUFNLENBQUM7TUFFOUM3RixLQUFJLENBQUNNLGNBQWMsQ0FBQ0ssb0JBQW9CLENBQUNvRixHQUFHLENBQUNqQixXQUFXLENBQUM7SUFFN0QsQ0FBQztJQUVPLEtBQUFDLHFCQUFxQixHQUFHLFVBQUNELFdBQVcsRUFBRVYsTUFBTSxFQUFJO01BRXBELElBQU0wQixpQkFBaUIsR0FBRzlGLEtBQUksQ0FBQ00sY0FBYyxDQUFDQyxvQkFBb0IsQ0FBQ1ksR0FBRyxDQUFDMkQsV0FBVyxDQUFDO01BRW5GZ0IsaUJBQWlCLENBQUNaLFNBQVMsVUFBTyxDQUFDZCxNQUFNLENBQUM7TUFDMUMwQixpQkFBaUIsQ0FBQ1gsUUFBUSxJQUFJLENBQUM7TUFFL0JuRixLQUFJLENBQUNNLGNBQWMsQ0FBQ0ssb0JBQW9CLENBQUNvRixHQUFHLENBQUNqQixXQUFXLENBQUM7SUFFN0QsQ0FBQztJQUVPLEtBQUFrQixlQUFlLEdBQUcsVUFBQ2xCLFdBQVcsRUFBSTtNQUV0QyxJQUFNZ0IsaUJBQWlCLEdBQUc5RixLQUFJLENBQUNNLGNBQWMsQ0FBQ0Msb0JBQW9CLENBQUNZLEdBQUcsQ0FBQzJELFdBQVcsQ0FBQztNQUVuRixJQUFJLENBQUNnQixpQkFBaUIsRUFBRTtNQUV4QkEsaUJBQWlCLENBQUNWLGdCQUFnQixHQUFJekksS0FBSyxDQUFDdUIsSUFBSSxDQUFDNEgsaUJBQWlCLENBQUNaLFNBQVMsQ0FBQy9PLE1BQU0sRUFBRSxDQUFDO01BRXRGO01BQ0EyUCxpQkFBaUIsQ0FBQ1IsV0FBVyxJQUFJUSxpQkFBaUIsQ0FBQ1IsV0FBVyxDQUFDUSxpQkFBaUIsQ0FBQ1YsZ0JBQWdCLENBQUM7SUFFdEcsQ0FBQztJQUVEO0lBQ1EsS0FBQWxELGlCQUFpQixHQUFHLFlBQUs7TUFFN0IsSUFBUXZCLG9CQUFvQixHQUFLWCxLQUFJLENBQUNNLGNBQWMsQ0FBNUNLLG9CQUFvQjtNQUU1QixJQUFJQSxvQkFBb0IsQ0FBQ2lFLElBQUksRUFBRTtRQUUzQmpFLG9CQUFvQixDQUFDckssT0FBTyxDQUFDLFVBQUN3TyxXQUFXLEVBQUk7VUFFekM5RSxLQUFJLENBQUNnRyxlQUFlLENBQUNsQixXQUFXLENBQUM7UUFFckMsQ0FBQyxDQUFDO1FBRUY5RSxLQUFJLENBQUNNLGNBQWMsQ0FBQ0ssb0JBQW9CLENBQUNzRixLQUFLLEVBQUU7O0lBSXhELENBQUM7SUFFTyxLQUFBOUQsVUFBVSxHQUFHLFVBQUNwQixVQUFVLEVBQUk7TUFFaEMsSUFBUVYsZUFBZSxHQUFzQkwsS0FBSSxDQUF6Q0ssZUFBZTtRQUFFRixlQUFlLEdBQUtILEtBQUksQ0FBeEJHLGVBQWU7TUFDeEMsSUFBTStGLE9BQU8sR0FBRzdGLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7TUFDL0MsSUFBT0UsZ0JBQWdCLEdBQTJCaUYsT0FBTyxDQUFsRGpGLGdCQUFnQjtRQUFFRyxPQUFPLEdBQWtCOEUsT0FBTyxDQUFoQzlFLE9BQU87UUFBRUUsWUFBWSxHQUFJNEUsT0FBTyxDQUF2QjVFLFlBQVk7TUFFOUMsSUFBSWpCLGVBQWUsQ0FBQ3VFLElBQUksSUFBSSxDQUFDLEVBQUU7UUFFM0I7UUFDQXpFLGVBQWUsQ0FBQzhGLEtBQUssRUFBRTtRQUV2QjtRQUNBakcsS0FBSSxDQUFDTSxjQUFjLENBQUNDLG9CQUFvQixDQUFDMEYsS0FBSyxFQUFFO1FBQ2hEakcsS0FBSSxDQUFDTSxjQUFjLENBQUNFLFlBQVksQ0FBQ3lGLEtBQUssRUFBRTtRQUN4Q2pHLEtBQUksQ0FBQ00sY0FBYyxDQUFDRyxtQkFBbUIsR0FBRyxFQUFFO1FBQzVDVCxLQUFJLENBQUNNLGNBQWMsQ0FBQ0ssb0JBQW9CLENBQUNzRixLQUFLLEVBQUU7UUFDaERqRyxLQUFJLENBQUNNLGNBQWMsQ0FBQ08sWUFBWSxHQUFHLElBQUk7UUFDdkNiLEtBQUksQ0FBQ00sY0FBYyxDQUFDSSx3QkFBd0IsQ0FBQyxJQUFJLENBQUM7T0FFckQsTUFBTTtRQUVIVSxPQUFPLENBQUM5SyxPQUFPLENBQUMsVUFBQzhOLE1BQU0sRUFBSTtVQUN2QixJQUFBK0IscUJBQUEsR0FBd0JoRyxlQUFlLENBQUNnQixHQUFHLENBQUNpRCxNQUFNLENBQUM7WUFBM0NVLFdBQVcsR0FBQXFCLHFCQUFBLENBQVhyQixXQUFXO1VBQ25COUUsS0FBSSxDQUFDK0UscUJBQXFCLENBQUNELFdBQVcsRUFBQ1YsTUFBTSxDQUFDO1FBQ2xELENBQUMsQ0FBQztRQUNGcEUsS0FBSSxDQUFDa0MsaUJBQWlCLEVBQUU7O01BSTVCakIsZ0JBQWdCLENBQUNnRixLQUFLLEVBQUU7TUFDeEI3RSxPQUFPLENBQUM2RSxLQUFLLEVBQUU7TUFDZjNFLFlBQVksQ0FBQzJFLEtBQUssRUFBRTtJQUV4QixDQUFDO0lBRUQ7SUFFQTtJQUVBO0lBQ1EsS0FBQTdELG1CQUFtQixHQUFHLFVBQUNyQixVQUFVLEVBQUVzQixXQUFXLEVBQUVDLGtCQUFrQixFQUFFQyxzQkFBc0IsRUFBSTtNQUVsRztNQUNBLElBQU02RCxjQUFjLEdBQXNCcEcsS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNFLGdCQUFnQjtNQUMvRixJQUFNb0YsV0FBVyxHQUFHMUosS0FBSyxDQUFDdUIsSUFBSSxDQUFDa0ksY0FBYyxDQUFDL0wsSUFBSSxFQUFFLENBQUM7TUFDckRnTSxXQUFXLENBQUNDLElBQUksQ0FBQyxVQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBQSxPQUFLRCxDQUFDLEdBQUdDLENBQUM7TUFBQSxFQUFDO01BRWhDLElBQU1DLFlBQVksR0FBR0osV0FBVyxDQUFDSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFFdkMsSUFBSUQsWUFBWSxHQUFJcEUsV0FBVyxHQUFFLENBQUUsRUFBRTtRQUFFO1FBRW5DLElBQU1zRSxRQUFRLEdBQUdOLFdBQVcsQ0FBQ08sTUFBTSxDQUFDLFVBQUNsRCxLQUFLLEVBQUc7VUFDekMsT0FBT0EsS0FBSyxHQUFJckIsV0FBVyxHQUFFLENBQUU7UUFDbkMsQ0FBQyxDQUFDO1FBRUZyQyxLQUFJLENBQUN3RSxtQkFBbUIsQ0FBQ3pELFVBQVUsRUFBRTRGLFFBQVEsRUFBRXJFLGtCQUFrQixDQUFDOztNQUl0RUMsc0JBQXNCLElBQUlBLHNCQUFzQixDQUFDRixXQUFXLENBQUM7SUFFakUsQ0FBQztJQUVEO0lBRVEsS0FBQUcsa0JBQWtCLEdBQUcsVUFBQ3pCLFVBQVUsRUFBRTBCLGVBQWUsRUFBRUgsa0JBQWtCLEVBQUk7TUFFN0UsSUFBTXVFLE9BQU8sR0FBR2xLLEtBQUssQ0FBQ3VCLElBQUksQ0FBQzhCLEtBQUksQ0FBQ0ssZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQyxDQUFDRSxnQkFBZ0IsQ0FBQzVHLElBQUksRUFBRSxDQUFDO01BRXhGLElBQU15TSxPQUFPLEdBQUdELE9BQU8sQ0FBQ0QsTUFBTSxDQUFDLFVBQUEvUyxHQUFHO1FBQUEsT0FBSSxDQUFDNE8sZUFBZSxDQUFDc0UsUUFBUSxDQUFDbFQsR0FBRyxDQUFDO01BQUEsRUFBQztNQUVyRSxJQUFJaVQsT0FBTyxDQUFDdk4sTUFBTSxFQUFFO1FBRWhCeUcsS0FBSSxDQUFDd0UsbUJBQW1CLENBQUN6RCxVQUFVLEVBQUUrRixPQUFPLEVBQUV4RSxrQkFBa0IsQ0FBQztRQUNqRSxPQUFPLElBQUk7T0FFZCxNQUFNO1FBRUgsT0FBTyxLQUFLOztJQUlwQixDQUFDO0lBRU8sS0FBQUksY0FBYyxHQUFHLFVBQUMzQixVQUFVLEVBQUU0QixRQUFRLEVBQUVGLGVBQWUsRUFBRUgsa0JBQWtCLEVBQUk7TUFFbkYsSUFBTTBFLFdBQVcsR0FBR3ZFLGVBQWUsQ0FBQ2xKLE1BQU07TUFFMUM7TUFDQSxJQUFLLENBQUNvSixRQUFRLElBQU0sQ0FBQ3FFLFdBQVksRUFBRSxPQUFPLEtBQUs7TUFFL0MsSUFBTUMsR0FBRyxHQUFHQyxJQUFJLENBQUNELEdBQUcsQ0FBQ0QsV0FBVyxFQUFFckUsUUFBUSxDQUFDO01BRTNDLElBQU15RCxjQUFjLEdBQXVCcEcsS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNFLGdCQUFnQjtRQUM1RkssWUFBWSxHQUFldEIsS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNPLFlBQVk7TUFFaEYsSUFBSzhFLGNBQWMsQ0FBQ3hCLElBQUksR0FBR3RELFlBQVksQ0FBQ3NELElBQUksSUFBS3FDLEdBQUcsRUFBRSxPQUFPLEtBQUs7TUFFbEU7TUFDQSxJQUFNRSxXQUFXLEdBQUd4SyxLQUFLLENBQUN1QixJQUFJLENBQUNrSSxjQUFjLENBQUMvTCxJQUFJLEVBQUUsQ0FBQztRQUNqRCtNLGFBQWEsR0FBR3pLLEtBQUssQ0FBQ3VCLElBQUksQ0FBQ29ELFlBQVksQ0FBQ2pILElBQUksRUFBRSxDQUFDO01BRW5ELElBQU13TSxPQUFPLE1BQUFRLE1BQUEsQ0FBT0YsV0FBVyxFQUFJQyxhQUFhLENBQUM7TUFFakRQLE9BQU8sQ0FBQ1AsSUFBSSxDQUFDLFVBQUNDLENBQUMsRUFBQ0MsQ0FBQztRQUFBLE9BQUtELENBQUMsR0FBR0MsQ0FBQztNQUFBLEVBQUM7TUFFNUI7TUFDQSxJQUFNYyxTQUFTLEdBQUdULE9BQU8sQ0FBQ3ROLE1BQU07UUFDNUJnTyxTQUFTLEdBQUdELFNBQVMsR0FBR0wsR0FBRztNQUUvQjtNQUNBLElBQU1PLFNBQVMsR0FBRy9FLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDaENnRixTQUFTLEdBQUdoRixlQUFlLENBQUN1RSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQzVDVSxPQUFPLEdBQUdiLE9BQU8sQ0FBQ2MsT0FBTyxDQUFDSCxTQUFTLENBQUM7UUFDcENJLE9BQU8sR0FBR2YsT0FBTyxDQUFDYyxPQUFPLENBQUNGLFNBQVMsQ0FBQztNQUV4QyxJQUFNSSxRQUFRLEdBQUdILE9BQU87UUFDcEJJLFFBQVEsR0FBR1IsU0FBUyxJQUFJTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDRyxRQUFRLEdBQUdGLFFBQVEsR0FBR0MsUUFBUTtNQUVsQyxJQUFNRSxhQUFhLEdBQUdkLElBQUksQ0FBQ2UsS0FBSyxDQUFFSixRQUFRLEdBQUNFLFFBQVEsR0FBRVIsU0FBUyxDQUFDO1FBQzNEVyxhQUFhLEdBQUdYLFNBQVMsR0FBR1MsYUFBYTtNQUU3QztNQUNBLElBQU1HLFFBQVEsR0FBR3RCLE9BQU8sQ0FBQ2hNLEtBQUssQ0FBQyxDQUFDLEVBQUNtTixhQUFhLENBQUM7UUFDM0NJLFFBQVEsR0FBR3ZCLE9BQU8sQ0FBQ2hNLEtBQUssQ0FBQ3lNLFNBQVMsR0FBR1ksYUFBYSxDQUFDO01BRXZELElBQU1HLE9BQU8sTUFBQWhCLE1BQUEsQ0FBQTFKLGtCQUFBLENBQU93SyxRQUFRLEdBQUF4SyxrQkFBQSxDQUFJeUssUUFBUSxFQUFDO01BRXpDcEksS0FBSSxDQUFDd0UsbUJBQW1CLENBQUN6RCxVQUFVLEVBQUVzSCxPQUFPLEVBQUUvRixrQkFBa0IsQ0FBQztNQUVqRSxPQUFPLElBQUk7SUFFZixDQUFDO0lBRU8sS0FBQU0sMEJBQTBCLEdBQUcsVUFBQzdCLFVBQVUsRUFBRTRCLFFBQVEsRUFBRUUsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFJO01BRWhHLElBQUksQ0FBQ0gsUUFBUSxFQUFFLE9BQU8sS0FBSztNQUUzQixJQUFBMkYscUJBQUEsR0FBMkN0SSxLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7UUFBdkVFLGdCQUFnQixHQUFBcUgscUJBQUEsQ0FBaEJySCxnQkFBZ0I7UUFBRUssWUFBWSxHQUFBZ0gscUJBQUEsQ0FBWmhILFlBQVk7TUFFdEMsSUFBTTJGLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQUNwRSxnQkFBZ0IsRUFBRUYsUUFBUSxDQUFDO01BRWhELElBQUsxQixnQkFBZ0IsQ0FBQzJELElBQUksR0FBR3RELFlBQVksQ0FBQ3NELElBQUksSUFBT3FDLEdBQUcsR0FBSW5FLGtCQUFtQixFQUFFO1FBRTdFLE9BQU8sS0FBSztPQUVmLE1BQU07UUFFSCxPQUFPLElBQUk7O0lBSW5CLENBQUM7SUFFRDtJQUVRLEtBQUFDLE9BQU8sR0FBRyxVQUFDaEMsVUFBVSxFQUFFaUMsYUFBYSxFQUFFQyxzQkFBc0IsRUFBSTtNQUVwRSxJQUFBc0Ysc0JBQUEsR0FBNkJ2SSxLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7UUFBekRVLGdCQUFnQixHQUFBOEcsc0JBQUEsQ0FBaEI5RyxnQkFBZ0I7TUFFeEIsSUFBUStHLHFCQUFxQixHQUFLL0csZ0JBQWdCLENBQTFDK0cscUJBQXFCO01BRTdCLElBQUFDLHFCQUFBLEdBQXlDaEgsZ0JBQWdCLENBQUNpSCxXQUFXLENBQUNsRCxPQUFPO1FBQXJFbUQsWUFBWSxHQUFBRixxQkFBQSxDQUFaRSxZQUFZO1FBQUVDLGNBQWMsR0FBQUgscUJBQUEsQ0FBZEcsY0FBYztRQUNoQ0MseUJBQXlCLEdBQUdwSCxnQkFBZ0IsQ0FBQ3FILDRCQUE0QixDQUFDdEQsT0FBTztRQUNqRnVELHdCQUF3QixHQUFHdEgsZ0JBQWdCLENBQUN1SCwyQkFBMkIsQ0FBQ3hELE9BQU87TUFFbkYsSUFBUXlELE9BQU8sR0FBZUoseUJBQXlCLENBQS9DSSxPQUFPO1FBQUV0RyxRQUFRLEdBQUtrRyx5QkFBeUIsQ0FBdENsRyxRQUFRO1FBQ3JCa0IsUUFBUSxHQUFHa0Ysd0JBQXdCLENBQUNHLHFCQUFxQixDQUFDdEUsSUFBSTtNQUVsRSxJQUFNdUUsUUFBUSxHQUFHLEVBQUU7TUFFbkIsSUFBSUMsU0FBUyxHQUFHekcsUUFBUSxhQUFSQSxRQUFRLGNBQVJBLFFBQVEsR0FBSSxDQUFDO01BRTdCeUcsU0FBUyxHQUFHbEMsSUFBSSxDQUFDbUMsR0FBRyxDQUFDRCxTQUFTLEVBQUV2RixRQUFRLENBQUM7TUFFekMsSUFBTXlGLFdBQVcsR0FDYkYsU0FBUyxHQUNMQSxTQUFTLEdBQ1R2RixRQUFRO01BRWhCLElBQU0wRixTQUFTLEdBQUc7UUFDZC9ELE9BQU8sRUFBQztPQUNYO01BRUQsSUFBTWdFLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBb0JBLENBQUk5RixLQUFLLEVBQUk7UUFDbkM2RixTQUFTLENBQUMvRCxPQUFPLEdBQUcsSUFBSTtRQUN4QnZDLHNCQUFzQixDQUFDUyxLQUFLLENBQUM7TUFDakMsQ0FBQztNQUVELElBQUlpRixZQUFZLENBQUNjLFlBQVksQ0FBQ2pFLE9BQU8sRUFBRTtRQUVuQyxJQUFNdkUsZ0JBQWdCLEdBQUdqQixLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUMsQ0FBQ0UsZ0JBQWdCO1FBRTlFLElBQUF5SSxxQkFBQSxHQUF3RGQsY0FBYyxDQUFDZSxTQUFTO1VBQXhFQyxvQkFBb0IsR0FBQUYscUJBQUEsQ0FBcEJFLG9CQUFvQjtVQUFFQyxxQkFBcUIsR0FBQUgscUJBQUEsQ0FBckJHLHFCQUFxQjtRQUVuRCxLQUFLLElBQUluRyxLQUFLLEdBQUcsQ0FBQyxFQUFFQSxLQUFLLEdBQUc0RixXQUFXLEVBQUU1RixLQUFLLEVBQUUsRUFBRTtVQUU5Q2tHLG9CQUFvQixJQUFJQSxvQkFBb0IsQ0FBQ2xHLEtBQUssQ0FBQztVQUNuRCxJQUFJLENBQUN6QyxnQkFBZ0IsQ0FBQzZJLEdBQUcsQ0FBQ3BHLEtBQUssQ0FBQyxFQUFFO1lBRTlCLElBQU0rQixPQUFPLEdBQUd6RixLQUFJLENBQUMrSixXQUFXLENBQzVCaEosVUFBVSxFQUNWMkMsS0FBSyxFQUNMdUYsT0FBTyxFQUNQVCxxQkFBcUIsRUFDckJxQixxQkFBcUIsRUFDckJMLG9CQUFvQixDQUN2QjtZQUNETCxRQUFRLENBQUNuUSxJQUFJLENBQUN5TSxPQUFPLENBQUM7O1VBSTFCLElBQUk4RCxTQUFTLENBQUMvRCxPQUFPLEVBQUU7OztNQUkvQnJMLE9BQU8sQ0FBQzZQLFVBQVUsQ0FBQ2IsUUFBUSxDQUFDLENBQUNsUyxJQUFJLENBQzdCLFlBQUk7UUFDQStJLEtBQUksQ0FBQ2tDLGlCQUFpQixFQUFFO1FBQ3hCYyxhQUFhLEVBQUU7TUFDbkIsQ0FBQyxDQUNKO0lBRUwsQ0FBQztJQXFvQk8sS0FBQXlCLHNDQUFzQyxHQUFHLFVBQUMxRCxVQUFVLEVBQUk7TUFFNUQsSUFBQWtKLHNCQUFBLEdBQThDakssS0FBSSxDQUFDSyxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDO1FBQTFFYSxpQ0FBaUMsR0FBQXFJLHNCQUFBLENBQWpDckksaUNBQWlDO01BRXpDLElBQUlBLGlDQUFpQyxJQUFJQSxpQ0FBaUMsQ0FBQ3JJLE1BQU0sRUFBRTtRQUFBLElBQUEyUSxTQUFBLEdBQUFyTiwwQkFBQSxDQUU1RCtFLGlDQUFpQztVQUFBdUksS0FBQTtRQUFBO1VBQXBELEtBQUFELFNBQUEsQ0FBQWhOLENBQUEsTUFBQWlOLEtBQUEsR0FBQUQsU0FBQSxDQUFBL00sQ0FBQSxJQUFBbkYsSUFBQSxHQUFzRDtZQUFBLElBQTNDb1MsSUFBSSxHQUFBRCxLQUFBLENBQUFwVyxLQUFBO1lBRVhpTSxLQUFJLENBQUMrRSxxQkFBcUIsQ0FBQ3FGLElBQUksQ0FBQ3RGLFdBQVcsRUFBRXNGLElBQUksQ0FBQ2hHLE1BQU0sQ0FBQzs7UUFFNUQsU0FBQTFQLEdBQUE7VUFBQXdWLFNBQUEsQ0FBQTlNLENBQUEsQ0FBQTFJLEdBQUE7UUFBQTtVQUFBd1YsU0FBQSxDQUFBNU0sQ0FBQTtRQUFBO1FBRUQwQyxLQUFJLENBQUNLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUMsQ0FBQ2EsaUNBQWlDLEdBQUcsRUFBRTtRQUUzRTVCLEtBQUksQ0FBQ2tDLGlCQUFpQixFQUFFOztJQUloQyxDQUFDO0lBL3NDRyxJQUFJLENBQUNuQyxvQkFBb0IsR0FBR0Esb0JBQW9CO0VBRXBEO0VBdUJBO0VBQ0E7RUFDQTtFQUVBO0VBRUE7RUFBQWpCLFlBQUEsQ0FBQWdCLFFBQUE7SUFBQWpNLEdBQUE7SUFBQUUsS0FBQSxFQUNBLFNBQUFzVyxpQkFBaUJ0SixVQUFVO01BRXZCLElBQUksQ0FBQ1YsZUFBZSxDQUFDNEUsR0FBRyxDQUFDbEUsVUFBVSxFQUMvQjtRQUNJVSxnQkFBZ0IsRUFBQyxJQUFJO1FBQ3JCUixnQkFBZ0IsRUFBRSxJQUFJYixHQUFHLEVBQUU7UUFDM0I7UUFDQWdCLE9BQU8sRUFBRSxJQUFJUixHQUFHLEVBQUU7UUFDbEJVLFlBQVksRUFBQyxJQUFJVixHQUFHLEVBQUU7UUFDdEJnQixpQ0FBaUMsRUFBQztPQUNyQyxDQUNKO01BRUQ7TUFFQSxPQUFPLElBQUksQ0FBQ2QsU0FBUyxDQUFDQyxVQUFVLENBQUM7SUFFckM7RUFBQztJQUFBbE4sR0FBQTtJQUFBRSxLQUFBLEVBb01hLFNBQUF1VyxzQkFBQSxFQUFxQjs7Ozs7O2NBRXZCdkssb0JBQW9CLEdBQUssSUFBSSxDQUE3QkEsb0JBQW9CO2NBRXBCUSxvQkFBb0IsR0FBSyxJQUFJLENBQUNELGNBQWMsQ0FBNUNDLG9CQUFvQjtjQUN0Qk0sWUFBWSxHQUFLLElBQUksQ0FBQ1AsY0FBYyxDQUFwQ08sWUFBWTtjQUFBLE1BR2RBLFlBQVksS0FBSyxJQUFJO2dCQUFBMEosUUFBQSxDQUFBalMsSUFBQTtnQkFBQTtjQUFBO2NBRXJCd04saUJBQWlCLEdBQUd2RixvQkFBb0IsQ0FBQ1ksR0FBRyxDQUFDTixZQUFZLENBQUM7Y0FBQSxNQUV0RGlGLGlCQUFpQixDQUFDWCxRQUFRLEdBQUdwRixvQkFBb0I7Z0JBQUF3SyxRQUFBLENBQUFqUyxJQUFBO2dCQUFBO2NBQUE7Y0FFakR3TixpQkFBaUIsQ0FBQ1gsUUFBUSxJQUFJLENBQUM7Y0FBQSxPQUFBb0YsUUFBQSxDQUFBeFMsTUFBQSxXQUN4QjhJLFlBQVk7WUFBQTtjQU0zQkEsWUFBWSxHQUFHLElBQUk7Y0FBQTJKLFVBQUEsR0FBQTNOLDBCQUFBLENBQzRCMEQsb0JBQW9CO2NBQUFnSyxRQUFBLENBQUE1UCxJQUFBO2NBQUE2UCxVQUFBLENBQUF0TixDQUFBO1lBQUE7Y0FBQSxLQUFBdU4sTUFBQSxHQUFBRCxVQUFBLENBQUFyTixDQUFBLElBQUFuRixJQUFBO2dCQUFBdVMsUUFBQSxDQUFBalMsSUFBQTtnQkFBQTtjQUFBO2NBQUFvUyxZQUFBLEdBQUE3TyxjQUFBLENBQUE0TyxNQUFBLENBQUExVyxLQUFBLE1BQXZEK1EsV0FBVyxHQUFBNEYsWUFBQSxLQUFFNUUsa0JBQWlCLEdBQUE0RSxZQUFBO2NBQUEsTUFFbEM1RSxrQkFBaUIsQ0FBQ1gsUUFBUSxHQUFHcEYsb0JBQW9CO2dCQUFBd0ssUUFBQSxDQUFBalMsSUFBQTtnQkFBQTtjQUFBO2NBQ2pEd04sa0JBQWlCLENBQUNYLFFBQVEsSUFBSSxDQUFDO2NBQy9CdEUsWUFBWSxHQUFHaUUsV0FBVztjQUFBLE9BQUF5RixRQUFBLENBQUF4UyxNQUFBO1lBQUE7Y0FBQXdTLFFBQUEsQ0FBQWpTLElBQUE7Y0FBQTtZQUFBO2NBQUFpUyxRQUFBLENBQUFqUyxJQUFBO2NBQUE7WUFBQTtjQUFBaVMsUUFBQSxDQUFBNVAsSUFBQTtjQUFBNFAsUUFBQSxDQUFBSSxFQUFBLEdBQUFKLFFBQUE7Y0FBQUMsVUFBQSxDQUFBcE4sQ0FBQSxDQUFBbU4sUUFBQSxDQUFBSSxFQUFBO1lBQUE7Y0FBQUosUUFBQSxDQUFBNVAsSUFBQTtjQUFBNlAsVUFBQSxDQUFBbE4sQ0FBQTtjQUFBLE9BQUFpTixRQUFBLENBQUE5TyxNQUFBO1lBQUE7Y0FBQSxNQU05Qm9GLFlBQVksS0FBSyxJQUFJO2dCQUFBMEosUUFBQSxDQUFBalMsSUFBQTtnQkFBQTtjQUFBO2NBQUFpUyxRQUFBLENBQUFqUyxJQUFBO2NBRU4sT0FBTSxJQUFJLENBQUMwTSxZQUFZLEVBQUU7WUFBQTtjQUF4Q25FLFlBQVksR0FBQTBKLFFBQUEsQ0FBQTNTLElBQUE7Y0FDWmtPLGlCQUFpQixHQUFHdkYsb0JBQW9CLENBQUNZLEdBQUcsQ0FBQ04sWUFBWSxDQUFDO2NBQzFEaUYsaUJBQWlCLENBQUNYLFFBQVEsSUFBSSxDQUFDO1lBQUE7Y0FJbkMsSUFBSSxDQUFDN0UsY0FBYyxDQUFDTyxZQUFZLEdBQUdBLFlBQVk7Y0FBQSxPQUFBMEosUUFBQSxDQUFBeFMsTUFBQSxXQUV4QzhJLFlBQVk7WUFBQTtZQUFBO2NBQUEsT0FBQTBKLFFBQUEsQ0FBQXpQLElBQUE7VUFBQTtRQUFBLEdBQUE4UCxPQUFBO01BQUEsQ0FFdEI7O0lBeVJEO0VBQUE7SUFBQS9XLEdBQUE7SUFBQUUsS0FBQSxFQUVRLFNBQUFtUCxpQkFBaUJuQyxVQUFVO01BRS9CLE9BQU8sSUFBSVgsR0FBRyxDQUFDLElBQUksQ0FBQ0MsZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQyxDQUFDRSxnQkFBZ0IsQ0FBQztJQUV6RTtFQUFDO0lBQUFwTixHQUFBO0lBQUFFLEtBQUEsRUFFTyxTQUFBb1Asa0JBQWtCcEMsVUFBVSxFQUFFMEIsZUFBZTtNQUUzQyxJQUFBb0ksU0FBUyxHQUFHLElBQUl6SyxHQUFHLEVBQUU7UUFBQTBLLHNCQUFBLEdBQ0EsSUFBSSxDQUFDekssZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQztRQUF6REUsZ0JBQWdCLEdBQUE2SixzQkFBQSxDQUFoQjdKLGdCQUFnQjtNQURLLElBQUE4SixVQUFBLEdBQUFsTywwQkFBQSxDQUdQNEYsZUFBZTtRQUFBdUksTUFBQTtNQUFBO1FBQW5DLEtBQUFELFVBQUEsQ0FBQTdOLENBQUEsTUFBQThOLE1BQUEsR0FBQUQsVUFBQSxDQUFBNU4sQ0FBQSxJQUFBbkYsSUFBQSxHQUFxQztVQUFBLElBQTFCMEwsS0FBSyxHQUFBc0gsTUFBQSxDQUFBalgsS0FBQTtVQUVaOFcsU0FBUyxDQUFDNUYsR0FBRyxDQUFDdkIsS0FBSyxFQUFFekMsZ0JBQWdCLENBQUNFLEdBQUcsQ0FBQ3VDLEtBQUssQ0FBQyxDQUFDOztNQUVwRCxTQUFBaFAsR0FBQTtRQUFBcVcsVUFBQSxDQUFBM04sQ0FBQSxDQUFBMUksR0FBQTtNQUFBO1FBQUFxVyxVQUFBLENBQUF6TixDQUFBO01BQUE7TUFFRCxPQUFPdU4sU0FBUztJQUVwQjtFQUFDO0lBQUFoWCxHQUFBO0lBQUFFLEtBQUEsRUFFTyxTQUFBcVAsZ0JBQWdCckMsVUFBVTtNQUU5QixJQUFNa0ssU0FBUyxHQUFHLElBQUk3SyxHQUFHLEVBQUU7TUFDM0IsSUFBQThLLHNCQUFBLEdBQW9CLElBQUksQ0FBQzdLLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7UUFBaERLLE9BQU8sR0FBQThKLHNCQUFBLENBQVA5SixPQUFPO01BQ2YsSUFBUWpCLGVBQWUsR0FBSyxJQUFJLENBQXhCQSxlQUFlO01BRXZCO01BQUEsSUFBQWdMLFVBQUEsR0FBQXRPLDBCQUFBLENBQ3FCdUUsT0FBTztRQUFBZ0ssTUFBQTtNQUFBO1FBQTVCLEtBQUFELFVBQUEsQ0FBQWpPLENBQUEsTUFBQWtPLE1BQUEsR0FBQUQsVUFBQSxDQUFBaE8sQ0FBQSxJQUFBbkYsSUFBQSxHQUE4QjtVQUFBLElBQW5Cb00sTUFBTSxHQUFBZ0gsTUFBQSxDQUFBclgsS0FBQTtVQUNiLElBQU1zWCxRQUFRLEdBQUdsTCxlQUFlLENBQUNnQixHQUFHLENBQUNpRCxNQUFNLENBQUM7VUFDNUMsSUFDSVYsS0FBSyxHQUVMMkgsUUFBUSxDQUZSM0gsS0FBSztZQUNMUyxTQUFTLEdBQ1RrSCxRQUFRLENBRFJsSCxTQUFTO1VBR2I4RyxTQUFTLENBQUNoRyxHQUFHLENBQUNiLE1BQU0sRUFBQztZQUNqQlYsS0FBSyxFQUFMQSxLQUFLO1lBQ0xTLFNBQVMsRUFBVEE7V0FDSCxDQUFDOztNQUVMLFNBQUF6UCxHQUFBO1FBQUF5VyxVQUFBLENBQUEvTixDQUFBLENBQUExSSxHQUFBO01BQUE7UUFBQXlXLFVBQUEsQ0FBQTdOLENBQUE7TUFBQTtNQUVELE9BQU8yTixTQUFTO0lBRXBCO0lBRUE7SUFFQTtJQUVBO0VBQUE7SUFBQXBYLEdBQUE7SUFBQUUsS0FBQSxFQUNRLFNBQUFzUCxVQUFVdEMsVUFBVSxFQUFFdUMsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLGFBQWE7TUFFakUsSUFBTXZDLGdCQUFnQixHQUF1QixJQUFJLENBQUNaLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUMsQ0FBQ0UsZ0JBQWdCO01BQ2xHLElBQVFkLGVBQWUsR0FBSyxJQUFJLENBQXhCQSxlQUFlO01BRXZCO01BRUEsSUFBTW1MLGFBQWEsR0FBRzlILGFBQWEsR0FBR0QsWUFBWSxHQUFHLENBQUM7UUFDbERnSSxhQUFhLEdBQUdqSSxVQUFVLEdBQUdDLFlBQVk7UUFDekNpSSxXQUFXLEdBQUdsSSxVQUFVLElBQUlnSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO01BRWxELElBQU1HLGFBQWEsR0FDZEYsYUFBYSxHQUFHLENBQUM7TUFBRztNQUNqQixJQUFJO01BQUU7TUFDTixNQUFNLEVBQUc7TUFFakI7TUFFQSxJQUFNRyxnQkFBZ0IsR0FBRy9PLEtBQUssQ0FBQ3VCLElBQUksQ0FBQytDLGdCQUFnQixDQUFDNUcsSUFBSSxFQUFFLENBQUMsQ0FBQ2lNLElBQUksQ0FBQyxVQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBQSxPQUFHRCxDQUFDLEdBQUNDLENBQUM7TUFBQSxFQUFDO01BRTdFLElBQU1tRix1QkFBdUIsR0FBR0QsZ0JBQWdCLENBQUM3USxLQUFLLEVBQUUsQ0FBQ0wsT0FBTyxFQUFFO01BRWxFLElBQU1vUixhQUFhLEdBQUdGLGdCQUFnQixDQUFDRyxTQUFTLENBQUMsVUFBQTlYLEtBQUs7VUFBQSxPQUFJQSxLQUFLLElBQUl1UCxVQUFVO1FBQUEsRUFBQztRQUMxRXdJLGVBQWUsR0FBR0osZ0JBQWdCLENBQUNHLFNBQVMsQ0FBQyxVQUFBOVgsS0FBSztVQUFBLE9BQUlBLEtBQUssSUFBSXdQLFlBQVk7UUFBQSxFQUFDO01BRWhGLElBQUl3SSxjQUFjLEdBQUdKLHVCQUF1QixDQUFDRSxTQUFTLENBQUMsVUFBQTlYLEtBQUs7VUFBQSxPQUFJQSxLQUFLLElBQUl5WCxXQUFXO1FBQUEsRUFBQztRQUNqRlEsZ0JBQWdCLEdBQUdMLHVCQUF1QixDQUFDRSxTQUFTLENBQUMsVUFBQTlYLEtBQUs7VUFBQSxPQUFJQSxLQUFLLElBQUl5UCxhQUFhO1FBQUEsRUFBQztNQUV6RjtNQUNBO1FBQ0ksSUFBTXlJLGNBQWMsR0FBR1AsZ0JBQWdCLENBQUNuUyxNQUFNO1FBQzlDLElBQUl3UyxjQUFjLElBQUksQ0FBQyxDQUFDLEVBQUVBLGNBQWMsR0FBSUUsY0FBYyxHQUFFLENBQUMsR0FBSUYsY0FBYztRQUMvRSxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsRUFBRUEsZ0JBQWdCLEdBQUlDLGNBQWMsR0FBRSxDQUFDLEdBQUlELGdCQUFnQjs7TUFHekY7TUFFQSxJQUFJRSxvQkFBb0I7TUFDeEIsSUFBS0osZUFBZSxJQUFJLENBQUMsQ0FBQyxJQUFNRSxnQkFBZ0IsSUFBSSxDQUFDLENBQUUsRUFBRTtRQUFFO1FBRXZERSxvQkFBb0IsR0FBRyxFQUFFO09BRTVCLE1BQU0sSUFBSUYsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUVqQ0Usb0JBQW9CLEdBQUdSLGdCQUFnQixDQUFDN1EsS0FBSyxDQUFDaVIsZUFBZSxDQUFDO09BRWpFLE1BQU07UUFBRTtRQUVMSSxvQkFBb0IsR0FBR1IsZ0JBQWdCLENBQUM3USxLQUFLLENBQUNpUixlQUFlLEVBQUVFLGdCQUFnQixHQUFHLENBQUMsQ0FBQzs7TUFJeEYsSUFBTUcsZ0JBQWdCLEdBQUcsSUFBSS9MLEdBQUcsRUFBRTtNQUNsQyxJQUFNZ00sa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFrQkEsQ0FBSTFJLEtBQUssRUFBSTtRQUVqQ3lJLGdCQUFnQixDQUFDbEgsR0FBRyxDQUFDdkIsS0FBSyxFQUFFekMsZ0JBQWdCLENBQUNFLEdBQUcsQ0FBQ3VDLEtBQUssQ0FBQyxDQUFDO01BRTVELENBQUM7TUFFRHdJLG9CQUFvQixDQUFDNVYsT0FBTyxDQUFDOFYsa0JBQWtCLENBQUM7TUFFaEQ7TUFFQSxJQUFJQyx3QkFBd0I7TUFDNUIsSUFBSVosYUFBYSxJQUFJLE1BQU0sRUFBRTtRQUFFO1FBRTNCLElBQUtHLGFBQWEsSUFBSSxDQUFDLENBQUMsSUFBTUUsZUFBZSxJQUFJLENBQUMsQ0FBRSxFQUFFO1VBRWxETyx3QkFBd0IsR0FBRyxFQUFFO1NBRWhDLE1BQU0sSUFBSVAsZUFBZSxJQUFJLENBQUMsQ0FBQyxFQUFFO1VBRTlCTyx3QkFBd0IsR0FBR1gsZ0JBQWdCLENBQUM3USxLQUFLLENBQUMrUSxhQUFhLENBQUM7U0FFbkUsTUFBTTtVQUVIUyx3QkFBd0IsR0FBR1gsZ0JBQWdCLENBQUM3USxLQUFLLENBQUMrUSxhQUFhLEVBQUVFLGVBQWUsQ0FBQzs7T0FJeEYsTUFBTTtRQUFFO1FBRUwsSUFBSUMsY0FBYyxJQUFJLENBQUMsQ0FBQyxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsRUFBRTtVQUVoREssd0JBQXdCLEdBQUcsRUFBRTtTQUVoQyxNQUFNLElBQUlOLGNBQWMsSUFBSSxDQUFDLENBQUMsRUFBRTtVQUU3Qk0sd0JBQXdCLEdBQUdYLGdCQUFnQixDQUFDN1EsS0FBSyxDQUFDbVIsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1NBRTFFLE1BQU07VUFFSEssd0JBQXdCLEdBQUdYLGdCQUFnQixDQUFDN1EsS0FBSyxDQUFDbVIsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFRCxjQUFjLEdBQUcsQ0FBQyxDQUFDOzs7TUFLbkcsSUFBSU4sYUFBYSxJQUFJLE1BQU0sRUFBRVksd0JBQXdCLENBQUM3UixPQUFPLEVBQUU7TUFFL0Q7TUFFQSxJQUFNOFIscUJBQXFCLEdBQUcsRUFBRTtNQUVoQyxJQUFNQyx1QkFBdUIsR0FBRyxTQUExQkEsdUJBQXVCQSxDQUFJN0ksS0FBSyxFQUFJO1FBRXRDLElBQU1VLE1BQU0sR0FBR25ELGdCQUFnQixDQUFDRSxHQUFHLENBQUN1QyxLQUFLLENBQUM7UUFFMUMsSUFBTThJLFFBQVEsR0FDVGYsYUFBYSxJQUFJLElBQUksR0FDbEIvSCxLQUFLLEdBQUc0SCxhQUFhLEdBQ3JCNUgsS0FBSyxHQUFHNEgsYUFBYTtRQUU3QnJLLGdCQUFnQixDQUFDZ0UsR0FBRyxDQUFDdUgsUUFBUSxFQUFDcEksTUFBTSxDQUFDO1FBQ3JDakUsZUFBZSxDQUFDZ0IsR0FBRyxDQUFDaUQsTUFBTSxDQUFDLENBQUNWLEtBQUssR0FBRzhJLFFBQVE7UUFDNUNGLHFCQUFxQixDQUFDdFQsSUFBSSxDQUFDd1QsUUFBUSxDQUFDO01BRXhDLENBQUM7TUFFREgsd0JBQXdCLENBQUMvVixPQUFPLENBQUNpVyx1QkFBdUIsQ0FBQztNQUV6RDtNQUVBLElBQU1FLGlCQUFpQixHQUFHLEVBQUU7TUFDNUIsSUFBTUMsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFrQkEsQ0FBSXRJLE1BQU0sRUFBRVYsS0FBSyxFQUFJO1FBQ3pDLElBQU04SSxRQUFRLEdBQUc5SSxLQUFLLEdBQUc2SCxhQUFhLEVBQUM7UUFFdkN0SyxnQkFBZ0IsQ0FBQ2dFLEdBQUcsQ0FBQ3VILFFBQVEsRUFBRXBJLE1BQU0sQ0FBQztRQUN0Q2pFLGVBQWUsQ0FBQ2dCLEdBQUcsQ0FBQ2lELE1BQU0sQ0FBQyxDQUFDVixLQUFLLEdBQUc4SSxRQUFRO1FBQzVDQyxpQkFBaUIsQ0FBQ3pULElBQUksQ0FBQ3dULFFBQVEsQ0FBQztNQUVwQyxDQUFDO01BRURMLGdCQUFnQixDQUFDN1YsT0FBTyxDQUFDb1csa0JBQWtCLENBQUM7TUFFNUM7TUFDQTtNQUVBLElBQU1DLGdCQUFnQixHQUFHLEdBQUF0RixNQUFBLENBQUlpRixxQkFBcUIsRUFBSUcsaUJBQWlCLEVBQUVuRyxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBR0QsQ0FBQyxHQUFDQyxDQUFDO01BQUEsRUFBQztNQUV6RixPQUFPbUcsZ0JBQWdCO0lBRTNCO0lBRUE7SUFFQTtFQUFBO0lBQUE5WSxHQUFBO0lBQUFFLEtBQUEsRUFDUSxTQUFBMFAsa0JBQWtCMUMsVUFBVSxFQUFFMkMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsUUFBUTtNQUV2RTtNQUNBLElBQU0rSSxXQUFXLEdBQUloSixTQUFTLElBQUksQ0FBRTtNQUNwQyxJQUFNaUosVUFBVSxHQUFJakosU0FBUyxJQUFJLENBQUMsQ0FBRTtNQUVwQyxJQUFNa0osV0FBVyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBQztNQUUvQztNQUNBLElBQU03TCxnQkFBZ0IsR0FBd0IsSUFBSSxDQUFDWixlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNFLGdCQUFnQjtNQUNuRyxJQUFRZCxlQUFlLEdBQUssSUFBSSxDQUF4QkEsZUFBZTtNQUN2QixJQUFNNE0scUJBQXFCLEdBQUdwUSxLQUFLLENBQUN1QixJQUFJLENBQUMrQyxnQkFBZ0IsQ0FBQzVHLElBQUksRUFBRSxDQUFDLENBQUNpTSxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsT0FBR0QsQ0FBQyxHQUFDQyxDQUFDO01BQUEsRUFBQyxFQUFDO01BQ25GLElBQU1wRixPQUFPLEdBQUcsSUFBSSxDQUFDZixlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDLENBQUNLLE9BQU87TUFFNUQ7TUFFQTtNQUNBLElBQUk0TCxjQUFjLEdBQUdySixTQUFTO01BQzlCLElBQUlzSixhQUFhLEdBQUd2SixLQUFLLEVBQUM7TUFFMUIsSUFBSW1KLFVBQVUsRUFBRTtRQUVaO1FBQ0EsSUFBSUcsY0FBYyxHQUFJbkosUUFBUSxHQUFHLENBQUUsRUFBRTtVQUVqQ21KLGNBQWMsR0FBSW5KLFFBQVEsR0FBRyxDQUFFO1VBQy9CLElBQUltSixjQUFjLEdBQUdDLGFBQWEsRUFBRSxPQUFPSCxXQUFXOztPQUk3RCxNQUFNO1FBQUU7UUFFTDtRQUNBLElBQUlHLGFBQWEsR0FBR3BKLFFBQVEsRUFBRTtVQUUxQixJQUFNcUosSUFBSSxHQUFHRCxhQUFhLEdBQUdwSixRQUFRO1VBQ3JDb0osYUFBYSxJQUFJQyxJQUFJO1VBQ3JCRixjQUFjLElBQUlFLElBQUk7VUFFdEI7OztNQU1SO01BQ0EsSUFBTUMsVUFBVSxHQUFHSCxjQUFjLEdBQUdDLGFBQWEsR0FBRyxDQUFDO01BRXJEO01BQ0EsSUFBTUcsY0FBYyxHQUFHRCxVQUFVLEdBQUd2SixTQUFTO01BQzdDLElBQU15SixnQkFBZ0IsR0FDakJ6SixTQUFTLElBQUksQ0FBQyxHQUNYcUosYUFBYSxHQUNiRCxjQUFjLElBQUlJLGNBQWMsR0FBRyxDQUFDLENBQUM7TUFFN0MsSUFBSUUsaUJBQWlCLEVBQUM7TUFDdEIsSUFBSVYsV0FBVyxFQUFFO1FBQ2JVLGlCQUFpQixHQUFHTCxhQUFhO09BQ3BDLE1BQU07UUFBRTtRQUNMSyxpQkFBaUIsR0FBR04sY0FBYyxHQUFHLENBQUM7O01BRzFDO01BRUE7TUFDQSxJQUFNTyxvQkFBb0IsR0FBR1IscUJBQXFCLENBQUNsQixTQUFTLENBQUMsVUFBQTlYLEtBQUssRUFBRztRQUVqRSxPQUFRQSxLQUFLLElBQUl1WixpQkFBaUI7TUFFdEMsQ0FBQyxDQUFDO01BRUY7TUFDQSxJQUFNRSxnQkFBZ0IsR0FBR1QscUJBQXFCLENBQUNsQixTQUFTLENBQUMsVUFBQTlYLEtBQUssRUFBRztRQUU3RCxPQUFRQSxLQUFLLElBQUlrWixhQUFhLElBQU1sWixLQUFLLElBQUlpWixjQUFlO01BRWhFLENBQUMsQ0FBQztNQUVGO01BQ0EsSUFBTVMscUJBQXFCLEdBQUc5USxLQUFLLENBQUN1QixJQUFJLENBQUM2TyxxQkFBcUIsQ0FBQyxDQUFDdlMsT0FBTyxFQUFFO01BQ3pFLElBQUlrVCxpQkFBaUIsR0FBR0QscUJBQXFCLENBQUM1QixTQUFTLENBQUMsVUFBQTlYLEtBQUssRUFBRTtRQUUzRCxPQUFRQSxLQUFLLElBQUlpWixjQUFjLElBQU1qWixLQUFLLElBQUlrWixhQUFjO01BRWhFLENBQUMsQ0FBQztNQUNGO01BQ0EsSUFBSVMsaUJBQWlCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFFekJBLGlCQUFpQixHQUFJWCxxQkFBcUIsQ0FBQ3hULE1BQU0sR0FBRyxDQUFDLEdBQUltVSxpQkFBaUI7UUFDMUUsSUFBSUEsaUJBQWlCLEdBQUdGLGdCQUFnQixFQUFFRSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7O01BSXBFO01BRUE7TUFDQSxJQUFJQyxxQkFBcUI7UUFBRTtRQUN2QkMsdUJBQXVCLEVBQUM7TUFFNUI7TUFDQSxJQUFJSixnQkFBZ0IsSUFBSSxDQUFDLENBQUMsRUFBRTtRQUFFO1FBRTFCRyxxQkFBcUIsR0FBRyxFQUFFO1FBQzFCQyx1QkFBdUIsR0FBRyxFQUFFO09BRS9CLE1BQU0sSUFBSUYsaUJBQWlCLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUVsQztRQUNBQyxxQkFBcUIsR0FBR1oscUJBQXFCLENBQUNsUyxLQUFLLENBQUMyUyxnQkFBZ0IsQ0FBQztRQUVyRSxJQUFJWixXQUFXLEVBQUU7VUFFYmdCLHVCQUF1QixHQUFHRCxxQkFBcUIsQ0FBQzlTLEtBQUssRUFBRTtTQUUxRCxNQUFNO1VBRUgsSUFBSTBTLG9CQUFvQixJQUFJLENBQUMsQ0FBQyxFQUFFO1lBRTVCSyx1QkFBdUIsR0FBRyxFQUFFO1dBRS9CLE1BQU07WUFFSEEsdUJBQXVCLEdBQUdiLHFCQUFxQixDQUFDbFMsS0FBSyxDQUFDMFMsb0JBQW9CLENBQUM7OztPQU10RixNQUFNO1FBQUU7UUFFTEkscUJBQXFCLEdBQUdaLHFCQUFxQixDQUFDbFMsS0FBSyxDQUFDMlMsZ0JBQWdCLEVBQUVFLGlCQUFpQixHQUFHLENBQUMsQ0FBQztRQUU1RixJQUFJZCxXQUFXLEVBQUU7VUFFYmdCLHVCQUF1QixHQUFHYixxQkFBcUIsQ0FBQ2xTLEtBQUssQ0FBQzBTLG9CQUFvQixDQUFDO1NBRTlFLE1BQU07VUFFSCxJQUFJQSxvQkFBb0IsSUFBSSxDQUFDLENBQUMsRUFBRTtZQUU1QkssdUJBQXVCLEdBQUcsRUFBRTtXQUUvQixNQUFNO1lBRUhBLHVCQUF1QixHQUFHYixxQkFBcUIsQ0FBQ2xTLEtBQUssQ0FBQzBTLG9CQUFvQixDQUFDOzs7O01BUXZGO01BRUE7TUFDQTtNQUNBLElBQUlNLHlCQUF5QixHQUFHLEVBQUU7UUFBRTtRQUNoQ0Msd0JBQXdCLEdBQUcsRUFBRTtRQUFFO1FBQy9CQyxzQkFBc0IsR0FBRyxFQUFFLEVBQUM7TUFFaEMsSUFBSW5CLFdBQVcsRUFBRTtRQUViaUIseUJBQXlCLEdBQUdGLHFCQUFxQjtPQUVwRCxNQUFNO1FBQUU7UUFFTEcsd0JBQXdCLEdBQUdILHFCQUFxQjtRQUVoRDtRQUFBLElBQUFLLFVBQUEsR0FBQW5SLDBCQUFBLENBQ29CaVIsd0JBQXdCO1VBQUFHLE1BQUE7UUFBQTtVQUE1QyxLQUFBRCxVQUFBLENBQUE5USxDQUFBLE1BQUErUSxNQUFBLEdBQUFELFVBQUEsQ0FBQTdRLENBQUEsSUFBQW5GLElBQUEsR0FBOEM7WUFBQSxJQUFuQzBMLE1BQUssR0FBQXVLLE1BQUEsQ0FBQWxhLEtBQUE7WUFFWmdhLHNCQUFzQixDQUFDL1UsSUFBSSxDQUFDaUksZ0JBQWdCLENBQUNFLEdBQUcsQ0FBQ3VDLE1BQUssQ0FBQyxDQUFDO1lBQ3hEekMsZ0JBQWdCLFVBQU8sQ0FBQ3lDLE1BQUssQ0FBQzs7UUFFakMsU0FBQWhQLEdBQUE7VUFBQXNaLFVBQUEsQ0FBQTVRLENBQUEsQ0FBQTFJLEdBQUE7UUFBQTtVQUFBc1osVUFBQSxDQUFBMVEsQ0FBQTtRQUFBOztNQUlMO01BRUE7TUFDQSxJQUFJc1AsV0FBVyxFQUFFZ0IsdUJBQXVCLENBQUNwVCxPQUFPLEVBQUU7TUFFbEQsSUFBTTBULHVCQUF1QixHQUFHLEVBQUUsRUFBQztNQUNuQyxJQUFNQywwQkFBMEIsR0FBZSxJQUFJdk4sR0FBRyxFQUFFLEVBQUM7TUFFekQ7TUFDQSxJQUFNd04sY0FBYyxHQUFHLFNBQWpCQSxjQUFjQSxDQUFHMUssS0FBSyxFQUFHO1FBRTNCLElBQU1VLE1BQU0sR0FBR25ELGdCQUFnQixDQUFDRSxHQUFHLENBQUN1QyxLQUFLLENBQUM7UUFDMUMsSUFBTThJLFFBQVEsR0FBRzlJLEtBQUssR0FBRzBKLGNBQWM7UUFFdkMsSUFBSVAsVUFBVSxFQUFFO1VBQ1pzQiwwQkFBMEIsQ0FBQ3BJLEdBQUcsQ0FBQ3JDLEtBQUssQ0FBQztVQUNyQ3lLLDBCQUEwQixVQUFPLENBQUMzQixRQUFRLENBQUM7O1FBRy9DdkwsZ0JBQWdCLENBQUNnRSxHQUFHLENBQUN1SCxRQUFRLEVBQUVwSSxNQUFNLENBQUM7UUFDdENqRSxlQUFlLENBQUNnQixHQUFHLENBQUNpRCxNQUFNLENBQUMsQ0FBQ1YsS0FBSyxHQUFHOEksUUFBUTtRQUM1QzBCLHVCQUF1QixDQUFDbFYsSUFBSSxDQUFDd1QsUUFBUSxDQUFDO01BRTFDLENBQUM7TUFFRDtNQUNBb0IsdUJBQXVCLENBQUN0WCxPQUFPLENBQUM4WCxjQUFjLENBQUM7TUFFL0M7TUFFQSxJQUFNeE0saUNBQWlDLEdBQUcsRUFBRSxFQUFDO01BQzdDLElBQUl5TSx1QkFBdUIsR0FBRyxFQUFFO01BRWhDLElBQUl6QixXQUFXLEVBQUU7UUFBQSxJQUFBMEIsVUFBQSxHQUFBelIsMEJBQUEsQ0FFT2dSLHlCQUF5QjtVQUFBVSxNQUFBO1FBQUE7VUFBN0MsS0FBQUQsVUFBQSxDQUFBcFIsQ0FBQSxNQUFBcVIsTUFBQSxHQUFBRCxVQUFBLENBQUFuUixDQUFBLElBQUFuRixJQUFBLEdBQStDO1lBQUEsSUFBcEMwTCxPQUFLLEdBQUE2SyxNQUFBLENBQUF4YSxLQUFBO1lBRVprTixnQkFBZ0IsVUFBTyxDQUFDeUMsT0FBSyxDQUFDOztRQUVqQyxTQUFBaFAsR0FBQTtVQUFBNFosVUFBQSxDQUFBbFIsQ0FBQSxDQUFBMUksR0FBQTtRQUFBO1VBQUE0WixVQUFBLENBQUFoUixDQUFBO1FBQUE7T0FFSixNQUFNO1FBQUU7UUFBQSxJQUFBa1IsVUFBQSxHQUFBM1IsMEJBQUEsQ0FFZ0JrUixzQkFBc0I7VUFBQVUsTUFBQTtRQUFBO1VBQTNDLEtBQUFELFVBQUEsQ0FBQXRSLENBQUEsTUFBQXVSLE1BQUEsR0FBQUQsVUFBQSxDQUFBclIsQ0FBQSxJQUFBbkYsSUFBQSxHQUE2QztZQUFBLElBQWxDb00sTUFBTSxHQUFBcUssTUFBQSxDQUFBMWEsS0FBQTtZQUViLElBQUEyYSxxQkFBQSxHQUF3QnZPLGVBQWUsQ0FBQ2dCLEdBQUcsQ0FBQ2lELE1BQU0sQ0FBQztjQUEzQ1UsV0FBVyxHQUFBNEoscUJBQUEsQ0FBWDVKLFdBQVc7WUFDbkJsRCxpQ0FBaUMsQ0FBQzVJLElBQUksQ0FBQztjQUFDb0wsTUFBTSxFQUFOQSxNQUFNO2NBQUVVLFdBQVcsRUFBWEE7WUFBVyxDQUFDLENBQUM7WUFDN0QzRSxlQUFlLFVBQU8sQ0FBQ2lFLE1BQU0sQ0FBQztZQUM5QmhELE9BQU8sVUFBTyxDQUFDZ0QsTUFBTSxDQUFDOztVQUkxQjtRQUFBLFNBQUExUCxHQUFBO1VBQUE4WixVQUFBLENBQUFwUixDQUFBLENBQUExSSxHQUFBO1FBQUE7VUFBQThaLFVBQUEsQ0FBQWxSLENBQUE7UUFBQTtRQUNBLElBQU1xUiw4QkFBOEIsR0FBR2hTLEtBQUssQ0FBQ3VCLElBQUksQ0FBQ2lRLDBCQUEwQixDQUFDO1FBRTdFLFNBQUFTLEdBQUEsTUFBQUMscUJBQUEsR0FBb0JGLDhCQUE4QixFQUFBQyxHQUFBLEdBQUFDLHFCQUFBLENBQUF0VixNQUFBLEVBQUFxVixHQUFBLElBQUU7VUFBL0MsSUFBTWxMLE9BQUssR0FBQW1MLHFCQUFBLENBQUFELEdBQUE7VUFFWjNOLGdCQUFnQixVQUFPLENBQUN5QyxPQUFLLENBQUM7O1FBSWxDMkssdUJBQXVCLEdBQUdQLHdCQUF3QixDQUFDekcsTUFBTSxDQUFDc0gsOEJBQThCLENBQUM7O01BSTdGLElBQUkvQixXQUFXLEVBQUVzQix1QkFBdUIsQ0FBQzFULE9BQU8sRUFBRSxFQUFDO01BRW5EO01BRUE7TUFDQSxPQUFPLENBQUM2UyxnQkFBZ0IsRUFBRUQsY0FBYyxFQUFFYyx1QkFBdUIsRUFBRUcsdUJBQXVCLEVBQUVSLHlCQUF5QixFQUFFak0saUNBQWlDLENBQUM7SUFFN0o7SUFFQTtJQUVBO0lBQ0E7RUFBQTtJQUFBL04sR0FBQTtJQUFBRSxLQUFBLEVBQ1EsU0FBQStQLHNCQUFzQi9DLFVBQVUsRUFBRTJDLEtBQUs7TUFFM0MsSUFBSSxDQUFDckQsZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQyxDQUFDTyxZQUFZLENBQUN5RSxHQUFHLENBQUNyQyxLQUFLLENBQUM7SUFFaEU7RUFBQztJQUFBN1AsR0FBQTtJQUFBRSxLQUFBLEVBRU8sU0FBQWdRLHdCQUF3QmhELFVBQVUsRUFBRTJDLEtBQUs7TUFFN0MsSUFBTXJELGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7TUFFNUQsSUFBSVYsZUFBZSxFQUFFO1FBQUU7UUFDbkJBLGVBQWUsQ0FBQ2lCLFlBQVksVUFBTyxDQUFDb0MsS0FBSyxDQUFDOztJQUdsRDtFQUFDO0lBQUE3UCxHQUFBO0lBQUFFLEtBQUEsRUFFTyxTQUFBaVEsYUFBQSxFQUFZO01BRWhCLE9BQU8sSUFBSSxDQUFDL0QsWUFBWSxFQUFFO0lBRTlCO0lBRUE7RUFBQTtJQUFBcE0sR0FBQTtJQUFBRSxLQUFBLEVBQ1EsU0FBQWtRLHVCQUF1QmxELFVBQVUsRUFBRTJDLEtBQUs7TUFFNUMsSUFBQW9MLHNCQUFBLEdBQTZCLElBQUksQ0FBQ3pPLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDSixVQUFVLENBQUM7UUFBekRFLGdCQUFnQixHQUFBNk4sc0JBQUEsQ0FBaEI3TixnQkFBZ0I7TUFFeEIsSUFBTW1ELE1BQU0sR0FDUG5ELGdCQUFnQixDQUFDNkksR0FBRyxDQUFDcEcsS0FBSyxDQUFDLEdBQ3hCekMsZ0JBQWdCLENBQUNFLEdBQUcsQ0FBQ3VDLEtBQUssQ0FBQyxHQUMxQixJQUFJLENBQUNNLFlBQVksRUFBRztNQUU3QixPQUFPSSxNQUFNO0lBRWpCO0lBRUM7RUFBQTtJQUFBdlEsR0FBQTtJQUFBRSxLQUFBLEVBQ2EsU0FBQW1RLGFBQWFuRCxVQUFVLEVBQUVvRCxTQUFTLEVBQUVULEtBQUssRUFBRVUsTUFBTSxFQUFFQyxrQkFBa0IsRUFBbUI7TUFBQSxJQUFqQkMsU0FBUyxHQUFBQyxTQUFBLENBQUFoTCxNQUFBLFFBQUFnTCxTQUFBLFFBQUFyTSxTQUFBLEdBQUFxTSxTQUFBLE1BQUcsS0FBSzs7Ozs7O2NBRWxHLElBQUksQ0FBQ1IsdUJBQXVCLENBQUNoRCxVQUFVLEVBQUUyQyxLQUFLLENBQUM7Y0FFekNyRCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDO2NBQUEsSUFFdkRWLGVBQWU7Z0JBQUEwTyxTQUFBLENBQUF6VyxJQUFBO2dCQUFBO2NBQUE7Y0FBQSxPQUFBeVcsU0FBQSxDQUFBaFgsTUFBQSxXQUFTLElBQUk7WUFBQTtjQUFBaVgsc0JBQUEsR0FHN0IsSUFBSSxDQUFDM08sZUFBZSxDQUFDYyxHQUFHLENBQUNKLFVBQVUsQ0FBQyxDQUFDVSxnQkFBZ0IsQ0FBQ3FILDRCQUE0QixDQUFDdEQsT0FBTyxFQUR0RnlKLE1BQU0sR0FBQUQsc0JBQUEsQ0FBTkMsTUFBTSxFQUFFQyxVQUFVLEdBQUFGLHNCQUFBLENBQVZFLFVBQVUsRUFBRUMsU0FBUyxHQUFBSCxzQkFBQSxDQUFURyxTQUFTLEVBQUVDLFdBQVcsR0FBQUosc0JBQUEsQ0FBWEksV0FBVztjQUc1Q0MsVUFBVSxHQUFHQyxnQkFBZ0IsQ0FBQzVMLEtBQUssRUFBRVUsTUFBTSxDQUFDO2NBQUEySyxTQUFBLENBQUF6VyxJQUFBO2NBRTlCLE9BQU0sSUFBSSxDQUFDZ1MscUJBQXFCLEVBQUU7WUFBQTtjQUFoRHhGLFdBQVcsR0FBQWlLLFNBQUEsQ0FBQW5YLElBQUE7Y0FFWGlPLE1BQU0sR0FDUnBHLE9BQUEsWUFBQWtHLGFBQUE7Z0JBQUEsYUFBaUIsZUFBZTtnQkFBQzlSLEdBQUcsRUFBSXVRLE1BQU07Z0JBQUEsZUFBaUJBLE1BQU07Z0JBQUEsY0FBZ0JWO2NBQUssR0FDdEZqRSxPQUFBLFlBQUFrRyxhQUFBLENBQUMvRixzQkFBQSxDQUFBMlAsUUFBUTtnQkFBQzFiLEdBQUcsRUFBSXVRLE1BQU07Z0JBQUVvTCxJQUFJLEVBQUlIO2NBQVUsRyxLQUFNbEwsU0FBUyxFLElBQWMsQ0FDdEU7Y0FFVixJQUFJLENBQUN5QixrQkFBa0IsQ0FBQ2QsV0FBVyxFQUFFVixNQUFNLEVBQUV5QixNQUFNLENBQUM7Y0FFOUM0SixjQUFjLEdBQUc7Z0JBQ25CSixVQUFVLEVBQVZBLFVBQVU7Z0JBQ1YzTCxLQUFLLEVBQUxBLEtBQUs7Z0JBQ0xVLE1BQU0sRUFBTkEsTUFBTTtnQkFDTnJELFVBQVUsRUFBVkEsVUFBVTtnQkFDVnNELGtCQUFrQixFQUFsQkEsa0JBQWtCO2dCQUNsQkYsU0FBUyxFQUFUQSxTQUFTO2dCQUNUVyxXQUFXLEVBQVhBO2VBQ0g7Y0FFRCxJQUFJLENBQUMzRSxlQUFlLENBQUM4RSxHQUFHLENBQUNiLE1BQU0sRUFBRXFMLGNBQWMsQ0FBQztjQUNoRHBQLGVBQWUsQ0FBQ2UsT0FBTyxDQUFDMkUsR0FBRyxDQUFDM0IsTUFBTSxDQUFDO2NBQ25DL0QsZUFBZSxDQUFDWSxnQkFBZ0IsQ0FBQ2dFLEdBQUcsQ0FBQ3ZCLEtBQUssRUFBRVUsTUFBTSxDQUFDO2NBRW5ELElBQUksQ0FBQ0UsU0FBUyxFQUFFLElBQUksQ0FBQ3BDLGlCQUFpQixFQUFFO2NBQUEsT0FBQTZNLFNBQUEsQ0FBQWhYLE1BQUEsV0FFakMwWCxjQUFjO1lBQUE7WUFBQTtjQUFBLE9BQUFWLFNBQUEsQ0FBQWpVLElBQUE7VUFBQTtRQUFBLEdBQUE0VSxRQUFBO01BQUEsQ0FFeEI7O0lBRUQ7RUFBQTtJQUFBN2IsR0FBQTtJQUFBRSxLQUFBLEVBQ2MsU0FBQWdXLFlBQ1ZoSixVQUFVLEVBQ1YyQyxLQUFLLEVBQ0x1RixPQUFPLEVBQ1BULHFCQUFxQixFQUNyQnFCLHFCQUFxQixFQUNyQkwsb0JBQW9COzs7Ozs7Y0FHZHBGLE1BQU0sR0FBRyxJQUFJLENBQUNKLFlBQVksRUFBRTtjQUFBMkwsU0FBQSxDQUFBaFYsSUFBQTtjQUFBZ1YsU0FBQSxDQUFBclgsSUFBQTtjQU1oQixPQUFNMlEsT0FBTyxDQUFDdkYsS0FBSyxFQUFFVSxNQUFNLENBQUM7WUFBQTtjQUExQ3dMLFdBQVcsR0FBQUQsU0FBQSxDQUFBL1gsSUFBQTtjQUNYLElBQUlnWSxXQUFXLEtBQUssSUFBSSxFQUFFQyxXQUFXLEdBQUdELFdBQVc7Y0FBQUQsU0FBQSxDQUFBclgsSUFBQTtjQUFBO1lBQUE7Y0FBQXFYLFNBQUEsQ0FBQWhWLElBQUE7Y0FBQWdWLFNBQUEsQ0FBQWhGLEVBQUEsR0FBQWdGLFNBQUE7Y0FJbkRFLFdBQVcsR0FBR0QsV0FBVyxHQUFHMVgsU0FBUztjQUNyQ2YsS0FBSyxHQUFBd1ksU0FBQSxDQUFBaEYsRUFBSTtZQUFBO2NBSWIsSUFBS2lGLFdBQVcsS0FBSyxJQUFJLElBQU1BLFdBQVcsS0FBSzFYLFNBQVUsRUFBRTtnQkFFdkQsSUFBSSxDQUFDdUgsT0FBQSxXQUFLLENBQUNxUSxjQUFjLENBQUNGLFdBQVcsQ0FBQyxFQUFFO2tCQUNwQ0MsV0FBVyxHQUFHRCxXQUFXO2tCQUN6QkEsV0FBVyxHQUFHMVgsU0FBUztrQkFDdkJmLEtBQUssR0FBRyxJQUFJSSxLQUFLLENBQUMsdUJBQXVCLENBQUM7OztjQUdqRCxNQUVJcVksV0FBVyxLQUFLLElBQUksSUFBTUEsV0FBVyxLQUFLMVgsU0FBVTtnQkFBQXlYLFNBQUEsQ0FBQXJYLElBQUE7Z0JBQUE7Y0FBQTtjQUcvQytMLGtCQUFrQixHQUFHO2dCQUN2Qm1FLHFCQUFxQixFQUFyQkE7ZUFDSDtjQUNELElBQUlvSCxXQUFXLENBQUNqUixLQUFLLENBQUNoTCxjQUFjLENBQUMsb0JBQW9CLENBQUMsRUFBRTtnQkFDeERvYyxPQUFPLEdBQUd0USxPQUFBLFdBQUssQ0FBQ3VRLFlBQVksQ0FBQ0osV0FBVyxFQUFFO2tCQUFDdkwsa0JBQWtCLEVBQWxCQTtnQkFBa0IsQ0FBQyxDQUFDO2VBQ2xFLE1BQU07Z0JBQ0gwTCxPQUFPLEdBQUdILFdBQVc7O2NBR3pCO2NBQUFELFNBQUEsQ0FBQXJYLElBQUE7Y0FDSSxPQUFNLElBQUksQ0FBQzRMLFlBQVksQ0FBQ25ELFVBQVUsRUFBQ2dQLE9BQU8sRUFBRXJNLEtBQUssRUFBRVUsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRSxJQUFJLENBQUM7WUFBQTtjQUFBc0wsU0FBQSxDQUFBclgsSUFBQTtjQUFBO1lBQUE7Y0FJeEYsSUFBSXNYLFdBQVcsS0FBSzFYLFNBQVMsRUFBRTtnQkFFM0IyUixxQkFBcUIsSUFDakJBLHFCQUFxQixDQUFDbkcsS0FBSyxFQUFFVSxNQUFNLEVBQUV5TCxXQUFXLEVBQUUsU0FBUyxFQUFFMVksS0FBSyxDQUFDO2VBRTFFLE1BQU07Z0JBQUU7Z0JBRUwwUyxxQkFBcUIsSUFDakJBLHFCQUFxQixDQUFDbkcsS0FBSyxFQUFFVSxNQUFNLEVBQUV5TCxXQUFXLEVBQUUsU0FBUyxFQUFFLElBQUl0WSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBRTFGaVMsb0JBQW9CLENBQUM5RixLQUFLLENBQUM7O1lBRTlCO1lBQUE7Y0FBQSxPQUFBaU0sU0FBQSxDQUFBN1UsSUFBQTtVQUFBO1FBQUEsR0FBQW1WLFFBQUE7TUFBQSxDQUlSOztJQUVEO0lBQ0E7RUFBQTtJQUFBcGMsR0FBQTtJQUFBRSxLQUFBLEVBQ1EsU0FBQXlRLG9CQUFvQnpELFVBQVUsRUFBRTJDLEtBQUssRUFBRXBCLGtCQUFrQjtNQUU3RCxJQUFNNE4sVUFBVSxHQUNYLENBQUN2VCxLQUFLLENBQUNDLE9BQU8sQ0FBQzhHLEtBQUssQ0FBQyxHQUNsQixDQUFDQSxLQUFLLENBQUMsR0FDUEEsS0FBSztNQUViLElBQUF5TSxzQkFBQSxHQUFzQyxJQUFJLENBQUM5UCxlQUFlLENBQUNjLEdBQUcsQ0FBQ0osVUFBVSxDQUFDO1FBQWxFRSxnQkFBZ0IsR0FBQWtQLHNCQUFBLENBQWhCbFAsZ0JBQWdCO1FBQUVHLE9BQU8sR0FBQStPLHNCQUFBLENBQVAvTyxPQUFPO01BRWpDLElBQVFqQixlQUFlLEdBQUssSUFBSSxDQUF4QkEsZUFBZTtNQUV2QixJQUFRNEUscUJBQXFCLEdBQUssSUFBSSxDQUE5QkEscUJBQXFCO01BRTdCLElBQU1xTCxVQUFVLEdBQUcsRUFBRTtNQUFBLElBQUFDLFVBQUEsR0FBQXhULDBCQUFBLENBRURxVCxVQUFVO1FBQUFJLE1BQUE7TUFBQTtRQUE5QixLQUFBRCxVQUFBLENBQUFuVCxDQUFBLE1BQUFvVCxNQUFBLEdBQUFELFVBQUEsQ0FBQWxULENBQUEsSUFBQW5GLElBQUEsR0FBZ0M7VUFBQSxJQUFyQjBMLE9BQUssR0FBQTRNLE1BQUEsQ0FBQXZjLEtBQUE7VUFFWixJQUFNcVEsTUFBTSxHQUFHbkQsZ0JBQWdCLENBQUNFLEdBQUcsQ0FBQ3VDLE9BQUssQ0FBQztVQUUxQyxJQUFJVSxNQUFNLEtBQUtsTSxTQUFTLEVBQUUsU0FBUSxDQUFDO1VBRW5Da1ksVUFBVSxDQUFDcFgsSUFBSSxDQUFDO1lBQUMwSyxLQUFLLEVBQUxBLE9BQUs7WUFBQ1UsTUFBTSxFQUFOQTtVQUFNLENBQUMsQ0FBQztVQUMvQixJQUFBbU0scUJBQUEsR0FBd0JwUSxlQUFlLENBQUNnQixHQUFHLENBQUNpRCxNQUFNLENBQUM7WUFBM0NVLFdBQVcsR0FBQXlMLHFCQUFBLENBQVh6TCxXQUFXO1VBRW5CQyxxQkFBcUIsQ0FBQ0QsV0FBVyxFQUFDVixNQUFNLENBQUM7VUFFekNqRSxlQUFlLFVBQU8sQ0FBQ2lFLE1BQU0sQ0FBQztVQUM5QmhELE9BQU8sVUFBTyxDQUFDZ0QsTUFBTSxDQUFDO1VBQ3RCbkQsZ0JBQWdCLFVBQU8sQ0FBQ3lDLE9BQUssQ0FBQzs7TUFFakMsU0FBQWhQLEdBQUE7UUFBQTJiLFVBQUEsQ0FBQWpULENBQUEsQ0FBQTFJLEdBQUE7TUFBQTtRQUFBMmIsVUFBQSxDQUFBL1MsQ0FBQTtNQUFBO01BRURnRixrQkFBa0IsSUFBSUEsa0JBQWtCLENBQUM4TixVQUFVLENBQUM7SUFFeEQ7SUFzQkE7RUFBQTtJQUFBdmMsR0FBQTtJQUFBRSxLQUFBLEVBQ1EsU0FBQTJRLFVBQVVOLE1BQU07TUFFcEIsT0FBTyxJQUFJLENBQUNqRSxlQUFlLENBQUMySixHQUFHLENBQUMxRixNQUFNLENBQUM7SUFFM0M7RUFBQztJQUFBdlEsR0FBQTtJQUFBRSxLQUFBLEVBRU8sU0FBQTRRLGtCQUFrQlAsTUFBTTtNQUU1QixJQUFJLElBQUksQ0FBQ00sU0FBUyxDQUFDTixNQUFNLENBQUMsRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQ2pFLGVBQWUsQ0FBQ2dCLEdBQUcsQ0FBQ2lELE1BQU0sQ0FBQzs7SUFHL0M7RUFBQztFQUFBLE9BQUF0RSxRQUFBO0FBQUE7QUFsdUNMdk0sa0JBQUEsR0FBQXVNLFFBQUE7QUFzdUNBO0FBRUE7QUFDQTtBQUNBO0FBRUEsSUFBTXdQLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBZ0JBLENBQUk1TCxLQUFLLEVBQUVVLE1BQU0sRUFBSTtFQUV2QyxJQUFNaUwsVUFBVSxHQUFHLElBQUF6UCxzQkFBQSxDQUFBNFEsb0JBQW9CLEdBQUU7RUFFekMsSUFBTUMsU0FBUyxHQUFHcEIsVUFBVSxDQUFDcUIsT0FBTztFQUNwQ0QsU0FBUyxDQUFDRSxLQUFLLENBQUNDLFFBQVEsR0FBRyxRQUFRO0VBRW5DSCxTQUFTLENBQUNJLE9BQU8sQ0FBQ25iLElBQUksR0FBRyxpQkFBaUI7RUFDMUMrYSxTQUFTLENBQUNJLE9BQU8sQ0FBQ25OLEtBQUssR0FBR0EsS0FBSztFQUMvQitNLFNBQVMsQ0FBQ0ksT0FBTyxDQUFDQyxXQUFXLEdBQUcxTSxNQUFNO0VBRXRDLE9BQU9pTCxVQUFVO0FBRXJCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vc3JjL3BvcnRhbGNhY2hlL2NhY2hlQVBJLnRzeD9lZGE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNhY2hlaGFuZGxlci50c3hcbi8vIGNvcHlyaWdodCAoYykgMjAxOS0yMDIzIEhlbnJpayBCZWNobWFubiwgVG9yb250bywgTGljZW5jZTogTUlUXG5cbi8qXG4gICAgVGhpcyBtb2R1bGUgbWFuYWdlcyB0aGUgSW5maW5pdGVHcmlkU2Nyb2xsZXIgbGltaXRlZCAoc3BhcnNlKSBjYWNoZS4gSXQgYWxzbyBwcm92aWRlcyBzdXBwb3J0IGZvciBcbiAgICBzZXJ2aWNlcyB3aGljaCBhbGxvdyB0aGUgaG9zdCB0byBhY3RpdmVseSBtYW5hZ2UgbWFueSBhc3BlY3RzIG9mIHRoZSBjYWNoZS4gU2VlIGRvY3VtZW50YXRpb25cbiAgICBhYm91dCB0aGUgdXNlciBmdW5jdGlvbnNDYWxsYmFjayBjYWxsYmFjayBmb3IgZGV0YWlscy4gVGhlIGNhY2hlTWF4IHByb3BlcnR5IGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGVcbiAgICBtYXhpbXVtIGRldmljZSBtZW1vcnkgY29uc3VtcHRpb24gb2YgdGhlIGNhY2hlLlxuXG4gICAgVGhlIGluZmluaXRlIGdyaWQgc2Nyb2xsZXIgc3RvcmVzIHVzZXIgY2VsbCBjb250ZW50IChjb21wb25lbnRzKSBpbiBhIGNlbnRyYWwgaGlkZGVuIGNhY2hlLCBcbiAgICBmcm9tIHdoZW5jZSB0aGUgY29tcG9uZW50cyBhcmUgcHVsbGVkIGludG8gdGhlIHJlbGV2YW50IENlbGxGcmFtZXMgZm9yIGRpc3BsYXkuIFRoZSB1c2VyIGNvbXBvbmVudHMgYXJlIFxuICAgIHN0b3JlZCBpbiBSZWFjdCBwb3J0YWxzLCB3aXRoIGVhY2ggcG9ydGFsIGluc3RhbnRpYXRlZCBpbiBhIGNvbnRhaW5lciBkaXYgKGRhdGEtdHlwZSA9ICdwb3J0YWx3cmFwcGVyJykuIFxuICAgIFRoZXNlIGNvbnRhaW5lciBkaXZzIGFyZSBwYXJ0IG9mIGEgc3RhbmRhcmQgUmVhY3QgY29tcG9uZW50IGxpc3QgaW4gdGhlIHJlYWwgRE9NLiBUaGUgY29udGFpbmVkIHBvcnRhbHMgXG4gICAgdGhlbXNlbHZlcyBhcmUgbm90IHBhcnQgb2YgdGhlIHJlYWwgRE9NLCBidXQgYXJlIHBhcnQgb2YgUmVhY3QncyB2aXJ0dWFsIERPTS5cblxuICAgIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcG9ydGFscy5odG1sIGZvciBnZW5lcmFsIGluZm9ybWF0aW9uIGFib3V0IFJlYWN0IHBvcnRhbHMuXG4gICAgU2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LXJldmVyc2UtcG9ydGFsIGZvciB0aGUgdXRpbGl0eSB0aGF0IEluZmluaXRlR3JpZFNjcm9sbGVyXG4gICAgdXNlcyB0byBtYW5hZ2UgcG9ydGFscy5cblxuICAgIFRoaXMgY2FjaGluZyBoYXMgbWFueSBhZHZhbnRhZ2VzLCBub3RhYmx5IHRoZSBhYmlsaXR5IHRvIG1vdmUgY2VsbHMgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGVcbiAgICBoZWFkIGFuZCB0YWlsIGdyaWRzIG9mIHRoZSBDcmFkbGUgd2l0aG91dCBsb3Npbmcgc3RhdGUsIGFuZCB0aGUgYWJpbGl0eSB0byBtYWludGFpbiBzdGF0ZSBmb3IgXG4gICAgY29tcGxleCBjb21wb25lbnRzIHdoaWNoIG1vdmUgYmV5b25kIHRoZSBzY29wZSBvZiB0aGUgY29udGVudCBvZiB0aGUgQ3JhZGxlLiBcblxuICAgIFRoZXJlIGlzIGFuIGltcG9ydGFudCBzaWRlIGVmZmVjdCB0byBjb25zaWRlci4gSW5zdGFudGlhdGVkIGNvbXBvbmVudHMgd2hpY2ggYXJlIHJlbW92ZWQgZnJvbSB0aGUgcmVhbCBET00gXG4gICAgaW50byB0aGUgcG9ydGFsIG9mIHRoZSB2aXJ0dWFsIERPTSBoYXZlIHRoZWlyIHNjcm9sbCBwb3NpdGlvbnMsIHdpZHRoLCBhbmQgaGVpZ2h0IHNldCB0byB6ZXJvLiBUaGVyZWZvcmUgaWYgXG4gICAgY29tcG9uZW50cyByZWx5IG9uIHRoZXNlIHZhbHVlcyBmb3IgY29uZmlndXJhdGlvbiwgdGhleSBtdXN0IGhhdmUgYSB3YXkgb2Ygc3RvcmluZyB0aG9zZSB2YWx1ZXMgaW4gc3RhdGUgXG4gICAgKG5vdGFibHkgdGhlIFNjcm9sbCBQb3MgLSBzY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcCksIHJlY29nbml6aW5nIHdoZW4gdGhlIGNvbXBvbmVudCBjb21lcyBvdXQgb2YgdGhlIHBvcnRhbCBjYWNoZSBcbiAgICBpbnRvIHRoZSByZWFsIERPTSAod2lkdGggYW5kIGhlaWdodCBhcmUgdHlwaWNhbGx5IG5vIGxvbmdlciBib3RoIDApLCBhbmQgcmVzcG9uZGluZyB0byBjaGFuZ2UgaW4gXG4gICAgY2FjaGUgc3RhdGUgYXBwcm9wcmlhdGVseS5cblxuICAgIFRpcHM6XG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgaW4gY2FjaGUgd2hlbiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgPSAwXG4gICAgICAgIC0geW91ciBjb21wb25lbnQgaXMgb3V0IG9mIGNhY2hlIHdoZW4gYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBiYWNrIHRvIG5vcm1hbFxuICAgICAgICAtIGlmIHlvdSBjcmVhdGUgYW4gZW1wdHkgJ3Njcm9sbGVyUHJvcGVydGllcycgcHJvcGVydHkgZm9yIHlvdXIgY29tcG9uZW50LCBDZWxsRnJhbWUgd2lsbFxuICAgICAgICAgICAgc2V0IGl0IHRvIGFuIG9iamVjdCBjb250YWluaW5nIHNjcm9sbGVyUHJvcGVydGllc1JlZiBhbmQgY2VsbEZyYW1lUHJvcGVydGllc1JlZlxuICAgICAgICAtIGlmIHlvdXIgY29tcG9uZW50IGRvZXMgbm90IHNjcm9sbCwgdGhlcmUgc2hvdWxkIGJlIG5vIGlzc3Vlcy5cblxuKi9cblxuLypcblxuICAgIFRPRE9cblxuICAgIC0gbW9kaWZ5IGNsZWFyIGNhY2hlIGZvciBzY3JvbGxlciBzZWxlY3Rpb25cblxuKi9cblxuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFja30gZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IGNyZWF0ZUh0bWxQb3J0YWxOb2RlLCBJblBvcnRhbCB9IGZyb20gJ3JlYWN0LXJldmVyc2UtcG9ydGFsJ1xuXG5pbXBvcnQgQ2FjaGVQYXJ0aXRpb24gZnJvbSAnLi9DYWNoZVBhcnRpdGlvbidcblxuLy8gdGhlIGNhY2hlIGl0c2VsZiBpcyBtYWludGFpbmVkIGluIHRoZSByb290IGluZmluaXRlZ3JpZHNjcm9sbGVyIGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FjaGVBUEkge1xuXG4gICAgY29uc3RydWN0b3IoQ0FDSEVfUEFSVElUSU9OX1NJWkUpIHtcblxuICAgICAgICB0aGlzLkNBQ0hFX1BBUlRJVElPTl9TSVpFID0gQ0FDSEVfUEFSVElUSU9OX1NJWkVcblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2xvYmFsSXRlbUlEID0gMFxuICAgIHByaXZhdGUgZ2xvYmFsUGFydGl0aW9uSUQgPSAwXG5cbiAgICBwcml2YXRlIGl0ZW1NZXRhZGF0YU1hcCA9IG5ldyBNYXAoKVxuXG4gICAgcHJpdmF0ZSBzY3JvbGxlckRhdGFNYXAgPSBuZXcgTWFwKClcblxuICAgIHByaXZhdGUgcGFydGl0aW9uUHJvcHMgPSB7XG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGFNYXA6bmV3IE1hcCgpLFxuICAgICAgICBwYXJ0aXRpb25NYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgcGFydGl0aW9uUmVuZGVyTGlzdDpudWxsLFxuICAgICAgICBwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGU6bnVsbCxcbiAgICAgICAgcGFydGl0aW9uTW9kaWZpZWRTZXQ6IG5ldyBTZXQoKSxcblxuICAgICAgICBwYXJ0aXRpb25QdHI6bnVsbCwgLy8gYWN0aXZlIHBhcnRpdGlvbiwgZm9yIGZvbGxvd3VwXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIENBQ0hFX1BBUlRJVElPTl9TSVpFXG5cbiAgICAvLyBwcml2YXRlIG1lYXN1cmVNZW1vcnkoc291cmNlKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygndXNlZEpTSGVhcFNpemUnLHNvdXJjZSwgcGVyZm9ybWFuY2VbJ21lbW9yeSddWyd1c2VkSlNIZWFwU2l6ZSddKVxuICAgIC8vIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVsgU2Nyb2xsZXIgUmVnaXN0cmF0aW9uICYgTWFpbnRlbmFuY2UgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHRoZSBvbmx5IG1lbWJlciBhY2Nlc3NlZCBkaXJlY3RseS4gQWxsIG90aGVyIGFjY2VzcyBpcyB0aHJvdWdoIHRoZSBmYWNhZGVcbiAgICByZWdpc3RlclNjcm9sbGVyKHNjcm9sbGVySUQpIHtcblxuICAgICAgICB0aGlzLnNjcm9sbGVyRGF0YU1hcC5zZXQoc2Nyb2xsZXJJRCwgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3JhZGxlUGFyYW1ldGVyczpudWxsLFxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXA6IG5ldyBNYXAoKSwgXG4gICAgICAgICAgICAgICAgLy8gc29tZSBwb3J0YWxzIG1heSBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ5IHJlcXVlc3RpZGxlY2FsbGJhY2ssIG5vdCB5ZXQgY3JlYXRlZFxuICAgICAgICAgICAgICAgIGl0ZW1TZXQ6IG5ldyBTZXQoKSwgLy8gZm9yIHNjcm9sbGVySUQgbGltaXRlZCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkU2V0Om5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3Q6bnVsbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIHRoaXMubWVhc3VyZU1lbW9yeSgnUkVHSVNURVInKVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZhY2FkZShzY3JvbGxlcklEKVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGYWNhZGUgPSAoc2Nyb2xsZXJJRCkgPT4ge1xuICAgICAgICBjb25zdCBmYWNhZGUgPSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhbmQgc2V0IGRhdGFcbiAgICAgICAgICAgIGdldCBpbmRleFRvSXRlbUlETWFwKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4VG9JdGVtSURNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEluZGV4VG9JdGVtSURNYXA6KCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAgdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLmluZGV4VG9JdGVtSURNYXBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXRlbVNldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtU2V0OigpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5pdGVtU2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbU1ldGFkYXRhTWFwOnRoaXMuaXRlbU1ldGFkYXRhTWFwLFxuICAgICAgICAgICAgZ2V0IHJlcXVlc3RlZFNldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0ZWRTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJlcXVlc3RlZFNldDooKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5yZXF1ZXN0ZWRTZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgcGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlKGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUoZm4pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlOihmbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlID0gZm5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgY3JhZGxlUGFyYW1ldGVycyhwYXJtcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDcmFkbGVQYXJhbWV0ZXJzKHBhcm1zKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENyYWRsZVBhcmFtZXRlcnM6KHBhcm1zKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLmNyYWRsZVBhcmFtZXRlcnMgPSBwYXJtc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QobGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0KGxpc3QpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0OihsaXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLnBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IGxpc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaW5zdGFuY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKVxuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBnZXRJbnN0YW5jZTooKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIHVuUmVnaXN0ZXJTY3JvbGxlcjooaXRlbVNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuUmVnaXN0ZXJTY3JvbGxlcihzY3JvbGxlcklELCBpdGVtU2V0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlclBhcnRpdGlvblJlcG86KCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBhcnRpdGlvblJlcG8oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlclBvcnRhbExpc3RzOigpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3J0YWxMaXN0cygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJDYWNoZTooKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJDYWNoZShzY3JvbGxlcklEKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYW5nZUNhY2hlTGlzdHNpemU6KG5ld2xpc3RzaXplLCBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VDYWNoZUxpc3RzaXplKHNjcm9sbGVySUQsIG5ld2xpc3RzaXplLCBkZWxldGVMaXN0Q2FsbGJhY2ssIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2spXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2hDYWNoZVRvQ3JhZGxlOihjcmFkbGVJbmRleExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQ2FjaGVUb0NyYWRsZShzY3JvbGxlcklELCBjcmFkbGVJbmRleExpc3QsIGRlbGV0ZUxpc3RDYWxsYmFjaylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJlQ2FjaGVUb01heDooY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZUNhY2hlVG9NYXgoc2Nyb2xsZXJJRCwgY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nOihjYWNoZU1heCwgY3JhZGxlTGlzdExlbmd0aCwgTUFYX0NBQ0hFX09WRVJfUlVOKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3VhcmRBZ2FpbnN0UnVuYXdheUNhY2hpbmcoc2Nyb2xsZXJJRCwgY2FjaGVNYXgsIGNyYWRsZUxpc3RMZW5ndGgsIE1BWF9DQUNIRV9PVkVSX1JVTilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVsb2FkOihmaW5hbENhbGxiYWNrLCBudWxsSXRlbVNldE1heExpc3RzaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlbG9hZChzY3JvbGxlcklELCBmaW5hbENhbGxiYWNrLCBudWxsSXRlbVNldE1heExpc3RzaXplKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENhY2hlSW5kZXhNYXA6KCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhY2hlSW5kZXhNYXAoc2Nyb2xsZXJJRClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDcmFkbGVJbmRleE1hcDooY3JhZGxlSW5kZXhMaXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3JhZGxlSW5kZXhNYXAoc2Nyb2xsZXJJRCwgY3JhZGxlSW5kZXhMaXN0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENhY2hlSXRlbU1hcDooKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVJdGVtTWFwKHNjcm9sbGVySUQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZUluZGV4Oih0b2xvd2luZGV4LCBmcm9tbG93aW5kZXgsIGZyb21oaWdoaW5kZXggKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUluZGV4KHNjcm9sbGVySUQsIHRvbG93aW5kZXgsIGZyb21sb3dpbmRleCwgZnJvbWhpZ2hpbmRleClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnNlcnRSZW1vdmVJbmRleDooaW5kZXgsIGhpZ2hyYW5nZSwgaW5jcmVtZW50LCBsaXN0c2l6ZSApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRSZW1vdmVJbmRleChzY3JvbGxlcklELCBpbmRleCwgaGlnaHJhbmdlLCBpbmNyZW1lbnQsIGxpc3RzaXplIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclBlbmRpbmdQb3J0YWw6KGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJQZW5kaW5nUG9ydGFsKHNjcm9sbGVySUQsIGluZGV4KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVucmVnaXN0ZXJQZW5kaW5nUG9ydGFsOihpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucmVnaXN0ZXJQZW5kaW5nUG9ydGFsKHNjcm9sbGVySUQsIGluZGV4KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE5ld0l0ZW1JRDooKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV3SXRlbUlEKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROZXdPckV4aXN0aW5nSXRlbUlEOihpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5ld09yRXhpc3RpbmdJdGVtSUQoc2Nyb2xsZXJJRCwgaW5kZXgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsOihjb21wb25lbnQsIGluZGV4LCBpdGVtSUQsIHNjcm9sbGVyUHJvcGVydGllcywgaXNQcmVsb2FkID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb3J0YWwoc2Nyb2xsZXJJRCwgY29tcG9uZW50LCBpbmRleCwgaXRlbUlELCBzY3JvbGxlclByb3BlcnRpZXMsIGlzUHJlbG9hZCA9IGZhbHNlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZVBvcnRhbEJ5SW5kZXg6KGluZGV4LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVQb3J0YWxCeUluZGV4KHNjcm9sbGVySUQsIGluZGV4LCBkZWxldGVMaXN0Q2FsbGJhY2spXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHlQb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3Q6KCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0KHNjcm9sbGVySUQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzUG9ydGFsOihpdGVtSUQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNQb3J0YWwoaXRlbUlEKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvcnRhbE1ldGFkYXRhOihpdGVtSUQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQb3J0YWxNZXRhZGF0YShpdGVtSUQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFjYWRlXG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1blJlZ2lzdGVyU2Nyb2xsZXIgPSAoc2Nyb2xsZXJJRCwgaXRlbVNldCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJEYXRhTWFwLCBpdGVtTWV0YWRhdGFNYXAgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIHNjcm9sbGVyRGF0YU1hcC5zaXplID09IDEgKSByZXR1cm4gLy8gYWxyZWFkeSBnZXR0aW5nIGRpc21hbnRsZWQ7IGF2b2lkIGNvbmZsaWN0XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VucmVnaXN0ZXIgc2Nyb2xsZXJJRCwgaXRlbVNldCcsc2Nyb2xsZXJJRCwgaXRlbVNldClcblxuICAgICAgICBzY3JvbGxlckRhdGFNYXAuZGVsZXRlKHNjcm9sbGVySUQpXG4gICAgICAgIGl0ZW1TZXQuZm9yRWFjaCgoaXRlbUlEKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcnRpdGlvbklEIH0gPSBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFydGl0aW9uUG9ydGFsKHBhcnRpdGlvbklELGl0ZW1JRClcbiAgICAgICAgICAgIGl0ZW1NZXRhZGF0YU1hcC5kZWxldGUoaXRlbUlEKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcbiAgICAgICAgLy8gdGhpcy5tZWFzdXJlTWVtb3J5KCdVTlJFR0lTVEVSJylcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVsgQ0FDSEUgUEFSVElUSU9OIE1BTkFHRU1FTlQgXT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHBhcnRpdGlvbnMgYXJlIGFkZGVkIGJ1dCBub3QgcmVtb3ZlZFxuXG4gICAgcHJpdmF0ZSByZW5kZXJQYXJ0aXRpb25SZXBvID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uUmVuZGVyTGlzdCA9IEFycmF5LmZyb20odGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25NYXAudmFsdWVzKCkpXG5cbiAgICAgICAgdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUodGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25SZW5kZXJMaXN0KVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRQYXJ0aXRpb24gPSAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSUQgPSB0aGlzLmdsb2JhbFBhcnRpdGlvbklEKytcbiAgICAgICAgdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5zZXQocGFydGl0aW9uSUQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9ydGFsTWFwOm5ldyBNYXAoKSwgXG4gICAgICAgICAgICAgICAgbWFwY291bnQ6MCwgLy8gcG9ydGFsTWFwIHVwZGF0ZSBjYW4gYmUgYXN5bmMsIHNvIG1hcGNvdW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBwb3J0YWxSZW5kZXJMaXN0Om51bGwsIFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOmZhbHNlLFxuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlOm51bGwsXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uSUQsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHJlc29sdmVmdW5jID0ge1xuICAgICAgICAgICAgY3VycmVudDpudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVmdW5jLmN1cnJlbnQgPSByZXNvbHZlXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIHJlc29sdmVmdW5jLmN1cnJlbnQocGFydGl0aW9uSUQpXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uTWFwLnNldChwYXJ0aXRpb25JRCxcbiAgICAgICAgICAgIDxDYWNoZVBhcnRpdGlvbiBcbiAgICAgICAgICAgICAgICBrZXkgPSB7cGFydGl0aW9uSUR9IFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvblByb3BzID0ge3RoaXMucGFydGl0aW9uUHJvcHN9IFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbklEID0ge3BhcnRpdGlvbklEfSBcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHsgY2FsbGJhY2sgfSAvPilcblxuICAgICAgICB0aGlzLnJlbmRlclBhcnRpdGlvblJlcG8oKVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGZpbmRQYXJ0aXRpb25XaXRoUm9vbSgpIHtcblxuICAgICAgICBjb25zdCB7IENBQ0hFX1BBUlRJVElPTl9TSVpFIH0gPSB0aGlzXG5cbiAgICAgICAgY29uc3QgeyBwYXJ0aXRpb25NZXRhZGF0YU1hcCB9ID0gdGhpcy5wYXJ0aXRpb25Qcm9wc1xuICAgICAgICBsZXQgeyBwYXJ0aXRpb25QdHIgfSA9IHRoaXMucGFydGl0aW9uUHJvcHNcblxuICAgICAgICBsZXQgcGFydGl0aW9uTWV0YWRhdGFcbiAgICAgICAgaWYgKHBhcnRpdGlvblB0ciAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YSA9IHBhcnRpdGlvbk1ldGFkYXRhTWFwLmdldChwYXJ0aXRpb25QdHIpXG5cbiAgICAgICAgICAgIGlmIChwYXJ0aXRpb25NZXRhZGF0YS5tYXBjb3VudCA8IENBQ0hFX1BBUlRJVElPTl9TSVpFKSB7XG5cbiAgICAgICAgICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5tYXBjb3VudCArPSAxIFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aXRpb25QdHJcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0aXRpb25QdHIgPSBudWxsXG4gICAgICAgIGZvciAoY29uc3QgW3BhcnRpdGlvbklELCBwYXJ0aXRpb25NZXRhZGF0YV0gb2YgcGFydGl0aW9uTWV0YWRhdGFNYXApIHtcblxuICAgICAgICAgICAgaWYgKHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50IDwgQ0FDSEVfUEFSVElUSU9OX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5tYXBjb3VudCArPSAxIFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvblB0ciA9IHBhcnRpdGlvbklEXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpdGlvblB0ciA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICBwYXJ0aXRpb25QdHIgPSBhd2FpdCB0aGlzLmFkZFBhcnRpdGlvbigpXG4gICAgICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YSA9IHBhcnRpdGlvbk1ldGFkYXRhTWFwLmdldChwYXJ0aXRpb25QdHIpXG4gICAgICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5tYXBjb3VudCArPSAxIFxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcnRpdGlvblByb3BzLnBhcnRpdGlvblB0ciA9IHBhcnRpdGlvblB0clxuXG4gICAgICAgIHJldHVybiBwYXJ0aXRpb25QdHJcblxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkUGFydGl0aW9uUG9ydGFsID0gKHBhcnRpdGlvbklELCBpdGVtSUQsIHBvcnRhbCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEucG9ydGFsTWFwLnNldChpdGVtSUQscG9ydGFsKVxuXG4gICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uTW9kaWZpZWRTZXQuYWRkKHBhcnRpdGlvbklEKVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVQYXJ0aXRpb25Qb3J0YWwgPSAocGFydGl0aW9uSUQsIGl0ZW1JRCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEucG9ydGFsTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgIHBhcnRpdGlvbk1ldGFkYXRhLm1hcGNvdW50IC09IDEgXG5cbiAgICAgICAgdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25Nb2RpZmllZFNldC5hZGQocGFydGl0aW9uSUQpXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlclBhcnRpdGlvbiA9IChwYXJ0aXRpb25JRCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbk1ldGFkYXRhID0gdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25NZXRhZGF0YU1hcC5nZXQocGFydGl0aW9uSUQpXG5cbiAgICAgICAgaWYgKCFwYXJ0aXRpb25NZXRhZGF0YSkgcmV0dXJuXG5cbiAgICAgICAgcGFydGl0aW9uTWV0YWRhdGEucG9ydGFsUmVuZGVyTGlzdCA9ICBBcnJheS5mcm9tKHBhcnRpdGlvbk1ldGFkYXRhLnBvcnRhbE1hcC52YWx1ZXMoKSlcblxuICAgICAgICAvLyBpZiBmb3JjZVVwZGF0ZSBoYXMgbm90IHlldCBiZWVuIGFzc2lnbmVkLCBpdCBpcyBpbiB0aGUgd29ya3MgZnJvbSBmaXJzdCBjYWxsIG9mIHBhcnRpdGlvblxuICAgICAgICBwYXJ0aXRpb25NZXRhZGF0YS5mb3JjZVVwZGF0ZSAmJiBwYXJ0aXRpb25NZXRhZGF0YS5mb3JjZVVwZGF0ZShwYXJ0aXRpb25NZXRhZGF0YS5wb3J0YWxSZW5kZXJMaXN0KVxuXG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlIG9mIHRoZSBDYWNoZVBhcnRpdGlvbiBjb21wb25lbnQgb2YgdGhlIHNjcm9sbGVyIHRvIHRyaWdnZXIgcmVuZGVyXG4gICAgcHJpdmF0ZSByZW5kZXJQb3J0YWxMaXN0cyA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IHBhcnRpdGlvbk1vZGlmaWVkU2V0IH0gPSB0aGlzLnBhcnRpdGlvblByb3BzXG5cbiAgICAgICAgaWYgKHBhcnRpdGlvbk1vZGlmaWVkU2V0LnNpemUpIHtcblxuICAgICAgICAgICAgcGFydGl0aW9uTW9kaWZpZWRTZXQuZm9yRWFjaCgocGFydGl0aW9uSUQpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGFydGl0aW9uKHBhcnRpdGlvbklEKVxuXG4gICAgICAgICAgICB9KSAgICAgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLnBhcnRpdGlvblByb3BzLnBhcnRpdGlvbk1vZGlmaWVkU2V0LmNsZWFyKClcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyQ2FjaGUgPSAoc2Nyb2xsZXJJRCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJEYXRhTWFwLCBpdGVtTWV0YWRhdGFNYXAgfSA9IHRoaXNcbiAgICAgICAgY29uc3QgZGF0YW1hcCA9IHNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRClcbiAgICAgICAgY29uc3Qge2luZGV4VG9JdGVtSURNYXAsIGl0ZW1TZXQsIHJlcXVlc3RlZFNldH0gPSBkYXRhbWFwXG5cbiAgICAgICAgaWYgKHNjcm9sbGVyRGF0YU1hcC5zaXplID09IDEpIHtcblxuICAgICAgICAgICAgLy8gY2xlYXIgYmFzZSBkYXRhXG4gICAgICAgICAgICBpdGVtTWV0YWRhdGFNYXAuY2xlYXIoKVxuXG4gICAgICAgICAgICAvLyBjbGVhciBjYWNoZSBwYXJ0aXRpb25zXG4gICAgICAgICAgICB0aGlzLnBhcnRpdGlvblByb3BzLnBhcnRpdGlvbk1ldGFkYXRhTWFwLmNsZWFyKClcbiAgICAgICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uTWFwLmNsZWFyKClcbiAgICAgICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uUmVuZGVyTGlzdCA9IFtdXG4gICAgICAgICAgICB0aGlzLnBhcnRpdGlvblByb3BzLnBhcnRpdGlvbk1vZGlmaWVkU2V0LmNsZWFyKClcbiAgICAgICAgICAgIHRoaXMucGFydGl0aW9uUHJvcHMucGFydGl0aW9uUHRyID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5wYXJ0aXRpb25Qcm9wcy5wYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUobnVsbClcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpdGVtU2V0LmZvckVhY2goKGl0ZW1JRCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGl0aW9uSUQgfSA9IGl0ZW1NZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFydGl0aW9uUG9ydGFsKHBhcnRpdGlvbklELGl0ZW1JRClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhUb0l0ZW1JRE1hcC5jbGVhcigpXG4gICAgICAgIGl0ZW1TZXQuY2xlYXIoKVxuICAgICAgICByZXF1ZXN0ZWRTZXQuY2xlYXIoKVxuXG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT1bIFJFUE9TSVRPUlkgQU5EIExJU1QgTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVsgYmFzaWMgb3BlcmF0aW9ucyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNhbGxlZCBmcm9tIENyYWRsZS5udWxsSXRlbVNldE1heExpc3RzaXplLCBhbmQgc2VydmljZUhhbmRsZXIuc2V0TGlzdHNpemVcbiAgICBwcml2YXRlIGNoYW5nZUNhY2hlTGlzdHNpemUgPSAoc2Nyb2xsZXJJRCwgbmV3bGlzdHNpemUsIGRlbGV0ZUxpc3RDYWxsYmFjaywgY2hhbmdlTGlzdHNpemVDYWxsYmFjaykgPT4ge1xuXG4gICAgICAgIC8vIG1hdGNoIGNhY2hlIHRvIG5ld2xpc3RzaXplXG4gICAgICAgIGNvbnN0IHBvcnRhbEluZGV4TWFwOk1hcDxudW1iZXIsbnVtYmVyPiA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5pbmRleFRvSXRlbUlETWFwXG4gICAgICAgIGNvbnN0IG1hcGtleXNMaXN0ID0gQXJyYXkuZnJvbShwb3J0YWxJbmRleE1hcC5rZXlzKCkpXG4gICAgICAgIG1hcGtleXNMaXN0LnNvcnQoKGEsYikgPT4gYSAtIGIpXG5cbiAgICAgICAgY29uc3QgaGlnaGVzdGluZGV4ID0gbWFwa2V5c0xpc3QuYXQoLTEpXG5cbiAgICAgICAgaWYgKGhpZ2hlc3RpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSkpIHsgLy8gcGFyZSB0aGUgY2FjaGVcblxuICAgICAgICAgICAgY29uc3QgcGFyZWxpc3QgPSBtYXBrZXlzTGlzdC5maWx0ZXIoKGluZGV4KT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+IChuZXdsaXN0c2l6ZSAtMSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsQnlJbmRleChzY3JvbGxlcklELCBwYXJlbGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrICYmIGNoYW5nZUxpc3RzaXplQ2FsbGJhY2sobmV3bGlzdHNpemUpXG5cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBjYWNoZSBzaXplIGxpbWl0IGVuZm9yY2VlbnQgXS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHJpdmF0ZSBtYXRjaENhY2hlVG9DcmFkbGUgPSAoc2Nyb2xsZXJJRCwgY3JhZGxlSW5kZXhMaXN0LCBkZWxldGVMaXN0Q2FsbGJhY2spID0+IHtcblxuICAgICAgICBjb25zdCBtYXBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRCkuaW5kZXhUb0l0ZW1JRE1hcC5rZXlzKCkpXG5cbiAgICAgICAgY29uc3QgZGVsa2V5cyA9IG1hcGtleXMuZmlsdGVyKGtleSA9PiAhY3JhZGxlSW5kZXhMaXN0LmluY2x1ZGVzKGtleSkpXG5cbiAgICAgICAgaWYgKGRlbGtleXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUG9ydGFsQnlJbmRleChzY3JvbGxlcklELCBkZWxrZXlzLCBkZWxldGVMaXN0Q2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyZUNhY2hlVG9NYXggPSAoc2Nyb2xsZXJJRCwgY2FjaGVNYXgsIGNyYWRsZUluZGV4TGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbW9kZWxMZW5ndGggPSBjcmFkbGVJbmRleExpc3QubGVuZ3RoXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5lZWQgZm9yIHBhcmluZ1xuICAgICAgICBpZiAoKCFjYWNoZU1heCkgfHwgKCFtb2RlbExlbmd0aCkpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KG1vZGVsTGVuZ3RoLCBjYWNoZU1heClcblxuICAgICAgICBjb25zdCBwb3J0YWxJbmRleE1hcDpNYXA8bnVtYmVyLCBudW1iZXI+ID0gdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLmluZGV4VG9JdGVtSURNYXAsXG4gICAgICAgICAgICByZXF1ZXN0ZWRTZXQ6U2V0PG51bWJlcj4gPSB0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRCkucmVxdWVzdGVkU2V0XG5cbiAgICAgICAgaWYgKChwb3J0YWxJbmRleE1hcC5zaXplICsgcmVxdWVzdGVkU2V0LnNpemUpIDw9IG1heCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgLy8gc29ydCB0aGUgbWFwIGtleXNcbiAgICAgICAgY29uc3QgbWFwa2V5c2xpc3QgPSBBcnJheS5mcm9tKHBvcnRhbEluZGV4TWFwLmtleXMoKSksXG4gICAgICAgICAgICByZXF1ZXN0ZWRrZXlzID0gQXJyYXkuZnJvbShyZXF1ZXN0ZWRTZXQua2V5cygpKVxuXG4gICAgICAgIGNvbnN0IG1hcGtleXMgPSBbLi4ubWFwa2V5c2xpc3QsLi4ucmVxdWVzdGVka2V5c11cblxuICAgICAgICBtYXBrZXlzLnNvcnQoKGEsYikgPT4gYSAtIGIpXG5cbiAgICAgICAgLy8gZ2V0IG51bWJlciB0byBwYXJlXG4gICAgICAgIGNvbnN0IG1hcExlbmd0aCA9IG1hcGtleXMubGVuZ3RoLFxuICAgICAgICAgICAgcGFyZWNvdW50ID0gbWFwTGVuZ3RoIC0gbWF4XG5cbiAgICAgICAgLy8gZGlzdHJpYnV0ZSBwYXJpbmcgcHJvcG9ydGlvbmFsbHkgYXQgZnJvbnQgYW5kIGJhY2tcbiAgICAgICAgY29uc3QgaGVhZGluZGV4ID0gY3JhZGxlSW5kZXhMaXN0WzBdLFxuICAgICAgICAgICAgdGFpbGluZGV4ID0gY3JhZGxlSW5kZXhMaXN0W21vZGVsTGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBoZWFkcG9zID0gbWFwa2V5cy5pbmRleE9mKGhlYWRpbmRleCksXG4gICAgICAgICAgICB0YWlscG9zID0gbWFwa2V5cy5pbmRleE9mKHRhaWxpbmRleClcblxuICAgICAgICBjb25zdCBoZWFkcm9vbSA9IGhlYWRwb3MsXG4gICAgICAgICAgICB0YWlscm9vbSA9IG1hcExlbmd0aCAtICh0YWlscG9zICsgMSksXG4gICAgICAgICAgICBwYXJlcm9vbSA9IGhlYWRyb29tICsgdGFpbHJvb21cblxuICAgICAgICBjb25zdCBoZWFkcGFyZWNvdW50ID0gTWF0aC5mbG9vcigoaGVhZHJvb20vcGFyZXJvb20pKnBhcmVjb3VudCksXG4gICAgICAgICAgICB0YWlscGFyZWNvdW50ID0gcGFyZWNvdW50IC0gaGVhZHBhcmVjb3VudFxuXG4gICAgICAgIC8vIGNvbGxlY3QgaW5kZXhlcyB0byBwYXJlXG4gICAgICAgIGNvbnN0IGhlYWRsaXN0ID0gbWFwa2V5cy5zbGljZSgwLGhlYWRwYXJlY291bnQpLFxuICAgICAgICAgICAgdGFpbGxpc3QgPSBtYXBrZXlzLnNsaWNlKG1hcExlbmd0aCAtIHRhaWxwYXJlY291bnQpXG5cbiAgICAgICAgY29uc3QgZGVsTGlzdCA9IFsuLi5oZWFkbGlzdCwuLi50YWlsbGlzdF1cblxuICAgICAgICB0aGlzLmRlbGV0ZVBvcnRhbEJ5SW5kZXgoc2Nyb2xsZXJJRCwgZGVsTGlzdCwgZGVsZXRlTGlzdENhbGxiYWNrKVxuXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nID0gKHNjcm9sbGVySUQsIGNhY2hlTWF4LCBjcmFkbGVMaXN0TGVuZ3RoLCBNQVhfQ0FDSEVfT1ZFUl9SVU4pID0+IHtcblxuICAgICAgICBpZiAoIWNhY2hlTWF4KSByZXR1cm4gZmFsc2VcblxuICAgICAgICBjb25zdCB7IGluZGV4VG9JdGVtSURNYXAsIHJlcXVlc3RlZFNldCB9ID0gdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpXG5cbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoY3JhZGxlTGlzdExlbmd0aCwgY2FjaGVNYXgpXG5cbiAgICAgICAgaWYgKChpbmRleFRvSXRlbUlETWFwLnNpemUgKyByZXF1ZXN0ZWRTZXQuc2l6ZSkgPD0gKChtYXgpICogTUFYX0NBQ0hFX09WRVJfUlVOKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWyBwcmVsb2FkIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHJpdmF0ZSBwcmVsb2FkID0gKHNjcm9sbGVySUQsIGZpbmFsQ2FsbGJhY2ssIG51bGxJdGVtU2V0TWF4TGlzdHNpemUpID0+IHtcblxuICAgICAgICBjb25zdCB7IGNyYWRsZVBhcmFtZXRlcnMgfSA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKVxuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIH0gPSBjcmFkbGVQYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZUhhbmRsZXIsIHNlcnZpY2VIYW5kbGVyIH0gPSBjcmFkbGVQYXJhbWV0ZXJzLmhhbmRsZXJzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzID0gY3JhZGxlUGFyYW1ldGVycy5jcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBjcmFkbGVJbnRlcm5hbFByb3BlcnRpZXMgPSBjcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUludGVybmFsUHJvcGVydGllc1JlZi5jdXJyZW50XG5cbiAgICAgICAgY29uc3QgeyBnZXRJdGVtLCBjYWNoZU1heCB9ID0gY3JhZGxlSW5oZXJpdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgIGxpc3RzaXplID0gY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzLnZpcnR1YWxMaXN0UHJvcGVydGllcy5zaXplXG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuXG4gICAgICAgIGxldCBjYWNoZVNpemUgPSBjYWNoZU1heCA/PyAwXG5cbiAgICAgICAgY2FjaGVTaXplID0gTWF0aC5taW4oY2FjaGVTaXplLCBsaXN0c2l6ZSlcblxuICAgICAgICBjb25zdCBwcmVsb2Fkc2l6ZSA9IFxuICAgICAgICAgICAgY2FjaGVTaXplP1xuICAgICAgICAgICAgICAgIGNhY2hlU2l6ZTpcbiAgICAgICAgICAgICAgICBsaXN0c2l6ZVxuXG4gICAgICAgIGNvbnN0IGJyZWFrbG9vcCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6ZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heExpc3RzaXplSW50ZXJydXB0ID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICBicmVha2xvb3AuY3VycmVudCA9IHRydWVcbiAgICAgICAgICAgIG51bGxJdGVtU2V0TWF4TGlzdHNpemUoaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGVIYW5kbGVyLmlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGluZGV4VG9JdGVtSURNYXAgPSB0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRCkuaW5kZXhUb0l0ZW1JRE1hcFxuXG4gICAgICAgICAgICBjb25zdCB7IHByZWxvYWRJbmRleENhbGxiYWNrLCBpdGVtRXhjZXB0aW9uQ2FsbGJhY2sgfSA9IHNlcnZpY2VIYW5kbGVyLmNhbGxiYWNrc1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJlbG9hZHNpemU7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgICAgIHByZWxvYWRJbmRleENhbGxiYWNrICYmIHByZWxvYWRJbmRleENhbGxiYWNrKGluZGV4KVxuICAgICAgICAgICAgICAgIGlmICghaW5kZXhUb0l0ZW1JRE1hcC5oYXMoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucHJlbG9hZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMaXN0c2l6ZUludGVycnVwdFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChicmVha2xvb3AuY3VycmVudCkgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcykudGhlbihcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0cygpXG4gICAgICAgICAgICAgICAgZmluYWxDYWxsYmFjaygpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1bIFNOQVBTSE9UUyBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcHJpdmF0ZSBnZXRDYWNoZUluZGV4TWFwKHNjcm9sbGVySUQpIHtcblxuICAgICAgICByZXR1cm4gbmV3IE1hcCh0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRCkuaW5kZXhUb0l0ZW1JRE1hcClcblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q3JhZGxlSW5kZXhNYXAoc2Nyb2xsZXJJRCwgY3JhZGxlSW5kZXhMaXN0KSB7XG5cbiAgICAgICAgY29uc3QgY3JhZGxlTWFwID0gbmV3IE1hcCgpLFxuICAgICAgICAgICAgeyBpbmRleFRvSXRlbUlETWFwIH0gPSB0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRClcblxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNyYWRsZUluZGV4TGlzdCkge1xuXG4gICAgICAgICAgICBjcmFkbGVNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmFkbGVNYXBcblxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2FjaGVJdGVtTWFwKHNjcm9sbGVySUQpIHtcblxuICAgICAgICBjb25zdCBjYWNoZWxpc3QgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgeyBpdGVtU2V0IH0gPSB0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRClcbiAgICAgICAgY29uc3QgeyBpdGVtTWV0YWRhdGFNYXAgfSA9IHRoaXNcblxuICAgICAgICAvLyBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLml0ZW1NZXRhZGF0YU1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW1JRCBvZiBpdGVtU2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGl0ZW1NZXRhZGF0YU1hcC5nZXQoaXRlbUlEKVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIH0gPSBtZXRhZGF0YVxuXG4gICAgICAgICAgICBjYWNoZWxpc3Quc2V0KGl0ZW1JRCx7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlbGlzdFxuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1bIFNFUlZJQ0UgU1VQUE9SVCBdPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIG1vdmUgaW5kZXhlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gbW92ZSBpcyBjb2VyY2VkIGJ5IHNlcnZpY2VoYW5kbGVyIHRvIGJlIHdpdGhpbiBjdXJyZW50IGxpc3QgYm91bmRzXG4gICAgcHJpdmF0ZSBtb3ZlSW5kZXgoc2Nyb2xsZXJJRCwgdG9sb3dpbmRleCwgZnJvbWxvd2luZGV4LCBmcm9taGlnaGluZGV4ICkge1xuXG4gICAgICAgIGNvbnN0IGluZGV4VG9JdGVtSURNYXA6TWFwPG51bWJlciwgbnVtYmVyPiA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5pbmRleFRvSXRlbUlETWFwXG4gICAgICAgIGNvbnN0IHsgaXRlbU1ldGFkYXRhTWFwIH0gPSB0aGlzXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0gZGVmaW5lIHBhcmFtZXRlcnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgbW92ZWJsb2Nrc2l6ZSA9IGZyb21oaWdoaW5kZXggLSBmcm9tbG93aW5kZXggKyAxLFxuICAgICAgICAgICAgbW92ZWluY3JlbWVudCA9IHRvbG93aW5kZXggLSBmcm9tbG93aW5kZXgsXG4gICAgICAgICAgICB0b2hpZ2hpbmRleCA9IHRvbG93aW5kZXggKyAobW92ZWJsb2Nrc2l6ZSAtIDEpXG5cbiAgICAgICAgY29uc3QgbW92ZWRpcmVjdGlvbiA9IFxuICAgICAgICAgICAgKG1vdmVpbmNyZW1lbnQgPiAwKT8gLy8gbW92ZSBibG9jayB1cCBpbiBsaXN0XG4gICAgICAgICAgICAgICAgJ3VwJzogLy8gc2hpZnQgZG93biwgbWFrZSByb29tIGZvciBzaGlmdGluZ2luZGV4IGFib3ZlXG4gICAgICAgICAgICAgICAgJ2Rvd24nICAgLy8gc2hpZnQgdXAsIG1ha2Ugcm9vbSBmb3Igc2hpZnRpbmdpbmRleCBiZWxvd1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSBmaW5kIGJvdW5kcyBvZiBmcm9tIGFuZCB0byBibG9ja3MgaW4gY2FjaGUgLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IG9yZGVyZWRpbmRleGxpc3QgPSBBcnJheS5mcm9tKGluZGV4VG9JdGVtSURNYXAua2V5cygpKS5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgY29uc3QgcmV2ZXJzZW9yZGVyZWRpbmRleGxpc3QgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKCkucmV2ZXJzZSgpXG5cbiAgICAgICAgY29uc3QgdG9sb3dpbmRleHB0ciA9IG9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID49IHRvbG93aW5kZXgpLFxuICAgICAgICAgICAgZnJvbWxvd2luZGV4cHRyID0gb3JkZXJlZGluZGV4bGlzdC5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPj0gZnJvbWxvd2luZGV4KVxuXG4gICAgICAgIGxldCB0b2hpZ2hpbmRleHB0ciA9IHJldmVyc2VvcmRlcmVkaW5kZXhsaXN0LmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA8PSB0b2hpZ2hpbmRleCksXG4gICAgICAgICAgICBmcm9taGlnaGluZGV4cHRyID0gcmV2ZXJzZW9yZGVyZWRpbmRleGxpc3QuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlIDw9IGZyb21oaWdoaW5kZXgpXG5cbiAgICAgICAgLy8gZ2V0IHJlcXVpcmVkIGludmVyc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVsaXN0Y291bnQgPSBvcmRlcmVkaW5kZXhsaXN0Lmxlbmd0aFxuICAgICAgICAgICAgaWYgKHRvaGlnaGluZGV4cHRyICE9IC0xKSB0b2hpZ2hpbmRleHB0ciA9IChjYWNoZWxpc3Rjb3VudCAtMSkgLSB0b2hpZ2hpbmRleHB0clxuICAgICAgICAgICAgaWYgKGZyb21oaWdoaW5kZXhwdHIgIT0gLTEpIGZyb21oaWdoaW5kZXhwdHIgPSAoY2FjaGVsaXN0Y291bnQgLTEpIC0gZnJvbWhpZ2hpbmRleHB0clxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBjYXB0dXJlIGluZGV4IGRhdGEgdG8gbW92ZSAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IGxpc3R0b3Byb2Nlc3Nmb3Jtb3ZlXG4gICAgICAgIGlmICgoZnJvbWxvd2luZGV4cHRyID09IC0xKSAmJiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkpIHsgLy8gc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgbGlzdHRvcHJvY2Vzc2Zvcm1vdmUgPSBbXVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbWhpZ2hpbmRleHB0ciA9PSAtMSkgeyAvLyBzY29wZSBpcyBwYXJ0aWFsbHkgaW4gdmlld1xuXG4gICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9ybW92ZSA9IG9yZGVyZWRpbmRleGxpc3Quc2xpY2UoZnJvbWxvd2luZGV4cHRyKVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHNjb3BlIGlzIGVudGlyZWx5IGluIHZpZXdcblxuICAgICAgICAgICAgbGlzdHRvcHJvY2Vzc2Zvcm1vdmUgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21sb3dpbmRleHB0ciwgZnJvbWhpZ2hpbmRleHB0ciArIDEpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3N0b21vdmVNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgY2FwdHVyZW1vdmVpbmRleEZuID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIHByb2Nlc3N0b21vdmVNYXAuc2V0KGluZGV4LCBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleCkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3Jtb3ZlLmZvckVhY2goY2FwdHVyZW1vdmVpbmRleEZuKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gZ2V0IGxpc3Qgb2YgaW5kZXhlcyB0byBzaGlmdCBvdXQgb2YgdGhlIHdheSAtLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgXG4gICAgICAgIGxldCBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2VcbiAgICAgICAgaWYgKG1vdmVkaXJlY3Rpb24gPT0gJ2Rvd24nKSB7IC8vIGJsb2NrIGlzIG1vdmluZyBkb3duLCBzaGlmdCBpcyB1cDsgdG9pbmRleCA8IGZyb21pbmRleFxuXG4gICAgICAgICAgICBpZiAoKHRvbG93aW5kZXhwdHIgPT0gLTEpICYmIChmcm9tbG93aW5kZXhwdHIgPT0gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21sb3dpbmRleHB0ciA9PSAtMSkge1xuXG4gICAgICAgICAgICAgICAgbGlzdHRvcHJvY2Vzc2ZvcmRpc3BsYWNlID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2xvd2luZGV4cHRyKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgbGlzdHRvcHJvY2Vzc2ZvcmRpc3BsYWNlID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZSh0b2xvd2luZGV4cHRyLCBmcm9tbG93aW5kZXhwdHIpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBzaGlmdGRpcmVjdGlvbiA9PSAtMTsgYmxvY2sgaXMgbW92aW5nIHVwLCBzaGlmdCBpcyBkb3duOyBmcm9taW5kZXggPCB0b2luZGV4XG5cbiAgICAgICAgICAgIGlmICh0b2hpZ2hpbmRleHB0ciA9PSAtMSAmJiBmcm9taGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBbXVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvaGlnaGluZGV4cHRyID09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0dG9wcm9jZXNzZm9yZGlzcGxhY2UgPSBvcmRlcmVkaW5kZXhsaXN0LnNsaWNlKGZyb21oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgbGlzdHRvcHJvY2Vzc2ZvcmRpc3BsYWNlID0gb3JkZXJlZGluZGV4bGlzdC5zbGljZShmcm9taGlnaGluZGV4cHRyICsgMSwgdG9oaWdoaW5kZXhwdHIgKyAxKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW92ZWRpcmVjdGlvbiA9PSAnZG93bicpIGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZS5yZXZlcnNlKClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBtb3ZlIGluZGV4ZXMgb3V0IG9mIHRoZSB3YXkgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRkaXNwbGFjZUxpc3QgPSBbXVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NzZGlzcGxhY2VpbmRleEZuID0gKGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JRCA9IGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KVxuXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IFxuICAgICAgICAgICAgICAgIChtb3ZlZGlyZWN0aW9uID09ICd1cCcpP1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtIG1vdmVibG9ja3NpemU6XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICsgbW92ZWJsb2Nrc2l6ZVxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCxpdGVtSUQpXG4gICAgICAgICAgICBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkZGlzcGxhY2VMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZS5mb3JFYWNoKHByb2Nlc3NzZGlzcGxhY2VpbmRleEZuKVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLSByZXBsYWNlIHNoaWZ0ZWQgaW5kZXggc3BhY2Ugd2l0aCBtb3ZlZCBpbmRleGVzIC0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWRtb3ZlTGlzdCA9IFtdXG4gICAgICAgIGNvbnN0IHByb2Nlc3Ntb3ZlaW5kZXhGbiA9IChpdGVtSUQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgbW92ZWluY3JlbWVudCAvLyBzd2FwXG5cbiAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuc2V0KG5ld0luZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRCkuaW5kZXggPSBuZXdJbmRleFxuICAgICAgICAgICAgcHJvY2Vzc2VkbW92ZUxpc3QucHVzaChuZXdJbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc3RvbW92ZU1hcC5mb3JFYWNoKHByb2Nlc3Ntb3ZlaW5kZXhGbilcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLXJldHVybiBsaXN0IG9mIHByb2Nlc3NlZCBpbmRleGVzIHRvIGNhbGxlciAtLS0tLS0tLVxuICAgICAgICAvLyBmb3Igc3luY2hybml6YXRpb24gd2l0aCBjcmFkbGUgY2VsbEZyYW1lc1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEluZGV4ZXMgPSBbLi4ucHJvY2Vzc2VkZGlzcGxhY2VMaXN0LC4uLnByb2Nlc3NlZG1vdmVMaXN0XS5zb3J0KChhLGIpPT5hLWIpXG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEluZGV4ZXNcblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bIGluc2VydC9yZW1vdmUgaW5kZXhlcyBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBpbnNlcnQgb3IgcmVtb3ZlIGluZGV4ZXM6IG11Y2ggb2YgdGhpcyBkZWFscyB3aXRoIHRoZSBmYWN0IHRoYXQgdGhlIGNhY2hlIGlzIHNwYXJzZS5cbiAgICBwcml2YXRlIGluc2VydFJlbW92ZUluZGV4KHNjcm9sbGVySUQsIGluZGV4LCBoaWdocmFuZ2UsIGluY3JlbWVudCwgbGlzdHNpemUgKSB7IC8vIGluY3JlbWVudCBpcyArMSBvciAtMVxuXG4gICAgICAgIC8vIGNsYXJpdHlcbiAgICAgICAgY29uc3QgaXNJbnNlcnRpbmcgPSAoaW5jcmVtZW50ID09IDEpXG4gICAgICAgIGNvbnN0IGlzUmVtb3ZpbmcgPSAoaW5jcmVtZW50ID09IC0xKVxuXG4gICAgICAgIGNvbnN0IGVtcHR5cmV0dXJuID0gW251bGwsIG51bGwsIFtdLFtdLFtdLCBbXV0gLy8gbm8gYWN0aW9uIHJldHVybiB2YWx1ZVxuXG4gICAgICAgIC8vIGNhY2hlIHJlc291cmNlc1xuICAgICAgICBjb25zdCBpbmRleFRvSXRlbUlETWFwOk1hcDxudW1iZXIsIG51bWJlcj4gID0gdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLmluZGV4VG9JdGVtSURNYXBcbiAgICAgICAgY29uc3QgeyBpdGVtTWV0YWRhdGFNYXAgfSA9IHRoaXNcbiAgICAgICAgY29uc3Qgb3JkZXJlZENhY2hlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShpbmRleFRvSXRlbUlETWFwLmtleXMoKSkuc29ydCgoYSxiKT0+YS1iKSAvLyBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgY29uc3QgaXRlbVNldCA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5pdGVtU2V0XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBkZWZpbmUgY29udGlndW91cyByYW5nZSBwYXJhbWV0ZXJzOyBhZGQgc2VudGluZWxzIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGhpZ2ggcmFuZ2UgaXMgdGhlIGhpZ2hlc3QgaW5kZXggbnVtYmVyIG9mIHRoZSBpbnNlcnQvcmVtb3ZlIHJhbmdlXG4gICAgICAgIGxldCBoaWdocmFuZ2VpbmRleCA9IGhpZ2hyYW5nZVxuICAgICAgICBsZXQgbG93cmFuZ2VpbmRleCA9IGluZGV4IC8vIHNlbWFudGljcyAtIG5hbWUgc3ltbWV0cnlcblxuICAgICAgICBpZiAoaXNSZW1vdmluZykge1xuXG4gICAgICAgICAgICAvLyByZW1vdmFsIG11c3QgYmUgZW50aXJlbHkgd2l0aGluIHNjb3BlIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoaGlnaHJhbmdlaW5kZXggPiAobGlzdHNpemUgLSAxKSkge1xuXG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXggPSAobGlzdHNpemUgLSAxKVxuICAgICAgICAgICAgICAgIGlmIChoaWdocmFuZ2VpbmRleCA8IGxvd3JhbmdlaW5kZXgpIHJldHVybiBlbXB0eXJldHVyblxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gaXNJbnNlcnRpbmdcblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gY2FuIGF0IG1vc3Qgc3RhcnQgYXQgdGhlIG5leHQgbG93cmFuZ2VpbmRleCBhYm92ZSB0aGUgY3VycmVudCBsaXN0OyBha2EgYXBwZW5kXG4gICAgICAgICAgICBpZiAobG93cmFuZ2VpbmRleCA+IGxpc3RzaXplKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gbG93cmFuZ2VpbmRleCAtIGxpc3RzaXplXG4gICAgICAgICAgICAgICAgbG93cmFuZ2VpbmRleCAtPSBkaWZmXG4gICAgICAgICAgICAgICAgaGlnaHJhbmdlaW5kZXggLT0gZGlmZlxuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGVtcHR5cmV0dXJuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFuZ2Vjb3VudCBpcyB0aGUgYWJzb2x1dGUgbnVtYmVyIGluIHRoZSBpbnNlcnQvcmVtb3ZlIGNvbnRpZ3VvdXMgcmFuZ2VcbiAgICAgICAgY29uc3QgcmFuZ2Vjb3VudCA9IGhpZ2hyYW5nZWluZGV4IC0gbG93cmFuZ2VpbmRleCArIDFcblxuICAgICAgICAvLyByYW5nZSBpbmNyZW1lbnQgYWRkcyBzaWduIHRvIHJhbmdlY291bnQgdG8gaW5kaWNhdGUgYWRkL3JlbW92ZVxuICAgICAgICBjb25zdCByYW5nZWluY3JlbWVudCA9IHJhbmdlY291bnQgKiBpbmNyZW1lbnRcbiAgICAgICAgY29uc3Qgc3RhcnRDaGFuZ2VJbmRleCA9IFxuICAgICAgICAgICAgKGluY3JlbWVudCA9PSAxKT9cbiAgICAgICAgICAgICAgICBsb3dyYW5nZWluZGV4OlxuICAgICAgICAgICAgICAgIGhpZ2hyYW5nZWluZGV4ICsgKHJhbmdlaW5jcmVtZW50ICsgMSlcblxuICAgICAgICBsZXQgdG9TaGlmdFN0YXJ0SW5kZXggLy8gc3RhcnQgb2YgaW5kZXhlcyB0byBzaGlmdCB1cCAoaW5zZXJ0KSBvciBkb3duIChyZW1vdmUpXG4gICAgICAgIGlmIChpc0luc2VydGluZykge1xuICAgICAgICAgICAgdG9TaGlmdFN0YXJ0SW5kZXggPSBsb3dyYW5nZWluZGV4XG4gICAgICAgIH0gZWxzZSB7IC8vIGlzUmVtb3ZpbmdcbiAgICAgICAgICAgIHRvU2hpZnRTdGFydEluZGV4ID0gaGlnaHJhbmdlaW5kZXggKyAxXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tIGRlZmluZSByYW5nZSBib3VuZGFyaWVzIHdpdGhpbiBvcmRlcmVkIGNhY2hlIGluZGV4IGxpc3QgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gb2J0YWluIHN0YXJwdHIgZm9yIGluZGV4ZXMgdG8gc2hpZnRcbiAgICAgICAgY29uc3QgdG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSB0b1NoaWZ0U3RhcnRJbmRleClcblxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIG9idGFpbiBsb3dDYWNoZVJhbmdlUHRyLi4uXG4gICAgICAgIGNvbnN0IGxvd0NhY2hlUmFuZ2VQdHIgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSBsb3dyYW5nZWluZGV4KSAmJiAodmFsdWUgPD0gaGlnaHJhbmdlaW5kZXgpXG5cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBvYnRhaW4gaGlnaENhY2hlUmFuZ2VQdHIuLi5cbiAgICAgICAgY29uc3QgcmV2ZXJzZUNhY2hlSW5kZXhMaXN0ID0gQXJyYXkuZnJvbShvcmRlcmVkQ2FjaGVJbmRleExpc3QpLnJldmVyc2UoKVxuICAgICAgICBsZXQgaGlnaENhY2hlUmFuZ2VQdHIgPSByZXZlcnNlQ2FjaGVJbmRleExpc3QuZmluZEluZGV4KHZhbHVlPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIDw9IGhpZ2hyYW5nZWluZGV4KSAmJiAodmFsdWUgPj0gbG93cmFuZ2VpbmRleClcblxuICAgICAgICB9KVxuICAgICAgICAvLyB0YWtlIGludmVyc2Ugb2YgaGlnaENhY2hlUmFuZ2VQdHIgZm9yIG5vbi1yZXZlcnNlIHNvcnRcbiAgICAgICAgaWYgKGhpZ2hDYWNoZVJhbmdlUHRyICE9IC0xKSB7XG5cbiAgICAgICAgICAgIGhpZ2hDYWNoZVJhbmdlUHRyID0gKG9yZGVyZWRDYWNoZUluZGV4TGlzdC5sZW5ndGggLSAxKSAtIGhpZ2hDYWNoZVJhbmdlUHRyXG4gICAgICAgICAgICBpZiAoaGlnaENhY2hlUmFuZ2VQdHIgPCBsb3dDYWNoZVJhbmdlUHRyKSBoaWdoQ2FjaGVSYW5nZVB0ciA9IC0xXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGlzb2xhdGUgaW5kZXggcmFuZ2UgbGlzdCBhbmQgc2hpZnQgbGlzdCAtLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjYWNoZSBpbnB1dHNcbiAgICAgICAgbGV0IGNhY2hlUmFuZ2VJbmRleGVzTGlzdCwgLy8gZm9yIGVpdGhlciBpbnNlcnQgb3IgcmVtb3ZlXG4gICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCAvLyBmb3IgZWl0aGVyIGluc2VydCBvciByZW1vdmVcblxuICAgICAgICAvLyBnZXQgaW5wdXRzXG4gICAgICAgIGlmIChsb3dDYWNoZVJhbmdlUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgb3V0IG9mIHZpZXdcblxuICAgICAgICAgICAgY2FjaGVSYW5nZUluZGV4ZXNMaXN0ID0gW11cbiAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gW11cblxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2hDYWNoZVJhbmdlUHRyID09IC0xKSB7IC8vIGNvcmUgc2NvcGUgaXMgcGFydGlhbGx5IGluIHZpZXc7IGxvd0NhY2hlUmFuZ2VQdHIgaXMgYXZhaWxhYmxlXG5cbiAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBhYm92ZSBsb3dDYWNoZVJhbmdlUHRyIG11c3QgaGF2ZSBpbmRleGVzIHJlc2V0XG4gICAgICAgICAgICBjYWNoZVJhbmdlSW5kZXhlc0xpc3QgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3Quc2xpY2UobG93Q2FjaGVSYW5nZVB0cilcblxuICAgICAgICAgICAgaWYgKGlzSW5zZXJ0aW5nKSB7XG5cbiAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IGNhY2hlUmFuZ2VJbmRleGVzTGlzdC5zbGljZSgpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IFtdXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gb3JkZXJlZENhY2hlSW5kZXhMaXN0LnNsaWNlKHRvU2hpZnRTdGFydENhY2hlUHRyKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyByYW5nZSBmdWxseSBpbiB2aWV3XG5cbiAgICAgICAgICAgIGNhY2hlUmFuZ2VJbmRleGVzTGlzdCA9IG9yZGVyZWRDYWNoZUluZGV4TGlzdC5zbGljZShsb3dDYWNoZVJhbmdlUHRyLCBoaWdoQ2FjaGVSYW5nZVB0ciArIDEpXG5cbiAgICAgICAgICAgIGlmIChpc0luc2VydGluZykge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVUb1NoaWZ0SW5kZXhlc0xpc3QgPSBvcmRlcmVkQ2FjaGVJbmRleExpc3Quc2xpY2UodG9TaGlmdFN0YXJ0Q2FjaGVQdHIpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9TaGlmdFN0YXJ0Q2FjaGVQdHIgPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdCA9IFtdXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0ID0gb3JkZXJlZENhY2hlSW5kZXhMaXN0LnNsaWNlKHRvU2hpZnRTdGFydENhY2hlUHRyKVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tIGxpc3QgY2FjaGUgaW5kZXhlcyBhbmQgaXRlbXMgdG8gcmVwbGFjZSBvciByZW1vdmUgLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjYWNoZSBvdXRwdXRzXG4gICAgICAgIC8vIGZvciBpbnNlcnQsIHRoZSByYW5nZSBiZWluZyBpbnNlcnRlZDsgZm9yIHJlbW92ZSwgYW55IHRhaWwgY3JhZGxlIGl0ZW1zIGFiYW5kb25lZFxuICAgICAgICBsZXQgY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCA9IFtdLCAvLyBmb3IgaW5zZXJ0LCB0aGUgcmFuZ2UgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCA9IFtdLCAvLyBmb3IgcmVtb3ZlLCB0aGUgcmFuZ2UgYmVpbmcgcmVtb3ZlZFxuICAgICAgICAgICAgY2FjaGVJdGVtc1RvUmVtb3ZlTGlzdCA9IFtdIC8vIGZvciByZW1vdmUsIGRlcml2ZWQgZnJvbSB0aGUgcHJldmlvdXNcblxuICAgICAgICBpZiAoaXNJbnNlcnRpbmcpIHtcblxuICAgICAgICAgICAgY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCA9IGNhY2hlUmFuZ2VJbmRleGVzTGlzdFxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGlzUmVtb3ZpbmdcblxuICAgICAgICAgICAgY2FjaGVJbmRleGVzVG9SZW1vdmVMaXN0ID0gY2FjaGVSYW5nZUluZGV4ZXNMaXN0XG5cbiAgICAgICAgICAgIC8vIGdldCBjYWNoZUl0ZW1zVG9SZW1vdmVMaXN0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCkge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVJdGVtc1RvUmVtb3ZlTGlzdC5wdXNoKGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KSlcbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLSBjb25kdWN0IGNhY2hlIG9wZXJhdGlvbnM7IGNhcHR1cmUgbGlzdCBvZiBzaGlmdGVkIGluZGV4ZXMgLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIGluY3JlbWVudCBoaWdoZXIgZnJvbSB0b3Agb2YgbGlzdCB0byBwcmVzZXJ2ZSBsb3dlciB2YWx1ZXMgZm9yIHN1YnNlcXVlbnQgaW5jcmVtZW50XG4gICAgICAgIGlmIChpc0luc2VydGluZykgY2FjaGVUb1NoaWZ0SW5kZXhlc0xpc3QucmV2ZXJzZSgpIFxuXG4gICAgICAgIGNvbnN0IGNhY2hlSW5kZXhlc1NoaWZ0ZWRMaXN0ID0gW10gLy8gdHJhY2sgc2hpZnRlZCBpbmRleGVzXG4gICAgICAgIGNvbnN0IGNhY2hlSW5kZXhlc1RyYW5zZmVycmVkU2V0OlNldDxudW1iZXI+ID0gbmV3IFNldCgpIC8vIG9idGFpbiBsaXN0IG9mIG9ycGhhbmVkIGluZGV4ZXNcblxuICAgICAgICAvLyBmdW5jdGlvbiBtb2RpZnkgaW5kZXgtdG8taXRlbWlkIG1hcCwgYW5kIG1ldGFkYXRhIG1hcCwgZm9yIGluZGV4IHNoaWZ0c1xuICAgICAgICBjb25zdCBwcm9jZXNzSW5kZXhGbiA9IGluZGV4ID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbUlEID0gaW5kZXhUb0l0ZW1JRE1hcC5nZXQoaW5kZXgpXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgcmFuZ2VpbmNyZW1lbnRcblxuICAgICAgICAgICAgaWYgKGlzUmVtb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBjYWNoZUluZGV4ZXNUcmFuc2ZlcnJlZFNldC5hZGQoaW5kZXgpXG4gICAgICAgICAgICAgICAgY2FjaGVJbmRleGVzVHJhbnNmZXJyZWRTZXQuZGVsZXRlKG5ld0luZGV4KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLnNldChuZXdJbmRleCwgaXRlbUlEKVxuICAgICAgICAgICAgaXRlbU1ldGFkYXRhTWFwLmdldChpdGVtSUQpLmluZGV4ID0gbmV3SW5kZXhcbiAgICAgICAgICAgIGNhY2hlSW5kZXhlc1NoaWZ0ZWRMaXN0LnB1c2gobmV3SW5kZXgpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhbGsgdGhyb3VnaCBpdGVtcyB0byBzaGlmdFxuICAgICAgICBjYWNoZVRvU2hpZnRJbmRleGVzTGlzdC5mb3JFYWNoKHByb2Nlc3NJbmRleEZuKVxuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1haW5pbmcgaW5kZXhlcyBhbmQgaXRlbXMgbm93IGR1cGxpY2F0ZXM7IHRyYWNrIHBvcnRhbCBkYXRhIHRvIHJlbW92ZSBhZnRlciBjcmFkbGUgdXBkYXRlZFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IFtdIC8vIGhvbGQgcG9ydGFscyBmb3IgZGVsZXRpb24gdW50aWwgYWZ0ZXIgYWZ0ZXIgY3JhZGxlIHN5bmNoXG4gICAgICAgIGxldCBjYWNoZUluZGV4ZXNSZW1vdmVkTGlzdCA9IFtdXG5cbiAgICAgICAgaWYgKGlzSW5zZXJ0aW5nKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZGVsZXRlKGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gaXNSZW1vdmluZ1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW1JRCBvZiBjYWNoZUl0ZW1zVG9SZW1vdmVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRpdGlvbklEIH0gPSBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcbiAgICAgICAgICAgICAgICBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QucHVzaCh7aXRlbUlELCBwYXJ0aXRpb25JRH0pXG4gICAgICAgICAgICAgICAgaXRlbU1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICAgICAgaXRlbVNldC5kZWxldGUoaXRlbUlEKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFiYW5kb25lZCBpbmRleGVzIGZyb20gcmVtb3ZlIHByb2Nlc3NcbiAgICAgICAgICAgIGNvbnN0IG9ycGhhbmVkSW5kZXhlc1RyYW5zZmVycmVkTGlzdCA9IEFycmF5LmZyb20oY2FjaGVJbmRleGVzVHJhbnNmZXJyZWRTZXQpXG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygb3JwaGFuZWRJbmRleGVzVHJhbnNmZXJyZWRMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZUluZGV4ZXNSZW1vdmVkTGlzdCA9IGNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdC5jb25jYXQob3JwaGFuZWRJbmRleGVzVHJhbnNmZXJyZWRMaXN0KVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbnNlcnRpbmcpIGNhY2hlSW5kZXhlc1NoaWZ0ZWRMaXN0LnJldmVyc2UoKSAvLyByZXR1cm4gdG8gYXNjZW5kaW5nIG9yZGVyXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlcyBmb3IgY2FsbGVyIHRvIHNlbmQgdG8gY29udGVudGhhbmRsZXIgZm9yIGNyYWRsZSBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgcmV0dXJuIFtzdGFydENoYW5nZUluZGV4LCByYW5nZWluY3JlbWVudCwgY2FjaGVJbmRleGVzU2hpZnRlZExpc3QsIGNhY2hlSW5kZXhlc1JlbW92ZWRMaXN0LCBjYWNoZUluZGV4ZXNUb1JlcGxhY2VMaXN0LCBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3RdXG5cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgSU5ESVZJRFVBTCBQT1JUQUwgTUFOQUdFTUVOVCBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gdXNlZCBmb3Igc2l6ZSBjYWxjdWxhdGlvbiBpbiBwYXJlQ2FjaGVUb01heFxuICAgIC8vIHJlZ2lzdGVycyBpbmRleGVzIHdoZW4gcmVxdWVzdGVkIGJ1dCBiZWZvcmUgcmV0cmlldmVkIGFuZCBlbnRlcmVkIGludG8gY2FjaGVcbiAgICBwcml2YXRlIHJlZ2lzdGVyUGVuZGluZ1BvcnRhbChzY3JvbGxlcklELCBpbmRleCkge1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5yZXF1ZXN0ZWRTZXQuYWRkKGluZGV4KVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnJlZ2lzdGVyUGVuZGluZ1BvcnRhbChzY3JvbGxlcklELCBpbmRleCkge1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbGVyRGF0YU1hcCA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKVxuXG4gICAgICAgIGlmIChzY3JvbGxlckRhdGFNYXApIHsgLy8gb3RoZXJ3aXNlIHNjcm9sbGVyIGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgIHNjcm9sbGVyRGF0YU1hcC5yZXF1ZXN0ZWRTZXQuZGVsZXRlKGluZGV4KVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5ld0l0ZW1JRCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxJdGVtSUQrK1xuXG4gICAgfVxuXG4gICAgLy8gZ2V0IG5ldyBvciBleGlzdGluZyBpdGVtSUQgZm9yIGNvbnRlbnRmdW5jdGlvbnMuY3JlYXRlQ2VsbEZyYW1lXG4gICAgcHJpdmF0ZSBnZXROZXdPckV4aXN0aW5nSXRlbUlEKHNjcm9sbGVySUQsIGluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgeyBpbmRleFRvSXRlbUlETWFwIH0gPSB0aGlzLnNjcm9sbGVyRGF0YU1hcC5nZXQoc2Nyb2xsZXJJRClcblxuICAgICAgICBjb25zdCBpdGVtSUQgPSBcbiAgICAgICAgICAgIChpbmRleFRvSXRlbUlETWFwLmhhcyhpbmRleCkpP1xuICAgICAgICAgICAgICAgIGluZGV4VG9JdGVtSURNYXAuZ2V0KGluZGV4KTpcbiAgICAgICAgICAgICAgICAodGhpcy5nZXROZXdJdGVtSUQoKSlcblxuICAgICAgICByZXR1cm4gaXRlbUlEXG5cbiAgICB9XG5cbiAgICAgLy8gY3JlYXRlIG5ldyBwb3J0YWxcbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVBvcnRhbChzY3JvbGxlcklELCBjb21wb25lbnQsIGluZGV4LCBpdGVtSUQsIHNjcm9sbGVyUHJvcGVydGllcywgaXNQcmVsb2FkID0gZmFsc2UpIHtcblxuICAgICAgICB0aGlzLnVucmVnaXN0ZXJQZW5kaW5nUG9ydGFsKHNjcm9sbGVySUQsIGluZGV4KVxuXG4gICAgICAgIGNvbnN0IHNjcm9sbGVyRGF0YU1hcCA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKVxuXG4gICAgICAgIGlmICghc2Nyb2xsZXJEYXRhTWFwKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIGNvbnN0IHsgbGF5b3V0LCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIG9yaWVudGF0aW9uIH0gPSBcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKS5jcmFkbGVQYXJhbWV0ZXJzLmNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXNSZWYuY3VycmVudFxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlKGluZGV4LCBpdGVtSUQpXG5cbiAgICAgICAgY29uc3QgcGFydGl0aW9uSUQgPSBhd2FpdCB0aGlzLmZpbmRQYXJ0aXRpb25XaXRoUm9vbSgpXG5cbiAgICAgICAgY29uc3QgcG9ydGFsID0gXG4gICAgICAgICAgICA8ZGl2IGRhdGEtdHlwZSA9ICdwb3J0YWx3cmFwcGVyJyBrZXkgPSB7aXRlbUlEfSBkYXRhLWl0ZW1pZCA9IHtpdGVtSUR9IGRhdGEtaW5kZXggPSB7aW5kZXh9PlxuICAgICAgICAgICAgICAgIDxJblBvcnRhbCBrZXkgPSB7aXRlbUlEfSBub2RlID0ge3BvcnRhbE5vZGV9ID4geyBjb21wb25lbnQgfSA8L0luUG9ydGFsPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgdGhpcy5hZGRQYXJ0aXRpb25Qb3J0YWwocGFydGl0aW9uSUQsIGl0ZW1JRCwgcG9ydGFsKVxuXG4gICAgICAgIGNvbnN0IHBvcnRhbE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgcG9ydGFsTm9kZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbUlELFxuICAgICAgICAgICAgc2Nyb2xsZXJJRCxcbiAgICAgICAgICAgIHNjcm9sbGVyUHJvcGVydGllcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcnRpdGlvbklELFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pdGVtTWV0YWRhdGFNYXAuc2V0KGl0ZW1JRCwgcG9ydGFsTWV0YWRhdGEpXG4gICAgICAgIHNjcm9sbGVyRGF0YU1hcC5pdGVtU2V0LmFkZChpdGVtSUQpXG4gICAgICAgIHNjcm9sbGVyRGF0YU1hcC5pbmRleFRvSXRlbUlETWFwLnNldChpbmRleCwgaXRlbUlEKVxuXG4gICAgICAgIGlmICghaXNQcmVsb2FkKSB0aGlzLnJlbmRlclBvcnRhbExpc3RzKClcblxuICAgICAgICByZXR1cm4gcG9ydGFsTWV0YWRhdGFcblxuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHByZWxvYWRpbmcgbmV3IGl0ZW1cbiAgICBwcml2YXRlIGFzeW5jIHByZWxvYWRJdGVtKFxuICAgICAgICBzY3JvbGxlcklELFxuICAgICAgICBpbmRleCwgXG4gICAgICAgIGdldEl0ZW0sIFxuICAgICAgICBzY3JvbGxlclByb3BlcnRpZXNSZWYsIFxuICAgICAgICBpdGVtRXhjZXB0aW9uQ2FsbGJhY2ssXG4gICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0XG4gICAgKSB7XG5cbiAgICAgICAgY29uc3QgaXRlbUlEID0gdGhpcy5nZXROZXdJdGVtSUQoKVxuXG4gICAgICAgIGxldCByZXR1cm52YWx1ZSwgdXNlcmNvbnRlbnQsIGVycm9yXG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgdXNlcmNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtKGluZGV4LCBpdGVtSUQpXG4gICAgICAgICAgICBpZiAodXNlcmNvbnRlbnQgPT09IG51bGwpIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcblxuICAgICAgICB9IGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgcmV0dXJudmFsdWUgPSB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgZXJyb3IgPSBlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodXNlcmNvbnRlbnQgIT09IG51bGwpICYmICh1c2VyY29udGVudCAhPT0gdW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KHVzZXJjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybnZhbHVlID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgICAgICB1c2VyY29udGVudCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIFJlYWN0IGVsZW1lbnQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHVzZXJjb250ZW50ICE9PSBudWxsKSAmJiAodXNlcmNvbnRlbnQgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxlclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQcm9wZXJ0aWVzUmVmLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50LnByb3BzLmhhc093blByb3BlcnR5KCdzY3JvbGxlclByb3BlcnRpZXMnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQodXNlcmNvbnRlbnQsIHtzY3JvbGxlclByb3BlcnRpZXN9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdXNlcmNvbnRlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29uc3QgcG9ydGFsRGF0YSA9IFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUG9ydGFsKHNjcm9sbGVySUQsY29udGVudCwgaW5kZXgsIGl0ZW1JRCwgc2Nyb2xsZXJQcm9wZXJ0aWVzLCB0cnVlKSAvLyB0cnVlID0gaXNQcmVsb2FkXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHVzZXJjb250ZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAncHJlbG9hZCcsIGVycm9yKVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB1c2VyY29udGVudCA9PT0gbnVsbDsgbGFzdCBpdGVtIGluIGxpc3RcblxuICAgICAgICAgICAgICAgIGl0ZW1FeGNlcHRpb25DYWxsYmFjayAmJiBcbiAgICAgICAgICAgICAgICAgICAgaXRlbUV4Y2VwdGlvbkNhbGxiYWNrKGluZGV4LCBpdGVtSUQsIHJldHVybnZhbHVlLCAncHJlbG9hZCcsIG5ldyBFcnJvcignZW5kIG9mIGxpc3QnKSlcblxuICAgICAgICAgICAgICAgIG1heExpc3RzaXplSW50ZXJydXB0KGluZGV4KVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIGEgcG9ydGFsIGxpc3QgaXRlbVxuICAgIC8vIGFjY2VwdHMgYW4gYXJyYXkgb2YgaW5kZXhlc1xuICAgIHByaXZhdGUgZGVsZXRlUG9ydGFsQnlJbmRleChzY3JvbGxlcklELCBpbmRleCwgZGVsZXRlTGlzdENhbGxiYWNrKSB7XG5cbiAgICAgICAgY29uc3QgaW5kZXhBcnJheSA9IFxuICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KGluZGV4KSk/XG4gICAgICAgICAgICAgICAgW2luZGV4XTpcbiAgICAgICAgICAgICAgICBpbmRleFxuXG4gICAgICAgIGNvbnN0IHsgaW5kZXhUb0l0ZW1JRE1hcCwgaXRlbVNldCB9ID0gdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpXG5cbiAgICAgICAgY29uc3QgeyBpdGVtTWV0YWRhdGFNYXAgfSA9IHRoaXNcblxuICAgICAgICBjb25zdCB7IHJlbW92ZVBhcnRpdGlvblBvcnRhbCB9ID0gdGhpc1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZUxpc3QgPSBbXVxuXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhBcnJheSkge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtSUQgPSBpbmRleFRvSXRlbUlETWFwLmdldChpbmRleClcblxuICAgICAgICAgICAgaWYgKGl0ZW1JRCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZSAvLyBhc3luYyBtaXNtYXRjaFxuXG4gICAgICAgICAgICBkZWxldGVMaXN0LnB1c2goe2luZGV4LGl0ZW1JRH0pXG4gICAgICAgICAgICBjb25zdCB7IHBhcnRpdGlvbklEIH0gPSBpdGVtTWV0YWRhdGFNYXAuZ2V0KGl0ZW1JRClcblxuICAgICAgICAgICAgcmVtb3ZlUGFydGl0aW9uUG9ydGFsKHBhcnRpdGlvbklELGl0ZW1JRClcblxuICAgICAgICAgICAgaXRlbU1ldGFkYXRhTWFwLmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBpdGVtU2V0LmRlbGV0ZShpdGVtSUQpXG4gICAgICAgICAgICBpbmRleFRvSXRlbUlETWFwLmRlbGV0ZShpbmRleClcblxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlTGlzdENhbGxiYWNrICYmIGRlbGV0ZUxpc3RDYWxsYmFjayhkZWxldGVMaXN0KVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseVBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IChzY3JvbGxlcklEKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QgfSA9IHRoaXMuc2Nyb2xsZXJEYXRhTWFwLmdldChzY3JvbGxlcklEKVxuXG4gICAgICAgIGlmIChwb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QgJiYgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0KSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnRpdGlvblBvcnRhbChpdGVtLnBhcnRpdGlvbklELCBpdGVtLml0ZW1JRClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlckRhdGFNYXAuZ2V0KHNjcm9sbGVySUQpLnBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCA9IFtdICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWxMaXN0cygpXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcXVlcnkgZXhpc3RlbmNlIG9mIGEgcG9ydGFsIGxpc3QgaXRlbVxuICAgIHByaXZhdGUgaGFzUG9ydGFsKGl0ZW1JRCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1NZXRhZGF0YU1hcC5oYXMoaXRlbUlEKVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQb3J0YWxNZXRhZGF0YShpdGVtSUQpIHtcblxuICAgICAgICBpZiAodGhpcy5oYXNQb3J0YWwoaXRlbUlEKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbU1ldGFkYXRhTWFwLmdldChpdGVtSUQpXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVsgVXRpbGl0eSBmdW5jdGlvbiBdPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBnZXQgYSByZWFjdC1yZXZlcnNlLXBvcnRhbCBJblBvcnRhbCBjb21wb25lbnQsIHdpdGggaXRzIG1ldGFkYXRhXG4vLyB3aXRoIHVzZXIgY29udGVudCBhbmQgY29udGFpbmVyXG4vLyBzZWUgYWxzbyBzb21lIHN0eWxlcyBzZXQgaW4gQ2VsbEZyYW1lXG5cbmNvbnN0IGNyZWF0ZVBvcnRhbE5vZGUgPSAoaW5kZXgsIGl0ZW1JRCkgPT4ge1xuXG4gICAgY29uc3QgcG9ydGFsTm9kZSA9IGNyZWF0ZUh0bWxQb3J0YWxOb2RlKClcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcnRhbE5vZGUuZWxlbWVudFxuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICBjb250YWluZXIuZGF0YXNldC50eXBlID0gJ2NvbnRlbnRlbnZlbG9wZSdcbiAgICBjb250YWluZXIuZGF0YXNldC5pbmRleCA9IGluZGV4XG4gICAgY29udGFpbmVyLmRhdGFzZXQuY2FjaGVpdGVtaWQgPSBpdGVtSURcblxuICAgIHJldHVybiBwb3J0YWxOb2RlXG5cbn0gICAgIFxuIl0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImV4cG9ydHMiLCJPcCIsIk9iamVjdCIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJkZXNjIiwidmFsdWUiLCIkU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJfaW52b2tlIiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsIl9fYXdhaXQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsImRvbmUiLCJtZXRob2ROYW1lIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaW5mbyIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmFibGUiLCJpdGVyYXRvck1ldGhvZCIsImlzTmFOIiwibGVuZ3RoIiwiaSIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJpdGVyIiwia2V5cyIsInZhbCIsIm9iamVjdCIsInJldmVyc2UiLCJwb3AiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiX2kiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwiQXJyYXkiLCJpc0FycmF5IiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIkYiLCJzIiwibiIsImUiLCJfZTIiLCJmIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsInN0ZXAiLCJfZTMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwicmVzIiwiTnVtYmVyIiwicmVhY3RfMSIsIl9faW1wb3J0RGVmYXVsdCIsInJlcXVpcmUiLCJyZWFjdF9yZXZlcnNlX3BvcnRhbF8xIiwiQ2FjaGVQYXJ0aXRpb25fMSIsIkNhY2hlQVBJIiwiQ0FDSEVfUEFSVElUSU9OX1NJWkUiLCJfdGhpcyIsImdsb2JhbEl0ZW1JRCIsImdsb2JhbFBhcnRpdGlvbklEIiwiaXRlbU1ldGFkYXRhTWFwIiwiTWFwIiwic2Nyb2xsZXJEYXRhTWFwIiwicGFydGl0aW9uUHJvcHMiLCJwYXJ0aXRpb25NZXRhZGF0YU1hcCIsInBhcnRpdGlvbk1hcCIsInBhcnRpdGlvblJlbmRlckxpc3QiLCJwYXJ0aXRpb25SZXBvRm9yY2VVcGRhdGUiLCJwYXJ0aXRpb25Nb2RpZmllZFNldCIsIlNldCIsInBhcnRpdGlvblB0ciIsImdldEZhY2FkZSIsInNjcm9sbGVySUQiLCJmYWNhZGUiLCJpbmRleFRvSXRlbUlETWFwIiwiZ2V0SW5kZXhUb0l0ZW1JRE1hcCIsImdldCIsIml0ZW1TZXQiLCJnZXRJdGVtU2V0IiwicmVxdWVzdGVkU2V0IiwiZ2V0UmVxdWVzdGVkU2V0Iiwic2V0UGFydGl0aW9uUmVwb0ZvcmNlVXBkYXRlIiwiY3JhZGxlUGFyYW1ldGVycyIsInBhcm1zIiwic2V0Q3JhZGxlUGFyYW1ldGVycyIsInBvcnRhbFBhcnRpdGlvbkl0ZW1zRm9yRGVsZXRlTGlzdCIsImxpc3QiLCJzZXRQb3J0YWxQYXJ0aXRpb25JdGVtc0ZvckRlbGV0ZUxpc3QiLCJnZXRJbnN0YW5jZSIsInVuUmVnaXN0ZXJTY3JvbGxlciIsInJlbmRlclBhcnRpdGlvblJlcG8iLCJyZW5kZXJQb3J0YWxMaXN0cyIsImNsZWFyQ2FjaGUiLCJjaGFuZ2VDYWNoZUxpc3RzaXplIiwibmV3bGlzdHNpemUiLCJkZWxldGVMaXN0Q2FsbGJhY2siLCJjaGFuZ2VMaXN0c2l6ZUNhbGxiYWNrIiwibWF0Y2hDYWNoZVRvQ3JhZGxlIiwiY3JhZGxlSW5kZXhMaXN0IiwicGFyZUNhY2hlVG9NYXgiLCJjYWNoZU1heCIsImd1YXJkQWdhaW5zdFJ1bmF3YXlDYWNoaW5nIiwiY3JhZGxlTGlzdExlbmd0aCIsIk1BWF9DQUNIRV9PVkVSX1JVTiIsInByZWxvYWQiLCJmaW5hbENhbGxiYWNrIiwibnVsbEl0ZW1TZXRNYXhMaXN0c2l6ZSIsImdldENhY2hlSW5kZXhNYXAiLCJnZXRDcmFkbGVJbmRleE1hcCIsImdldENhY2hlSXRlbU1hcCIsIm1vdmVJbmRleCIsInRvbG93aW5kZXgiLCJmcm9tbG93aW5kZXgiLCJmcm9taGlnaGluZGV4IiwiaW5zZXJ0UmVtb3ZlSW5kZXgiLCJpbmRleCIsImhpZ2hyYW5nZSIsImluY3JlbWVudCIsImxpc3RzaXplIiwicmVnaXN0ZXJQZW5kaW5nUG9ydGFsIiwidW5yZWdpc3RlclBlbmRpbmdQb3J0YWwiLCJnZXROZXdJdGVtSUQiLCJnZXROZXdPckV4aXN0aW5nSXRlbUlEIiwiY3JlYXRlUG9ydGFsIiwiY29tcG9uZW50IiwiaXRlbUlEIiwic2Nyb2xsZXJQcm9wZXJ0aWVzIiwiaXNQcmVsb2FkIiwiYXJndW1lbnRzIiwiZGVsZXRlUG9ydGFsQnlJbmRleCIsImFwcGx5UG9ydGFsUGFydGl0aW9uSXRlbXNGb3JEZWxldGVMaXN0IiwiaGFzUG9ydGFsIiwiZ2V0UG9ydGFsTWV0YWRhdGEiLCJzaXplIiwiX2l0ZW1NZXRhZGF0YU1hcCRnZXQiLCJwYXJ0aXRpb25JRCIsInJlbW92ZVBhcnRpdGlvblBvcnRhbCIsImFkZFBhcnRpdGlvbiIsInNldCIsInBvcnRhbE1hcCIsIm1hcGNvdW50IiwicG9ydGFsUmVuZGVyTGlzdCIsIm1vZGlmaWVkIiwiZm9yY2VVcGRhdGUiLCJyZXNvbHZlZnVuYyIsImN1cnJlbnQiLCJwcm9taXNlIiwiY2FsbGJhY2siLCJjcmVhdGVFbGVtZW50IiwiYWRkUGFydGl0aW9uUG9ydGFsIiwicG9ydGFsIiwicGFydGl0aW9uTWV0YWRhdGEiLCJhZGQiLCJyZW5kZXJQYXJ0aXRpb24iLCJjbGVhciIsImRhdGFtYXAiLCJfaXRlbU1ldGFkYXRhTWFwJGdldDIiLCJwb3J0YWxJbmRleE1hcCIsIm1hcGtleXNMaXN0Iiwic29ydCIsImEiLCJiIiwiaGlnaGVzdGluZGV4IiwiYXQiLCJwYXJlbGlzdCIsImZpbHRlciIsIm1hcGtleXMiLCJkZWxrZXlzIiwiaW5jbHVkZXMiLCJtb2RlbExlbmd0aCIsIm1heCIsIk1hdGgiLCJtYXBrZXlzbGlzdCIsInJlcXVlc3RlZGtleXMiLCJjb25jYXQiLCJtYXBMZW5ndGgiLCJwYXJlY291bnQiLCJoZWFkaW5kZXgiLCJ0YWlsaW5kZXgiLCJoZWFkcG9zIiwiaW5kZXhPZiIsInRhaWxwb3MiLCJoZWFkcm9vbSIsInRhaWxyb29tIiwicGFyZXJvb20iLCJoZWFkcGFyZWNvdW50IiwiZmxvb3IiLCJ0YWlscGFyZWNvdW50IiwiaGVhZGxpc3QiLCJ0YWlsbGlzdCIsImRlbExpc3QiLCJfdGhpcyRzY3JvbGxlckRhdGFNYXAiLCJfdGhpcyRzY3JvbGxlckRhdGFNYXAyIiwic2Nyb2xsZXJQcm9wZXJ0aWVzUmVmIiwiX2NyYWRsZVBhcmFtZXRlcnMkaGFuIiwiaGFuZGxlcnNSZWYiLCJzdGF0ZUhhbmRsZXIiLCJzZXJ2aWNlSGFuZGxlciIsImNyYWRsZUluaGVyaXRlZFByb3BlcnRpZXMiLCJjcmFkbGVJbmhlcml0ZWRQcm9wZXJ0aWVzUmVmIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiY3JhZGxlSW50ZXJuYWxQcm9wZXJ0aWVzUmVmIiwiZ2V0SXRlbSIsInZpcnR1YWxMaXN0UHJvcGVydGllcyIsInByb21pc2VzIiwiY2FjaGVTaXplIiwibWluIiwicHJlbG9hZHNpemUiLCJicmVha2xvb3AiLCJtYXhMaXN0c2l6ZUludGVycnVwdCIsImlzTW91bnRlZFJlZiIsIl9zZXJ2aWNlSGFuZGxlciRjYWxsYiIsImNhbGxiYWNrcyIsInByZWxvYWRJbmRleENhbGxiYWNrIiwiaXRlbUV4Y2VwdGlvbkNhbGxiYWNrIiwiaGFzIiwicHJlbG9hZEl0ZW0iLCJhbGxTZXR0bGVkIiwiX3RoaXMkc2Nyb2xsZXJEYXRhTWFwMyIsIl9pdGVyYXRvciIsIl9zdGVwIiwiaXRlbSIsInJlZ2lzdGVyU2Nyb2xsZXIiLCJmaW5kUGFydGl0aW9uV2l0aFJvb20iLCJfY29udGV4dCIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJfc3RlcDIkdmFsdWUiLCJ0MCIsIl9jYWxsZWUiLCJjcmFkbGVNYXAiLCJfdGhpcyRzY3JvbGxlckRhdGFNYXA0IiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsImNhY2hlbGlzdCIsIl90aGlzJHNjcm9sbGVyRGF0YU1hcDUiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwibWV0YWRhdGEiLCJtb3ZlYmxvY2tzaXplIiwibW92ZWluY3JlbWVudCIsInRvaGlnaGluZGV4IiwibW92ZWRpcmVjdGlvbiIsIm9yZGVyZWRpbmRleGxpc3QiLCJyZXZlcnNlb3JkZXJlZGluZGV4bGlzdCIsInRvbG93aW5kZXhwdHIiLCJmaW5kSW5kZXgiLCJmcm9tbG93aW5kZXhwdHIiLCJ0b2hpZ2hpbmRleHB0ciIsImZyb21oaWdoaW5kZXhwdHIiLCJjYWNoZWxpc3Rjb3VudCIsImxpc3R0b3Byb2Nlc3Nmb3Jtb3ZlIiwicHJvY2Vzc3RvbW92ZU1hcCIsImNhcHR1cmVtb3ZlaW5kZXhGbiIsImxpc3R0b3Byb2Nlc3Nmb3JkaXNwbGFjZSIsInByb2Nlc3NlZGRpc3BsYWNlTGlzdCIsInByb2Nlc3NzZGlzcGxhY2VpbmRleEZuIiwibmV3SW5kZXgiLCJwcm9jZXNzZWRtb3ZlTGlzdCIsInByb2Nlc3Ntb3ZlaW5kZXhGbiIsInByb2Nlc3NlZEluZGV4ZXMiLCJpc0luc2VydGluZyIsImlzUmVtb3ZpbmciLCJlbXB0eXJldHVybiIsIm9yZGVyZWRDYWNoZUluZGV4TGlzdCIsImhpZ2hyYW5nZWluZGV4IiwibG93cmFuZ2VpbmRleCIsImRpZmYiLCJyYW5nZWNvdW50IiwicmFuZ2VpbmNyZW1lbnQiLCJzdGFydENoYW5nZUluZGV4IiwidG9TaGlmdFN0YXJ0SW5kZXgiLCJ0b1NoaWZ0U3RhcnRDYWNoZVB0ciIsImxvd0NhY2hlUmFuZ2VQdHIiLCJyZXZlcnNlQ2FjaGVJbmRleExpc3QiLCJoaWdoQ2FjaGVSYW5nZVB0ciIsImNhY2hlUmFuZ2VJbmRleGVzTGlzdCIsImNhY2hlVG9TaGlmdEluZGV4ZXNMaXN0IiwiY2FjaGVJbmRleGVzVG9SZXBsYWNlTGlzdCIsImNhY2hlSW5kZXhlc1RvUmVtb3ZlTGlzdCIsImNhY2hlSXRlbXNUb1JlbW92ZUxpc3QiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwiY2FjaGVJbmRleGVzU2hpZnRlZExpc3QiLCJjYWNoZUluZGV4ZXNUcmFuc2ZlcnJlZFNldCIsInByb2Nlc3NJbmRleEZuIiwiY2FjaGVJbmRleGVzUmVtb3ZlZExpc3QiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9pdGVtTWV0YWRhdGFNYXAkZ2V0MyIsIm9ycGhhbmVkSW5kZXhlc1RyYW5zZmVycmVkTGlzdCIsIl9pMiIsIl9vcnBoYW5lZEluZGV4ZXNUcmFucyIsIl90aGlzJHNjcm9sbGVyRGF0YU1hcDYiLCJfY29udGV4dDIiLCJfdGhpcyRzY3JvbGxlckRhdGFNYXA3IiwibGF5b3V0IiwiY2VsbEhlaWdodCIsImNlbGxXaWR0aCIsIm9yaWVudGF0aW9uIiwicG9ydGFsTm9kZSIsImNyZWF0ZVBvcnRhbE5vZGUiLCJJblBvcnRhbCIsIm5vZGUiLCJwb3J0YWxNZXRhZGF0YSIsIl9jYWxsZWUyIiwiX2NvbnRleHQzIiwidXNlcmNvbnRlbnQiLCJyZXR1cm52YWx1ZSIsImlzVmFsaWRFbGVtZW50IiwiY29udGVudCIsImNsb25lRWxlbWVudCIsIl9jYWxsZWUzIiwiaW5kZXhBcnJheSIsIl90aGlzJHNjcm9sbGVyRGF0YU1hcDgiLCJkZWxldGVMaXN0IiwiX2l0ZXJhdG9yOCIsIl9zdGVwOCIsIl9pdGVtTWV0YWRhdGFNYXAkZ2V0NCIsImNyZWF0ZUh0bWxQb3J0YWxOb2RlIiwiY29udGFpbmVyIiwiZWxlbWVudCIsInN0eWxlIiwib3ZlcmZsb3ciLCJkYXRhc2V0IiwiY2FjaGVpdGVtaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/portalcache/cacheAPI.tsx\n')},"./node_modules/react-reverse-portal/dist/web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InPortal: () => (/* binding */ InPortal),\n/* harmony export */   OutPortal: () => (/* binding */ OutPortal),\n/* harmony export */   createHtmlPortalNode: () => (/* binding */ createHtmlPortalNode),\n/* harmony export */   createSvgPortalNode: () => (/* binding */ createSvgPortalNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// Internally, the portalNode must be for either HTML or SVG elements\nvar ELEMENT_TYPE_HTML = \'html\';\nvar ELEMENT_TYPE_SVG = \'svg\';\n// ReactDOM can handle several different namespaces, but they\'re not exported publicly\n// https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/DOMNamespaces.js#L8-L10\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar validateElementType = function (domElement, elementType) {\n    if (elementType === ELEMENT_TYPE_HTML) {\n        return domElement instanceof HTMLElement;\n    }\n    if (elementType === ELEMENT_TYPE_SVG) {\n        return domElement instanceof SVGElement;\n    }\n    throw new Error("Unrecognized element type \\"" + elementType + "\\" for validateElementType.");\n};\n// This is the internal implementation: the public entry points set elementType to an appropriate value\nvar createPortalNode = function (elementType, options) {\n    var initialProps = {};\n    var parent;\n    var lastPlaceholder;\n    var element;\n    if (elementType === ELEMENT_TYPE_HTML) {\n        element = document.createElement(\'div\');\n    }\n    else if (elementType === ELEMENT_TYPE_SVG) {\n        element = document.createElementNS(SVG_NAMESPACE, \'g\');\n    }\n    else {\n        throw new Error("Invalid element type \\"" + elementType + "\\" for createPortalNode: must be \\"html\\" or \\"svg\\".");\n    }\n    if (options && typeof options === "object") {\n        for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            element.setAttribute(key, value);\n        }\n    }\n    var portalNode = {\n        element: element,\n        elementType: elementType,\n        setPortalProps: function (props) {\n            initialProps = props;\n        },\n        getInitialPortalProps: function () {\n            return initialProps;\n        },\n        mount: function (newParent, newPlaceholder) {\n            if (newPlaceholder === lastPlaceholder) {\n                // Already mounted - noop.\n                return;\n            }\n            portalNode.unmount();\n            // To support SVG and other non-html elements, the portalNode\'s elementType needs to match\n            // the elementType it\'s being rendered into\n            if (newParent !== parent) {\n                if (!validateElementType(newParent, elementType)) {\n                    throw new Error("Invalid element type for portal: \\"" + elementType + "\\" portalNodes must be used with " + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");\n                }\n            }\n            newParent.replaceChild(portalNode.element, newPlaceholder);\n            parent = newParent;\n            lastPlaceholder = newPlaceholder;\n        },\n        unmount: function (expectedPlaceholder) {\n            if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {\n                // Skip unmounts for placeholders that aren\'t currently mounted\n                // They will have been automatically unmounted already by a subsequent mount()\n                return;\n            }\n            if (parent && lastPlaceholder) {\n                parent.replaceChild(lastPlaceholder, portalNode.element);\n                parent = undefined;\n                lastPlaceholder = undefined;\n            }\n        }\n    };\n    return portalNode;\n};\nvar InPortal = /** @class */ (function (_super) {\n    __extends(InPortal, _super);\n    function InPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.addPropsChannel = function () {\n            Object.assign(_this.props.node, {\n                setPortalProps: function (props) {\n                    // Rerender the child node here if/when the out portal props change\n                    _this.setState({ nodeProps: props });\n                }\n            });\n        };\n        _this.state = {\n            nodeProps: _this.props.node.getInitialPortalProps(),\n        };\n        return _this;\n    }\n    InPortal.prototype.componentDidMount = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.componentDidUpdate = function () {\n        this.addPropsChannel();\n    };\n    InPortal.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, children = _a.children, node = _a.node;\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child) {\n            if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child))\n                return child;\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, _this.state.nodeProps);\n        }), node.element);\n    };\n    return InPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar OutPortal = /** @class */ (function (_super) {\n    __extends(OutPortal, _super);\n    function OutPortal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.placeholderNode = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        _this.passPropsThroughPortal();\n        return _this;\n    }\n    OutPortal.prototype.passPropsThroughPortal = function () {\n        var propsForTarget = Object.assign({}, this.props, { node: undefined });\n        this.props.node.setPortalProps(propsForTarget);\n    };\n    OutPortal.prototype.componentDidMount = function () {\n        var node = this.props.node;\n        this.currentPortalNode = node;\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentDidUpdate = function () {\n        // We re-mount on update, just in case we were unmounted (e.g. by\n        // a second OutPortal, which has now been removed)\n        var node = this.props.node;\n        // If we\'re switching portal nodes, we need to clean up the current one first.\n        if (this.currentPortalNode && node !== this.currentPortalNode) {\n            this.currentPortalNode.unmount(this.placeholderNode.current);\n            this.currentPortalNode.setPortalProps({});\n            this.currentPortalNode = node;\n        }\n        var placeholder = this.placeholderNode.current;\n        var parent = placeholder.parentNode;\n        node.mount(parent, placeholder);\n        this.passPropsThroughPortal();\n    };\n    OutPortal.prototype.componentWillUnmount = function () {\n        var node = this.props.node;\n        node.unmount(this.placeholderNode.current);\n        node.setPortalProps({});\n    };\n    OutPortal.prototype.render = function () {\n        // Render a placeholder to the DOM, so we can get a reference into\n        // our location in the DOM, and swap it out for the portaled node.\n        // A <div> placeholder works fine even for SVG.\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.placeholderNode });\n    };\n    return OutPortal;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\nvar createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);\nvar createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmV2ZXJzZS1wb3J0YWwvZGlzdC93ZWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQ087QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQXFCLENBQUMsK0NBQWtCO0FBQ3ZELGlCQUFpQixpREFBb0I7QUFDckM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLFVBQVUsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDMkU7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1pbmZpbml0ZS1ncmlkLXNjcm9sbGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJldmVyc2UtcG9ydGFsL2Rpc3Qvd2ViL2luZGV4LmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gSW50ZXJuYWxseSwgdGhlIHBvcnRhbE5vZGUgbXVzdCBiZSBmb3IgZWl0aGVyIEhUTUwgb3IgU1ZHIGVsZW1lbnRzXG52YXIgRUxFTUVOVF9UWVBFX0hUTUwgPSAnaHRtbCc7XG52YXIgRUxFTUVOVF9UWVBFX1NWRyA9ICdzdmcnO1xuLy8gUmVhY3RET00gY2FuIGhhbmRsZSBzZXZlcmFsIGRpZmZlcmVudCBuYW1lc3BhY2VzLCBidXQgdGhleSdyZSBub3QgZXhwb3J0ZWQgcHVibGljbHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I4N2FhYmRmZTFiNzQ2MWU3MzMxYWJiMzYwMWQ5ZTZiYjI3NTQ0YmMvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvRE9NTmFtZXNwYWNlcy5qcyNMOC1MMTBcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciB2YWxpZGF0ZUVsZW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRV9TVkcpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciB2YWxpZGF0ZUVsZW1lbnRUeXBlLlwiKTtcbn07XG4vLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbjogdGhlIHB1YmxpYyBlbnRyeSBwb2ludHMgc2V0IGVsZW1lbnRUeXBlIHRvIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG52YXIgY3JlYXRlUG9ydGFsTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSB7fTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBsYXN0UGxhY2Vob2xkZXI7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfSFRNTCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBFTEVNRU5UX1RZUEVfU1ZHKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgJ2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZWxlbWVudCB0eXBlIFxcXCJcIiArIGVsZW1lbnRUeXBlICsgXCJcXFwiIGZvciBjcmVhdGVQb3J0YWxOb2RlOiBtdXN0IGJlIFxcXCJodG1sXFxcIiBvciBcXFwic3ZnXFxcIi5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwb3J0YWxOb2RlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgIHNldFBvcnRhbFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcyA9IHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsUG9ydGFsUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAobmV3UGFyZW50LCBuZXdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG5ld1BsYWNlaG9sZGVyID09PSBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IG1vdW50ZWQgLSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRhbE5vZGUudW5tb3VudCgpO1xuICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCBTVkcgYW5kIG90aGVyIG5vbi1odG1sIGVsZW1lbnRzLCB0aGUgcG9ydGFsTm9kZSdzIGVsZW1lbnRUeXBlIG5lZWRzIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudFR5cGUgaXQncyBiZWluZyByZW5kZXJlZCBpbnRvXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlRWxlbWVudFR5cGUobmV3UGFyZW50LCBlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50IHR5cGUgZm9yIHBvcnRhbDogXFxcIlwiICsgZWxlbWVudFR5cGUgKyBcIlxcXCIgcG9ydGFsTm9kZXMgbXVzdCBiZSB1c2VkIHdpdGggXCIgKyBlbGVtZW50VHlwZSArIFwiIGVsZW1lbnRzLCBidXQgT3V0UG9ydGFsIGlzIHdpdGhpbiA8XCIgKyBuZXdQYXJlbnQudGFnTmFtZSArIFwiPi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyZW50LnJlcGxhY2VDaGlsZChwb3J0YWxOb2RlLmVsZW1lbnQsIG5ld1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGxhc3RQbGFjZWhvbGRlciA9IG5ld1BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoZXhwZWN0ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGxhY2Vob2xkZXIgJiYgZXhwZWN0ZWRQbGFjZWhvbGRlciAhPT0gbGFzdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50cyBmb3IgcGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBtb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IHVubW91bnRlZCBhbHJlYWR5IGJ5IGEgc3Vic2VxdWVudCBtb3VudCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBsYXN0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGxhc3RQbGFjZWhvbGRlciwgcG9ydGFsTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGFzdFBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZTtcbn07XG52YXIgSW5Qb3J0YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRQcm9wc0NoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLnByb3BzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBzZXRQb3J0YWxQcm9wczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcmVuZGVyIHRoZSBjaGlsZCBub2RlIGhlcmUgaWYvd2hlbiB0aGUgb3V0IHBvcnRhbCBwcm9wcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBub2RlUHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGVQcm9wczogX3RoaXMucHJvcHMubm9kZS5nZXRJbml0aWFsUG9ydGFsUHJvcHMoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkUHJvcHNDaGFubmVsKCk7XG4gICAgfTtcbiAgICBJblBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZFByb3BzQ2hhbm5lbCgpO1xuICAgIH07XG4gICAgSW5Qb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIF90aGlzLnN0YXRlLm5vZGVQcm9wcyk7XG4gICAgICAgIH0pLCBub2RlLmVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluUG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgT3V0UG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0UG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlck5vZGUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dFBvcnRhbC5wcm90b3R5cGUucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzRm9yVGFyZ2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBub2RlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMucHJvcHMubm9kZS5zZXRQb3J0YWxQcm9wcyhwcm9wc0ZvclRhcmdldCk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuICAgICAgICBub2RlLm1vdW50KHBhcmVudCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBhc3NQcm9wc1Rocm91Z2hQb3J0YWwoKTtcbiAgICB9O1xuICAgIE91dFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSByZS1tb3VudCBvbiB1cGRhdGUsIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIHVubW91bnRlZCAoZS5nLiBieVxuICAgICAgICAvLyBhIHNlY29uZCBPdXRQb3J0YWwsIHdoaWNoIGhhcyBub3cgYmVlbiByZW1vdmVkKVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcbiAgICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIHBvcnRhbCBub2Rlcywgd2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgY3VycmVudCBvbmUgZmlyc3QuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb3J0YWxOb2RlICYmIG5vZGUgIT09IHRoaXMuY3VycmVudFBvcnRhbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvcnRhbE5vZGUuc2V0UG9ydGFsUHJvcHMoe30pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9ydGFsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlck5vZGUuY3VycmVudDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICAgIG5vZGUubW91bnQocGFyZW50LCBwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGFzc1Byb3BzVGhyb3VnaFBvcnRhbCgpO1xuICAgIH07XG4gICAgT3V0UG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGU7XG4gICAgICAgIG5vZGUudW5tb3VudCh0aGlzLnBsYWNlaG9sZGVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgbm9kZS5zZXRQb3J0YWxQcm9wcyh7fSk7XG4gICAgfTtcbiAgICBPdXRQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGEgcGxhY2Vob2xkZXIgdG8gdGhlIERPTSwgc28gd2UgY2FuIGdldCBhIHJlZmVyZW5jZSBpbnRvXG4gICAgICAgIC8vIG91ciBsb2NhdGlvbiBpbiB0aGUgRE9NLCBhbmQgc3dhcCBpdCBvdXQgZm9yIHRoZSBwb3J0YWxlZCBub2RlLlxuICAgICAgICAvLyBBIDxkaXY+IHBsYWNlaG9sZGVyIHdvcmtzIGZpbmUgZXZlbiBmb3IgU1ZHLlxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5wbGFjZWhvbGRlck5vZGUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0UG9ydGFsO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7XG52YXIgY3JlYXRlSHRtbFBvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX0hUTUwpO1xudmFyIGNyZWF0ZVN2Z1BvcnRhbE5vZGUgPSBjcmVhdGVQb3J0YWxOb2RlLmJpbmQobnVsbCwgRUxFTUVOVF9UWVBFX1NWRyk7XG5leHBvcnQgeyBjcmVhdGVIdG1sUG9ydGFsTm9kZSwgY3JlYXRlU3ZnUG9ydGFsTm9kZSwgSW5Qb3J0YWwsIE91dFBvcnRhbCwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-reverse-portal/dist/web/index.js\n')},"./node_modules/requestidlecallback/index.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof __webpack_require__.g != undefined ?\n\t\t\t__webpack_require__.g :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVxdWVzdGlkbGVjYWxsYmFjay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQUssSUFBMEM7QUFDL0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckIsR0FBRyxLQUFLLEVBSU47QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsR0FBRyxxQkFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckYsSUFBSTs7QUFFSjtBQUNBLGtGQUFrRixrREFBa0Q7QUFDcEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QyxHQUFHLFdBQVc7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtaW5maW5pdGUtZ3JpZC1zY3JvbGxlci8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0aWRsZWNhbGxiYWNrL2luZGV4LmpzPzg3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmlkbGVDYWxsYmFja1NoaW0gPSBmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgc2NoZWR1bGVTdGFydCwgdGhyb3R0bGVEZWxheSwgbGF6eXRpbWVyLCBsYXp5cmFmO1xuXHR2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgP1xuXHRcdHdpbmRvdyA6XG5cdFx0dHlwZW9mIGdsb2JhbCAhPSB1bmRlZmluZWQgP1xuXHRcdFx0Z2xvYmFsIDpcblx0XHRcdHRoaXMgfHwge307XG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXHR2YXIgY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuXHR2YXIgdGFza3MgPSBbXTtcblx0dmFyIHJ1bkF0dGVtcHRzID0gMDtcblx0dmFyIGlzUnVubmluZyA9IGZhbHNlO1xuXHR2YXIgcmVtYWluaW5nVGltZSA9IDc7XG5cdHZhciBtaW5UaHJvdHRsZSA9IDM1O1xuXHR2YXIgdGhyb3R0bGUgPSAxMjU7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciB0YXNrU3RhcnQgPSAwO1xuXHR2YXIgdGFza2xlbmd0aCA9IDA7XG5cdHZhciBJZGxlRGVhZGxpbmUgPSB7XG5cdFx0Z2V0IGRpZFRpbWVvdXQoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdGltZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSAoRGF0ZS5ub3coKSAtIHRhc2tTdGFydCk7XG5cdFx0XHRyZXR1cm4gdGltZVJlbWFpbmluZyA8IDAgPyAwIDogdGltZVJlbWFpbmluZztcblx0XHR9LFxuXHR9O1xuXHR2YXIgc2V0SW5hY3RpdmUgPSBkZWJvdW5jZShmdW5jdGlvbigpe1xuXHRcdHJlbWFpbmluZ1RpbWUgPSAyMjtcblx0XHR0aHJvdHRsZSA9IDY2O1xuXHRcdG1pblRocm90dGxlID0gMDtcblx0fSk7XG5cblx0ZnVuY3Rpb24gZGVib3VuY2UoZm4pe1xuXHRcdHZhciBpZCwgdGltZXN0YW1wO1xuXHRcdHZhciB3YWl0ID0gOTk7XG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBsYXN0ID0gKERhdGUubm93KCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRpZiAobGFzdCA8IHdhaXQpIHtcblx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGNoZWNrLCB3YWl0IC0gbGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHRcdGZuKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0XHRpZighaWQpe1xuXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoY2hlY2ssIHdhaXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydFJ1bm5pbmcoKXtcblx0XHRpZihpc1J1bm5pbmcpe1xuXHRcdFx0aWYobGF6eXJhZil7XG5cdFx0XHRcdGNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShsYXp5cmFmKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhenl0aW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsYXp5dGltZXIpO1xuXHRcdFx0fVxuXHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25JbnB1dG9yTXV0YXRpb24oKXtcblx0XHRpZih0aHJvdHRsZSAhPSAxMjUpe1xuXHRcdFx0cmVtYWluaW5nVGltZSA9IDc7XG5cdFx0XHR0aHJvdHRsZSA9IDEyNTtcblx0XHRcdG1pblRocm90dGxlID0gMzU7XG5cblx0XHRcdGlmKGlzUnVubmluZykge1xuXHRcdFx0XHRhYm9ydFJ1bm5pbmcoKTtcblx0XHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldEluYWN0aXZlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzY2hlZHVsZUFmdGVyUmFmKCkge1xuXHRcdGxhenlyYWYgPSBudWxsO1xuXHRcdGxhenl0aW1lciA9IHNldFRpbWVvdXQocnVuVGFza3MsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVSYWYoKXtcblx0XHRsYXp5dGltZXIgPSBudWxsO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZUFmdGVyUmFmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlTGF6eSgpe1xuXG5cdFx0aWYoaXNSdW5uaW5nKXtyZXR1cm47fVxuXHRcdHRocm90dGxlRGVsYXkgPSB0aHJvdHRsZSAtIChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcblxuXHRcdHNjaGVkdWxlU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0aXNSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdGlmKG1pblRocm90dGxlICYmIHRocm90dGxlRGVsYXkgPCBtaW5UaHJvdHRsZSl7XG5cdFx0XHR0aHJvdHRsZURlbGF5ID0gbWluVGhyb3R0bGU7XG5cdFx0fVxuXG5cdFx0aWYodGhyb3R0bGVEZWxheSA+IDkpe1xuXHRcdFx0bGF6eXRpbWVyID0gc2V0VGltZW91dChzY2hlZHVsZVJhZiwgdGhyb3R0bGVEZWxheSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm90dGxlRGVsYXkgPSAwO1xuXHRcdFx0c2NoZWR1bGVSYWYoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UYXNrcygpe1xuXHRcdHZhciB0YXNrLCBpLCBsZW47XG5cdFx0dmFyIHRpbWVUaHJlc2hvbGQgPSByZW1haW5pbmdUaW1lID4gOSA/XG5cdFx0XHQ5IDpcblx0XHRcdDFcblx0XHQ7XG5cblx0XHR0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdGlzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0bGF6eXRpbWVyID0gbnVsbDtcblxuXHRcdGlmKHJ1bkF0dGVtcHRzID4gMiB8fCB0YXNrU3RhcnQgLSB0aHJvdHRsZURlbGF5IC0gNTAgPCBzY2hlZHVsZVN0YXJ0KXtcblx0XHRcdGZvcihpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuICYmIElkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lVGhyZXNob2xkOyBpKyspe1xuXHRcdFx0XHR0YXNrID0gdGFza3Muc2hpZnQoKTtcblx0XHRcdFx0dGFza2xlbmd0aCsrO1xuXHRcdFx0XHRpZih0YXNrKXtcblx0XHRcdFx0XHR0YXNrKElkbGVEZWFkbGluZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih0YXNrcy5sZW5ndGgpe1xuXHRcdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJ1bkF0dGVtcHRzID0gMDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrU2hpbSh0YXNrKXtcblx0XHRpbmRleCsrO1xuXHRcdHRhc2tzLnB1c2godGFzayk7XG5cdFx0c2NoZWR1bGVMYXp5KCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuY2VsSWRsZUNhbGxiYWNrU2hpbShpZCl7XG5cdFx0dmFyIGluZGV4ID0gaWQgLSAxIC0gdGFza2xlbmd0aDtcblx0XHRpZih0YXNrc1tpbmRleF0pe1xuXHRcdFx0dGFza3NbaW5kZXhdID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZighcm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICFyb290LmNhbmNlbElkbGVDYWxsYmFjayl7XG5cdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFja1NoaW07XG5cdFx0cm9vdC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2tTaGltO1xuXG5cdFx0aWYocm9vdC5kb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKXtcblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbklucHV0b3JNdXRhdGlvbik7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25JbnB1dG9yTXV0YXRpb24sIHRydWUpO1xuXHRcdFx0WydjbGljaycsICdrZXlwcmVzcycsICd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb25JbnB1dG9yTXV0YXRpb24sIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlfSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYocm9vdC5NdXRhdGlvbk9ic2VydmVyKXtcblx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uSW5wdXRvck11dGF0aW9uICkub2JzZXJ2ZSggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnl7XG5cdFx0XHRyb290LnJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24oKXt9LCB7dGltZW91dDogMH0pO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHQoZnVuY3Rpb24ocklDKXtcblx0XHRcdFx0dmFyIHRpbWVSZW1haW5pbmdQcm90bywgdGltZVJlbWFpbmluZztcblx0XHRcdFx0cm9vdC5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpe1xuXHRcdFx0XHRcdGlmKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQudGltZW91dCA9PSAnbnVtYmVyJyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcklDKGZuLCB0aW1lb3V0LnRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcklDKGZuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYocm9vdC5JZGxlQ2FsbGJhY2tEZWFkbGluZSAmJiAodGltZVJlbWFpbmluZ1Byb3RvID0gSWRsZUNhbGxiYWNrRGVhZGxpbmUucHJvdG90eXBlKSl7XG5cdFx0XHRcdFx0dGltZVJlbWFpbmluZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGltZVJlbWFpbmluZ1Byb3RvLCAndGltZVJlbWFpbmluZycpO1xuXHRcdFx0XHRcdGlmKCF0aW1lUmVtYWluaW5nIHx8ICF0aW1lUmVtYWluaW5nLmNvbmZpZ3VyYWJsZSB8fCAhdGltZVJlbWFpbmluZy5nZXQpe3JldHVybjt9XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVSZW1haW5pbmdQcm90bywgJ3RpbWVSZW1haW5pbmcnLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aW1lUmVtYWluaW5nLmdldC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHJvb3QucmVxdWVzdElkbGVDYWxsYmFjaylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlcXVlc3Q6IHJlcXVlc3RJZGxlQ2FsbGJhY2tTaGltLFxuXHRcdGNhbmNlbDogY2FuY2VsSWRsZUNhbGxiYWNrU2hpbSxcblx0fTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/requestidlecallback/index.js\n")},react:Q=>{"use strict";Q.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":Q=>{"use strict";Q.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(Q){var F=__webpack_module_cache__[Q];if(void 0!==F)return F.exports;var B=__webpack_module_cache__[Q]={exports:{}};return __webpack_modules__[Q].call(B.exports,B,B.exports,__webpack_require__),B.exports}__webpack_require__.n=Q=>{var F=Q&&Q.__esModule?()=>Q.default:()=>Q;return __webpack_require__.d(F,{a:F}),F},__webpack_require__.d=(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(Q){if("object"==typeof window)return window}}(),__webpack_require__.o=(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),__webpack_require__.r=Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/InfiniteGridScroller.tsx");return __webpack_exports__})()));